[
    {
        "title": "Minimize String Length",
        "question_content": "Given a 0-indexed string s, repeatedly perform the following operation any number of times:\n\n\tChoose an index i in the string, and let c be the character in position i. Delete the closest occurrence of c to the left of i (if any) and the closest occurrence of c to the right of i (if any).\n\nYour task is to minimize the length of s by performing the above operation any number of times.\nReturn an integer denoting the length of the minimized string.\n&nbsp;\nExample 1:\n\nInput: s = \"aaabc\"\nOutput: 3\nExplanation: In this example, s is \"aaabc\". We can start by selecting the character 'a' at index 1. We then remove the closest 'a' to the left of index 1, which is at index 0, and the closest 'a' to the right of index 1, which is at index 2. After this operation, the string becomes \"abc\". Any further operation we perform on the string will leave it unchanged. Therefore, the length of the minimized string is 3.\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: 3\nExplanation: For this we can start with character 'b' at index 1. There is no occurrence of 'b' to the left of index 1, but there is one to the right at index 2, so we delete the 'b' at index 2. The string becomes \"cbd\" and further operations will leave it unchanged. Hence, the minimized length is 3.&nbsp;\n\nExample 3:\n\nInput: s = \"dddaaa\"\nOutput: 2\nExplanation: For this, we can start with the character 'd' at index 1. The closest occurrence of a 'd' to its left is at index 0, and the closest occurrence of a 'd' to its right is at index 2. We delete both index 0 and 2, so the string becomes \"daaa\". In the new string, we can select the character 'a' at index 2. The closest occurrence of an 'a' to its left is at index 1, and the closest occurrence of an 'a' to its right is at index 3. We delete both of them, and the string becomes \"da\". We cannot minimize this further, so the minimized length is 2.\n\n&nbsp;\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 100\n\ts contains only lowercase English letters",
        "solutions": [
            {
                "id": 3616312,
                "title": "one-line-code-for-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set((s)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set((s)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595131,
                "title": "find-unique-character-very-simple-and-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution </b>\\nIt can be observed that the we can remove all the duplicate of a character except the last one. So basically we just need to find number of unique character we have in the string as the answer.\\n\\n# Code\\n```\\nint minimizedStringLength(string s) {\\n    unordered_set<char> st;\\n    for(auto c: s) st.insert(c);\\n    return st.size();\\n}\\n```\\n\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minimizedStringLength(string s) {\\n    unordered_set<char> st;\\n    for(auto c: s) st.insert(c);\\n    return st.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595387,
                "title": "one-line-solution-c-java-python",
                "content": "# Intuition\\nJust count the number of distinct characters.\\n\\n# Approach\\nJust count the number of distinct characters.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        return unordered_set<char>(s.begin(), s.end()).size();\\n    }\\n};\\n```\\n\\nJava\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n}\\n```\\n\\nPython\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        return unordered_set<char>(s.begin(), s.end()).size();\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594946,
                "title": "hashset",
                "content": "We can remove all occurances of `c` except the last one.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len({*s})\\n```\\n\\n**C++**\\n```cpp\\nint minimizedStringLength(string s) {\\n    return unordered_set(begin(s), end(s)).size();\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len({*s})\\n```\n```cpp\\nint minimizedStringLength(string s) {\\n    return unordered_set(begin(s), end(s)).size();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594961,
                "title": "java-easy-solution-6-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minimizedStringLength(String s) {\\n    var map = new boolean[26];\\n    var ans = 0;\\n    \\n    for (var c : s.toCharArray())\\n      map[c - \\'a\\'] = true;\\n\\n    for (var c : map) if (c) ans++;\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minimizedStringLength(String s) {\\n    var map = new boolean[26];\\n    var ans = 0;\\n    \\n    for (var c : s.toCharArray())\\n      map[c - \\'a\\'] = true;\\n\\n    for (var c : map) if (c) ans++;\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594910,
                "title": "use-new-set-2-lines",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = function(s) {\\n    const u = new Set(s)\\n    return u.size\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = function(s) {\\n    const u = new Set(s)\\n    return u.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596066,
                "title": "python-3-1-line-w-explanation-t-m-98-46",
                "content": "The problem can be reduced to this:\\n\\nIf a character occurs more than once in`s`, then we may remove at least one of those characters with each move. If exactly one of a character is present, then it may not be removed. Hence, the answer is the count of distinct\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(s))\\n```\\n[https://leetcode.com/problems/minimize-string-length/submissions/963522297/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1) in which *N* ~ count of distinct characters.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595507,
                "title": "java-c-python-hashset",
                "content": "# **Explanation**\\nFor all same character, at least one will be left.\\nSo we only need to know,\\nahow many different characters in the input `s`\\nWe can use a hash set to find this.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(26)`\\n<br>\\n\\n**Java**\\nUse `distinct`\\n```java\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimizedStringLength(string s) {\\n        return unordered_set(s.begin(), s.end()).size();\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimizedStringLength(String s) {\\n        return (int) s.chars().distinct().count();\\n    }\\n```\n```cpp\\n    int minimizedStringLength(string s) {\\n        return unordered_set(s.begin(), s.end()).size();\\n    }\\n```\n```py\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3625803,
                "title": "easy-solution-in-java-0ms-100-beats",
                "content": "# Approach\\nThe approach to solving the problem is as follows:\\n\\n1. A method named `minimizedStringLength` is defined, which takes a string parameter `s`.\\n2. Inside the method, an integer array `arr` of size 26 is created to store the count of each letter in the alphabet.\\n3. The method iterates through each character `c` in the string `s` using a for-each loop.\\n4. For each character, the count at the corresponding index in the `arr` array is incremented by 1. This step counts the occurrences of each letter in the string.\\n5. After counting the occurrences of each letter, a variable `count` is initialized to 0.\\n6. The method iterates through each element `n` in the `arr` array.\\n7. For each element, if it is not zero (indicating that the letter is present in the string), the `count` variable is incremented by 1.\\n8. Finally, the value of `count` is returned, which represents the number of distinct letters present in the string `s`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595845,
                "title": "count-disticnt-no-of-chars-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> v(26,0);\\n        int ans = 0;\\n        for(auto &i: s){\\n            if(!v[i-\\'a\\']){\\n                ans++;\\n                v[i-\\'a\\'] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> v(26,0);\\n        int ans = 0;\\n        for(auto &i: s){\\n            if(!v[i-\\'a\\']){\\n                ans++;\\n                v[i-\\'a\\'] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595137,
                "title": "c-very-easy-solution-using-map-stl",
                "content": "# Intuition\\nAt first glance, we can clearly see that we have to count all unique characters in given string.\\n\\n# Approach\\nThe code uses a map data structure, count, to keep track of the frequency of each character in the string. It iterates over the characters in the string using a for loop and updates the count for each character. After counting all the characters, the size of the map is returned, which represents the number of distinct characters in the string.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input string. As the code iterates over each character in the string once\\n\\n- Space complexity:\\nO(n), as the map will store n key-value pairs, where n is the length of the input string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        \\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        \\n        return count.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        \\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        \\n        return count.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959846,
                "title": "very-easy-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a hashset of type characters \\n- Iterate all the characters of the string and add those characters in the hashset\\n- Hashset do not allow duplicate elememts \\n- return the size of the hashset\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set=new HashSet();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set=new HashSet();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924430,
                "title": "4-lines-solution-java-hashset",
                "content": "# Intuition\\nThe problem is all about removing all duplicates.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo, use hashSet and return the size of the set.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(char c : s.toCharArray()){\\n            set.add(c);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(char c : s.toCharArray()){\\n            set.add(c);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786530,
                "title": "java-faster-then-100-1-liner",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Codes :\\n### **1st method : 100% faster**\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean map[] = new boolean[26];\\n        int ans = 0;\\n        for(char c : s.toCharArray()) \\n            map[c - \\'a\\'] = true;\\n        for(boolean b : map)\\n            if(b == true) ans ++;\\n        return ans;\\n    }\\n}\\n```\\n### **2nd method : 1 liner**\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int)s.chars().distinct().count();\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean map[] = new boolean[26];\\n        int ans = 0;\\n        for(char c : s.toCharArray()) \\n            map[c - \\'a\\'] = true;\\n        for(boolean b : map)\\n            if(b == true) ans ++;\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        return (int)s.chars().distinct().count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606038,
                "title": "c-java-count-number-of-unique-characters",
                "content": "Given the problem that asks us to select an index `i` within a string and then delete the nearest instances of that character to the left and right of `i`, we can infer that we should remove all duplicate occurrences of each character, leaving only one occurrence of each. Therefore, the problem can be simplified to determining the count of unique characters within the string.\\n\\nWe can solve this problem using a hashset, but this method might be too time-consuming. As an optimization, we can use a boolean array instead. The first time we encounter a character, we increment a count. This count, maintained throughout the iteration of the string, serves as the final solution.\\n\\nC++:\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        boolean[] visited = new boolean[26];\\n        for (char c : s.toCharArray()) {\\n            if (visited[c - \\'a\\']) continue;\\n            visited[c - \\'a\\'] = true;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598133,
                "title": "python-elegant-short-1-line-hash-set-size",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597498,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++) {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++) {\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597086,
                "title": "c-solution-stack-beginner-friendly-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        stack<char> stk;\\n        map<char, int> mp;\\n        for (int i=0;i<s.length(); i++) {\\n            if ((!stk.empty() && s[i] == stk.top()) or (!stk.empty() && mp.find(s[i]) != mp.end())) {\\n                // \\n            } else {\\n                stk.push(s[i]);\\n                mp.insert({s[i], i});\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        stack<char> stk;\\n        map<char, int> mp;\\n        for (int i=0;i<s.length(); i++) {\\n            if ((!stk.empty() && s[i] == stk.top()) or (!stk.empty() && mp.find(s[i]) != mp.end())) {\\n                // \\n            } else {\\n                stk.push(s[i]);\\n                mp.insert({s[i], i});\\n            }\\n        }\\n        return stk.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595303,
                "title": "o-n-easy-to-understand-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Check if the result contains the character or not. If the result contains\\n    the character then do not add it, else add that charcter to the resultant\\n    string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        String result = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            if(!result.contains(String.valueOf(s.charAt(i)))) {\\n                result += String.valueOf(s.charAt(i));\\n            }\\n        }\\n        return result.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        String result = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            if(!result.contains(String.valueOf(s.charAt(i)))) {\\n                result += String.valueOf(s.charAt(i));\\n            }\\n        }\\n        return result.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595248,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int len = s.length();\\n        int charIndex = 0;\\n        while(charIndex < 26) {\\n            int i=0;\\n            while(i < s.length() && s.charAt(i) != (char) (\\'a\\' + charIndex))\\n                i++;\\n            int end = i+1;\\n            int count = 0;\\n            while(end < s.length()) {\\n                if(s.charAt(end) == (char)(\\'a\\' + charIndex))\\n                    count++;\\n                if(count == 2) {\\n                    len -= 2;\\n                    count = 0;\\n                }\\n                end++;\\n            }\\n            if(count > 0)\\n                len -= 1;\\n            charIndex++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int len = s.length();\\n        int charIndex = 0;\\n        while(charIndex < 26) {\\n            int i=0;\\n            while(i < s.length() && s.charAt(i) != (char) (\\'a\\' + charIndex))\\n                i++;\\n            int end = i+1;\\n            int count = 0;\\n            while(end < s.length()) {\\n                if(s.charAt(end) == (char)(\\'a\\' + charIndex))\\n                    count++;\\n                if(count == 2) {\\n                    len -= 2;\\n                    count = 0;\\n                }\\n                end++;\\n            }\\n            if(count > 0)\\n                len -= 1;\\n            charIndex++;\\n        }\\n        \\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595149,
                "title": "just-2-lines-c-easiest-problem",
                "content": "CODE\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<int>set(s.begin(),s.end());\\n        return set.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<int>set(s.begin(),s.end());\\n        return set.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925129,
                "title": "easy-understanding-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] chars = s.toCharArray();\\n        int[] counts = new int[26];\\n        int result =0;\\n        for(char c: chars){\\n            counts[c-\\'a\\']++;\\n        }\\n        for(int i:counts){\\n            if(i>0){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] chars = s.toCharArray();\\n        int[] counts = new int[26];\\n        int result =0;\\n        for(char c: chars){\\n            counts[c-\\'a\\']++;\\n        }\\n        for(int i:counts){\\n            if(i>0){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908437,
                "title": "super-easy-python3-solution-beats-75",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = []\\n        for i in s:\\n            res.append(i)\\n        news=set(res)\\n        return len(news)\\n```\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(res))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = []\\n        for i in s:\\n            res.append(i)\\n        news=set(res)\\n        return len(news)\\n```\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \\n        return len(set(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838984,
                "title": "can-you-optimize-it-c-solution-beats-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string ans =\"\";\\n        sort(s.begin(),s.end());\\n        for(int i = 1 ; i<s.length();i++ ){\\n            if(s[i]!=s[i-1]){\\n                ans+=s[i];\\n            }\\n        }\\n        return ans.length()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string ans =\"\";\\n        sort(s.begin(),s.end());\\n        for(int i = 1 ; i<s.length();i++ ){\\n            if(s[i]!=s[i-1]){\\n                ans+=s[i];\\n            }\\n        }\\n        return ans.length()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704884,
                "title": "c-easy-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/2fe5698a-d0e5-4549-8638-57aecfff5a34_1688226708.6732652.png)\\n\\n# Intuition\\nJust return the number of different chars.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        return new HashSet<char>(s).Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        return new HashSet<char>(s).Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619491,
                "title": "python3-one-liner-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf at every character, we are allowed to remove its left and right occurrences then basically we can remove all its duplicate occurrences.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can just return the length of the set of given string as, the set object in python removes all duplicate occurrences of all the elements present in the iterative object passed to it. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the length of s\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612504,
                "title": "simple-c-code",
                "content": "# Code\\n\\n## Code 1 : Using Unordered Set\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set <char> us;\\n        for(auto &it:s)\\n            us.insert(it);\\n        return us.size();\\n    }\\n};\\n```\\n\\n## Code 2: Using Unordered Map\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map <char,bool> ump;\\n        for(auto &it:s)\\n            ump[it]=1;\\n        return ump.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set <char> us;\\n        for(auto &it:s)\\n            us.insert(it);\\n        return us.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map <char,bool> ump;\\n        for(auto &it:s)\\n            ump[it]=1;\\n        return ump.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597035,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596812,
                "title": "one-liner-solution-as-simple-as-it-can-get",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set st(s.begin(),s.end());\\n        return st.size();       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set st(s.begin(),s.end());\\n        return st.size();       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596319,
                "title": "minimize-string-length",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>hs = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            hs.add(c);\\n        }\\n        return hs.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>hs = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            hs.add(c);\\n        }\\n        return hs.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595430,
                "title": "c-python-java-easy-solution-w-intuition-code",
                "content": "# Intuition\\nIn this problem, you can prove that only one occurance of any character will remain by the end of all operation.\\nConsider the string s=\"abcdabacd\"\\n```html\\nindex  - 0 1 2 3 4 5 6 7 8 9\\nstring - a b c d a b a c d a\\n```\\nWe\\'ll consider the index to be unchanged after removal for simplicity of explanation.\\n\\nAt i=0, the \"a\" present at i=4 will be removed.\\nAt i=6, the \"a\" present at i=0 and i=9 will be removed.\\n\\nSimilarly, at each occurance of \"a\", at least 1 other \"a\" will be removed(if any exist). This way only one occurance of every character will remain. \\n\\n# Approach\\nSince we know that we just have to count the number of distinct character, the approach is as simple as using a hashset to get the number of distinct characters.\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> cset;\\n        for(char c: s)\\n            cset.insert(c);\\n        return cset.size();\\n    }\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```\\n```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for(int i=0; i<s.length(); i++)\\n            hs.add(s.charAt(i));\\n        return hs.size();\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> hs(26, false);\\n        for(char c: s)\\n            hs[c-\\'a\\'] = true;\\n        int res{0};\\n        for(bool c: hs)\\n            res += c;\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n\\n- Time complexity: $$O(n)$$\\nSince we\\'re traversing the entire string once.\\n\\n- Space complexity: $$O(n)$$ \\nBecause we are storing all the characters of `s` in the Hash Set. In this specific case, the constraint \"*`s` contains only lowercase English letters*\" makes it $$O(26)$$.\\n\\n>### Note\\n>- Upvote if you liked my solution\\n>- Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```html\\nindex  - 0 1 2 3 4 5 6 7 8 9\\nstring - a b c d a b a c d a\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> cset;\\n        for(char c: s)\\n            cset.insert(c);\\n        return cset.size();\\n    }\\n};\\n```\n```python []\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```\n```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> hs = new HashSet<>();\\n        for(int i=0; i<s.length(); i++)\\n            hs.add(s.charAt(i));\\n        return hs.size();\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<bool> hs(26, false);\\n        for(char c: s)\\n            hs[c-\\'a\\'] = true;\\n        int res{0};\\n        for(bool c: hs)\\n            res += c;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595420,
                "title": "return-len-set-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595322,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        unordered_map<char, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            char ch = s[i];\\n            mp[ch].push_back(i);\\n        }\\n        \\n        return mp.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        unordered_map<char, vector<int>> mp;\\n        for(int i = 0; i < s.size(); i++) {\\n            char ch = s[i];\\n            mp[ch].push_back(i);\\n        }\\n        \\n        return mp.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595317,
                "title": "python3-solution-one-linear",
                "content": "# Intuition\\nWe can delete any letters as much if its duplicate exist. So we need to count the number of all different characters in the string.\\n\\n# Approach\\nBy using Counter in python we can achieve the above. the len of the counter is the number of different characters in the string.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(26)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(Counter(s))\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(Counter(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595313,
                "title": "c-o-n-simple-solution",
                "content": "# Intuition\\nJust return the number of different chars.\\n\\n# Approach\\nAt first count number of each char:\\n```\\nprivate Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n```\\nThen return the number of different chars:\\n```\\nvar dic = CreateMinimizedStringLengt(s);\\nreturn dic.Count;\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is the length of s\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        var dic = CreateMinimizedStringLengt(s);\\n        return dic.Count;\\n    }\\n    private Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n    {\\n        var rs = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (!rs.ContainsKey(s[i]))\\n            {\\n                rs.Add(s[i], 1);\\n            }\\n            else\\n            {\\n                rs[s[i]]++;\\n            }\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nprivate Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n```\n```\\nvar dic = CreateMinimizedStringLengt(s);\\nreturn dic.Count;\\n```\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        var dic = CreateMinimizedStringLengt(s);\\n        return dic.Count;\\n    }\\n    private Dictionary<char, int> CreateMinimizedStringLengt(string s)\\n    {\\n        var rs = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (!rs.ContainsKey(s[i]))\\n            {\\n                rs.Add(s[i], 1);\\n            }\\n            else\\n            {\\n                rs[s[i]]++;\\n            }\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595246,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto it:s) st.insert(it);\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto it:s) st.insert(it);\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595098,
                "title": "easy-java-6-line-hashset",
                "content": "```\\nclass Solution {\\n   public static int minimizedStringLength(String s) {\\n      char str[]=s.toCharArray();\\n      HashSet<Character> hs=new HashSet<>();\\n      for(int i=0;i<s.length();i++){\\n        hs.add(s.charAt(i));\\n      }\\n      return hs.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public static int minimizedStringLength(String s) {\\n      char str[]=s.toCharArray();\\n      HashSet<Character> hs=new HashSet<>();\\n      for(int i=0;i<s.length();i++){\\n        hs.add(s.charAt(i));\\n      }\\n      return hs.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595088,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n    We need to count unique char in the string\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m) \\n    m = number of unique char, max value is 26\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = (s) => {\\n    const uniqueChars = new Set([...s]);\\n    return uniqueChars.size;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nconst minimizedStringLength = (s) => {\\n    const uniqueChars = new Set([...s]);\\n    return uniqueChars.size;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595082,
                "title": "python3-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a hashmap to store each character in the string. If the character is already inside the hashmap, skip it or just increment its count by 1.\\nWe then can return the length of the hashmap which will only include distinct characters.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), we visit each character inside s only once. n is the length of s.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) Worst case, every character is distinct and we have to store all of them inside the hashmap.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Use a hashmap. If character already inside map, don\\'t add. Then return length of hashmap\\n        duplicate = {}\\n\\n        if len(s) == 1:\\n            return 1\\n        for c in s:\\n            if c not in duplicate:\\n                duplicate[c] = 1\\n            duplicate[c] += 1\\n        \\n        return len(duplicate)\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Use a hashmap. If character already inside map, don\\'t add. Then return length of hashmap\\n        duplicate = {}\\n\\n        if len(s) == 1:\\n            return 1\\n        for c in s:\\n            if c not in duplicate:\\n                duplicate[c] = 1\\n            duplicate[c] += 1\\n        \\n        return len(duplicate)\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595065,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a map to count the occurrence of each character in the string. By iterating over the map and incrementing a counter variable, it effectively counts the number of unique characters in the string. The final count represents the minimum length of the string after removing duplicate characters.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a map<int,int> called m to store the count of each character in the input string s.\\n\\nThe for loop iterates through each character it in the string s and increments its count in the map m.\\n\\nAfter counting all the characters, the variable ans is initialized to 0.\\n\\nThe second for loop iterates through each key-value pair it in the map m.\\n\\nIn each iteration, the variable ans is incremented by 1, effectively counting the number of unique characters in the string.\\n\\nFinally, the value of ans is returned as the minimum length of the string after removing duplicates.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the input string s. This is because the code iterates over each character in the string to count their occurrences and then iterates over the map to count the number of unique characters. Both iterations have a linear time complexity with respect to the length of the string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the length of the input string s. This is because the map m stores the count of each character, which can be at most the length of the string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n     \\n    map<int,int> m; // Create a map to store character counts\\n    for(auto it:s) m[it]++; // Count the occurrence of each character in the input string\\n    int ans=0; // Initialize a variable to store the count of unique characters\\n    for(auto it:m) {\\n        ans++; // Increment the count for each unique character in the map\\n    }\\n    return ans; // Return the count of unique characters\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n     \\n    map<int,int> m; // Create a map to store character counts\\n    for(auto it:s) m[it]++; // Count the occurrence of each character in the input string\\n    int ans=0; // Initialize a variable to store the count of unique characters\\n    for(auto it:m) {\\n        ans++; // Increment the count for each unique character in the map\\n    }\\n    return ans; // Return the count of unique characters\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595056,
                "title": "groupby",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) \\n    {\\n        return s.Select(x=>x).GroupBy(x=>x).Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) \\n    {\\n        return s.Select(x=>x).GroupBy(x=>x).Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595039,
                "title": "c-easy-solution-hashmap",
                "content": "The given code is a C++ solution for the problem of finding the length of the minimized string after performing a specific operation on a given string.\\n\\nA loop is used to iterate over each character in the string s. For each character, it is inserted into the mp unordered map with a value of true. This effectively removes any duplicate characters from the map since keys in an unordered map are unique.\\n```\\n#include<unordered_map>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n         int n = s.size();\\n        unordered_map<char, bool> mp;\\n\\n        for (int i = 0; i < n; i++) {\\n            mp[s[i]] = true;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<unordered_map>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n         int n = s.size();\\n        unordered_map<char, bool> mp;\\n\\n        for (int i = 0; i < n; i++) {\\n            mp[s[i]] = true;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3595036,
                "title": "stack-and-dict-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s):\\n        cnt = defaultdict(int)\\n        for i in s:\\n            cnt[i] += 1\\n        cnt = dict(sorted(cnt.items(), key=lambda x:x[1], reverse=True))\\n        st = []\\n        for i in s:\\n            #only append if cnt is 1. else decrease cnt \\n            if cnt[i] == 1: st.append(i)\\n            else: cnt[i] -= 1\\n        return len(st)\\n\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s):\\n        cnt = defaultdict(int)\\n        for i in s:\\n            cnt[i] += 1\\n        cnt = dict(sorted(cnt.items(), key=lambda x:x[1], reverse=True))\\n        st = []\\n        for i in s:\\n            #only append if cnt is 1. else decrease cnt \\n            if cnt[i] == 1: st.append(i)\\n            else: cnt[i] -= 1\\n        return len(st)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595029,
                "title": "python3-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595022,
                "title": "3-line-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> st;\\n        for(auto ch:s)\\n            st.insert(ch);\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> st;\\n        for(auto ch:s)\\n            st.insert(ch);\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594991,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(string s) \\n    {\\n        set<char> st;\\n        for(auto ch: s) st.insert(ch);\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(string s) \\n    {\\n        set<char> st;\\n        for(auto ch: s) st.insert(ch);\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594974,
                "title": "short-simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<String> set = new HashSet();\\n        for(int i=0; i<s.length(); i++) set.add(s.charAt(i)+\"\");\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<String> set = new HashSet();\\n        for(int i=0; i<s.length(); i++) set.add(s.charAt(i)+\"\");\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091256,
                "title": "simple-with-unit-tests",
                "content": "## Follow Vaclav Kosar for more software and machine learning at https://vaclavkosar.com/\\n\\n\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \"\"\"\\n        Given a string `s`.\\n        Operation: select position `i` with character `c`, delete closest occurent of `c` to the left if any and right if any.\\n        Repeat Operation any number of times to minimize length of string `s`.\\n        Return length of the minimized string.\\n\\n        The operation above, allows us to deduplicate characters in the string.\\n        While removing the middle duplicates lead to faster results, because we can remove the characters in pairs.\\n\\n        >>> Solution().minimizedStringLength(\"aikadua\")\\n        5\\n\\n        # Explanation: I would select the middle \"a\" to remove. len(\"ikadu\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"aaabc\")\\n        3\\n\\n        # len(\"abc\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"cbbd\")\\n        3\\n\\n\\n        >>> Solution().minimizedStringLength(\"dddaaa\")\\n        2\\n\\n        # len(\"abc\")\\n\\n\\n        Another opportunity is ability to find the duplicate characters quickly.\\n        Perhaps one option would be to index them with for example dictionary.\\n\\n        Let me index the string into dictionary by character.\\n        Then deduplicate within that index.\\n        Then return remaining length.\\n\\n        Now to save time, I can just use set to get the right answer already and get the same result.\\n\\n        \"\"\"\\n\\n        # char_index = defaultdict(list)\\n        # for i, c in enumerate(s):\\n        #    char_index[c].append(i)\\n        # for c in char_index:\\n        #   indexes = char_index[c]\\n        #   indexes.pop(0); indexes.pop(-1)\\n        #\\n        # ...\\n\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        \"\"\"\\n        Given a string `s`.\\n        Operation: select position `i` with character `c`, delete closest occurent of `c` to the left if any and right if any.\\n        Repeat Operation any number of times to minimize length of string `s`.\\n        Return length of the minimized string.\\n\\n        The operation above, allows us to deduplicate characters in the string.\\n        While removing the middle duplicates lead to faster results, because we can remove the characters in pairs.\\n\\n        >>> Solution().minimizedStringLength(\"aikadua\")\\n        5\\n\\n        # Explanation: I would select the middle \"a\" to remove. len(\"ikadu\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"aaabc\")\\n        3\\n\\n        # len(\"abc\")\\n\\n\\n        >>> Solution().minimizedStringLength(\"cbbd\")\\n        3\\n\\n\\n        >>> Solution().minimizedStringLength(\"dddaaa\")\\n        2\\n\\n        # len(\"abc\")\\n\\n\\n        Another opportunity is ability to find the duplicate characters quickly.\\n        Perhaps one option would be to index them with for example dictionary.\\n\\n        Let me index the string into dictionary by character.\\n        Then deduplicate within that index.\\n        Then return remaining length.\\n\\n        Now to save time, I can just use set to get the right answer already and get the same result.\\n\\n        \"\"\"\\n\\n        # char_index = defaultdict(list)\\n        # for i, c in enumerate(s):\\n        #    char_index[c].append(i)\\n        # for c in char_index:\\n        #   indexes = char_index[c]\\n        #   indexes.pop(0); indexes.pop(-1)\\n        #\\n        # ...\\n\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085382,
                "title": "minimize-string-length-js-as-short-as-possible",
                "content": "```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s).size\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s).size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082545,
                "title": "python-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        dic = {}\\n        for i in s:\\n            if i in dic:\\n                dic[i] += 1\\n            else:\\n                dic[i] = 1\\n        count = 0\\n        for i in dic:\\n            count += 1\\n        return count \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        dic = {}\\n        for i in s:\\n            if i in dic:\\n                dic[i] += 1\\n            else:\\n                dic[i] = 1\\n        count = 0\\n        for i in dic:\\n            count += 1\\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081844,
                "title": "best-solution-using-hash-map-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map <char, int> mp;\\n        for(auto i : s) {\\n            mp[i]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map <char, int> mp;\\n        for(auto i : s) {\\n            mp[i]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079835,
                "title": "simple-hashtable-as-boolean-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] lowers = new boolean[\\'z\\' - \\'a\\' + 1];\\n        int size = 0;\\n\\n        for(int i = 0; i < s.length(); i ++) {\\n            char ch = s.charAt(i);\\n\\n            if(!lowers[ch - \\'a\\']) {\\n                size ++;\\n                lowers[ch - \\'a\\'] = true;\\n            }\\n        }\\n\\n\\n        return size;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] lowers = new boolean[\\'z\\' - \\'a\\' + 1];\\n        int size = 0;\\n\\n        for(int i = 0; i < s.length(); i ++) {\\n            char ch = s.charAt(i);\\n\\n            if(!lowers[ch - \\'a\\']) {\\n                size ++;\\n                lowers[ch - \\'a\\'] = true;\\n            }\\n        }\\n\\n\\n        return size;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077975,
                "title": "python-one-line-solution-easy-solution",
                "content": "# Intuition\\nuse set: it store only non repeted values and then return the length\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076864,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[27];\\n        for (char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        for (int i : arr) {\\n            if (i > 0) {\\n                arr[26]++;\\n            }\\n        }\\n        return --arr[26];        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[27];\\n        for (char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        for (int i : arr) {\\n            if (i > 0) {\\n                arr[26]++;\\n            }\\n        }\\n        return --arr[26];        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073422,
                "title": "c-straightforward-approach-with-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            for (int j = i + 1; j < s.Length;)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                    s = s.Remove(j, 1);\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n\\n        return s.Length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            for (int j = i + 1; j < s.Length;)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                    s = s.Remove(j, 1);\\n                }\\n                else\\n                {\\n                    j++;\\n                }\\n            }\\n        }\\n\\n        return s.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072370,
                "title": "return-size-of-hashmap",
                "content": "# Intuition\\nthere will be only 1 key for repeated chars, so return len of keys.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashMap<Character,Integer> mapple = new HashMap<>();\\n        for (int i = 0; i <s.length(); i++) {\\n            mapple.put(s.charAt(i),1);\\n        }\\n        return mapple.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashMap<Character,Integer> mapple = new HashMap<>();\\n        for (int i = 0; i <s.length(); i++) {\\n            mapple.put(s.charAt(i),1);\\n        }\\n        return mapple.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069635,
                "title": "simple-c-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nusign map STL\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> count;\\n        for(int i = 0; i < s.size(); i++){\\n            count[s[i]]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069478,
                "title": "2716-minimize-string-length-easy-simple-solutions",
                "content": "# Code\\n```Python []\\n\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        # Using built-in function: `return len(set(s))`\\n        res = \"\"\\n        for i in s:\\n            if i not in res:\\n                res += i\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python []\\n\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        # Using built-in function: `return len(set(s))`\\n        res = \"\"\\n        for i in s:\\n            if i not in res:\\n                res += i\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068678,
                "title": "4-line-code",
                "content": "# Intuition\\nuse a HashSet to prevent the entry of duplicates and return the size of the HashSet\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> len=new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n            len.add(s.charAt(i));\\n        return len.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> len=new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n            len.add(s.charAt(i));\\n        return len.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068238,
                "title": "simple-and-easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean visit[] = new boolean[26];\\n        int ans =0;\\n        for(char c:s.toCharArray()){\\n            if(!visit[c-\\'a\\']){\\n                ans++;\\n                visit[c-\\'a\\'] =true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean visit[] = new boolean[26];\\n        int ans =0;\\n        for(char c:s.toCharArray()){\\n            if(!visit[c-\\'a\\']){\\n                ans++;\\n                visit[c-\\'a\\'] =true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066711,
                "title": "using-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(s) {\\n    var obj={};\\n    for(var i=0;i<s.length;i++)\\n    {\\n        if(obj[s[i]]==undefined)\\n        {\\n           obj[s[i]]=1;\\n        }\\n        else\\n        {\\n            obj[s[i]]++;\\n        }\\n    }\\n    var ky=Object.keys(obj);\\n    return ky.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(s) {\\n    var obj={};\\n    for(var i=0;i<s.length;i++)\\n    {\\n        if(obj[s[i]]==undefined)\\n        {\\n           obj[s[i]]=1;\\n        }\\n        else\\n        {\\n            obj[s[i]]++;\\n        }\\n    }\\n    var ky=Object.keys(obj);\\n    return ky.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062189,
                "title": "one-line-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051607,
                "title": "beats-100-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n        int count = 0;\\n       //To store repeated character at one place\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n       //To count same char only once \\n          for(int i=0;i<26;i++){\\n              if(arr[i] > 0)\\n              count++;\\n          }\\n          return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n        int count = 0;\\n       //To store repeated character at one place\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            arr[ch-\\'a\\']++;\\n        }\\n       //To count same char only once \\n          for(int i=0;i<26;i++){\\n              if(arr[i] > 0)\\n              count++;\\n          }\\n          return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049269,
                "title": "one-line-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimplest way is to make a set out of string \\'s\\' in order to find all unique elements from the string and return its length\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049001,
                "title": "very-easy-to-understand-beats-100-java",
                "content": "\\n# Here\\'s how the code works:\\n\\n1. It initializes a variable ```count``` to 0, which will be used to count the unique letters.\\n2. It creates a ```boolean array flag``` with 26 elements, representing the 26 lowercase letters of the English alphabet. Each element is initially set to ```false```.\\n3. It then iterates over the characters in the input string s.\\nFor each character c in the string, it calculates its position in the array flag by subtracting \\'a\\' from it. This effectively maps ```\\'a\\'``` to ```index 0```, ```\\'b\\'``` to ```index 1```, and so on.\\n4. It sets the corresponding element in the flag array to true to indicate that the letter has been encountered.\\n5. After processing all characters in the input ```string```, it iterates over the ```flag array``` to count how many letters have been marked as ```true```.\\n6. The count of unique letters is stored in the ```count``` variable, which is then returned as the result.\\nIn the end, this code returns the count of unique lowercase letters in the input ```string s```. A simple and efficient way to achieve this task.\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count=0;\\n        boolean[] flag=new boolean[26];\\n        for(int i=0;i<s.length();i++){\\n            flag[s.charAt(i)-\\'a\\'] = true;\\n        }\\n        for(int i=0;i<flag.length;i++){\\n            if(flag[i]) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```count```\n```boolean array flag```\n```false```\n```\\'a\\'```\n```index 0```\n```\\'b\\'```\n```index 1```\n```string```\n```flag array```\n```true```\n```count```\n```string s```\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count=0;\\n        boolean[] flag=new boolean[26];\\n        for(int i=0;i<s.length();i++){\\n            flag[s.charAt(i)-\\'a\\'] = true;\\n        }\\n        for(int i=0;i<flag.length;i++){\\n            if(flag[i]) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048360,
                "title": "java-solution-beats-86-85",
                "content": "\\n# Approach\\n1) Every character must occur minimum times.\\n2) The least no of times that a character occurs has to be 1.\\n3) Let\\'s make a string str of characters from \\'a\\' to \\'z\\'.\\n4) Check if each separate character in str is present in s.\\n5) The count of the string will start to minimise because only individual characters will be counted i.e only once.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s)\\n    {\\n        String str=\"abcdefghijklmnopqrstuvwxyz\";\\n        int min_len=0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(s.indexOf(str.charAt(i))!=-1)\\n               min_len++;\\n        }\\n       return min_len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s)\\n    {\\n        String str=\"abcdefghijklmnopqrstuvwxyz\";\\n        int min_len=0;\\n        for(int i=0;i<str.length();i++)\\n        {\\n            if(s.indexOf(str.charAt(i))!=-1)\\n               min_len++;\\n        }\\n       return min_len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044087,
                "title": "easy-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Hashset\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<String> h1 = new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            h1.add(s.substring(i,i+1));\\n        }\\n        System.out.println(\"h1 is \"+h1);\\n        return h1.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<String> h1 = new HashSet<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            h1.add(s.substring(i,i+1));\\n        }\\n        System.out.println(\"h1 is \"+h1);\\n        return h1.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043328,
                "title": "100-runtime-beats-99-40-memory-beats-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int arr[]=new int[26];\\n        int count=0;\\n        for(char c : s.toCharArray()){\\n            arr[c-\\'a\\']++;\\n        }\\n        for(int n:arr){\\n            if(n!=0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int arr[]=new int[26];\\n        int count=0;\\n        for(char c : s.toCharArray()){\\n            arr[c-\\'a\\']++;\\n        }\\n        for(int n:arr){\\n            if(n!=0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042765,
                "title": "python-1-line-solution-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040820,
                "title": "c-o-1-memory-complexity",
                "content": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        sort(s.begin(),s.end());\\n        int cnt=1;\\n        \\n        for(int i=1;i<s.size();i++){\\n            \\n            if(s[i]!=s[i-1]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        sort(s.begin(),s.end());\\n        int cnt=1;\\n        \\n        for(int i=1;i<s.size();i++){\\n            \\n            if(s[i]!=s[i-1]){\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4040329,
                "title": "python-beat-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n      res = 0\\n      st = set(s)\\n      for i in st:\\n        res += 1\\n      return res\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n      res = 0\\n      st = set(s)\\n      for i in st:\\n        res += 1\\n      return res\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036551,
                "title": "c-easy-and-readable-solution-faster-than-62",
                "content": "![image.png](https://assets.leetcode.com/users/images/02707d73-80c2-425c-814c-d8783e5284d5_1694538701.2099478.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        Dictionary<char, int> dc = new ();\\n        for (int i = 0; i < s.Length; i++)\\n            if (!dc.ContainsKey(s[i]))\\n                dc.Add(s[i], 1);\\n            else\\n                dc[s[i]]++;\\n        return dc.Count;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimizedStringLength(string s) {\\n        Dictionary<char, int> dc = new ();\\n        for (int i = 0; i < s.Length; i++)\\n            if (!dc.ContainsKey(s[i]))\\n                dc.Add(s[i], 1);\\n            else\\n                dc[s[i]]++;\\n        return dc.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031544,
                "title": "easiest-solution-o-n-beat-90",
                "content": "\\n# Complexity\\n- Time complexity:\\n ```\\nO(N)\\n```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(N)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        if(s.length()==1)\\n        return 1;\\n         string str;\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(str.length()>0)\\n            { if(s[i]==str[str.length()-1])\\n            {\\n                continue;\\n            }\\n            else\\n            { str+=s[i];\\n\\n            }\\n\\n            }\\n            else\\n            {\\n                str+=s[i];\\n            }\\n        }\\n        return str.length();\\n    }\\n};\\n```\\n\\nhope you found it useful....btw i didnt get leetcode submit algorithm \\uD83D\\uDE05...when i submit first time this code beats 98% takes only 8ms hahaha",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nO(N)\\n```\n```\\nO(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        if(s.length()==1)\\n        return 1;\\n         string str;\\n        sort(s.begin(),s.end());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(str.length()>0)\\n            { if(s[i]==str[str.length()-1])\\n            {\\n                continue;\\n            }\\n            else\\n            { str+=s[i];\\n\\n            }\\n\\n            }\\n            else\\n            {\\n                str+=s[i];\\n            }\\n        }\\n        return str.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025324,
                "title": "one-line-code-with-no-extra-space-and-linear-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(1)** ---> Set can be Constructed of Size(26) Worst Case Possible. So it is Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022345,
                "title": "easy-to-understand-python-solution-1-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016358,
                "title": "elixir-mapset-rust-hashset-solutions",
                "content": "### Elixir\\n\\n```\\ndefmodule Solution do\\n  @spec minimized_string_length(s :: String.t()) :: integer\\n  def minimized_string_length(s) do\\n    s |> String.graphemes() |> MapSet.new() |> MapSet.size()\\n  end\\nend\\n\\n```\\n\\n### Rust\\n\\n```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let st: HashSet<u8> = HashSet::from_iter(s.bytes().into_iter());\\n        st.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec minimized_string_length(s :: String.t()) :: integer\\n  def minimized_string_length(s) do\\n    s |> String.graphemes() |> MapSet.new() |> MapSet.size()\\n  end\\nend\\n\\n```\n```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let st: HashSet<u8> = HashSet::from_iter(s.bytes().into_iter());\\n        st.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4015125,
                "title": "accepted-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014349,
                "title": "javascript-1-liner",
                "content": "# Code\\n```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s.split(\\'\\')).size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimizedStringLength = function(s) {\\n    return new Set(s.split(\\'\\')).size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013784,
                "title": "beats-100-in-time-space",
                "content": "# Approach - Use int array and store as 1 for the character is present\\n\\nThen calculate the total by iterating over the loop\\nThis beats the Set and HashMap solution flat out doubled the time\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] alpha = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            alpha[s.charAt(i)-\\'a\\'] = 1;\\n        }\\n        int total = 0;\\n        for(int num:alpha){\\n            total+=num;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] alpha = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            alpha[s.charAt(i)-\\'a\\'] = 1;\\n        }\\n        int total = 0;\\n        for(int num:alpha){\\n            total+=num;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013281,
                "title": "simple-c-program-answer",
                "content": "# Intuition\\nSOLUTION IN C PROGRAM .\\n\\n# Approach\\nBY SORTING THE CHARACTER INSIDE THE STRING AND COUNTING THE INDIVIUAL CHARACTER \\n\\n# Code\\n```\\nint minimizedStringLength(char * s){\\n\\n   int length = strlen(s); \\n   int count = 0;\\n   \\n   char temp;\\n   for(int i=0;i<length;i++){\\n       for(int j=i+1;j<length;j++){\\n           if(s[i] > s[j]){\\n               temp = s[i];\\n               s[i] = s[j];\\n               s[j] = temp;\\n           } \\n       }\\n   }\\n\\n   for(int i=1; i<length; i++){\\n       if(s[i] != s[count]){\\n           count++;\\n           s[count] = s[i];\\n       }\\n   }\\n\\n   return count + 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizedStringLength(char * s){\\n\\n   int length = strlen(s); \\n   int count = 0;\\n   \\n   char temp;\\n   for(int i=0;i<length;i++){\\n       for(int j=i+1;j<length;j++){\\n           if(s[i] > s[j]){\\n               temp = s[i];\\n               s[i] = s[j];\\n               s[j] = temp;\\n           } \\n       }\\n   }\\n\\n   for(int i=1; i<length; i++){\\n       if(s[i] != s[count]){\\n           count++;\\n           s[count] = s[i];\\n       }\\n   }\\n\\n   return count + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010143,
                "title": "java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean alphabets[] = new boolean[26];\\n        int ans = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(!alphabets[c - \\'a\\']){\\n                ans++;\\n                alphabets[c - \\'a\\'] = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean alphabets[] = new boolean[26];\\n        int ans = 0;\\n\\n        for(char c : s.toCharArray()){\\n            if(!alphabets[c - \\'a\\']){\\n                ans++;\\n                alphabets[c - \\'a\\'] = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009932,
                "title": "2lines-code-easy-code-java-string",
                "content": "\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (ch[i] != ch[i + 1]) {\\n                count++;\\n            }\\n        }\\n        // Increment count for the last unique character\\n        count++;\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        char[] ch = s.toCharArray();\\n        Arrays.sort(ch);\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (ch[i] != ch[i + 1]) {\\n                count++;\\n            }\\n        }\\n        // Increment count for the last unique character\\n        count++;\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005654,
                "title": "o-n-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnce you have analysed, the goal is to find the unique elements in the string\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Using a set, try to insert all the elements in the set\\n2. Return the size of the set\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set <char> ans;\\n        for(auto x : s) {\\n            ans.insert(x);\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set <char> ans;\\n        for(auto x : s) {\\n            ans.insert(x);\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002535,
                "title": "two-types-of-code-array-and-string-method-both",
                "content": "\\n```\\nfunction minimizedStringLength(s: string): number {\\n    //  let strArr = [...s];\\n    // let count = 0;\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     for (let j = i + 1; j < strArr.length; j++) {\\n    //         if (strArr[i] === strArr[j]) {\\n    //             strArr[j] = \".\";\\n    //         }\\n    //     }\\n    // }\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     if (strArr[i] != \".\") {\\n    //         count++;\\n    //     }\\n    // }\\n\\n    // return count;\\n\\n     let str = \"\";\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (!str.includes(s[i])) {\\n            str += s[i];\\n        }\\n    }\\n\\n    return str.length;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction minimizedStringLength(s: string): number {\\n    //  let strArr = [...s];\\n    // let count = 0;\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     for (let j = i + 1; j < strArr.length; j++) {\\n    //         if (strArr[i] === strArr[j]) {\\n    //             strArr[j] = \".\";\\n    //         }\\n    //     }\\n    // }\\n\\n    // for (let i = 0; i < strArr.length; i++) {\\n    //     if (strArr[i] != \".\") {\\n    //         count++;\\n    //     }\\n    // }\\n\\n    // return count;\\n\\n     let str = \"\";\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (!str.includes(s[i])) {\\n            str += s[i];\\n        }\\n    }\\n\\n    return str.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001122,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string>\\nclass Solution {\\n    public:\\n    int minimizedStringLength(string s) {\\n        int n=s.size();\\n        for (int i=0;i<n;){\\n            char ch=s[i];\\n            int j=i+1;\\n            while(j<n){\\n                if (s[j]==ch){\\n                    s.erase(j,1);\\n                    n--;\\n                }\\n                else j++;\\n            }\\n            i++;\\n        }\\n        return s.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\nclass Solution {\\n    public:\\n    int minimizedStringLength(string s) {\\n        int n=s.size();\\n        for (int i=0;i<n;){\\n            char ch=s[i];\\n            int j=i+1;\\n            while(j<n){\\n                if (s[j]==ch){\\n                    s.erase(j,1);\\n                    n--;\\n                }\\n                else j++;\\n            }\\n            i++;\\n        }\\n        return s.size();\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3992806,
                "title": "trick-solution-easy-solution-using-set-4-line-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought was breaking the solution but it seemed too much work so I tried reading the question again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter reading it again I suspected a trick solution might work.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> res = new HashSet<>();\\n        for(char c : s.toCharArray())\\n            res.add(c);\\n        return res.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> res = new HashSet<>();\\n        for(char c : s.toCharArray())\\n            res.add(c);\\n        return res.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992235,
                "title": "minimize-string-length",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    We just have to return the number of unique character in String\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(k) where k is the number of unique element. \\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Map<Character,Integer> map = new HashMap<>(); \\n        \\n        int ans = 0;\\n        for(char ch : s.toCharArray())\\n        {\\n            if(map.containsKey(ch)) continue;\\n            else{\\n                map.put(ch,1);\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Map<Character,Integer> map = new HashMap<>(); \\n        \\n        int ans = 0;\\n        for(char ch : s.toCharArray())\\n        {\\n            if(map.containsKey(ch)) continue;\\n            else{\\n                map.put(ch,1);\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988060,
                "title": "c-2-line-easy-solution",
                "content": "# C++ | 2 Line | easy solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        sort(s.begin(),s.end());\\n        s.erase(unique(s.begin(),s.end()),s.end());\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        sort(s.begin(),s.end());\\n        s.erase(unique(s.begin(),s.end()),s.end());\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985282,
                "title": "typescript-solution",
                "content": "```\\nfunction minimizedStringLength(s: string): number {\\n    const chars: string[] = [...new Set(s.split(\\'\\'))];\\n    return chars.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction minimizedStringLength(s: string): number {\\n    const chars: string[] = [...new Set(s.split(\\'\\'))];\\n    return chars.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983548,
                "title": "solution-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFist I was thinking that I will leave string \"absba\"\\nBut after carfully reading the task I understod that I neeed only distince letters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981569,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>h=new HashSet();\\n        for(int i=0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n        return h.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character>h=new HashSet();\\n        for(int i=0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n        return h.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980359,
                "title": "best-explained-and-easiest-solution",
                "content": "# Intuition\\nBasicaly the question is to return the size of substring in a given string which has no duplicate characters,so if you think about it the easiest way to solve this problem is to use set data structure,because set doesnt contain duplicates.\\n\\n# Approach\\n-Traverse through the string and insert every character to set.\\n-In the end return the size of a set.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    set<char>st;\\n    for(char c:s){\\n      st.insert(c);\\n    }    \\n    return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    set<char>st;\\n    for(char c:s){\\n      st.insert(c);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3979931,
                "title": "python-one-line-solution",
                "content": "The only challenge here was to not misinterpret the description and sample cases\\n\\nthe final string will contain no duplicates\\n# Solution\\n```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978878,
                "title": "simple-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(String.valueOf(s.charAt(i)));\\n        }\\n        return set.size();\\n\\n\\n        // StringBuilder sb = new StringBuilder(s);\\n        // for(int i=0; i<sb.length()-1; i++){\\n        //     for(int j=0; j<sb.length()-1; j++){\\n        //         if(sb.charAt(j)==sb.charAt(j+1)){\\n        //             sb.deleteCharAt(j);\\n        //         }\\n        //     }\\n        // }\\n        // String str = sb.toString();\\n        // return str.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0; i<s.length(); i++){\\n            set.add(String.valueOf(s.charAt(i)));\\n        }\\n        return set.size();\\n\\n\\n        // StringBuilder sb = new StringBuilder(s);\\n        // for(int i=0; i<sb.length()-1; i++){\\n        //     for(int j=0; j<sb.length()-1; j++){\\n        //         if(sb.charAt(j)==sb.charAt(j+1)){\\n        //             sb.deleteCharAt(j);\\n        //         }\\n        //     }\\n        // }\\n        // String str = sb.toString();\\n        // return str.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978609,
                "title": "go-beats-100",
                "content": "# Intuition\\nf the input string contains only lowercase English letters, you can use an array of size 26 to count the frequency of each letter in the string\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc minimizedStringLength(s string) int {\\n    freq := [26]int{}\\n\\n    for _, c := range s {\\n        freq[c-\\'a\\']++\\n    }\\n\\n    count := 0\\n    for _, f := range freq {\\n        if f > 0 {\\n            count++\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimizedStringLength(s string) int {\\n    freq := [26]int{}\\n\\n    for _, c := range s {\\n        freq[c-\\'a\\']++\\n    }\\n\\n    count := 0\\n    for _, f := range freq {\\n        if f > 0 {\\n            count++\\n        }\\n    }\\n\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973020,
                "title": "easy-java-solution-by-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> h = new HashSet<>();\\n        for(int i =0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n\\n    return h.size();}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> h = new HashSet<>();\\n        for(int i =0;i<s.length();i++){\\n            h.add(s.charAt(i));\\n        }\\n\\n    return h.size();}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972899,
                "title": "solution-with-constant-time-and-memory",
                "content": "\\n# Approach\\nWe need the number of the unique characters. If a character appears\\nmore than 1 time, it can be reduced to 1 apparition. Instead of \\nusing set or map (which occupies a lot memory), use a 26 sized-array(\\nwe are working with small letters) like a map of <int, int> or like a set.\\n![image.png](https://assets.leetcode.com/users/images/e8fc8a39-f97c-4101-9999-1b3d6a3a387c_1693244183.0110075.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //s contains only lowercase English letters\\n        int arr[26] = {0};\\n        for (auto c : s)\\n        {\\n            arr[c - \\'a\\']++;\\n        }\\n        int nr = 0;\\n        for (int c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            if (arr [c - \\'a\\'] >= 1)\\n            {\\n                nr ++;\\n            }\\n        }\\n        return nr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //s contains only lowercase English letters\\n        int arr[26] = {0};\\n        for (auto c : s)\\n        {\\n            arr[c - \\'a\\']++;\\n        }\\n        int nr = 0;\\n        for (int c = \\'a\\'; c <= \\'z\\'; c++)\\n        {\\n            if (arr [c - \\'a\\'] >= 1)\\n            {\\n                nr ++;\\n            }\\n        }\\n        return nr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972775,
                "title": "hash-map-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> mp;\\n\\n        for (int i=0;i<s.size();i++) {\\n            mp[s[i]]++;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        map<char, int> mp;\\n\\n        for (int i=0;i<s.size();i++) {\\n            mp[s[i]]++;\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955894,
                "title": "ruby-one-line-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {String} s\\n# @return {Integer}\\ndef minimized_string_length(s)\\n    return s.split(\"\").tally.size\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @return {Integer}\\ndef minimized_string_length(s)\\n    return s.split(\"\").tally.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3951560,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char,int>m;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            if(m[s[i]]==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char,int>m;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            if(m[s[i]]==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951308,
                "title": "c-bits-manipulation-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int mask = 0;\\n        for(char &ele:s){\\n            mask |= (1<<(ele-\\'a\\'));\\n        }\\n        int res = 0;\\n        while(mask){\\n            res += (mask&1);\\n            mask = mask>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int mask = 0;\\n        for(char &ele:s){\\n            mask |= (1<<(ele-\\'a\\'));\\n        }\\n        int res = 0;\\n        while(mask){\\n            res += (mask&1);\\n            mask = mask>>1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949226,
                "title": "minimize-string-length-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i =0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n        for(int i =0; i < s.length(); i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946369,
                "title": "js-hashmap-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(arr) {\\n    let map = new Map();\\n\\n\\n    for(let i=0; i<arr.length; i++){\\n        if(!map.has(arr[i])) map.set(arr[i], 1)\\n    }\\n\\n    return map.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function(arr) {\\n    let map = new Map();\\n\\n\\n    for(let i=0; i<arr.length; i++){\\n        if(!map.has(arr[i])) map.set(arr[i], 1)\\n    }\\n\\n    return map.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943656,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(NLogN)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int j = 0;\\n        int resultCount = 1;\\n        char[] tmp = s.toCharArray();\\n\\n        Arrays.sort(tmp);\\n\\n        for (int i = 1; i < tmp.length; i++) {\\n            if (tmp[i] != tmp[j]) {\\n                resultCount++;\\n                j = i;\\n            }\\n        }\\n\\n        return resultCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int j = 0;\\n        int resultCount = 1;\\n        char[] tmp = s.toCharArray();\\n\\n        Arrays.sort(tmp);\\n\\n        for (int i = 1; i < tmp.length; i++) {\\n            if (tmp[i] != tmp[j]) {\\n                resultCount++;\\n                j = i;\\n            }\\n        }\\n\\n        return resultCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942288,
                "title": "easy-code-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string temp=\"\";\\n        sort(s.begin(),s.end());\\n        temp.push_back(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(temp.back()!=s[i])\\n            {\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        string temp=\"\";\\n        sort(s.begin(),s.end());\\n        temp.push_back(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(temp.back()!=s[i])\\n            {\\n                temp.push_back(s[i]);\\n            }\\n        }\\n        return temp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941177,
                "title": "simple-solution-4-lines-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> sb = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            sb.add(c);\\n        }\\n        return sb.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> sb = new HashSet<>();\\n        for(char c:s.toCharArray()){\\n            sb.add(c);\\n        }\\n        return sb.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939092,
                "title": "clean-golang-solution",
                "content": "# Code\\n```\\nfunc minimizedStringLength(s string) int {\\n    set := make(map[rune]struct{},0)\\n    for _,v := range s {\\n        set[v] = struct{}{}\\n    }\\n    return len(set)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimizedStringLength(s string) int {\\n    set := make(map[rune]struct{},0)\\n    for _,v := range s {\\n        set[v] = struct{}{}\\n    }\\n    return len(set)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937649,
                "title": "2716-minimize-string-length-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(N);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //taking the int variables i,j \\n        int i=0,j=0;\\n        //taking the one string variable\\n        string st=\"\";\\n        //using the sort method to sort the string \\n        sort(s.begin(), s.end());\\n        while(i<s.length()){\\n            st+=s[i];\\n            if(s[i]==s[i+1]){\\n                st.pop_back();\\n            }\\n            else{\\n                j++;\\n                st+=s[i];\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        //taking the int variables i,j \\n        int i=0,j=0;\\n        //taking the one string variable\\n        string st=\"\";\\n        //using the sort method to sort the string \\n        sort(s.begin(), s.end());\\n        while(i<s.length()){\\n            st+=s[i];\\n            if(s[i]==s[i+1]){\\n                st.pop_back();\\n            }\\n            else{\\n                j++;\\n                st+=s[i];\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3932732,
                "title": "easy-solution-2-lines-using-set",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n       return st.size();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n       return st.size();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931847,
                "title": "one-word-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n        \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        return len(set(s))\\n        \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928205,
                "title": "easy-to-understand-c-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st(s.begin(),s.end());\\n\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926241,
                "title": "simple-java-solution-single-loop",
                "content": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder r = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (r.indexOf(String.valueOf(c)) == -1) {\\n                r.append(c);\\n            }\\n        }\\n        return r.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder r = new StringBuilder();\\n        for (char c : s.toCharArray()) {\\n            if (r.indexOf(String.valueOf(c)) == -1) {\\n                r.append(c);\\n            }\\n        }\\n        return r.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925031,
                "title": "easy-python-solution-for-minimize-the-string-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = \\'\\'\\n        for i in s:\\n            if i not in res:\\n                res += i\\n            else:\\n                pass\\n        return len(res)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = \\'\\'\\n        for i in s:\\n            if i not in res:\\n                res += i\\n            else:\\n                pass\\n        return len(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923048,
                "title": "short-and-easy-solution-using-set-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nintuition is simple to take unique elements from strings\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso i think about set as it stors only unique elements\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTC is O(N)\\n\\n- Space complexity:\\n- O(N) as we took set  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto c:s)\\n        {\\n            st.insert(c);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>st;\\n        for(auto c:s)\\n        {\\n            st.insert(c);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921937,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) \\n        {\\n            if (sb.indexOf(String.valueOf(c)) == -1) \\n            {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.length();\\n         }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : s.toCharArray()) \\n        {\\n            if (sb.indexOf(String.valueOf(c)) == -1) \\n            {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.length();\\n         }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921726,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(const string& s)\\n    {\\n        int freq[26] = {0};\\n        for (char c : s)\\n        {\\n            freq[c - \\'a\\']++;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (freq[i] > 0)\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimizedStringLength(const string& s)\\n    {\\n        int freq[26] = {0};\\n        for (char c : s)\\n        {\\n            freq[c - \\'a\\']++;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            if (freq[i] > 0)\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921046,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        int[] arr = new int[26];\\n        for(char c:s.toCharArray()){\\n            if(arr[c - \\'a\\'] == 0){\\n                count++;\\n                arr[c - \\'a\\'] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int count = 0;\\n        int[] arr = new int[26];\\n        for(char c:s.toCharArray()){\\n            if(arr[c - \\'a\\'] == 0){\\n                count++;\\n                arr[c - \\'a\\'] = 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919817,
                "title": "just-count-the-unique-characters-o-n-beats-100",
                "content": "# intuition\\nfor any character having more than one occurence, it can be deleted from left or right of chosen pivot character.\\nonly the pivot character can\\'t be deleted.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] distincts = new boolean[26];\\n        for(char ch: s.toCharArray()) {\\n            distincts[ch-97] = true;\\n        }\\n        int sum = 0;\\n        for(boolean b: distincts) {\\n            sum += b?1:0;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] distincts = new boolean[26];\\n        for(char ch: s.toCharArray()) {\\n            distincts[ch-97] = true;\\n        }\\n        int sum = 0;\\n        for(boolean b: distincts) {\\n            sum += b?1:0;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917891,
                "title": "dart-solution-in-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minimizedStringLength(String s) {\\n      return s.split(\\'\\').toSet().length;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minimizedStringLength(String s) {\\n      return s.split(\\'\\').toSet().length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917314,
                "title": "go-simple-solution",
                "content": "# Code\\n```go\\nfunc minimizedStringLength(s string) (l int) {\\n    // recommended slices more than map which is slower\\n    v := make([]bool, 26)\\n    for _, b := range s {\\n        if v[b-\\'a\\'] {\\n            continue\\n        }\\n        v[b-\\'a\\'] = true \\n        l++\\n    }\\n    return\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minimizedStringLength(s string) (l int) {\\n    // recommended slices more than map which is slower\\n    v := make([]bool, 26)\\n    for _, b := range s {\\n        if v[b-\\'a\\'] {\\n            continue\\n        }\\n        v[b-\\'a\\'] = true \\n        l++\\n    }\\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916820,
                "title": "easy-understanding",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(m) where m isthe unique charecters in the string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int count = 0;\\n        char ch = s[0];\\n        int n = s.size();\\n        unordered_map<int, int> umap;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(umap.find(s[i]) != umap.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n                umap[s[i]]++;\\n            }\\n        }\\n        return umap.size();\\n        // for(int i=1;i<n;i++)\\n        // {\\n        //     if(s[i] == ch)\\n        //     {\\n        //         continue;\\n        //     }\\n        //     else\\n        //     {\\n        //         count++;\\n        //         ch = s[i];\\n        //     }\\n        // }\\n        // return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        int count = 0;\\n        char ch = s[0];\\n        int n = s.size();\\n        unordered_map<int, int> umap;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(umap.find(s[i]) != umap.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n                umap[s[i]]++;\\n            }\\n        }\\n        return umap.size();\\n        // for(int i=1;i<n;i++)\\n        // {\\n        //     if(s[i] == ch)\\n        //     {\\n        //         continue;\\n        //     }\\n        //     else\\n        //     {\\n        //         count++;\\n        //         ch = s[i];\\n        //     }\\n        // }\\n        // return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916506,
                "title": "96-with-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<int> arr(26,0);\\n        int ans=0;\\n        for(auto i:s){\\n            arr[i-\\'a\\']++;\\n            if(arr[i-\\'a\\']==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        vector<int> arr(26,0);\\n        int ans=0;\\n        for(auto i:s){\\n            arr[i-\\'a\\']++;\\n            if(arr[i-\\'a\\']==1)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916035,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] table = new boolean[26];\\n        int count = 0;\\n\\n        for(char c : s.toCharArray())\\n           table[c -\\'a\\'] = true;\\n        \\n        for(int i = 0; i < 26; i++)\\n           if(table[i]) count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        boolean[] table = new boolean[26];\\n        int count = 0;\\n\\n        for(char c : s.toCharArray())\\n           table[c -\\'a\\'] = true;\\n        \\n        for(int i = 0; i < 26; i++)\\n           if(table[i]) count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914310,
                "title": "easy-solution-using-set-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910404,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just removing the duplicate here.\\nSo just remove the duplicate string elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        List<Character> list=new ArrayList<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(!list.contains(s.charAt(i)))\\n            {\\n                list.add(s.charAt(i));\\n            }\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        List<Character> list=new ArrayList<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(!list.contains(s.charAt(i)))\\n            {\\n                list.add(s.charAt(i));\\n            }\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907841,
                "title": "using-map-in-c-very-easy-solution",
                "content": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        //Time and space com = O(n);\\n        unordered_map<char,int> mp;\\n        for(char ch : s)\\n        {\\n            mp[ch]++;\\n        }\\n        \\n        return mp.size();\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        \\n        //Time and space com = O(n);\\n        unordered_map<char,int> mp;\\n        for(char ch : s)\\n        {\\n            mp[ch]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3902678,
                "title": "o-n-simple-solution-using-mapping-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust use pigeonhole sort principle\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minimizedStringLength(char * s){\\n    int arr[26] = {0};\\n    for(int i = 0;i < strlen(s);i++){\\n        arr[s[i] - \\'a\\']++;\\n    }\\n    int p = 0;\\n    for(int i = 0;i < 26;i++){\\n        if(arr[i] > 0){\\n            p++;\\n        }\\n    }\\n    return(p);\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizedStringLength(char * s){\\n    int arr[26] = {0};\\n    for(int i = 0;i < strlen(s);i++){\\n        arr[s[i] - \\'a\\']++;\\n    }\\n    int p = 0;\\n    for(int i = 0;i < 26;i++){\\n        if(arr[i] > 0){\\n            p++;\\n        }\\n    }\\n    return(p);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3901474,
                "title": "simple-approach-is-using-set",
                "content": "\\n# Approach\\nSince any characher from left or right has to be deleted\\nTherefore any dublicate will be removed in the end.\\nso, the question boils down to count of unique elements.\\n\\n\\n\\n# Code\\n```\\n    int minimizedStringLength(string s) {\\n        set<char>se;\\n        for(char ch:s)se.insert(ch);\\n        return se.size();\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int minimizedStringLength(string s) {\\n        set<char>se;\\n        for(char ch:s)se.insert(ch);\\n        return se.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3898481,
                "title": "one-line-solution-with-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function (s) {\\n\\n    // remove same character from string s using Set() and convert into string from array using join() and find length of string using .length property and return it\\n    return [...new Set([...s])].join(\\'\\').length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimizedStringLength = function (s) {\\n\\n    // remove same character from string s using Set() and convert into string from array using join() and find length of string using .length property and return it\\n    return [...new Set([...s])].join(\\'\\').length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895120,
                "title": "very-easy-to-understand-just-go-and-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ntraverse every character of set and add it to hashset; lastly return set size;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> A = new HashSet<>();\\n        for(int i =0;i<s.length(); i++){\\n            if(!A.contains(s.charAt(i))){\\n                A.add(s.charAt(i));\\n            }\\n        }\\n        return A.size();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        HashSet<Character> A = new HashSet<>();\\n        for(int i =0;i<s.length(); i++){\\n            if(!A.contains(s.charAt(i))){\\n                A.add(s.charAt(i));\\n            }\\n        }\\n        return A.size();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894988,
                "title": "python3-and-python-100-simple-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = [i for i in set(s)]\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        res = [i for i in set(s)]\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894144,
                "title": "beginner-friendly-hashset-sol",
                "content": "# Intuition\\nThe answer string consist of only distinct characters\\n\\n# Approach\\nHashSet\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n\\n        for(char c : s.toCharArray()) {\\n            if(!set.add(c)) continue;\\n            else set.add(c);\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```\\n\\nPLEASE UPVOTE(if you\\'re not gay)",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character> set = new HashSet<>();\\n\\n        for(char c : s.toCharArray()) {\\n            if(!set.add(c)) continue;\\n            else set.add(c);\\n        }\\n        \\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893003,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    int i = 1;\\n    while (i < s.length()) {\\n        cout << s << endl;\\n        \\n        int left = i - 1;\\n        while (left >= 0 && s[left] != s[i]) {\\n            left--;\\n        }\\n        if (left >= 0) {\\n            s.erase(left, 1);\\n            i--;\\n        }\\n\\n        int right = i + 1;\\n        while (right < s.length() && s[right] != s[i]) {\\n            right++;\\n        }\\n        if (right < s.length()) {\\n            s.erase(right, 1);\\n        }\\n\\n        i++;\\n    }\\n    return s.length();\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n    int i = 1;\\n    while (i < s.length()) {\\n        cout << s << endl;\\n        \\n        int left = i - 1;\\n        while (left >= 0 && s[left] != s[i]) {\\n            left--;\\n        }\\n        if (left >= 0) {\\n            s.erase(left, 1);\\n            i--;\\n        }\\n\\n        int right = i + 1;\\n        while (right < s.length() && s[right] != s[i]) {\\n            right++;\\n        }\\n        if (right < s.length()) {\\n            s.erase(right, 1);\\n        }\\n\\n        i++;\\n    }\\n    return s.length();\\n}\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3881800,
                "title": "3-lines-solution-incl-return-statement",
                "content": "# Intuition\\nRead between the lines. No need to search for similar chars inside of a string. All you are asked for is a count of unique chars.\\n\\n# Approach\\n- sort it\\n- remove duplicates\\n\\nerase(unique) idiom works just fine\\n\\n# Complexity\\n- Time complexity:\\n$$O(NlogN)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        std::sort(s.begin(), s.end());\\n        s.erase(std::unique(s.begin(), s.end()), s.end() );\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        std::sort(s.begin(), s.end());\\n        s.erase(std::unique(s.begin(), s.end()), s.end() );\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879996,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> mp;\\n\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> mp;\\n\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873211,
                "title": "in-1-line",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        s = set(s)\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizedStringLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        s = set(s)\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872551,
                "title": "two-line-code-using-counter-function-runtime-45ms-beat-98-in-runtime",
                "content": "# Intuition\\n-> count the number of distinct character in string and return that count\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n->count the occurances of characters in string using counter function and return the number of distinct keys using len and keys function\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        c=Counter(s)\\n        return len(c.keys())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        c=Counter(s)\\n        return len(c.keys())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864868,
                "title": "python-one-liner-faster-than",
                "content": "# Intuition\\nThis problem is nothing more than a roundabout way of counting the number of unique characters in a string.  There are a number of ways to do this.\\n\\n# Approach\\nMy approach focuses on a \"real-world\" solution to this, which means convenient for the author.  For that reason, this solution is a one-liner.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**: We iterate through a string of length `n` once, performing constant time operations each iteration.  This solution beat 98.55% submissions.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**: We store potentially `n` characters in a set.  While one might be tempted to say this is O(1) space as the constraints specify the input characters are lowercase English letters, the proper abstraction applies to any range of character inputs.  This solution beat 70.97% of submissions.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        #this is literally just returning the number of unique characters\\n        return len({i for i in s})\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        #this is literally just returning the number of unique characters\\n        return len({i for i in s})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862849,
                "title": "easy-to-understand-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let mut unique: HashSet<char> = HashSet::new();\\n    \\n        for char in s.chars() {\\n            unique.insert(char);\\n        }\\n\\n        unique.len() as i32 //.try_into().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn minimized_string_length(s: String) -> i32 {\\n        let mut unique: HashSet<char> = HashSet::new();\\n    \\n        for char in s.chars() {\\n            unique.insert(char);\\n        }\\n\\n        unique.len() as i32 //.try_into().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3859841,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # for i, c in enumerate(s):\\n        #     p = s[i::].find(c)\\n        #     s[p].replace(s[p], \" \")\\n        #     q = s[:i].find(c)\\n        #     s[q].replace(s[q], \" \")\\n        # return len(s)\\n        return len(set(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # for i, c in enumerate(s):\\n        #     p = s[i::].find(c)\\n        #     s[p].replace(s[p], \" \")\\n        #     q = s[:i].find(c)\\n        #     s[q].replace(s[q], \" \")\\n        # return len(s)\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858325,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimizedStringLength(_ s: String) -> Int {\\n        Set(s).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857964,
                "title": "simple-solution-for-beginner-using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        l1=[]\\n        l2=[]\\n        for i in s:\\n            if i not in l1:\\n                l1.append(i)\\n            else:\\n                l2.append(i)\\n        return len(l1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        l1=[]\\n        l2=[]\\n        for i in s:\\n            if i not in l1:\\n                l1.append(i)\\n            else:\\n                l2.append(i)\\n        return len(l1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855703,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(strlen(s))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) as it does not depend on strlen but it \\'26\\'+\\'1\\' extra space used. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minimizedStringLength(char * s){\\n    int ans[\\'z\\'-64]={0};\\n    int count=0;\\n   for(int i=0;i<strlen(s);i++)\\n   {\\n       if(ans[s[i]-65]==0)\\n       {\\n           count++;\\n           ans[s[i]-65]++;\\n       }\\n       else\\n       continue;\\n   }\\n   return count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimizedStringLength(char * s){\\n    int ans[\\'z\\'-64]={0};\\n    int count=0;\\n   for(int i=0;i<strlen(s);i++)\\n   {\\n       if(ans[s[i]-65]==0)\\n       {\\n           count++;\\n           ans[s[i]-65]++;\\n       }\\n       else\\n       continue;\\n   }\\n   return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853728,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>ss;\\n        for(auto i:s){\\n            ss.insert(i);\\n        }\\n\\n        return ss.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        set<char>ss;\\n        for(auto i:s){\\n            ss.insert(i);\\n        }\\n\\n        return ss.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853714,
                "title": "java-easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        int[] arr = new int[26];\\n\\n        for(char c : s.toCharArray())\\n            arr[c - \\'a\\']++;\\n\\n        int count = 0;\\n\\n        for(int n : arr) \\n            if(n != 0) count++;\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849099,
                "title": "using-hashmap-one-line-solution",
                "content": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Using Hashmap\\n        # hash_ = {}\\n        # for i in s:\\n        #     if i not in hash_:\\n        #         hash_[i] = 1\\n        #     hash_[i] += 1\\n        # return len(hash_)\\n        \\n        # One line.\\n        return len(set(s))\\n```\\n\\nThanks for reading :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizedStringLength(self, s: str) -> int:\\n        # Using Hashmap\\n        # hash_ = {}\\n        # for i in s:\\n        #     if i not in hash_:\\n        #         hash_[i] = 1\\n        #     hash_[i] += 1\\n        # return len(hash_)\\n        \\n        # One line.\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846026,
                "title": "beginner-friendly-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character>set=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizedStringLength(String s) {\\n        Set<Character>set=new HashSet<>();\\n        for(int i=0;i<s.length();i++){\\n            set.add(s.charAt(i));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845826,
                "title": "java-3ms-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // HashSet + StringBuilder strategy: 8ms Beats 79.21%\\n    // boolean[123] + StringBuilder strategy: 4ms Beats 99.80%\\n    // boolean[123] + int numChars strategy: 3ms Beats 100.00%\\n\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] skipForever = new boolean[123];\\n        int numChars = 0;  // what we\\'ll return\\n\\n        for (char c : s.toCharArray()) {\\n            if (!skipForever[c]) {\\n                ++numChars;\\n                skipForever[c] = true;\\n            }\\n        }\\n\\n        return numChars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // HashSet + StringBuilder strategy: 8ms Beats 79.21%\\n    // boolean[123] + StringBuilder strategy: 4ms Beats 99.80%\\n    // boolean[123] + int numChars strategy: 3ms Beats 100.00%\\n\\n    public int minimizedStringLength(String s) {\\n\\n        boolean[] skipForever = new boolean[123];\\n        int numChars = 0;  // what we\\'ll return\\n\\n        for (char c : s.toCharArray()) {\\n            if (!skipForever[c]) {\\n                ++numChars;\\n                skipForever[c] = true;\\n            }\\n        }\\n\\n        return numChars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845701,
                "title": "c-efficient-concise",
                "content": "# Intuition\\nThe problem description is a bit confusing, but it boils down to a count of unique characters.\\n# Approach\\nUse a set to count unique characters.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)\\n\\n- Space complexity:\\n$$O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string& s) {\\n        unordered_set<char> t(s.begin(), s.end());\\n        return t.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string& s) {\\n        unordered_set<char> t(s.begin(), s.end());\\n        return t.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844318,
                "title": "c-easy-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> ump;\\n        for(auto i : s) ump[i]++;\\n        \\n        int extra = 0;\\n        for(auto i : ump) {\\n            if(i.second > 1) extra += i.second - 1;\\n        }\\n        return s.size() - extra;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_map<char, int> ump;\\n        for(auto i : s) ump[i]++;\\n        \\n        int extra = 0;\\n        for(auto i : ump) {\\n            if(i.second > 1) extra += i.second - 1;\\n        }\\n        return s.size() - extra;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1916536,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916041,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916139,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916884,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2069258,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2054998,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1980052,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1975797,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1931513,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1921418,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916536,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916041,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916139,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1916884,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2069258,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 2054998,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1980052,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1975797,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1931513,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            },
            {
                "id": 1921418,
                "content": [
                    {
                        "username": "Kavya_Goyal",
                        "content": "The problem statement is not properly written as in this we not suppose to count just the unique characters or remove duplicates .\\nWe should remove left and right and count the character Like if a testcase is like aaabbcdaa so the length of this should be 5 instead of 4 as by removing left and right occurrence of the same characters \\nSo  left out characters  should be abcda this how length of this will be 5 \\nThis is what problem state instead of what the solution it is accepting."
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "[@matamv](/matamv) Now they have update the tag but fail to update the problem statement They can simply write remove duplicates or count unique character if this is a solution they need."
                    },
                    {
                        "username": "laticm",
                        "content": "yeah this is where i was stuck. also, it had medium tag in contest. i went blank "
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It\\'s not at all a medium level problem. Should be marked easy."
                    },
                    {
                        "username": "aquaman55",
                        "content": "you should be marked as easy"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "it is marked as a easy\\n"
                    },
                    {
                        "username": "Socrii13",
                        "content": "The only thing in this question was how did u take the question as sample case can mislead ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "One line problem. ```Set``` is your the best friend here"
                    },
                    {
                        "username": "SidKay",
                        "content": "I really do not understand what this problem description is saying, but `set` it is then."
                    },
                    {
                        "username": "ss6156852",
                        "content": "SEt is your friend here\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "Soo... \\n\\nif I have string \"aaaadddaaa\":\\n\\nit should be \"ad\" or \"ada\""
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Question just ask for returning number of unique char. When you submit `return len(set(s))`, you will pass the test."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "Performing the operations any number of time, will always leave the string full with unique characters. There are no tests checking in which order, do you take the characters away, and also it is not that clear in the description, in which order should you do if there are only two  similar characters in ex: \"abca\". Should you take the left \"a\" or the right \"a\" and give a result of \"abc\" or \"bca\". \\n\\nAnd since it checks if you have taken all the non-unique characters out, instead of using a hashmap and wondering whether you should remove the left or the right character, you can use the set() function and pass the tests."
                    },
                    {
                        "username": "MaheshK04",
                        "content": "does anyone know how to do this problem without hashset?\\nif u know please tell me the approach to solve it "
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You may sort and then count chars not equal to their left neighbor. "
                    },
                    {
                        "username": "aryan1905",
                        "content": "just check for number of unique charachter occurences which will lead to removal of duplicates.\\n\\nclass Solution {\\npublic:\\n    int minimizedStringLength(string s) {\\n        unordered_set<char> uniqueChars;\\n        for (char ch : s) {\\n            if (uniqueChars.find(ch) == uniqueChars.end()) {\\n                uniqueChars.insert(ch);\\n            }\\n        }\\n        return uniqueChars.size();\\n    }\\n};"
                    },
                    {
                        "username": "Kavya_Goyal",
                        "content": "class Solution {\\n    public int minimizedStringLength(String s) {\\n       int arr[]= new int[26];\\n        int count=0;\\n        for(int i =0;i<s.length();i++){\\n            arr[s.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i =0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\nThis is how you can solve it without hashset\\n"
                    },
                    {
                        "username": "laticm",
                        "content": "you can use an array of size 26 to keep track of the count of elements, and if any of their count>0 increment result by 1. return result\\n"
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "why this is giving me a wrong ans on 1125 testcase.\n`your inline code...your inline code...\nclass Solution {\npublic:\n    int minimizedStringLength(string s) {\n        int i=0 ;\n        int N =s.size();\n        for (int j = 0 ; j < N ; j++ ){\n            if(s[i]!=s[j]){\n                s[i+1]=s[j];\n                i++;\n            }\n        }\n        return{i+1};\n    }\n};`"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "bro you\\'re checking adjacent elements only but they asked for closest occurrence\\n\\ncheck this solution\\nhttps://leetcode.com/problems/minimize-string-length/solutions/3613884/best-approach-easy-java-solution-beats-100/\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Semi-Ordered Permutation",
        "question_content": "<p>You are given a <strong>0-indexed</strong> permutation of <code>n</code> integers <code>nums</code>.</p>\n\n<p>A permutation is called <strong>semi-ordered</strong> if the first number equals <code>1</code> and the last number equals <code>n</code>. You can perform the below operation as many times as you want until you make <code>nums</code> a <strong>semi-ordered</strong> permutation:</p>\n\n<ul>\n\t<li>Pick two adjacent elements in <code>nums</code>, then swap them.</li>\n</ul>\n\n<p>Return <em>the minimum number of operations to make </em><code>nums</code><em> a <strong>semi-ordered permutation</strong></em>.</p>\n\n<p>A <strong>permutation</strong> is a sequence of integers from <code>1</code> to <code>n</code> of length <code>n</code> containing each number exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,4,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can make the permutation semi-ordered using these sequence of operations: \n1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than two operations that make nums a semi-ordered permutation. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,1,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can make the permutation semi-ordered using these sequence of operations:\n1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3].\n2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].\n3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].\nIt can be proved that there is no sequence of less than three operations that make nums a semi-ordered permutation.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,4,2,5]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The permutation is already a semi-ordered permutation.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length == n &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i]&nbsp;&lt;= 50</code></li>\n\t<li><code>nums is a permutation.</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3595297,
                "title": "java-c-python-index-of-1-and-n",
                "content": "# **Explanation**\\nIf index of `1` is `i`,\\n`1` needs `i` swaps to be the first.\\n\\nIf index of `n` is `j`,\\n`n` needs `n - 1 - j` swaps to be the first.\\n\\nIf `i < j`,\\n`res` is `i + (n - 1 - j)`.\\n\\nIf `i > j`,\\n`res` is `i + (n - 1 - j) - 1`,\\nsave one swap when swap `1` and `n`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int semiOrderedPermutation(int[] A) {\\n        int n = A.length, i = 0, j = 0;\\n        for (int k = 0; k < n; k++) {\\n            if (A[k] == 1) i = k;\\n            if (A[k] == A.length) j = k;\\n        }\\n        return i + n - 1 - j - (i > j ? 1 : 0);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size(), i = find(A.begin(), A.end(), 1) - A.begin(), j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def semiOrderedPermutation(self, A: List[int]) -> int:\\n        n = len(A)\\n        i, j = A.index(1), A.index(n)\\n        return i + n - 1 - j - (i > j)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int semiOrderedPermutation(int[] A) {\\n        int n = A.length, i = 0, j = 0;\\n        for (int k = 0; k < n; k++) {\\n            if (A[k] == 1) i = k;\\n            if (A[k] == A.length) j = k;\\n        }\\n        return i + n - 1 - j - (i > j ? 1 : 0);\\n    }\\n```\n```cpp\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size(), i = find(A.begin(), A.end(), 1) - A.begin(), j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n```\n```py\\n    def semiOrderedPermutation(self, A: List[int]) -> int:\\n        n = len(A)\\n        i, j = A.index(1), A.index(n)\\n        return i + n - 1 - j - (i > j)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3595215,
                "title": "explained-iteration-very-simple-and-easy-to-understand",
                "content": "## Approach\\n1. Find the ith index of min val 1 => we need to do i operation to move 1 to first position\\n2. Find the ith index of the max val n => we need to do (n - i - 1) operation to take it to last position\\n3. Take the sum of above two as the answer. Only corner case is when the ith index of 1 is larger than ith index of n - in this case we need to reduce the ans by 1 as the 1 & n cna be swapped at the same time so that we count it as 1 operation in place of 2.\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int imin = 0, imax = nums.size(), n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] == 1) imin = i;\\n            if(nums[i] == n) imax = i;\\n        }\\n        if(imin < imax) return (imin + n - imax - 1);\\n        return (imin + n - imax - 1) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int imin = 0, imax = nums.size(), n = nums.size();\\n        for(int i = 0; i < n; ++i){\\n            if(nums[i] == 1) imin = i;\\n            if(nums[i] == n) imax = i;\\n        }\\n        if(imin < imax) return (imin + n - imax - 1);\\n        return (imin + n - imax - 1) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594901,
                "title": "find-positions",
                "content": "**C++**\\n```cpp\\nint semiOrderedPermutation(vector<int>& n) {\\n    int first = find(begin(n), end(n), 1) - begin(n);\\n    int last = find(begin(n), end(n), n.size()) - begin(n);\\n    return first + (n.size() - last - 1) - (first > last);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint semiOrderedPermutation(vector<int>& n) {\\n    int first = find(begin(n), end(n), 1) - begin(n);\\n    int last = find(begin(n), end(n), n.size()) - begin(n);\\n    return first + (n.size() - last - 1) - (first > last);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594970,
                "title": "long-but-easy-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function (nums) {\\n    const n = nums.length\\n    if (nums[0] === 1 && nums[n - 1] === n) return 0\\n    \\n    let cn = 0\\n    \\n    let i = nums.indexOf(1)\\n    while (nums[0] !== 1 && i >= 0) {\\n        const curr = nums[i - 1]\\n        \\n        nums[i - 1] = nums[i]\\n        nums[i] = curr\\n        \\n        i -= 1\\n        cn += 1\\n    }\\n    \\n    if (nums[0] === 1 && nums[n - 1] === n) return cn\\n    i = nums.indexOf(n)\\n    while (nums[n - 1] !== n && i < n) {\\n        const curr = nums[i]\\n        \\n        nums[i] = nums[i + 1]\\n        nums[i + 1] = curr\\n        \\n        i += 1\\n        cn += 1\\n    }\\n    \\n    return cn\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function (nums) {\\n    const n = nums.length\\n    if (nums[0] === 1 && nums[n - 1] === n) return 0\\n    \\n    let cn = 0\\n    \\n    let i = nums.indexOf(1)\\n    while (nums[0] !== 1 && i >= 0) {\\n        const curr = nums[i - 1]\\n        \\n        nums[i - 1] = nums[i]\\n        nums[i] = curr\\n        \\n        i -= 1\\n        cn += 1\\n    }\\n    \\n    if (nums[0] === 1 && nums[n - 1] === n) return cn\\n    i = nums.indexOf(n)\\n    while (nums[n - 1] !== n && i < n) {\\n        const curr = nums[i]\\n        \\n        nums[i] = nums[i + 1]\\n        nums[i + 1] = curr\\n        \\n        i += 1\\n        cn += 1\\n    }\\n    \\n    return cn\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597749,
                "title": "python-3-2-lines-w-brief-explanation-t-m-96-97",
                "content": "We first determine the indices `mn`and`mx`of two numbers being migrated to the ends of the list. Second, we count the number of steps required to move each, which are`mn`and`n-mx-1`. We check whether`mn > mx`, in which casethe two migrations share a step and we then correct by decrementing the sum by one. We return this sum.\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        mn, mx = nums.index(1) , nums.index(n:= len(nums))     \\n        return mn - mx + n - 1 - (mn > mx)\\n```\\n[https://leetcode.com/problems/semi-ordered-permutation/submissions/991660777/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        mn, mx = nums.index(1) , nums.index(n:= len(nums))     \\n        return mn - mx + n - 1 - (mn > mx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595007,
                "title": "java-easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int semiOrderedPermutation(int[] nums) {\\n    int n = nums.length, a = 0, b = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (nums[i] == 1) a = i;\\n      if (nums[i] == n) b = i;\\n    }\\n    return a + (n-1-b) - (a > b ? 1 : 0);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n  public int semiOrderedPermutation(int[] nums) {\\n    int n = nums.length, a = 0, b = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (nums[i] == 1) a = i;\\n      if (nums[i] == n) b = i;\\n    }\\n    return a + (n-1-b) - (a > b ? 1 : 0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595866,
                "title": "get-index-of-1-n-c",
                "content": "get index 1 and n\\na = index of 1;\\nb = index of n\\nif(index of 1 < index of n)\\n    than return a+n-1-b;\\nelse return a+n-1-b-n//there is we substracte previous ans by 1 because here one case is possible that we swap(1,n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int a,b,i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(nums[i]==1)a = i;\\n            else if(nums[i]==n)b = i;\\n        }\\n        if(a<b){\\n            return a+n-1-b;\\n        }else{\\n            return a+n-1-b-1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int a,b,i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(nums[i]==1)a = i;\\n            else if(nums[i]==n)b = i;\\n        }\\n        if(a<b){\\n            return a+n-1-b;\\n        }else{\\n            return a+n-1-b-1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594930,
                "title": "find-c",
                "content": "# Intuition\\n**Find Position of ```1``` and ```n```**\\n**```Result = ind_one + (n - ind_n + 1)```** (Calculating Swaps)\\n**But if ind_one is on left of ind_n, it means you one swap operation will be common for both i.e ```swap(1, n)``` so will do ```Result - 1```**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int ind_One = find(nums.begin(), nums.end(), 1) - nums.begin(), ind_N = find(nums.begin(), nums.end(), n) - nums.begin();\\n        int Result = ind_One + n - (ind_N + 1);\\n        if(ind_One > ind_N)    // One on left of N\\n            return Result - 1;\\n        return Result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```1```\n```n```\n```Result = ind_one + (n - ind_n + 1)```\n```swap(1, n)```\n```Result - 1```\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int ind_One = find(nums.begin(), nums.end(), 1) - nums.begin(), ind_N = find(nums.begin(), nums.end(), n) - nums.begin();\\n        int Result = ind_One + n - (ind_N + 1);\\n        if(ind_One > ind_N)    // One on left of N\\n            return Result - 1;\\n        return Result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597044,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)\\n        j=nums.index(n)\\n        ans=i+n-1-j-(i>j)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)\\n        j=nums.index(n)\\n        ans=i+n-1-j-(i>j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595606,
                "title": "c-easy-o-n-solution-w-intuition-code-finding-index",
                "content": "# Intuition\\nMy intuition for this problem was to know the number of swaps to change the position of a number. Our task is to move the smallest number to the start and the largest number to the end of the array.\\nTo move a number from index `i=5` to `j=0`, we need `i-j` swaps. So to move the minimum number from any index to the `0th index` we need as many number of swaps as the index of the min. number.\\nNow we need `n-1-i` swaps to move the largest number(positioned at $$i^{th}$$ index) to the `n-1 index` but there\\'s a catch if we do this after moving the min number.\\n\\nWe need to consider the fact that the largest number can come before the smallest number and that moving the smallest number has moved the largest number towards it\\'s desired location. So if the largest number\\'s index comes before the minimum number\\'s index, we use `n-1-i - 1` to indicate that it has to do one less swap itself. \\n\\n# Approach\\nThe approach is simple, we just find:\\n- index of minimum number `minIdx`\\n- index of maximum number `maxIdx`\\n\\nAnd use what we derived above:\\n- Swaps for moving minimum number, `smin`: `minIdx`\\n- Swaps for moving maximum number, `smax`: \\n1. `n-1-maxIdx` if `minIdx<maxIdx`\\n2. `n-1-maxIdx - 1` if `minIdx>maxIdx`\\n\\nSo,  Total number of swaps (our answer): `smin + smax`\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int minIdx{0};\\n        int maxIdx{0};\\n        for(int i=0; i<nums.size(); i++) {\\n            if (nums[i] < nums[minIdx])\\n                minIdx = i;\\n            if (nums[i] > nums[maxIdx])\\n                maxIdx = i;\\n        }\\n        int res{0};\\n        res += minIdx;\\n        res += nums.size()-1-maxIdx-(maxIdx<minIdx);\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nBecause we\\'re traversing the array once to find the indices of the minimum and the maximum number.\\n- Space complexity: $$O(1)$$\\n\\n\\n> ### Note\\n> - Upvote if you liked my solution\\n> - Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int minIdx{0};\\n        int maxIdx{0};\\n        for(int i=0; i<nums.size(); i++) {\\n            if (nums[i] < nums[minIdx])\\n                minIdx = i;\\n            if (nums[i] > nums[maxIdx])\\n                maxIdx = i;\\n        }\\n        int res{0};\\n        res += minIdx;\\n        res += nums.size()-1-maxIdx-(maxIdx<minIdx);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595196,
                "title": "python-3-easy-solution-compare-min-and-max-index",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\\n            return 0\\n        \\n        op = 0\\n        min_idx = nums.index(min(nums))\\n        max_idx = nums.index(max(nums))\\n        if min_idx < max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx)\\n        if min_idx > max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\\n        \\n        return op\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        \\n        if nums[0] == 1 and nums[len(nums) - 1] == len(nums):\\n            return 0\\n        \\n        op = 0\\n        min_idx = nums.index(min(nums))\\n        max_idx = nums.index(max(nums))\\n        if min_idx < max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx)\\n        if min_idx > max_idx:\\n            op = min_idx + (len(nums) - 1 - max_idx) - 1\\n        \\n        return op\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872501,
                "title": "java-beginner-friendly-solution-100-beats-fully-explained",
                "content": "# Approach\\n\\nTo convert the given permutation `nums` into a semi-ordered permutation, we need to perform swaps to move the number `1` to the first position and the number `n` to the last position. We can achieve this by finding the indices of `1` and `n` in the array and then calculating the number of operations required to move `1` to the first position and `n` to the last position.\\n\\n**Logic:**\\n1. Initialize two variables `count` and `idx` to keep track of the number of operations and the index of `1` in the array, respectively.\\n2. Loop through the array to find the index of the number `1`. Set `idx` to this index.\\n3. Calculate the number of operations required to move `1` to the first position. Set `count` to `idx`.\\n4. While the number at the first position is not `1`, swap the elements at indices `idx` and `idx-1` to move `1` towards the first position. Decrement `idx` by 1 after each swap.\\n5. Loop through the array again to find the index of the number `n`. Set `idx` to this index.\\n6. Calculate the number of operations required to move `n` to the last position. Return `count + n - idx - 1`, which represents the total number of operations needed to make `nums` a semi-ordered permutation.\\n\\n**Pseudocode:**\\n```plaintext\\nFunction semiOrderedPermutation(nums):\\n    n = length of nums\\n    count = 0\\n    idx = 0\\n    \\n    # Find the index of 1 in nums\\n    for i = 0 to n-1:\\n        if nums[i] == 1:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move 1 to the first position\\n    count = idx\\n    \\n    # Move 1 to the first position using swaps\\n    while nums[0] != 1:\\n        swap nums[idx] and nums[idx-1]\\n        idx = idx - 1\\n    \\n    # Find the index of n in nums\\n    for i = 0 to n-1:\\n        if nums[i] == n:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move n to the last position\\n    return count + n - idx - 1\\n```\\n\\n**Final Remarks:**\\nThe provided solution follows the above approach and logic to solve the problem. It efficiently moves the number `1` to the first position and the number `n` to the last position, minimizing the number of swaps needed. The solution is clear and concise, making it easy for beginners to understand and implement.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        int idx = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        count = idx;\\n\\n        while (nums[0] != 1) {\\n            nums[idx] = nums[idx - 1];\\n            nums[idx - 1] = 1;\\n            idx--;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == n) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        return count + n - idx - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Simulation"
                ],
                "code": "```plaintext\\nFunction semiOrderedPermutation(nums):\\n    n = length of nums\\n    count = 0\\n    idx = 0\\n    \\n    # Find the index of 1 in nums\\n    for i = 0 to n-1:\\n        if nums[i] == 1:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move 1 to the first position\\n    count = idx\\n    \\n    # Move 1 to the first position using swaps\\n    while nums[0] != 1:\\n        swap nums[idx] and nums[idx-1]\\n        idx = idx - 1\\n    \\n    # Find the index of n in nums\\n    for i = 0 to n-1:\\n        if nums[i] == n:\\n            idx = i\\n            break\\n    \\n    # Calculate the number of operations to move n to the last position\\n    return count + n - idx - 1\\n```\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        int idx = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        count = idx;\\n\\n        while (nums[0] != 1) {\\n            nums[idx] = nums[idx - 1];\\n            nums[idx - 1] = 1;\\n            idx--;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == n) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        return count + n - idx - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606110,
                "title": "c-java-determining-the-positions-of-1-and-n",
                "content": "\\nDetermine the locations of `1` and `N`, labelled as `one_index` and `n_index` respectively. The number of swaps needed to reposition `1` at the start is equivalent to `one_index`, and similarly, to move `N` to the final position, `N - 1 - n_index` swaps are required. \\n\\nHowever, should `1` be located to the right of `N`, then as `1` is moved towards the 0th position, it would swap places with `N`, thereby bringing `N` a step closer to its desired final position. This would therefore require one less swap, i.e., `N - 1 - n_index - 1` to relocate `N` to the end. Consequently, if `1` is to the right of `N`, we need to subtract 1 from the total swap count.\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int one_index = 0, n_index = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) one_index = i;\\n            else if (nums[i] == n) n_index = i;\\n        }\\n        return one_index + n - 1 - n_index - (one_index < n_index ? 0 : 1);\\n    }\\n};\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = 0, nIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) oneIndex = i;\\n            else if (nums[i] == n) nIndex = i;\\n        }\\n        return oneIndex + n - 1 - nIndex - (oneIndex < nIndex ? 0 : 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int one_index = 0, n_index = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) one_index = i;\\n            else if (nums[i] == n) n_index = i;\\n        }\\n        return one_index + n - 1 - n_index - (one_index < n_index ? 0 : 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = 0, nIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) oneIndex = i;\\n            else if (nums[i] == n) nIndex = i;\\n        }\\n        return oneIndex + n - 1 - nIndex - (oneIndex < nIndex ? 0 : 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600932,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the position of 1 and the n in the nums which will take o(n)\\ni have used find but simple iteration can also be done to find the pos of both the elements \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the pos of both the element using simple iteration or find \\n2. Their are only two case which we have to see now \\n             i.pos_1 < pos_2\\n             ii. pos_1 > pos_2\\n3. For case i we simple add the no of swaps need for both the element to reach their respective position \\n4. for case ii we do the same as for case i but subtract 1 from it as when we were swaping elements for 1 as the pos_2 < pos_1 then the n element must have shifted by one toward its destination so -1 to the ans\\n# Complexity\\n- Time complexity:\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int pos_1 = find(nums.begin(),nums.end(),1) - nums.begin();\\n        int pos_2 = find(nums.begin(),nums.end(),n) - nums.begin();\\n        return (pos_1<pos_2) ?(pos_1 +  n-1-pos_2):(pos_1 + (n-1 - pos_2) - (1));\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int pos_1 = find(nums.begin(),nums.end(),1) - nums.begin();\\n        int pos_2 = find(nums.begin(),nums.end(),n) - nums.begin();\\n        return (pos_1<pos_2) ?(pos_1 +  n-1-pos_2):(pos_1 + (n-1 - pos_2) - (1));\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599250,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int mini=0;\\n        int maxi=0;\\n        int n=nums.size();\\n        for(int i=0 ; i < n ; i++){\\n            if(nums[i]==1){\\n                mini=i;\\n            }\\n            else if(nums[i]==n){\\n                maxi=i;\\n            }\\n        }\\n        if(mini>maxi){\\n            maxi=(n-1)-(maxi+1);\\n        }\\n        else{\\n            maxi=(n-1)-maxi;\\n        }\\n        return mini+maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int mini=0;\\n        int maxi=0;\\n        int n=nums.size();\\n        for(int i=0 ; i < n ; i++){\\n            if(nums[i]==1){\\n                mini=i;\\n            }\\n            else if(nums[i]==n){\\n                maxi=i;\\n            }\\n        }\\n        if(mini>maxi){\\n            maxi=(n-1)-(maxi+1);\\n        }\\n        else{\\n            maxi=(n-1)-maxi;\\n        }\\n        return mini+maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595395,
                "title": "simple-java-o-n-solution",
                "content": "# Approach\\n- Get the index of 1 and N\\n- Number of swaps would be sum of difference between index of 1 and 0 and difference between index of N and last index.\\n- If position of N is before 1, then we require 1 less swap\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int indexOne = -1;\\n        int indexN = -1;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 1)\\n                indexOne = i;\\n            if(nums[i] == nums.length)\\n                indexN = i;\\n        }\\n        \\n        int count = 0;\\n        if(indexOne > indexN)\\n            count--;\\n        \\n        count += indexOne + (nums.length - 1 - indexN);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int indexOne = -1;\\n        int indexN = -1;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] == 1)\\n                indexOne = i;\\n            if(nums[i] == nums.length)\\n                indexN = i;\\n        }\\n        \\n        int count = 0;\\n        if(indexOne > indexN)\\n            count--;\\n        \\n        count += indexOne + (nums.length - 1 - indexN);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595158,
                "title": "o-n-very-easy-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Just find the idex of 1 and the index of maximum number. \\n    If the index of 1 > index of max number, it will take one swap less \\n    if(idx1>idx){\\n        idx1=idx1-1;\\n        }\\n    The answer will be (nums.length-1-idx) + idx1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        int idx=0,idx1=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n                idx=i;\\n            }\\n            if(nums[i]==1){\\n                idx1=i;\\n            }\\n        }\\n        if(idx1>idx){\\n            idx1=idx1-1;\\n        }\\n        return (nums.length-1-idx) + idx1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        int idx=0,idx1=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n                idx=i;\\n            }\\n            if(nums[i]==1){\\n                idx1=i;\\n            }\\n        }\\n        if(idx1>idx){\\n            idx1=idx1-1;\\n        }\\n        return (nums.length-1-idx) + idx1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594957,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int opr = 0, j = 0;\\n//         finding 1\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == 1)    j = i;\\n//         operating 1 to start index\\n        while(j > 0){\\n            nums[j] = nums[j-1];\\n            nums[j-1] = 1;\\n            opr++;\\n            j--;\\n        }\\n//         finding n\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == nums.length)    j = i;\\n//         operating n to last index\\n        while(j < nums.length-1){\\n            nums[j] = nums[j+1];\\n            nums[j+1] = nums.length;\\n            opr++;\\n            j++;\\n        }   \\n        return opr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int opr = 0, j = 0;\\n//         finding 1\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == 1)    j = i;\\n//         operating 1 to start index\\n        while(j > 0){\\n            nums[j] = nums[j-1];\\n            nums[j-1] = 1;\\n            opr++;\\n            j--;\\n        }\\n//         finding n\\n        for(int i=0; i<nums.length; i++)    \\n            if(nums[i] == nums.length)    j = i;\\n//         operating n to last index\\n        while(j < nums.length-1){\\n            nums[j] = nums[j+1];\\n            nums[j+1] = nums.length;\\n            opr++;\\n            j++;\\n        }   \\n        return opr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909979,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the given 0-indexed array, we are allowed to perform swap on any two adjacent elements unit we make array nums a semi-ordered permutation.\\nwe can perform swap on element valued 1 till it reaches index 0.\\nSimilarly, we perform swap on element valued n (which is also the size of the array nums) till it reaches the last index that is (n-1).\\nWe return the number of swaps required in this process.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int cnt=0;\\n        bool f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                       swap(nums[i],nums[i+1]);\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                       swap(nums[i], nums[i-1]);\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int cnt=0;\\n        bool f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                       swap(nums[i],nums[i+1]);\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                       swap(nums[i], nums[i-1]);\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672706,
                "title": "2-c-solutions-beginner-friendly-approach-with-and-without-vector-find",
                "content": "\\n# Code\\n```\\n// Soution 1 (With find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size();\\n        int i = find(A.begin(), A.end(), 1) - A.begin(); \\n        int j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n}\\n\\n// Solution 2 (Without find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size(), count=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1){\\n                count+=i;\\n                for(int j=i; j>0; j--)\\n                    swap(nums[j], nums[j-1]); // we swap the numbers so that the later considering the case when 1 comes after n-1 because count will get repeated for such cases\\n                break;\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==n){ \\n                count+=(n-1)-i;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Soution 1 (With find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& A) {\\n        int n = A.size();\\n        int i = find(A.begin(), A.end(), 1) - A.begin(); \\n        int j = find(A.begin(), A.end(), n) - A.begin();\\n        return i + n - 1 - j - (i > j);\\n    }\\n}\\n\\n// Solution 2 (Without find())\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size(), count=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1){\\n                count+=i;\\n                for(int j=i; j>0; j--)\\n                    swap(nums[j], nums[j-1]); // we swap the numbers so that the later considering the case when 1 comes after n-1 because count will get repeated for such cases\\n                break;\\n            }\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==n){ \\n                count+=(n-1)-i;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672586,
                "title": "simple-code-c",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int start,end;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] == 1)\\n                start = i;\\n            if(nums[i] == n)\\n                end = i;\\n        }\\n        if(start > end)\\n            return start + n - end - 2;\\n        else \\n            return start + n - end-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int start,end;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] == 1)\\n                start = i;\\n            if(nums[i] == n)\\n                end = i;\\n        }\\n        if(start > end)\\n            return start + n - end - 2;\\n        else \\n            return start + n - end-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672114,
                "title": "c-2-pointer-solution-7ms-46-3mb",
                "content": "For this problem we have to just find the indexes of `1` and the value matching length of `nums`, then check how far they are from being in the first and in the last position - with a caveat: if the first position is `>` than the last one, when we start swapping one of the indexes we will put the latter closer to its position, so we need to take that into account.\\n\\nNow, to code our solution, let\\'s start with declaring our support variables:\\n* `len` will store the length of `nums`;\\n* `p1` and `p2` will be where we store the positions of the values `1` and `len` respectively, both initially set to be `-1`.\\n\\nWe will then loop with `i` across all the positions in `nums` until we have found both pointers (ie: `p1 == -1 || p2 == -1`) and:\\n* store `nums[i]` in `n`;\\n* if `n == 1`, we will set `p1` to be `i`;\\n* otherwise, if `n == len`, we will set `p2` to be `i`.\\n\\nOnce done, we will `return` the sum of the distances of `p1` from the first position (ie: `p1 - 0`) and `p2` from the last position (ie: `len - p2 - 1`), adjusted by `-1` as we mentioned in our incipit if `p1 > p2`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), p1 = -1, p2 = -1;\\n        // parsing nums\\n        for (int i = 0, n; p1 == -1 || p2 == -1; i++) {\\n            n = nums[i];\\n            if (n == 1) p1 = i;\\n            else if (n == len) p2 = i;\\n        }\\n        return (p1 > p2 ? -1 : 0) + p1 + len - p2 - 1;\\n    }\\n};\\n```\\n\\nAlternative version of that logic, working directly with a variable result `res` and a boolean flag `foundOne` to check if we had already found the other index before. Notice that now we need to do one less check at each loop iteration and that we use `foundOne` in the `else if` clause to decrease the value of `res` by `1` if we had found `1` before `len`; overall, this version seemed to perform a bit better:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), res = 0;\\n        bool foundOne = false;\\n        // parsing nums\\n        for (int i = 0, n; ; i++) {\\n            n = nums[i];\\n            if (n == 1) {\\n                res += i;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n            else if (n == len) {\\n                res += len - i - 1 - !foundOne;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), p1 = -1, p2 = -1;\\n        // parsing nums\\n        for (int i = 0, n; p1 == -1 || p2 == -1; i++) {\\n            n = nums[i];\\n            if (n == 1) p1 = i;\\n            else if (n == len) p2 = i;\\n        }\\n        return (p1 > p2 ? -1 : 0) + p1 + len - p2 - 1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), res = 0;\\n        bool foundOne = false;\\n        // parsing nums\\n        for (int i = 0, n; ; i++) {\\n            n = nums[i];\\n            if (n == 1) {\\n                res += i;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n            else if (n == len) {\\n                res += len - i - 1 - !foundOne;\\n                if (foundOne) break;\\n                foundOne = true;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626499,
                "title": "simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n        for (int x = 0; x<n; x++) {\\n            if (nums[x] == 1) i = x;\\n            if (nums[x] == n) j = x;\\n        }\\n\\n        if (j < i) return i + n-j-2;\\n        return i + n-j-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n        for (int x = 0; x<n; x++) {\\n            if (nums[x] == 1) i = x;\\n            if (nums[x] == n) j = x;\\n        }\\n\\n        if (j < i) return i + n-j-2;\\n        return i + n-j-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624244,
                "title": "formula-based-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int mx=0, mxidx=0;\\n        int mn=INT_MAX, mnidx;\\n        int count=0;\\n\\n        for(int i=0; i<n; i++){\\n            mx=max(mx, nums[i]);\\n            if(nums[i]==mx) mxidx=i;\\n\\n            mn=min(mn, nums[i]);\\n            if(nums[i]==mn) mnidx=i;\\n        }\\n        \\n        count=n+mnidx-mxidx-1;\\n        if(mnidx<mxidx) return count;\\n        return --count;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int mx=0, mxidx=0;\\n        int mn=INT_MAX, mnidx;\\n        int count=0;\\n\\n        for(int i=0; i<n; i++){\\n            mx=max(mx, nums[i]);\\n            if(nums[i]==mx) mxidx=i;\\n\\n            mn=min(mn, nums[i]);\\n            if(nums[i]==mn) mnidx=i;\\n        }\\n        \\n        count=n+mnidx-mxidx-1;\\n        if(mnidx<mxidx) return count;\\n        return --count;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600574,
                "title": "super-easy-solution-with-simple-logic-store-positions",
                "content": "# Intuition\\nSince we have to swap adjacent numbers to fulfil the given condition ,we will store the psoiton of 1 and the last number by iterating through loop. After the answer will be total number of swaps,hence we will add the number of swaps with the help of their positions.\\nBut if the last number i.e. n is present before the number 1 both of the them reach their destinantion simultaneously ,hence we will decrease the answer by 1.\\n\\n# Approach\\n- We will store the two psoitons in variables f and l.\\n- We will store the answer i.e. total number of swaps in variable\\n```\\nint ans=f+(n-1-l);\\n```\\n- We will check for the condition (mentioned in Intuiton above) and decrement answer by 1 if it is there.\\n```\\nif(l<f)\\n{\\n    ans=ans-1;\\n}\\n```\\n- Return the answer.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:It will be O(n) because of for loop.\\n\\n\\n- Space complexity:It wil be O(1) .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int f=0,l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                f=i;\\n            }\\n            if(nums[i]==n)\\n            {\\n                l=i;\\n            }\\n        }\\n        int ans=f+(n-1-l);\\n        if(l<f)\\n        {\\n            ans=ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if it helps!",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nint ans=f+(n-1-l);\\n```\n```\\nif(l<f)\\n{\\n    ans=ans-1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int f=0,l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                f=i;\\n            }\\n            if(nums[i]==n)\\n            {\\n                l=i;\\n            }\\n        }\\n        int ans=f+(n-1-l);\\n        if(l<f)\\n        {\\n            ans=ans-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597605,
                "title": "java-solution-beats-100-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int semiOrder(int nums[], int count) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length) {\\n            return count;\\n        }\\n        else if(nums[0]==1) {\\n            for(int i=0; i<nums.length-1; i++) {\\n                if(nums[i]==nums.length) {\\n                    nums[i]=nums[i+1];\\n                    nums[i+1]=nums.length;\\n                    break;\\n                }\\n            }\\n        }\\n        else {\\n            for(int i=1; i<nums.length; i++) {\\n                if(nums[i]==1) {\\n                    nums[i]=nums[i-1];\\n                    nums[i-1]=1;\\n                    break;\\n                }\\n            }\\n        }\\n        return semiOrder(nums,count+1);\\n    }\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        return semiOrder(nums, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int semiOrder(int nums[], int count) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length) {\\n            return count;\\n        }\\n        else if(nums[0]==1) {\\n            for(int i=0; i<nums.length-1; i++) {\\n                if(nums[i]==nums.length) {\\n                    nums[i]=nums[i+1];\\n                    nums[i+1]=nums.length;\\n                    break;\\n                }\\n            }\\n        }\\n        else {\\n            for(int i=1; i<nums.length; i++) {\\n                if(nums[i]==1) {\\n                    nums[i]=nums[i-1];\\n                    nums[i-1]=1;\\n                    break;\\n                }\\n            }\\n        }\\n        return semiOrder(nums,count+1);\\n    }\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        return semiOrder(nums, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596789,
                "title": "easiest-implementation",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx1,idxN;\\n        for(int i=0 ; i<n ; i++) {\\n            if(nums[i] == 1) idx1 = i;\\n            if(nums[i] == n) idxN = i;\\n        }\\n        \\n        int ans = idx1 + n-1-idxN;\\n        if(idxN < idx1) ans--; // one common swap\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx1,idxN;\\n        for(int i=0 ; i<n ; i++) {\\n            if(nums[i] == 1) idx1 = i;\\n            if(nums[i] == n) idxN = i;\\n        }\\n        \\n        int ans = idx1 + n-1-idxN;\\n        if(idxN < idx1) ans--; // one common swap\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596433,
                "title": "step-by-step-explanation-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**We just need to find the index of both the elements min element=1\\nand maxelement=nums.size();**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# There are two cases only\\n1. If location of max element  is right to location of minimum  element like **[2,3,1,7,6,5,4]** *here 7 is at right of 1*\\nin this case answer is **n-maxIndex+minindex** i.e \\n**Index of 7 is 3 index of 1 is 2 and n=6 (last index of array)**\\n    6-3+2=5\\n\\n\\n2. If location of max is left of location of minimum like **[2,3,7,4,5,1,6]**\\nin this case answer is **n-maxIndex+minIndex-1** i.e \\n**Index of 7 is 2 index of 1 is 5 and n=6 (last index of array)**\\n 6-2+5-1=8\\n\\n### here 1 is subtracted because when we swap max element with elements to put it at right place it will be swapped once with min elelment\\n**[2,3,7,4,5,1,6]**\\nhere ist swap **[2,3,4,7,5,1,6]**\\nhere 2nd swap **[2,3,4,5,7,1,6]**\\nhere 3rd swap **[2,3,4,5,1,7,6]**\\n**Now look here the minimum element is changing it\\'s postion\\nSo -1 is done to count this** \\n\\n\\n\\n\\n**Here 7 is max element\\n 1 is min element**\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$  Constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n               int min=-1,max=-1,ans;\\n               int n=nums.size()-1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==1)\\n                        {\\n                min=i;\\n                        } //if\\n            if(nums[i]==nums.size())\\n                       {\\n                        max=i;\\n                            }//if\\n                \\n        if(min!=-1&&max!=-1){break;}//to break the loop \\n        }//for\\n        ans=min+(n-max);\\n        if(max<min) \\n             {\\n             return ans-1;\\n             }\\n    \\n     return ans; \\n        \\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max = Arrays.stream(nums).max().getAsInt();\\n        int indexMin=0;\\n        int indexMax=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indexMin=i;\\n            }\\n            if(nums[i]==max){\\n                indexMax=i;\\n            }\\n        }\\n        if(indexMax<indexMin){\\n            return indexMin + nums.length-1 -indexMax-1;\\n        }\\n        else{\\n            return indexMin + nums.length-1 -indexMax;\\n        }\\n        \\n    }\\n}\\n```\\n# UPVOTE IF IT\\'S HELPFUL\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n               int min=-1,max=-1,ans;\\n               int n=nums.size()-1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==1)\\n                        {\\n                min=i;\\n                        } //if\\n            if(nums[i]==nums.size())\\n                       {\\n                        max=i;\\n                            }//if\\n                \\n        if(min!=-1&&max!=-1){break;}//to break the loop \\n        }//for\\n        ans=min+(n-max);\\n        if(max<min) \\n             {\\n             return ans-1;\\n             }\\n    \\n     return ans; \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max = Arrays.stream(nums).max().getAsInt();\\n        int indexMin=0;\\n        int indexMax=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indexMin=i;\\n            }\\n            if(nums[i]==max){\\n                indexMax=i;\\n            }\\n        }\\n        if(indexMax<indexMin){\\n            return indexMin + nums.length-1 -indexMax-1;\\n        }\\n        else{\\n            return indexMin + nums.length-1 -indexMax;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596035,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        a=nums.index(min(nums))\\n        b=nums.index(max(nums))\\n        if b<a:\\n            return a+(len(nums)-1-b)-1\\n        else:\\n            return a+(len(nums)-1-b)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        a=nums.index(min(nums))\\n        b=nums.index(max(nums))\\n        if b<a:\\n            return a+(len(nums)-1-b)-1\\n        else:\\n            return a+(len(nums)-1-b)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595718,
                "title": "c-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int l = 0 , r = n - 1;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(nums[i] == 1) l = i;\\n\\n            if(nums[i] == n) r = i; \\n        }\\n\\n        if(r < l){\\n            return l + (n-1-r) - 1;\\n        }\\n\\n        return l + (n-1-r);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int l = 0 , r = n - 1;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(nums[i] == 1) l = i;\\n\\n            if(nums[i] == n) r = i; \\n        }\\n\\n        if(r < l){\\n            return l + (n-1-r) - 1;\\n        }\\n\\n        return l + (n-1-r);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595687,
                "title": "positions-solution-for-c-explanation-complexity",
                "content": "# Approach\\nThe idea is to find the positions of the element with a value 1 and the element with a value n.\\n* The first position is the number of iterations needed to move an element from its current position to the zero position.\\n* The (nums.length - second position) is the number of iterations needed to move an element from its current position to the last position.\\n\\nThe corner case is when the first position is larger than the second one. So, we use one swap to change both elements at once.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic int SemiOrderedPermutation(int[] nums)\\n{\\n    var leftIndex = -1;\\n    var rightIndex = -1;\\n\\n    // Find positions\\n    for (var i = 0; i < nums.Length; i++)\\n    {\\n        if (nums[i] == 1)\\n        {\\n            leftIndex = i;\\n        }\\n        else if (nums[i] == nums.Length)\\n        {\\n            rightIndex = i;\\n        }\\n        else if (leftIndex != -1 && rightIndex != -1)\\n        {\\n            break;\\n        }\\n    }\\n\\n    // Check if already semi-ordered\\n    if (leftIndex == 0 && rightIndex == nums.Length - 1)\\n    {\\n        return 0;\\n    }\\n\\n    // Calc number of iterations\\n    return leftIndex + (nums.Length - rightIndex - 1) + (leftIndex > rightIndex ? -1 : 0);\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int SemiOrderedPermutation(int[] nums)\\n{\\n    var leftIndex = -1;\\n    var rightIndex = -1;\\n\\n    // Find positions\\n    for (var i = 0; i < nums.Length; i++)\\n    {\\n        if (nums[i] == 1)\\n        {\\n            leftIndex = i;\\n        }\\n        else if (nums[i] == nums.Length)\\n        {\\n            rightIndex = i;\\n        }\\n        else if (leftIndex != -1 && rightIndex != -1)\\n        {\\n            break;\\n        }\\n    }\\n\\n    // Check if already semi-ordered\\n    if (leftIndex == 0 && rightIndex == nums.Length - 1)\\n    {\\n        return 0;\\n    }\\n\\n    // Calc number of iterations\\n    return leftIndex + (nums.Length - rightIndex - 1) + (leftIndex > rightIndex ? -1 : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595436,
                "title": "easy-understanding-with-intuition-and-approach-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI got to reach the solution with the help of some examples\\nYou may understand with the help of:-\\nexample 1: arr1=[2,1,4,3]\\n- first thing to observe is that the position of 1 and n are such that 1 appears before n\\n- we see that we have to swap the elements [((n-1)-position of n)+(position of first-0)]number of times\\n\\nexample 2: arr2=[2,4,1,3]\\n- first thing to observe is that the position of 1 and n are such that 1 appears after n\\n- we see that we have to swap the elements [((n-1)-position of n)+(position of first-0)]number of times\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. store the index of 1 and n\\n2. let us say index of 1 = first and n=last\\n3. the value of ans will be=((n-1)-last)+(first-0)\\n4. check if first > last\\n5. if so then decrease the value of answer(because we can see that we will be swapping once less as there will be a condition when 1 and n will be swapped,so need to count this just once)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& arr) {\\n        int n=arr.size();\\n        int first=-1,last=-1;\\n        //first store the index of 1 and n\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==n)last=i;\\n            if(arr[i]==1)first=i;\\n        }\\n        //now when we observe the solution with a few examples we get to know that there are two cases\\n        int ans=-1;\\n        if(last<first){\\n            ans=((n-1)-last)+(first-0);\\n            ans--;\\n        }\\n        else{\\n            ans=((n-1)-last)+(first-0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& arr) {\\n        int n=arr.size();\\n        int first=-1,last=-1;\\n        //first store the index of 1 and n\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==n)last=i;\\n            if(arr[i]==1)first=i;\\n        }\\n        //now when we observe the solution with a few examples we get to know that there are two cases\\n        int ans=-1;\\n        if(last<first){\\n            ans=((n-1)-last)+(first-0);\\n            ans--;\\n        }\\n        else{\\n            ans=((n-1)-last)+(first-0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595386,
                "title": "python3-solution-find-position",
                "content": "# Intuition\\nFind the position of 1 and n in the nums let say l and r resp., no. of swaps required to make l the first-number is `l` since we need to swap all the elements with 1 from index l to 0, Similarly for n be the last-number we required `n - r - 1` swaps.\\nBut there\\'s a catch if the index of n is less than 1 than we need to `subtract 1` from ans, as 1 swap is counted twice. When 1 and n are adjacent to each other after some operation\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = nums.index(1), nums.index(n)\\n        return l + n - r - 1 - (1 if r < l else 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = nums.index(1), nums.index(n)\\n        return l + n - r - 1 - (1 if r < l else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595368,
                "title": "2-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums.index(len(nums))<nums.index(1):return (len(nums)-1-nums.index(len(nums)))+nums.index(1)-1\\n        else:return (len(nums)-1-nums.index(len(nums)))+nums.index(1)\\n       \\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums.index(len(nums))<nums.index(1):return (len(nums)-1-nums.index(len(nums)))+nums.index(1)-1\\n        else:return (len(nums)-1-nums.index(len(nums)))+nums.index(1)\\n       \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595310,
                "title": "easy-c-solution-observation-based",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(nums[0] == 1 and nums[nums.size() - 1] == nums.size()) {\\n            return 0;\\n        }\\n        \\n        int pos1 = -1;\\n        int pos2 = -1;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == 1) {\\n                pos1 = i;\\n            }\\n            if(nums[i] == n) {\\n                pos2 = i;\\n            }\\n        }\\n        int ans = 0;\\n        if(pos1 < pos2) {\\n           ans = pos1 + (n - 1 - pos2); \\n        }\\n        \\n        if(pos1 > pos2) {\\n            int temp = pos1 - pos2;\\n            pos1 = pos2;\\n            pos2 = pos1 + 1;\\n            \\n            ans = pos1 + (n-1-pos2) + temp;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(nums[0] == 1 and nums[nums.size() - 1] == nums.size()) {\\n            return 0;\\n        }\\n        \\n        int pos1 = -1;\\n        int pos2 = -1;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == 1) {\\n                pos1 = i;\\n            }\\n            if(nums[i] == n) {\\n                pos2 = i;\\n            }\\n        }\\n        int ans = 0;\\n        if(pos1 < pos2) {\\n           ans = pos1 + (n - 1 - pos2); \\n        }\\n        \\n        if(pos1 > pos2) {\\n            int temp = pos1 - pos2;\\n            pos1 = pos2;\\n            pos2 = pos1 + 1;\\n            \\n            ans = pos1 + (n-1-pos2) + temp;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595300,
                "title": "simplest-solution-in-java-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int c=0;\\n        while(nums[0]!=1){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                int t=nums[i];\\n                nums[i]=nums[i-1];\\n                nums[i-1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        while(nums[nums.length-1]!=nums.length){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==nums.length){\\n                int t=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        return c;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int c=0;\\n        while(nums[0]!=1){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                int t=nums[i];\\n                nums[i]=nums[i-1];\\n                nums[i-1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        while(nums[nums.length-1]!=nums.length){\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==nums.length){\\n                int t=nums[i];\\n                nums[i]=nums[i+1];\\n                nums[i+1]=t;\\n                c++;\\n                break;\\n\\n            }\\n        }\\n        }\\n        return c;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595277,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx,idx2;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==1) idx=i;\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        int ans=0;\\n        for(int i = idx;i>=0;i--){\\n            if(i==0) break;\\n            swap(nums[i],nums[i-1]);\\n            ans++;\\n        }\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        for(int i = idx2;i<nums.size();i++){\\n            if(i==nums.size()-1) break;\\n            swap(nums[i],nums[i+1]);\\n            ans++;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx,idx2;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==1) idx=i;\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        int ans=0;\\n        for(int i = idx;i>=0;i--){\\n            if(i==0) break;\\n            swap(nums[i],nums[i-1]);\\n            ans++;\\n        }\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==nums.size()) idx2=i;\\n        }\\n        for(int i = idx2;i<nums.size();i++){\\n            if(i==nums.size()-1) break;\\n            swap(nums[i],nums[i+1]);\\n            ans++;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595229,
                "title": "explained-cpp-solution",
                "content": "Certainly! Here\\'s an explanation of the code with comments:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();  // Get the size of the input vector\\n        int s = 0;  // Initialize variable s to store the index of value 1\\n        int e = 0;  // Initialize variable e to store the index of value n\\n\\n        // Loop through each element of the vector\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];  // Get the current element\\n\\n            // Check if the current element is equal to 1 or n\\n            if (val == 1 || val == n) {\\n                if (val == 1) {\\n                    s = i;  // If the element is 1, update s with the current index\\n                } else {\\n                    e = i;  // If the element is n, update e with the current index\\n                }\\n            }\\n        }\\n\\n        int diff = n - e;  // Calculate the difference between n and e\\n        diff--;  // Subtract 1 from diff\\n\\n        int ans = s + diff;  // Calculate ans by adding s and diff\\n\\n        // If s is greater than e, subtract 1 from ans\\n        if (s > e) {\\n            ans--;\\n        }\\n\\n        return ans;  // Return the final ans value\\n    }\\n};\\n```\\n\\nI hope this helps! Let me know if you have any further questions.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();  // Get the size of the input vector\\n        int s = 0;  // Initialize variable s to store the index of value 1\\n        int e = 0;  // Initialize variable e to store the index of value n\\n\\n        // Loop through each element of the vector\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];  // Get the current element\\n\\n            // Check if the current element is equal to 1 or n\\n            if (val == 1 || val == n) {\\n                if (val == 1) {\\n                    s = i;  // If the element is 1, update s with the current index\\n                } else {\\n                    e = i;  // If the element is n, update e with the current index\\n                }\\n            }\\n        }\\n\\n        int diff = n - e;  // Calculate the difference between n and e\\n        diff--;  // Subtract 1 from diff\\n\\n        int ans = s + diff;  // Calculate ans by adding s and diff\\n\\n        // If s is greater than e, subtract 1 from ans\\n        if (s > e) {\\n            ans--;\\n        }\\n\\n        return ans;  // Return the final ans value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595214,
                "title": "semi-order-permutation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        int i=0;\\n        while(i<n){\\n            if(nums[0]==1){\\n                break;\\n            }\\n            if(nums[i]==1&&i!=0){\\n                swap(nums[i],nums[i-1]);\\n                count++;\\n                i--;\\n            }\\n            else i++;\\n        }\\n        int value=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==n)value=i;\\n        }\\n        return count+n-value-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        int i=0;\\n        while(i<n){\\n            if(nums[0]==1){\\n                break;\\n            }\\n            if(nums[i]==1&&i!=0){\\n                swap(nums[i],nums[i-1]);\\n                count++;\\n                i--;\\n            }\\n            else i++;\\n        }\\n        int value=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==n)value=i;\\n        }\\n        return count+n-value-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595139,
                "title": "o-n-approach-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0] == 1 && nums[n-1] == n)\\n            return 0;\\n        int lo = 0, hi = n-1;\\n        for(int i = 0;i  < n; i++){\\n            if(nums[i] == 1){\\n                lo = i;\\n            }\\n            if(nums[i] == n){\\n                hi = i;\\n            }\\n        }\\n        int ans;\\n        if(lo > hi){\\n            ans = lo + abs(n-1-hi-1);\\n        }\\n        else{\\n            ans = lo + abs(n-1-hi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0] == 1 && nums[n-1] == n)\\n            return 0;\\n        int lo = 0, hi = n-1;\\n        for(int i = 0;i  < n; i++){\\n            if(nums[i] == 1){\\n                lo = i;\\n            }\\n            if(nums[i] == n){\\n                hi = i;\\n            }\\n        }\\n        int ans;\\n        if(lo > hi){\\n            ans = lo + abs(n-1-hi-1);\\n        }\\n        else{\\n            ans = lo + abs(n-1-hi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595108,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code works based on the intuition that for a semi-ordered permutation, we need to bring the number 1 to the front of the array and the maximum number to the end. The number of elements between these two positions represents the elements that need to be rearranged. By finding the positions of 1 and the maximum number, the code calculates the answer accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses two pointers, l and r, to keep track of the positions of specific numbers in the array.\\n\\nIt iterates over the elements of the array to find the last occurrences of the numbers 1 and the maximum number.\\n\\nIt calculates the answer by adding the position of the last occurrence of 1 (l) and the number of elements between the right pointer (r) and the end of the array.\\n\\nIf there are duplicate elements between the two pointers (l > r), it adjusts the answer by decrementing it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the size of the input array nums. This is because the code iterates over the array once to find the positions of 1 and the maximum number. The time taken is directly proportional to the size of the input array. Therefore, the time complexity is linear with respect to the input size.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1), as it uses a constant amount of extra space to store the left pointer (l), the right pointer (r), and the answer. The space usage does not depend on the size of the input array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int semiOrderedPermutation(vector<int>& nums) {\\n    int l = 0, r = 0;\\n    for(int i = 0; i < nums.size(); i++) {\\n        if(nums[i] == 1)\\n            l = i; // Update the left pointer if the current number is 1\\n        if(nums[i] == nums.size())\\n            r = i; // Update the right pointer if the current number is equal to the size of the array\\n    }\\n    int ans = l + (nums.size() - 1 - r); // Calculate the answer by adding the left pointer position and the number of elements between the right pointer and the end of the array\\n    if(l > r)\\n        ans--; // Adjust the answer if the left pointer is greater than the right pointer\\n    return ans; // Return the calculated answer\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int semiOrderedPermutation(vector<int>& nums) {\\n    int l = 0, r = 0;\\n    for(int i = 0; i < nums.size(); i++) {\\n        if(nums[i] == 1)\\n            l = i; // Update the left pointer if the current number is 1\\n        if(nums[i] == nums.size())\\n            r = i; // Update the right pointer if the current number is equal to the size of the array\\n    }\\n    int ans = l + (nums.size() - 1 - r); // Calculate the answer by adding the left pointer position and the number of elements between the right pointer and the end of the array\\n    if(l > r)\\n        ans--; // Adjust the answer if the left pointer is greater than the right pointer\\n    return ans; // Return the calculated answer\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595053,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        if(nums[0]==1 && nums[n-1]==n) return 0;\\n        int swaps=0;\\n        int i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) break;\\n        }\\n        for(int x=i; x>=1; x--)\\n        {\\n            swap(nums[x],nums[x-1]);\\n            swaps++;\\n        }\\n        i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==n) break;\\n        }\\n        for(int x=i; x<n-1; x++)\\n        {\\n            swap(nums[x],nums[x+1]);\\n            swaps++;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        if(nums[0]==1 && nums[n-1]==n) return 0;\\n        int swaps=0;\\n        int i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) break;\\n        }\\n        for(int x=i; x>=1; x--)\\n        {\\n            swap(nums[x],nums[x-1]);\\n            swaps++;\\n        }\\n        i=0;\\n        for(i=0; i<n; i++)\\n        {\\n            if(nums[i]==n) break;\\n        }\\n        for(int x=i; x<n-1; x++)\\n        {\\n            swap(nums[x],nums[x+1]);\\n            swaps++;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595005,
                "title": "easy-java-fast-brute-force",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n int count=0;\\n        if(nums[0]==1&& nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int indst=0;\\n        int indend=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indst =i;\\n            }\\n            if(nums[i]==nums.length){\\n                indend=i;\\n            }\\n        }\\n        if(indst>indend){\\n            count+=indst+(nums.length-2-indend);\\n        }\\n        else{\\n            count+=indst+nums.length-1-indend;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n int count=0;\\n        if(nums[0]==1&& nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int indst=0;\\n        int indend=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                indst =i;\\n            }\\n            if(nums[i]==nums.length){\\n                indend=i;\\n            }\\n        }\\n        if(indst>indend){\\n            count+=indst+(nums.length-2-indend);\\n        }\\n        else{\\n            count+=indst+nums.length-1-indend;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594979,
                "title": "index-of-1-and-n-simple-solution-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int first = 0, last = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n           if(nums[i]==1){\\n               first=i;\\n           }\\n            if(nums[i]==n){\\n                last=i;\\n            }\\n        }\\n        int min = 0;\\n        if(first<last)\\n            min = (first + (n-last-1));\\n        else\\n            min = (first + (n-last-2));\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int first = 0, last = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n           if(nums[i]==1){\\n               first=i;\\n           }\\n            if(nums[i]==n){\\n                last=i;\\n            }\\n        }\\n        int min = 0;\\n        if(first<last)\\n            min = (first + (n-last-1));\\n        else\\n            min = (first + (n-last-2));\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594936,
                "title": "c-easy-solution",
                "content": "The given code represents a solution in C++ for the problem of finding the number of operations required to transform a given permutation of integers into a semi-ordered permutation.\\nThe variable n is assigned the size of the nums vector, which represents the length of the permutation.\\n\\nThe variables s and e are initialized to 0. These variables will track the indices of the first occurrence of 1 and the last occurrence of n, respectively\\n\\nAfter the loop, the variable diff is calculated as the difference between the total length of the permutation n and the index of the last occurrence of n e. This represents the number of elements that need to be moved to the left to transform the permutation into a semi-ordered permutation.\\n\\nThe variable diff is decremented by 1 to exclude the element at index e from the count of operations since it is already in its correct position.\\n\\nThe variable ans is calculated by adding the index of the first occurrence of 1 s and the adjusted diff. This represents the final position of the last element in the semi-ordered permutation.\\n\\nIf s is greater than e, it means that the first occurrence of 1 appears after the last occurrence of n. In this case, ans is decremented by 1 to account for this overlap between the two elements.\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n        int s=0;\\n        int e=0;\\n        for (int i = 0 ; i<n;i++){\\n            int val = nums[i];\\n            if(val ==1 ||val==n){\\n                if (val == 1){\\n                    s = i;\\n                }\\n                else {\\n                    e  = i;\\n                }\\n            }\\n        }\\n        int diff = n - e;\\n        diff--;\\n        int ans = s + diff;\\n        if(s>e){\\n            ans--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n        int s=0;\\n        int e=0;\\n        for (int i = 0 ; i<n;i++){\\n            int val = nums[i];\\n            if(val ==1 ||val==n){\\n                if (val == 1){\\n                    s = i;\\n                }\\n                else {\\n                    e  = i;\\n                }\\n            }\\n        }\\n        int diff = n - e;\\n        diff--;\\n        int ans = s + diff;\\n        if(s>e){\\n            ans--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078796,
                "title": "java-solution-100-faster-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int maxInd = 0;\\n        int minInd = 0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(max < nums[i]){\\n                max = nums[i];\\n                maxInd = i;\\n            }\\n            if(min > nums[i]){\\n                min = nums[i];\\n                minInd = i;\\n            }\\n        }\\n\\n        int count = minInd + nums.length-maxInd-1;\\n\\n        if(minInd > maxInd)\\n            count--;\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int maxInd = 0;\\n        int minInd = 0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(max < nums[i]){\\n                max = nums[i];\\n                maxInd = i;\\n            }\\n            if(min > nums[i]){\\n                min = nums[i];\\n                minInd = i;\\n            }\\n        }\\n\\n        int count = minInd + nums.length-maxInd-1;\\n\\n        if(minInd > maxInd)\\n            count--;\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058631,
                "title": "easier-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMax(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()-1];\\n    }\\n    int findMin(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[0];\\n    }\\n    int findInd(int no, vector<int> nums){\\n        for(int i=0;i<=nums.size()-1;i++){\\n            if(nums[i]==no){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int si=nums.size();\\n        int min=findMin(nums);\\n        int max=findMax(nums);\\n        int minInd=findInd(min, nums);\\n        int maxInd=findInd(max, nums);\\n        if(minInd<maxInd){\\n           return minInd + (si-maxInd) - 1;\\n        }\\n        return minInd + (si-maxInd) - 2;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMax(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()-1];\\n    }\\n    int findMin(vector<int> nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[0];\\n    }\\n    int findInd(int no, vector<int> nums){\\n        for(int i=0;i<=nums.size()-1;i++){\\n            if(nums[i]==no){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int si=nums.size();\\n        int min=findMin(nums);\\n        int max=findMax(nums);\\n        int minInd=findInd(min, nums);\\n        int maxInd=findInd(max, nums);\\n        if(minInd<maxInd){\\n           return minInd + (si-maxInd) - 1;\\n        }\\n        return minInd + (si-maxInd) - 2;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027981,
                "title": "php-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function semiOrderedPermutation($nums) {\\n        $min = min($nums);\\n        $max = max($nums);\\n        $ln = count($nums);\\n        \\n        if ($nums[0] === $min && $nums[$ln - 1] === $max) {\\n            return 0;\\n        }\\n\\n        $minIndex = array_search($min, $nums);\\n        $maxIndex = array_search($max, $nums);\\n        $n = $minIndex > $maxIndex? 2: 1;\\n\\n        return $minIndex + $ln - $maxIndex - $n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function semiOrderedPermutation($nums) {\\n        $min = min($nums);\\n        $max = max($nums);\\n        $ln = count($nums);\\n        \\n        if ($nums[0] === $min && $nums[$ln - 1] === $max) {\\n            return 0;\\n        }\\n\\n        $minIndex = array_search($min, $nums);\\n        $maxIndex = array_search($max, $nums);\\n        $n = $minIndex > $maxIndex? 2: 1;\\n\\n        return $minIndex + $ln - $maxIndex - $n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020620,
                "title": "python-3-solution-beats-60-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse while loops and count the swaps\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ - Worst case scenario\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        smallest = min(nums)\\n        largest = max(nums)\\n\\n        count = 0\\n\\n        while nums[0] != smallest:\\n            small_index = nums.index(smallest)\\n            nums[small_index], nums[small_index - 1] = nums[small_index - 1], nums[small_index]\\n            count += 1        \\n        \\n        while nums[-1] != largest:\\n            large_index = nums.index(largest)\\n            nums[large_index], nums[large_index + 1] = nums[large_index + 1], nums[large_index]\\n            count += 1\\n\\n        return count        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        smallest = min(nums)\\n        largest = max(nums)\\n\\n        count = 0\\n\\n        while nums[0] != smallest:\\n            small_index = nums.index(smallest)\\n            nums[small_index], nums[small_index - 1] = nums[small_index - 1], nums[small_index]\\n            count += 1        \\n        \\n        while nums[-1] != largest:\\n            large_index = nums.index(largest)\\n            nums[large_index], nums[large_index + 1] = nums[large_index + 1], nums[large_index]\\n            count += 1\\n\\n        return count        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007684,
                "title": "java-100-o-n-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int indexOfOne = -1;\\n        int indexOfN = -1;\\n        for(int i = 0; i < n; i++){\\n            if(indexOfOne != -1 && indexOfN != -1) break;\\n            if(indexOfOne == -1 && nums[i] == 1) indexOfOne = i;\\n            if(indexOfN == -1 && nums[i] == n) indexOfN = i;\\n        }\\n        if(indexOfN < indexOfOne) return indexOfOne + (n-1 - indexOfN) - 1;\\n        return indexOfOne + (n-1 - indexOfN);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int indexOfOne = -1;\\n        int indexOfN = -1;\\n        for(int i = 0; i < n; i++){\\n            if(indexOfOne != -1 && indexOfN != -1) break;\\n            if(indexOfOne == -1 && nums[i] == 1) indexOfOne = i;\\n            if(indexOfN == -1 && nums[i] == n) indexOfN = i;\\n        }\\n        if(indexOfN < indexOfOne) return indexOfOne + (n-1 - indexOfN) - 1;\\n        return indexOfOne + (n-1 - indexOfN);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992262,
                "title": "semi-ordered-permutation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    find the index of 1 and n in the given array.\\n    based on the index value of 1 and n we just need to find the \\n    number of swap required to take 1 and n to the 0th and n-1th index\\n    \\n    for 1 the number of swap required to bring it to 0th index is\\n    same as the index at which it was found. ( you can try it out)\\n\\n    for n the number of swap required to bring it to n-1th index is \\n    equal to (n-i-index_max). where index_max is the index where n \\n    was found.\\n    hence return the total of swap for 1 and n. \\n\\n    but there is one exception if the index_max < index_min then we \\n    must return total - 1 because one swap will be counted twice \\n    one during swapping of 1 and one during swapping of n. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max_index = -1;\\n        int min_index = -1;\\n        \\n        for(int i = 0; i< nums.length; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                min_index = i;\\n            }\\n            if(nums[i] == nums.length)\\n            {\\n                max_index = i;\\n            }\\n            if(max_index != -1 && min_index != -1) break;\\n        }\\n        \\n        if(max_index > min_index) {\\n            return min_index + nums.length-1 - max_index; \\n        }else{\\n             return min_index + nums.length-2 - max_index;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int max_index = -1;\\n        int min_index = -1;\\n        \\n        for(int i = 0; i< nums.length; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                min_index = i;\\n            }\\n            if(nums[i] == nums.length)\\n            {\\n                max_index = i;\\n            }\\n            if(max_index != -1 && min_index != -1) break;\\n        }\\n        \\n        if(max_index > min_index) {\\n            return min_index + nums.length-1 - max_index; \\n        }else{\\n             return min_index + nums.length-2 - max_index;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983842,
                "title": "c-solution-o-n-s-1",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int idx_1 = 0;\\n        int idx_n = 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                idx_1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                idx_n = i;\\n            }\\n        }\\n\\n        int res = 0;\\n        res -= (idx_n < idx_1);\\n\\n        res += idx_1;\\n        res += nums.size() - idx_n - 1;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int idx_1 = 0;\\n        int idx_n = 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                idx_1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                idx_n = i;\\n            }\\n        }\\n\\n        int res = 0;\\n        res -= (idx_n < idx_1);\\n\\n        res += idx_1;\\n        res += nums.size() - idx_n - 1;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976732,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-99-memory",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int output = 0;\\n        int t = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                output += i;\\n                t = i;\\n                i = nums.length;\\n            }\\n            while (t > 0) {\\n                int temp = nums[t-1];\\n                nums[t] = temp;\\n                nums[--t] = 1;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == nums.length) {\\n                output += nums.length - 1 - i;\\n                break;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int output = 0;\\n        int t = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                output += i;\\n                t = i;\\n                i = nums.length;\\n            }\\n            while (t > 0) {\\n                int temp = nums[t-1];\\n                nums[t] = temp;\\n                nums[--t] = 1;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == nums.length) {\\n                output += nums.length - 1 - i;\\n                break;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960477,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l = nums.index(min(nums))\\n        count = 0\\n\\n        while l >= 1:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            count += 1\\n        \\n        r = nums.index(max(nums))\\n\\n        while r < len(nums) - 1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            count += 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l = nums.index(min(nums))\\n        count = 0\\n\\n        while l >= 1:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            count += 1\\n        \\n        r = nums.index(max(nums))\\n\\n        while r < len(nums) - 1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            count += 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956485,
                "title": "easy-python-pointer-solution-beats-97-64-11-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, we find where \\'1\\' and \\'n\\' are and grab their indices. Then we bubble \\'1\\' to the first of the array counting passes as we go. Then we bubble \\'n\\' to the end of the array counting passes as we go.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        res = 0\\n        l = nums.index(1)\\n        while l != 0:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            res += 1\\n        r = nums.index(len(nums))\\n        while r != len(nums)-1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            res += 1\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        res = 0\\n        l = nums.index(1)\\n        while l != 0:\\n            nums[l], nums[l-1] = nums[l-1], nums[l]\\n            l -= 1\\n            res += 1\\n        r = nums.index(len(nums))\\n        while r != len(nums)-1:\\n            nums[r], nums[r+1] = nums[r+1], nums[r]\\n            r += 1\\n            res += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917935,
                "title": "java-simple-solution",
                "content": "class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n       int i1=0,i2=0;\\n    \\tint n=nums.length;\\n    \\t\\n    \\tfor(int i=0;i<n;i++) {\\n    \\t\\tif(nums[i]==1) {\\n    \\t\\t\\ti1=i;\\n    \\t\\t}\\n    \\t\\tif(nums[i]==n) {\\n    \\t\\t\\ti2=i;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tif(i1<i2) {\\n    \\t\\treturn i1+(n-1)-i2;\\n    \\t}else {\\n    \\t\\treturn i1+(n-2)-i2;\\n    \\t} \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n       int i1=0,i2=0;\\n    \\tint n=nums.length;\\n    \\t\\n    \\tfor(int i=0;i<n;i++) {\\n    \\t\\tif(nums[i]==1) {\\n    \\t\\t\\ti1=i;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3910195,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the given 0-indexed array, we are allowed to perform swap on any two adjacent elements unit we make array nums a semi-ordered permutation.\\nwe can perform swap on element valued 1 to make it reach index 0.\\nSimilarly, we perform swap on element valued n (which is also the size of the array nums) till it reaches the last index that is (n-1).\\nWe return the number of swaps required in this process.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n          int n=nums.length;\\n        int cnt=0;\\n        boolean f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                      int temp= nums[i];\\n                      nums[i]=nums[i+1];\\n                      nums[i+1]=temp;\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                     int temp= nums[i-1];\\n                     nums[i-1]=nums[i];\\n                     nums[i]=temp;\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n          int n=nums.length;\\n        int cnt=0;\\n        boolean f=false;\\n        while(f==false){\\n               for(int i=0;i<n;i++){\\n                   if(nums[i]==n & i!=(n-1)){\\n                      int temp= nums[i];\\n                      nums[i]=nums[i+1];\\n                      nums[i+1]=temp;\\n                       cnt++;\\n                   }\\n                   if(nums[i]==1 && i!=0){\\n                     int temp= nums[i-1];\\n                     nums[i-1]=nums[i];\\n                     nums[i]=temp;\\n                       cnt++;\\n                   }\\n               }\\n               if(nums[0]==1 && nums[n-1]==n){\\n                   f=true;\\n               }\\n\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892012,
                "title": "c-solution-using-only-for-loops",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n      int one=0;\\n      int last=0;\\n      int ans=0;\\n      int n=nums.size();\\n      if(nums[0]!=1){\\n          for(int i=0; i<n; i++){\\n              if(nums[i]==1){\\n                 one=i;\\n                  break;\\n              }\\n          }\\n          for(int i=one; i>0; i--){\\n              nums[i]=nums[i-1];\\n              ans++;\\n          }\\n          nums[0]=1;\\n      }\\n\\n      if(nums[n-1]!=n){\\n           for(int i=0; i<n; i++){\\n              if(nums[i]==n){\\n                   last=i;\\n                  break;\\n              }\\n      }\\n       for(int i=last; i<n-1; i++){\\n              nums[i]=nums[i+1];\\n              ans++;\\n          }\\n          nums[n-1]=n;\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n      int one=0;\\n      int last=0;\\n      int ans=0;\\n      int n=nums.size();\\n      if(nums[0]!=1){\\n          for(int i=0; i<n; i++){\\n              if(nums[i]==1){\\n                 one=i;\\n                  break;\\n              }\\n          }\\n          for(int i=one; i>0; i--){\\n              nums[i]=nums[i-1];\\n              ans++;\\n          }\\n          nums[0]=1;\\n      }\\n\\n      if(nums[n-1]!=n){\\n           for(int i=0; i<n; i++){\\n              if(nums[i]==n){\\n                   last=i;\\n                  break;\\n              }\\n      }\\n       for(int i=last; i<n-1; i++){\\n              nums[i]=nums[i+1];\\n              ans++;\\n          }\\n          nums[n-1]=n;\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889234,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int max = 0; \\n        int min = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1) min = i;\\n            if(nums[i] == n) max = i;\\n        }\\n\\n        return (min <  max) ? n - 1 - max + min :  n - 1 - max + min - 1;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int max = 0; \\n        int min = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1) min = i;\\n            if(nums[i] == n) max = i;\\n        }\\n\\n        return (min <  max) ? n - 1 - max + min :  n - 1 - max + min - 1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865059,
                "title": "simple-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function(nums) {\\n  const length = nums.length;\\n  const positionOf1 = nums.indexOf(1);\\n  const positionOfMaxNum = nums.indexOf(length);\\n  const minimumSwap = positionOf1 + (length - positionOfMaxNum - 1);\\n\\n  return (positionOf1 < positionOfMaxNum) ? minimumSwap : minimumSwap - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst semiOrderedPermutation = function(nums) {\\n  const length = nums.length;\\n  const positionOf1 = nums.indexOf(1);\\n  const positionOfMaxNum = nums.indexOf(length);\\n  const minimumSwap = positionOf1 + (length - positionOfMaxNum - 1);\\n\\n  return (positionOf1 < positionOfMaxNum) ? minimumSwap : minimumSwap - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864561,
                "title": "java-1ms-beats-100-00",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        int idxOf1 = -1;\\n        int idxOfN = -1;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == 1) {\\n                idxOf1 = i;\\n            } else if (nums[i] == n) {\\n                idxOfN = i;\\n            }\\n        }\\n\\n        if (idxOf1 < idxOfN) {\\n            return idxOf1 + (n - idxOfN - 1);\\n        } else {  // idxOf1 > idxOfN\\n            return idxOf1 + (n - idxOfN - 2);\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        int idxOf1 = -1;\\n        int idxOfN = -1;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == 1) {\\n                idxOf1 = i;\\n            } else if (nums[i] == n) {\\n                idxOfN = i;\\n            }\\n        }\\n\\n        if (idxOf1 < idxOfN) {\\n            return idxOf1 + (n - idxOfN - 1);\\n        } else {  // idxOf1 > idxOfN\\n            return idxOf1 + (n - idxOfN - 2);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864057,
                "title": "semi-ordered-permutation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums[0]==1 and nums[-1]==len(nums):\\n            return 0\\n        num=0\\n        while nums[-1]!=len(nums):\\n            nummax=nums.index(len(nums))\\n            nums[nummax],nums[nummax+1]=nums[nummax+1],len(nums)\\n            num+=1\\n        while nums[0]!=1:\\n            nummin=nums.index(1)\\n            nums[nummin],nums[nummin-1]=nums[nummin-1],1\\n            num+=1\\n        return num\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        if nums[0]==1 and nums[-1]==len(nums):\\n            return 0\\n        num=0\\n        while nums[-1]!=len(nums):\\n            nummax=nums.index(len(nums))\\n            nums[nummax],nums[nummax+1]=nums[nummax+1],len(nums)\\n            num+=1\\n        while nums[0]!=1:\\n            nummin=nums.index(1)\\n            nums[nummin],nums[nummin-1]=nums[nummin-1],1\\n            num+=1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862667,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        \\n        let f = nums.firstIndex(of: 1)!\\n        let l = nums.firstIndex(of: nums.count)!\\n        \\n        var res = f + (nums.count - l - 1)\\n\\n        if l < f { res -= 1 }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        \\n        let f = nums.firstIndex(of: 1)!\\n        let l = nums.firstIndex(of: nums.count)!\\n        \\n        var res = f + (nums.count - l - 1)\\n\\n        if l < f { res -= 1 }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857591,
                "title": "best-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1&&nums[n-1]==n) return 0;\\n        int a,b;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) a=i;\\n            if(nums[i]==n) b=i;\\n        }\\n        if(a>b){\\n            return a+(n-1)-b-1;\\n        }\\n        else\\n            return a+(n-1)-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1&&nums[n-1]==n) return 0;\\n        int a,b;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) a=i;\\n            if(nums[i]==n) b=i;\\n        }\\n        if(a>b){\\n            return a+(n-1)-b-1;\\n        }\\n        else\\n            return a+(n-1)-b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853758,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplementation\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=0;\\n        int pos1=-1,pos2=-1;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==1)pos1=i;\\n        }\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==nums.size())pos2=i;\\n        }\\n\\n        int n=nums.size();\\n        ++pos1,++pos2;\\n\\n        ans=abs(1-pos1)+abs(pos2-n);\\n        if(pos1>pos2)--ans;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=0;\\n        int pos1=-1,pos2=-1;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==1)pos1=i;\\n        }\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==nums.size())pos2=i;\\n        }\\n\\n        int n=nums.size();\\n        ++pos1,++pos2;\\n\\n        ans=abs(1-pos1)+abs(pos2-n);\\n        if(pos1>pos2)--ans;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841295,
                "title": "brutefoce-easiest-approac-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[0]!=1){\\n                for(int j=1;j<nums.length;j++){\\n                    if(nums[j]==1){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j-1];\\n                        nums[j-1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        \\n        }\\n        int last=nums.length-1;\\n        int acc=nums.length;\\n\\n        for(int i=last;i>=0;i--){\\n            if(nums[last]!=nums.length){\\n                for(int j=last-1;j>=0;j--){\\n                    if(nums[j]==acc){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j+1];\\n                        nums[j+1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n\\n        for(int i=0;i<nums.length;i++){\\n            System.out.print(nums[i]+\" \");\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[0]!=1){\\n                for(int j=1;j<nums.length;j++){\\n                    if(nums[j]==1){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j-1];\\n                        nums[j-1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        \\n        }\\n        int last=nums.length-1;\\n        int acc=nums.length;\\n\\n        for(int i=last;i>=0;i--){\\n            if(nums[last]!=nums.length){\\n                for(int j=last-1;j>=0;j--){\\n                    if(nums[j]==acc){\\n                        int temp=nums[j];\\n                        nums[j]=nums[j+1];\\n                        nums[j+1]=temp;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n\\n        for(int i=0;i<nums.length;i++){\\n            System.out.print(nums[i]+\" \");\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837038,
                "title": "c-simple-iteration-easy-and-understandable-clean-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind index of 1 and n let x is index of 1 and y is index of n then \\n\\nlets tae an example\\n\\n     [2, 6 , 7 , 8 , 9 , 1 , 4 , 10 , 5 , 15 , 12 , 13 , 14 , 11 , 3 ]\\n\\n\\n\\nhere x = 5 and y = 9 \\n\\n\\nif x < y so in this case to move 1 to the 0th position we need x operation and to move 15 to 14th position we need 14 -9 or  n-1-y\\n\\n\\n\\nnow another case \\n\\n\\nnow if  x > y\\n\\n     [2, 6 , 7 , 8 , 9 , 15 , 4 , 10 , 5 , 1 , 12 , 13 , 14 , 11 , 3 ]\\n\\nhere x = 9  and y = 5 \\n\\nnow first we move 1 to 0th position  so array will be \\n\\n    [1, 2 , 6 , 7 , 8 , 9 , 15 , 4 , 10 , 5 , 12 , 13 , 14 , 11 , 3 ]\\n\\nnow value of y is chaneged  y = 5 to y =6 means in this need 14 -6 = 8 operations\\n\\nmeas if  x > y then we need 1 operation less than if x<y\\n\\n\\n\\n\\n\\nfinal \\n\\nif(x>y) return   return  x  + n-2 - y ;\\nif(x<y) return  return  x  + n-1 - y ;\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Iteration\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n.\\n.\\n.\\n.\\n.\\n\\nPlease correct me if I am wrong anywhere or have anyMemoization general suggestions.\\nPlease correct me if I am wrong anywhere or have anyMemoization general suggestions.\\n\\n.\\n.\\n.\\n.\\n.\\n\\n# Code\\n\\n\\n\\n\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n = nums.size() ;\\n        int x = 0 ,  y  = 0 ;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) x = i ;\\n            else if(nums[i]==n) y = i ;\\n        }\\n        if(x > y) return  x  + n-2 - y ;\\n        return x  + n-1 - y ;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int n = nums.size() ;\\n        int x = 0 ,  y  = 0 ;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==1) x = i ;\\n            else if(nums[i]==n) y = i ;\\n        }\\n        if(x > y) return  x  + n-2 - y ;\\n        return x  + n-1 - y ;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826272,
                "title": "48ms-beats-100-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of swaps depends on the initial positions of the lowest and highest values in the array.\\n\\nIf the index of the maximum value is lower than the index of the minimum value, you can swap both of their places in one swap, thus we need to take this into account by subtracting 1 if this is the case.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the index of the max and min values\\n2. Calculate how far the max is from the end (from `nums.length - 1`)\\n3. Calculate how far the min is from the start (Basically just the index of the min value)\\n4. Add these 2 values from steps 2 and 3 to get the answer, but if the index of the max value is lower than the index of the min value, subtract 1\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const maximum = nums.indexOf(Math.max(...nums))\\n    const minimum = nums.indexOf(Math.min(...nums))\\n\\n    return maximum < minimum ? (nums.length - 1 - maximum) + minimum - 1 : (nums.length - 1 - maximum) + minimum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const maximum = nums.indexOf(Math.max(...nums))\\n    const minimum = nums.indexOf(Math.min(...nums))\\n\\n    return maximum < minimum ? (nums.length - 1 - maximum) + minimum - 1 : (nums.length - 1 - maximum) + minimum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803742,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        \\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == 1){\\n                nums.erase(nums.begin() + i);\\n                ans += i;\\n                break;\\n            }\\n        }\\n\\n        nums.insert(nums.begin() , 1);\\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == n){\\n                ans += n-1-i;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        \\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == 1){\\n                nums.erase(nums.begin() + i);\\n                ans += i;\\n                break;\\n            }\\n        }\\n\\n        nums.insert(nums.begin() , 1);\\n        for (int i=0 ; i<n ; i++){\\n            if (nums[i] == n){\\n                ans += n-1-i;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793561,
                "title": "swift-simple-solution-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var l = -1\\n        var r = -1\\n        var pointer = 0\\n        \\n        while l == -1 || r == -1 {\\n            if nums[pointer] == 1 {\\n                l = pointer\\n            } else if nums[pointer] == nums.count {\\n                r = pointer\\n            }\\n            pointer += 1\\n        }\\n        \\n        let count = l + nums.count - 1 - r\\n\\n        return l < r ? count : count - 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var l = -1\\n        var r = -1\\n        var pointer = 0\\n        \\n        while l == -1 || r == -1 {\\n            if nums[pointer] == 1 {\\n                l = pointer\\n            } else if nums[pointer] == nums.count {\\n                r = pointer\\n            }\\n            pointer += 1\\n        }\\n        \\n        let count = l + nums.count - 1 - r\\n\\n        return l < r ? count : count - 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786054,
                "title": "esay",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        i1 = nums.index(1)\\n        i2 = nums.index(n)\\n        c = i1+(n-i2-1)\\n        if i2<i1:\\n            c-=1 \\n        return c\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        i1 = nums.index(1)\\n        i2 = nums.index(n)\\n        c = i1+(n-i2-1)\\n        if i2<i1:\\n            c-=1 \\n        return c\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784381,
                "title": "cpp-very-easy-beginner-lvl-solution-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int index=0;\\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == 1 ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int op = 0;\\n        if( index != 0){\\n            for( int i = index ; i > 0 ; i--){\\n                swap(nums[i],nums[i-1]);\\n                op++;\\n            }\\n        }\\n        \\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == nums.size() ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        if( index != nums.size()-1 ){\\n            for( int i = index ; i<nums.size()-1 ;i++){\\n                swap(nums[i] , nums[i+1]);\\n                op++;\\n            }\\n        }\\n        \\n        return op;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int index=0;\\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == 1 ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int op = 0;\\n        if( index != 0){\\n            for( int i = index ; i > 0 ; i--){\\n                swap(nums[i],nums[i-1]);\\n                op++;\\n            }\\n        }\\n        \\n        for( int i =0 ; i < nums.size() ;i++){\\n            if( nums[i] == nums.size() ) \\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        if( index != nums.size()-1 ){\\n            for( int i = index ; i<nums.size()-1 ;i++){\\n                swap(nums[i] , nums[i+1]);\\n                op++;\\n            }\\n        }\\n        \\n        return op;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777106,
                "title": "easy-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        // Get the indexes of 1 and n as p1 and p2\\n        int p1= 0;\\n        int p2 = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] ==1){\\n                p1 = i;\\n            }\\n            else if(nums[i] == n){\\n                p2 = i;\\n            }\\n        }\\n        /*if 1 is before n then simply 1 and n will swap without altering each other\\'s coordinates*/ \\n        int temp = p1 + (n-1-p2);\\n        /*else if n is before 1 then we will encounter n thus swapping and taking n an index close to its final position thereby reducing moves required by 1*/\\n        if(p1>p2){\\n            return temp-1;\\n        }\\n        return temp;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        // Get the indexes of 1 and n as p1 and p2\\n        int p1= 0;\\n        int p2 = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] ==1){\\n                p1 = i;\\n            }\\n            else if(nums[i] == n){\\n                p2 = i;\\n            }\\n        }\\n        /*if 1 is before n then simply 1 and n will swap without altering each other\\'s coordinates*/ \\n        int temp = p1 + (n-1-p2);\\n        /*else if n is before 1 then we will encounter n thus swapping and taking n an index close to its final position thereby reducing moves required by 1*/\\n        if(p1>p2){\\n            return temp-1;\\n        }\\n        return temp;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775782,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    let min = 0;\\n    let max = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) min = i;\\n        if (nums[i] === nums.length) max = i;\\n    }\\n    let result = min + (nums.length - max - 1)\\n    return min < max ? result : result-1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    let min = 0;\\n    let max = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) min = i;\\n        if (nums[i] === nums.length) max = i;\\n    }\\n    let result = min + (nums.length - max - 1)\\n    return min < max ? result : result-1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770810,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn semi_ordered_permutation(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let first = nums.iter().position(|&x| x == 1).unwrap();\\n        let last = nums.iter().position(|&x| x == n as i32).unwrap();\\n\\n        if first < last {\\n            (first + n - last - 1) as _\\n        } else {\\n            (first + n - last - 2) as _\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn semi_ordered_permutation(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let first = nums.iter().position(|&x| x == 1).unwrap();\\n        let last = nums.iter().position(|&x| x == n as i32).unwrap();\\n\\n        if first < last {\\n            (first + n - last - 1) as _\\n        } else {\\n            (first + n - last - 2) as _\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3769993,
                "title": "semiorderedpermutation",
                "content": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int min = nums.Min();\\n        int max = nums.Max();\\n\\n        int indexOfMin = Array.IndexOf(nums, min);\\n        int indexOfMax = Array.IndexOf(nums, max);\\n\\n        int swaps = 0;\\n       \\n        if(indexOfMin == 0 && indexOfMax + 1 == nums.Length) return 0;\\n        if(nums.Length == 2) return swaps = (indexOfMin == 0) ? 0:1;\\n\\n        swaps += indexOfMin;\\n        swaps += nums.Length - (indexOfMax+1);\\n        if(indexOfMax < indexOfMin) swaps-=1;\\n\\n        return swaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int min = nums.Min();\\n        int max = nums.Max();\\n\\n        int indexOfMin = Array.IndexOf(nums, min);\\n        int indexOfMax = Array.IndexOf(nums, max);\\n\\n        int swaps = 0;\\n       \\n        if(indexOfMin == 0 && indexOfMax + 1 == nums.Length) return 0;\\n        if(nums.Length == 2) return swaps = (indexOfMin == 0) ? 0:1;\\n\\n        swaps += indexOfMin;\\n        swaps += nums.Length - (indexOfMax+1);\\n        if(indexOfMax < indexOfMin) swaps-=1;\\n\\n        return swaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766730,
                "title": "very-easy-c-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int fir = -1, last = -1;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == 1){\\n                fir = i;\\n                break;\\n            }\\n        }\\n\\n        if(fir != 0){\\n            for(int i=fir; i>=1; i--){\\n                swap(nums[i], nums[i-1]);\\n                count++;\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == n){\\n                last = i;\\n                break;\\n            }\\n        }\\n\\n        if(last != n-1){\\n            for(int i=last; i<n-1; i++){\\n                swap(nums[i], nums[i+1]);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        int fir = -1, last = -1;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == 1){\\n                fir = i;\\n                break;\\n            }\\n        }\\n\\n        if(fir != 0){\\n            for(int i=fir; i>=1; i--){\\n                swap(nums[i], nums[i-1]);\\n                count++;\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == n){\\n                last = i;\\n                break;\\n            }\\n        }\\n\\n        if(last != n-1){\\n            for(int i=last; i<n-1; i++){\\n                swap(nums[i], nums[i+1]);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746225,
                "title": "java-o-n-100-faster",
                "content": "In the end, **b** shows the distance between largest number and the end of the array.\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 1, b = nums.length, idxA = 0, idxB = 0, res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == a) idxA = i;\\n            if (nums[i] == b) idxB = i;\\n        }\\n        b = b - idxB - 1;\\n        return idxB < idxA ? idxA + b - 1 : idxA + b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 1, b = nums.length, idxA = 0, idxB = 0, res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == a) idxA = i;\\n            if (nums[i] == b) idxB = i;\\n        }\\n        b = b - idxB - 1;\\n        return idxB < idxA ? idxA + b - 1 : idxA + b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732498,
                "title": "find-position-1-and-n-c",
                "content": "\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int x = 0, y = 0, swp = 0, n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) x = i;\\n            if(nums[i] == n) y = n - i - 1;\\n            if(y && x == 0 && nums[0] != 1) swp = 1;\\n        }\\n        return x + y - swp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int x = 0, y = 0, swp = 0, n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) x = i;\\n            if(nums[i] == n) y = n - i - 1;\\n            if(y && x == 0 && nums[0] != 1) swp = 1;\\n        }\\n        return x + y - swp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729288,
                "title": "javascript-bubblesort",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    return bubbleSort(nums)\\n};\\n\\nfunction bubbleSort(arr) {\\n  \\n    var i, j;\\n    var len = arr.length;\\n    let count = 0;\\n  \\n    var isSwapped = false;\\n  \\n    for (i = 0; i < len; i++) {\\n  \\n        isSwapped = false;\\n  \\n        for (j = 0; j < len; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                var temp = arr[j]\\n                arr[j] = arr[j + 1];\\n                arr[j + 1] = temp;\\n                isSwapped = true;\\n\\n                if (\\n                    (arr[j] == 1 || arr[j+1] == len) ||\\n                    (arr[j+1] == 1 || arr[j] == len)\\n                )\\n                count++;\\n            }\\n        }\\n  \\n        if (!isSwapped) {\\n            break;\\n        }\\n    }\\n  \\n    //return arr\\n    return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    return bubbleSort(nums)\\n};\\n\\nfunction bubbleSort(arr) {\\n  \\n    var i, j;\\n    var len = arr.length;\\n    let count = 0;\\n  \\n    var isSwapped = false;\\n  \\n    for (i = 0; i < len; i++) {\\n  \\n        isSwapped = false;\\n  \\n        for (j = 0; j < len; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                var temp = arr[j]\\n                arr[j] = arr[j + 1];\\n                arr[j + 1] = temp;\\n                isSwapped = true;\\n\\n                if (\\n                    (arr[j] == 1 || arr[j+1] == len) ||\\n                    (arr[j+1] == 1 || arr[j] == len)\\n                )\\n                count++;\\n            }\\n        }\\n  \\n        if (!isSwapped) {\\n            break;\\n        }\\n    }\\n  \\n    //return arr\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3725988,
                "title": "basic-c-solution-easy-to-understand-explained-beats-90-runtime-and-memory-beginner",
                "content": "# Intuition\\nSure! Let me explain the code in first person and discuss its complexity.\\n\\nIn this code, I see a class named `Solution` with a member function `semiOrderedPermutation`. This function takes a reference to a vector of integers `nums` as input and calculates a count value based on certain conditions.\\n\\n# Approach\\n\\nNow, let\\'s go through the code step by step:\\n\\n1. First, there is an `if` condition that checks if the first element of `nums` is `1` and the last element is equal to the size of `nums`. If this condition is true, it means that the vector is already a semi-ordered permutation, and there is no need to perform any operations. In this case, the function returns `0`.\\n\\n2. If the condition in the previous step is not met, the code initializes a variable `count` to `0`. This variable will be used to keep track of the count value.\\n\\n3. The code then enters a `for` loop that iterates over the elements of the `nums` vector. Inside this loop:\\n   - It checks if the current element is equal to `1`.\\n   - If the condition is true, it means that we have found the first element of the permutation. We update the `count` by adding the current index `i` to it. This is because we want to count the number of swaps required to bring the first element (`1`) to its correct position.\\n   - Next, there is a nested `while` loop that performs the actual swapping of elements. Starting from the current index `j = i`, it iterates backwards and swaps `nums[j]` with `nums[j-1]` until `j` becomes `0`. This effectively moves the first element to the front of the vector.\\n\\n4. After the first loop finishes, the code enters another `for` loop that iterates over the elements of `nums` once again. Inside this loop:\\n   - It checks if the current element is equal to the size of `nums`. If the condition is true, it means we have found the last element of the permutation. We update the `count` by adding the difference between `(nums.size() - 1)` and the current index `i` to it. This accounts for the number of swaps required to bring the last element to its correct position.\\n\\n5. Finally, the function returns the calculated `count` value, representing the number of swaps needed to obtain a semi-ordered permutation of `nums`.\\n\\n# Complexity\\n- Time complexity : The code runs two nested loops, each iterating over the elements of `nums`, so the time complexity is O(n^2), where n is the size of the vector.\\n\\n- Space complexity : The space complexity of the code is O(1) as it only uses a constant amount of additional space, regardless of the input size.\\n\\n![star-wars-bb8.gif](https://assets.leetcode.com/users/images/decbf26e-0058-4c78-9c8f-144a49fed944_1688628814.790765.gif)\\n\\n# Do upvote if you like the solution , happy leetcoding\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] == 1 && nums[nums.size()-1] == nums.size())\\n        {\\n            return 0;\\n        }\\n            int count = 0;\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == 1)\\n                {\\n                    count = count + i;\\n                    int j = i;\\n                    while(j>0)\\n                    {\\n                        int temp = nums[j];\\n                        nums[j] = nums[j-1];\\n                        nums[j-1] = temp;\\n                        j--;\\n                    }\\n                }\\n            }\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == nums.size())\\n                {\\n                    count = count + ((nums.size()-1)-i);\\n                }\\n            }\\n            return count;    \\n    }\\n}; //Please Upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] == 1 && nums[nums.size()-1] == nums.size())\\n        {\\n            return 0;\\n        }\\n            int count = 0;\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == 1)\\n                {\\n                    count = count + i;\\n                    int j = i;\\n                    while(j>0)\\n                    {\\n                        int temp = nums[j];\\n                        nums[j] = nums[j-1];\\n                        nums[j-1] = temp;\\n                        j--;\\n                    }\\n                }\\n            }\\n            for(int i = 0 ; i < nums.size() ; i++)\\n            {\\n                if(nums[i] == nums.size())\\n                {\\n                    count = count + ((nums.size()-1)-i);\\n                }\\n            }\\n            return count;    \\n    }\\n}; //Please Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722194,
                "title": "find-indexof-1-and-lastindexof-n",
                "content": "# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  const firstOne = nums.indexOf(1);\\n  const lastN = nums.lastIndexOf(nums.length);\\n  return firstOne > lastN\\n    ? nums.length - lastN - 2 + firstOne\\n    : nums.length - lastN - 1 + firstOne;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  const firstOne = nums.indexOf(1);\\n  const lastN = nums.lastIndexOf(nums.length);\\n  return firstOne > lastN\\n    ? nums.length - lastN - 2 + firstOne\\n    : nums.length - lastN - 1 + firstOne;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3722031,
                "title": "array-manipulation-to-find-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int total_score=0;\\n        int index1=0,index2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n                break;\\n            }\\n        }\\n        nums.erase(nums.begin()+index1);\\n        reverse(nums.begin(),nums.end());\\n        nums.push_back(1);\\n        reverse(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                index2=i;\\n                break;\\n            }\\n        }\\n        total_score=index1+(nums.size()-1-index2);\\n        return total_score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int total_score=0;\\n        int index1=0,index2=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n                break;\\n            }\\n        }\\n        nums.erase(nums.begin()+index1);\\n        reverse(nums.begin(),nums.end());\\n        nums.push_back(1);\\n        reverse(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                index2=i;\\n                break;\\n            }\\n        }\\n        total_score=index1+(nums.size()-1-index2);\\n        return total_score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714726,
                "title": "python-3-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l  = len(nums)\\n        if nums.index(l) < nums.index(1):\\n            return l - 2 -nums.index(l) + nums.index(1)\\n        if nums.index(l) > nums.index(1):\\n            return l - 1  -nums.index(l) + nums.index(1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        l  = len(nums)\\n        if nums.index(l) < nums.index(1):\\n            return l - 2 -nums.index(l) + nums.index(1)\\n        if nums.index(l) > nums.index(1):\\n            return l - 1  -nums.index(l) + nums.index(1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711226,
                "title": "very-simple-short-solution-with-explanation-c",
                "content": "# Intuition\\nThe problem asks for the minimum number of swaps required to transform a given array into a semi-ordered permutation. A semi-ordered permutation is defined as an array where the first element is 1, the last element is n, and all other elements are in increasing order. \\n\\nTo solve this problem, we can find the positions of the elements 1 and n in the given array. Depending on their relative positions, we can determine the minimum number of swaps required to transform the array into a semi-ordered permutation.\\n\\n# Approach\\n1. Find the positions of the elements 1 and n in the given array.\\n2. Calculate the distance of the element 1 from the beginning of the array (`posOne`) and the distance of the element n from the end of the array (`posN`).\\n3. If `posOne` is greater than `posN`, it means that the element 1 is located after the element n in the array. In this case, we need to swap the positions of the elements 1 and n, as well as adjust the positions `posOne` and `posN` accordingly.\\n4. Calculate the minimum number of swaps required by adding `posOne` and `posN` together and subtracting 1 (since we don\\'t need to swap the element 1 with itself).\\n5. If `posOne` is less than or equal to `posN`, it means that the element 1 is located before the element n in the array. In this case, we don\\'t need to swap any elements, so the minimum number of swaps required is equal to `posOne` + `posN`.\\n6. Return the minimum number of swaps as the result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the input array. The algorithm iterates through the array once to find the positions of the elements 1 and n.\\n- Space complexity: O(1). The algorithm uses a constant amount of extra space to store the positions `posOne` and `posN`.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        auto oneFind = find(nums.begin(), nums.end(), 1);\\n        auto nFind = find(nums.begin(), nums.end(), n);\\n\\n        int posOne = distance(nums.begin(), oneFind);\\n        int posN = distance(nums.begin(), nFind);\\n\\n        if (posOne > posN) {\\n            posN = n - posN - 1;\\n            return posOne + posN - 1;\\n        }\\n        \\n        posN = n - posN - 1;\\n        return posOne + posN;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        auto oneFind = find(nums.begin(), nums.end(), 1);\\n        auto nFind = find(nums.begin(), nums.end(), n);\\n\\n        int posOne = distance(nums.begin(), oneFind);\\n        int posN = distance(nums.begin(), nFind);\\n\\n        if (posOne > posN) {\\n            posN = n - posN - 1;\\n            return posOne + posN - 1;\\n        }\\n        \\n        posN = n - posN - 1;\\n        return posOne + posN;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697442,
                "title": "java-1000-accurate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n            int one  = 0;\\n        int n = 0;\\n        int ans = 0;\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!( nums[nums.length-1] == nums.length)){\\n            ans++;\\n            int temp = nums[n+1];\\n            nums[n+1] = nums[n];\\n            nums[n] = temp;\\n            n++;\\n        }\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!(nums[0] == 1 )){\\n            ans++;\\n\\n            int temp = nums[one-1];\\n            nums[one-1] = nums[one];\\n            nums[one] = temp;\\n            one--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n            int one  = 0;\\n        int n = 0;\\n        int ans = 0;\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!( nums[nums.length-1] == nums.length)){\\n            ans++;\\n            int temp = nums[n+1];\\n            nums[n+1] = nums[n];\\n            nums[n] = temp;\\n            n++;\\n        }\\n        for (int i = 0; i <nums.length; i++) {\\n            if(nums[i] == 1)one = i;\\n            if(nums[i] == nums.length)n = i;\\n        }\\n        while(!(nums[0] == 1 )){\\n            ans++;\\n\\n            int temp = nums[one-1];\\n            nums[one-1] = nums[one];\\n            nums[one] = temp;\\n            one--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697333,
                "title": "permutation-js-min-max-indexes-89-93-88-ms",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    a = 1\\n    b = nums.length\\n\\n    x = nums.indexOf(a)\\n    y = nums.indexOf(b)\\n\\n    return x < y ? (b - 1) - y + x : (b - 1) - y + x - 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n    a = 1\\n    b = nums.length\\n\\n    x = nums.indexOf(a)\\n    y = nums.indexOf(b)\\n\\n    return x < y ? (b - 1) - y + x : (b - 1) - y + x - 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3693002,
                "title": "very-easy-ts-js-solution-by-just-swapping-elements",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur goal is to bring the smallest element that is 1 to the start of the array and N i.e nums.length to the end of the array. \\nSo we create two functions let say swapFirstIndex() which swaps elements starting from the index where 1 is present, untill 1 comes to the start of the array. \\nThen we create another function swapLastIndex() which elements starting from the index where n is present, untill n comes to the end of the array.\\n\\nAnd every time we do the swap we increase the counter in both the functions. \\n\\n**Note** - To find the index of 1 and n we use indexOf() function.\\n\\n**If you find my solution easy to understand and helpful, please upvote. It motivates me to post more solutions**\\n**Happy Coding !!**\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let count = 0\\n    let n = nums.length\\n    if(nums[0] == 1 && nums[n-1] == n){\\n        return count\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] == n){\\n        return swapFirstIndex(nums,count)\\n    }\\n\\n    if(nums[0] == 1 && nums[n-1] !== n){\\n        return swapLastIndex(nums,count,n)\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] !== n){\\n        return swapFirstIndex(nums,count) + swapLastIndex(nums,count,n)\\n    }\\n};\\n\\nfunction swapFirstIndex(nums,count){\\n    while(!(nums[0] == 1)){\\n        let indexOne = nums.indexOf(1)\\n        let right = indexOne\\n        let left = right - 1\\n            \\n        let temp = nums[right]\\n        nums[right] = nums[left]\\n        nums[left] = temp\\n        count ++\\n    }\\n    return count\\n}\\n\\nfunction swapLastIndex(nums,count,n){\\n    while(!(nums[n-1] == n)){\\n        let indexOne = nums.indexOf(n)\\n        let left = indexOne\\n        let right = left + 1\\n        \\n        let temp = nums[left]\\n        nums[left] = nums[right]\\n        nums[right] = temp\\n        \\n        count ++\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let count = 0\\n    let n = nums.length\\n    if(nums[0] == 1 && nums[n-1] == n){\\n        return count\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] == n){\\n        return swapFirstIndex(nums,count)\\n    }\\n\\n    if(nums[0] == 1 && nums[n-1] !== n){\\n        return swapLastIndex(nums,count,n)\\n    }\\n\\n    if(nums[0] !== 1 && nums[n-1] !== n){\\n        return swapFirstIndex(nums,count) + swapLastIndex(nums,count,n)\\n    }\\n};\\n\\nfunction swapFirstIndex(nums,count){\\n    while(!(nums[0] == 1)){\\n        let indexOne = nums.indexOf(1)\\n        let right = indexOne\\n        let left = right - 1\\n            \\n        let temp = nums[right]\\n        nums[right] = nums[left]\\n        nums[left] = temp\\n        count ++\\n    }\\n    return count\\n}\\n\\nfunction swapLastIndex(nums,count,n){\\n    while(!(nums[n-1] == n)){\\n        let indexOne = nums.indexOf(n)\\n        let left = indexOne\\n        let right = left + 1\\n        \\n        let temp = nums[left]\\n        nums[left] = nums[right]\\n        nums[right] = temp\\n        \\n        count ++\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691144,
                "title": "video-walkthrough",
                "content": "https://youtu.be/jdyrzn5KGqI",
                "solutionTags": [
                    "C++"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3685238,
                "title": "a-math-asb-solution",
                "content": "# Approach\\nCheck if the permutation is already semi-ordered. If so, return 0. If not, continue on to get the index of 1 and `n`. Return the sum of the distance of 1 from the 0-index and the distance of `n` from the (n-1)-index, which represents the path each value must take to its semi-ordered position. If these paths overlap (the index of `n` is less than the index of 1), then reduce this sum by one. This is because they will eventually end up being swapped with each other, moving both one index closer to the positions with only one move. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        if (nums[0] == 1 && nums[n - 1] == n) return 0;\\n\\n        int pos1 = -1, posN = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) pos1 = i;\\n            else if (nums[i] == n) posN = i;\\n            if (pos1 != -1 && posN != -1) break;\\n        }\\n\\n        int overlap = posN < pos1 ? -1 : 0;\\n        return Math.abs(0 - pos1) + Math.abs(n - 1 - posN) + overlap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        if (nums[0] == 1 && nums[n - 1] == n) return 0;\\n\\n        int pos1 = -1, posN = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) pos1 = i;\\n            else if (nums[i] == n) posN = i;\\n            if (pos1 != -1 && posN != -1) break;\\n        }\\n\\n        int overlap = posN < pos1 ? -1 : 0;\\n        return Math.abs(0 - pos1) + Math.abs(n - 1 - posN) + overlap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675679,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0]==1 and nums[n-1]==n) return 0;\\n        int low=0;\\n        int high=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) low=i;\\n            if(nums[i]==n) high=i;\\n        }\\n\\n        if(low>high){\\n            return (low-0) + (n-1-high) -1;\\n        }\\n        else return (low-0) + (n-1-high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(nums[0]==1 and nums[n-1]==n) return 0;\\n        int low=0;\\n        int high=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) low=i;\\n            if(nums[i]==n) high=i;\\n        }\\n\\n        if(low>high){\\n            return (low-0) + (n-1-high) -1;\\n        }\\n        else return (low-0) + (n-1-high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670489,
                "title": "beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int index1=-1;\\n        int indexN=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1=i;\\n            }\\n            else if(nums[i]==nums.length){\\n                indexN=i;\\n            }\\n        }\\n        return index1+(nums.length-1-indexN)-(index1 > indexN ? 1 : 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0]==1 && nums[nums.length-1]==nums.length){\\n            return 0;\\n        }\\n        int index1=-1;\\n        int indexN=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1=i;\\n            }\\n            else if(nums[i]==nums.length){\\n                indexN=i;\\n            }\\n        }\\n        return index1+(nums.length-1-indexN)-(index1 > indexN ? 1 : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657263,
                "title": "java-easy-solution-beats-100",
                "content": "# Complexity\\n- Time complexity:- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 0;\\n        int b = 0;\\n        int n = nums.length;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == 1)\\n                a = i;\\n            if(nums[i] == n)\\n                b = i;\\n        }\\n        if(a > b)\\n            b++;\\n        b = n - b - 1;\\n        return a+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int a = 0;\\n        int b = 0;\\n        int n = nums.length;\\n        for(int i = 0;i < n;i++){\\n            if(nums[i] == 1)\\n                a = i;\\n            if(nums[i] == n)\\n                b = i;\\n        }\\n        if(a > b)\\n            b++;\\n        b = n - b - 1;\\n        return a+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655641,
                "title": "java-simple-explained",
                "content": "**Idea:** \\n* Keep swapping 1 and n to their left and right neighbors respectively. \\n* You\\'ll notice that the number of swaps required (S) = distance of 1 from start + distance of n from end (but there\\'s a condition)\\n* If 1 is to the left of n, then the above formulat is correct\\n* Else if 1 is to the right of n, then in order to come to the 0th index 1 will swap itself with n, thus bringing down the swap count for n by 1, so anwer here will be S - 1\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int semiOrderedPermutation(int[] nums) {\\n\\tvar oneIdx = -1;\\n\\tvar nIdx = -1;\\n\\tvar n = nums.length;\\n\\n\\tfor (var i = 0; i < n && (oneIdx == -1 || nIdx == -1) ; i++)\\n\\t\\tif (nums[i] == 1)\\n\\t\\t\\toneIdx = i;\\n\\t\\telse if (nums[i] == n)\\n\\t\\t\\tnIdx = i;\\n\\n\\tvar swaps = oneIdx + (n - 1 - nIdx);\\n\\treturn oneIdx < nIdx ? swaps : --swaps;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int semiOrderedPermutation(int[] nums) {\\n\\tvar oneIdx = -1;\\n\\tvar nIdx = -1;\\n\\tvar n = nums.length;\\n\\n\\tfor (var i = 0; i < n && (oneIdx == -1 || nIdx == -1) ; i++)\\n\\t\\tif (nums[i] == 1)\\n\\t\\t\\toneIdx = i;\\n\\t\\telse if (nums[i] == n)\\n\\t\\t\\tnIdx = i;\\n\\n\\tvar swaps = oneIdx + (n - 1 - nIdx);\\n\\treturn oneIdx < nIdx ? swaps : --swaps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650284,
                "title": "simple-java-n-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] arr) {\\n        int idx1=0;\\n        int idx2=0;\\n        int n=arr.length;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n            idx1=i;\\n            if(arr[i]==n)\\n            idx2=i;\\n        }\\n        return idx1<idx2 ? idx1+(n-1-idx2) : idx1+(n-1-idx2)-1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] arr) {\\n        int idx1=0;\\n        int idx2=0;\\n        int n=arr.length;\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==1)\\n            idx1=i;\\n            if(arr[i]==n)\\n            idx2=i;\\n        }\\n        return idx1<idx2 ? idx1+(n-1-idx2) : idx1+(n-1-idx2)-1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648318,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1 and nums[n-1]==n){\\n            return 0;\\n        }\\n       int st,en;\\n       for(int i=0;i<n;i++){\\n         \\n         if(nums[i]==1){\\n             st=i;\\n         }\\n         if(nums[i]==n){\\n             en=i;\\n         }\\n       }\\n      if(st>en)return st+n-en-2;\\n      return st+n-1-en;\\n     \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums[0]==1 and nums[n-1]==n){\\n            return 0;\\n        }\\n       int st,en;\\n       for(int i=0;i<n;i++){\\n         \\n         if(nums[i]==1){\\n             st=i;\\n         }\\n         if(nums[i]==n){\\n             en=i;\\n         }\\n       }\\n      if(st>en)return st+n-en-2;\\n      return st+n-1-en;\\n     \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648077,
                "title": "simple-solution-by-swapping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var c = 0\\n        var temp = 0\\n        var nums = nums\\n        while(true){\\n            if(nums[0] == 1 && nums[nums.count-1] == nums.count){\\n                return c\\n            }else{\\n                for i in 0..<nums.count{\\n                    if(nums[i] == 1 && i != 0){\\n                        temp = nums[i-1]\\n                        nums[i-1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                if(nums[0] == 1){\\n                    for i in 0..<nums.count{\\n                    if(nums[i] == nums.count && i != nums.count-1){\\n                        temp = nums[i+1]\\n                        nums[i+1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        var c = 0\\n        var temp = 0\\n        var nums = nums\\n        while(true){\\n            if(nums[0] == 1 && nums[nums.count-1] == nums.count){\\n                return c\\n            }else{\\n                for i in 0..<nums.count{\\n                    if(nums[i] == 1 && i != 0){\\n                        temp = nums[i-1]\\n                        nums[i-1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                if(nums[0] == 1){\\n                    for i in 0..<nums.count{\\n                    if(nums[i] == nums.count && i != nums.count-1){\\n                        temp = nums[i+1]\\n                        nums[i+1] = nums[i]\\n                        nums[i] = temp\\n                        c += 1\\n                    }\\n                }\\n                    \\n                }\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647548,
                "title": "ts-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  let minIndex = 0;\\n  let maxIndex = nums.length - 1\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === 1) {\\n      minIndex = i\\n    } else if (nums[i] === nums.length) {\\n      maxIndex = i\\n    }\\n  }\\n  return minIndex + nums.length - 1 - maxIndex - (minIndex > maxIndex ? 1 : 0)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n  let minIndex = 0;\\n  let maxIndex = nums.length - 1\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === 1) {\\n      minIndex = i\\n    } else if (nums[i] === nums.length) {\\n      maxIndex = i\\n    }\\n  }\\n  return minIndex + nums.length - 1 - maxIndex - (minIndex > maxIndex ? 1 : 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3647435,
                "title": "java-100-beats-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {int c= 0,j=0,k=0;\\n    if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n    {\\n        return 0;\\n    }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                j=i;\\n            }\\n            if(nums[i]==nums.length)\\n            {\\n                k=i;\\n            }\\n        }\\n        if(j<k)\\n        {\\n            c=(j-0)+(nums.length-1-k);\\n        }\\n        if(k<j)\\n        {\\n             c=(j-0)+(nums.length-1-k)-1;\\n        }\\n  return c;  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {int c= 0,j=0,k=0;\\n    if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n    {\\n        return 0;\\n    }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                j=i;\\n            }\\n            if(nums[i]==nums.length)\\n            {\\n                k=i;\\n            }\\n        }\\n        if(j<k)\\n        {\\n            c=(j-0)+(nums.length-1-k);\\n        }\\n        if(k<j)\\n        {\\n             c=(j-0)+(nums.length-1-k)-1;\\n        }\\n  return c;  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647048,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int count =0;\\n        int max = nums.Max();\\n        int maxIndex = Array.IndexOf(nums, max);\\n        int min = nums.Min();\\n        int minIndex = Array.IndexOf(nums, min);\\n        if(minIndex>maxIndex){\\n            maxIndex++;\\n        }\\n        count = minIndex + nums.Length-maxIndex-1;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int count =0;\\n        int max = nums.Max();\\n        int maxIndex = Array.IndexOf(nums, max);\\n        int min = nums.Min();\\n        int minIndex = Array.IndexOf(nums, min);\\n        if(minIndex>maxIndex){\\n            maxIndex++;\\n        }\\n        count = minIndex + nums.Length-maxIndex-1;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646155,
                "title": "eazy-to-understand-c-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) check if they are at there desired positions if yes ? return 0.\\n2) find position of 1 (oneIsAt), define a counter (count).\\n3) swap 1 to its desired position and count no.of swaps.\\n4) find the position of n, check whether the last element(n) is at its position if yes return count.\\n> step 4 is important because if we do not check this then n+1 in our next step would throw error \"Array Index Out Of Bound\".\\n5) Swap the n to its place and count no of swaps.\\n6) Return count.\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N) -> worst case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return 0;\\n        }\\n        int oneIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                oneIsAt = i;\\n            }\\n        }\\n       \\n        int count = 0;\\n        while(nums[0] != 1){\\n            swap(nums[oneIsAt] , nums[oneIsAt-1]);\\n            oneIsAt--;\\n            count ++;\\n        }\\n         int nIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == nums.size()){\\n                nIsAt = i;\\n            }\\n        }\\n         if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return count;\\n        }\\n        while(nums[nums.size()-1] != nums.size()){\\n            swap(nums[nIsAt] , nums[nIsAt+1]);\\n            nIsAt++;\\n            count ++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return 0;\\n        }\\n        int oneIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                oneIsAt = i;\\n            }\\n        }\\n       \\n        int count = 0;\\n        while(nums[0] != 1){\\n            swap(nums[oneIsAt] , nums[oneIsAt-1]);\\n            oneIsAt--;\\n            count ++;\\n        }\\n         int nIsAt = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == nums.size()){\\n                nIsAt = i;\\n            }\\n        }\\n         if(nums[0] ==1  && nums[nums.size()-1] == nums.size()){\\n            return count;\\n        }\\n        while(nums[nums.size()-1] != nums.size()){\\n            swap(nums[nIsAt] , nums[nIsAt+1]);\\n            nIsAt++;\\n            count ++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645742,
                "title": "python-3-code-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need to count swaps think like that...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n***Case 1*:**\\nFirst check is there any need to swap or not.\\n\\n***case 2*:**\\nCheck for *`nums[0] == 1`* if not find the index of` 1 `and store it to `i`(current index) just swap the previous index element with the current index because in question only we need to swap with adjacent element now every swap increase the count by `1`do this until `n` comes in into position.\\n\\n*****case 3***:**\\nCheck for *`nums[len(nums)-1] == len(nums)`* if not find the index of *`len(nums)`* and store it to `i`(current index) just swap the next index element with the current index because in question only we need to swap with adjacent element now every swap increase the count by `1` do this until `n` comes in into position.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        count = 0\\n\\n        #case 1\\n        if nums[0] == 1 and nums[len(nums)-1] == len(nums):\\n            return 0\\n\\n        #case 2\\n        if nums[0] != 1:  \\n            while nums[0] != 1:\\n                i = nums.index(1)                       #finding index\\n                nums[i],nums[i-1] = nums[i-1],nums[i]   # swapping previous index with current index\\n                count += 1\\n\\n        #case 3\\n        if nums[len(nums)-1] != len(nums):  \\n            while nums[len(nums)-1] != len(nums):\\n                i = nums.index(len(nums))                   #finding index\\n                nums[i],nums[i+1] = nums[i+1],nums[i]       # swapping next index with current index\\n                count += 1\\n        \\n        return count\\n\\n```\\n\\nIf there is any mistake/suggestion please let me know below...\\uD83D\\uDC47",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        count = 0\\n\\n        #case 1\\n        if nums[0] == 1 and nums[len(nums)-1] == len(nums):\\n            return 0\\n\\n        #case 2\\n        if nums[0] != 1:  \\n            while nums[0] != 1:\\n                i = nums.index(1)                       #finding index\\n                nums[i],nums[i-1] = nums[i-1],nums[i]   # swapping previous index with current index\\n                count += 1\\n\\n        #case 3\\n        if nums[len(nums)-1] != len(nums):  \\n            while nums[len(nums)-1] != len(nums):\\n                i = nums.index(len(nums))                   #finding index\\n                nums[i],nums[i+1] = nums[i+1],nums[i]       # swapping next index with current index\\n                count += 1\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640995,
                "title": "easy-to-understand-solution-just-3-lines",
                "content": "## Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        first, n_th = nums.index(1), nums.index(n)\\n        return first + n - 1 - n_th - (first > n_th)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        first, n_th = nums.index(1), nums.index(n)\\n        return first + n - 1 - n_th - (first > n_th)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640484,
                "title": "100-beat-java-beginner-friendly-solution",
                "content": "#\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n     int n = nums.length;\\n     int a=0,b=0,c=0;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==1){\\n             a = i;\\n         }\\n     }\\n         while(nums[0]!=1){\\n             int temp = nums[a-1];\\n             nums[a-1] = nums[a];\\n             nums[a] = temp;\\n             a = a-1;\\n             c++;\\n         }\\n         for(int j=0;j<n;j++){\\n         if(nums[j]==n){\\n             b = j;\\n         }\\n     }\\n         while(nums[n-1]!=n && b+1<n){\\n             int t = nums[b+1];\\n             nums[b+1] = nums[b];\\n             nums[b] = t;\\n             b = b+1;\\n             c++;\\n         }\\n     return c;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n     int n = nums.length;\\n     int a=0,b=0,c=0;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==1){\\n             a = i;\\n         }\\n     }\\n         while(nums[0]!=1){\\n             int temp = nums[a-1];\\n             nums[a-1] = nums[a];\\n             nums[a] = temp;\\n             a = a-1;\\n             c++;\\n         }\\n         for(int j=0;j<n;j++){\\n         if(nums[j]==n){\\n             b = j;\\n         }\\n     }\\n         while(nums[n-1]!=n && b+1<n){\\n             int t = nums[b+1];\\n             nums[b+1] = nums[b];\\n             nums[b] = t;\\n             b = b+1;\\n             c++;\\n         }\\n     return c;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639729,
                "title": "c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int firstElIndex = -1;\\n        int lastElIndex = -1;\\n\\n        for(int i=0; i<nums.Length; i++){\\n            if(nums[i] == 1){\\n                firstElIndex = i;\\n            }\\n\\n            if(nums[i] == nums.Length){\\n                lastElIndex = i;\\n            }\\n        }\\n\\n        int numberOfSwaps = firstElIndex + nums.Length - lastElIndex - 1;\\n        return firstElIndex > lastElIndex ? numberOfSwaps - 1 : numberOfSwaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        int firstElIndex = -1;\\n        int lastElIndex = -1;\\n\\n        for(int i=0; i<nums.Length; i++){\\n            if(nums[i] == 1){\\n                firstElIndex = i;\\n            }\\n\\n            if(nums[i] == nums.Length){\\n                lastElIndex = i;\\n            }\\n        }\\n\\n        int numberOfSwaps = firstElIndex + nums.Length - lastElIndex - 1;\\n        return firstElIndex > lastElIndex ? numberOfSwaps - 1 : numberOfSwaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639093,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        const auto index1 = find(begin(nums), end(nums), 1);\\n        const auto indexN = find(begin(nums), end(nums), nums.size());\\n        return distance(begin(nums), index1) + distance(indexN, end(nums)) - 1 - (indexN < index1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        const auto index1 = find(begin(nums), end(nums), 1);\\n        const auto indexN = find(begin(nums), end(nums), nums.size());\\n        return distance(begin(nums), index1) + distance(indexN, end(nums)) - 1 - (indexN < index1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629006,
                "title": "java-easy-solution-100-faster-o-n-time-complexity-o-1-space",
                "content": "# Intuition\\nFind total shifts needed to shift 1 and n to correct posiitons.\\n\\n# Approach\\nIf n is present before 1, we would need one less shift, as they both can be shifted once when they cross the path and it would count as 1 operation instead of 2.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = -1;\\n        int lastIndex = -1;\\n        int ops =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == 1) oneIndex = i;\\n            if(nums[i] == n) lastIndex = i; \\n        }\\n\\n        //Total Shifts to make 1 reach the start\\n        ops += oneIndex;\\n        //Total Shifts to make n reach the last.\\n        ops += (n-1)-lastIndex;\\n        //If n is before 1, we have to do one less shift.\\n        if(lastIndex < oneIndex) ops--;\\n\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int oneIndex = -1;\\n        int lastIndex = -1;\\n        int ops =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == 1) oneIndex = i;\\n            if(nums[i] == n) lastIndex = i; \\n        }\\n\\n        //Total Shifts to make 1 reach the start\\n        ops += oneIndex;\\n        //Total Shifts to make n reach the last.\\n        ops += (n-1)-lastIndex;\\n        //If n is before 1, we have to do one less shift.\\n        if(lastIndex < oneIndex) ops--;\\n\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628737,
                "title": "super-easy-2ms-java-code",
                "content": "# APPROACH \\nfind index-i of 1 ie i operations needed\\nfind index-j of n ie n-j-1 operations needed\\nadd both i+j\\nand if j<i then do -1\\n\\n#\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\n class Solution{\\n    public int semiOrderedPermutation(int[] nums) \\n    {\\n        int n=nums.length,res=0,indexOf1=0,indexOfn=n;\\n        for(int i=0;i<n;i++)\\n        {\\n        if(nums[i]==1) indexOf1=i;\\n        if(nums[i]==n) indexOfn=i;\\n        }\\n        res=n+ indexOf1-indexOfn-1;\\n         if(indexOfn<indexOf1)\\n         res--;\\n         return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution{\\n    public int semiOrderedPermutation(int[] nums) \\n    {\\n        int n=nums.length,res=0,indexOf1=0,indexOfn=n;\\n        for(int i=0;i<n;i++)\\n        {\\n        if(nums[i]==1) indexOf1=i;\\n        if(nums[i]==n) indexOfn=i;\\n        }\\n        res=n+ indexOf1-indexOfn-1;\\n         if(indexOfn<indexOf1)\\n         res--;\\n         return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627502,
                "title": "iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                one=i\\n            elif nums[i] ==len(nums):\\n                last=i\\n        if one<last:\\n            return one+(len(nums)-1-last)\\n        else:\\n            return one+(len(nums)-1-last)-1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                one=i\\n            elif nums[i] ==len(nums):\\n                last=i\\n        if one<last:\\n            return one+(len(nums)-1-last)\\n        else:\\n            return one+(len(nums)-1-last)-1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625619,
                "title": "c-solution",
                "content": "```\\nint semiOrderedPermutation(vector<int>& nums) {\\n\\tauto mn = min_element(begin(nums), end(nums));\\n\\tauto mx = max_element(begin(nums), end(nums));\\n\\tint stPos = distance(begin(nums), mn);\\n\\tint endPos = distance(begin(nums), mx);\\n\\tint res = stPos + nums.size() - endPos - 1;\\n\\treturn res < nums.size() ? res : res - 1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint semiOrderedPermutation(vector<int>& nums) {\\n\\tauto mn = min_element(begin(nums), end(nums));\\n\\tauto mx = max_element(begin(nums), end(nums));\\n\\tint stPos = distance(begin(nums), mn);\\n\\tint endPos = distance(begin(nums), mx);\\n\\tint res = stPos + nums.size() - endPos - 1;\\n\\treturn res < nums.size() ? res : res - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625459,
                "title": "from-simulation-to-formula",
                "content": "**Simulation: brute-force**\\n1. Find pos of `min` and `max` values\\n2. Simulate what you would do with swaps on an array:\\n- swap `max` right till you have `[N - 1] = N`\\n- swap `min` left till you have `[0] = 1`\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = max_pos = 0\\n        for i in range(N):\\n            if nums[i] == 1:\\n                min_pos = i\\n            if nums[i] == N:\\n                max_pos = i\\n        count = 0\\n        while nums[0] != 1 or nums[N - 1] != N:\\n            if nums[0] != 1:\\n                nums[min_pos], nums[min_pos - 1] = nums[min_pos - 1], nums[min_pos]\\n                if nums[min_pos] == N:\\n                    max_pos += 1\\n                min_pos -= 1\\n            elif nums[N - 1] != N:\\n                nums[max_pos], nums[max_pos + 1] = nums[max_pos + 1], nums[max_pos]\\n                if nums[max_pos] == 1:\\n                    min_pos -= 1\\n                max_pos += 1\\n            count += 1\\n        return count\\n```\\n\\n**Formula**\\nAnalysis of what simulaton does:\\nSimulate what you would do with swaps on an array:\\n- swap `max` right till you have `[N - 1] = N`\\n- swap `min` left till you have `[0] = 1`\\n\\n2 examples would be enough to show observations and logic:\\n\\n1 ) `min_pos` does not cross `max_pos` position\\n```\\n<---- ---->\\n3 2 1 6 5 4\\n  1 # 1 swap\\n1 # 1 swap\\n        6 # 1 swap\\n          6 # 1 swap\\n```\\n2 ) `min_pos` crosses `max_pos` position\\n```\\n<---- ---->\\n6 5 4 3 2 1\\n  6 # 1 swap\\n    6 # 1 swap\\n      6 # 1 swap\\n        6 # 1 swap\\n\\n*** !!! This is the important moment, when min_pos and max_pos are in adjacent positions !!! ***\\n6 5 4 3[6 1]\\n       [1 6] # 1 swap, but this swap also swaps 1 to the left by 1 !!! This is a free ride for min_pos left by 1 pos!!!\\n```\\nSo you need to calc travel for `min_pos` to get to `[0]` + `max_pos` to get to `[N-1]` - 1 pos if you have case #2 (`min_pos` > `max_pos`)\\n\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = nums.index(1)\\n        max_pos = nums.index(N)\\n\\t\\t# min_pos to [0] + max_pos to [N - 1] - free ride, if any\\n        return (min_pos) + (N - 1 - max_pos) - (min_pos > max_pos)\\n```\\n\\nFor 1-line fans:\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        return (min_pos := nums.index(1)) + (N := len(nums)) - 1 - (max_pos := nums.index(N)) - (min_pos > max_pos)\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = max_pos = 0\\n        for i in range(N):\\n            if nums[i] == 1:\\n                min_pos = i\\n            if nums[i] == N:\\n                max_pos = i\\n        count = 0\\n        while nums[0] != 1 or nums[N - 1] != N:\\n            if nums[0] != 1:\\n                nums[min_pos], nums[min_pos - 1] = nums[min_pos - 1], nums[min_pos]\\n                if nums[min_pos] == N:\\n                    max_pos += 1\\n                min_pos -= 1\\n            elif nums[N - 1] != N:\\n                nums[max_pos], nums[max_pos + 1] = nums[max_pos + 1], nums[max_pos]\\n                if nums[max_pos] == 1:\\n                    min_pos -= 1\\n                max_pos += 1\\n            count += 1\\n        return count\\n```\n```\\n<---- ---->\\n3 2 1 6 5 4\\n  1 # 1 swap\\n1 # 1 swap\\n        6 # 1 swap\\n          6 # 1 swap\\n```\n```\\n<---- ---->\\n6 5 4 3 2 1\\n  6 # 1 swap\\n    6 # 1 swap\\n      6 # 1 swap\\n        6 # 1 swap\\n\\n*** !!! This is the important moment, when min_pos and max_pos are in adjacent positions !!! ***\\n6 5 4 3[6 1]\\n       [1 6] # 1 swap, but this swap also swaps 1 to the left by 1 !!! This is a free ride for min_pos left by 1 pos!!!\\n```\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        min_pos = nums.index(1)\\n        max_pos = nums.index(N)\\n\\t\\t# min_pos to [0] + max_pos to [N - 1] - free ride, if any\\n        return (min_pos) + (N - 1 - max_pos) - (min_pos > max_pos)\\n```\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        return (min_pos := nums.index(1)) + (N := len(nums)) - 1 - (max_pos := nums.index(N)) - (min_pos > max_pos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621951,
                "title": "c-no-swap-o-n",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int p1 = -1, pn = -1, n = nums.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                p1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                pn = i;\\n            }\\n        }\\n\\n        return p1 + (n - pn - 1) - (p1 > pn);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) \\n    {\\n        int p1 = -1, pn = -1, n = nums.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (nums[i] == 1)\\n            {\\n                p1 = i;\\n            }\\n\\n            if (nums[i] == nums.size())\\n            {\\n                pn = i;\\n            }\\n        }\\n\\n        return p1 + (n - pn - 1) - (p1 > pn);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621126,
                "title": "using-index-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                f = i\\n            elif nums[i] == len(nums):\\n                l = i\\n        if l<f:\\n            return len(nums)-1-l+f-1\\n        else:\\n            return len(nums)-1-l+f\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                f = i\\n            elif nums[i] == len(nums):\\n                l = i\\n        if l<f:\\n            return len(nums)-1-l+f-1\\n        else:\\n            return len(nums)-1-l+f\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619924,
                "title": "elixir-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 381ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 62.4MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec semi_ordered_permutation(nums :: [integer]) :: integer\\n  def semi_ordered_permutation(nums) do\\n    n = Enum.count(nums)\\n    {_, {pos1, pos2}} =\\n      Enum.reduce(nums, {0, {0, 0}}, fn num, {i, {pos1, pos2}} ->\\n        cond do\\n          num == 1 ->\\n            {i + 1, {i, pos2}}\\n          num == n ->\\n            {i + 1, {pos1, i}}\\n          true ->\\n            {i + 1, {pos1, pos2}}\\n        end\\n      end)\\n    if pos1 > pos2, do: pos1 + n - 1 - pos2 - 1, else: pos1 + n - 1 - pos2\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec semi_ordered_permutation(nums :: [integer]) :: integer\\n  def semi_ordered_permutation(nums) do\\n    n = Enum.count(nums)\\n    {_, {pos1, pos2}} =\\n      Enum.reduce(nums, {0, {0, 0}}, fn num, {i, {pos1, pos2}} ->\\n        cond do\\n          num == 1 ->\\n            {i + 1, {i, pos2}}\\n          num == n ->\\n            {i + 1, {pos1, i}}\\n          true ->\\n            {i + 1, {pos1, pos2}}\\n        end\\n      end)\\n    if pos1 > pos2, do: pos1 + n - 1 - pos2 - 1, else: pos1 + n - 1 - pos2\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3619531,
                "title": "java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int p1 = 0,pn = 0;\\n        for(int i = 0;i < nums.length;i++){\\n            if(nums[i] == 1) p1 = i;\\n            else if(nums[i] == nums.length) pn = i;\\n        }\\n        int ans = p1 + nums.length - 1 - pn;\\n        if(p1 > pn) --ans; // because in this case `1` and `n` will share one common swap\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int p1 = 0,pn = 0;\\n        for(int i = 0;i < nums.length;i++){\\n            if(nums[i] == 1) p1 = i;\\n            else if(nums[i] == nums.length) pn = i;\\n        }\\n        int ans = p1 + nums.length - 1 - pn;\\n        if(p1 > pn) --ans; // because in this case `1` and `n` will share one common swap\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619471,
                "title": "easy-clean-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a very straightforward approach, we can simply, easily simulate it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep track of the given indices of 1 and the last element. Perform swaps and calculate swaps to find the required answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the size of nums\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        reqd = {1:0, n:(n-1)}\\n        given = {1:0, n:0}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                given[1] = i\\n            if nums[i] == n:\\n                given[n] = i\\n        if given == reqd: return 0\\n        if given[n] < given[1]:\\n            return n-1-given[n]+given[1]-1\\n        else:\\n            return given[1] + (n-1) - given[n]\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        reqd = {1:0, n:(n-1)}\\n        given = {1:0, n:0}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                given[1] = i\\n            if nums[i] == n:\\n                given[n] = i\\n        if given == reqd: return 0\\n        if given[n] < given[1]:\\n            return n-1-given[n]+given[1]-1\\n        else:\\n            return given[1] + (n-1) - given[n]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619132,
                "title": "find-positions-and-return",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let fPos = 0;\\n    let lPos = 0;\\n    const n = nums.length;\\n    for(let i=0; i<n; i++) {\\n        if(nums[i] == 1) fPos = i;\\n        else if(nums[i] == n) lPos = i;\\n    }\\n    \\n    return lPos < fPos? (n - lPos + fPos - 2) : (n - lPos + fPos - 1); \\n    \\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nfunction semiOrderedPermutation(nums: number[]): number {\\n    let fPos = 0;\\n    let lPos = 0;\\n    const n = nums.length;\\n    for(let i=0; i<n; i++) {\\n        if(nums[i] == 1) fPos = i;\\n        else if(nums[i] == n) lPos = i;\\n    }\\n    \\n    return lPos < fPos? (n - lPos + fPos - 2) : (n - lPos + fPos - 1); \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619013,
                "title": "java-solution-easy-to-understand-swap-2ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int s=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                s=i;\\n                break;\\n            }\\n        }\\n        int e=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==nums.length){\\n                e=i;\\n                break;\\n            }\\n        }\\n        int s1=s;\\n        int e1=e;\\n        int c=0;\\n        while(e!=nums.length-1){\\n            c++;\\n            e++;\\n        }\\n        while(s!=0){\\n            c++;\\n            s--;\\n        }\\n        if(s1>e1)return c-1;\\n        else return c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int s=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                s=i;\\n                break;\\n            }\\n        }\\n        int e=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==nums.length){\\n                e=i;\\n                break;\\n            }\\n        }\\n        int s1=s;\\n        int e1=e;\\n        int c=0;\\n        while(e!=nums.length-1){\\n            c++;\\n            e++;\\n        }\\n        while(s!=0){\\n            c++;\\n            s--;\\n        }\\n        if(s1>e1)return c-1;\\n        else return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618551,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min_indx = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int max_indx = max_element(nums.begin(),nums.end()) - nums.begin();\\n        int n = nums.size();\\n        int cnt = 0;\\n        cnt += (min_indx);\\n        cnt += (n-1-max_indx);\\n        //this is because if max_indx is less than min_indx then by swaping the max_indx will get increase by 1;\\n        if(min_indx>max_indx){\\n            cnt--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min_indx = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int max_indx = max_element(nums.begin(),nums.end()) - nums.begin();\\n        int n = nums.size();\\n        int cnt = 0;\\n        cnt += (min_indx);\\n        cnt += (n-1-max_indx);\\n        //this is because if max_indx is less than min_indx then by swaping the max_indx will get increase by 1;\\n        if(min_indx>max_indx){\\n            cnt--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618477,
                "title": "2ms-100-java-solution",
                "content": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        int index1=0;\\n        int indexn=0;\\n        int n=nums.length;\\n        if(n==1)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n            }\\n            else if(nums[i]==n)\\n            {\\n                indexn=i;\\n            }\\n        }\\n        int carry=(index1>indexn)?1:0;\\n        return index1+(n-indexn-1)-carry;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        int index1=0;\\n        int indexn=0;\\n        int n=nums.length;\\n        if(n==1)return 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                index1=i;\\n            }\\n            else if(nums[i]==n)\\n            {\\n                indexn=i;\\n            }\\n        }\\n        int carry=(index1>indexn)?1:0;\\n        return index1+(n-indexn-1)-carry;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618086,
                "title": "simulate-the-process-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums)\\n    {\\n          int count = 0;\\n          //we can just simulate the whole process using the loop or iteratons\\n\\n          //we need to find the position of the 1 in the nums vector\\n          int onepos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == 1)\\n              {\\n                  onepos = i;\\n                  break;\\n              }\\n          }\\n          if(onepos != 0)\\n          {\\n               while(onepos != 0)\\n               {\\n                   int temp       = nums[onepos-1];\\n                   nums[onepos-1] = nums[onepos];\\n                   nums[onepos]   = temp;\\n                   count++;\\n\\n                   onepos = onepos - 1;   \\n               }\\n          }\\n\\n          //we need to fnd the positon of the n in the nums vector\\n          int npos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == nums.size())\\n              {\\n                  npos = i;\\n                  break;\\n              }\\n          }\\n          if(npos != nums.size()-1)\\n          {\\n               while(npos != nums.size()-1)\\n               {\\n                   int temp       = nums[npos+1];\\n                   nums[npos+1] = nums[npos];\\n                   nums[npos]   = temp;\\n                   count++;\\n\\n                   npos = npos + 1;   \\n               }\\n          }\\n          return count;          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums)\\n    {\\n          int count = 0;\\n          //we can just simulate the whole process using the loop or iteratons\\n\\n          //we need to find the position of the 1 in the nums vector\\n          int onepos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == 1)\\n              {\\n                  onepos = i;\\n                  break;\\n              }\\n          }\\n          if(onepos != 0)\\n          {\\n               while(onepos != 0)\\n               {\\n                   int temp       = nums[onepos-1];\\n                   nums[onepos-1] = nums[onepos];\\n                   nums[onepos]   = temp;\\n                   count++;\\n\\n                   onepos = onepos - 1;   \\n               }\\n          }\\n\\n          //we need to fnd the positon of the n in the nums vector\\n          int npos = -1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(nums[i] == nums.size())\\n              {\\n                  npos = i;\\n                  break;\\n              }\\n          }\\n          if(npos != nums.size()-1)\\n          {\\n               while(npos != nums.size()-1)\\n               {\\n                   int temp       = nums[npos+1];\\n                   nums[npos+1] = nums[npos];\\n                   nums[npos]   = temp;\\n                   count++;\\n\\n                   npos = npos + 1;   \\n               }\\n          }\\n          return count;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616433,
                "title": "easy-python-just-find-the-index-of-1-and-n",
                "content": "\\tclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)+1\\n        j=nums.index(n)+1\\n        if i<j:\\n            return (n-j)+(i-1)\\n        else:\\n            return (n-j)+(i-1) -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        i=nums.index(1)+1\\n        j=nums.index(n)+1\\n        if i<j:\\n            return (n-j)+(i-1)\\n        else:\\n            return (n-j)+(i-1) -1",
                "codeTag": "Java"
            },
            {
                "id": 3615997,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def semiOrderedPermutation(nums: Array[Int]): Int = {\\n    val n = nums.length\\n    val left = nums.indexOf(1)\\n    val right = nums.indexOf(n)\\n    left + (n - 1 - right) - (if(left > right) 1 else 0)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def semiOrderedPermutation(nums: Array[Int]): Int = {\\n    val n = nums.length\\n    val left = nums.indexOf(1)\\n    val right = nums.indexOf(n)\\n    left + (n - 1 - right) - (if(left > right) 1 else 0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3615811,
                "title": "c-basic-searching-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int  n=size(nums),i=find(begin(nums),end(nums),1)-begin(nums),j=find(begin(nums),end(nums),n)-begin(nums);\\n        return n-1-j+i-(i>j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int  n=size(nums),i=find(begin(nums),end(nums),1)-begin(nums),j=find(begin(nums),end(nums),n)-begin(nums);\\n        return n-1-j+i-(i>j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615465,
                "title": "c-python-code-easy-to-understanf",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx1 , idxn , n = nums.size() ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                idx1 = i ;\\n            }\\n            else if(nums[i] == n)\\n            {\\n                idxn = i ;\\n            }\\n        }\\n        return idx1 > idxn ? idx1 + (n - idxn) - 2 : idx1 + (n - idxn) - 1 ;\\n    }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        val1 = -1\\n        valn = -1\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] == 1:\\n                val1 = i\\n            elif nums[i] == n:\\n                valn = i\\n        if val1 > valn:\\n            return val1 + (n - valn) - 2\\n        return val1 + (n-valn) - 1\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int idx1 , idxn , n = nums.size() ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                idx1 = i ;\\n            }\\n            else if(nums[i] == n)\\n            {\\n                idxn = i ;\\n            }\\n        }\\n        return idx1 > idxn ? idx1 + (n - idxn) - 2 : idx1 + (n - idxn) - 1 ;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        val1 = -1\\n        valn = -1\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] == 1:\\n                val1 = i\\n            elif nums[i] == n:\\n                valn = i\\n        if val1 > valn:\\n            return val1 + (n - valn) - 2\\n        return val1 + (n-valn) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615378,
                "title": "python-3",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        f, l = nums.index(1), nums.index(n)\\n\\n        if f < l:\\n            return f + (n - 1 - l)\\n\\n        else:\\n            return f + (n - 1 - l - 1)\\n\\n        \\n        \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n\\n        n = len(nums)\\n        f, l = nums.index(1), nums.index(n)\\n\\n        if f < l:\\n            return f + (n - 1 - l)\\n\\n        else:\\n            return f + (n - 1 - l - 1)\\n\\n        \\n        \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614690,
                "title": "simple-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        last=max(nums)\\n        if(nums[0]==1 and nums[-1]==last):\\n            return 0\\n        count=0\\n        while(nums[0]!=1):\\n            index1=nums.index(1)\\n            i=index1-1\\n            nums[index1], nums[i]=nums[i],nums[index1]\\n            count+=1\\n            \\n        while(nums[len(nums)-1]!=last):\\n            indexlast=nums.index(last)\\n            i=indexlast+1\\n            nums[indexlast], nums[i]=nums[i],nums[indexlast]\\n            count+=1\\n        \\n        return count\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        last=max(nums)\\n        if(nums[0]==1 and nums[-1]==last):\\n            return 0\\n        count=0\\n        while(nums[0]!=1):\\n            index1=nums.index(1)\\n            i=index1-1\\n            nums[index1], nums[i]=nums[i],nums[index1]\\n            count+=1\\n            \\n        while(nums[len(nums)-1]!=last):\\n            indexlast=nums.index(last)\\n            i=indexlast+1\\n            nums[indexlast], nums[i]=nums[i],nums[indexlast]\\n            count+=1\\n        \\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613943,
                "title": "best-solution-with-example-beats-100-without-swapping",
                "content": "# Intuition\\nproblem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\n\\nfind index of minimum element i.e 1 and maximum element i.e nums.length\\n\\nthat means elements before index1 and after index2 have to be swapped \\n![20230608_192346.jpg](https://assets.leetcode.com/users/images/b3a4eeea-66de-4fd8-8c4f-8d8ca9709d4d_1686232773.1585362.jpeg)\\n\\nwhat if index2<index1 you can you figure it out by your own? :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index1 =0;\\n        int index2 =0;\\n        \\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1 =i;\\n                continue;\\n            }\\n            \\n            if(nums[i]==nums.length){\\n                index2 = i;\\n                continue;\\n            }\\n        }\\n        \\n        if(index2<index1){\\n            index2 = nums.length-1 - index2;\\n            \\n            return (index1+index2)-1;\\n        }\\n        \\n        index2 = nums.length -1 - index2;\\n        \\n        return (index1+index2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index1 =0;\\n        int index2 =0;\\n        \\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                index1 =i;\\n                continue;\\n            }\\n            \\n            if(nums[i]==nums.length){\\n                index2 = i;\\n                continue;\\n            }\\n        }\\n        \\n        if(index2<index1){\\n            index2 = nums.length-1 - index2;\\n            \\n            return (index1+index2)-1;\\n        }\\n        \\n        index2 = nums.length -1 - index2;\\n        \\n        return (index1+index2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613588,
                "title": "java-simple-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n public int semiOrderedPermutation(int[] nums) {\\n    int indexOf1 = -1, indexOfN = -1;\\n    for(int i = 0; i < nums.length; i++){\\n        if(nums[i] == 1) indexOf1 = i;\\n        else if(nums[i] == nums.length) indexOfN = i;\\n    }\\n    return indexOf1 + nums.length - 1 - indexOfN - ((indexOfN < indexOf1) ? 1 : 0) ;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int semiOrderedPermutation(int[] nums) {\\n    int indexOf1 = -1, indexOfN = -1;\\n    for(int i = 0; i < nums.length; i++){\\n        if(nums[i] == 1) indexOf1 = i;\\n        else if(nums[i] == nums.length) indexOfN = i;\\n    }\\n    return indexOf1 + nums.length - 1 - indexOfN - ((indexOfN < indexOf1) ? 1 : 0) ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611842,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=fun1(nums)+fun2(nums);\\n        return ans;\\n    }\\n    int fun1(vector<int>&nums)\\n    {\\n        if(nums[0]==1)\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                swap(nums[i],nums[i-1]);\\n                return 1+fun1(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n    int fun2(vector<int>&nums)\\n    {\\n        if(nums[nums.size()-1]==nums.size())\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                swap(nums[i],nums[i+1]);\\n                return 1+fun2(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int ans=fun1(nums)+fun2(nums);\\n        return ans;\\n    }\\n    int fun1(vector<int>&nums)\\n    {\\n        if(nums[0]==1)\\n        {\\n            return 0;\\n        }\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                swap(nums[i],nums[i-1]);\\n                return 1+fun1(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n    int fun2(vector<int>&nums)\\n    {\\n        if(nums[nums.size()-1]==nums.size())\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums.size())\\n            {\\n                swap(nums[i],nums[i+1]);\\n                return 1+fun2(nums);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611295,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        var min = (int.MaxValue, 0);\\n        var max = (0, 0);\\n        for(var i = 0; i < nums.Length; i++){\\n            if(nums[i] < min.Item1)\\n                min = (nums[i], i);\\n            if(nums[i] > max.Item1)\\n                max = (nums[i], i);\\n        }\\n\\n        if(min.Item2 > max.Item2)\\n            return min.Item2 + (nums.Length - 2 - max.Item2);\\n        else\\n            return min.Item2 + (nums.Length - 1 - max.Item2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SemiOrderedPermutation(int[] nums) {\\n        var min = (int.MaxValue, 0);\\n        var max = (0, 0);\\n        for(var i = 0; i < nums.Length; i++){\\n            if(nums[i] < min.Item1)\\n                min = (nums[i], i);\\n            if(nums[i] > max.Item1)\\n                max = (nums[i], i);\\n        }\\n\\n        if(min.Item2 > max.Item2)\\n            return min.Item2 + (nums.Length - 2 - max.Item2);\\n        else\\n            return min.Item2 + (nums.Length - 1 - max.Item2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610955,
                "title": "js-solution-95-ms",
                "content": "# Complexity\\n- Time complexity:\\n95 ms\\n\\n- Space complexity:\\n45.5 MB\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n  const indexMin = nums.indexOf(Math.min(...nums))\\n  const indexMax = nums.indexOf(Math.max(...nums))\\n\\n  if(indexMin > indexMax){\\n    return indexMin + nums.length - 1 - indexMax - 1\\n  } else {\\n    return indexMin + nums.length - 1 - indexMax\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar semiOrderedPermutation = function(nums) {\\n  const indexMin = nums.indexOf(Math.min(...nums))\\n  const indexMax = nums.indexOf(Math.max(...nums))\\n\\n  if(indexMin > indexMax){\\n    return indexMin + nums.length - 1 - indexMax - 1\\n  } else {\\n    return indexMin + nums.length - 1 - indexMax\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610805,
                "title": "simple-formula",
                "content": "\\n# Code\\n```\\ndef semiOrderedPermutation(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    return nums.index(1) + n - 1 - nums.index(n) - int(nums.index(1) > nums.index(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef semiOrderedPermutation(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    return nums.index(1) + n - 1 - nums.index(n) - int(nums.index(1) > nums.index(n))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3609704,
                "title": "easyyyyy",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        c1=0\\n        cn=0\\n        ind1=nums.index(1)\\n        for i in range(ind1-1,-1,-1):\\n            if nums[i]!=n:\\n                c1+=1\\n        indn=nums.index(n)\\n        for j in range(indn+1,n):\\n            cn+=1\\n        return c1+cn\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        c1=0\\n        cn=0\\n        ind1=nums.index(1)\\n        for i in range(ind1-1,-1,-1):\\n            if nums[i]!=n:\\n                c1+=1\\n        indn=nums.index(n)\\n        for j in range(indn+1,n):\\n            cn+=1\\n        return c1+cn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609283,
                "title": "pure-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        \\n        int n = nums.length;\\n        int r1=0;\\n        int r2=0;\\n        while (true) {\\n            if(nums[0]==1 && nums[n-1]==n){\\n                break;\\n            }\\n            while(nums[0]!=1){\\n                int first = getPosition(1,nums);\\n                swap(first,first-1,nums);\\n                r1++;\\n            }\\n            while(nums[n-1]!=n){\\n                int last = getPosition(n,nums);\\n                swap(last,last+1,nums);\\n                r2++;\\n            }\\n        }\\n        int result = r1+r2;\\n        return result;\\n        \\n    }\\n    \\n     public static void swap(int a,int b,int[] nums){\\n\\n        int temp= nums[a];\\n        nums[a]= nums[b];\\n        nums[b]=temp;\\n\\n//        System.out.println(\"a\"+a+\"b\"+b);\\n    }\\n\\n    public static int getPosition(int a,int[] nums){\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==a){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        \\n        \\n        int n = nums.length;\\n        int r1=0;\\n        int r2=0;\\n        while (true) {\\n            if(nums[0]==1 && nums[n-1]==n){\\n                break;\\n            }\\n            while(nums[0]!=1){\\n                int first = getPosition(1,nums);\\n                swap(first,first-1,nums);\\n                r1++;\\n            }\\n            while(nums[n-1]!=n){\\n                int last = getPosition(n,nums);\\n                swap(last,last+1,nums);\\n                r2++;\\n            }\\n        }\\n        int result = r1+r2;\\n        return result;\\n        \\n    }\\n    \\n     public static void swap(int a,int b,int[] nums){\\n\\n        int temp= nums[a];\\n        nums[a]= nums[b];\\n        nums[b]=temp;\\n\\n//        System.out.println(\"a\"+a+\"b\"+b);\\n    }\\n\\n    public static int getPosition(int a,int[] nums){\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==a){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608830,
                "title": "easy-cpp-solution-6-line-code",
                "content": "\\n# Approach\\nfind min and max element index by using stl (min & max element)\\nif max is left of min then \\nwe find min index from start ans max index from end \\nboth add and -1 for (one we swap both)\\notherwise we simple max from end index \\nadd min and max index then return add of both\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n- 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min=min_element(nums.begin(),nums.end())-nums.begin();\\n        int max=max_element(nums.begin(),nums.end())-nums.begin();\\n        if(max<min){\\n            max=(nums.size()-1)-max;\\n            return (max+min)-1;\\n        }\\n        max=(nums.size()-1)-max;\\n        return max+min;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int min=min_element(nums.begin(),nums.end())-nums.begin();\\n        int max=max_element(nums.begin(),nums.end())-nums.begin();\\n        if(max<min){\\n            max=(nums.size()-1)-max;\\n            return (max+min)-1;\\n        }\\n        max=(nums.size()-1)-max;\\n        return max+min;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608172,
                "title": "straight-forward",
                "content": "# Intuition\\nbased on the location of 1 and the nums.length\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index_of_first = 0;\\n        int index_of_last = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1)\\n                index_of_first = i;\\n            if (nums[i] == nums.length)\\n                index_of_last = i;\\n        }\\n\\n        if (index_of_first > index_of_last) {\\n            return index_of_first + nums.length - 1 - index_of_last - 1;\\n        } else {\\n            return index_of_first + nums.length - 1 - index_of_last;\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        int index_of_first = 0;\\n        int index_of_last = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1)\\n                index_of_first = i;\\n            if (nums[i] == nums.length)\\n                index_of_last = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3608123,
                "title": "recursive-swapping",
                "content": "# Intuition\\nRecursive swapping.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       boolean checkForCross=true;\\n       int global_first=0;\\n       int global_second=0;\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        int first=0;\\n        int second=0;\\n     \\n        if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n        return 0;\\n       else if(nums[0]==1)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==nums.length)\\n                {\\n                    return nums.length-i-1;\\n                }\\n            }\\n        }\\n       else if(nums[nums.length-1]==nums.length)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n            global_first=first;global_second=second;\\n\\n           int finalResult=swap(nums,first,second);\\n           return finalResult;\\n        }\\n        return -1;\\n    }\\n    \\n    public int swap(int[] nums,int first,int second)\\n    {\\nif(nums[0]==1 && checkForCross==false)return global_first+(nums.length-1-global_second)-1;\\nif(nums[0]==1 && checkForCross==true)return global_first+(nums.length-1-global_second);\\n       for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n       if(second==first-1)checkForCross=false;\\n       int dummy=nums[first];\\n       nums[first]=nums[first-1];\\n       nums[first-1]=dummy;\\n       return swap(nums,first,second);\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       boolean checkForCross=true;\\n       int global_first=0;\\n       int global_second=0;\\n    public int semiOrderedPermutation(int[] nums) {\\n        int count=0;\\n        int first=0;\\n        int second=0;\\n     \\n        if(nums[0]==1 && nums[nums.length-1]==nums.length)\\n        return 0;\\n       else if(nums[0]==1)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==nums.length)\\n                {\\n                    return nums.length-i-1;\\n                }\\n            }\\n        }\\n       else if(nums[nums.length-1]==nums.length)\\n        {\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n            global_first=first;global_second=second;\\n\\n           int finalResult=swap(nums,first,second);\\n           return finalResult;\\n        }\\n        return -1;\\n    }\\n    \\n    public int swap(int[] nums,int first,int second)\\n    {\\nif(nums[0]==1 && checkForCross==false)return global_first+(nums.length-1-global_second)-1;\\nif(nums[0]==1 && checkForCross==true)return global_first+(nums.length-1-global_second);\\n       for(int i=0;i<nums.length;i++)\\n            {\\n                if(nums[i]==1)first=i;\\n                if(nums[i]==nums.length)second=i;\\n            }\\n       if(second==first-1)checkForCross=false;\\n       int dummy=nums[first];\\n       nums[first]=nums[first-1];\\n       nums[first-1]=dummy;\\n       return swap(nums,first,second);\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607981,
                "title": "ez-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = -1, high = -1;\\n        if(nums[0] == 1 and nums[n-1] == n) return 0;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1)\\n              low = i;\\n            else if(nums[i] == n)\\n              high = i;\\n        }\\n        if(low > high) return (low - 0) + (n - 1 - high) - 1;\\n        else return (low - 0) + (n - 1 - high);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int low = -1, high = -1;\\n        if(nums[0] == 1 and nums[n-1] == n) return 0;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1)\\n              low = i;\\n            else if(nums[i] == n)\\n              high = i;\\n        }\\n        if(low > high) return (low - 0) + (n - 1 - high) - 1;\\n        else return (low - 0) + (n - 1 - high);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607180,
                "title": "python-simple-and-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe calculate the difference between indedx and the value of 1 or n. The difference is the number of steps required.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the absolute difference of (index of 1 - 1) and (index of n - n). Sum the difference and that is the return value.\\n\\nAfter each operation, we would re-order the list to mimic the swap action. (Slower but intuitive)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        cnt = 0 \\n\\n        for i in [1, len(nums)]:\\n            if nums.index(i) != i - 1:\\n                cnt += abs(nums.index(i) - (i - 1))\\n                if i == 1:\\n                    nums[i-1:i-1] = [nums.pop(nums.index(i))] # Swap the location\\n\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        cnt = 0 \\n\\n        for i in [1, len(nums)]:\\n            if nums.index(i) != i - 1:\\n                cnt += abs(nums.index(i) - (i - 1))\\n                if i == 1:\\n                    nums[i-1:i-1] = [nums.pop(nums.index(i))] # Swap the location\\n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606980,
                "title": "javascript-tc-o-n-sc-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n \\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const n = nums.length;\\n    let fi = -1, li = -1;\\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] === 1) {\\n            fi = i;\\n        } else if (nums[i] === n) {\\n            li = i;\\n        }\\n    }\\n    let ans = fi - 0 + n - 1 - li;\\n    if (li < fi) {\\n        ans--;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n \\n */\\nvar semiOrderedPermutation = function(nums) {\\n    const n = nums.length;\\n    let fi = -1, li = -1;\\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] === 1) {\\n            fi = i;\\n        } else if (nums[i] === n) {\\n            li = i;\\n        }\\n    }\\n    let ans = fi - 0 + n - 1 - li;\\n    if (li < fi) {\\n        ans--;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605904,
                "title": "100-fast-java-c-explain-with-images",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**step 1.** find min and max number **index** as **min** and **max** variable\\n**step 2.** for min to **0th** index there are **min - 0** swaps == min swaps\\n**step 3.** for max to **end** index there are **end - max** swaps\\n**step 4.** totalswaps = min + (end - max)\\n\\n**step 5.** if (min < max), return totalswaps\\n            else return totalswaps -1;\\n**NOTE:: here, -1 because min and max swap count added twice as shown below**\\n![1686072871283.jpg](https://assets.leetcode.com/users/images/5dff1329-02cb-4ea3-906e-65d31d9d08c3_1686074160.5710166.jpeg)\\n\\n![1686072871276.jpg](https://assets.leetcode.com/users/images/ad8a8733-9486-47c8-90d2-ef4587983f06_1686074103.3038957.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0] == 1 && nums[nums.length-1] == nums.length) return 0;\\n        int end = nums.length-1;\\n        int min = 0;\\n        int max = end;\\n        \\n        for(int i=0; i< nums.length;i++){\\n            if(nums[i] == nums.length){\\n                max = i;\\n            }\\n            if(nums[i] == 1){\\n                min = i;\\n            }\\n        }\\n        int totalSwaps = min + (end - max);\\n        if(min < max) return totalSwaps;\\n\\n        else return totalSwaps  - 1; //because max and min are already swapped \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int semiOrderedPermutation(int[] nums) {\\n        if(nums[0] == 1 && nums[nums.length-1] == nums.length) return 0;\\n        int end = nums.length-1;\\n        int min = 0;\\n        int max = end;\\n        \\n        for(int i=0; i< nums.length;i++){\\n            if(nums[i] == nums.length){\\n                max = i;\\n            }\\n            if(nums[i] == 1){\\n                min = i;\\n            }\\n        }\\n        int totalSwaps = min + (end - max);\\n        if(min < max) return totalSwaps;\\n\\n        else return totalSwaps  - 1; //because max and min are already swapped \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603696,
                "title": "c-o-n-solution-without-extra-space",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size(), index1 = -1, index2 = -1;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        for (int i=0;i<n;i++) {\\n            if (nums[i] == 1) {\\n                index1 = i;\\n            } \\n            if (nums[i] == n) {\\n                index2 = i;\\n            }\\n        }\\n        if (index1 < index2) {\\n            return index1 + n - 1 - index2;\\n        } else {\\n            return index2 + n - 1 - index1 + 2*(index1 - index2 - 1) + 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size(), index1 = -1, index2 = -1;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        for (int i=0;i<n;i++) {\\n            if (nums[i] == 1) {\\n                index1 = i;\\n            } \\n            if (nums[i] == n) {\\n                index2 = i;\\n            }\\n        }\\n        if (index1 < index2) {\\n            return index1 + n - 1 - index2;\\n        } else {\\n            return index2 + n - 1 - index1 + 2*(index1 - index2 - 1) + 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603326,
                "title": "java-simple-solution-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int firstNumber = 0;\\n        int lastNumber = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                firstNumber = i;\\n            }\\n            if (nums[i] == n) {\\n                lastNumber = i;\\n            }\\n        }\\n\\n        int lessMove = 0;\\n        if (firstNumber > lastNumber) {\\n            lessMove = 1;\\n        }\\n\\n        return firstNumber + (n - 1 - lastNumber) - lessMove;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int semiOrderedPermutation(int[] nums) {\\n        int n = nums.length;\\n        int firstNumber = 0;\\n        int lastNumber = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                firstNumber = i;\\n            }\\n            if (nums[i] == n) {\\n                lastNumber = i;\\n            }\\n        }\\n\\n        int lessMove = 0;\\n        if (firstNumber > lastNumber) {\\n            lessMove = 1;\\n        }\\n\\n        return firstNumber + (n - 1 - lastNumber) - lessMove;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603198,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n       int index1 = 0;\\n        int indexlast = n;\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i] == 1) index1 = i;\\n            if(nums[i] == n) indexlast = i;\\n        }\\n        int ans = index1 + n - indexlast -1;\\n        if(index1 > indexlast) ans--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n       int index1 = 0;\\n        int indexlast = n;\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i] == 1) index1 = i;\\n            if(nums[i] == n) indexlast = i;\\n        }\\n        int ans = index1 + n - indexlast -1;\\n        if(index1 > indexlast) ans--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602382,
                "title": "swift-fast-one-pass",
                "content": "**One Pass (accepted answer)**\\n```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        let N = nums.count\\n        var p = 0\\n        var q = nums[N-1] == N ? N - 1 : 0\\n        \\n        for (i,num) in nums.enumerated() where num == 1 || num == N {\\n            (p,q) = num == 1 ? (i,q) : (p,i) \\n            guard p*q == 0 else { break }\\n        }\\n        \\n        return p + (N - 1 - q) + (p>q ? -1 : 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func semiOrderedPermutation(_ nums: [Int]) -> Int {\\n        let N = nums.count\\n        var p = 0\\n        var q = nums[N-1] == N ? N - 1 : 0\\n        \\n        for (i,num) in nums.enumerated() where num == 1 || num == N {\\n            (p,q) = num == 1 ? (i,q) : (p,i) \\n            guard p*q == 0 else { break }\\n        }\\n        \\n        return p + (N - 1 - q) + (p>q ? -1 : 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602044,
                "title": "easy-solution-python-simple-and-best",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        idx_1 = nums.index(1)\\n        idx_n = nums.index(len(nums))\\n\\n        if idx_1 > idx_n:\\n            return idx_1 + (len(nums) - idx_n - 1) - 1\\n        else:\\n            return idx_1 + (len(nums) - idx_n - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def semiOrderedPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        idx_1 = nums.index(1)\\n        idx_n = nums.index(len(nums))\\n\\n        if idx_1 > idx_n:\\n            return idx_1 + (len(nums) - idx_n - 1) - 1\\n        else:\\n            return idx_1 + (len(nums) - idx_n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601750,
                "title": "easiest-approach-with-intuition-cpp",
                "content": "# Intuition\\nThis is a very easy problem..\\nWe don\\'t need to swap and just observe the output array.\\nIf index of n < index of 1 then there will be one less swap as 1 will swap with n once.\\nand If index of n> index of 1 then simply we will subtract the index.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int sz=nums.size();\\n        int n=nums.size()-1;\\n        int lastele;\\n        int firstele;\\n        for(int i=0 ; i<=n ; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                firstele=i;   //we will store the index of 1\\n            }\\n            if(nums[i]==sz)   // we will store the index of n\\n            {\\n                lastele=i;\\n            }\\n        }\\n        \\n        int count;\\n        if(lastele<firstele)   //we will compare for both the cases\\n        {\\n            count=((firstele-0)+(n-lastele))-1;\\n        }\\n        else{\\n            count=((firstele-0)+(n-lastele));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        \\n        int sz=nums.size();\\n        int n=nums.size()-1;\\n        int lastele;\\n        int firstele;\\n        for(int i=0 ; i<=n ; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                firstele=i;   //we will store the index of 1\\n            }\\n            if(nums[i]==sz)   // we will store the index of n\\n            {\\n                lastele=i;\\n            }\\n        }\\n        \\n        int count;\\n        if(lastele<firstele)   //we will compare for both the cases\\n        {\\n            count=((firstele-0)+(n-lastele))-1;\\n        }\\n        else{\\n            count=((firstele-0)+(n-lastele));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601694,
                "title": "simple-c-solution-by-finding-positions-of-maximum-and-minimum-element",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int i1=0,i2=0,mini=nums[0],maxi=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                i2=i;\\n                maxi=nums[i];\\n            }\\n            if(nums[i]<mini)\\n            {\\n                i1=i;\\n                mini=nums[i];\\n            }\\n        }\\n        if(i1>i2)\\n        return ((i1-0)+(nums.size()-1-i2))-1;\\n        else\\n        return ((i1-0)+(nums.size()-1-i2));\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int i1=0,i2=0,mini=nums[0],maxi=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                i2=i;\\n                maxi=nums[i];\\n            }\\n            if(nums[i]<mini)\\n            {\\n                i1=i;\\n                mini=nums[i];\\n            }\\n        }\\n        if(i1>i2)\\n        return ((i1-0)+(nums.size()-1-i2))-1;\\n        else\\n        return ((i1-0)+(nums.size()-1-i2));\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601615,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        first = last = None\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                first = i\\n            elif nums[i] == len(nums):\\n                last = i\\n        \\n        return first + (len(nums)-1-last) - (0 if first<last else 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\\n        first = last = None\\n\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                first = i\\n            elif nums[i] == len(nums):\\n                last = i\\n        \\n        return first + (len(nums)-1-last) - (0 if first<last else 1)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1916664,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1916079,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1959233,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1925801,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            },
            {
                "id": 1921322,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Hey LeetCode we need more Easy problems  to start our mornings "
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "its time to QUIT"
                    },
                    {
                        "username": "iota_codes",
                        "content": "given sequence is not a permutation, if you use the algorithms here in the solutions section, u will get \\noutput 7, as the size of the sequence is 6, the nth value will be 6 which is at position 3 from last\\nand 1 which is at position 5 from begining, so it will take 7 moves"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "[@hmthsai7](/hmthsai7) thanks I entered an invalid test case"
                    },
                    {
                        "username": "hmthsai7",
                        "content": "1 to 0th index and 6 to the last index will take 7 moves\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "You can use bubble sort to sort the array and count the first and the last item in array when it is swapped"
                    },
                    {
                        "username": "saran0609",
                        "content": "class Solution {\\npublic:\\n    int semiOrderedPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int maxi=nums[0];\\n        int mini=nums[0];\\n        int la,sm=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            {\\n                maxi=nums[i];\\n                la=i;\\n            }\\n\\n            else if(mini>nums[i])\\n            {\\n                mini=nums[i];\\n                sm=i;\\n            }\\n        }\\n\\n        int fi=sm;\\n        int se=n-1-la;\\n\\n        if(sm>la)\\n        {\\n            return fi+se-1;\\n        }\\n\\n        else\\n        return fi+se;\\n        \\n    }\\n};\\n\\n\\n\\ni was getting wrong ans for nums=[2,1] as some garbbage value instead of 1"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "problem seems hard when we see it first but the fact that each element is present from 1 to n exactly once makes problem easy.\\nfind index of minimum element i.e 1 and maximum element i.e nums.length \\nthat means elements before index1 and after index2 have to be swapped .\\n\\nwhat if index2<index1 you can you figure it out by your own? :) "
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum of Matrix After Queries",
        "question_content": "<p>You are given an integer <code>n</code> and a <strong>0-indexed</strong>&nbsp;<strong>2D array</strong> <code>queries</code> where <code>queries[i] = [type<sub>i</sub>, index<sub>i</sub>, val<sub>i</sub>]</code>.</p>\n\n<p>Initially, there is a <strong>0-indexed</strong> <code>n x n</code> matrix filled with <code>0</code>&#39;s. For each query, you must apply one of the following changes:</p>\n\n<ul>\n\t<li>if <code>type<sub>i</sub> == 0</code>, set the values in the row with <code>index<sub>i</sub></code> to <code>val<sub>i</sub></code>, overwriting any previous values.</li>\n\t<li>if <code>type<sub>i</sub> == 1</code>, set the values in the column with <code>index<sub>i</sub></code> to <code>val<sub>i</sub></code>, overwriting any previous values.</li>\n</ul>\n\n<p>Return <em>the sum of integers in the matrix after all queries are applied</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/05/11/exm1.png\" style=\"width: 681px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]\n<strong>Output:</strong> 23\n<strong>Explanation:</strong> The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 23. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/05/11/exm2.png\" style=\"width: 681px; height: 331px;\" />\n<pre>\n<strong>Input:</strong> n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]\n<strong>Output:</strong> 17\n<strong>Explanation:</strong> The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 17.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>queries[i].length == 3</code></li>\n\t<li><code>0 &lt;= type<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt; n</code></li>\n\t<li><code>0 &lt;= val<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3594967,
                "title": "explained-reverse-iteration-o-n-very-simple-and-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n## Approach \\n1. Here iterate from the end & Keep track number of rows and number of cols that can be assigned a value\\n3. Add to answer val * remaining row when col operation is performed &\\n    add to answer val * remaining col when row operation is performed.\\n4. Decreament remaining row when row operation is performed &\\n    reamining col when col operation is performed\\n\\nNote : The trick is to when ever we perform a row operation then number of column remaining for next col operation 1 less and same is the case for col operation.\\n\\nFAQ : Why we are considering only once every index, even there is duplicate possible ?\\nAns: Even if there is duplicate, the last one will overwrite the effect of the previous query excution on the same index. So as we iterate from last, we need to only consider the last one and not any other occurance of it.\\n\\n## Complexity \\nTime : O(N) where N = q.size()\\nSpace : O(N) where N = n\\n\\n## Code\\n\\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& q) {\\n    vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n    long long ans = 0, rowRemain = n, colRemain = n;\\n    for(int i = q.size()-1; i >= 0; --i){\\n        if(q[i][0] == 0 && rowFlag[q[i][1]]) { ans += colRemain * q[i][2];    rowFlag[q[i][1]] = 0; rowRemain--; }\\n        if(q[i][0] == 1 && colFlag[q[i][1]]) { ans += rowRemain * q[i][2];    colFlag[q[i][1]] = 0; colRemain--; }\\n    }\\n    return ans;\\n}\\n\\n```\\n\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long matrixSumQueries(int n, vector<vector<int>>& q) {\\n    vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n    long long ans = 0, rowRemain = n, colRemain = n;\\n    for(int i = q.size()-1; i >= 0; --i){\\n        if(q[i][0] == 0 && rowFlag[q[i][1]]) { ans += colRemain * q[i][2];    rowFlag[q[i][1]] = 0; rowRemain--; }\\n        if(q[i][0] == 1 && colFlag[q[i][1]]) { ans += rowRemain * q[i][2];    colFlag[q[i][1]] = 0; colRemain--; }\\n    }\\n    return ans;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595010,
                "title": "c-java-python-track-seen-count-with-image-example",
                "content": "# Intuition\\n```\\nn = 10, queries = [[1, 7, 1], [0, 6, 2]]\\n```\\n![image.png](https://assets.leetcode.com/users/images/f398ef4c-142a-4692-9c06-282f8e3728d2_1685851113.5247235.png)\\n\\nThe queries which will come later will have a **greater** impact on final sum because it will overwrite any cell that was filled/not-filled before. Therefore, we can try to make sum by traversing in reverse direction of `queries`.\\n\\nIn above example,\\n1. We can first add `2 * 10 = 20` to our sum because it will overwrite everything as it is the **last** query.\\n2. Then, while considering the previous query `[1, 7, 1]`, we need to know how many rows will be there that would have been overwritten in upcoming queries. So, we can track this by maintaining seen rows\\' count. By this we will know that there is one row that will be overwritten in future so we add `1 * 9 = 9` to our sum.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int rowSeenCount = 0, colSeenCount = 0;\\n        vector<bool> rowSeen(n), colSeen(n);\\n        long long sum = 0;\\n        for (int qi = queries.size() - 1; qi >= 0; qi--) {\\n            int type = queries[qi][0], index = queries[qi][1], val = queries[qi][2];\\n            if (type == 0 && !rowSeen[index]) {\\n                rowSeenCount++;\\n                rowSeen[index] = true;\\n                sum += 1LL * (n - colSeenCount) * val;\\n            }\\n            if (type == 1 && !colSeen[index]) {\\n                colSeenCount++;\\n                colSeen[index] = true;\\n                sum += 1LL * (n - rowSeenCount) * val;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowSeenCount = 0, colSeenCount = 0;\\n        boolean[] rowSeen = new boolean[n];\\n        boolean[] colSeen = new boolean[n];\\n        long sum = 0;\\n        for (int qi = queries.length - 1; qi >= 0; qi--) {\\n            int type = queries[qi][0], index = queries[qi][1], val = queries[qi][2];\\n            if (type == 0 && !rowSeen[index]) {\\n                rowSeenCount++;\\n                rowSeen[index] = true;\\n                sum += (n - colSeenCount) * val;\\n            }\\n            if (type == 1 && !colSeen[index]) {\\n                colSeenCount++;\\n                colSeen[index] = true;\\n                sum += (n - rowSeenCount) * val;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rowSeenCount, colSeenCount, total = 0, 0, 0\\n        rowSeen, colSeen = [False] * n, [False] * n\\n        for qi in range(len(queries) - 1, -1, -1):\\n            typei, index, val = queries[qi][0], queries[qi][1], queries[qi][2]\\n            if typei == 0 and not rowSeen[index]:\\n                rowSeenCount += 1\\n                rowSeen[index] = True\\n                total += (n - colSeenCount) * val\\n            if typei == 1 and not colSeen[index]:\\n                colSeenCount += 1\\n                colSeen[index] = True\\n                total += (n - rowSeenCount) * val\\n        return total\\n```\\n\\n# Complexity\\n- Time complexity: $$O(queries.length)$$\\n- Space complexity: $$O(n)$$\\n\\n# QnA\\n**Q:** [@Bacon_lord](/Bacon_lord) : I dont understand why we need to track the rows/cols, shouldn\\'t counting the rows/cols be enough, and once you reach n no need to increment further.... this is wrong but i dont understand why it\\'s wrong?\\n**A:** It is required as there can be multiple queries for same row (or same column). Take same example as above, add another query: \\n```\\nn = 10, queries = [[1, 7, 1], [0, 6, 3], [0, 6, 2]]\\n```\\nFinal matrix will be same as in above image. But if we counted same row `6` twice, then when we reach `[1, 7, 1]` we will do `1 * 8 = 8` but we should have done `1 * 9 = 9`.\\nAlso, those multiple queries are meaningless because only last of all the same will be in the final result as it will overwrite on completely same row (or column). Since we are traversing in reverse direction, we put it in hashmap or visited array and we will not consider queries to same row (or column) that would have been made in past with respect to it.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nn = 10, queries = [[1, 7, 1], [0, 6, 2]]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int rowSeenCount = 0, colSeenCount = 0;\\n        vector<bool> rowSeen(n), colSeen(n);\\n        long long sum = 0;\\n        for (int qi = queries.size() - 1; qi >= 0; qi--) {\\n            int type = queries[qi][0], index = queries[qi][1], val = queries[qi][2];\\n            if (type == 0 && !rowSeen[index]) {\\n                rowSeenCount++;\\n                rowSeen[index] = true;\\n                sum += 1LL * (n - colSeenCount) * val;\\n            }\\n            if (type == 1 && !colSeen[index]) {\\n                colSeenCount++;\\n                colSeen[index] = true;\\n                sum += 1LL * (n - rowSeenCount) * val;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowSeenCount = 0, colSeenCount = 0;\\n        boolean[] rowSeen = new boolean[n];\\n        boolean[] colSeen = new boolean[n];\\n        long sum = 0;\\n        for (int qi = queries.length - 1; qi >= 0; qi--) {\\n            int type = queries[qi][0], index = queries[qi][1], val = queries[qi][2];\\n            if (type == 0 && !rowSeen[index]) {\\n                rowSeenCount++;\\n                rowSeen[index] = true;\\n                sum += (n - colSeenCount) * val;\\n            }\\n            if (type == 1 && !colSeen[index]) {\\n                colSeenCount++;\\n                colSeen[index] = true;\\n                sum += (n - rowSeenCount) * val;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rowSeenCount, colSeenCount, total = 0, 0, 0\\n        rowSeen, colSeen = [False] * n, [False] * n\\n        for qi in range(len(queries) - 1, -1, -1):\\n            typei, index, val = queries[qi][0], queries[qi][1], queries[qi][2]\\n            if typei == 0 and not rowSeen[index]:\\n                rowSeenCount += 1\\n                rowSeen[index] = True\\n                total += (n - colSeenCount) * val\\n            if typei == 1 and not colSeen[index]:\\n                colSeenCount += 1\\n                colSeen[index] = True\\n                total += (n - rowSeenCount) * val\\n        return total\\n```\n```\\nn = 10, queries = [[1, 7, 1], [0, 6, 3], [0, 6, 2]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594928,
                "title": "last-query-wins",
                "content": "We start with the last query and go backwards.\\n\\n\\nWe track `id` of rows and columns we have seen - so we can ignore earlier queries that will be  overwritten.\\n\\nWe also track how many rows and columns are still not covered by any query. That way, each query adds:\\n- `v * cols_cnt` for a row,\\n- `v * rows_cnt` for a column.\\n\\n## Minimalizm Version\\nIn this version, we abstract from rows and columns, and use `type` as an idex.\\n\\nSee a verbose version below (could be easier to understand).\\n\\n**C++**\\n```cpp\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cnt[2] = {n, n};\\n    bool seen[2][10001] = {};\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (!seen[type][id]) {\\n            seen[type][id] = true;\\n            res += v * cnt[!type];\\n            --cnt[type];\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\n## Verbose Version\\n**C++**\\n```cpp\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cols_cnt = n, rows_cnt = n;\\n    vector<bool> cols(n), rows(n);\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (type == 0) { // row\\n            if (!rows[id]) {\\n                rows[id] = true;\\n                --rows_cnt;\\n                res += v * cols_cnt;\\n            }\\n        }\\n        else { // col\\n            if (!cols[id]) {\\n                cols[id] = true;\\n                --cols_cnt;    \\n                res += v * rows_cnt;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cnt[2] = {n, n};\\n    bool seen[2][10001] = {};\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (!seen[type][id]) {\\n            seen[type][id] = true;\\n            res += v * cnt[!type];\\n            --cnt[type];\\n        }\\n    }\\n    return res;\\n}\\n```\n```cpp\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cols_cnt = n, rows_cnt = n;\\n    vector<bool> cols(n), rows(n);\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (type == 0) { // row\\n            if (!rows[id]) {\\n                rows[id] = true;\\n                --rows_cnt;\\n                res += v * cols_cnt;\\n            }\\n        }\\n        else { // col\\n            if (!cols[id]) {\\n                cols[id] = true;\\n                --cols_cnt;    \\n                res += v * rows_cnt;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595045,
                "title": "java-c-python-reverse-queries",
                "content": "# **Why people down vote this thread without even a word or reason?**\\n# **Please upvote this, thanks.**\\n\\n# **Intuition**\\n\"overwriting any previous values.\"\\nSo we don\\'t know whether the current value will be overrote by later query.\\nWe can iterate `queries` reversely,\\nso we can make sure once the value filled,\\nit won\\'t be changed anymore.\\n<br>\\n\\n# **Explanation**\\n`col[i]` the values in the row with index `i`.\\n`row[i]` the values in the col with index `i`.\\n\\n\\nIterate `queries` reversely,\\nif `col[i]` or `row[i]` already set,\\nignore it.\\notherwise set the value.\\n\\nIf `row[i]` is set,\\nwe didn\\'t set `n` values in matrix,\\nsince there length of `col` have already been set,\\nwe only fill in `n - col.size()` cell in `i`th row,\\nso the total value is incresed by `v * (n - col.size())`.\\nIf `col[i]` is set, similar case.\\n\\nFinally we return result.\\n<br>\\n\\n# **Complexity**\\nTime `O(queries)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Map<Integer, Integer> col = new HashMap<>(), row = new HashMap<>();\\n        long res = 0;\\n        for (int j = queries.length - 1; j >= 0; --j) {\\n            int t = queries[j][0], i = queries[j][1], v = queries[j][2];\\n            if (t == 0 && !col.containsKey(i)) {\\n                col.put(i, v);\\n                res += 1L * v * (n - row.size());\\n            }\\n            if (t == 1 && !row.containsKey(i)) {\\n                row.put(i, v);\\n                res += 1L * v * (n - col.size());\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_map<int, int> col, row;\\n        long long res = 0;\\n        for (int j = queries.size() - 1; j >= 0; --j) {\\n            int t = queries[j][0], i = queries[j][1], v = queries[j][2];\\n            if (t == 0 && !col.count(i)) {\\n                col[i] = v;\\n                res += v * (n - row.size());\\n            }\\n            if (t == 1 && !row.count(i)) {\\n                row[i] = v;\\n                res += v * (n - col.size());\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        col, row = {}, {}\\n        res = 0\\n        for t,i,v in queries[::-1]:\\n            if t == 0 and i not in row:\\n                row[i] = v\\n                res += v * (n - len(col))\\n            if t == 1 and i not in col:\\n                col[i] = v\\n                res += v * (n - len(row))\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Map<Integer, Integer> col = new HashMap<>(), row = new HashMap<>();\\n        long res = 0;\\n        for (int j = queries.length - 1; j >= 0; --j) {\\n            int t = queries[j][0], i = queries[j][1], v = queries[j][2];\\n            if (t == 0 && !col.containsKey(i)) {\\n                col.put(i, v);\\n                res += 1L * v * (n - row.size());\\n            }\\n            if (t == 1 && !row.containsKey(i)) {\\n                row.put(i, v);\\n                res += 1L * v * (n - col.size());\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_map<int, int> col, row;\\n        long long res = 0;\\n        for (int j = queries.size() - 1; j >= 0; --j) {\\n            int t = queries[j][0], i = queries[j][1], v = queries[j][2];\\n            if (t == 0 && !col.count(i)) {\\n                col[i] = v;\\n                res += v * (n - row.size());\\n            }\\n            if (t == 1 && !row.count(i)) {\\n                row[i] = v;\\n                res += v * (n - col.size());\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        col, row = {}, {}\\n        res = 0\\n        for t,i,v in queries[::-1]:\\n            if t == 0 and i not in row:\\n                row[i] = v\\n                res += v * (n - len(col))\\n            if t == 1 and i not in col:\\n                col[i] = v\\n                res += v * (n - len(row))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3595038,
                "title": "dedicated-to-beginners-image-explanation-c-java-python",
                "content": "**IMPORTANT\\uD83D\\uDCDD**  : If you want to master the concept of sliding window and want to solve all slding window (20+) problems just using single template you may check out my youtube channel by clicking my profile icon and you will find the link of channel. Best of Luck \\u270C\\uFE0F\\n**It took a lot of efforts to prepare a image explanation , please upvote this post so that other can find it easily.**\\nThankyou,\\n\\n![image](https://assets.leetcode.com/users/images/c9c5c980-4dad-42cb-b2f8-766fd1d7196d_1685897211.6367457.png)\\n![image](https://assets.leetcode.com/users/images/d15f48f8-d72e-408c-99ba-6ac2cee67287_1685897057.0139484.png)\\n![image](https://assets.leetcode.com/users/images/28656679-747a-4c8d-8f43-44e7f1c6e17e_1685898753.1859484.png)\\n![image](https://assets.leetcode.com/users/images/e7b90e9f-c855-4a54-a096-9eed05f9f501_1685899477.3602993.png)\\n![image](https://assets.leetcode.com/users/images/760b9c3e-1848-490f-91f2-80fac33523f5_1685898930.5690446.png)\\n![image](https://assets.leetcode.com/users/images/e86d9d46-b43d-4c13-a6df-b049d39c0d92_1685899716.3258834.png)\\n\\n\\n\\n\\n\\n**1. C++**\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n         long sum = 0;\\n         int row = n, col = n;\\n        \\n         unordered_set<int>Rowvis;       // storage of index for type==0\\n         unordered_set<int>Colvis;        // storage of index for type==1\\n\\n    for (int i = queries.size() - 1; i >= 0; i--) {\\n        \\n        int type=queries[i][0];\\n        int idx=queries[i][1];\\n        int value=queries[i][2];\\n        \\n        if (type==0) {\\n            if (Rowvis.find(idx)!=Rowvis.end()) {            // because this index is already calculated\\n                continue;\\n            } \\n            else {                     \\n               \\n                sum += col* value;     // update its value if not filled this index already (updated col value will handle it)\\n                Rowvis.insert(idx);    // mark this index as updated for type==0                          \\n                row --;               // decrement row value because this row value is now permanent we can not update it further\\n              \\n            }\\n        } else {\\n            if (Colvis.find(idx)!=Colvis.end()) {        // because this index is already calculated\\n                continue;\\n            }\\n            else {\\n               \\n                sum += row * value;   // update its value if not filled this index already (updated row value will handle it)\\n                Colvis.insert(idx);   // mark this index as updated for type==1\\n                col --;             // decrement col value because this col value is now permanent we can not update it \\n            }\\n        }\\n    }\\n\\n    return sum;\\n\\n    }\\n};\\n```\\n \\n **More Optimized C++ code:**\\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>visrow(n),viscol(n);\\n        \\n        reverse(queries.begin(), queries.end());\\n        \\n        int row=n, col= n;\\n        long long sum= 0;\\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            int type= queries[i][0];\\n            int idx= queries[i][1];\\n            \\n            if(type == 0 and visrow[idx] == 0){        \\n               \\n                int value= queries[i][2];\\n                \\n                sum+= row * value;            \\n                visrow[idx] = 1;              // this row is changed so dont visit it again\\n                col--;                        // now 1 more col is reserved you cant fill this\\n            }\\n            \\n            else if(type ==1 and viscol[idx] == 0){             \\n               \\n                int value= queries[i][2];\\n                \\n                sum+= col * value;\\n                viscol[idx]= 1;            // this col is changed so dont visit it again\\n                row--;                     // now 1 more row is reserved you cant fill this\\n            } \\n        }\\n        \\n        return sum;\\n    }\\n```\\n\\n**2. PYTHON**\\n\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n, queries):\\n        sum_val = 0\\n        row = n\\n        col = n\\n        \\n        row_vis = set()    # storage of index for type==0\\n        col_vis = set()    # storage of index for type==1\\n        \\n        for i in range(len(queries) - 1, -1, -1):\\n            query_type = queries[i][0]\\n            idx = queries[i][1]\\n            value = queries[i][2]\\n            \\n            if query_type == 0:\\n                if idx in row_vis:    # because this index is already calculated\\n                    continue\\n                else:\\n                    sum_val += col * value    # update its value if not filled this index already (updated col value will handle it)\\n                    row_vis.add(idx)    # mark this index as updated for type==0\\n                    row -= 1    # decrement row value because this row value is now permanent we cannot update it further\\n            else:\\n                if idx in col_vis:    # because this index is already calculated\\n                    continue\\n                else:\\n                    sum_val += row * value    # update its value if not filled this index already (updated row value will handle it)\\n                    col_vis.add(idx)    # mark this index as updated for type==1\\n                    col -= 1    # decrement col value because this col value is now permanent we cannot update it further\\n        \\n        return sum_val\\n\\n```\\n\\n**3. JAVA**\\n\\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\nimport java.util.List;\\n\\nclass Solution {\\n    public long matrixSumQueries(int n, List<List<Integer>> queries) {\\n        long sumVal = 0;\\n        int row = n;\\n        int col = n;\\n\\n        Set<Integer> rowVis = new HashSet<>();    // storage of index for type==0\\n        Set<Integer> colVis = new HashSet<>();    // storage of index for type==1\\n\\n        for (int i = queries.size() - 1; i >= 0; i--) {\\n            int type = queries.get(i).get(0);\\n            int idx = queries.get(i).get(1);\\n            int value = queries.get(i).get(2);\\n\\n            if (type == 0) {\\n                if (rowVis.contains(idx)) {    // because this index is already calculated\\n                    continue;\\n                } else {\\n                    sumVal += col * value;    // update its value if not filled this index already (updated col value will handle it)\\n                    rowVis.add(idx);    // mark this index as updated for type==0\\n                    row--;    // decrement row value because this row value is now permanent we cannot update it further\\n                }\\n            } else {\\n                if (colVis.contains(idx)) {    // because this index is already calculated\\n                    continue;\\n                } else {\\n                    sumVal += row * value;    // update its value if not filled this index already (updated row value will handle it)\\n                    colVis.add(idx);    // mark this index as updated for type==1\\n                    col--;    // decrement col value because this col value is now permanent we cannot update it further\\n                }\\n            }\\n        }\\n\\n        return sumVal;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n         long sum = 0;\\n         int row = n, col = n;\\n        \\n         unordered_set<int>Rowvis;       // storage of index for type==0\\n         unordered_set<int>Colvis;        // storage of index for type==1\\n\\n    for (int i = queries.size() - 1; i >= 0; i--) {\\n        \\n        int type=queries[i][0];\\n        int idx=queries[i][1];\\n        int value=queries[i][2];\\n        \\n        if (type==0) {\\n            if (Rowvis.find(idx)!=Rowvis.end()) {            // because this index is already calculated\\n                continue;\\n            } \\n            else {                     \\n               \\n                sum += col* value;     // update its value if not filled this index already (updated col value will handle it)\\n                Rowvis.insert(idx);    // mark this index as updated for type==0                          \\n                row --;               // decrement row value because this row value is now permanent we can not update it further\\n              \\n            }\\n        } else {\\n            if (Colvis.find(idx)!=Colvis.end()) {        // because this index is already calculated\\n                continue;\\n            }\\n            else {\\n               \\n                sum += row * value;   // update its value if not filled this index already (updated row value will handle it)\\n                Colvis.insert(idx);   // mark this index as updated for type==1\\n                col --;             // decrement col value because this col value is now permanent we can not update it \\n            }\\n        }\\n    }\\n\\n    return sum;\\n\\n    }\\n};\\n```\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>visrow(n),viscol(n);\\n        \\n        reverse(queries.begin(), queries.end());\\n        \\n        int row=n, col= n;\\n        long long sum= 0;\\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            int type= queries[i][0];\\n            int idx= queries[i][1];\\n            \\n            if(type == 0 and visrow[idx] == 0){        \\n               \\n                int value= queries[i][2];\\n                \\n                sum+= row * value;            \\n                visrow[idx] = 1;              // this row is changed so dont visit it again\\n                col--;                        // now 1 more col is reserved you cant fill this\\n            }\\n            \\n            else if(type ==1 and viscol[idx] == 0){             \\n               \\n                int value= queries[i][2];\\n                \\n                sum+= col * value;\\n                viscol[idx]= 1;            // this col is changed so dont visit it again\\n                row--;                     // now 1 more row is reserved you cant fill this\\n            } \\n        }\\n        \\n        return sum;\\n    }\\n```\n```\\nclass Solution:\\n    def matrixSumQueries(self, n, queries):\\n        sum_val = 0\\n        row = n\\n        col = n\\n        \\n        row_vis = set()    # storage of index for type==0\\n        col_vis = set()    # storage of index for type==1\\n        \\n        for i in range(len(queries) - 1, -1, -1):\\n            query_type = queries[i][0]\\n            idx = queries[i][1]\\n            value = queries[i][2]\\n            \\n            if query_type == 0:\\n                if idx in row_vis:    # because this index is already calculated\\n                    continue\\n                else:\\n                    sum_val += col * value    # update its value if not filled this index already (updated col value will handle it)\\n                    row_vis.add(idx)    # mark this index as updated for type==0\\n                    row -= 1    # decrement row value because this row value is now permanent we cannot update it further\\n            else:\\n                if idx in col_vis:    # because this index is already calculated\\n                    continue\\n                else:\\n                    sum_val += row * value    # update its value if not filled this index already (updated row value will handle it)\\n                    col_vis.add(idx)    # mark this index as updated for type==1\\n                    col -= 1    # decrement col value because this col value is now permanent we cannot update it further\\n        \\n        return sum_val\\n\\n```\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\nimport java.util.List;\\n\\nclass Solution {\\n    public long matrixSumQueries(int n, List<List<Integer>> queries) {\\n        long sumVal = 0;\\n        int row = n;\\n        int col = n;\\n\\n        Set<Integer> rowVis = new HashSet<>();    // storage of index for type==0\\n        Set<Integer> colVis = new HashSet<>();    // storage of index for type==1\\n\\n        for (int i = queries.size() - 1; i >= 0; i--) {\\n            int type = queries.get(i).get(0);\\n            int idx = queries.get(i).get(1);\\n            int value = queries.get(i).get(2);\\n\\n            if (type == 0) {\\n                if (rowVis.contains(idx)) {    // because this index is already calculated\\n                    continue;\\n                } else {\\n                    sumVal += col * value;    // update its value if not filled this index already (updated col value will handle it)\\n                    rowVis.add(idx);    // mark this index as updated for type==0\\n                    row--;    // decrement row value because this row value is now permanent we cannot update it further\\n                }\\n            } else {\\n                if (colVis.contains(idx)) {    // because this index is already calculated\\n                    continue;\\n                } else {\\n                    sumVal += row * value;    // update its value if not filled this index already (updated row value will handle it)\\n                    colVis.add(idx);    // mark this index as updated for type==1\\n                    col--;    // decrement col value because this col value is now permanent we cannot update it further\\n                }\\n            }\\n        }\\n\\n        return sumVal;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594918,
                "title": "reverse-iteration-through-queries-python",
                "content": "# Explanation\\n- Do reverse iteration through queries because latest rows and cols have contribution to our final answer.\\n- Add visited rows and cols to hash set.\\n# Complexity\\n`Time O(length of queries)`\\n`Space O(N)`\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        cols, rows = set(), set()\\n        res = 0\\n        for ty, index, val in queries[::-1]:\\n            if ty:\\n                if index not in cols:\\n                    cols.add(index)\\n                    res += val * n\\n                    res -= val * len(rows)\\n            else:\\n                if index not in rows:\\n                    rows.add(index)\\n                    res += val * n\\n                    res -= val * len(cols)\\n        return res\\n```\\nUpVote, if you like **:)**",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        cols, rows = set(), set()\\n        res = 0\\n        for ty, index, val in queries[::-1]:\\n            if ty:\\n                if index not in cols:\\n                    cols.add(index)\\n                    res += val * n\\n                    res -= val * len(rows)\\n            else:\\n                if index not in rows:\\n                    rows.add(index)\\n                    res += val * n\\n                    res -= val * len(cols)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595075,
                "title": "explained-reverse-iteration-o-n",
                "content": "# EXPLANATION\\nWe start at the bottom-right corner of the grid.\\n\\nFor each cell, we check if it is a row operation or a column operation.\\n\\nIf it\\'s a row operation, we multiply the cell value by the number of remaining rows. This value represents how many times this cell\\'s value will contribute to the final answer.\\n\\nIf it\\'s a column operation, we multiply the cell value by the number of remaining columns. This value represents how many times this cell\\'s value will contribute to the final answer.\\n\\nAfter each row operation, we decrement the count of remaining rows by 1 because the next column operation will have one less row to work with.\\n\\nAfter each column operation, we decrement the count of remaining columns by 1 because the next row operation will have one less column to work with.\\n\\nWe continue this process until we reach the top-left corner of the grid.\\n\\nFinally, we return the sum of all the values obtained from the above steps as the answer.\\n# CODE\\n\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n    vector<bool> rowFlag(n, true), colFlag(n, true);\\n    long long totalSum = 0, remainingRows = n, remainingCols = n;\\n\\n    for (int i = queries.size() - 1; i >= 0; --i) {\\n        int queryType = queries[i][0];\\n        int index = queries[i][1];\\n        int value = queries[i][2];\\n\\n        if (queryType == 0 && rowFlag[index]) {\\n            totalSum += remainingCols * value;\\n            rowFlag[index] = false;\\n            remainingRows--;\\n        }\\n        if (queryType == 1 && colFlag[index]) {\\n            totalSum += remainingRows * value;\\n            colFlag[index] = false;\\n            remainingCols--;\\n        }\\n    }\\n\\n    return totalSum;\\n    }\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "# EXPLANATION\\nWe start at the bottom-right corner of the grid.\\n\\nFor each cell, we check if it is a row operation or a column operation.\\n\\nIf it\\'s a row operation, we multiply the cell value by the number of remaining rows. This value represents how many times this cell\\'s value will contribute to the final answer.\\n\\nIf it\\'s a column operation, we multiply the cell value by the number of remaining columns. This value represents how many times this cell\\'s value will contribute to the final answer.\\n\\nAfter each row operation, we decrement the count of remaining rows by 1 because the next column operation will have one less row to work with.\\n\\nAfter each column operation, we decrement the count of remaining columns by 1 because the next row operation will have one less column to work with.\\n\\nWe continue this process until we reach the top-left corner of the grid.\\n\\nFinally, we return the sum of all the values obtained from the above steps as the answer.\\n# CODE\\n\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n    vector<bool> rowFlag(n, true), colFlag(n, true);\\n    long long totalSum = 0, remainingRows = n, remainingCols = n;\\n\\n    for (int i = queries.size() - 1; i >= 0; --i) {\\n        int queryType = queries[i][0];\\n        int index = queries[i][1];\\n        int value = queries[i][2];\\n\\n        if (queryType == 0 && rowFlag[index]) {\\n            totalSum += remainingCols * value;\\n            rowFlag[index] = false;\\n            remainingRows--;\\n        }\\n        if (queryType == 1 && colFlag[index]) {\\n            totalSum += remainingRows * value;\\n            colFlag[index] = false;\\n            remainingCols--;\\n        }\\n    }\\n\\n    return totalSum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3595012,
                "title": "start-from-the-end-o-q-c-java-python",
                "content": "# Intuition\\n**```Start from reverse since at the end we end up at the latest configuration of the matrix. Afterwards if there is case of overwriting then we would not consider it as we starting from latest to initial configuration```**\\n\\n# Approach\\n**```Take two maps one for row , and one for the column. Take two variable which would keep the count of no. of columns and no. of rows```**\\n**``` ```**\\n\\nAt any point while performing the row query add **``` val_at_the_row * (n - colums_already_painted) ```**\\nAt any point while performing the col query add **``` val_at_the_col * (n - rows_already_painted) ```**\\n\\n\\n# Complexity\\n- Time complexity:\\n**```Since it requires just to traverse the entire query only once the time complexity is: O(q) where q is the size of the query list```**\\n\\n- Space complexity:\\n**```We are using here 2 map one for row and other for col so Space taken by a map can be at max N, so O(N) where N is the number of rows and columns```**\\n\\n# Code (C++)\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0, rsum = 0, csum = 0;\\n        unordered_map<int, int> mpr, mpc;\\n        reverse(queries.begin(), queries.end());\\n        for (auto it : queries)\\n        {\\n            if (it[0] == 0)\\n            {\\n                // row\\n                int r = it[1];\\n                int val = it[2];\\n                if (mpr.find(r) == mpr.end())\\n                {\\n                    rsum ++;\\n                    mpr[r] = val;\\n                    ans += val * (n - csum);\\n                }\\n            }\\n            else\\n            {\\n                //col\\n                int c = it[1];\\n                int val = it[2];\\n                if (mpc.find(c) == mpc.end())\\n                {\\n                    csum ++;\\n                    mpc[c] = val;\\n                    ans += val * (n - rsum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code(Java)\\n``` import java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Collections;\\n\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans = 0, rsum = 0, csum = 0;\\n        Map<Integer, Integer> mpr = new HashMap<>();\\n        Map<Integer, Integer> mpc = new HashMap<>();\\n        List<List<Integer>> queryList = new ArrayList<>();\\n\\n        for (int[] query : queries) {\\n            List<Integer> list = new ArrayList<>();\\n            for (int i = 0; i < query.length; i++) {\\n                list.add(query[i]);\\n            }\\n            queryList.add(list);\\n        }\\n        \\n        Collections.reverse(queryList);\\n        \\n        for (List<Integer> it : queryList) {\\n            if (it.get(0) == 0) {\\n                // row\\n                int r = it.get(1);\\n                int val = it.get(2);\\n                if (!mpr.containsKey(r)) {\\n                    rsum++;\\n                    mpr.put(r, val);\\n                    ans += val * (n - csum);\\n                }\\n            } else {\\n                // col\\n                int c = it.get(1);\\n                int val = it.get(2);\\n                if (!mpc.containsKey(c)) {\\n                    csum++;\\n                    mpc.put(c, val);\\n                    ans += val * (n - rsum);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n# Code(Python)\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n, queries):\\n        ans = 0\\n        rsum = 0\\n        csum = 0\\n        mpr = {}\\n        mpc = {}\\n        queries.reverse()\\n        \\n        for it in queries:\\n            if it[0] == 0:\\n                # row\\n                r = it[1]\\n                val = it[2]\\n                if r not in mpr:\\n                    rsum += 1\\n                    mpr[r] = val\\n                    ans += val * (n - csum)\\n            else:\\n                # col\\n                c = it[1]\\n                val = it[2]\\n                if c not in mpc:\\n                    csum += 1\\n                    mpc[c] = val\\n                    ans += val * (n - rsum)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```Start from reverse since at the end we end up at the latest configuration of the matrix. Afterwards if there is case of overwriting then we would not consider it as we starting from latest to initial configuration```\n```Take two maps one for row , and one for the column. Take two variable which would keep the count of no. of columns and no. of rows```\n``` ```\n``` val_at_the_row * (n - colums_already_painted) ```\n``` val_at_the_col * (n - rows_already_painted) ```\n```Since it requires just to traverse the entire query only once the time complexity is: O(q) where q is the size of the query list```\n```We are using here 2 map one for row and other for col so Space taken by a map can be at max N, so O(N) where N is the number of rows and columns```\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0, rsum = 0, csum = 0;\\n        unordered_map<int, int> mpr, mpc;\\n        reverse(queries.begin(), queries.end());\\n        for (auto it : queries)\\n        {\\n            if (it[0] == 0)\\n            {\\n                // row\\n                int r = it[1];\\n                int val = it[2];\\n                if (mpr.find(r) == mpr.end())\\n                {\\n                    rsum ++;\\n                    mpr[r] = val;\\n                    ans += val * (n - csum);\\n                }\\n            }\\n            else\\n            {\\n                //col\\n                int c = it[1];\\n                int val = it[2];\\n                if (mpc.find(c) == mpc.end())\\n                {\\n                    csum ++;\\n                    mpc[c] = val;\\n                    ans += val * (n - rsum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` import java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Collections;\\n\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans = 0, rsum = 0, csum = 0;\\n        Map<Integer, Integer> mpr = new HashMap<>();\\n        Map<Integer, Integer> mpc = new HashMap<>();\\n        List<List<Integer>> queryList = new ArrayList<>();\\n\\n        for (int[] query : queries) {\\n            List<Integer> list = new ArrayList<>();\\n            for (int i = 0; i < query.length; i++) {\\n                list.add(query[i]);\\n            }\\n            queryList.add(list);\\n        }\\n        \\n        Collections.reverse(queryList);\\n        \\n        for (List<Integer> it : queryList) {\\n            if (it.get(0) == 0) {\\n                // row\\n                int r = it.get(1);\\n                int val = it.get(2);\\n                if (!mpr.containsKey(r)) {\\n                    rsum++;\\n                    mpr.put(r, val);\\n                    ans += val * (n - csum);\\n                }\\n            } else {\\n                // col\\n                int c = it.get(1);\\n                int val = it.get(2);\\n                if (!mpc.containsKey(c)) {\\n                    csum++;\\n                    mpc.put(c, val);\\n                    ans += val * (n - rsum);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def matrixSumQueries(self, n, queries):\\n        ans = 0\\n        rsum = 0\\n        csum = 0\\n        mpr = {}\\n        mpc = {}\\n        queries.reverse()\\n        \\n        for it in queries:\\n            if it[0] == 0:\\n                # row\\n                r = it[1]\\n                val = it[2]\\n                if r not in mpr:\\n                    rsum += 1\\n                    mpr[r] = val\\n                    ans += val * (n - csum)\\n            else:\\n                # col\\n                c = it[1]\\n                val = it[2]\\n                if c not in mpc:\\n                    csum += 1\\n                    mpc[c] = val\\n                    ans += val * (n - rsum)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595858,
                "title": "c-simple-and-easy-to-understand-time-o-q-space-o-n",
                "content": "# Intuition\\nStart from reverse since at the end we end up at the latest configuration of the matrix. Afterwards if there is case of overwriting then we would not consider it as we starting from latest to initial configuration\\n\\n# Approach\\nTake two unordered set one for row , and one for the column. Take two variable which would keep the count of number of rows and columns.\\n\\nAt any point while performing the row query add `val_at_the_row * (number of colums available)` and decrease the number of row by 1.\\nAt any point while performing the col query add `val_at_the_col * (number of rows available)` and decrease the number of column by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(q)$$ where q is the size of the query list\\n\\n- Space complexity:\\n$$O(N)$$ where N is the number of rows and columns to store in unordered set\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>> &q)\\n    {\\n        unordered_set<int> row, col;\\n        int nrow = n, ncol = n;\\n        long long int sum = 0;\\n        for (int i = q.size() - 1; i >= 0; i--)\\n        {\\n            int type = q[i][0];\\n            int indx = q[i][1];\\n            int val = q[i][2];\\n            if (type == 0 && row.find(indx) == row.end())\\n            {\\n                sum += (ncol * val);\\n                row.insert(indx);\\n                nrow--;\\n            }\\n            else if (type == 1 && col.find(indx) == col.end())\\n            {\\n                sum += (nrow * val);\\n                col.insert(indx);\\n                ncol--;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n![LEETCODE.png](https://assets.leetcode.com/users/images/86abe9b8-5bc8-4506-892c-6e61c18fe2c5_1685861372.3619711.png)\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>> &q)\\n    {\\n        unordered_set<int> row, col;\\n        int nrow = n, ncol = n;\\n        long long int sum = 0;\\n        for (int i = q.size() - 1; i >= 0; i--)\\n        {\\n            int type = q[i][0];\\n            int indx = q[i][1];\\n            int val = q[i][2];\\n            if (type == 0 && row.find(indx) == row.end())\\n            {\\n                sum += (ncol * val);\\n                row.insert(indx);\\n                nrow--;\\n            }\\n            else if (type == 1 && col.find(indx) == col.end())\\n            {\\n                sum += (nrow * val);\\n                col.insert(indx);\\n                ncol--;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595078,
                "title": "python-reverse-the-queries-o-q-explained",
                "content": "Idea behind Reverse :\\nif the cells udated by the query i then some or all cells may be overwrite by the i+1 th query and so on\\n\\n\\tclass Solution:\\n\\t\\t\\t\\tdef matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\t\\t\\t\\t\\trows = [0]*n  # row[i] : is ith row already filled ?\\n\\t\\t\\t\\t\\tcols = [0]*n  # col[i] : is ith col already filled ?\\n\\t\\t\\t\\t\\tfillRows = 0\\n\\t\\t\\t\\t\\tfillCols = 0\\n\\n\\t\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\t\\tfor i in range(len(queries)-1,-1,-1):\\n\\t\\t\\t\\t\\t\\ttyp,idx,val = queries[i]\\n\\t\\t\\t\\t\\t\\tif typ == 0:\\n\\t\\t\\t\\t\\t\\t\\tif rows[idx] == 1:  # idx row already filled\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t\\tres += (n - fillCols)*val   # fillCols cells already filled in the row idx\\n\\t\\t\\t\\t\\t\\t\\trows[idx] = 1  # idx row is filled now\\n\\t\\t\\t\\t\\t\\t\\tfillRows += 1  # increase the fill rows count as idx row is filled now\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tif cols[idx] == 1:  # idx col already filled\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t\\tres += (n - fillRows)*val   # fillRows cells already filled in the col idx\\n\\t\\t\\t\\t\\t\\t\\tcols[idx] = 1  # idx col is filled now\\n\\t\\t\\t\\t\\t\\t\\tfillCols += 1  # increase the fill cols count as idx col is filled now\\n\\t\\t\\t\\t\\treturn res\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "Idea behind Reverse :\\nif the cells udated by the query i then some or all cells may be overwrite by the i+1 th query and so on\\n\\n\\tclass Solution:\\n\\t\\t\\t\\tdef matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\t\\t\\t\\t\\trows = [0]*n  # row[i] : is ith row already filled ?\\n\\t\\t\\t\\t\\tcols = [0]*n  # col[i] : is ith col already filled ?\\n\\t\\t\\t\\t\\tfillRows = 0\\n\\t\\t\\t\\t\\tfillCols = 0\\n\\n\\t\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\t\\tfor i in range(len(queries)-1,-1,-1):\\n\\t\\t\\t\\t\\t\\ttyp,idx,val = queries[i]\\n\\t\\t\\t\\t\\t\\tif typ == 0:\\n\\t\\t\\t\\t\\t\\t\\tif rows[idx] == 1:  # idx row already filled\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t\\tres += (n - fillCols)*val   # fillCols cells already filled in the row idx\\n\\t\\t\\t\\t\\t\\t\\trows[idx] = 1  # idx row is filled now\\n\\t\\t\\t\\t\\t\\t\\tfillRows += 1  # increase the fill rows count as idx row is filled now\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tif cols[idx] == 1:  # idx col already filled\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\t\\tres += (n - fillRows)*val   # fillRows cells already filled in the col idx\\n\\t\\t\\t\\t\\t\\t\\tcols[idx] = 1  # idx col is filled now\\n\\t\\t\\t\\t\\t\\t\\tfillCols += 1  # increase the fill cols count as idx col is filled now\\n\\t\\t\\t\\t\\treturn res\\n",
                "codeTag": "Java"
            },
            {
                "id": 3594999,
                "title": "c-greedy-easy-and-short-solution",
                "content": "# Approach \\n- Updation of the most recent query\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long ans=0;\\n        long long r=0,c=0;\\n        vector<int>row(n+1),col(n+1);\\n        // Here we are eliminating all the repeating queries and just keeping the most recent query\\n        // We are eliminating query by changing the type of the query\\n        for(int i=q.size()-1;i>=0;i--){\\n            if(q[i][0]==0){\\n                if(row[q[i][1]]!=0) q[i][0]=2;\\n                else row[q[i][1]]=1;\\n            }\\n            else{\\n                if(col[q[i][1]]!=0) q[i][0]=2;\\n                else col[q[i][1]]=1;                \\n            }\\n        }\\n        // Just adding the complete val*n and subtracting all the previous values that have been put into rows \\n        // if the query is of column and vice versa\\n        for(auto& i:q){\\n            if(i[0]==0){               \\n                r+=i[2];\\n                ans+= i[2]*n;\\n                ans-=c; \\n            }\\n            else if(i[0]==1){\\n                c+=i[2];\\n                ans+=i[2]*n;\\n                ans-=r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long ans=0;\\n        long long r=0,c=0;\\n        vector<int>row(n+1),col(n+1);\\n        // Here we are eliminating all the repeating queries and just keeping the most recent query\\n        // We are eliminating query by changing the type of the query\\n        for(int i=q.size()-1;i>=0;i--){\\n            if(q[i][0]==0){\\n                if(row[q[i][1]]!=0) q[i][0]=2;\\n                else row[q[i][1]]=1;\\n            }\\n            else{\\n                if(col[q[i][1]]!=0) q[i][0]=2;\\n                else col[q[i][1]]=1;                \\n            }\\n        }\\n        // Just adding the complete val*n and subtracting all the previous values that have been put into rows \\n        // if the query is of column and vice versa\\n        for(auto& i:q){\\n            if(i[0]==0){               \\n                r+=i[2];\\n                ans+= i[2]*n;\\n                ans-=c; \\n            }\\n            else if(i[0]==1){\\n                c+=i[2];\\n                ans+=i[2]*n;\\n                ans-=r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594914,
                "title": "java-c-easy-to-understand-faster-than-100-with-set-o-10-5",
                "content": "# Intuition\\nI tried n^2 approach but it was giving tle\\n\\n# Approach\\nWe can declare two variables row and col which is the current length of row and col we then just take sum of the elements as we move forward.\\n\\n# Java Code \\n(special thanks to @sai_prashant)\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long row=n,col=n;\\n        long sum=0;\\n        HashSet<Integer> rowMap=new HashSet<>();\\n        HashSet<Integer> colMap=new HashSet<>();\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n                if(col<=0||rowMap.contains(queries[i][1]))continue;\\n                sum+=(col)*(long)queries[i][2];\\n                rowMap.add(queries[i][1]);\\n                row--;\\n            }else{\\n                if(row<=0||colMap.contains(queries[i][1]))continue;\\n                sum+=(row)*(long)queries[i][2];\\n                colMap.add(queries[i][1]);\\n                col--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n# C++ Code\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // so the logic is we start iterating queries array from the last\\n    // we only update one row/col only once and then skip if they appear again\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int row = n,col = n;\\n        long long ans = 0;\\n        int x = queries.size();\\n        unordered_set<int> rows,cols;\\n        for(int i=(x-1);i>=0;i--){\\n            if(col > 0 && queries[i][0] == 0){\\n                if(rows.find(queries[i][1]) == rows.end()){\\n                    ans += col * (long long) queries[i][2];\\n                    row--;\\n                    rows.insert(queries[i][1]);\\n                }\\n            }else if(row > 0){\\n                if(cols.find(queries[i][1]) == cols.end()){\\n                    ans += row * (long long) queries[i][2];\\n                    col--;\\n                    cols.insert(queries[i][1]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long row=n,col=n;\\n        long sum=0;\\n        HashSet<Integer> rowMap=new HashSet<>();\\n        HashSet<Integer> colMap=new HashSet<>();\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n                if(col<=0||rowMap.contains(queries[i][1]))continue;\\n                sum+=(col)*(long)queries[i][2];\\n                rowMap.add(queries[i][1]);\\n                row--;\\n            }else{\\n                if(row<=0||colMap.contains(queries[i][1]))continue;\\n                sum+=(row)*(long)queries[i][2];\\n                colMap.add(queries[i][1]);\\n                col--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // so the logic is we start iterating queries array from the last\\n    // we only update one row/col only once and then skip if they appear again\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int row = n,col = n;\\n        long long ans = 0;\\n        int x = queries.size();\\n        unordered_set<int> rows,cols;\\n        for(int i=(x-1);i>=0;i--){\\n            if(col > 0 && queries[i][0] == 0){\\n                if(rows.find(queries[i][1]) == rows.end()){\\n                    ans += col * (long long) queries[i][2];\\n                    row--;\\n                    rows.insert(queries[i][1]);\\n                }\\n            }else if(row > 0){\\n                if(cols.find(queries[i][1]) == cols.end()){\\n                    ans += row * (long long) queries[i][2];\\n                    col--;\\n                    cols.insert(queries[i][1]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596016,
                "title": "c-only-last-replacement-matters",
                "content": "```\\n// rows -> number of rows visited \\n// cols->number of columns visited\\n// row X cols intersection can change the values \\n// for row : r columns can change r times val of row , so just we count till now: how many number of col visited that affects the values in row (intially n values in that row)\\n// same for column \\n// visited array to maintain the index of rows/column visited to avoid the repeated replacement of same column /row\\n// only last replacement of particular row/column matters! and give contribution to sum\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) \\n    {\\n        long long ans=0;\\n        int row=0;\\n        int col=0;\\n        vector<bool> visrow(n,0),viscol(n,0);\\n        for(int i=q.size()-1;i>=0;i--)\\n        {\\n            int type=q[i][0];\\n            int val=q[i][2];\\n            if(type==0)\\n            {\\n                int rowind=q[i][1];\\n                if(visrow[rowind]==0)\\n                {\\n                ans+=1LL*val*(n-col);\\n                row++;\\n                    visrow[rowind]=1;\\n                }\\n                \\n            }\\n            else\\n            {\\n                \\n                int colind=q[i][1];\\n                if(viscol[colind]==0)\\n                {\\n                    ans+=1LL*val*(n-row);\\n                col++;\\n                    viscol[colind]=1;\\n                }\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\n// rows -> number of rows visited \\n// cols->number of columns visited\\n// row X cols intersection can change the values \\n// for row : r columns can change r times val of row , so just we count till now: how many number of col visited that affects the values in row (intially n values in that row)\\n// same for column \\n// visited array to maintain the index of rows/column visited to avoid the repeated replacement of same column /row\\n// only last replacement of particular row/column matters! and give contribution to sum\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) \\n    {\\n        long long ans=0;\\n        int row=0;\\n        int col=0;\\n        vector<bool> visrow(n,0),viscol(n,0);\\n        for(int i=q.size()-1;i>=0;i--)\\n        {\\n            int type=q[i][0];\\n            int val=q[i][2];\\n            if(type==0)\\n            {\\n                int rowind=q[i][1];\\n                if(visrow[rowind]==0)\\n                {\\n                ans+=1LL*val*(n-col);\\n                row++;\\n                    visrow[rowind]=1;\\n                }\\n                \\n            }\\n            else\\n            {\\n                \\n                int colind=q[i][1];\\n                if(viscol[colind]==0)\\n                {\\n                    ans+=1LL*val*(n-row);\\n                col++;\\n                    viscol[colind]=1;\\n                }\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595095,
                "title": "c-clean-concise-easy-to-read-and-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApproach is simple we calculate the contribution of row or col according to last query which have most priority , So we start from last and as we add contribution of any row and col we mark it as visited \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nclass Solution {\\npublic:\\n   \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n\\n        long long ans=0;       \\n       vector<int>row(n,0),col(n,0);   //making visited array for row and column\\n        \\n    int cntr=0,cntc=0;                 ///storing the count of num of row and col \\n        for(int i=q.size()-1;i>=0;i--){     //taking last querie which have more priority \\n             int ind=q[i][1];               //finding index of row or col\\n             int val=q[i][2];\\n                                             \\n            if(q[i][0]==0){               //if type ==0 it\\'s mean it is row\\n               \\n              if(row[ind]==0){\\n                  ans+=val*(n-cntc);       //  adding contribution of (n-cntc ) row cell which will have value ==val\\n                  row[ind]=1;               //mark visited\\n                  cntr++;                 \\n\\n              }\\n               \\n            }\\n            else {                             //if type ==1 it\\'s mean it is col\\n                \\n             if(col[ind]==0){\\n                ans+=val*(n-cntr);               //  adding contribution of (n-cntr ) col cell which will have value ==val\\n                cntc++;\\n                col[ind]=1;            //mark visited\\n                }\\n            \\n            }\\n            if(cntc+cntr==2*n) return ans;    //if all row and col visited then return ans\\n        }\\n               \\n        return ans;\\n    }\\n};\\n\\n# please upvote \\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n\\n        long long ans=0;       \\n       vector<int>row(n,0),col(n,0);   //making visited array for row and column\\n        \\n    int cntr=0,cntc=0;                 ///storing the count of num of row and col \\n        for(int i=q.size()-1;i>=0;i--){     //taking last querie which have more priority \\n             int ind=q[i][1];               //finding index of row or col\\n             int val=q[i][2];\\n                                             \\n            if(q[i][0]==0){               //if type ==0 it\\'s mean it is row\\n               \\n              if(row[ind]==0){\\n                  ans+=val*(n-cntc);       //  adding contribution of (n-cntc ) row cell which will have value ==val\\n                  row[ind]=1;               //mark visited\\n                  cntr++;                 \\n\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3594909,
                "title": "java-easy-solution-15-lines",
                "content": "# Complexity\\n- Time complexity: $$O(m)$$ where `m = queries.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long matrixSumQueries(int n, int[][] queries) {\\n    var rows = new boolean[n];\\n    var cols = new boolean[n];\\n    int rowCnt = n, colCnt = n;\\n    var sum = 0L;\\n    \\n    for (var i = queries.length - 1; i >=0 && rowCnt > 0 && colCnt > 0; i--) {\\n      if (queries[i][0] == 0) {\\n        if (rows[queries[i][1]]) continue;\\n        \\n        rows[queries[i][1]] = true;\\n        rowCnt--;\\n        sum += colCnt * queries[i][2];\\n      } else {\\n        if (cols[queries[i][1]]) continue;\\n        \\n        cols[queries[i][1]] = true;\\n        colCnt--;\\n        sum += rowCnt * queries[i][2];\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  public long matrixSumQueries(int n, int[][] queries) {\\n    var rows = new boolean[n];\\n    var cols = new boolean[n];\\n    int rowCnt = n, colCnt = n;\\n    var sum = 0L;\\n    \\n    for (var i = queries.length - 1; i >=0 && rowCnt > 0 && colCnt > 0; i--) {\\n      if (queries[i][0] == 0) {\\n        if (rows[queries[i][1]]) continue;\\n        \\n        rows[queries[i][1]] = true;\\n        rowCnt--;\\n        sum += colCnt * queries[i][2];\\n      } else {\\n        if (cols[queries[i][1]]) continue;\\n        \\n        cols[queries[i][1]] = true;\\n        colCnt--;\\n        sum += rowCnt * queries[i][2];\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595409,
                "title": "o-n-solution-no-tle-explained-line-by-line-fully-commented",
                "content": "# Intuition\\n First did this problem in O(n*n) , but got tle , then thought a little more and found that we are actually not required to check for all the queries and we can actually reduce the time complexity to O(n) (where n I am considering as the size of queries vector).\\n\\n# Approach\\nThe approach is that rather than starting from the start of the queries vector , i will start from the end , and for each query i will see whether it is related to the row or column. After that i will see that whether i have already considered this row/column or not. If i have already seen this row/column earlier in my query than i will not do anything , if it\\'s the first time i will do the changes then .\\n\\nAs i know there are n row/colums and i have to convert all them to new value (queries[i][2]) , so why don\\'t i just do n * queries[i][2].\\nBut the catch here is that if i will only do this then i will get sum of some cell more than one time , therefore i will subtract the sum of all the cell that i didn\\'t change this time and calculating the correct sum.\\n\\n**I hope I could make you understand the approach , go through the code ones , all the steps are very well commented.**\\n\\n# Complexity\\n- Time complexity:\\n **O(queries.size())**\\n\\n- Space complexity:\\n **all we are using is some variables to store count and 2 vectors of size n each \\nso total space complexity is O(2*n) i.e O(n).**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        // to store the final answer\\n        long long int sum = 0;\\n        \\n        // to keep check of the rows i have already seen.\\n        vector<int> row(n,0);\\n\\n        // to keep check of the rows i have already seen.\\n        vector<int> col(n,0);\\n\\n        // these will keep the count of the no. of rows and columns that i have changed\\n        int countrow = 0, countcol = 0;\\n        \\n        for(int i = queries.size()-1 ; i >= 0 ; i--){\\n            \\n            \\n            if(queries[i][0] == 0){     // i have to do operation in row\\n                \\n                // i will only update the values if i haven\\'t already done for this particular row\\n                if(row[queries[i][1]] == 0){    \\n\\n                    // total n rows , value of each cell will be queries[i][2] , so for n it will get multiplied but we will subtract the value of this queries[i][2] for the cells that were already filled.\\n                    sum += (n * queries[i][2]) - (countcol*queries[i][2]);  \\n                    countrow++;\\n                    row[queries[i][1]] = 1;\\n                }\\n                \\n            }\\n\\n            if(queries[i][0] == 1){     // i have to do operation in column\\n\\n                // i will only update the values if i haven\\'t already done for this particular row\\n                if(col[queries[i][1]] == 0){\\n\\n                    // total n colums , value of each cell will be queries[i][2] , so for n it will get multiplied but we will subtract the value of this queries[i][2] for the cells that were already filled.\\n                    sum += (n*queries[i][2]) - (countrow*queries[i][2]);\\n                    countcol++;\\n                    col[queries[i][1]] = 1;\\n                }\\n            }      \\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        // to store the final answer\\n        long long int sum = 0;\\n        \\n        // to keep check of the rows i have already seen.\\n        vector<int> row(n,0);\\n\\n        // to keep check of the rows i have already seen.\\n        vector<int> col(n,0);\\n\\n        // these will keep the count of the no. of rows and columns that i have changed\\n        int countrow = 0, countcol = 0;\\n        \\n        for(int i = queries.size()-1 ; i >= 0 ; i--){\\n            \\n            \\n            if(queries[i][0] == 0){     // i have to do operation in row\\n                \\n                // i will only update the values if i haven\\'t already done for this particular row\\n                if(row[queries[i][1]] == 0){    \\n\\n                    // total n rows , value of each cell will be queries[i][2] , so for n it will get multiplied but we will subtract the value of this queries[i][2] for the cells that were already filled.\\n                    sum += (n * queries[i][2]) - (countcol*queries[i][2]);  \\n                    countrow++;\\n                    row[queries[i][1]] = 1;\\n                }\\n                \\n            }\\n\\n            if(queries[i][0] == 1){     // i have to do operation in column\\n\\n                // i will only update the values if i haven\\'t already done for this particular row\\n                if(col[queries[i][1]] == 0){\\n\\n                    // total n colums , value of each cell will be queries[i][2] , so for n it will get multiplied but we will subtract the value of this queries[i][2] for the cells that were already filled.\\n                    sum += (n*queries[i][2]) - (countrow*queries[i][2]);\\n                    countcol++;\\n                    col[queries[i][1]] = 1;\\n                }\\n            }      \\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595345,
                "title": "good-question-with-simple-and-readable-solution-o-n-time-and-o-n-space",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        # make dictionary with default value of [1,1] where first\\n        # value represents whether type 0 is processed or not.\\n        # Similarly, second value represents whether type 1 is\\n        # processed or not\\n        d = defaultdict(lambda: [1,1])\\n\\n        # stores the summation of vlaues of matrix entries\\n        ans = 0\\n\\n        # cr, cc denotes number of rows / columns processed\\n        cr, cc = 0, 0\\n\\n        # start query from reversed fashion as we know the fact we can overwrite the\\n        # values\\n        for x, y, z in reversed(queries):\\n\\n            # For index = y and type = x, process the matrix and\\n            # later, make the value to 0.\\n            # (Remember, we move in reversed manner)\\n            # Eg. for a particular query with index y and type 0,\\n            # we made d[y] = [0,1], so that we\\'ve liabilty to process\\n            # index y with type 1 as it is set to 1\\n            if d[y][x]:\\n                # x = 0 means type 0, so increment row\\'s count\\n                if x == 0:\\n                    cr += 1\\n                # x = 1 means type 1, so increment col\\'s count\\n                else:\\n                    cc += 1\\n\\n                # while processing yth row, we\\'ve to remove those columns which are\\n                # already processed\\n                if x == 0:\\n                    remaining = n - cc\\n                # while processing yth col, we\\'ve to remove those rows which are\\n                # already processed\\n                else:\\n                    remaining = n - cr\\n\\n                # multiply with value to get the desired result and add to variable ans    \\n                ans += remaining * z\\n\\n                # since, we process the yth row / col depend upon type i.e. x, we can\\n                # now mark to 0 (Remember, we move in reversed manner)\\n                d[y][x] = 0\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        # make dictionary with default value of [1,1] where first\\n        # value represents whether type 0 is processed or not.\\n        # Similarly, second value represents whether type 1 is\\n        # processed or not\\n        d = defaultdict(lambda: [1,1])\\n\\n        # stores the summation of vlaues of matrix entries\\n        ans = 0\\n\\n        # cr, cc denotes number of rows / columns processed\\n        cr, cc = 0, 0\\n\\n        # start query from reversed fashion as we know the fact we can overwrite the\\n        # values\\n        for x, y, z in reversed(queries):\\n\\n            # For index = y and type = x, process the matrix and\\n            # later, make the value to 0.\\n            # (Remember, we move in reversed manner)\\n            # Eg. for a particular query with index y and type 0,\\n            # we made d[y] = [0,1], so that we\\'ve liabilty to process\\n            # index y with type 1 as it is set to 1\\n            if d[y][x]:\\n                # x = 0 means type 0, so increment row\\'s count\\n                if x == 0:\\n                    cr += 1\\n                # x = 1 means type 1, so increment col\\'s count\\n                else:\\n                    cc += 1\\n\\n                # while processing yth row, we\\'ve to remove those columns which are\\n                # already processed\\n                if x == 0:\\n                    remaining = n - cc\\n                # while processing yth col, we\\'ve to remove those rows which are\\n                # already processed\\n                else:\\n                    remaining = n - cr\\n\\n                # multiply with value to get the desired result and add to variable ans    \\n                ans += remaining * z\\n\\n                # since, we process the yth row / col depend upon type i.e. x, we can\\n                # now mark to 0 (Remember, we move in reversed manner)\\n                d[y][x] = 0\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604681,
                "title": "python-elegant-short-o-n-hash-map",
                "content": "# Complexity\\n- Time complexity: $$O(m)$$, where $$m$$ - length of ```queries```\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        used_cols = set()\\n        used_rows = set()\\n\\n        # Initially matrix filled with zeros\\n        queries_sum = 0\\n\\n        for op, idx, val in reversed(queries):\\n            # Fills an untouched row\\n            if op == 0 and idx not in used_rows:\\n                queries_sum += val * (n - len(used_cols))  # Column may have already filled cells with other rows\\n                used_rows.add(idx)\\n            # Fills an untouched column\\n            elif op == 1 and idx not in used_cols:\\n                queries_sum += val * (n - len(used_rows))  # Row may have already filled cells with other columns\\n                used_cols.add(idx)\\n\\n        return queries_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```queries```\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        used_cols = set()\\n        used_rows = set()\\n\\n        # Initially matrix filled with zeros\\n        queries_sum = 0\\n\\n        for op, idx, val in reversed(queries):\\n            # Fills an untouched row\\n            if op == 0 and idx not in used_rows:\\n                queries_sum += val * (n - len(used_cols))  # Column may have already filled cells with other rows\\n                used_rows.add(idx)\\n            # Fills an untouched column\\n            elif op == 1 and idx not in used_cols:\\n                queries_sum += val * (n - len(used_rows))  # Row may have already filled cells with other columns\\n                used_cols.add(idx)\\n\\n        return queries_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598544,
                "title": "python-3-7-lines-bitmap-t-m-99-90",
                "content": "\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        rowcol, ans, Seen = [n,n], 0, [0,0]\\n\\n        for typ, idx, val in reversed(queries):\\n     \\n            if Seen[typ]&(1<<idx): continue\\n            Seen[typ]|= (1<<idx)\\n    \\n            ans+= val * rowcol[typ]\\n            rowcol[typ^1]-= 1\\n\\n        return  ans\\n```\\n[https://leetcode.com/problems/sum-of-matrix-after-queries/submissions/1011786423/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(queries)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        rowcol, ans, Seen = [n,n], 0, [0,0]\\n\\n        for typ, idx, val in reversed(queries):\\n     \\n            if Seen[typ]&(1<<idx): continue\\n            Seen[typ]|= (1<<idx)\\n    \\n            ans+= val * rowcol[typ]\\n            rowcol[typ^1]-= 1\\n\\n        return  ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595969,
                "title": "simple-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& v) {\\n        long long int ans = 0;\\n        int a = n, b = n;\\n        vector<int> c(b,0),r(n,0);\\n        reverse(v.begin(),v.end());//traverse from back\\n        for(auto &i: v){\\n            cout<<a<<\" \"<<b<<endl;\\n            if(i[0]){\\n                if(a>0){\\n                    if(c[i[1]]>0)continue;\\n                    ans += i[2]*1LL*a;\\n                    c[i[1]] = i[2];\\n                }\\n                b--;\\n            }else{\\n                if(b>0){\\n                    if(r[i[1]]>0)continue;\\n                    ans += i[2]*1LL*b;\\n                    r[i[1]] = i[2];\\n                }\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& v) {\\n        long long int ans = 0;\\n        int a = n, b = n;\\n        vector<int> c(b,0),r(n,0);\\n        reverse(v.begin(),v.end());//traverse from back\\n        for(auto &i: v){\\n            cout<<a<<\" \"<<b<<endl;\\n            if(i[0]){\\n                if(a>0){\\n                    if(c[i[1]]>0)continue;\\n                    ans += i[2]*1LL*a;\\n                    c[i[1]] = i[2];\\n                }\\n                b--;\\n            }else{\\n                if(b>0){\\n                    if(r[i[1]]>0)continue;\\n                    ans += i[2]*1LL*b;\\n                    r[i[1]] = i[2];\\n                }\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3595356,
                "title": "step-by-step-detailed-explanation-of-short-code",
                "content": "# Intuition\\nThe problem involves performing sum queries on a matrix. We are given the size of the matrix n and a list of queries, where each query specifies whether to add a value to a row or column and the corresponding index. Our goal is to calculate the sum after applying all the queries.\\n\\n# Approach\\n1. Initialize a variable sum to keep track of the sum and set it to 0.\\n2. Create two sets, row and col, to store the indices of the rows and columns affected by the queries.\\n3. Iterate over the queries in reverse order, starting from the last query. This allows us to process the queries in reverse order while still maintaining the correct sum.\\n4. For each query, extract the type, index, and value.\\n5. If the query type is 1 (column query), check if the column index ind is already present in the col set. If it is, continue to the next query.\\n6. Add the column index ind to the col set.\\n7. Update the sum by adding the product of the value val and the number of rows not affected by the column queries (n - row.size).\\n8. If the query type is 0 (row query), check if the row index ind is already present in the row set. If it is, continue to the next query.\\nAdd the row index ind to the row set.\\n9. Update the sum by adding the product of the value val and the number of columns not affected by the row queries (n - col.size).\\n10. After processing all the queries, return the final value of sum.\\n# Complexity\\n* Time complexity: O(k), where k is the number of queries. We iterate over the queries in reverse order, performing constant time operations for each query.\\n* Space complexity: O(n), where n is the size of the matrix. We use two sets to store the indices of the affected rows and columns, which can have a maximum size of n.\\n\\n# Code\\n```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n    let sum = 0 ;\\n    let row = new Set() , col = new Set() , len = queries.length;\\n    for( let i = len - 1 ; i >= 0 ; i-- ){\\n        let [type , ind , val] = queries[i];\\n        if(type){\\n            if(col.has(ind))continue;\\n            col.add(ind);\\n            sum += (val * (n - row.size));\\n        }\\n        else {\\n            if(row.has(ind))continue;\\n            row.add(ind);\\n            sum += (val * (n - col.size));\\n        }\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n    let sum = 0 ;\\n    let row = new Set() , col = new Set() , len = queries.length;\\n    for( let i = len - 1 ; i >= 0 ; i-- ){\\n        let [type , ind , val] = queries[i];\\n        if(type){\\n            if(col.has(ind))continue;\\n            col.add(ind);\\n            sum += (val * (n - row.size));\\n        }\\n        else {\\n            if(row.has(ind))continue;\\n            row.add(ind);\\n            sum += (val * (n - col.size));\\n        }\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595171,
                "title": "greedy-c-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        vector<long long>col(n),row(n);\\n        \\n        long long ans=0, ro=0,co=0;\\n        \\n        for(int i=q.size()-1;i>=0;i--){\\n            \\n            int type = q[i][0];\\n            int index = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type==0){\\n                if(row[index]){\\n                    q[i][0]=2;\\n                }\\n                else {\\n                    row[index] = 1;\\n                }\\n            }\\n            else{\\n                if(col[index]){\\n                    q[i][0]=2;\\n                }\\n                else {\\n                    col[index] = 1;  \\n                }              \\n            }\\n            \\n        }\\n        for(int i=0;i<q.size();i++){\\n            \\n            int type = q[i][0];\\n            int index = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type==0){   \\n                \\n                ro+=val;\\n                ans+= val*n;\\n                ans-=co; \\n                \\n            }\\n            if(type==1){\\n                \\n                co+=val;\\n                ans+=val*n;\\n                ans-=ro;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        vector<long long>col(n),row(n);\\n        \\n        long long ans=0, ro=0,co=0;\\n        \\n        for(int i=q.size()-1;i>=0;i--){\\n            \\n            int type = q[i][0];\\n            int index = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type==0){\\n                if(row[index]){\\n                    q[i][0]=2;\\n                }\\n                else {\\n                    row[index] = 1;\\n                }\\n            }\\n            else{\\n                if(col[index]){\\n                    q[i][0]=2;\\n                }\\n                else {\\n                    col[index] = 1;  \\n                }              \\n            }\\n            \\n        }\\n        for(int i=0;i<q.size();i++){\\n            \\n            int type = q[i][0];\\n            int index = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type==0){   \\n                \\n                ro+=val;\\n                ans+= val*n;\\n                ans-=co; \\n                \\n            }\\n            if(type==1){\\n                \\n                co+=val;\\n                ans+=val*n;\\n                ans-=ro;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595013,
                "title": "reverse-order-is-the-key-c",
                "content": "# Approach\\nApply the queries in reverse order by carrying the number of rows and cols available, it is very straighfoward to update these values.\\n# Complexity\\n- Time complexity:\\n- $O(|queries|)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0; \\n        long long R= n,C =n;\\n        vector<bool> Rused(n),Cused(n);\\n        \\n        int M = queries.size();\\n        for(int i = M-1;i>=0;i--){\\n            int t = queries[i][0];     \\n            int id = queries[i][1];      \\n            long long x = queries[i][2];      \\n            \\n            if(t == 0){\\n                if(Rused[id])continue;\\n                ans += C*x;\\n                Rused[id] = true;\\n                R--;\\n            }\\n            else{\\n                if(Cused[id])continue;\\n                ans += R*x;\\n                Cused[id] = true;\\n                C--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0; \\n        long long R= n,C =n;\\n        vector<bool> Rused(n),Cused(n);\\n        \\n        int M = queries.size();\\n        for(int i = M-1;i>=0;i--){\\n            int t = queries[i][0];     \\n            int id = queries[i][1];      \\n            long long x = queries[i][2];      \\n            \\n            if(t == 0){\\n                if(Rused[id])continue;\\n                ans += C*x;\\n                Rused[id] = true;\\n                R--;\\n            }\\n            else{\\n                if(Cused[id])continue;\\n                ans += R*x;\\n                Cused[id] = true;\\n                C--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594984,
                "title": "python-reverse-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        queries.reverse()\\n        rows = set()\\n        cols = set()\\n        res = 0\\n        for t,i,val in queries:\\n            if t == 0:\\n                if i not in rows:\\n                    res += val*(n-len(cols))\\n                rows.add(i)\\n            else:\\n                if i not in cols:\\n                    res += val*(n-len(rows))\\n                cols.add(i)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        queries.reverse()\\n        rows = set()\\n        cols = set()\\n        res = 0\\n        for t,i,val in queries:\\n            if t == 0:\\n                if i not in rows:\\n                    res += val*(n-len(cols))\\n                rows.add(i)\\n            else:\\n                if i not in cols:\\n                    res += val*(n-len(rows))\\n                cols.add(i)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594962,
                "title": "strict-test-cases-3-solutions-o-n-explanation",
                "content": "Intuition:\\nGiven the input matrix and a set of queries, we need to calculate the sum of values in the matrix based on the queries. The queries specify whether to calculate row sums or column sums, along with the indices and values to be added or subtracted. To efficiently calculate the sum, we can process the queries in reverse order and keep track of the processed rows and columns.\\n\\nApproach:\\n\\nInitialize the cumulative sum variable sumi to 0.\\nCreate sets row and col to keep track of processed rows and columns, respectively.\\nIterate through the queries in reverse order using a for loop.\\nFor each query, check the value of a (0 for row sum, 1 for column sum).\\nIf a is 0 (row sum):\\nCheck if the row index b is already in the row set.\\nIf not, add the row index to the row set and update sumi by adding c * (n - len(col)), where c is the value to be added or subtracted, and (n - len(col)) represents the number of unprocessed columns.\\nIf a is 1 (column sum):\\nCheck if the column index b is already in the col set.\\nIf not, add the column index to the col set and update sumi by adding c * (n - len(row)), where (n - len(row)) represents the number of unprocessed rows.\\nReturn the final value of sumi as the result.\\nComplexity:\\n\\nTime complexity: The algorithm iterates through the queries once in reverse order, resulting in a time complexity of O(q), where q is the number of queries.\\nSpace complexity: The algorithm uses additional space to store the row and col sets, which can have at most n elements (assuming an n x n matrix). Therefore, the space complexity is O(n).\\n\\n# Code\\nACCEPTED\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        sumi = 0\\n        row = set()\\n        col = set()\\n\\n        for a, b, c in reversed(queries):\\n            if a == 0:\\n                if b not in row:\\n                    row.add(b)\\n                    sumi += c * (n - len(col))\\n            else:\\n                if b not in col:\\n                    col.add(b)\\n                    sumi += c * (n - len(row))\\n        \\n        return sumi\\n\\n\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/96e80b2b-bf6f-4773-9493-38541adeafe0_1685851459.9388924.png)\\n```\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        sumi=0\\n        row=[0]*n\\n        col=[0]*n\\n        \\n        for i in range(len(queries)-1,-1,-1):\\n            a,b,c=queries[i]\\n            if a==0:\\n                if row[b]!=1:\\n                    row[b]=1\\n                    sumi+=c*(n-sum(col))\\n                \\n            else:\\n                if col[b]!=1:\\n                    col[b]=1\\n                    sumi+=c*(n-sum(row))\\n        return sumi\\n```\\n![image.png](https://assets.leetcode.com/users/images/206dfc2c-7828-4a35-b2ba-56bcec1519d4_1685851567.7818458.png)\\n\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        d=defaultdict(int)\\n        \\n        for a,b,c in queries[::-1]:\\n            if a==0:\\n                i=0\\n                while 0<=i<n:\\n                    if (b,i) not in d:\\n                        d[(b,i)]=c\\n                    i+=1\\n            else:\\n                i=0\\n                while 0<=i<n:\\n                    if (i,b) not in d:\\n                        d[(i,b)]=c\\n                    i+=1\\n        # print(d)\\n        return sum(d.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        sumi = 0\\n        row = set()\\n        col = set()\\n\\n        for a, b, c in reversed(queries):\\n            if a == 0:\\n                if b not in row:\\n                    row.add(b)\\n                    sumi += c * (n - len(col))\\n            else:\\n                if b not in col:\\n                    col.add(b)\\n                    sumi += c * (n - len(row))\\n        \\n        return sumi\\n\\n\\n\\n```\n```\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        sumi=0\\n        row=[0]*n\\n        col=[0]*n\\n        \\n        for i in range(len(queries)-1,-1,-1):\\n            a,b,c=queries[i]\\n            if a==0:\\n                if row[b]!=1:\\n                    row[b]=1\\n                    sumi+=c*(n-sum(col))\\n                \\n            else:\\n                if col[b]!=1:\\n                    col[b]=1\\n                    sumi+=c*(n-sum(row))\\n        return sumi\\n```\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        d=defaultdict(int)\\n        \\n        for a,b,c in queries[::-1]:\\n            if a==0:\\n                i=0\\n                while 0<=i<n:\\n                    if (b,i) not in d:\\n                        d[(b,i)]=c\\n                    i+=1\\n            else:\\n                i=0\\n                while 0<=i<n:\\n                    if (i,b) not in d:\\n                        d[(i,b)]=c\\n                    i+=1\\n        # print(d)\\n        return sum(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594958,
                "title": "java-c-set-math-greedy-algo",
                "content": "Idea is to check the lastest entry for columns and rows only and \\nentries to take in a latest row = (n - number column entries considered till now ) * value of latest row \\nentries to take in a latest column = (n - number row entries considered till now) * value of latest column\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long totalSum = 0, cNo = 0, rNo = 0;\\n        unordered_set<int> r, c;\\n        for(int indx = q.size()-1; indx > - 1 ; indx--){\\n            auto qs = q[indx];\\n            if(!qs[0] && r.find(qs[1]) == r.end()){\\n                r.insert(qs[1]);\\n                rNo++;\\n               totalSum += (qs[2] * (n-cNo));\\n      \\n            }else if(qs[0] && c.find(qs[1]) == c.end()){\\n                c.insert(qs[1]);\\n                cNo++;\\n               totalSum += (qs[2] * (n- rNo));\\n            }\\n            \\n        }\\n        return totalSum;\\n     \\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] q) {\\n        long totalSum = 0, cNo = 0, rNo = 0;\\n        HashSet<Integer> r = new HashSet<>(), c = new HashSet<>();\\n        for(int indx = q.length-1; indx > - 1 ; indx--){\\n            var qs = q[indx];\\n            if(qs[0] == 0 && !r.contains(qs[1])){\\n                r.add(qs[1]);\\n                rNo++;\\n               totalSum += (qs[2] * (n-cNo));\\n      \\n            }else if(qs[0] == 1 && !c.contains(qs[1])){\\n                c.add(qs[1]);\\n                cNo++;\\n               totalSum += (qs[2] * (n- rNo));\\n            }\\n            \\n        }\\n        return totalSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long totalSum = 0, cNo = 0, rNo = 0;\\n        unordered_set<int> r, c;\\n        for(int indx = q.size()-1; indx > - 1 ; indx--){\\n            auto qs = q[indx];\\n            if(!qs[0] && r.find(qs[1]) == r.end()){\\n                r.insert(qs[1]);\\n                rNo++;\\n               totalSum += (qs[2] * (n-cNo));\\n      \\n            }else if(qs[0] && c.find(qs[1]) == c.end()){\\n                c.insert(qs[1]);\\n                cNo++;\\n               totalSum += (qs[2] * (n- rNo));\\n            }\\n            \\n        }\\n        return totalSum;\\n     \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] q) {\\n        long totalSum = 0, cNo = 0, rNo = 0;\\n        HashSet<Integer> r = new HashSet<>(), c = new HashSet<>();\\n        for(int indx = q.length-1; indx > - 1 ; indx--){\\n            var qs = q[indx];\\n            if(qs[0] == 0 && !r.contains(qs[1])){\\n                r.add(qs[1]);\\n                rNo++;\\n               totalSum += (qs[2] * (n-cNo));\\n      \\n            }else if(qs[0] == 1 && !c.contains(qs[1])){\\n                c.add(qs[1]);\\n                cNo++;\\n               totalSum += (qs[2] * (n- rNo));\\n            }\\n            \\n        }\\n        return totalSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594891,
                "title": "real-hard-3-methods-explained",
                "content": "**<<<<UPvote**\\n\\n\\n\\n**IDEA**\\nThe brute force requires every cell to be traversed so it will cause TLE (n^2).\\nSince the order of queries also matters, so we can\\'t simply store the change and result them all later.\\n**1st Approach**\\nIn this approach, we iterate from the end and keep track of remaining rows and columns. We calculate the contribution based on the current value and remaining rows/columns, considering the effect of row and column operations. By decrementing the counts for each operation, we ensure accurate calculation of the contribution.\\n\\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n        long long ans = 0, rowRemain = n, colRemain = n;\\n        for(int i = q.size()-1; i >= 0; --i){\\n            if(q[i][0] == 0 && rowFlag[q[i][1]]) { ans += colRemain * q[i][2];    rowFlag[q[i][1]] = 0; rowRemain--; }\\n            if(q[i][0] == 1 && colFlag[q[i][1]]) { ans += rowRemain * q[i][2];    colFlag[q[i][1]] = 0; colRemain--; }\\n        }\\n        return ans;\\n    }\\n\\n```\\n\\n\\n\\n**2nd Approach**\\n\\nWe start with the last query and go backwards.\\n\\nWe track if we have seen a row or column with id - so we can ignore earlier queries that will be overwritten.\\n\\nWe also count how many rows and columns have not been seen in cnt.\\n\\nThis way, each query adds v * cnt, where cnt is the count of unseen rows (for type == 0) or columns (for type == 1).\\n\\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cnt[2] = {n, n};\\n    bool seen[2][10001] = {};\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (!seen[type][id]) {\\n            seen[type][id] = true;\\n            res += v * cnt[!type];\\n            --cnt[type];\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\n**3rd Approach**\\n\\n\\nSuppose if a cell is made under two or more updations, then the final value will surely update the previous and it will be the answer. So if we approach from backwards (in the queries array) and then check if the current cell is already updated then it means we don\\'t need to sum the current value.\\n\\n**Complexity**\\nTime complexity:\\nO(queries.length())\\nSpace complexity:\\nO(n)\\nCode\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> rowV(n, -1), colV(n, -1);\\n        int rowC, colC;\\n        \\n        //It is done only to make the backward iteration simpler.\\n        reverse(queries.begin(), queries.end());\\n        \\n        long long sum=0;\\n        for(auto q : queries) {\\n            if((q[0] == 0 && rowV[q[1]] != -1) || (q[0] == 1 && colV[q[1]] != -1)) {\\n                continue;        \\n            }\\n            else {\\n                if(q[0] == 0) {\\n                    sum += (n-colC)*q[2];\\n                    rowV[q[1]] = q[2];\\n                    rowC++;\\n                }\\n                else {\\n                    sum += (n-rowC)*q[2];\\n                    colV[q[1]] = q[2];\\n                    colC++;\\n                }\\n                \\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n        long long ans = 0, rowRemain = n, colRemain = n;\\n        for(int i = q.size()-1; i >= 0; --i){\\n            if(q[i][0] == 0 && rowFlag[q[i][1]]) { ans += colRemain * q[i][2];    rowFlag[q[i][1]] = 0; rowRemain--; }\\n            if(q[i][0] == 1 && colFlag[q[i][1]]) { ans += rowRemain * q[i][2];    colFlag[q[i][1]] = 0; colRemain--; }\\n        }\\n        return ans;\\n    }\\n\\n```\n```\\nlong long matrixSumQueries(int n, vector<vector<int>>& qs) {\\n    long long res = 0, cnt[2] = {n, n};\\n    bool seen[2][10001] = {};\\n    for (int i = qs.size() - 1; i >= 0; --i) {\\n        int type = qs[i][0], id = qs[i][1], v = qs[i][2];\\n        if (!seen[type][id]) {\\n            seen[type][id] = true;\\n            res += v * cnt[!type];\\n            --cnt[type];\\n        }\\n    }\\n    return res;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> rowV(n, -1), colV(n, -1);\\n        int rowC, colC;\\n        \\n        //It is done only to make the backward iteration simpler.\\n        reverse(queries.begin(), queries.end());\\n        \\n        long long sum=0;\\n        for(auto q : queries) {\\n            if((q[0] == 0 && rowV[q[1]] != -1) || (q[0] == 1 && colV[q[1]] != -1)) {\\n                continue;        \\n            }\\n            else {\\n                if(q[0] == 0) {\\n                    sum += (n-colC)*q[2];\\n                    rowV[q[1]] = q[2];\\n                    rowC++;\\n                }\\n                else {\\n                    sum += (n-rowC)*q[2];\\n                    colV[q[1]] = q[2];\\n                    colC++;\\n                }\\n                \\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606245,
                "title": "c-java-iterating-from-the-final-query-to-the-first",
                "content": "The problem statement reveals that iterating from the first to the last query allows each subsequent query to overwrite previous values. Consequently, when we reverse this process, iterating from the last query to the first, no query can supersede the one following it. Instead, they only fill values in specific rows or columns if there are entries with a value of 0.\\n\\nTo facilitate this, we utilize two variables: `rows_filled` and `cols_filled` to track how many rows and columns have been populated so far. When filling a row, the focus is on the number of columns yet to be filled. Values are then filled into these columns, and `rows_filled` is incremented by one. Similarly, when filling a column, the emphasis is on the unpopulated rows. Values are filled into these rows, and `cols_filled` is increased by one.\\n\\nHowever, we must account for a potential edge case where the queries attempt to fill a row or column multiple times. Since our reverse iteration prevents any query from overwriting a previous one, each row or column can only be filled once. To handle this, we deploy two boolean arrays that track whether a row or column has already been filled.\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int rows_filled = 0, cols_filled = 0;\\n        vector<bool> rows(n, 0), cols(n, 0);\\n        long sum = 0l;\\n        for (int i = queries.size() - 1; i >= 0; i--) {\\n            vector<int> q = queries[i];\\n            if (q[0] == 0) {\\n                if (rows[q[1]]) continue;\\n                rows[q[1]] = 1;\\n                sum += q[2] * (n - cols_filled);\\n                rows_filled++;\\n            } else {\\n                if (cols[q[1]]) continue;\\n                cols[q[1]] = 1;\\n                sum += q[2] * (n - rows_filled);\\n                cols_filled++;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowsFilled = 0, colsFilled = 0;\\n        boolean[] rows = new boolean[n], cols = new boolean[n];\\n        long sum = 0l;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int[] q = queries[i];\\n            if (q[0] == 0) {\\n                if (rows[q[1]]) continue;\\n                rows[q[1]] = true;\\n                sum += q[2] * (n - colsFilled);\\n                rowsFilled++;\\n            } else {\\n                if (cols[q[1]]) continue;\\n                cols[q[1]] = true;\\n                sum += q[2] * (n - rowsFilled);\\n                colsFilled++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int rows_filled = 0, cols_filled = 0;\\n        vector<bool> rows(n, 0), cols(n, 0);\\n        long sum = 0l;\\n        for (int i = queries.size() - 1; i >= 0; i--) {\\n            vector<int> q = queries[i];\\n            if (q[0] == 0) {\\n                if (rows[q[1]]) continue;\\n                rows[q[1]] = 1;\\n                sum += q[2] * (n - cols_filled);\\n                rows_filled++;\\n            } else {\\n                if (cols[q[1]]) continue;\\n                cols[q[1]] = 1;\\n                sum += q[2] * (n - rows_filled);\\n                cols_filled++;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowsFilled = 0, colsFilled = 0;\\n        boolean[] rows = new boolean[n], cols = new boolean[n];\\n        long sum = 0l;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int[] q = queries[i];\\n            if (q[0] == 0) {\\n                if (rows[q[1]]) continue;\\n                rows[q[1]] = true;\\n                sum += q[2] * (n - colsFilled);\\n                rowsFilled++;\\n            } else {\\n                if (cols[q[1]]) continue;\\n                cols[q[1]] = true;\\n                sum += q[2] * (n - rowsFilled);\\n                colsFilled++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599051,
                "title": "c-straight-forward-o-n-solution-w-intuition-code-traversing-queries-from-end",
                "content": "# Intuition\\nWe can think of this problem as painting a grid wall. At every query, you\\'re painting the $$q[i][1]^{th}$$ row/columns based on type, with paint $$q[i][2]$$.\\nNow a simple thing that you need to think of is that when the if a part of wall is painted with color `x` and later on if that part is painted with paint `y` then the color `y` will be the current color of the wall which in this case is the value of the cell.\\n\\nThis means that we can traverse the queries from the end and add the `val` for the respective row/columns, and if the same row/column is being painted in an earlier query we can ignore the change.\\n\\nAnother important thing is to know is that if we\\'re painting a row and if two columns of that row are painted in a later query, we need to ignore those two columns\\' values. We\\'ll decrease the number of columns when we paint rows and vice versa. This will be more clearer in the approach and the code.\\nSimilar to the above point, we need to take care of the same row/column being painted twice. Only the latest query for that row should be considered. (we\\'ll use a HashSet for this)\\n\\n# Approach\\n1. Store the number of rows `r` and columns `c`\\n2. Create two vectors (one for Rows Filled and one for Columns Filled) to see if the row/columns is already filled at a later point.\\n3. Repeat step `4` to `x` for all queries from **end** to **start**\\n4. If `type == 0` and `row is not painted` then add `c*val` to the answer. Reduce `r` by `1`. Mark row as painted.\\n5. If `type == 1` and `column is not painted` then add `r*val` to the answer. Reduce `c` by `1`. Mark columns as painted.\\n\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int r=n, c=n;\\n        vector<bool> rf(n, false), cf(n, false);\\n        long long res{0ll};\\n        for(int i=queries.size()-1; i>=0 && r>=0 && c>=0; i--) {\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            if (type == 0) {\\n                if (rf[idx]) continue;\\n                res += (long long)c*val;\\n                r--;\\n                rf[idx] = true;\\n            }\\n            else {\\n                if (cf[idx]) continue;\\n                res += (long long)r*val;\\n                c--;\\n                cf[idx] = true;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(||queries||)$$\\nSince we\\'re traversing through all the queries, it\\'ll take the number of queries time.\\n\\n- Space complexity: $$O(n + n)$$\\nSince we\\'re using two Arrays/HashSets.\\n\\n\\n> ### Note\\n> - Upvote if you liked my solution\\n> - Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int r=n, c=n;\\n        vector<bool> rf(n, false), cf(n, false);\\n        long long res{0ll};\\n        for(int i=queries.size()-1; i>=0 && r>=0 && c>=0; i--) {\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            if (type == 0) {\\n                if (rf[idx]) continue;\\n                res += (long long)c*val;\\n                r--;\\n                rf[idx] = true;\\n            }\\n            else {\\n                if (cf[idx]) continue;\\n                res += (long long)r*val;\\n                c--;\\n                cf[idx] = true;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596202,
                "title": "c-most-easy-greedy-solution-by-reverse-iteration",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(),queries.end());\\n        unordered_set<ll> row,col;\\n        ll cntr=0,cntc=0;\\n        ll ans=0;\\n        for(auto it:queries)\\n        {\\n            int type=it[0];\\n            int ind=it[1];\\n            int val=it[2];\\n            if(type==0)\\n            {\\n                if(row.find(ind)==row.end())\\n                {\\n                row.insert(ind);\\n                ans+=(n-cntc)*val*1LL;\\n                cntr++;\\n                }\\n            }\\n            if(type==1)\\n            {\\n                 if(col.find(ind)==col.end())\\n                 {\\n                     col.insert(ind);\\n                    ans+=(n-cntr)*val*1LL;\\n                    cntc++;\\n                 }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(),queries.end());\\n        unordered_set<ll> row,col;\\n        ll cntr=0,cntc=0;\\n        ll ans=0;\\n        for(auto it:queries)\\n        {\\n            int type=it[0];\\n            int ind=it[1];\\n            int val=it[2];\\n            if(type==0)\\n            {\\n                if(row.find(ind)==row.end())\\n                {\\n                row.insert(ind);\\n                ans+=(n-cntc)*val*1LL;\\n                cntr++;\\n                }\\n            }\\n            if(type==1)\\n            {\\n                 if(col.find(ind)==col.end())\\n                 {\\n                     col.insert(ind);\\n                    ans+=(n-cntr)*val*1LL;\\n                    cntc++;\\n                 }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595596,
                "title": "java-o-n-solution-with-explanation-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLast query will always have all row/col filled. Starting from last query to 1st, each query will fill only those empty spaces left by pervious query.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - Maintain a set each for rows and cols.\\n - For each query starting from the last to first, check if the row/col to be filled is already filled. \\n - If its already filled, that means in the natural order(first to last), the current value will get overwritten so no need to consider this query.\\n - If not filled, add the row/col index to the row/col set respectively.\\n - Check the size of col set for type == 0 and row set for type == 1. This will tell us number of columns/rows already filled. We will therefore have (n-size) cells which will be filled by current query. So increment in total sum from this query will be (n - size) * value(i.e. queries[i][2]) \\n\\n# Complexity\\n- Time complexity: O(K), where K = length of queries array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        long sum = 0;\\n        for(int i=queries.length-1; i>=0; i--) {\\n            long currSum = 0;\\n            if(queries[i][0] == 0) {\\n                int row = queries[i][1];\\n                if(rows.contains(row))\\n                    continue;\\n                rows.add(queries[i][1]);\\n                int count = n - cols.size();\\n                \\n                currSum = (long) queries[i][2] * count;\\n            } else {\\n                int col = queries[i][1];\\n                if(cols.contains(col))\\n                    continue;\\n                \\n                cols.add(queries[i][1]);\\n                int count = n - rows.size();\\n                \\n                currSum = (long) queries[i][2] * count;\\n            }\\n            \\n            sum += currSum;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        long sum = 0;\\n        for(int i=queries.length-1; i>=0; i--) {\\n            long currSum = 0;\\n            if(queries[i][0] == 0) {\\n                int row = queries[i][1];\\n                if(rows.contains(row))\\n                    continue;\\n                rows.add(queries[i][1]);\\n                int count = n - cols.size();\\n                \\n                currSum = (long) queries[i][2] * count;\\n            } else {\\n                int col = queries[i][1];\\n                if(cols.contains(col))\\n                    continue;\\n                \\n                cols.add(queries[i][1]);\\n                int count = n - rows.size();\\n                \\n                currSum = (long) queries[i][2] * count;\\n            }\\n            \\n            sum += currSum;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594998,
                "title": "c-using-two-sets",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        unordered_set<int> row, col;\\n        for (int i = queries.size() - 1; i >= 0; i--){\\n            if(queries[i][0]){\\n                if(col.find(queries[i][1]) == col.end()){\\n                    col.insert(queries[i][1]);\\n                    sum += (n - row.size()) * queries[i][2];\\n                }\\n            }\\n            else{\\n                if(row.find(queries[i][1]) == row.end()){\\n                    row.insert(queries[i][1]);\\n                    sum += (n - col.size()) * queries[i][2];\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        unordered_set<int> row, col;\\n        for (int i = queries.size() - 1; i >= 0; i--){\\n            if(queries[i][0]){\\n                if(col.find(queries[i][1]) == col.end()){\\n                    col.insert(queries[i][1]);\\n                    sum += (n - row.size()) * queries[i][2];\\n                }\\n            }\\n            else{\\n                if(row.find(queries[i][1]) == row.end()){\\n                    row.insert(queries[i][1]);\\n                    sum += (n - col.size()) * queries[i][2];\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594911,
                "title": "easy-explaination-intution-0-n-easy-and-simple-code",
                "content": "# Intuition\\nDon\\'t worry if you were not able to solve this problem during the contest,\\nLets get into the question:\\n\\nwe have to **Return the sum of integers in the matrix after all queries are applied ** So, If you observe the if we see the changes made in the **REVERSE ORDER** , then you just need to update the 2d matrix once, if again the same indices appear do not bother about it.\\n\\nA problem was not how to build an effective algorithm.\\n1. Observe the change when a column or a row is added, what changes do we see for the upcoming values.\\n\\nEverytime a new column or row filled with a given value is added, next time empty places for the upcoming element decreses by 1.\\n\\n---\\nSee:\\n        Take a 3X3 matrix all filled with 0,s\\n        0 0 0\\n        0 0 0\\n        0 0 0\\nNow lets us add value 1 to the first row:\\n        1 1 1\\n        0 0 0\\n        0 0 0\\nNow see for and upcoming values for the column you\\'ll have n-1 places to fill it, the same goes vice versa. \\n\\n\\n\\n\\n      \\n\\n\\n# Approach\\n1. Firstly reverse the array.\\n2. Initialize a set data structue to keep the track of the row number or the column number for which you have made the changes.\\n3. Add to answer val * remaining row when col operation is performed &\\nadd to answer val * remaining col when row operation is performed.\\n4. Decreament remaining row when row operation is performed &\\nreamining col when col operation is performed.\\n\\n# Complexity\\n- Time complexity:\\n0(n) where n is the number of queries\\n\\n- Space complexity:\\n0(n) set size where n is the number of indices\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& a) {\\n        int x = a.size();\\n        int row = n,col = n;\\n        reverse(a.begin(),a.end()); // Key observaition\\n        long long ans = 0;\\n        set<pair<int,int>> st;\\n        for(int i=0;i<x;i++)\\n        {\\n            int type = a[i][0];\\n            int flag = a[i][1];\\n            int val = a[i][2];\\n            if(st.find({type,flag})==st.end())\\n            {\\n                st.insert({type,flag});\\n                if(type==0)\\n                {\\n                    long long temp1 = row*val; // Simple maths\\n                    col--;\\n                    ans+= temp1;\\n                }\\n                else if(type==1)\\n                {\\n                    long long temp2 = col*val;\\n                    row--;\\n                    ans+= temp2;\\n                }\\n            }\\n            else if(st.find({type,flag})!=st.end())continue;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& a) {\\n        int x = a.size();\\n        int row = n,col = n;\\n        reverse(a.begin(),a.end()); // Key observaition\\n        long long ans = 0;\\n        set<pair<int,int>> st;\\n        for(int i=0;i<x;i++)\\n        {\\n            int type = a[i][0];\\n            int flag = a[i][1];\\n            int val = a[i][2];\\n            if(st.find({type,flag})==st.end())\\n            {\\n                st.insert({type,flag});\\n                if(type==0)\\n                {\\n                    long long temp1 = row*val; // Simple maths\\n                    col--;\\n                    ans+= temp1;\\n                }\\n                else if(type==1)\\n                {\\n                    long long temp2 = col*val;\\n                    row--;\\n                    ans+= temp2;\\n                }\\n            }\\n            else if(st.find({type,flag})!=st.end())continue;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594896,
                "title": "only-logic-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) The brute force requires every cell to be traversed so it will cause TLE (n^2).\\n2) Since the order of queries also matters, so we can\\'t simply store the change and result them all later.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose if a cell is made under two or more updations, then the final value will surely update the previous and it will be the answer. So if we approach from backwards (in the queries array) and then check if the current cell is already updated then it means we don\\'t need to sum the current value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(queries.length())\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> rowV(n, -1), colV(n, -1);\\n        int rowC, colC;\\n        \\n        //It is done only to make the backward iteration simpler.\\n        reverse(queries.begin(), queries.end());\\n        \\n        long long sum=0;\\n        for(auto q : queries) {\\n            if((q[0] == 0 && rowV[q[1]] != -1) || (q[0] == 1 && colV[q[1]] != -1)) {\\n                continue;        \\n            }\\n            else {\\n                if(q[0] == 0) {\\n                    sum += (n-colC)*q[2];\\n                    rowV[q[1]] = q[2];\\n                    rowC++;\\n                }\\n                else {\\n                    sum += (n-rowC)*q[2];\\n                    colV[q[1]] = q[2];\\n                    colC++;\\n                }\\n                \\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> rowV(n, -1), colV(n, -1);\\n        int rowC, colC;\\n        \\n        //It is done only to make the backward iteration simpler.\\n        reverse(queries.begin(), queries.end());\\n        \\n        long long sum=0;\\n        for(auto q : queries) {\\n            if((q[0] == 0 && rowV[q[1]] != -1) || (q[0] == 1 && colV[q[1]] != -1)) {\\n                continue;        \\n            }\\n            else {\\n                if(q[0] == 0) {\\n                    sum += (n-colC)*q[2];\\n                    rowV[q[1]] = q[2];\\n                    rowC++;\\n                }\\n                else {\\n                    sum += (n-rowC)*q[2];\\n                    colV[q[1]] = q[2];\\n                    colC++;\\n                }\\n                \\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619738,
                "title": "simple-small-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MatrixSumQueries(int n, int[][] queries) {\\n        \\n        var rows = new HashSet<int>();\\n        var columns = new HashSet<int>();\\n        long sum = 0;\\n\\n        for(int i = queries.Length - 1; i >= 0; i--)\\n        {\\n            var isRow = queries[i][0] == 0;\\n            var isColumn = queries[i][0] == 1;\\n            var index = queries[i][1];\\n            var val =  queries[i][2];\\n\\n            if(isRow && !rows.Contains(index))\\n            {\\n                sum += (n - columns.Count) * val;\\n                rows.Add(index);\\n            }\\n            else if(isColumn && !columns.Contains(index))\\n            {\\n                sum +=  (n - rows.Count) * val;\\n                columns.Add(index);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MatrixSumQueries(int n, int[][] queries) {\\n        \\n        var rows = new HashSet<int>();\\n        var columns = new HashSet<int>();\\n        long sum = 0;\\n\\n        for(int i = queries.Length - 1; i >= 0; i--)\\n        {\\n            var isRow = queries[i][0] == 0;\\n            var isColumn = queries[i][0] == 1;\\n            var index = queries[i][1];\\n            var val =  queries[i][2];\\n\\n            if(isRow && !rows.Contains(index))\\n            {\\n                sum += (n - columns.Count) * val;\\n                rows.Add(index);\\n            }\\n            else if(isColumn && !columns.Contains(index))\\n            {\\n                sum +=  (n - rows.Count) * val;\\n                columns.Add(index);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619429,
                "title": "easy-clean-python3-solution-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved even with simulating the process but that approach is too slow. So, what we can do is maintain sets of rows and columns changed and start with final queries (i.e., the queries whose changes don\\'t get modified again)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by iterating the queries in reverse order as the final query will never get overrridden and is final. We keep a count of number of rows and columns changed so far in order to keep track of how many cells are modified at each query.\\nWe also keep track of all the changed rows and columns (using sets) so that once a row or column is modified, it isn\\'t modified again (as we are traversing in reverse order, the later changes are actually ones which were supposed to happen earlier but were overridden by later queries)\\nThe ans variable is updated with each query.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ where n is the size od queries list\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0 \\n        rowchng, colchng = 0,0\\n        row, col = set(), set()\\n        for i in range(len(queries)-1,-1,-1):\\n            typ, ind, val = queries[i]\\n            if typ == 0:\\n                if ind not in row:\\n                    row.add(ind)\\n                    ans += (n-colchng)*val\\n                    rowchng += 1\\n            else:\\n                if ind not in col:\\n                    ans += (n-rowchng)*val\\n                    colchng += 1\\n                    col.add(ind)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0 \\n        rowchng, colchng = 0,0\\n        row, col = set(), set()\\n        for i in range(len(queries)-1,-1,-1):\\n            typ, ind, val = queries[i]\\n            if typ == 0:\\n                if ind not in row:\\n                    row.add(ind)\\n                    ans += (n-colchng)*val\\n                    rowchng += 1\\n            else:\\n                if ind not in col:\\n                    ans += (n-rowchng)*val\\n                    colchng += 1\\n                    col.add(ind)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598293,
                "title": "easiy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long sum=0;\\n        map<int,int> mpr,mpc;\\n        set<int> sr,sc;\\n        int some=q.size();\\n        for(int i=some-1;i>=0;i--){\\n            int type=q[i][0];\\n            int ind=q[i][1];\\n            int val=q[i][2];\\n            if(type==0){\\n                if(mpr[ind]==0){\\n                    sum+=((n-sc.size())*val);\\n                    mpr[ind]=1;\\n                    sr.insert(ind);\\n                }\\n            }\\n            else{\\n                if(mpc[ind]==0){\\n                    sum+=((n-sr.size())*val);\\n                    mpc[ind]=1;\\n                    sc.insert(ind);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        long long sum=0;\\n        map<int,int> mpr,mpc;\\n        set<int> sr,sc;\\n        int some=q.size();\\n        for(int i=some-1;i>=0;i--){\\n            int type=q[i][0];\\n            int ind=q[i][1];\\n            int val=q[i][2];\\n            if(type==0){\\n                if(mpr[ind]==0){\\n                    sum+=((n-sc.size())*val);\\n                    mpr[ind]=1;\\n                    sr.insert(ind);\\n                }\\n            }\\n            else{\\n                if(mpc[ind]==0){\\n                    sum+=((n-sr.size())*val);\\n                    mpc[ind]=1;\\n                    sc.insert(ind);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597048,
                "title": "easy-cpp-solution",
                "content": "# Approach \\nTry reverse order of queries.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        #define ll long long\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n            ios_base::sync_with_stdio(false);\\n            cin.tie(NULL);\\n            ll ans = 0;\\n            vector<bool>row(n),col(n);\\n            ll size = n*n;\\n            ll colu=0,rowu=0;\\n            for(int i=queries.size()-1;i>=0;i--){\\n                    int type = queries[i][0];\\n                    if(type==0){\\n                            if(row[queries[i][1]]==false){\\n                                    ll op = n-colu;\\n                                    ans+=(1LL*queries[i][2]*op);\\n                                    rowu++;\\n                                    row[queries[i][1]]=true;\\n                            } \\n                    }else{\\n                            if(col[queries[i][1]]==false){\\n                                   ll op = n-rowu;\\n                                   ans+=(1LL*queries[i][2]*op);\\n                                   colu++; \\n                                   col[queries[i][1]]=true;\\n                            }\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        #define ll long long\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n            ios_base::sync_with_stdio(false);\\n            cin.tie(NULL);\\n            ll ans = 0;\\n            vector<bool>row(n),col(n);\\n            ll size = n*n;\\n            ll colu=0,rowu=0;\\n            for(int i=queries.size()-1;i>=0;i--){\\n                    int type = queries[i][0];\\n                    if(type==0){\\n                            if(row[queries[i][1]]==false){\\n                                    ll op = n-colu;\\n                                    ans+=(1LL*queries[i][2]*op);\\n                                    rowu++;\\n                                    row[queries[i][1]]=true;\\n                            } \\n                    }else{\\n                            if(col[queries[i][1]]==false){\\n                                   ll op = n-rowu;\\n                                   ans+=(1LL*queries[i][2]*op);\\n                                   colu++; \\n                                   col[queries[i][1]]=true;\\n                            }\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596562,
                "title": "video-explanation-binary-search-intuition",
                "content": "# Explanation\\n\\n[Click here for the video](https://youtu.be/OJiVpzztP_s)\\n\\n# Code\\n```\\ntypedef long long int ll;\\n\\n#define pii pair<int, int>\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<pii> rows(n, make_pair(-1, 0));\\n        vector<pii> cols(n, make_pair(-1, 0));\\n        \\n        for (int j = 0; j < queries.size(); j ++) {\\n            vector<int> q = queries[j];\\n            \\n            if (q[0] == 0) \\n                rows[q[1]] = {j, q[2]};\\n            else \\n                cols[q[1]] = {j, q[2]};\\n        }\\n        \\n        long long result = 0;\\n        \\n        /*\\n        for (int r = 0; r < n; r ++) {\\n            for (int c = 0; c < n; c ++) {\\n                pii val = max (rows[r], cols[c]);\\n                result += val.S;\\n            }\\n        }\\n        */\\n        \\n        sort (cols.begin(), cols.end());\\n        \\n        vector<ll> prefix_cols(n+1, 0);\\n        for (int j = 1; j <= n; j ++) prefix_cols[j] = prefix_cols[j-1] + cols[j-1].S;\\n        \\n        for (int r = 0; r < n; r ++) {\\n            pii row = rows[r];\\n            ll col_pos = lower_bound(cols.begin(), cols.end(), row) - cols.begin();\\n            \\n            result += col_pos * row.S;\\n            if (col_pos < n) result += (prefix_cols[n] - prefix_cols[col_pos]);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\n#define pii pair<int, int>\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<pii> rows(n, make_pair(-1, 0));\\n        vector<pii> cols(n, make_pair(-1, 0));\\n        \\n        for (int j = 0; j < queries.size(); j ++) {\\n            vector<int> q = queries[j];\\n            \\n            if (q[0] == 0) \\n                rows[q[1]] = {j, q[2]};\\n            else \\n                cols[q[1]] = {j, q[2]};\\n        }\\n        \\n        long long result = 0;\\n        \\n        /*\\n        for (int r = 0; r < n; r ++) {\\n            for (int c = 0; c < n; c ++) {\\n                pii val = max (rows[r], cols[c]);\\n                result += val.S;\\n            }\\n        }\\n        */\\n        \\n        sort (cols.begin(), cols.end());\\n        \\n        vector<ll> prefix_cols(n+1, 0);\\n        for (int j = 1; j <= n; j ++) prefix_cols[j] = prefix_cols[j-1] + cols[j-1].S;\\n        \\n        for (int r = 0; r < n; r ++) {\\n            pii row = rows[r];\\n            ll col_pos = lower_bound(cols.begin(), cols.end(), row) - cols.begin();\\n            \\n            result += col_pos * row.S;\\n            if (col_pos < n) result += (prefix_cols[n] - prefix_cols[col_pos]);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596280,
                "title": "clean-best-c-code-greedy-traverse-from-back",
                "content": "# Complexity\\n- Time complexity:\\nO(q) where \\'q\\' is the size of the query\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long sum = 0;\\n        vector<int> row(n),col(n);\\n        int row_visited = 0,col_visited = 0,que_size = queries.size();\\n        for(int i=que_size-1;i>=0;i--){\\n            int type = queries[i][0],ind = queries[i][1],val = queries[i][2];\\n            if((type && col[ind]) || (!type && row[ind]))\\n                continue;\\n            if(type){\\n                sum += (n - row_visited)*val; \\n                col_visited++;\\n                col[ind] = 1;\\n            }\\n            else{\\n                sum += (n - col_visited)*val; \\n                row_visited++;\\n                row[ind] = 1;\\n            }\\n                \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long sum = 0;\\n        vector<int> row(n),col(n);\\n        int row_visited = 0,col_visited = 0,que_size = queries.size();\\n        for(int i=que_size-1;i>=0;i--){\\n            int type = queries[i][0],ind = queries[i][1],val = queries[i][2];\\n            if((type && col[ind]) || (!type && row[ind]))\\n                continue;\\n            if(type){\\n                sum += (n - row_visited)*val; \\n                col_visited++;\\n                col[ind] = 1;\\n            }\\n            else{\\n                sum += (n - col_visited)*val; \\n                row_visited++;\\n                row[ind] = 1;\\n            }\\n                \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596093,
                "title": "c-easy-to-understand-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code processes a series of queries, each representing either a row or a column in a matrix.\\n2. It stores the values assigned to each row and column in separate vectors (row and col).\\n3. The code sorts the row queries based on their order of occurrence.\\n4. It calculates the cumulative sum of row values, representing the sum of values in each row up to that point.\\n5. It creates a vector (ans) with the indices of the row queries.\\n6. The code iterates through the column queries and finds the relevant row queries using binary search.\\n7. It calculates the sum based on the contributions of rows and columns.\\n8. Finally, it returns the computed sum as the result.\\n\\n# Complexity\\n- Time complexity: O(N*LOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(3*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<pair<int,long long>> row(n,{0,0}),col(n,{0,0});\\n        for(int i=0;i<queries.size();++i){\\n            int type=queries[i][0];\\n            int x=queries[i][1];\\n            int val=queries[i][2];\\n            if(type==0){\\n                row[x]=make_pair(i+1,val);\\n            }\\n            else{\\n                col[x]=make_pair(i+1,val);\\n            }\\n        }\\n        sort(row.begin(),row.end());\\n        for(int i=1;i<n;++i){\\n            row[i].second+=row[i-1].second;\\n        }\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n;++i){\\n            ans[i]=row[i].first;\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;++i){\\n            int ind=upper_bound(ans.begin(),ans.end(),col[i].first)-ans.begin();\\n            if(ind==0){\\n                sum+=row[n-1].second*1ll;\\n            }\\n            else{\\n                sum+=(ind*col[i].second)*1ll;\\n                sum+=(row[n-1].second-row[ind-1].second)*1ll;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<pair<int,long long>> row(n,{0,0}),col(n,{0,0});\\n        for(int i=0;i<queries.size();++i){\\n            int type=queries[i][0];\\n            int x=queries[i][1];\\n            int val=queries[i][2];\\n            if(type==0){\\n                row[x]=make_pair(i+1,val);\\n            }\\n            else{\\n                col[x]=make_pair(i+1,val);\\n            }\\n        }\\n        sort(row.begin(),row.end());\\n        for(int i=1;i<n;++i){\\n            row[i].second+=row[i-1].second;\\n        }\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n;++i){\\n            ans[i]=row[i].first;\\n        }\\n        long long sum=0;\\n        for(int i=0;i<n;++i){\\n            int ind=upper_bound(ans.begin(),ans.end(),col[i].first)-ans.begin();\\n            if(ind==0){\\n                sum+=row[n-1].second*1ll;\\n            }\\n            else{\\n                sum+=(ind*col[i].second)*1ll;\\n                sum+=(row[n-1].second-row[ind-1].second)*1ll;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595988,
                "title": "easiest-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        vector<int>row(n, 0);\\n        vector<int>col(n, 0);\\n        \\n        long long ans = 0;\\n        int r = 0, c = 0;\\n        for(int i = q.size()-1; i >= 0; i--)\\n        {\\n            int type = q[i][0];\\n            int ind = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type == 0 && row[ind] == 0 )\\n            {\\n                r++;\\n                row[ind] = 1;\\n                ans += (n - c) * val;\\n            }\\n            \\n            if(type == 1 && col[ind] == 0)\\n            {\\n                c++;\\n                col[ind] = 1;\\n                ans += (n - r) * val;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        vector<int>row(n, 0);\\n        vector<int>col(n, 0);\\n        \\n        long long ans = 0;\\n        int r = 0, c = 0;\\n        for(int i = q.size()-1; i >= 0; i--)\\n        {\\n            int type = q[i][0];\\n            int ind = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(type == 0 && row[ind] == 0 )\\n            {\\n                r++;\\n                row[ind] = 1;\\n                ans += (n - c) * val;\\n            }\\n            \\n            if(type == 1 && col[ind] == 0)\\n            {\\n                c++;\\n                col[ind] = 1;\\n                ans += (n - r) * val;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595881,
                "title": "traverse-queries-in-reverse-c",
                "content": "# Complexity\\n- Time complexity :  $$O(Q)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity :  $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        long long ans = 0;\\n        unordered_set<int> visRow;\\n        unordered_set<int> visCol;\\n        for(int i=q-1 ; i>=0 ; i--) {\\n            int type = queries[i][0];\\n            int val = queries[i][2];\\n            if(queries[i][0] == 1) {\\n                int col = queries[i][1];\\n                if(visCol.count(col)) continue;\\n                \\n                ans += 1ll*(n-visRow.size())*val;\\n                visCol.insert(col);\\n            }\\n            \\n            else {\\n                int row = queries[i][1];\\n                if(visRow.count(row)) continue;\\n                \\n                ans += 1ll*(n-visCol.size())*val;\\n                visRow.insert(row);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        long long ans = 0;\\n        unordered_set<int> visRow;\\n        unordered_set<int> visCol;\\n        for(int i=q-1 ; i>=0 ; i--) {\\n            int type = queries[i][0];\\n            int val = queries[i][2];\\n            if(queries[i][0] == 1) {\\n                int col = queries[i][1];\\n                if(visCol.count(col)) continue;\\n                \\n                ans += 1ll*(n-visRow.size())*val;\\n                visCol.insert(col);\\n            }\\n            \\n            else {\\n                int row = queries[i][1];\\n                if(visRow.count(row)) continue;\\n                \\n                ans += 1ll*(n-visCol.size())*val;\\n                visRow.insert(row);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595798,
                "title": "simple-and-easy-to-understand-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int size = queries.size();\\n        int rows = n, cols = n;\\n        vector<bool> rowVis(n,0), colVis(n,0);\\n        long ans = 0;\\n        \\n        //Iterating in reverse order so we don\\'t have to update already visited rows/cols.\\n        for(int i=size-1; i>=0; i--)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(type == 0)\\n            {\\n              if(rowVis[index] == 0) //Checking whether the row is already visited.\\n              {\\n                rowVis[index] = 1;\\n                ans += val*rows;\\n                cols--; //No need to update already visited elements in next iterations.\\n              }\\n            }\\n            else\\n            {\\n                if(colVis[index] == 0)\\n                {\\n                    colVis[index] = 1;\\n                    ans += val*cols;\\n                    rows--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int size = queries.size();\\n        int rows = n, cols = n;\\n        vector<bool> rowVis(n,0), colVis(n,0);\\n        long ans = 0;\\n        \\n        //Iterating in reverse order so we don\\'t have to update already visited rows/cols.\\n        for(int i=size-1; i>=0; i--)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(type == 0)\\n            {\\n              if(rowVis[index] == 0) //Checking whether the row is already visited.\\n              {\\n                rowVis[index] = 1;\\n                ans += val*rows;\\n                cols--; //No need to update already visited elements in next iterations.\\n              }\\n            }\\n            else\\n            {\\n                if(colVis[index] == 0)\\n                {\\n                    colVis[index] = 1;\\n                    ans += val*cols;\\n                    rows--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595698,
                "title": "line-by-line-comments-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, we consider the simulation approach. We iterate form the first query to the last query, and set value for each cell. Then we traverse the matrix, ans get the final sum. But the simulation approach\\'s time complexity is too high. We handle a cell too many times. After thinking for a while, we realized that we only need to handle the last value of one cell, although it\\'s not easy to think of that.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key point to solve this problem is only handle the last value of one cell. So we iterate from the last query to the first query. Whenever we added a row of values or a column of values to the result, we marked that row or column deleted, because all previously setted values are overrided. There is no need to handle these values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(queries.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] q) {\\n        boolean[] row = new boolean[n]; // mark rows that are deleted. true meas deleted\\n        boolean[] col = new boolean[n]; // mark columns that are deleted. true meas deleted\\n        int rowRemain = n; // count the number of rows that are not deleted\\n        int colRemain = n; // count the number of columns that are not deleted\\n        long ans = 0;\\n        for (int i = q.length - 1; i >= 0; --i) {\\n            int type = q[i][0], index = q[i][1], value = q[i][2];\\n            if (type == 0) {\\n                if (!row[index]) { // the row has not been deleted\\n                    // only not deleted columns contribute to the final sum\\n                    ans += value * colRemain;\\n                    row[index] = true; // mark this row is deleted\\n                    --rowRemain; // decrease the number of not deleted rows\\n                }\\n            } else {\\n                if (!col[index]) { // the column has not been deleted\\n                    // only not deleted rows contribute to the final sum\\n                    ans += value * rowRemain;\\n                    col[index] = true; // mark this column is deleted\\n                    --colRemain; // decrease the number of not deleted columns\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] q) {\\n        boolean[] row = new boolean[n]; // mark rows that are deleted. true meas deleted\\n        boolean[] col = new boolean[n]; // mark columns that are deleted. true meas deleted\\n        int rowRemain = n; // count the number of rows that are not deleted\\n        int colRemain = n; // count the number of columns that are not deleted\\n        long ans = 0;\\n        for (int i = q.length - 1; i >= 0; --i) {\\n            int type = q[i][0], index = q[i][1], value = q[i][2];\\n            if (type == 0) {\\n                if (!row[index]) { // the row has not been deleted\\n                    // only not deleted columns contribute to the final sum\\n                    ans += value * colRemain;\\n                    row[index] = true; // mark this row is deleted\\n                    --rowRemain; // decrease the number of not deleted rows\\n                }\\n            } else {\\n                if (!col[index]) { // the column has not been deleted\\n                    // only not deleted rows contribute to the final sum\\n                    ans += value * rowRemain;\\n                    col[index] = true; // mark this column is deleted\\n                    --colRemain; // decrease the number of not deleted columns\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595697,
                "title": "explained-with-short-examples-o-q-c",
                "content": "# Intuition and Appraoch\\nIt doesnt make sense to process the queries from the start.\\nBecause some query from the future can replace this query that can change the answer.\\n\\n***So its better to process queries from the end***\\n\\nAnd we dont need to process pair duplicate queries(For ex: 0 operation on row 5 once happened, cant happen again, as we are traversing backwards)\\nStore the first two part of the queries in set or hashset to check for this condition.\\n\\n***Any row operation reduces the cells in the columns which contribute to the sum and any column operation reduces the cells in rows that contribute to the sum(this was the main operation)***\\n\\nFor ex: Once we replace all values of row 4, as we are processing queries form the end, doesnt matter what queries are, this row will remain unchanged.\\nIt is the same as reducing a cell form every column of the matrix.\\nSame goes for column operation and row cells.\\n\\n[ Read example again and think, if not able to understand, its like layers ]\\n\\nSo maintaing a rowCellCount and colCellCount will be helpful to make the answer.\\n\\nif (type == 0){\\n\\t\\tcolCells--;\\n\\t\\tans += rowCells * val;\\n}\\nelse{\\n\\t\\trowCells--;\\n\\t\\tans += colCells * val;\\n}\\n\\n\\n# Complexity\\n- Time complexity:\\nO(queries.size)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n\\tlong long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n\\t\\tlong long ans = 0;\\n\\t\\tll rowCells = n;\\n\\t\\tll colCells = n;\\n\\t\\tunordered_set<int> st;\\n\\t\\tll type, index, val;\\n\\t\\tint key;\\n\\t\\tfor (int i = queries.size() - 1; i >= 0 ; --i)\\n\\t\\t{\\n\\t\\t\\ttype = queries[i][0];\\n\\t\\t\\tindex = queries[i][1];\\n\\t\\t\\tval = queries[i][2];\\n\\t\\t\\tkey = type==0? 0 : n;\\n\\t\\t\\tkey += index;\\n\\t\\t\\tif (st.find(key) != end(st))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tst.insert(key);\\n\\t\\t\\tif (type == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolCells--;\\n\\t\\t\\t\\tans += rowCells * val;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\trowCells--;\\n\\t\\t\\t\\tans += colCells * val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n\\n```\\n\\nUpvote if you found this helpful!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n\\tlong long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n\\t\\tlong long ans = 0;\\n\\t\\tll rowCells = n;\\n\\t\\tll colCells = n;\\n\\t\\tunordered_set<int> st;\\n\\t\\tll type, index, val;\\n\\t\\tint key;\\n\\t\\tfor (int i = queries.size() - 1; i >= 0 ; --i)\\n\\t\\t{\\n\\t\\t\\ttype = queries[i][0];\\n\\t\\t\\tindex = queries[i][1];\\n\\t\\t\\tval = queries[i][2];\\n\\t\\t\\tkey = type==0? 0 : n;\\n\\t\\t\\tkey += index;\\n\\t\\t\\tif (st.find(key) != end(st))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tst.insert(key);\\n\\t\\t\\tif (type == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolCells--;\\n\\t\\t\\t\\tans += rowCells * val;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\trowCells--;\\n\\t\\t\\t\\tans += colCells * val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595543,
                "title": "reverse-iteration-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we are overwriting the queries its easy to manage them in reverse order.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate the queries in reverse fashion and keep track of the row and column which are used or for which a query is already encountered before and also keep a track of at each step how many rows and cols are modified. We need to do this because (lets say we have already made a column as any value say 4, if we encounter query to perform on a row we know that one of its column is already set we cant modify this so we just add in our ans the values of the remaing columns).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN) -> iterating through the queries for once and insertion in set takes logn\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) -> space due to use of set\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        long long ans = 0;\\n        \\n        int col = 0;\\n        int row = 0;\\n        \\n        set<pair<int, int>> st;\\n        \\n        for(int i = q.size() - 1; i >= 0; i--){\\n            \\n            long long mulRow = row;\\n            long long mulCol = col;\\n\\n            int type = q[i][0];\\n            int ind = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(st.count({type, ind}) == 0){\\n                ans += (n * val) - ((type == 0 ? mulRow : mulCol) * val);\\n                if(type == 1) row++;\\n                else col++;\\n            }\\n            \\n            st.insert({type, ind});\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        long long ans = 0;\\n        \\n        int col = 0;\\n        int row = 0;\\n        \\n        set<pair<int, int>> st;\\n        \\n        for(int i = q.size() - 1; i >= 0; i--){\\n            \\n            long long mulRow = row;\\n            long long mulCol = col;\\n\\n            int type = q[i][0];\\n            int ind = q[i][1];\\n            int val = q[i][2];\\n            \\n            if(st.count({type, ind}) == 0){\\n                ans += (n * val) - ((type == 0 ? mulRow : mulCol) * val);\\n                if(type == 1) row++;\\n                else col++;\\n            }\\n            \\n            st.insert({type, ind});\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595485,
                "title": "counting-and-reverse-iteration-solution-explanation",
                "content": "# Approach\\n`cntR` and `cntC` are the no. of rows and columns resp. which are not set yet.\\nwe are iterating the queries in `reverse`, since the last elements in the query are prefferable since they are the one whose set value is reflected in the matrix , they `overwrite the others`.\\nTherefore we are tracking record of the row and column which are visited or not, if it is visited, we should not evaluate its set value and if it is not visited we evaluate and reduce the `cnt by 1` for the corresponding row or column and mark it visited that it should not be evaluted afterwards. \\n\\n# Complexity\\n- Time complexity: $$O(len(queries))$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0\\n        cntR, cntC = n, n\\n        R = [True] * n\\n        C = [True] * n\\n        for t, i, v in queries[::-1]:\\n            if t == 0 and R[i]:\\n                ans += v * cntC\\n                cntR -= 1\\n                R[i] = False\\n            elif t == 1 and C[i]:\\n                ans += v * cntR\\n                cntC -= 1\\n                C[i] = False\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0\\n        cntR, cntC = n, n\\n        R = [True] * n\\n        C = [True] * n\\n        for t, i, v in queries[::-1]:\\n            if t == 0 and R[i]:\\n                ans += v * cntC\\n                cntR -= 1\\n                R[i] = False\\n            elif t == 1 and C[i]:\\n                ans += v * cntR\\n                cntC -= 1\\n                C[i] = False\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595449,
                "title": "c-solution-greedy-brute-force-optimized",
                "content": "# Intuition\\n* Process the queries in reversed order because if you process from forward, you will have to update matrix each time..\\n* By processing in reverse , you make sure that no further changes can be made on that row or column.\\n\\n# Approach\\n* Here iterate in reverse order & Keep track number of rows and number of cols that can be assigned a value, using row counter and column counter.\\n* Add to answer $$(val * remainingRow)$$ when col operation is performed & add to answer $$(val * remainingCol)$$ when row operation is performed.\\n* Decreament remaining $$row$$ when row operation is performed &\\nreamining $$col$$ when col operation is performed\\n* Note : The trick is to when ever we perform a $$row$$ operation then number of column remaining for next $$col$$ operation 1 less and same is the case for col operation.\\n\\n\\n# Code\\n\\n\\n## Brute Force - TLE\\n* Time Complexity - $$O(N^2)$$\\n* Space Complexity - $$O(N^2)$$\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        if(queries.size() == 0){\\n            return 0;\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        for(auto &q : queries){\\n            int t = q[0];\\n            int i = q[1];\\n            int v = q[2];\\n            \\n            //col\\n            if(t == 1){\\n                for(int k = 0; k < n; k++){\\n                    ans[k][i] = v;\\n                }\\n            }\\n            //row\\n            else{\\n                for(int k = 0; k < n; k++){\\n                    ans[i][k] = v;\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                res += ans[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n## Optimized Approach\\n* Time Complexity - $$O(N)$$\\n* Space Complexity - $$O(N)$$\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int m = queries.size();\\n        unordered_set<int> rowMap;\\n        unordered_set<int> colMap;\\n        \\n        long long ans = 0;\\n        \\n        long long rowCounter = 0;\\n        long long colCounter = 0;\\n        \\n        \\n        for(int i = m - 1; i >= 0; i--){\\n            int t = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(t == 1){\\n                if(colMap.count(idx)){\\n                    continue;\\n                }\\n                else{\\n                    colMap.insert(idx);\\n                    ans += (n - rowCounter) * val;\\n                    colCounter++;\\n                }\\n            }\\n            else if(t == 0){\\n                if(rowMap.count(idx)){\\n                    continue;\\n                }\\n                else{\\n                    rowMap.insert(idx);\\n                    ans += (n - colCounter) * val;\\n                    rowCounter++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        if(queries.size() == 0){\\n            return 0;\\n        }\\n        \\n        vector<vector<int>> ans(n, vector<int>(n, 0));\\n        \\n        for(auto &q : queries){\\n            int t = q[0];\\n            int i = q[1];\\n            int v = q[2];\\n            \\n            //col\\n            if(t == 1){\\n                for(int k = 0; k < n; k++){\\n                    ans[k][i] = v;\\n                }\\n            }\\n            //row\\n            else{\\n                for(int k = 0; k < n; k++){\\n                    ans[i][k] = v;\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                res += ans[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int m = queries.size();\\n        unordered_set<int> rowMap;\\n        unordered_set<int> colMap;\\n        \\n        long long ans = 0;\\n        \\n        long long rowCounter = 0;\\n        long long colCounter = 0;\\n        \\n        \\n        for(int i = m - 1; i >= 0; i--){\\n            int t = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(t == 1){\\n                if(colMap.count(idx)){\\n                    continue;\\n                }\\n                else{\\n                    colMap.insert(idx);\\n                    ans += (n - rowCounter) * val;\\n                    colCounter++;\\n                }\\n            }\\n            else if(t == 0){\\n                if(rowMap.count(idx)){\\n                    continue;\\n                }\\n                else{\\n                    rowMap.insert(idx);\\n                    ans += (n - colCounter) * val;\\n                    rowCounter++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595331,
                "title": "c-o-n-reverse-iteration",
                "content": "We reverse the queries given bcoz in reverse manner what we place in the matrix will cannot be changed by any other operations. \\nlet if the operation is on row then we set that row to zero and increment the col bcoz when we perform operation in row then one col is occupied and same for cols.\\nEdge Case: if cols[i] or rows[i] is already zero then we dont have to decrement the srow or scol as there is no new col or row is changed\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>rows(n,n),cols(n,n);\\n        reverse(queries.begin(),queries.end());\\n        long long sum=0,scol=0,srow=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long type=queries[i][0],indx=queries[i][1],val=queries[i][2];\\n            if(type)\\n            {\\n                sum+=max(cols[indx]-scol,0ll)*(long long)val;\\n                if(srow<n&&cols[indx]!=0)\\n\\t\\t\\t\\t\\tsrow++;\\n                cols[indx]=0;\\n            }\\n            else \\n            {\\n                sum+=max(rows[indx]-srow,0ll)*(long long)val;\\n                if(scol<n&&rows[indx]!=0)\\n\\t\\t\\t\\t\\tscol++;  \\n                rows[indx]=0;\\n            }\\n        }\\n        return sum;\\n    }\\n};``\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>rows(n,n),cols(n,n);\\n        reverse(queries.begin(),queries.end());\\n        long long sum=0,scol=0,srow=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long type=queries[i][0],indx=queries[i][1],val=queries[i][2];\\n            if(type)\\n            {\\n                sum+=max(cols[indx]-scol,0ll)*(long long)val;\\n                if(srow<n&&cols[indx]!=0)\\n\\t\\t\\t\\t\\tsrow++;\\n                cols[indx]=0;\\n            }\\n            else \\n            {\\n                sum+=max(rows[indx]-srow,0ll)*(long long)val;\\n                if(scol<n&&rows[indx]!=0)\\n\\t\\t\\t\\t\\tscol++;  \\n                rows[indx]=0;\\n            }\\n        }\\n        return sum;\\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595325,
                "title": "javascript-time-o-q-space-o-n-3-solutions-8-lines-of-code-in-the-shortest-one",
                "content": "# Approach\\n1. Iterate from the end and Keep track number of rows and number of cols that can be assigned a value.\\n2. Add to answer val * row rest when col operation is performed and add to answer val * col rest when row operation is performed.\\n3. Decrement row rest when row operation is performed and col rest when col operation is performed.\\n\\n# With Arrays\\n```javascript\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [\\n    new Uint8Array(n),\\n    new Uint8Array(n),\\n  ];\\n  const rest = [n, n];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (seen[type][index] === 0) {\\n      seen[type][index] = 1;\\n      ans += rest[1-type] * val;\\n      rest[type]--;\\n    }\\n  }\\n  \\n  return ans;\\n};\\n```\\n# Or shorter with Sets\\n```\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [new Set(), new Set()];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (!seen[type].has(index)) {\\n      seen[type].add(index);\\n      ans += (n-seen[1-type].size) * val;\\n    }\\n  }\\n  \\n  return ans;\\n};\\n\\n```\\n# Or the shortest with Sets and ReduceRight\\n```\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [new Set(), new Set()];\\n  return queries.reduceRight((sum, [type, index, val]) => \\n    !seen[type].has(index)\\n      ? (seen[type].add(index), sum + (n-seen[1-type].size) * val)\\n      : sum\\n  , 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [\\n    new Uint8Array(n),\\n    new Uint8Array(n),\\n  ];\\n  const rest = [n, n];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (seen[type][index] === 0) {\\n      seen[type][index] = 1;\\n      ans += rest[1-type] * val;\\n      rest[type]--;\\n    }\\n  }\\n  \\n  return ans;\\n};\\n```\n```\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [new Set(), new Set()];\\n  let ans = 0;\\n\\n  for (let i = queries.length-1; i >= 0; i--) {\\n    const [type, index, val] = queries[i];\\n    if (!seen[type].has(index)) {\\n      seen[type].add(index);\\n      ans += (n-seen[1-type].size) * val;\\n    }\\n  }\\n  \\n  return ans;\\n};\\n\\n```\n```\\nvar matrixSumQueries = function(n, queries) {\\n  const seen = [new Set(), new Set()];\\n  return queries.reduceRight((sum, [type, index, val]) => \\n    !seen[type].has(index)\\n      ? (seen[type].add(index), sum + (n-seen[1-type].size) * val)\\n      : sum\\n  , 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595324,
                "title": "c-greedy-easy-and-short-solution",
                "content": "# Intuition\\nBy reading problem statement it look simple greedy with optimized brute force problem.\\n\\n# Approach\\n- Start iterating from the end, while keeping track of the count of assignable rows and columns.\\n- When performing a column operation, multiply the value by the remaining number of rows and add it to the answer. When performing a row operation, multiply the value by the remaining number of columns and add it to the answer.\\n- Decrease the count of remaining rows when a row operation is performed, and decrease the count of remaining columns when a column operation is performed.\\n\\n# Complexity\\n- Time complexity: \\n  `O(q)` where q is number of queries.\\n\\n- Space complexity:\\n  `O(n)` where n is number of rows/colums. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& ques) {\\n        vector<int> row(n,0), col(n,0); \\n        int rfill = 0, cfill = 0,ind;\\n        long long val,sum = 0;\\n\\n        for(int i = ques.size()-1; i>=0;--i){\\n            ind = ques[i][1];\\n            val = ques[i][2];\\n            if(ques[i][0] == 0){\\n                if(!row[ind]){\\n                    sum += val * (n-cfill);\\n                    ++rfill;\\n                    row[ind] = val;\\n                }\\n            }else{\\n                if(!col[ind]){\\n                    sum += val * (n-rfill);\\n                    ++cfill;\\n                    col[ind] = val;\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& ques) {\\n        vector<int> row(n,0), col(n,0); \\n        int rfill = 0, cfill = 0,ind;\\n        long long val,sum = 0;\\n\\n        for(int i = ques.size()-1; i>=0;--i){\\n            ind = ques[i][1];\\n            val = ques[i][2];\\n            if(ques[i][0] == 0){\\n                if(!row[ind]){\\n                    sum += val * (n-cfill);\\n                    ++rfill;\\n                    row[ind] = val;\\n                }\\n            }else{\\n                if(!col[ind]){\\n                    sum += val * (n-rfill);\\n                    ++cfill;\\n                    col[ind] = val;\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595239,
                "title": "c-simple-solution",
                "content": "# Intuition\\nWhen we make a column change then all row would get affected similarly if we make a row change then all columns would be affected.\\nNow keeping this in mind we now just have to think how many row or columns are affected and that can be done by storing number of column change and row change in a variable (Here r and c).\\nThen we can easily subtract that amount from our answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int d[n][2];\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            d[i][0]=1;\\n            d[i][1]=1;\\n        }\\n        int r=0,c=0;\\n        int q=queries.size();\\n        for(int i=q-1;i>=0;i--){\\n            if(d[queries[i][1]][queries[i][0]]){\\n            if(queries[i][0]) c++;\\n            else r++;\\n            ans+=(n-(queries[i][0]==0? c:r))*queries[i][2];\\n            d[queries[i][1]][queries[i][0]]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int d[n][2];\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            d[i][0]=1;\\n            d[i][1]=1;\\n        }\\n        int r=0,c=0;\\n        int q=queries.size();\\n        for(int i=q-1;i>=0;i--){\\n            if(d[queries[i][1]][queries[i][0]]){\\n            if(queries[i][0]) c++;\\n            else r++;\\n            ans+=(n-(queries[i][0]==0? c:r))*queries[i][2];\\n            d[queries[i][1]][queries[i][0]]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595237,
                "title": "o-n-solution-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust think this question as if you are trying to color a square paper with different color paint.\\nIn each stroke you color some part of the paper.\\nAfter you are done with painting the only the last paint would be visible.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the above intution we can say that the row or colum which was last changed will be persisted while other will be lost.\\nSo, for each query we need to find how many cells will be remain unchanged after the finaly query.\\nTo achive this we need to maintain two boolean array represting which row or col has been used. Apart from that we need to keep track of how many row or col has been used.\\n\\ntc -> no. of cols used\\ntr-> no. of rows used\\nFor each query : q\\n    Type 1 : val(i) * (n-tc)\\n    Type 2  : val(i) * (n-tr)\\n\\n# Complexity\\n- Time complexity: O( queries.size() )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  \\n\\n- Space complexity: O(n) -> to store the bool array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(),queries.end());\\n        \\n        vector<bool> rcheck(n,false),ccheck(n,false);\\n        long long ans = 0, tr = 0, tc = 0;\\n        for( auto &q : queries ){\\n            int tq = q[0];\\n            if( tq==0 ){\\n                int rn = q[1];\\n                int val = q[2];\\n                \\n                if( rcheck[rn] )\\n                    continue;\\n                \\n                rcheck[rn] = true;\\n                tr++;\\n                ans += val * (n-tc);\\n            }\\n            else {\\n                int cn = q[1];\\n                int val = q[2];\\n                \\n                if( ccheck[cn] )\\n                    continue;\\n                \\n                ccheck[cn] = true;\\n                tc++;\\n                ans += val * (n-tr);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(),queries.end());\\n        \\n        vector<bool> rcheck(n,false),ccheck(n,false);\\n        long long ans = 0, tr = 0, tc = 0;\\n        for( auto &q : queries ){\\n            int tq = q[0];\\n            if( tq==0 ){\\n                int rn = q[1];\\n                int val = q[2];\\n                \\n                if( rcheck[rn] )\\n                    continue;\\n                \\n                rcheck[rn] = true;\\n                tr++;\\n                ans += val * (n-tc);\\n            }\\n            else {\\n                int cn = q[1];\\n                int val = q[2];\\n                \\n                if( ccheck[cn] )\\n                    continue;\\n                \\n                ccheck[cn] = true;\\n                tc++;\\n                ans += val * (n-tr);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595165,
                "title": "easy-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse from backward and add in the ans accordingly..\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        // cd - column done , rd - row done\\n        vector<int> cd (n , 0) , rd(n , 0);\\n        long long ans = 0;\\n        int cnc = 0, cnr = 0;  // cnc-to store the col done count , cnr-to store the row done count \\n        \\n        \\n        for(int i=queries.size()-1 ; i>=0 ; i--){\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(type == 0){\\n                if(rd[idx] == 0){\\n                    ans += (n-cnc)*val;\\n                    rd[idx] = 1;\\n                    cnr++;\\n               }\\n            }\\n            else if(type == 1){\\n               if(cd[idx] == 0){\\n                    ans += (n-cnr)*val;\\n                    cd[idx] = 1;\\n                    cnc++;\\n               }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        // cd - column done , rd - row done\\n        vector<int> cd (n , 0) , rd(n , 0);\\n        long long ans = 0;\\n        int cnc = 0, cnr = 0;  // cnc-to store the col done count , cnr-to store the row done count \\n        \\n        \\n        for(int i=queries.size()-1 ; i>=0 ; i--){\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            if(type == 0){\\n                if(rd[idx] == 0){\\n                    ans += (n-cnc)*val;\\n                    rd[idx] = 1;\\n                    cnr++;\\n               }\\n            }\\n            else if(type == 1){\\n               if(cd[idx] == 0){\\n                    ans += (n-cnr)*val;\\n                    cd[idx] = 1;\\n                    cnc++;\\n               }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595156,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code works based on the intuition that for each query, it checks if a row or column index has been visited before. If it hasn\\'t, it adds the product of the remaining row or column count and the value to the sum. This ensures that the sum considers only the elements that have not been previously accounted for in the visited rows or columns.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses two sets, r and c, to store the row and column indices encountered in the queries.\\n\\nThe queries are reversed to iterate over them in reverse order.\\n\\nA variable ans is initialized to store the sum of matrix elements.\\n\\nThe code iterates over each query, performs row or column operations, and updates the sum accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(q), where q is the number of queries. Since the code iterates over the queries in reverse order, it performs constant time operations for each query. Therefore, the time complexity is linear with respect to the number of queries.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the size of the matrix. This is because the code uses two sets, r and c, to store visited row and column indices. The size of these sets can grow at most up to the number of rows or columns in the matrix.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n    set<int> r, c; // Create two sets to store the row and column indices\\n    reverse(queries.begin(), queries.end()); // Reverse the order of queries\\n    long long ans = 0; // Initialize a variable to store the sum of matrix elements\\n    for(auto it : queries) {\\n        if(it[0] == 0) { // Query type 0: row operation\\n            if(r.find(it[1]) == r.end()) { // If the row index is not present in the set\\n                ans += (n - c.size()) * it[2]; // Add the product of (remaining column count) and the value to the answer\\n                r.insert(it[1]); // Insert the row index into the set\\n            }\\n        }\\n        else { // Query type 1: column operation\\n            if(c.find(it[1]) == c.end()) { // If the column index is not present in the set\\n                ans += (n - r.size()) * it[2]; // Add the product of (remaining row count) and the value to the answer\\n                c.insert(it[1]); // Insert the column index into the set\\n            }\\n        }\\n    }\\n    return ans; // Return the final sum of matrix elements\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n    set<int> r, c; // Create two sets to store the row and column indices\\n    reverse(queries.begin(), queries.end()); // Reverse the order of queries\\n    long long ans = 0; // Initialize a variable to store the sum of matrix elements\\n    for(auto it : queries) {\\n        if(it[0] == 0) { // Query type 0: row operation\\n            if(r.find(it[1]) == r.end()) { // If the row index is not present in the set\\n                ans += (n - c.size()) * it[2]; // Add the product of (remaining column count) and the value to the answer\\n                r.insert(it[1]); // Insert the row index into the set\\n            }\\n        }\\n        else { // Query type 1: column operation\\n            if(c.find(it[1]) == c.end()) { // If the column index is not present in the set\\n                ans += (n - r.size()) * it[2]; // Add the product of (remaining row count) and the value to the answer\\n                c.insert(it[1]); // Insert the column index into the set\\n            }\\n        }\\n    }\\n    return ans; // Return the final sum of matrix elements\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595061,
                "title": "easy-java-fast-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] query) {\\n      int[][] res = new int[n][2];\\n        long answer = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            res[i][0] = 1;\\n            res[i][1] = 1;\\n        }\\n        int cr = 0, cc = 0;\\n\\n        for (int i = query.length - 1; i >= 0; i--) {\\n            if (res[query[i][1]][query[i][0]] != 0) {\\n                if (query[i][0] == 0) {\\n                    cr++;\\n                } else {\\n                    cc++;\\n                }\\n                answer += (n - (query[i][0] == 0 ? cc : cr)) * query[i][2];\\n                res[query[i][1]][query[i][0]] = 0;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] query) {\\n      int[][] res = new int[n][2];\\n        long answer = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            res[i][0] = 1;\\n            res[i][1] = 1;\\n        }\\n        int cr = 0, cc = 0;\\n\\n        for (int i = query.length - 1; i >= 0; i--) {\\n            if (res[query[i][1]][query[i][0]] != 0) {\\n                if (query[i][0] == 0) {\\n                    cr++;\\n                } else {\\n                    cc++;\\n                }\\n                answer += (n - (query[i][0] == 0 ? cc : cr)) * query[i][2];\\n                res[query[i][1]][query[i][0]] = 0;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595052,
                "title": "sum-of-matrix-after-queries-solution-time-complexity-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> rowUsed(n,0);\\n        vector<int> colUsed(n,0);\\n        int countRowsUsed=0,countColsUsed=0;\\n        int sz=queries.size();\\n        long long res=0;\\n        for(int q=sz-1;q>=0;q--){\\n            int type=queries[q][0];\\n            if(type==0){\\n                int rowIdx=queries[q][1];\\n                if(rowUsed[rowIdx]==0){\\n                    rowUsed[rowIdx]=1;\\n                    countRowsUsed++;\\n                    res+=((n-countColsUsed)*queries[q][2]);\\n                }\\n            }\\n            else{\\n                int colIdx=queries[q][1];\\n                if(colUsed[colIdx]==0){\\n                    colUsed[colIdx]=1;\\n                    countColsUsed++;\\n                    res+=((n-countRowsUsed)*queries[q][2]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> rowUsed(n,0);\\n        vector<int> colUsed(n,0);\\n        int countRowsUsed=0,countColsUsed=0;\\n        int sz=queries.size();\\n        long long res=0;\\n        for(int q=sz-1;q>=0;q--){\\n            int type=queries[q][0];\\n            if(type==0){\\n                int rowIdx=queries[q][1];\\n                if(rowUsed[rowIdx]==0){\\n                    rowUsed[rowIdx]=1;\\n                    countRowsUsed++;\\n                    res+=((n-countColsUsed)*queries[q][2]);\\n                }\\n            }\\n            else{\\n                int colIdx=queries[q][1];\\n                if(colUsed[colIdx]==0){\\n                    colUsed[colIdx]=1;\\n                    countColsUsed++;\\n                    res+=((n-countRowsUsed)*queries[q][2]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594955,
                "title": "c-o-queries-size-reverse-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        // int count = 0;\\n        long long sol = 0;\\n        int row = n;\\n        int col = n;\\n        vector<vector<int>>vis(n+1,vector<int>(3,0));\\n       for(int i=queries.size()-1;i>=0;i--)\\n       {\\n           int a = queries[i][0];\\n           int b = queries[i][1];\\n           int c = queries[i][2];\\n           if(vis[b][a])continue;\\n           vis[b][a] = 1;\\n           if(a==1)\\n           {\\n               // cout<<c<<\" \"<<row<<endl;;\\n               sol+=(long long)c*row;\\n               col--;\\n           }\\n           else\\n           {\\n               // cout<<c<<\" \"<<col<<endl;\\n               sol+=(long long)c*col;\\n               row--;\\n               \\n           }\\n       }\\n        return sol;\\n        // vector<vector<int>>ans(n+1,vector<int>(n+1,0));\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         auto x = row[i];\\n        //         auto y = col[j];\\n        //         if(x.first > y.first)\\n        //         {\\n        //             ans[i][j]  = x.second;\\n        //         }\\n        //         else\\n        //         {\\n        //             ans[i][j] = y.second;\\n        //         }\\n        //     }\\n        // }\\n        // long long sol = 0;\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         sol+=(long long)ans[i][j];\\n        //     }\\n        // }\\n        // return sol;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        // int count = 0;\\n        long long sol = 0;\\n        int row = n;\\n        int col = n;\\n        vector<vector<int>>vis(n+1,vector<int>(3,0));\\n       for(int i=queries.size()-1;i>=0;i--)\\n       {\\n           int a = queries[i][0];\\n           int b = queries[i][1];\\n           int c = queries[i][2];\\n           if(vis[b][a])continue;\\n           vis[b][a] = 1;\\n           if(a==1)\\n           {\\n               // cout<<c<<\" \"<<row<<endl;;\\n               sol+=(long long)c*row;\\n               col--;\\n           }\\n           else\\n           {\\n               // cout<<c<<\" \"<<col<<endl;\\n               sol+=(long long)c*col;\\n               row--;\\n               \\n           }\\n       }\\n        return sol;\\n        // vector<vector<int>>ans(n+1,vector<int>(n+1,0));\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         auto x = row[i];\\n        //         auto y = col[j];\\n        //         if(x.first > y.first)\\n        //         {\\n        //             ans[i][j]  = x.second;\\n        //         }\\n        //         else\\n        //         {\\n        //             ans[i][j] = y.second;\\n        //         }\\n        //     }\\n        // }\\n        // long long sol = 0;\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     {\\n        //         sol+=(long long)ans[i][j];\\n        //     }\\n        // }\\n        // return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3594920,
                "title": "c-o-n-solution-without-using-matrix",
                "content": "High level intuition:\\n1. If you traverse the queries in reverse order, once a spot is occupied, it cannot be overtaken by an earlier query.\\n2. Do not use matrices since O(n * n) in this case will exceed the time limit (10^8).\\n3. For each element in the matrix, there is only one row and one column that can mutate it.\\n4. When you fill up a row, all columns will have lost the opportunity to fill up one element. Vice versa for filling up columns.\\n5. Therefore, You can keep a total count of number of elements that can still be filled for all columns (and for all rows).\\n6. Use a visited array for rows and columns to ensure no earlier query can override the values in that row/column.\\n\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> row(n, 1), col(n, 1);\\n        int rowc = n, colc = n;\\n        reverse(queries.begin(), queries.end());\\n        for (auto query : queries) {\\n            auto type = query[0], index = query[1], val = query[2];\\n            if (type == 0 && row[index]) {\\n                ans += rowc * val;\\n                colc -= 1;\\n                row[index] = 0;\\n            } else if (type == 1 && col[index]) {\\n                ans += colc * val;\\n                rowc -= 1;\\n                col[index] = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> row(n, 1), col(n, 1);\\n        int rowc = n, colc = n;\\n        reverse(queries.begin(), queries.end());\\n        for (auto query : queries) {\\n            auto type = query[0], index = query[1], val = query[2];\\n            if (type == 0 && row[index]) {\\n                ans += rowc * val;\\n                colc -= 1;\\n                row[index] = 0;\\n            } else if (type == 1 && col[index]) {\\n                ans += colc * val;\\n                rowc -= 1;\\n                col[index] = 0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594903,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long countRowsChanged = n;\\n        boolean[] rowsChanged = new boolean[n];\\n        long countColsChanged = n;\\n        boolean[] colsChanged = new boolean[n];\\n        long result = 0;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int[] query = queries[i];\\n            int type = query[0];\\n            int index = query[1];\\n            long value =  (long) query[2];\\n            if (type == 0) {\\n                if (rowsChanged[index]) {\\n                    continue;\\n                }\\n                result = result + (long) (countColsChanged * value);\\n                countRowsChanged--;\\n                rowsChanged[index] = true;\\n            } else {\\n                if (colsChanged[index]) {\\n                    continue;\\n                }\\n                result = result + (long) (countRowsChanged * value);\\n                countColsChanged--;\\n                colsChanged[index] = true;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long countRowsChanged = n;\\n        boolean[] rowsChanged = new boolean[n];\\n        long countColsChanged = n;\\n        boolean[] colsChanged = new boolean[n];\\n        long result = 0;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int[] query = queries[i];\\n            int type = query[0];\\n            int index = query[1];\\n            long value =  (long) query[2];\\n            if (type == 0) {\\n                if (rowsChanged[index]) {\\n                    continue;\\n                }\\n                result = result + (long) (countColsChanged * value);\\n                countRowsChanged--;\\n                rowsChanged[index] = true;\\n            } else {\\n                if (colsChanged[index]) {\\n                    continue;\\n                }\\n                result = result + (long) (countRowsChanged * value);\\n                countColsChanged--;\\n                colsChanged[index] = true;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958523,
                "title": "golang-solution",
                "content": "# Code\\n```go\\nfunc matrixSumQueries(n int, queries [][]int) int64 {\\n\\trowFlush, colFlush := make([][2]int, n), make([][2]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\trowFlush[i] = [2]int{-1, 0}\\n\\t\\tcolFlush[i] = [2]int{-1, 0}\\n\\t}\\n\\tfor i, q := range queries {\\n\\t\\tswitch q[0] {\\n\\t\\tcase 0:\\n\\t\\t\\trowFlush[q[1]] = [2]int{i, q[2]}\\n\\t\\tcase 1:\\n\\t\\t\\tcolFlush[q[1]] = [2]int{i, q[2]}\\n\\t\\t}\\n\\t}\\n\\tsummation := 0\\n\\tfor r := 0; r < n; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tif rowFlush[r][0] > colFlush[c][0] {\\n\\t\\t\\t\\tsummation += rowFlush[r][1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsummation += colFlush[c][1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int64(summation)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc matrixSumQueries(n int, queries [][]int) int64 {\\n\\trowFlush, colFlush := make([][2]int, n), make([][2]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\trowFlush[i] = [2]int{-1, 0}\\n\\t\\tcolFlush[i] = [2]int{-1, 0}\\n\\t}\\n\\tfor i, q := range queries {\\n\\t\\tswitch q[0] {\\n\\t\\tcase 0:\\n\\t\\t\\trowFlush[q[1]] = [2]int{i, q[2]}\\n\\t\\tcase 1:\\n\\t\\t\\tcolFlush[q[1]] = [2]int{i, q[2]}\\n\\t\\t}\\n\\t}\\n\\tsummation := 0\\n\\tfor r := 0; r < n; r++ {\\n\\t\\tfor c := 0; c < n; c++ {\\n\\t\\t\\tif rowFlush[r][0] > colFlush[c][0] {\\n\\t\\t\\t\\tsummation += rowFlush[r][1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsummation += colFlush[c][1]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn int64(summation)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913446,
                "title": "keep-track-of-seen-rows-and-cols-beats-96-explanation",
                "content": "\"\"\"\\n        Process queries in reversed order, as the latest queries represent the \\n        most recent changes in the matrix.\\n\\n        Once you encounter an operation on some row/column, \\n        no further operations will affect the values in this row/column. \\n        Keep track of seen rows and columns with a set.\\n\\n        When operating on an unseen row/column, \\n        the number of affected cells is the number of columns/rows you haven\\u2019t previously seen.\\n        \"\"\"\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen_cols = set()\\n        seen_rows = set() \\n        result = 0\\n        for query in queries[::-1]:\\n            typ, index, val = query[:]\\n            if typ and index not in seen_rows:\\n                result+=(val*n) - (len(seen_cols) * val)\\n                seen_rows.add(index)\\n            elif not typ and index not in seen_cols:   \\n                result+=(val*n) - (len(seen_rows)*val)\\n                seen_cols.add(index)\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen_cols = set()\\n        seen_rows = set() \\n        result = 0\\n        for query in queries[::-1]:\\n            typ, index, val = query[:]\\n            if typ and index not in seen_rows:\\n                result+=(val*n) - (len(seen_cols) * val)\\n                seen_rows.add(index)\\n            elif not typ and index not in seen_cols:   \\n                result+=(val*n) - (len(seen_rows)*val)\\n                seen_cols.add(index)\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913371,
                "title": "java-solution-by-hashset",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        HashSet<Integer>row=new HashSet<>();\\n        HashSet<Integer>col=new HashSet<>();\\n        long ans=0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            boolean col1=false;\\n           \\n              if(queries[i][0]==1)col1=true;\\n              if(col1){\\n                  if(!col.contains(queries[i][1])){\\n                      ans+=((n-row.size())*queries[i][2]);\\n                  }\\n                  col.add(queries[i][1]);\\n              }\\n              else{\\n                  if(!row.contains(queries[i][1])){\\n                      ans+=((n-col.size())*queries[i][2]);\\n                  }\\n                  row.add(queries[i][1]);\\n              }\\n              \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        HashSet<Integer>row=new HashSet<>();\\n        HashSet<Integer>col=new HashSet<>();\\n        long ans=0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            boolean col1=false;\\n           \\n              if(queries[i][0]==1)col1=true;\\n              if(col1){\\n                  if(!col.contains(queries[i][1])){\\n                      ans+=((n-row.size())*queries[i][2]);\\n                  }\\n                  col.add(queries[i][1]);\\n              }\\n              else{\\n                  if(!row.contains(queries[i][1])){\\n                      ans+=((n-col.size())*queries[i][2]);\\n                  }\\n                  row.add(queries[i][1]);\\n              }\\n              \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884904,
                "title": "hashmap-and-hashset-implemented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n         int row = n;\\n        int col = n; \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        Set<Integer> unqRow = new HashSet<>();\\n        Set<Integer> unqCol = new HashSet<>();\\n        int len = queries.length - 1; \\n\\n        while (len >= 0) {\\n            int[] arr = queries[len];\\n\\n            if (arr[0] == 1&& !unqCol.contains(arr[1])) { \\n                m.put(arr[2], m.getOrDefault(arr[2], 0) + row);\\n                unqCol.add(arr[1]);\\n                col--;\\n            } \\n            \\n            if(arr[0] == 0&& !unqRow.contains(arr[1])){\\n                m.put(arr[2], m.getOrDefault(arr[2], 0) + col);\\n                unqRow.add(arr[1]);\\n                row--;\\n            }\\n\\n\\n            len--;\\n        }\\n        long total = 0;\\n\\n        for (int key : m.keySet()) { \\n            total +=(long) key * m.get(key);\\n\\n        }\\n      \\n        return total;\\n\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n         int row = n;\\n        int col = n; \\n        HashMap<Integer, Integer> m = new HashMap<>();\\n        Set<Integer> unqRow = new HashSet<>();\\n        Set<Integer> unqCol = new HashSet<>();\\n        int len = queries.length - 1; \\n\\n        while (len >= 0) {\\n            int[] arr = queries[len];\\n\\n            if (arr[0] == 1&& !unqCol.contains(arr[1])) { \\n                m.put(arr[2], m.getOrDefault(arr[2], 0) + row);\\n                unqCol.add(arr[1]);\\n                col--;\\n            } \\n            \\n            if(arr[0] == 0&& !unqRow.contains(arr[1])){\\n                m.put(arr[2], m.getOrDefault(arr[2], 0) + col);\\n                unqRow.add(arr[1]);\\n                row--;\\n            }\\n\\n\\n            len--;\\n        }\\n        long total = 0;\\n\\n        for (int key : m.keySet()) { \\n            total +=(long) key * m.get(key);\\n\\n        }\\n      \\n        return total;\\n\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845332,
                "title": "c-easy-to-understand-clean",
                "content": "# Intuition\\ngoing backwards, until all rows or cols are used up.\\n\\n# Approach\\nkeep track of how many rows and cols have been used up so far.\\nIf one particular row/col is already used, skip.\\n\\n# Complexity\\n- Time complexity:\\nO(N) ( queries length or n)\\n\\n- Space complexity:\\nO(n) two sets to save which row/col have been used. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        unordered_set<int> row, col;\\n        for(int k = queries.size()-1; k>=0 && row.size()<n && col.size()<n; k--) {\\n            vector<int> q = queries[k];\\n            if (q[0] == 0) {\\n                // row insert\\n                auto [_, added] = row.insert(q[1]);\\n                if (added) ans += q[2]*(n-col.size());\\n            } else {\\n                // col insert\\n                auto [_, added] = col.insert(q[1]);\\n                if (added) ans += q[2]*(n-row.size());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        unordered_set<int> row, col;\\n        for(int k = queries.size()-1; k>=0 && row.size()<n && col.size()<n; k--) {\\n            vector<int> q = queries[k];\\n            if (q[0] == 0) {\\n                // row insert\\n                auto [_, added] = row.insert(q[1]);\\n                if (added) ans += q[2]*(n-col.size());\\n            } else {\\n                // col insert\\n                auto [_, added] = col.insert(q[1]);\\n                if (added) ans += q[2]*(n-row.size());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837463,
                "title": "c-reverse-traversal-easy-and-understandable-clean-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nReverse Traversal\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force ( TLE TLE TLE )  also can not declare array \\n\\nReverse Traversal\\n\\n\\n# Complexity\\n- Time complexity: O(q) // q is size of queries\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n.\\n.\\n.\\n.\\n.\\n\\nPlease correct me if I am wrong anywhere or have anyMemoization general suggestions.\\nPlease correct me if I am wrong anywhere or have anyMemoization general suggestions.\\n\\n.\\n.\\n.\\n.\\n.\\n\\n# Code\\n\\nMethod -1 \\n\\n\\n```\\n\\n\\n\\n// //                           \\n// //                           \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// //                             \\n// // //   Time Complexity   = O(n^2)   \\n// //                              \\n// // //   Space Complexity  = O(n^2)   \\n// //                               \\n\\n\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> mat (n, vector<int>(n,0)) ;\\n        long long ans  = 0 ;\\n        int m = queries.size() ;\\n        for(int i=0; i<m; i++)\\n        {\\n            int type = queries[i][0] ;\\n            int ind = queries[i][1] ;\\n            int val = queries[i][2] ;\\n            // ans += n * val ;\\n            if(type==0) for(int j=0; j<n; j++) mat[ind][j] = val;\\n            else if(type==1) for(int k=0; k<n; k++) mat[k][ind] = val;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++) ans += mat[i][j] ;\\n        }\\n        return  ans ;\\n    }\\n};\\n\\n\\n\\n\\n```\\n\\n\\n\\n\\n\\nMethod -2\\n\\n\\n```\\n\\n\\n\\n\\n// //                           \\n// //                           \\n// // //  2nd Method    ======>  Reverse Traversal   \\n// // //  2nd Method    ======>  Reverse Traversal   \\n// // //  2nd Method    ======>  Reverse Traversal  \\n// //                             \\n// // //   Time Complexity   = O(q)    // q is size of queries\\n// //                              \\n// // //   Space Complexity  = O(2*n)  \\n// //                               \\n\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        int q = queries.size() ;\\n        long long ans = 0 ; \\n        vector<int> row(n+5 , 0) ;   \\n        vector<int> col(n+5 , 0) ;  \\n        int row_ct = 0 , col_ct = 0 ; \\n        for(int i=q-1; i>=0; i--)\\n        {\\n            cout<<i<<endl;\\n            int type = queries[i][0] ;\\n            int ind = queries[i][1] ;\\n            int val = queries[i][2] ;\\n            if(type==0 && row[ind]==0 )\\n            {\\n                row[ind] = 1 ;\\n                ans +=  val * 1LL * (n -col_ct) ;\\n                row_ct++ ;\\n            }\\n            else if( type==1 && col[ind]==0)\\n            {\\n                col[ind] = 1 ;\\n                ans +=  val * 1LL * (n -row_ct) ;\\n                col_ct++ ;\\n            }\\n        }\\n        return ans  ; \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\n\\n// //                           \\n// //                           \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// // //  1st Method    ======>    Brute Force ( TLE TLE TLE )  \\n// //                             \\n// // //   Time Complexity   = O(n^2)   \\n// //                              \\n// // //   Space Complexity  = O(n^2)   \\n// //                               \\n\\n\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<vector<int>> mat (n, vector<int>(n,0)) ;\\n        long long ans  = 0 ;\\n        int m = queries.size() ;\\n        for(int i=0; i<m; i++)\\n        {\\n            int type = queries[i][0] ;\\n            int ind = queries[i][1] ;\\n            int val = queries[i][2] ;\\n            // ans += n * val ;\\n            if(type==0) for(int j=0; j<n; j++) mat[ind][j] = val;\\n            else if(type==1) for(int k=0; k<n; k++) mat[k][ind] = val;\\n        }\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++) ans += mat[i][j] ;\\n        }\\n        return  ans ;\\n    }\\n};\\n\\n\\n\\n\\n```\n```\\n\\n\\n\\n\\n// //                           \\n// //                           \\n// // //  2nd Method    ======>  Reverse Traversal   \\n// // //  2nd Method    ======>  Reverse Traversal   \\n// // //  2nd Method    ======>  Reverse Traversal  \\n// //                             \\n// // //   Time Complexity   = O(q)    // q is size of queries\\n// //                              \\n// // //   Space Complexity  = O(2*n)  \\n// //                               \\n\\n\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        int q = queries.size() ;\\n        long long ans = 0 ; \\n        vector<int> row(n+5 , 0) ;   \\n        vector<int> col(n+5 , 0) ;  \\n        int row_ct = 0 , col_ct = 0 ; \\n        for(int i=q-1; i>=0; i--)\\n        {\\n            cout<<i<<endl;\\n            int type = queries[i][0] ;\\n            int ind = queries[i][1] ;\\n            int val = queries[i][2] ;\\n            if(type==0 && row[ind]==0 )\\n            {\\n                row[ind] = 1 ;\\n                ans +=  val * 1LL * (n -col_ct) ;\\n                row_ct++ ;\\n            }\\n            else if( type==1 && col[ind]==0)\\n            {\\n                col[ind] = 1 ;\\n                ans +=  val * 1LL * (n -row_ct) ;\\n                col_ct++ ;\\n            }\\n        }\\n        return ans  ; \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3827106,
                "title": "java-solution-using-reverse-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\u2B55(m), where m = queries.length;\\n\\n- Space complexity:\\n\\u2B55(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowVisited = n;\\n        int colVisited = n;\\n        boolean[] isVisitedRow = new boolean[n];\\n        boolean[] isVisitedCol = new boolean[n];\\n        long sum = 0;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int indx = queries[i][1];\\n            int val = queries[i][2];\\n            if (type == 0 && ! isVisitedRow[indx]) {\\n                sum += colVisited * val;\\n                isVisitedRow[indx] = true;\\n                rowVisited--;\\n            } \\n             if (type == 1 && ! isVisitedCol[indx]) {\\n                sum += rowVisited * val;\\n                isVisitedCol[indx] = true;\\n                colVisited--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int rowVisited = n;\\n        int colVisited = n;\\n        boolean[] isVisitedRow = new boolean[n];\\n        boolean[] isVisitedCol = new boolean[n];\\n        long sum = 0;\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int indx = queries[i][1];\\n            int val = queries[i][2];\\n            if (type == 0 && ! isVisitedRow[indx]) {\\n                sum += colVisited * val;\\n                isVisitedRow[indx] = true;\\n                rowVisited--;\\n            } \\n             if (type == 1 && ! isVisitedCol[indx]) {\\n                sum += rowVisited * val;\\n                isVisitedCol[indx] = true;\\n                colVisited--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824141,
                "title": "traverse-in-reverse-order",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> row(n,0);\\n        vector<int> col(n,0);\\n        long long rowSum = 0;\\n        long long colSum = 0;\\n        long long sum = 0;\\n        for(int i=queries.size()-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            if(type==0){\\n                if(row[index]==0){\\n                    sum += val*(n-colSum);\\n                    row[index]=1;\\n                    rowSum++;\\n                }\\n\\n            }\\n            else{\\n                if(col[index]==0){\\n                    sum += val*(n-rowSum);\\n                    col[index]=1;\\n                    colSum++;\\n                }\\n            }\\n            cout<<sum<<endl;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> row(n,0);\\n        vector<int> col(n,0);\\n        long long rowSum = 0;\\n        long long colSum = 0;\\n        long long sum = 0;\\n        for(int i=queries.size()-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            if(type==0){\\n                if(row[index]==0){\\n                    sum += val*(n-colSum);\\n                    row[index]=1;\\n                    rowSum++;\\n                }\\n\\n            }\\n            else{\\n                if(col[index]==0){\\n                    sum += val*(n-rowSum);\\n                    col[index]=1;\\n                    colSum++;\\n                }\\n            }\\n            cout<<sum<<endl;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3795768,
                "title": "easy-self-explanatory-code",
                "content": "# Intuition\\nThe brute approach was to just follow what the problem statement states as we can see the later a query comes that val has more chances to stay on the matrix.\\n\\n# Approach\\nSo why not just iterate the queries from behind and keep track of num of rows and num of cols to update the ans but what if a row or col that has already been filled comes agaiin so we need to keep track of the already filled rows and cols.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n\\n        int numRowsLeft=n;\\n        int numColsLeft=n;\\n\\n        long long sum=0;\\n        int sz=queries.size();\\n        unordered_set<int> rowsVisited;\\n        unordered_set<int> colsVisited;\\n\\n        for(int i=sz-1;i>=0;i--){\\n            if(queries[i][0]==0 && rowsVisited.find(queries[i][1])==rowsVisited.end()){\\n                numRowsLeft--;\\n                sum+=numColsLeft*queries[i][2];\\n                rowsVisited.insert(queries[i][1]);\\n            }\\n            else if(queries[i][0]==1 && colsVisited.find(queries[i][1])==colsVisited.end()){\\n                numColsLeft--;\\n                sum+=numRowsLeft*queries[i][2];\\n                colsVisited.insert(queries[i][1]);\\n\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n\\n        int numRowsLeft=n;\\n        int numColsLeft=n;\\n\\n        long long sum=0;\\n        int sz=queries.size();\\n        unordered_set<int> rowsVisited;\\n        unordered_set<int> colsVisited;\\n\\n        for(int i=sz-1;i>=0;i--){\\n            if(queries[i][0]==0 && rowsVisited.find(queries[i][1])==rowsVisited.end()){\\n                numRowsLeft--;\\n                sum+=numColsLeft*queries[i][2];\\n                rowsVisited.insert(queries[i][1]);\\n            }\\n            else if(queries[i][0]==1 && colsVisited.find(queries[i][1])==colsVisited.end()){\\n                numColsLeft--;\\n                sum+=numRowsLeft*queries[i][2];\\n                colsVisited.insert(queries[i][1]);\\n\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769505,
                "title": "beats-86-short-fast-and-easy-solution-in-python",
                "content": "# PLEASEEEEEEEEE UPVOTEEEEE \\uD83E\\uDD7A\\uD83D\\uDC9D\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        row=set()\\n        col=set()\\n        ans=0\\n        for i,j,k in queries[::-1]:\\n            if i==0:\\n                if j not in row:\\n                    ans+=(n-len(col))*k\\n                    row.add(j)\\n            if i==1:\\n                if j not in col:\\n                    ans+=(n-len(row))*k\\n                    col.add(j)\\n        return ans\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        row=set()\\n        col=set()\\n        ans=0\\n        for i,j,k in queries[::-1]:\\n            if i==0:\\n                if j not in row:\\n                    ans+=(n-len(col))*k\\n                    row.add(j)\\n            if i==1:\\n                if j not in col:\\n                    ans+=(n-len(row))*k\\n                    col.add(j)\\n        return ans\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743046,
                "title": "beat-100-java-solution-with-explanation",
                "content": "# Intuition\\nEach element in the matrix will only **honor** the last query because the value of an old query will be override by the value of a new query.  Given that said, we will scan queries in reverse order,  like queries[x-1], queries[x-2], ..., queries[1], queries[0].\\n\\nFor each query, we need to find how many elements to override. There are several cases.\\n\\n1. If the row (or col) has already been queried by a later query in time sequence, we will skip this query.\\n2. If the row (or col) is not queries, we have to think about how many elements to override. For row query, the elements to override in the row are the ones that have not been covered by any column query. Same for column query, the elements to override in the column are the ones that have not been covered by row query.\\n\\n\\n# Approach\\n**Define two boolean arrays that represent if a row or column has been queried, and two integers that represent the numbers rows or columns that have not been queried**\\n```\\nboolean[] queriedRow = new boolean[n];\\nboolean[] queriedCol = new boolean[n];\\nint remainingRows = n, remainingCols = n;\\n```\\n\\nFor row query \\n```\\nqueriedRow[row] = true\\nremainingRows--\\n```\\n\\nFor column query, \\n```\\nqueriedCol[col] = true\\nremainingCols--\\n```\\n\\n\\n**Calculate sum for each query**\\n\\nFor row query, \\n```\\nsum += value * remainingCols\\n```\\n\\nFor column query, \\n```\\nsum += value * remainingRows\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(m), m is the length of queries\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        boolean[] queriedRow = new boolean[n];\\n        boolean[] queriedCol = new boolean[n];\\n\\n        long sum = 0;\\n        int remainingRows = n, remainingCols = n;\\n        for (int i = queries.length - 1; i >=0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n            if (type == 0) {\\n                if (queriedRow[index]) {\\n                    continue;\\n                }\\n\\n                sum += (long)(value * remainingCols);\\n                remainingRows --;\\n                queriedRow[index] = true;\\n            } else {\\n                if (queriedCol[index]) {\\n                    continue;\\n                }\\n                \\n                sum += (long)(value * remainingRows);\\n                remainingCols --;\\n                queriedCol[index] = true;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nboolean[] queriedRow = new boolean[n];\\nboolean[] queriedCol = new boolean[n];\\nint remainingRows = n, remainingCols = n;\\n```\n```\\nqueriedRow[row] = true\\nremainingRows--\\n```\n```\\nqueriedCol[col] = true\\nremainingCols--\\n```\n```\\nsum += value * remainingCols\\n```\n```\\nsum += value * remainingRows\\n```\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        boolean[] queriedRow = new boolean[n];\\n        boolean[] queriedCol = new boolean[n];\\n\\n        long sum = 0;\\n        int remainingRows = n, remainingCols = n;\\n        for (int i = queries.length - 1; i >=0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n            if (type == 0) {\\n                if (queriedRow[index]) {\\n                    continue;\\n                }\\n\\n                sum += (long)(value * remainingCols);\\n                remainingRows --;\\n                queriedRow[index] = true;\\n            } else {\\n                if (queriedCol[index]) {\\n                    continue;\\n                }\\n                \\n                sum += (long)(value * remainingRows);\\n                remainingCols --;\\n                queriedCol[index] = true;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735229,
                "title": "c-hash-table-beginner-friendly-clean-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans=0;\\n        long long row=0;\\n        long long column=0;\\n        map<int,int> m0;\\n        map<int,int> m1;\\n\\n        for(int i=queries.size()-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n                if(m0.find(queries[i][1])!=m0.end()){\\n                    continue;\\n                }\\n                ans+=queries[i][2]*(n-column);\\n                m0[queries[i][1]]++;\\n                row++;\\n            }\\n            else{\\n                if(m1.find(queries[i][1])!=m1.end()){\\n                    continue;\\n                }\\n                ans+=queries[i][2]*(n-row);\\n                m1[queries[i][1]]++;\\n                column++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans=0;\\n        long long row=0;\\n        long long column=0;\\n        map<int,int> m0;\\n        map<int,int> m1;\\n\\n        for(int i=queries.size()-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n                if(m0.find(queries[i][1])!=m0.end()){\\n                    continue;\\n                }\\n                ans+=queries[i][2]*(n-column);\\n                m0[queries[i][1]]++;\\n                row++;\\n            }\\n            else{\\n                if(m1.find(queries[i][1])!=m1.end()){\\n                    continue;\\n                }\\n                ans+=queries[i][2]*(n-row);\\n                m1[queries[i][1]]++;\\n                column++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717449,
                "title": "python-micro-optimized-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rows, cols = [0] * (n + 1), [0] * (n + 1) \\n        rows[-1], cols[-1] = n, n# last index stores length of hashset\\n        result = 0\\n        action_for_query = [(rows, cols), (cols, rows)]\\n        for query_type, index, value in reversed(queries):\\n            modified_axis, opposite_axis = action_for_query[query_type]\\n            if modified_axis[index] == 0:\\n                modified_axis[index] = 1 # 1 = used\\n                modified_axis[-1] -= 1 # decrease the count at the last index\\n                result += opposite_axis[-1] * value\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rows, cols = [0] * (n + 1), [0] * (n + 1) \\n        rows[-1], cols[-1] = n, n# last index stores length of hashset\\n        result = 0\\n        action_for_query = [(rows, cols), (cols, rows)]\\n        for query_type, index, value in reversed(queries):\\n            modified_axis, opposite_axis = action_for_query[query_type]\\n            if modified_axis[index] == 0:\\n                modified_axis[index] = 1 # 1 = used\\n                modified_axis[-1] -= 1 # decrease the count at the last index\\n                result += opposite_axis[-1] * value\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717429,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_map<int,bool> rVisit, cVisit;\\n        ll sum=0;\\n\\n        // traverse queries array in reverse order\\n\\n        for(int i=queries.size()-1; i>=0; i--){\\n            if(queries[i][0]==0){\\n                int rowIndex = queries[i][1];\\n                int val = queries[i][2];\\n                if(rVisit[rowIndex]) continue;\\n\\n                ll temp = n-cVisit.size();\\n                sum += temp*val;  \\n                rVisit[rowIndex] = 1;          \\n            }\\n            else{\\n                int colIndex = queries[i][1];\\n                int val = queries[i][2];\\n                if(cVisit[colIndex]) continue;\\n\\n                ll temp = n-rVisit.size();\\n                sum += temp*val;\\n                cVisit[colIndex] = 1;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_map<int,bool> rVisit, cVisit;\\n        ll sum=0;\\n\\n        // traverse queries array in reverse order\\n\\n        for(int i=queries.size()-1; i>=0; i--){\\n            if(queries[i][0]==0){\\n                int rowIndex = queries[i][1];\\n                int val = queries[i][2];\\n                if(rVisit[rowIndex]) continue;\\n\\n                ll temp = n-cVisit.size();\\n                sum += temp*val;  \\n                rVisit[rowIndex] = 1;          \\n            }\\n            else{\\n                int colIndex = queries[i][1];\\n                int val = queries[i][2];\\n                if(cVisit[colIndex]) continue;\\n\\n                ll temp = n-rVisit.size();\\n                sum += temp*val;\\n                cVisit[colIndex] = 1;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717424,
                "title": "simple-python-beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rows, cols = set(i for i in range(n)), set(i for i in range(n))\\n        result = 0\\n        action_for_query = {0: (rows, cols), 1: (cols, rows)}\\n        for query_type, index, value in reversed(queries):\\n            modified_axis, opposite_axis = action_for_query[query_type]\\n            if index in modified_axis:\\n                modified_axis.remove(index)\\n                result += len(opposite_axis) * value\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        rows, cols = set(i for i in range(n)), set(i for i in range(n))\\n        result = 0\\n        action_for_query = {0: (rows, cols), 1: (cols, rows)}\\n        for query_type, index, value in reversed(queries):\\n            modified_axis, opposite_axis = action_for_query[query_type]\\n            if index in modified_axis:\\n                modified_axis.remove(index)\\n                result += len(opposite_axis) * value\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715454,
                "title": "c-traverse-from-end",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(max(n, queries.size()))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long res = 0;\\n        vector<int> col(n, -1), row(n, -1);\\n        int rowCnt = 0, colCnt = 0;\\n        for (int i = queries.size() - 1; i >= 0; -- i) {\\n            if (queries[i][0]) {\\n                if (col[queries[i][1]] == -1) {\\n                    col[queries[i][1]] = queries[i][2];\\n                    res += queries[i][2] * (n - rowCnt);\\n                    ++ colCnt;\\n                }\\n            } else {\\n                if (row[queries[i][1]] == -1) {\\n                    row[queries[i][1]] = queries[i][2];\\n                    res += queries[i][2] * (n - colCnt);\\n                    ++ rowCnt;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long res = 0;\\n        vector<int> col(n, -1), row(n, -1);\\n        int rowCnt = 0, colCnt = 0;\\n        for (int i = queries.size() - 1; i >= 0; -- i) {\\n            if (queries[i][0]) {\\n                if (col[queries[i][1]] == -1) {\\n                    col[queries[i][1]] = queries[i][2];\\n                    res += queries[i][2] * (n - rowCnt);\\n                    ++ colCnt;\\n                }\\n            } else {\\n                if (row[queries[i][1]] == -1) {\\n                    row[queries[i][1]] = queries[i][2];\\n                    res += queries[i][2] * (n - colCnt);\\n                    ++ rowCnt;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704732,
                "title": "sum-of-matrix-after-queries-souvik-hazra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n    ans = 0\\n    # seen[0] := row, seen[1] := col\\n    seen = [[False] * n for _ in range(2)]\\n    # notSet[0] = row, notSet[1] := col\\n    notSet = [n] * 2\\n\\n    # Late queries dominate.\\n    for type, index, val in reversed(queries):\\n      if not seen[type][index]:\\n        ans += val * notSet[type ^ 1]\\n        seen[type][index] = True\\n        notSet[type] -= 1\\n\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n    ans = 0\\n    # seen[0] := row, seen[1] := col\\n    seen = [[False] * n for _ in range(2)]\\n    # notSet[0] = row, notSet[1] := col\\n    notSet = [n] * 2\\n\\n    # Late queries dominate.\\n    for type, index, val in reversed(queries):\\n      if not seen[type][index]:\\n        ans += val * notSet[type ^ 1]\\n        seen[type][index] = True\\n        notSet[type] -= 1\\n\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700314,
                "title": "sum-of-matrix-after-queries-java-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rows=new HashSet<>();\\n        Set<Integer> cols=new HashSet<>();\\n        long sum=0;\\n        for (int i=queries.length-1;i>=0;i--){\\n            int [] q=queries[i];\\n            int type=q[0];\\n            int index=q[1];\\n            int val=q[2];\\n            if (type==0){\\n                if (!rows.contains(index)){\\n                    sum+=(n-cols.size())*val;\\n                    rows.add(index);\\n                }\\n            }else {\\n                if (!cols.contains(index)){\\n                    sum+=(n-rows.size())*val;\\n                    cols.add(index);\\n                }\\n            }\\n        }\\n        return sum;        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rows=new HashSet<>();\\n        Set<Integer> cols=new HashSet<>();\\n        long sum=0;\\n        for (int i=queries.length-1;i>=0;i--){\\n            int [] q=queries[i];\\n            int type=q[0];\\n            int index=q[1];\\n            int val=q[2];\\n            if (type==0){\\n                if (!rows.contains(index)){\\n                    sum+=(n-cols.size())*val;\\n                    rows.add(index);\\n                }\\n            }else {\\n                if (!cols.contains(index)){\\n                    sum+=(n-rows.size())*val;\\n                    cols.add(index);\\n                }\\n            }\\n        }\\n        return sum;        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682382,
                "title": "c-count-number-of-row-and-col-left",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n        long long ans = 0, rowRemain = n, colRemain = n;\\n        for(int i = q.size()-1; i >= 0; --i){\\n            if(q[i][0] == 0 && rowFlag[q[i][1]]) \\n            { ans += colRemain * q[i][2];    \\n            rowFlag[q[i][1]] = 0; \\n            rowRemain--; }\\n            if(q[i][0] == 1 && colFlag[q[i][1]])\\n            { ans += rowRemain * q[i][2];    \\n             colFlag[q[i][1]] = 0;\\n             colRemain--; }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        vector<bool> rowFlag(n, 1), colFlag(n, 1);\\n        long long ans = 0, rowRemain = n, colRemain = n;\\n        for(int i = q.size()-1; i >= 0; --i){\\n            if(q[i][0] == 0 && rowFlag[q[i][1]]) \\n            { ans += colRemain * q[i][2];    \\n            rowFlag[q[i][1]] = 0; \\n            rowRemain--; }\\n            if(q[i][0] == 1 && colFlag[q[i][1]])\\n            { ans += rowRemain * q[i][2];    \\n             colFlag[q[i][1]] = 0;\\n             colRemain--; }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680252,
                "title": "beats-90-o-n-in-time-and-space-neat-and-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int qs = queries.size(), no_of_col = n, no_of_row = n;\\n        long long ans = 0;\\n        vector<bool> row(n,0), col(n,0);\\n     //start iterating queries from the last   \\n        for(int i=qs-1; i>=0; i--)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n                 if(type == 0 && !row[index]) //if previously not changed, then\\n                  {\\n                    row[index] = 1;\\n                    ans += no_of_col*val;\\n                    no_of_row--; //so that we do not change this row again\\n\\n                  }\\n                 if(type == 1 && !col[index]) //if previously not changed, then\\n                  {\\n                    col[index] = 1;\\n                    ans += no_of_row*val;\\n                    no_of_col--; //so that we do not change this col again\\n                  }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int qs = queries.size(), no_of_col = n, no_of_row = n;\\n        long long ans = 0;\\n        vector<bool> row(n,0), col(n,0);\\n     //start iterating queries from the last   \\n        for(int i=qs-1; i>=0; i--)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n                 if(type == 0 && !row[index]) //if previously not changed, then\\n                  {\\n                    row[index] = 1;\\n                    ans += no_of_col*val;\\n                    no_of_row--; //so that we do not change this row again\\n\\n                  }\\n                 if(type == 1 && !col[index]) //if previously not changed, then\\n                  {\\n                    col[index] = 1;\\n                    ans += no_of_row*val;\\n                    no_of_col--; //so that we do not change this col again\\n                  }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678662,
                "title": "readable-python-solution",
                "content": "```\\nclass Solution:    \\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int        \\n        seen_rows, seen_cols = set(), set()\\n        total_sum = 0\\n\\n        for q_type, q_idx, q_val in reversed(queries):\\n            if q_type == 0:  \\n                if q_idx not in seen_rows:\\n                    total_sum += q_val * (n - len(seen_cols))\\n                    seen_rows.add(q_idx)\\n            else:  \\n                if q_idx not in seen_cols:\\n                    total_sum += q_val * (n - len(seen_rows))\\n                    seen_cols.add(q_idx)\\n\\n        return total_sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:    \\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int        \\n        seen_rows, seen_cols = set(), set()\\n        total_sum = 0\\n\\n        for q_type, q_idx, q_val in reversed(queries):\\n            if q_type == 0:  \\n                if q_idx not in seen_rows:\\n                    total_sum += q_val * (n - len(seen_cols))\\n                    seen_rows.add(q_idx)\\n            else:  \\n                if q_idx not in seen_cols:\\n                    total_sum += q_val * (n - len(seen_rows))\\n                    seen_cols.add(q_idx)\\n\\n        return total_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674126,
                "title": "c-solution-by-reverse-traversal-of-given-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(queries.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int m=queries.size();\\n        vector<int> row(n,0), col(n,0);\\n        for(int i=m-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n               if(row[queries[i][1]]==0) row[queries[i][1]]=1;\\n                else queries[i][1]=n;\\n            }\\n            if(queries[i][0]==1){\\n              if(col[queries[i][1]]==0)  col[queries[i][1]]=1;\\n                else queries[i][1]=n;\\n            }\\n        }\\n        \\n        int r=n,c=n;\\n        long long int ans=0;\\n        \\n        for(int i=m-1;i>=0;i--){\\n            int type=queries[i][0];\\n            int ind=queries[i][1];\\n            int val=queries[i][2];\\n            \\n            if(type==0 && ind!=n){\\n                ans+=c*val;\\n                r--;\\n            }\\n            if(type==1 && ind!=n){\\n                ans+=r*val;\\n                c--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int m=queries.size();\\n        vector<int> row(n,0), col(n,0);\\n        for(int i=m-1;i>=0;i--){\\n            if(queries[i][0]==0){\\n               if(row[queries[i][1]]==0) row[queries[i][1]]=1;\\n                else queries[i][1]=n;\\n            }\\n            if(queries[i][0]==1){\\n              if(col[queries[i][1]]==0)  col[queries[i][1]]=1;\\n                else queries[i][1]=n;\\n            }\\n        }\\n        \\n        int r=n,c=n;\\n        long long int ans=0;\\n        \\n        for(int i=m-1;i>=0;i--){\\n            int type=queries[i][0];\\n            int ind=queries[i][1];\\n            int val=queries[i][2];\\n            \\n            if(type==0 && ind!=n){\\n                ans+=c*val;\\n                r--;\\n            }\\n            if(type==1 && ind!=n){\\n                ans+=r*val;\\n                c--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669321,
                "title": "c-map-based-easy-solution-intuitive-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int size = queries.size();\\n        long long sum = 0;\\n        \\n        map<int, bool> markRow;\\n        map<int, bool> markCol; \\n\\n        for(int i=size-1; i>=0; i--){\\n            vector<int> query = queries[i];\\n            bool isCol = (queries[i][0] == 1) ? true : false;\\n            int index  = queries[i][1];\\n            int value = queries[i][2];\\n            if(isCol){\\n                if(markCol.find(index) != markCol.end()){\\n                    continue;\\n                }\\n                else{\\n                    sum += (n - markRow.size()) * value;\\n                    markCol[index] = true;\\n                }\\n\\n            }\\n            else{\\n                if(markRow.find(index) != markRow.end()){\\n                    continue;\\n                }\\n                else{\\n                    sum += (n - markCol.size()) * value;\\n                    markRow[index] = true;\\n                }\\n            }           \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int size = queries.size();\\n        long long sum = 0;\\n        \\n        map<int, bool> markRow;\\n        map<int, bool> markCol; \\n\\n        for(int i=size-1; i>=0; i--){\\n            vector<int> query = queries[i];\\n            bool isCol = (queries[i][0] == 1) ? true : false;\\n            int index  = queries[i][1];\\n            int value = queries[i][2];\\n            if(isCol){\\n                if(markCol.find(index) != markCol.end()){\\n                    continue;\\n                }\\n                else{\\n                    sum += (n - markRow.size()) * value;\\n                    markCol[index] = true;\\n                }\\n\\n            }\\n            else{\\n                if(markRow.find(index) != markRow.end()){\\n                    continue;\\n                }\\n                else{\\n                    sum += (n - markCol.size()) * value;\\n                    markRow[index] = true;\\n                }\\n            }           \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660881,
                "title": "simple-reverse-iteration-new-differernt-approach",
                "content": "[![image](https://assets.leetcode.com/users/images/c531954e-243c-4632-b4db-79a61fc3c981_1687253322.0880413.png)\\n](http://)\\n**MY  FIRST APPROACH GET FAILED AT SOME CASES. ALTHOUGH IT WAS QUITE NEAR TO THE DESIRED SOLUTION.\\nMy intuition was simple, since constraints were high I need to think about some thing in which I\\'m only taking into account rows and colm. Because we cant keep updating array then it would be quite simple question. We need to think somethng different. Since values are keep updating, so it was quite obvious to think the answer from the back **\\n\\nCode for 1st Approach: \\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int N=queries.size();\\n        int row=0;\\n        int colm=0;\\n        for(int i=N-1;i>=0;i--){\\n            \\n            \\n            if(queries[i][0]==0){// row\\n                queries[i].push_back(colm);\\n                row++;\\n            }else{\\n                queries[i].push_back(row);\\n                colm++;\\n            }\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<N;i++){\\n            int k=n-queries[i][3];\\n            int ans=k*queries[i][2];\\n            sum+=ans;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\nI was failed because I did\\'nt take into account that if same row or colm query is asked again.  If that happened then that value will be overwritten and sum will be not be taken into account towards our answer. \\nFor that i created two visited arrays for both row and colm. \\n\\n2nd Approach\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int N=queries.size();\\n        long long row=0;\\n        long long colm=0;\\n        long long sum=0;\\n        map<int,int>mpr,mpc;\\n        for(int i=N-1;i>=0;i--){\\n            \\n            int id=queries[i][1];\\n            \\n            if(queries[i][0]==0 && mpr[id]==0){// row\\n                // queries[i].push_back(colm);\\n                long long k=n-colm;\\n                long long ans=k*queries[i][2];\\n                sum+=ans;\\n                mpr[id]=1;\\n                row++;\\n            }else if(queries[i][0]==1 && mpc[id]==0){\\n                // queries[i].push_back(row);\\n                \\n                long long k=n-row;\\n                long long ans=k*queries[i][2];\\n                sum+=ans;\\n                mpc[id]=1;\\n                colm++;\\n            }\\n        }\\n        \\n       \\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int N=queries.size();\\n        int row=0;\\n        int colm=0;\\n        for(int i=N-1;i>=0;i--){\\n            \\n            \\n            if(queries[i][0]==0){// row\\n                queries[i].push_back(colm);\\n                row++;\\n            }else{\\n                queries[i].push_back(row);\\n                colm++;\\n            }\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<N;i++){\\n            int k=n-queries[i][3];\\n            int ans=k*queries[i][2];\\n            sum+=ans;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int N=queries.size();\\n        long long row=0;\\n        long long colm=0;\\n        long long sum=0;\\n        map<int,int>mpr,mpc;\\n        for(int i=N-1;i>=0;i--){\\n            \\n            int id=queries[i][1];\\n            \\n            if(queries[i][0]==0 && mpr[id]==0){// row\\n                // queries[i].push_back(colm);\\n                long long k=n-colm;\\n                long long ans=k*queries[i][2];\\n                sum+=ans;\\n                mpr[id]=1;\\n                row++;\\n            }else if(queries[i][0]==1 && mpc[id]==0){\\n                // queries[i].push_back(row);\\n                \\n                long long k=n-row;\\n                long long ans=k*queries[i][2];\\n                sum+=ans;\\n                mpc[id]=1;\\n                colm++;\\n            }\\n        }\\n        \\n       \\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651884,
                "title": "easy-linear-time-faster-than-100-reverse-traversal-query",
                "content": "*Approach is being explained at each step and fully explained using Comments.*\\n\\n# Complexity\\n- Time complexity: **O(Queries.size())**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)** \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        long long ans = 0;\\n\\n        // Visited arrays for row and column\\n        vector <int> rowVisited(n,0);\\n        vector <int> colVisited(n,0);\\n\\n        int rowAffectedCnt = 0 ;\\n        int colAffectedCnt = 0 ; \\n\\n        // Traversing in a reverse order of queries as queries at the end / last has a more dominant affect on values \\n\\n        for(int i=queries.size()-1 ; i>=0 ; i--){\\n\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n            // Row operation\\n            if(type == 0){\\n\\n                // not previously affected/changed this row\\n                if(rowVisited[index] == 0){\\n\\n                    rowVisited[index] = 1; // now mark affected or changed\\n\\n                    // No of Changes to be done will be the n - TOTAL previously column which are already affected , since we are not going to change those cells whose column is changed before this current operation on row\\n                    int noOfChanges = n - colAffectedCnt;\\n\\n                    ans += 1ll*val*noOfChanges; // Just add val * noOfChanges\\n\\n                    rowAffectedCnt++; // increment the no. of rows being affected\\n                }\\n\\n                // If any previously affected row is made any changes it will have a no effect\\n\\n            }\\n\\n\\n            // Col operation\\n            else{\\n\\n                // not previously affected this col\\n                if(colVisited[index] == 0){\\n\\n                    colVisited[index] = 1; // not mark affected or changed\\n\\n                    // No of Changes to be done will be the n - TOTAL previously rows which are already affected , since we are not going to change those cells whose rows is changed before this current operation on column\\n\\n                    int noOfChanges = n - rowAffectedCnt;\\n\\n                    ans += 1ll*val*noOfChanges;\\n\\n                    colAffectedCnt++; // increment the no. of cols being affected\\n            \\n                }\\n\\n                // If any previously affected COL is made any changes it will have a no effect\\n\\n            }\\n\\n\\n        }\\n\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```\\n\\n**If you liked the approach , PLEASE UPVOTE ...!**",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        long long ans = 0;\\n\\n        // Visited arrays for row and column\\n        vector <int> rowVisited(n,0);\\n        vector <int> colVisited(n,0);\\n\\n        int rowAffectedCnt = 0 ;\\n        int colAffectedCnt = 0 ; \\n\\n        // Traversing in a reverse order of queries as queries at the end / last has a more dominant affect on values \\n\\n        for(int i=queries.size()-1 ; i>=0 ; i--){\\n\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n            // Row operation\\n            if(type == 0){\\n\\n                // not previously affected/changed this row\\n                if(rowVisited[index] == 0){\\n\\n                    rowVisited[index] = 1; // now mark affected or changed\\n\\n                    // No of Changes to be done will be the n - TOTAL previously column which are already affected , since we are not going to change those cells whose column is changed before this current operation on row\\n                    int noOfChanges = n - colAffectedCnt;\\n\\n                    ans += 1ll*val*noOfChanges; // Just add val * noOfChanges\\n\\n                    rowAffectedCnt++; // increment the no. of rows being affected\\n                }\\n\\n                // If any previously affected row is made any changes it will have a no effect\\n\\n            }\\n\\n\\n            // Col operation\\n            else{\\n\\n                // not previously affected this col\\n                if(colVisited[index] == 0){\\n\\n                    colVisited[index] = 1; // not mark affected or changed\\n\\n                    // No of Changes to be done will be the n - TOTAL previously rows which are already affected , since we are not going to change those cells whose rows is changed before this current operation on column\\n\\n                    int noOfChanges = n - rowAffectedCnt;\\n\\n                    ans += 1ll*val*noOfChanges;\\n\\n                    colAffectedCnt++; // increment the no. of cols being affected\\n            \\n                }\\n\\n                // If any previously affected COL is made any changes it will have a no effect\\n\\n            }\\n\\n\\n        }\\n\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649307,
                "title": "java-reverse-loop",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou will see the set of rows just keep overwriting previous resuls. \\nYou just need to find out the last operation of each cols and rows.\\n\\nKeep in mind:\\nWhen you check cols, the vals in cols will be overwritten by later query of rows, and vice versa. see comment like \"// the value in rows.size() cells is already added.\"\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTC: O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSC: O(N)\\n# Code\\n```\\npublic long matrixSumQueries(int n, int[][] qs) {\\n    Set<Integer> rows = new HashSet<>(), cols = new HashSet<>();\\n    long res = 0;\\n    for (int i = qs.length - 1; i >= 0; i--) {\\n        int[] q = qs[i];\\n        if (q[0] == 0 ) { // rows\\n            // the value in cols.size() cells is already added.\\n            if (rows.add(q[1])) res += q[2] * (n - cols.size());\\n        } else if (cols.add(q[1])) { // cols\\n            // the value in rows.size() cells is already added.\\n            res += q[2] * (n - rows.size());\\n        }\\n        if (rows.size() == n && cols.size() == n) break;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long matrixSumQueries(int n, int[][] qs) {\\n    Set<Integer> rows = new HashSet<>(), cols = new HashSet<>();\\n    long res = 0;\\n    for (int i = qs.length - 1; i >= 0; i--) {\\n        int[] q = qs[i];\\n        if (q[0] == 0 ) { // rows\\n            // the value in cols.size() cells is already added.\\n            if (rows.add(q[1])) res += q[2] * (n - cols.size());\\n        } else if (cols.add(q[1])) { // cols\\n            // the value in rows.size() cells is already added.\\n            res += q[2] * (n - rows.size());\\n        }\\n        if (rows.size() == n && cols.size() == n) break;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642562,
                "title": "latest-updates-only-one-if-block",
                "content": "# Intuition\\n\\n1. The latest update on the any particular row / column dominates the matrix. \\n2. To find the sum effeciently its optimal to consider queries in reverse order.\\n3. Initially let number of columns and rows that are not updated be equal to n.\\n4. If latest query updates cth column for the first time, then it contributes to the sum by **value x activeRows**.\\n5. Query update on the cth column dominates throughout other queries, therefore the number of active columns decreases by 1.\\n6. If latest query updates rth row for the first time, then it contributes to the sum by **value x activeCols**.\\n7. Query update on the rth row dominates throughout other queries, therefore the number of active rows decreases by 1.\\n\\n# Approach (Two IF Blocks)\\n  \\n    if(type == 0) // change row\\n        {\\n                int row = queries[i][1];\\n                if(!rowHash[row]) rowHash[row] = true, (sumOfMatrix += (queries[i][2] * activeCols)), --activeRows;\\n        }\\n     else if(type == 1) // change col\\n        {\\n            int col = queries[i][1]; \\n            if(!colHash[col]) colHash[col] = true, (sumOfMatrix += (queries[i][2] * activeRows)), --activeCols;\\n        }\\n\\n**The above TWO IF BLOCKS can be reduced to a SINGLE IF LINE by making using of 2D array maps.**(See code for its implementation)\\n    \\n# Complexity\\n- Time complexity:  $$0(q)$$\\n\\n- Space complexity: $$0(n)$$\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution \\n{\\n    public:\\n\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    \\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {    \\n        // rowHash[r] = true => row r has been updated by earlier query.\\n        // colHash[c] = true => col c has been updated by earlier query.\\n\\n        vector<vector<bool>> hash(2, vector<bool>(n, false)); // hash[0] = rowHash[0...n-1], hash[1] = colHash[0...n-1]\\n        \\n        vector<int> active(2, n); // active[0] = active_rows, active[1] = active_cols\\n        \\n        int q             = (int) queries.size();\\n        \\n        ll sumOfMatrix    = 0LL;\\n          \\n        for(int i = q - 1; i >= 0; --i)\\n        {\\n            int type = queries[i][0];\\n            \\n            if(!hash[type][queries[i][1]]) (hash[type][queries[i][1]] = true), (sumOfMatrix += (queries[i][2] * active[type ^ 1])), (--active[type]);\\n          \\n        }\\n         \\n        return sumOfMatrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution \\n{\\n    public:\\n\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    \\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {    \\n        // rowHash[r] = true => row r has been updated by earlier query.\\n        // colHash[c] = true => col c has been updated by earlier query.\\n\\n        vector<vector<bool>> hash(2, vector<bool>(n, false)); // hash[0] = rowHash[0...n-1], hash[1] = colHash[0...n-1]\\n        \\n        vector<int> active(2, n); // active[0] = active_rows, active[1] = active_cols\\n        \\n        int q             = (int) queries.size();\\n        \\n        ll sumOfMatrix    = 0LL;\\n          \\n        for(int i = q - 1; i >= 0; --i)\\n        {\\n            int type = queries[i][0];\\n            \\n            if(!hash[type][queries[i][1]]) (hash[type][queries[i][1]] = true), (sumOfMatrix += (queries[i][2] * active[type ^ 1])), (--active[type]);\\n          \\n        }\\n         \\n        return sumOfMatrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639930,
                "title": "simple-reverse-iteration-and-using-maps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        ll sum = 0;\\n        map<int, int> rmp, cmp;// duplicate complete row, col change\\n        int rcnt = 0, ccnt = 0;\\n        for(int i = queries.size()-1;i>=0;i--){\\n            vector<int> e = queries[i];\\n            int t = e[0], rcn = e[1], x = e[2];\\n            if(t == 0){//row set\\n                if(!rmp.count(rcn)){// nhi milna chaiye\\n                    sum += (n-ccnt)*1ll*x;\\n                    rcnt++;\\n                }\\n                rmp[rcn] = x;\\n            }else{// col set\\n                if(!cmp.count(rcn)){// nhi milna chaiye\\n                    sum += (n-rcnt)*1ll*x;\\n                    ccnt++;\\n                }\\n                cmp[rcn] = x;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        ll sum = 0;\\n        map<int, int> rmp, cmp;// duplicate complete row, col change\\n        int rcnt = 0, ccnt = 0;\\n        for(int i = queries.size()-1;i>=0;i--){\\n            vector<int> e = queries[i];\\n            int t = e[0], rcn = e[1], x = e[2];\\n            if(t == 0){//row set\\n                if(!rmp.count(rcn)){// nhi milna chaiye\\n                    sum += (n-ccnt)*1ll*x;\\n                    rcnt++;\\n                }\\n                rmp[rcn] = x;\\n            }else{// col set\\n                if(!cmp.count(rcn)){// nhi milna chaiye\\n                    sum += (n-rcnt)*1ll*x;\\n                    ccnt++;\\n                }\\n                cmp[rcn] = x;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638072,
                "title": "c-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity:  $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) \\n    {\\n        int r = n;\\n        int c = n;\\n        long long int ans = 0;\\n        vector<int> row_vis(n, 0);\\n        vector<int> col_vis(n, 0);\\n        \\n        for(int i=q.size()-1; i>=0; i--)\\n        {\\n            if(q[i][0]==0 && row_vis[q[i][1]]==0){\\n                ans = ans+(c*q[i][2]);\\n                r--;\\n                row_vis[q[i][1]]=1;\\n            }\\n            else if(q[i][0]==1 && col_vis[q[i][1]]==0){\\n                ans = ans+(r*q[i][2]);\\n                c--;\\n                col_vis[q[i][1]]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q) \\n    {\\n        int r = n;\\n        int c = n;\\n        long long int ans = 0;\\n        vector<int> row_vis(n, 0);\\n        vector<int> col_vis(n, 0);\\n        \\n        for(int i=q.size()-1; i>=0; i--)\\n        {\\n            if(q[i][0]==0 && row_vis[q[i][1]]==0){\\n                ans = ans+(c*q[i][2]);\\n                r--;\\n                row_vis[q[i][1]]=1;\\n            }\\n            else if(q[i][0]==1 && col_vis[q[i][1]]==0){\\n                ans = ans+(r*q[i][2]);\\n                c--;\\n                col_vis[q[i][1]]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635954,
                "title": "java-o-n-beats-100-optimal-solution-easy-explanation-beginner-friendly",
                "content": "# Intuition\\nDo we even need to create the matrix ??\\n\\n# Approach\\n**Start from the ending of the queries** because when traversed from back we are **garaunteed that the values wont change** as they are the latest and they would end up in ans. We keep a track of the rows and columns used so we dont use those again. So if a column is used, while adding the values from a row means that it can be added for all the cols except the once already used. so if there are 2 cols already used we cant add those grid cells as they have already been added. \\n\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# PLEASE UPVOTE FOR 100 YEARS OF GOOD LUCK!!!\\n\\n# Code Without Comments Below\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans=0;\\n        int c=n;  //number of columns not used\\n        int r=n;  //number of rows not used \\n        boolean[] row=new boolean[n];     //to track rows used\\n        boolean[] col=new boolean[n];     //to track columns used\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==1){\\n                //column to be used\\n                //check if the index col is used\\n                if(!col[queries[i][1]]){\\n\\n                    col[queries[i][1]]=true;    //make it used true\\n                    ans+=queries[i][2]*r;       //add the value multiplied by the no. of unused rows\\n                    c--;          //decrement value of cols used\\n                }\\n            }else{\\n            //row to be used \\n            //check if the index row is used\\n                    if(!row[queries[i][1]]){\\n                        row[queries[i][1]]=true;    //make it used true\\n                        ans+=queries[i][2]*c;       //add the value multiplied by the no. of unused cols\\n                        r--;                //decrement value of rows used     \\n                    }\\n                }    \\n            //if any rows and cols non used value goes to zero that means we have utilised every cell and need not traverse ahead\\n            if(r==0||c==0){\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n# Code Without Comments\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans=0;\\n        int c=n;  \\n        int r=n;  \\n        boolean[] row=new boolean[n];     \\n        boolean[] col=new boolean[n];\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==1){\\n                if(!col[queries[i][1]]){\\n                    col[queries[i][1]]=true;\\n                    ans+=queries[i][2]*r;\\n                    c--;    \\n                }\\n            }else{\\n                    if(!row[queries[i][1]]){\\n                        row[queries[i][1]]=true;\\n                        ans+=queries[i][2]*c;\\n                        r--;\\n                    }\\n                }    \\n            if(r==0||c==0){\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans=0;\\n        int c=n;  //number of columns not used\\n        int r=n;  //number of rows not used \\n        boolean[] row=new boolean[n];     //to track rows used\\n        boolean[] col=new boolean[n];     //to track columns used\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==1){\\n                //column to be used\\n                //check if the index col is used\\n                if(!col[queries[i][1]]){\\n\\n                    col[queries[i][1]]=true;    //make it used true\\n                    ans+=queries[i][2]*r;       //add the value multiplied by the no. of unused rows\\n                    c--;          //decrement value of cols used\\n                }\\n            }else{\\n            //row to be used \\n            //check if the index row is used\\n                    if(!row[queries[i][1]]){\\n                        row[queries[i][1]]=true;    //make it used true\\n                        ans+=queries[i][2]*c;       //add the value multiplied by the no. of unused cols\\n                        r--;                //decrement value of rows used     \\n                    }\\n                }    \\n            //if any rows and cols non used value goes to zero that means we have utilised every cell and need not traverse ahead\\n            if(r==0||c==0){\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long ans=0;\\n        int c=n;  \\n        int r=n;  \\n        boolean[] row=new boolean[n];     \\n        boolean[] col=new boolean[n];\\n        for(int i=queries.length-1;i>=0;i--){\\n            if(queries[i][0]==1){\\n                if(!col[queries[i][1]]){\\n                    col[queries[i][1]]=true;\\n                    ans+=queries[i][2]*r;\\n                    c--;    \\n                }\\n            }else{\\n                    if(!row[queries[i][1]]){\\n                        row[queries[i][1]]=true;\\n                        ans+=queries[i][2]*c;\\n                        r--;\\n                    }\\n                }    \\n            if(r==0||c==0){\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635692,
                "title": "python-runtime-o-n-memory-o-n",
                "content": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = rowCovered = colCovered = 0\\n        row = [0]*n\\n        col = [0]*n\\n        \\n        for j in range(len(queries)-1, -1, -1):\\n            t, i, v = queries[j]\\n            if t == 0:\\n                if row[i] == 0:\\n                    rowCovered += 1\\n                    ans += (n - colCovered)*v\\n                    row[i] = 1\\n            else:\\n                if col[i] == 0:\\n                    colCovered += 1\\n                    ans += (n - rowCovered)*v\\n                    col[i] = 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = rowCovered = colCovered = 0\\n        row = [0]*n\\n        col = [0]*n\\n        \\n        for j in range(len(queries)-1, -1, -1):\\n            t, i, v = queries[j]\\n            if t == 0:\\n                if row[i] == 0:\\n                    rowCovered += 1\\n                    ans += (n - colCovered)*v\\n                    row[i] = 1\\n            else:\\n                if col[i] == 0:\\n                    colCovered += 1\\n                    ans += (n - rowCovered)*v\\n                    col[i] = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634975,
                "title": "c-reverse-iterative-row-col-hashmap-solution",
                "content": "# Intuition\\nIn order to compute the sum after the queries, we need to simulate some part of performing the queries. However, actually holding a large 2D array can be very memory-intensive.\\n\\nEach query overwrites the values in a row or col. That means, after a bunch of overlapping queries, only the most recent would be visible. Therefore, we should iterate backwards through the queries and keep track of which row and col indexes have already been filled.\\n\\n# Approach\\nMake a long to hold the final sum and two hashsets to keep track of the row and col indexes we have filled.\\n\\nIterate through each query backwards and get their type, index, and value. Based on the type, decide which set to fill and which set to compare against. If the set to fill does not contain our current index, add to our sum the query\\'s val * (n - the size of the comparison set).\\n\\n**Explanation**\\n\\nAs we iterate backwards, we want to simulate filling in rows and columns that have not been filled yet. This algorithm first checks if we\\'ve already filled the entire target row/col index. If so, we can\\'t fill anything here so we skip it. If it hasn\\'t been filled, then we check how many values have been filled in the comparison set. We can use this to determine how many blank row/col values we can fill using the query\\'s value.\\n\\nFor example, if the matrix is size 10 and we want to fill row 2 with the value 5, we\\'ll first check to make sure that row 2 has not been filled (since that means we can\\'t put anything here). Then, we check how many cols have been filled. Let\\'s say 6 have been filled. Since 6 cols have been filled, we can still fill 4 (10 - 6) row spaces with our value 5. 4 spaces * 5 value = 20 added to the sum. Then we make sure to mark row 2 as filled.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - We do constant-time operations for each query.\\n\\n- Space complexity:\\n$$O(n)$$ - In the worst case scenario, both hashsets will be filled with n integers.\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public long MatrixSumQueries(int n, int[][] queries)\\n    {\\n        long sum = 0;\\n        HashSet<int> filledRows = new HashSet<int>();\\n        HashSet<int> filledCols = new HashSet<int>();\\n\\n        for (int i = queries.Length - 1; i >= 0; --i)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n            var setToFill = (type == 0) ? filledRows : filledCols;\\n            var setToCompare = (type == 0) ? filledCols : filledRows;\\n            \\n            if (!setToFill.Contains(index))\\n            {\\n                sum += (val * (n - setToCompare.Count));\\n                setToFill.Add(index);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long MatrixSumQueries(int n, int[][] queries)\\n    {\\n        long sum = 0;\\n        HashSet<int> filledRows = new HashSet<int>();\\n        HashSet<int> filledCols = new HashSet<int>();\\n\\n        for (int i = queries.Length - 1; i >= 0; --i)\\n        {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n\\n            var setToFill = (type == 0) ? filledRows : filledCols;\\n            var setToCompare = (type == 0) ? filledCols : filledRows;\\n            \\n            if (!setToFill.Contains(index))\\n            {\\n                sum += (val * (n - setToCompare.Count));\\n                setToFill.Add(index);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630780,
                "title": "python-thinking-process",
                "content": "This reminds me 2D version of https://leetcode.com/problems/stamping-the-sequence/ \\n\\n1. A few observations from constraints:\\nYou can\\'t just fill out rows/cols for each query and even if you, then you still need to calc the grid\\'s sum.\\nWhich will be `10^4^2`. Maybe TLE. Maybe not.\\nSo we need something that is `O(1)` to calculate the matrix\\'s sum :/\\n\\nThat was brute-force analysis :/\\n\\nWhat can we do to optimize it??? Not much, throw it away.\\n\\n2. Observations from provided examples:\\nThe key to success is to draw a few examples and analyze what\\'s going on.\\n**The vizualization is the key:**\\n![image](https://assets.leetcode.com/users/images/48f16c0c-8362-4147-b4bd-30a6fb9674cf_1686613341.355105.png)\\nWhat do we see here?\\nEach query overrides an existing `column` or `row`.\\n`1` is the solid and **goes across the grid**.\\n`2` is **the solid** and goes across the grid. It\\'s now **the only** solid line that goes across the trid.\\nit overrides `1` in the intersection part.\\n`3` is **the solid** and goes across the grid. It\\'s now **the only** solid line that goes across the trid.\\nit overrides `2` in the intersection part.\\nThis is the interesting part:\\n`4` is **the solid** and goes across the grid. It\\'s now **the only** solid line that goes across the trid.\\nit overrides `1` **AND** `3` in the 2 intersection parts.\\n\\nWhat can we conclude from this process?\\n1. the last query\\'s line is the only line that has all n values\\n2. as soon as the previous line meets some intersections on `rows` or `cols` (actually for `rows` it intersects with `cols` and the opposite) the number of intersections is the number of overriden values by the next line.\\n\\nSo it makes sense to go backward fom the last query to the first one and count number of cells that are left not overriden by the next line:\\n`4` has all cells not overriden\\n`4` overrides 1 cell from `3` line\\n`3` is overriden by `4` and overrides 1 cell from `2` line\\n`2` is overriden by `3` and overrides 1 cell from `1` line\\n!!! `1` is overriden by `2` and `4` lines\\n\\nLook at the image above again.\\n\\nSo each time we travel back we need to count number of intersections with the already present lines (`rows` or `cols`).\\n\\n`4` has 0 intersections -> `+(N - 0) * val`\\n`3` has 1 intersection with `4` -> `+(N - 1) * val`\\n`2` has 1 intersection with `3` -> `+(N - 1) * val`\\n`1` has 2 intersection with `1` and `4` -> `+(N - 2) * val`\\n\\nAnd don\\'t forget that you cannot **count** the same line multiple times during traversal!!!\\n\\n```\\nclass Solution:\\n    def matrixSumQueries(self, N: int, queries: List[List[int]]) -> int:\\n        used_r = set()\\n        used_c = set()\\n        # t = 0 - row, 1 - column\\n        count = 0\\n        for t, i, v in reversed(queries):\\n            if t == 0:\\n                if i not in used_r:\\n                    count += (N - len(used_c)) * v\\n                    used_r.add(i)\\n            else:\\n                if i not in used_c:\\n                    count += (N - len(used_r)) * v\\n                    used_c.add(i)\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, N: int, queries: List[List[int]]) -> int:\\n        used_r = set()\\n        used_c = set()\\n        # t = 0 - row, 1 - column\\n        count = 0\\n        for t, i, v in reversed(queries):\\n            if t == 0:\\n                if i not in used_r:\\n                    count += (N - len(used_c)) * v\\n                    used_r.add(i)\\n            else:\\n                if i not in used_c:\\n                    count += (N - len(used_r)) * v\\n                    used_c.add(i)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627219,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        summ = 0\\n        rows = set()\\n        cols = set()\\n\\n        for x in queries[::-1]:\\n            if x[1] not in (cols if x[0] else rows):\\n                summ += (n-len(rows if x[0] else cols))*x[2]\\n                (cols if x[0] else rows).add(x[1])\\n        \\n        return summ\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        summ = 0\\n        rows = set()\\n        cols = set()\\n\\n        for x in queries[::-1]:\\n            if x[1] not in (cols if x[0] else rows):\\n                summ += (n-len(rows if x[0] else cols))*x[2]\\n                (cols if x[0] else rows).add(x[1])\\n        \\n        return summ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626573,
                "title": "simple-approach-detailed-explanation-o-n-time-complexity",
                "content": "# Intuition\\nClassic problem of how to solve 2D array problem with large constraint. Make another row and column array, 1D, to store the result of row and column in O(N).\\nThe very initial observation that the queries at last will not get updated. And if for any row the query is already dealt we need not update it again. \\n\\n# Approach\\nThe apprach was to make 2 new matrix of name row and col.\\nNow traverse the queries matrix from the last.\\nThe values palced at the last will not be changed. So we move in the same fashion.\\nAgain if query type is 1 we place the value in column and decrease the row number by one. \\nSimilarly for type 0.\\nWe also make sure that once a row is traversed it\\'s not traversed again. So we place a check for that purpose.\\nYou will get more clarity of the concept and how it is done by dry run of the code.\\nThank You.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) + O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size()-1;\\n        int row[n], col[n];\\n        for(int i=0;i<n;i++) {\\n            row[i] = i;\\n            col[i] = i;\\n        }\\n        int r = n, c = n;\\n        long long ans = 0;\\n        for(int i=m;i>=0;i--) {\\n            if(queries[i][0] == 1) {\\n                if(col[queries[i][1]] != -1) {\\n                    col[queries[i][1]] = -1;\\n                    ans += queries[i][2] * c;\\n                    r--;\\n                }\\n            }\\n            else {\\n                if(row[queries[i][1]] != -1) {\\n                    row[queries[i][1]] = -1;\\n                    ans += queries[i][2] * r;\\n                    c--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size()-1;\\n        int row[n], col[n];\\n        for(int i=0;i<n;i++) {\\n            row[i] = i;\\n            col[i] = i;\\n        }\\n        int r = n, c = n;\\n        long long ans = 0;\\n        for(int i=m;i>=0;i--) {\\n            if(queries[i][0] == 1) {\\n                if(col[queries[i][1]] != -1) {\\n                    col[queries[i][1]] = -1;\\n                    ans += queries[i][2] * c;\\n                    r--;\\n                }\\n            }\\n            else {\\n                if(row[queries[i][1]] != -1) {\\n                    row[queries[i][1]] = -1;\\n                    ans += queries[i][2] * r;\\n                    c--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625193,
                "title": "simple-approach-c-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Approach is very Simple ,that For every Row and column. Start from last Queries , because Last value comes n times in the matrix . \\n\\nCreate two variable rowCount and ColCount,It will track the count, that How much Time need to add that value in sum. \\n\\nTo Make sure that the Final operation on any Row/column Not get lost, and not get changed,So, Can create a Visted array for both row and columns.\\n\\n# Complexity\\n- Time complexity:\\n\\nHere Time Complexity is O(m), Where m is the length of queries \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nTwo array are Created for Tracking the attemp on that particular row and column. Hence O(2n) ,Here n is the number of rows/columns\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int rwCount=n; \\n        int clCount=n; \\n        \\n        int m=queries.size();\\n        int i=m-1; \\n        \\n        vector<bool> rows(n, false); \\n        vector<bool> cols(n, false);\\n        \\n        long long int sum=0;\\n        while(i>=0 )\\n        {\\n          if(queries[i][0]==0 && rwCount!=0 && !rows[queries[i][1]]){ // that means it is Row; \\n          sum+=(queries[i][2]*rwCount);\\n              rows[queries[i][1]]=true;\\n              clCount--;\\n          }\\n          else if(queries[i][0]==1 && clCount!=0 && !cols[queries[i][1]])\\n          {\\n              cols[queries[i][1]]=true; \\n              sum+=(queries[i][2]*clCount);\\n              rwCount--;\\n          }\\n            i--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        \\n        int rwCount=n; \\n        int clCount=n; \\n        \\n        int m=queries.size();\\n        int i=m-1; \\n        \\n        vector<bool> rows(n, false); \\n        vector<bool> cols(n, false);\\n        \\n        long long int sum=0;\\n        while(i>=0 )\\n        {\\n          if(queries[i][0]==0 && rwCount!=0 && !rows[queries[i][1]]){ // that means it is Row; \\n          sum+=(queries[i][2]*rwCount);\\n              rows[queries[i][1]]=true;\\n              clCount--;\\n          }\\n          else if(queries[i][0]==1 && clCount!=0 && !cols[queries[i][1]])\\n          {\\n              cols[queries[i][1]]=true; \\n              sum+=(queries[i][2]*clCount);\\n              rwCount--;\\n          }\\n            i--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624816,
                "title": "reverse-engineering-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs each query is overwriting and we are aiming at final result, its better traversing from backwards i.e from the last query to first query because whatever may be the begninnig query\\'s functionality will we focus on ultimate query\\'s impact hence move on removing each strip from the matrix and saving the sum at each step.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhenever already visited row or column is appeared we should not consider any operation as the same row/col is already overwritten completely and we donot at all bother about the previous value.\\n# Complexity\\n- Time complexity:  $O(Queries.length)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rowVisited = new HashSet<>();\\n        Set<Integer> colVisited = new HashSet<>();\\n        long sum = 0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            int[] q = queries[i];\\n            int type = q[0];\\n            int index = q[1];\\n            int val = q[2];\\n            if(type==0){\\n                if(!rowVisited.contains(index)){\\n                    sum += (n-colVisited.size())*val;\\n                    rowVisited.add(index);\\n                }\\n            }else{\\n                if(!colVisited.contains(index)){\\n                    sum += (n-rowVisited.size())*val;\\n                    colVisited.add(index);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rowVisited = new HashSet<>();\\n        Set<Integer> colVisited = new HashSet<>();\\n        long sum = 0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            int[] q = queries[i];\\n            int type = q[0];\\n            int index = q[1];\\n            int val = q[2];\\n            if(type==0){\\n                if(!rowVisited.contains(index)){\\n                    sum += (n-colVisited.size())*val;\\n                    rowVisited.add(index);\\n                }\\n            }else{\\n                if(!colVisited.contains(index)){\\n                    sum += (n-rowVisited.size())*val;\\n                    colVisited.add(index);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621675,
                "title": "backwards-mind",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust think backwards, do it like keeping wooden plank over a wooden plank. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> done(n, vector<int>(2, 0));\\n        long long ans = 0;\\n        vector<int> additionalIndexes(2, n);\\n        for(int i = queries.size() -1; i >= 0; i--){\\n            int type = queries[i][0], index = queries[i][1], value = queries[i][2];\\n            if(!done[index][type]){\\n                done[index][type] = 1;\\n                ans += value*additionalIndexes[!type];\\n                additionalIndexes[type]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        vector<vector<int>> done(n, vector<int>(2, 0));\\n        long long ans = 0;\\n        vector<int> additionalIndexes(2, n);\\n        for(int i = queries.size() -1; i >= 0; i--){\\n            int type = queries[i][0], index = queries[i][1], value = queries[i][2];\\n            if(!done[index][type]){\\n                done[index][type] = 1;\\n                ans += value*additionalIndexes[!type];\\n                additionalIndexes[type]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621352,
                "title": "easy-solution-using-row-and-column-matrix-and-counter-variable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        int q_size=q.size();\\n\\n        int row=0, col=0;\\n\\n        long long sum=0;\\n\\n        vector<bool> rowArray(n,false);\\n        vector<bool> colArray(n,false);\\n\\n        for(int i=q.size()-1; i>=0; i--)\\n        {\\n\\n            int check=q[i][0];\\n            int val=q[i][2];\\n            int idx=q[i][1];\\n\\n            //row\\n            if(check==0 && rowArray[idx]==false)\\n            {\\n                rowArray[idx]=true;\\n                sum+=val*(n-col);\\n                row++;\\n            }\\n            //column\\n            else if(check==1 && colArray[idx]==false)\\n            {\\n                colArray[idx]=true;\\n                sum+=val*(n-row);\\n                col++;\\n            }   \\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n \\n    long long matrixSumQueries(int n, vector<vector<int>>& q) {\\n        \\n        int q_size=q.size();\\n\\n        int row=0, col=0;\\n\\n        long long sum=0;\\n\\n        vector<bool> rowArray(n,false);\\n        vector<bool> colArray(n,false);\\n\\n        for(int i=q.size()-1; i>=0; i--)\\n        {\\n\\n            int check=q[i][0];\\n            int val=q[i][2];\\n            int idx=q[i][1];\\n\\n            //row\\n            if(check==0 && rowArray[idx]==false)\\n            {\\n                rowArray[idx]=true;\\n                sum+=val*(n-col);\\n                row++;\\n            }\\n            //column\\n            else if(check==1 && colArray[idx]==false)\\n            {\\n                colArray[idx]=true;\\n                sum+=val*(n-row);\\n                col++;\\n            }   \\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620886,
                "title": "c-concise-o-n-solution",
                "content": "\\nKeep track of the rows and columns being set. \\nTraverse from right to left as the right side changes will overwrite the left side changes.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) - To keep track of rows/columns already set previously.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        int row = n, col = n;\\n        vector<bool> row_visited(n, false);\\n        vector<bool> col_visited(n, false);\\n        for (vector<vector<int>>::reverse_iterator it = queries.rbegin(); it != queries.rend(); it++) {\\n            int type = (*it)[0];\\n            int index = (*it)[1];\\n            int val = (*it)[2];\\n            if (type == 0) {\\n                if (row_visited[index] == false) {\\n                    row_visited[index] = true;\\n                    sum+=(col)*val;\\n                    row--;\\n                }\\n            } else {\\n                if (col_visited[index] == false) {\\n                    col_visited[index] = true;\\n                    sum+=(row)*val;\\n                    col--;\\n                }\\n            }\\n        }\\n        return sum;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        int row = n, col = n;\\n        vector<bool> row_visited(n, false);\\n        vector<bool> col_visited(n, false);\\n        for (vector<vector<int>>::reverse_iterator it = queries.rbegin(); it != queries.rend(); it++) {\\n            int type = (*it)[0];\\n            int index = (*it)[1];\\n            int val = (*it)[2];\\n            if (type == 0) {\\n                if (row_visited[index] == false) {\\n                    row_visited[index] = true;\\n                    sum+=(col)*val;\\n                    row--;\\n                }\\n            } else {\\n                if (col_visited[index] == false) {\\n                    col_visited[index] = true;\\n                    sum+=(row)*val;\\n                    col--;\\n                }\\n            }\\n        }\\n        return sum;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619811,
                "title": "python3-solution-using-hash-set-time-and-space-optimized",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was to create a 0-filled n x n matrix and then use a nested for loop to update the rows and columns of the matrix. And thereafter loop through the rows of the matrix to find the total sum. However, I ran into TLE error as this Brute Force approach could not handle the extreme cases.\\nThen, I looked again and saw the hints provided:\\n1. Process queries in reversed order, as the latest queries represent the most recent changes in the matrix.\\n2. Once you encounter an operation on some row/column, no further operations will affect the values in this row/column. Keep track of seen rows and columns with a set.\\n3. When operating on an unseen row/column, the number of affected cells is the number of columns/rows you haven\\u2019t previously seen.\\n\\nSince the latest queries represent the most recent changes in the matrix. Now, instead of a 2D matrix, I set up two hash sets to track both the visited row and column indices and avoid changing them again. I also, set up a counter and initiated it to 0 to cumulatively compute the integer sum as I looped through the queries.\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the size of the queries\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, where n is the length of the matrix\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        visited_rows = set()\\n        visited_cols = set()\\n\\n        total_sum = 0\\n\\n        for query_type, index, value in reversed(queries):\\n\\n            if query_type == 0:\\n                if index not in visited_rows:\\n                    visited_rows.add(index)\\n                    total_sum += (n - len(visited_cols)) * value\\n            elif query_type == 1:\\n                if index not in visited_cols:\\n                    visited_cols.add(index)\\n                    total_sum += (n - len(visited_rows)) * value\\n\\n        return total_sum\\n\\n    # Time complexity: O(n), where n is the size of the queries\\n    # Space complexity: $$O(n)$$, where n is the length of the matrix\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        visited_rows = set()\\n        visited_cols = set()\\n\\n        total_sum = 0\\n\\n        for query_type, index, value in reversed(queries):\\n\\n            if query_type == 0:\\n                if index not in visited_rows:\\n                    visited_rows.add(index)\\n                    total_sum += (n - len(visited_cols)) * value\\n            elif query_type == 1:\\n                if index not in visited_cols:\\n                    visited_cols.add(index)\\n                    total_sum += (n - len(visited_rows)) * value\\n\\n        return total_sum\\n\\n    # Time complexity: O(n), where n is the size of the queries\\n    # Space complexity: $$O(n)$$, where n is the length of the matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617929,
                "title": "iterate-from-reverse-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate from reverse over queries. keep track of rows and columns(usually consider map or set) you have visited if they appear again simply ignore these queries.\\nAnd calculation for query 0 is sum += value*(n-cols.size()),\\nAnd calculation for query 1 is sum += value*(n-rows.size()),\\n\\n\\n# Complexity\\n- Time complexity:$$O(q*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(), queries.end());\\n        long long sum = 0;\\n        set<int> rows,cols;\\n        for(auto q : queries){\\n            int query = q[0];\\n            int indx = q[1];\\n            int value = q[2];\\n            \\n            if(query==0){\\n                if(rows.count(indx)) continue;\\n                sum += value*(n-cols.size());\\n                rows.insert(indx);\\n            }\\n            else{\\n                if(cols.count(indx)) continue;\\n                sum += value*(n-rows.size());\\n                cols.insert(indx);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        reverse(queries.begin(), queries.end());\\n        long long sum = 0;\\n        set<int> rows,cols;\\n        for(auto q : queries){\\n            int query = q[0];\\n            int indx = q[1];\\n            int value = q[2];\\n            \\n            if(query==0){\\n                if(rows.count(indx)) continue;\\n                sum += value*(n-cols.size());\\n                rows.insert(indx);\\n            }\\n            else{\\n                if(cols.count(indx)) continue;\\n                sum += value*(n-rows.size());\\n                cols.insert(indx);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617834,
                "title": "sum-of-matrix-after-queries-with-o-q-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI got this idea from \"Hint\", start taking queries from reverse so if a row/column is changed the it should not be affected in further iterations as the latest queries represent the most recent changes in the matrix\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf a whole column is changed then one element of a row is affected similarly if a row is chnaged then one element of a column is affected. So we need to keep track of how many rows and columns are affected. So everytime a whole row/column is changed it reduces one element from each column/row. We can just multiply the the number i.e queries[i][2] with the no.of rows/columns that are not not affected to get the value we need to add to the sum for each query.\\n\\n# Complexity\\n- Time complexity:$$O(q)$$\\nq -> queries.length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n\\n        long sum = 0;\\n\\n        int cols_not_affected = n, rows_not_affected = n;\\n        boolean[] cols_affected = new boolean[n], rows_affected = new boolean[n];\\n\\n        for(int i=0; i<n; ++i){\\n            cols_affected[i]=false;\\n            rows_affected[i]=false;\\n        }\\n\\n        for(int i=queries.length-1; i>-1; --i){\\n            if(queries[i][0]==0){\\n                if(!rows_affected[queries[i][1]]){\\n                    rows_affected[queries[i][1]]=true;\\n                    rows_not_affected-=1;\\n                    sum += (cols_not_affected*queries[i][2]);\\n                }\\n            } else {\\n                if(!cols_affected[queries[i][1]]){\\n                    cols_affected[queries[i][1]]=true;\\n                    cols_not_affected-=1;\\n                    sum += (rows_not_affected*queries[i][2]);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n\\n        long sum = 0;\\n\\n        int cols_not_affected = n, rows_not_affected = n;\\n        boolean[] cols_affected = new boolean[n], rows_affected = new boolean[n];\\n\\n        for(int i=0; i<n; ++i){\\n            cols_affected[i]=false;\\n            rows_affected[i]=false;\\n        }\\n\\n        for(int i=queries.length-1; i>-1; --i){\\n            if(queries[i][0]==0){\\n                if(!rows_affected[queries[i][1]]){\\n                    rows_affected[queries[i][1]]=true;\\n                    rows_not_affected-=1;\\n                    sum += (cols_not_affected*queries[i][2]);\\n                }\\n            } else {\\n                if(!cols_affected[queries[i][1]]){\\n                    cols_affected[queries[i][1]]=true;\\n                    cols_not_affected-=1;\\n                    sum += (rows_not_affected*queries[i][2]);\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617733,
                "title": "ruby",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer} n\\n# @param {Integer[][]} queries\\n# @return {Integer}\\ndef matrix_sum_queries(n, queries)  \\n  sum = 0  \\n  row_count = 0 \\n  col_count = 0 \\n  length = queries.length\\n  row_seen = Array.new(n)\\n  col_seen = Array.new(n)\\n  \\n  for i in ((length-1).downto(0)) do \\n    query = queries[i]\\n\\n    if query[0] == 0 and !row_seen[query[1]]\\n        row_count += 1\\n        sum += (n-col_count)*query[2]\\n        row_seen[query[1]] = true \\n    elsif query[0] == 1 and !col_seen[query[1]]\\n        col_count += 1\\n        sum += (n-row_count)*query[2]\\n        col_seen[query[1]] = true \\n    end \\n\\n  end \\n  \\n  sum \\n  \\nend \\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @param {Integer[][]} queries\\n# @return {Integer}\\ndef matrix_sum_queries(n, queries)  \\n  sum = 0  \\n  row_count = 0 \\n  col_count = 0 \\n  length = queries.length\\n  row_seen = Array.new(n)\\n  col_seen = Array.new(n)\\n  \\n  for i in ((length-1).downto(0)) do \\n    query = queries[i]\\n\\n    if query[0] == 0 and !row_seen[query[1]]\\n        row_count += 1\\n        sum += (n-col_count)*query[2]\\n        row_seen[query[1]] = true \\n    elsif query[0] == 1 and !col_seen[query[1]]\\n        col_count += 1\\n        sum += (n-row_count)*query[2]\\n        col_seen[query[1]] = true \\n    end \\n\\n  end \\n  \\n  sum \\n  \\nend \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3617554,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlast query overwrites everything.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate from the last query and reduce the number of rows and columns which can be later considered in the sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> row(n,-1);\\n        vector<int> col(n,-1);\\n        int r = n,c = n;\\n        for(int i = queries.size()-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int rc = queries[i][1];\\n            int val = queries[i][2];\\n            if(type == 0){\\n                if(row[rc] == -1){\\n                    ans+=(c*val);\\n                    row[rc] = 1;\\n                    r--;\\n                }\\n            }\\n            else{\\n                if(col[rc] == -1){\\n                    ans+=(r*val);\\n                    col[rc] = 1;\\n                    c--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> row(n,-1);\\n        vector<int> col(n,-1);\\n        int r = n,c = n;\\n        for(int i = queries.size()-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int rc = queries[i][1];\\n            int val = queries[i][2];\\n            if(type == 0){\\n                if(row[rc] == -1){\\n                    ans+=(c*val);\\n                    row[rc] = 1;\\n                    r--;\\n                }\\n            }\\n            else{\\n                if(col[rc] == -1){\\n                    ans+=(r*val);\\n                    col[rc] = 1;\\n                    c--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616789,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def matrixSumQueries(n: Int, queries: Array[Array[Int]]): Long = {\\n    val rowSeen = Array.fill(n)(false)\\n    val colSeen = Array.fill(n)(false)\\n    queries.foldRight(0L, 0, 0)((cur, acc) => {\\n      val ty = cur(0)\\n      val id = cur(1)\\n      val value = cur(2)\\n      if(ty == 0 && !rowSeen(id)){\\n        rowSeen(id) = true\\n        (acc._1 + (n - acc._3) * value, acc._2 + 1, acc._3)\\n      } else if(ty == 1 && !colSeen(id)){\\n        colSeen(id) = true\\n        (acc._1 + (n - acc._2) * value, acc._2, acc._3 + 1)\\n      } else acc\\n    })._1\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def matrixSumQueries(n: Int, queries: Array[Array[Int]]): Long = {\\n    val rowSeen = Array.fill(n)(false)\\n    val colSeen = Array.fill(n)(false)\\n    queries.foldRight(0L, 0, 0)((cur, acc) => {\\n      val ty = cur(0)\\n      val id = cur(1)\\n      val value = cur(2)\\n      if(ty == 0 && !rowSeen(id)){\\n        rowSeen(id) = true\\n        (acc._1 + (n - acc._3) * value, acc._2 + 1, acc._3)\\n      } else if(ty == 1 && !colSeen(id)){\\n        colSeen(id) = true\\n        (acc._1 + (n - acc._2) * value, acc._2, acc._3 + 1)\\n      } else acc\\n    })._1\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3616014,
                "title": "interesting-problem-java-100-runtime-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReading description, didnt noticed about queries will always override latest value.\\nAfter multiple submissions, by reading tip mentioned in discussions would have helped me to resolve.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nQueries will always override with latest value.\\nBetter start from reverse, no need to override, keep track of visited rows and columns.\\nAdd them into sum and make sure you will not add values which are already added as a part of previous visits. Below one statement is most important to consider.\\n`sum += (val * (n-colsVisited));`\\n\\n# Complexity\\n- Time complexity: O(k) - k queries\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) - visited rows/cols & O(1) for sum\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        boolean[] visitedRows = new boolean[n];\\n        boolean[] visitedCols = new boolean[n];\\n        long sum =0;\\n\\n        int rowsVisited = 0;\\n        int colsVisited = 0;\\n\\n        for(int i=queries.length-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int j = queries[i][1];\\n            int val = queries[i][2];\\n\\n            if(type==0 && !visitedRows[j]){\\n                rowsVisited++;\\n                sum += (val * (n-colsVisited));\\n                visitedRows[j] = true;\\n            }else if(type==1 && !visitedCols[j]){\\n                colsVisited++;\\n                sum += (val* (n-rowsVisited));\\n                visitedCols[j] = true;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        boolean[] visitedRows = new boolean[n];\\n        boolean[] visitedCols = new boolean[n];\\n        long sum =0;\\n\\n        int rowsVisited = 0;\\n        int colsVisited = 0;\\n\\n        for(int i=queries.length-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int j = queries[i][1];\\n            int val = queries[i][2];\\n\\n            if(type==0 && !visitedRows[j]){\\n                rowsVisited++;\\n                sum += (val * (n-colsVisited));\\n                visitedRows[j] = true;\\n            }else if(type==1 && !visitedCols[j]){\\n                colsVisited++;\\n                sum += (val* (n-rowsVisited));\\n                visitedCols[j] = true;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615906,
                "title": "easy-java-solution-o-n",
                "content": "\\n# Complexity\\n- Time complexity: O( k )  [ where k = queries.length ]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n        long row = (long)n;\\n        long colm = (long)n;\\n        HashSet<Integer> rSet = new HashSet<>();\\n        HashSet<Integer> cSet = new HashSet<>();\\n        long ans = 0l;\\n\\n        for(int i=queries.length-1; i>=0; i--){\\n\\n            if(queries[i][0] == 1){\\n                if(!cSet.contains(queries[i][1])){\\n                    ans += row*((long)queries[i][2]);\\n                    colm--;\\n                    cSet.add(queries[i][1]);\\n                }\\n            }\\n            else{\\n                if(!rSet.contains(queries[i][1])){\\n                    ans += colm*((long)queries[i][2]);\\n                    row--;\\n                    rSet.add(queries[i][1]);\\n                }\\n            }\\n            \\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        \\n        long row = (long)n;\\n        long colm = (long)n;\\n        HashSet<Integer> rSet = new HashSet<>();\\n        HashSet<Integer> cSet = new HashSet<>();\\n        long ans = 0l;\\n\\n        for(int i=queries.length-1; i>=0; i--){\\n\\n            if(queries[i][0] == 1){\\n                if(!cSet.contains(queries[i][1])){\\n                    ans += row*((long)queries[i][2]);\\n                    colm--;\\n                    cSet.add(queries[i][1]);\\n                }\\n            }\\n            else{\\n                if(!rSet.contains(queries[i][1])){\\n                    ans += colm*((long)queries[i][2]);\\n                    row--;\\n                    rSet.add(queries[i][1]);\\n                }\\n            }\\n            \\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615649,
                "title": "swift-track-visited-axes",
                "content": "**Track Visited Axes (accepted answer)**\\n```\\nclass Solution {\\n    func matrixSumQueries(_ n: Int, _ queries: [[Int]]) -> Int {\\n        var result = 0\\n        var visited = Array(repeating: [false,false], count: n)\\n        var unvisited = [n,n]\\n        for q in queries.reversed() where !visited[q[1]][q[0]] {\\n            let (axis, i) = (q[0], q[1])\\n            visited[i][axis] = true\\n            result += q[2] * unvisited[axis ^ 1]\\n            unvisited[axis] -= 1\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func matrixSumQueries(_ n: Int, _ queries: [[Int]]) -> Int {\\n        var result = 0\\n        var visited = Array(repeating: [false,false], count: n)\\n        var unvisited = [n,n]\\n        for q in queries.reversed() where !visited[q[1]][q[0]] {\\n            let (axis, i) = (q[0], q[1])\\n            visited[i][axis] = true\\n            result += q[2] * unvisited[axis ^ 1]\\n            unvisited[axis] -= 1\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615424,
                "title": "java-5ms-100-and-clean-code",
                "content": "# Approach\\n1. As queries have priority, it makes sense to process the queries in reverse order.\\n2. Use a 2 x boolean[n] to keep track of what rows or cold have been queried.\\n    - Also count how many rows / cols have been queried\\n3. When processing a query, select the query type: row or col. If it has not been process (boolean[]), mark and process it\\n4. If a whole column get set a certain value, do you multiply n by value?\\n    - No, as certain rows from that column might have been already pre-processed\\n    - EG: n = 10, \\n    - last query : col 4 value 5. => this means sum += 5 * 10 (10 rows)\\n    - query -1: row 3 value 7= > we can\\'t add 10 * 7 (70) to sum because on previous query we have updated column 4, which already overrode row 3. Thus, we can only add 7 * 9 to sum (63).\\n    - With each query, count the edited number of rows/cols as each modification will only have partial benefit (diminishing returns)\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long sum = 0L;\\n        boolean[] modifiedRows = new boolean[n];\\n        boolean[] modifiedCols = new boolean[n];\\n        int touchedRows = 0, touchedCols = 0;\\n        int[] query;\\n        for (int i = queries.length -1; i >= 0; i--) {\\n            query = queries[i];\\n            if (query[0] == 0) {\\n                if (!modifiedRows[query[1]]) {\\n                    modifiedRows[query[1]] = true;\\n                    touchedRows++;\\n                    sum += ((long)query[2] * (n - touchedCols));\\n                }\\n            } else if (!modifiedCols[query[1]]) {\\n                modifiedCols[query[1]] = true;\\n                touchedCols++;\\n                sum += ((long)query[2] * (n - touchedRows));\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        long sum = 0L;\\n        boolean[] modifiedRows = new boolean[n];\\n        boolean[] modifiedCols = new boolean[n];\\n        int touchedRows = 0, touchedCols = 0;\\n        int[] query;\\n        for (int i = queries.length -1; i >= 0; i--) {\\n            query = queries[i];\\n            if (query[0] == 0) {\\n                if (!modifiedRows[query[1]]) {\\n                    modifiedRows[query[1]] = true;\\n                    touchedRows++;\\n                    sum += ((long)query[2] * (n - touchedCols));\\n                }\\n            } else if (!modifiedCols[query[1]]) {\\n                modifiedCols[query[1]] = true;\\n                touchedCols++;\\n                sum += ((long)query[2] * (n - touchedRows));\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615211,
                "title": "two-hashset-o-queries-length-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.The last query win the battle, map them in the HashSet.\\n2.Every count how many visited spaces in the column/row by the size of row/column\\n3.Add value* count to the answer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(queries.length)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**0(2*n)**\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rowM = new HashSet<>();\\n        Set<Integer> colM = new HashSet<>();\\n        long ans =0;\\n        for(int i=queries.length-1; i>=0; i--){\\n            int[] q = queries[i];\\n            int count =0;\\n            if(q[0] ==0){\\n                if(rowM.contains(q[1])) continue;\\n                count = n-colM.size();\\n                rowM.add(q[1]);\\n            }else{\\n                if(colM.contains(q[1]))continue;\\n                count = n- rowM.size();\\n                colM.add(q[1]);\\n            }\\n            ans += count*q[2];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> rowM = new HashSet<>();\\n        Set<Integer> colM = new HashSet<>();\\n        long ans =0;\\n        for(int i=queries.length-1; i>=0; i--){\\n            int[] q = queries[i];\\n            int count =0;\\n            if(q[0] ==0){\\n                if(rowM.contains(q[1])) continue;\\n                count = n-colM.size();\\n                rowM.add(q[1]);\\n            }else{\\n                if(colM.contains(q[1]))continue;\\n                count = n- rowM.size();\\n                colM.add(q[1]);\\n            }\\n            ans += count*q[2];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614946,
                "title": "easy-java-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int[] row = new int[n];\\n        int[] col = new int[n];\\n        int num_row = n, num_col = n;\\n        long sum = 0;\\n        for(int i=queries.length-1;i>=0;i--) {\\n            if(queries[i][0] == 0) \\n            {\\n                if(row[queries[i][1]] == 0) \\n                {\\n                    row[queries[i][1]] = 1;\\n                    num_row--;\\n                    sum += queries[i][2]*num_col;\\n                    \\n                }\\n            }\\n            else \\n            {\\n                if(col[queries[i][1]] == 0) \\n                {\\n                    col[queries[i][1]] = 1;\\n                    num_col--;\\n                    sum += queries[i][2]*num_row;\\n                    \\n                }\\n            }\\n            if(num_row == 0 || num_col == 0) return sum;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int[] row = new int[n];\\n        int[] col = new int[n];\\n        int num_row = n, num_col = n;\\n        long sum = 0;\\n        for(int i=queries.length-1;i>=0;i--) {\\n            if(queries[i][0] == 0) \\n            {\\n                if(row[queries[i][1]] == 0) \\n                {\\n                    row[queries[i][1]] = 1;\\n                    num_row--;\\n                    sum += queries[i][2]*num_col;\\n                    \\n                }\\n            }\\n            else \\n            {\\n                if(col[queries[i][1]] == 0) \\n                {\\n                    col[queries[i][1]] = 1;\\n                    num_col--;\\n                    sum += queries[i][2]*num_row;\\n                    \\n                }\\n            }\\n            if(num_row == 0 || num_col == 0) return sum;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611008,
                "title": "python3-two-sets-and-backwards",
                "content": "# Intuition\\na query will only add values if\\n1. there is no query who at the same row/col\\n2. n - col_covered if it\\'s a row, or n - row_covered if it\\'s a col\\n\\n# Approach\\ntwo sets to record how many col/row are covered\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, Q: List[List[int]]) -> int:\\n        res = 0\\n        seens = [set() for _ in range(2)]\\n        for m, i, v in Q[::-1]:\\n            if i not in seens[m]:\\n                res += v * (n - len(seens[1 - m]))\\n            seens[m].add(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, Q: List[List[int]]) -> int:\\n        res = 0\\n        seens = [set() for _ in range(2)]\\n        for m, i, v in Q[::-1]:\\n            if i not in seens[m]:\\n                res += v * (n - len(seens[1 - m]))\\n            seens[m].add(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609002,
                "title": "very-easy-and-simple-solution-o-n-explained",
                "content": "**Approach:  Last wale ka prabhav sb me dikhega to kyu na hm last se shuru kre!**\\n\\n*\\u2B50\\u2714simply calculate the sum of values in a matrix by processing the queries in reverse order and keeping track of visited rows and columns. The unvisited rows or columns are multiplied by the respective query value and added to the final answer\\u2B50.* \\n\\nLet\\'s break down the approach:\\n\\nInitialize two vectors, visCol and visRow, of size n with all elements set to 0. These vectors are used to keep track of visited columns and rows.\\n\\nInitialize variables NoOfRowsOperated and NoOfColOperated to 0. These variables count the number of rows and columns operated on.\\n\\nInitialize the variable ans to 0. This variable stores the final sum of values in the matrix.\\n\\nIterate through the queries in reverse order (from the last query to the first).\\n\\nFor each query, extract the query type (t), the index (ind), and the value (val).\\n\\nIf the query type is 0, check if the row at index ind has not been visited (visRow[ind] == 0). If it hasn\\'t been visited, update the answer (ans) by adding the product of val and the number of unvisited columns (n - NoOfColOperated). Increment NoOfRowsOperated and mark the row as visited (visRow[ind] = 1).\\n\\nIf the query type is 1, perform a similar operation for the column at index ind. Check if it has not been visited (visCol[ind] == 0), update the answer (ans) by adding the product of val and the number of unvisited rows (n - NoOfRowsOperated). Increment NoOfColOperated and mark the column as visited (visCol[ind] = 1).\\n\\nAfter processing all the queries, return the final answer (ans), which represents the sum of values in the matrix based on the given queries.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(long long n, vector<vector<int>>& q) {\\n        vector<int>visCol(n,0); \\n        vector<int>visRow(n,0);\\n        long long NoOfRowsOperated=0,NoOfColOperated=0;\\n        long long ans=0;\\n        for(int i=q.size()-1;i>=0;i--){\\n            int t=q[i][0];\\n            int ind=q[i][1];\\n            long long val=q[i][2];\\n            if(t==0){\\n               if(!visRow[ind]) {\\n                   ans+=val*(n-NoOfColOperated);\\n                   NoOfRowsOperated++;\\n                   visRow[ind]=1;\\n                   \\n               }\\n            }\\n            else{\\n                if(!visCol[ind]) {\\n                   ans+=val*(n-NoOfRowsOperated);\\n                    NoOfColOperated++;\\n                    visCol[ind]=1;\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(long long n, vector<vector<int>>& q) {\\n        vector<int>visCol(n,0); \\n        vector<int>visRow(n,0);\\n        long long NoOfRowsOperated=0,NoOfColOperated=0;\\n        long long ans=0;\\n        for(int i=q.size()-1;i>=0;i--){\\n            int t=q[i][0];\\n            int ind=q[i][1];\\n            long long val=q[i][2];\\n            if(t==0){\\n               if(!visRow[ind]) {\\n                   ans+=val*(n-NoOfColOperated);\\n                   NoOfRowsOperated++;\\n                   visRow[ind]=1;\\n                   \\n               }\\n            }\\n            else{\\n                if(!visCol[ind]) {\\n                   ans+=val*(n-NoOfRowsOperated);\\n                    NoOfColOperated++;\\n                    visCol[ind]=1;\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608496,
                "title": "java-easy-to-understand-reverse-iteration",
                "content": "The optimal solution involves traversing the given queries in reverse order. This is done so that we dont have to go through the trouble of subtracting the values which are overwritten.\\nHere, we directly start of with the max possible occurences of any element, given the number of rows and column which are still left to be occupied.\\n\\n# Complexity\\n- Time complexity: O(m), m being the number of queries\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int r = n;\\n        int c = n;\\n        int m = queries.length;\\n        Set<Integer> visitedRows = new HashSet<>();\\n        Set<Integer> visitedCols = new HashSet<>();\\n        long sum = 0;\\n        for(int i = m-1; i>=0; i--)\\n        {\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            if(queries[i][0] == 0 && !visitedRows.contains(index))\\n            {\\n                sum += (long)c*queries[i][2];\\n                visitedRows.add(index);\\n                r--;\\n            }\\n            else if(queries[i][0] == 1 && !visitedCols.contains(index))\\n            {\\n                sum += (long)r*queries[i][2];\\n                visitedCols.add(index);\\n                c--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int r = n;\\n        int c = n;\\n        int m = queries.length;\\n        Set<Integer> visitedRows = new HashSet<>();\\n        Set<Integer> visitedCols = new HashSet<>();\\n        long sum = 0;\\n        for(int i = m-1; i>=0; i--)\\n        {\\n            int index = queries[i][1];\\n            int val = queries[i][2];\\n            if(queries[i][0] == 0 && !visitedRows.contains(index))\\n            {\\n                sum += (long)c*queries[i][2];\\n                visitedRows.add(index);\\n                r--;\\n            }\\n            else if(queries[i][0] == 1 && !visitedCols.contains(index))\\n            {\\n                sum += (long)r*queries[i][2];\\n                visitedCols.add(index);\\n                c--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607840,
                "title": "beats-100-java-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int seenColCount = 0;\\n        int seenRowCount = 0;\\n        long sum = 0;\\n\\n        boolean[] rowSeen = new boolean[n];\\n        boolean[] colSeen = new boolean[n];\\n\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n\\n            if (type == 0 && !rowSeen[index]) {\\n                seenRowCount++;\\n                rowSeen[index] = true;\\n                sum += (n - seenColCount) * value;\\n            } else if (type == 1 && !colSeen[index]) {\\n                seenColCount++;\\n                colSeen[index] = true;\\n                sum += (n - seenRowCount) * value;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        int seenColCount = 0;\\n        int seenRowCount = 0;\\n        long sum = 0;\\n\\n        boolean[] rowSeen = new boolean[n];\\n        boolean[] colSeen = new boolean[n];\\n\\n        for (int i = queries.length - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n\\n            if (type == 0 && !rowSeen[index]) {\\n                seenRowCount++;\\n                rowSeen[index] = true;\\n                sum += (n - seenColCount) * value;\\n            } else if (type == 1 && !colSeen[index]) {\\n                seenColCount++;\\n                colSeen[index] = true;\\n                sum += (n - seenRowCount) * value;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607459,
                "title": "simple-c-solution",
                "content": "\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long res=0;\\n        int c=n,r=n;\\n        map<int,int> col,row;\\n        for(int i=queries.size()-1;i>=0;i--){\\n            int type=queries[i][0],ind=queries[i][1],val=queries[i][2];\\n            if(type==0 && row[ind]!=1){\\n              row[ind]=1;\\n              res+=(c*val);  \\n              r--;  \\n            }\\n            else if(type==1 && col[ind]!=1){\\n              col[ind]=1;\\n              res+=(r*val);   \\n              c--;  \\n            }\\n        }\\n      \\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long res=0;\\n        int c=n,r=n;\\n        map<int,int> col,row;\\n        for(int i=queries.size()-1;i>=0;i--){\\n            int type=queries[i][0],ind=queries[i][1],val=queries[i][2];\\n            if(type==0 && row[ind]!=1){\\n              row[ind]=1;\\n              res+=(c*val);  \\n              r--;  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3607345,
                "title": "python-o-n-time-complexity-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnly the last query of the rows or columns will affect the matrix sum. Therefore, we will process the queries backward and skip the seen rows and columns.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will process the queries backward, for each query, we will increase the sum by val * (n - number of seen row/column). If we are working on row, we subtract the no. of seen column, and vice versa. The intuition behind subtracting number of seen row/column is that the later operation will overwrite the previous value, the later query\\'s value (which we will process first) have the priority in the returned sum.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, n is the queries\\' length here.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$, m is the matrix\\'s length.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen = set()\\n        row_cnt, col_cnt = 0, 0\\n        res = 0\\n        \\n        for t, i, val in queries[::-1]:\\n            if (t, i) not in seen:\\n                if t == 0:\\n                    row_cnt += 1\\n                    res += val * (n - col_cnt)\\n                else:\\n                    col_cnt += 1\\n                    res += val * (n - row_cnt)\\n                \\n                seen.add((t, i))\\n        \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen = set()\\n        row_cnt, col_cnt = 0, 0\\n        res = 0\\n        \\n        for t, i, val in queries[::-1]:\\n            if (t, i) not in seen:\\n                if t == 0:\\n                    row_cnt += 1\\n                    res += val * (n - col_cnt)\\n                else:\\n                    col_cnt += 1\\n                    res += val * (n - row_cnt)\\n                \\n                seen.add((t, i))\\n        \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607335,
                "title": "c-think-in-reverse",
                "content": "# Intuition\\nLast operation values will be n..\\n\\n# Approach\\nKeep track of the filled number of rows and columns and also visited rows and columns.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& qu) {\\n        long long int ans = 0;\\n        int q = qu.size();\\n        vector<vector<int>> vis (2 , vector<int>(n , 0));\\n        int cn[2];\\n        cn[0] = 0 , cn[1] = 0;//cn[0] stores the filled number of rows , cn[1] stores columns filled. \\n        for(int i = q - 1; i >= 0; i--)\\n        {\\n            int ty = qu[i][0] , in = qu[i][1] , val = qu[i][2];\\n           \\n                if(vis[ty][in] == 0)\\n                {\\n                    ans += (val) * (n - (cn[ty ^ 1]));\\n                    vis[ty][in]++;\\n                    cn[ty]++;\\n                }\\n            \\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& qu) {\\n        long long int ans = 0;\\n        int q = qu.size();\\n        vector<vector<int>> vis (2 , vector<int>(n , 0));\\n        int cn[2];\\n        cn[0] = 0 , cn[1] = 0;//cn[0] stores the filled number of rows , cn[1] stores columns filled. \\n        for(int i = q - 1; i >= 0; i--)\\n        {\\n            int ty = qu[i][0] , in = qu[i][1] , val = qu[i][2];\\n           \\n                if(vis[ty][in] == 0)\\n                {\\n                    ans += (val) * (n - (cn[ty ^ 1]));\\n                    vis[ty][in]++;\\n                    cn[ty]++;\\n                }\\n            \\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606594,
                "title": "c-traverse-from-the-last-query-and-maintain-unordered-set-for-rows-and-column",
                "content": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_set<int> rows;\\n        unordered_set<int> cols;\\n        \\n        long long ans =0;\\n        int type=0,index=0,val=0;\\n        for (int i=queries.size()-1;i>=0;i--){\\n            type = queries[i][0];\\n            index = queries[i][1];\\n            val = queries[i][2];\\n            if (type==0){\\n                if (rows.find(index)==rows.end()){\\n                    ans += val * (n-cols.size());\\n                    rows.insert(index);\\n                }\\n            }\\n            else{\\n                if (cols.find(index)==cols.end()){\\n                    ans += val * (n-rows.size());\\n                    cols.insert(index);\\n                }\\n            }\\n        }\\n        return ans;\\n         \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_set<int> rows;\\n        unordered_set<int> cols;\\n        \\n        long long ans =0;\\n        int type=0,index=0,val=0;\\n        for (int i=queries.size()-1;i>=0;i--){\\n            type = queries[i][0];\\n            index = queries[i][1];\\n            val = queries[i][2];\\n            if (type==0){\\n                if (rows.find(index)==rows.end()){\\n                    ans += val * (n-cols.size());\\n                    rows.insert(index);\\n                }\\n            }\\n            else{\\n                if (cols.find(index)==cols.end()){\\n                    ans += val * (n-rows.size());\\n                    cols.insert(index);\\n                }\\n            }\\n        }\\n        return ans;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606455,
                "title": "python-o-q-count-opposite-types",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince a later query will overwrite any previous values in the matrix, we need to consider queries in reverse order.\\n\\nNotice that if a later query writes to a row, then any earlier query that writes to a column contributes one less value to the final matrix.\\n\\nSpecifically, an earlier query of a [row | column] will contribute `(n - k) * val` to the total, where `k` is the number of later queries (of opposite type) that write to distinct [columns | rows].\\n\\nSince every query writes to the whole row or column, we dont need to care about _where_ the missing values are, but only _how many_ there are.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep a count of the number of missing query types, `missing`. At first, there will be `n` values missing in every row and `n` values missing in every column.\\n\\nKeep a set of distinct query types, `seen` to know when a later query type has written to a specific row or column.\\n\\n- For each query type not yet seen:\\n    - Mark the query type as seen.\\n    - Add the number of missing values of that type to the total.\\n    - Decrement the number of missing values for the current type.\\n\\n# Complexity\\n- Time complexity:  $$ O(q) $$, where $$ q $$ is number of queries.\\n    - Must check at least $$ n + n $$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(n) $$\\n    - Store at most $$ n + n $$ query types in `seen`.\\n    - Store count of missing rows and columns.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```py\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen = set()\\n        missing = [n, n]\\n        total = 0\\n        \\n        for i in range(len(queries) - 1, -1, -1):\\n            typ, ind, val = queries[i]\\n            if (typ, ind) not in seen:\\n                seen.add((typ, ind))\\n                total += val * missing[typ]\\n                missing[typ ^ 1] -= 1\\n        \\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        seen = set()\\n        missing = [n, n]\\n        total = 0\\n        \\n        for i in range(len(queries) - 1, -1, -1):\\n            typ, ind, val = queries[i]\\n            if (typ, ind) not in seen:\\n                seen.add((typ, ind))\\n                total += val * missing[typ]\\n                missing[typ ^ 1] -= 1\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605625,
                "title": "c-solution-using-unordered-sets",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_set<int>rows;\\n        unordered_set<int>cols;\\n        int q_rows = queries.size();\\n        long long sum=0;\\n        for(int i=q_rows-1; i>=0; i--){\\n            if(queries[i][0]==0 && rows.find(queries[i][1])==rows.end()){\\n                sum+=queries[i][2]*(n-cols.size());\\n                rows.insert(queries[i][1]);\\n            }\\n            else if(queries[i][0]==1 && cols.find(queries[i][1])==cols.end()){\\n                sum+=queries[i][2]*(n-rows.size());\\n                cols.insert(queries[i][1]);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        unordered_set<int>rows;\\n        unordered_set<int>cols;\\n        int q_rows = queries.size();\\n        long long sum=0;\\n        for(int i=q_rows-1; i>=0; i--){\\n            if(queries[i][0]==0 && rows.find(queries[i][1])==rows.end()){\\n                sum+=queries[i][2]*(n-cols.size());\\n                rows.insert(queries[i][1]);\\n            }\\n            else if(queries[i][0]==1 && cols.find(queries[i][1])==cols.end()){\\n                sum+=queries[i][2]*(n-rows.size());\\n                cols.insert(queries[i][1]);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605424,
                "title": "python3-o-n-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        row_counter, col_counter = 0, 0\\n        seen_row, seen_col = set(), set()\\n        res = 0\\n        for type_i, index_i, val_i in queries[::-1]:\\n            if type_i == 0:\\n                if index_i not in seen_row:\\n                    seen_row.add(index_i)\\n                    res += (val_i * (n - col_counter))\\n                    row_counter += 1\\n            else:\\n                if index_i not in seen_col:\\n                    seen_col.add(index_i)\\n                    res += (val_i * (n - row_counter))\\n                    col_counter += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        row_counter, col_counter = 0, 0\\n        seen_row, seen_col = set(), set()\\n        res = 0\\n        for type_i, index_i, val_i in queries[::-1]:\\n            if type_i == 0:\\n                if index_i not in seen_row:\\n                    seen_row.add(index_i)\\n                    res += (val_i * (n - col_counter))\\n                    row_counter += 1\\n            else:\\n                if index_i not in seen_col:\\n                    seen_col.add(index_i)\\n                    res += (val_i * (n - row_counter))\\n                    col_counter += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605347,
                "title": "javascript-typescript-go-backwards-track-only-top-cols-and-rows",
                "content": "# Intuition\\nimagine each row and column as a strip of paper\\nnow lay them all down, one on top of the other until the matrix is full.\\n\\nthe sum is the visible numbers \\nHowever, actually building it this way takes too long.\\n\\nso instead, start from the end. Lay down rows and columns in reverse because the end ones are the ones going to be on top.\\n\\nIf you are laying down a row, it must go \\'under\\' the previously laid columns so we must subtract their values as they will cover up those indexes of the row.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (queries length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO (n ** 2)\\n\\n# Code\\n```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n\\n    let sum: number = 0\\n    let rowSeen: Set<number> = new Set()\\n    let colSeen: Set<number> = new Set()\\n\\n    for (const [type, index, val] of queries.reverse()) {\\n        // row\\n        if (type === 0 && !rowSeen.has(index)) {\\n            rowSeen.add(index)\\n            sum += n * val - colSeen.size * val\\n        }\\n\\n        // col\\n        if (type === 1 && !colSeen.has(index)) {\\n            colSeen.add(index)\\n            sum += n * val - rowSeen.size * val\\n        }\\n    }\\n\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n\\n    let sum: number = 0\\n    let rowSeen: Set<number> = new Set()\\n    let colSeen: Set<number> = new Set()\\n\\n    for (const [type, index, val] of queries.reverse()) {\\n        // row\\n        if (type === 0 && !rowSeen.has(index)) {\\n            rowSeen.add(index)\\n            sum += n * val - colSeen.size * val\\n        }\\n\\n        // col\\n        if (type === 1 && !colSeen.has(index)) {\\n            colSeen.add(index)\\n            sum += n * val - rowSeen.size * val\\n        }\\n    }\\n\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3605062,
                "title": "easy-o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        int m = queries.size();\\n        long long rowCnt = n;\\n        long long colCnt = n;\\n        unordered_set<int> visRow;//For visited rows\\n        unordered_set<int> visCol;//For visited cols\\n\\n        for(int i=m-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            long long val = queries[i][2];\\n\\n            if(type==0 and visRow.count(index)==0){//To change the Rows\\n                sum += val * colCnt;\\n                rowCnt--;//Decreasing row count\\n                visRow.insert(index);//Marked as visited row index\\n            }\\n            else if(type==1 and visCol.count(index)==0){//To change the Cols\\n                sum += val * rowCnt;\\n                colCnt--;//Decreasing col count\\n                visCol.insert(index);//Marked as visited col index\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        int m = queries.size();\\n        long long rowCnt = n;\\n        long long colCnt = n;\\n        unordered_set<int> visRow;//For visited rows\\n        unordered_set<int> visCol;//For visited cols\\n\\n        for(int i=m-1;i>=0;i--){\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            long long val = queries[i][2];\\n\\n            if(type==0 and visRow.count(index)==0){//To change the Rows\\n                sum += val * colCnt;\\n                rowCnt--;//Decreasing row count\\n                visRow.insert(index);//Marked as visited row index\\n            }\\n            else if(type==1 and visCol.count(index)==0){//To change the Cols\\n                sum += val * rowCnt;\\n                colCnt--;//Decreasing col count\\n                visCol.insert(index);//Marked as visited col index\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604587,
                "title": "my-c-solution",
                "content": "# Intuition\\nMain thing to observe here is that **traversing from right to left is optimal** because last time val is overwritten, we\\'ll be considering that val.\\n\\nI have taken two visited arr (row and col) as we are traversing from right to left if particular row or col is already considered then no need to overwrite the value with val, continue the iteration, else overwrite the values with val and mark that ind(row or col) true.\\n\\nI have also taken rowCount and colCount to optimize the solution(to get rid of extra O(n) time complexity) we know, for any row if we are overwriting the values we have to check for colCount if it is not zero then we can\\'t add that particular cell values because we already add it in our answer previously(as we are moving from right to left and last values are to be considered at last).\\n\\nfor given row, our sum will be = val + val + ....n times ==> n*val;\\nbut if colCount is not zero means we cannot add colCount number of cells in our sum, sum = (n-colCount)*val.\\n\\nsame goes for every col.\\n\\n# Complexity\\n- Time complexity:O(queries.size()) => O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        vector<bool> row(n, false);\\n        vector<bool> col(n, false);\\n        int rowCount = 0;\\n        int colCount = 0;\\n        \\n        // traversing from right to left\\n        for(int i = queries.size()-1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int ind = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            // row\\n            if(type == 0) {\\n                // check if for this row values are already considered in our sum because we only want last overwritten values and as we are going from right to left we have already taken into account.\\n                if(!row[ind]) {\\n                    // increase row count to further avoid considering values which were already considered.\\n                    rowCount++;\\n                    row[ind] = true;\\n                    sum += (n-colCount)*val;\\n                }\\n            // column\\n            } else {\\n                if(!col[ind]) {\\n                    colCount++;\\n                    col[ind] = true;\\n                    sum += (n-rowCount)*val;\\n                }\\n            }\\n            \\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long sum = 0;\\n        vector<bool> row(n, false);\\n        vector<bool> col(n, false);\\n        int rowCount = 0;\\n        int colCount = 0;\\n        \\n        // traversing from right to left\\n        for(int i = queries.size()-1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int ind = queries[i][1];\\n            int val = queries[i][2];\\n            \\n            // row\\n            if(type == 0) {\\n                // check if for this row values are already considered in our sum because we only want last overwritten values and as we are going from right to left we have already taken into account.\\n                if(!row[ind]) {\\n                    // increase row count to further avoid considering values which were already considered.\\n                    rowCount++;\\n                    row[ind] = true;\\n                    sum += (n-colCount)*val;\\n                }\\n            // column\\n            } else {\\n                if(!col[ind]) {\\n                    colCount++;\\n                    col[ind] = true;\\n                    sum += (n-rowCount)*val;\\n                }\\n            }\\n            \\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603989,
                "title": "easy-to-understand-python-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0\\n        rows = set()\\n        cols = set()\\n        rowsNum = n\\n        colsNum = n\\n\\n        while rows != [] or cols != []:\\n\\n            if queries:\\n                que = queries.pop()\\n                t = que[0]\\n                index = que[1]\\n                val = que[2]\\n                if t == 0 and index not in rows:\\n                    ans += colsNum * val\\n                    rows.add(index)\\n                    rowsNum -= 1\\n                elif t == 1 and index not in cols:\\n                    ans += rowsNum * val\\n                    cols.add(index)\\n                    colsNum -= 1\\n            else:\\n                break\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans = 0\\n        rows = set()\\n        cols = set()\\n        rowsNum = n\\n        colsNum = n\\n\\n        while rows != [] or cols != []:\\n\\n            if queries:\\n                que = queries.pop()\\n                t = que[0]\\n                index = que[1]\\n                val = que[2]\\n                if t == 0 and index not in rows:\\n                    ans += colsNum * val\\n                    rows.add(index)\\n                    rowsNum -= 1\\n                elif t == 1 and index not in cols:\\n                    ans += rowsNum * val\\n                    cols.add(index)\\n                    colsNum -= 1\\n            else:\\n                break\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603165,
                "title": "c-think-reverse",
                "content": "# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        set<int> r,c;\\n        long long ans = 0ll;\\n        reverse(queries.begin(),queries.end());\\n        for(auto& que:queries){\\n            int type = que[0], index = que[1], val = que[2];\\n            if(type==0){\\n                if(r.find(index)==r.end()){\\n                    ans+=(n-c.size())*val;\\n                    r.insert(index);\\n                }\\n            }else{\\n                if(c.find(index)==c.end()){\\n                    ans+=(n-r.size())*val;\\n                    c.insert(index);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        set<int> r,c;\\n        long long ans = 0ll;\\n        reverse(queries.begin(),queries.end());\\n        for(auto& que:queries){\\n            int type = que[0], index = que[1], val = que[2];\\n            if(type==0){\\n                if(r.find(index)==r.end()){\\n                    ans+=(n-c.size())*val;\\n                    r.insert(index);\\n                }\\n            }else{\\n                if(c.find(index)==c.end()){\\n                    ans+=(n-r.size())*val;\\n                    c.insert(index);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602795,
                "title": "java-simple-solution",
                "content": "The idea is to traverse queries backwards so we see the newest queries first.\\n\\nIf the query type is 0, that means a row is replaced, and the amount of tiles in the row that was replaced depends on how many columns overwritten it afterwards. We keep track of which rows and columns have been replaced as we traverse backwards.\\n\\nThe idea of the formula `sum += (curVal * (n-placedCols.size()))` is the following example:\\nIf n = 4, val = 2, and a row was replaced on the last query, 4 tiles would be replaced with the value 2 (since obviously nothing overwritten the tiles after, so `placedCols.size() = 0` here). However, if the same query was done but 3 different columns were replaced after it, then only 1 tile would be replaced (`placedCols.size() = 3` here). This basically suggests that as we are iterating backwards on the queries, more and more unique row/col overwrites happened after `queries[i]` so the amount of tiles the older values occupy become less and less.\\n\\nThe idea of\\n```               \\nif (placedRows.contains(curIdx)) {\\n\\tcontinue;\\n}\\n```\\nis that a newer query overwritten this specific row index, so this value is not relevant to the sum anymore.\\n\\n**Java Solution:**\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        //Keep track of rows/cols already filled\\n        Set<Integer> placedRows = new HashSet<>();\\n        Set<Integer> placedCols = new HashSet<>();\\n        long sum = 0;\\n        for (int i = queries.length-1; i >= 0; i--) {\\n            int curType = queries[i][0];\\n            int curIdx = queries[i][1];\\n            long curVal = queries[i][2];\\n            //Row\\n            if (curType == 0) {\\n                //If already contains, then don\\'t do anything because we overwritten it\\n                if (placedRows.contains(curIdx)) {\\n                    continue;\\n                }\\n                placedRows.add(curIdx);\\n                //Older queries are less populated\\n                sum += (curVal * (n-placedCols.size()));\\n                \\n            }\\n            //Col\\n            else if (curType == 1) {\\n                if (placedCols.contains(curIdx)) {\\n                    continue;\\n                }\\n                placedCols.add(curIdx);\\n                sum += (curVal * (n-placedRows.size()));\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```               \\nif (placedRows.contains(curIdx)) {\\n\\tcontinue;\\n}\\n```\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        //Keep track of rows/cols already filled\\n        Set<Integer> placedRows = new HashSet<>();\\n        Set<Integer> placedCols = new HashSet<>();\\n        long sum = 0;\\n        for (int i = queries.length-1; i >= 0; i--) {\\n            int curType = queries[i][0];\\n            int curIdx = queries[i][1];\\n            long curVal = queries[i][2];\\n            //Row\\n            if (curType == 0) {\\n                //If already contains, then don\\'t do anything because we overwritten it\\n                if (placedRows.contains(curIdx)) {\\n                    continue;\\n                }\\n                placedRows.add(curIdx);\\n                //Older queries are less populated\\n                sum += (curVal * (n-placedCols.size()));\\n                \\n            }\\n            //Col\\n            else if (curType == 1) {\\n                if (placedCols.contains(curIdx)) {\\n                    continue;\\n                }\\n                placedCols.add(curIdx);\\n                sum += (curVal * (n-placedRows.size()));\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602764,
                "title": "python3-o-len-queries-neat-code-reverse-traverse",
                "content": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans, overlaps = 0, [set(), set()]\\n        for t, i, v in reversed(queries):\\n            if i in overlaps[t]: continue\\n            ans += v * (n - len(overlaps[1 - t]))\\n            overlaps[t].add(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        ans, overlaps = 0, [set(), set()]\\n        for t, i, v in reversed(queries):\\n            if i in overlaps[t]: continue\\n            ans += v * (n - len(overlaps[1 - t]))\\n            overlaps[t].add(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602720,
                "title": "easy-to-understand-reverse-one-pass-hashset",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn matrix_sum_queries(n: i32, queries: Vec<Vec<i32>>) -> i64 {\\n        let (mut rows, mut cols) = (HashSet::new(), HashSet::new());\\n        let n = n as i64;\\n        let mut ans = 0;\\n        \\n        for q in queries.iter().rev() {\\n            if q[0] == 0 {\\n                if !rows.insert(q[1]) { continue };\\n                ans += (n - cols.len() as i64) * q[2] as i64;\\n            } else {\\n                if !cols.insert(q[1]) { continue };\\n                ans += (n - rows.len() as i64) * q[2] as i64;\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn matrix_sum_queries(n: i32, queries: Vec<Vec<i32>>) -> i64 {\\n        let (mut rows, mut cols) = (HashSet::new(), HashSet::new());\\n        let n = n as i64;\\n        let mut ans = 0;\\n        \\n        for q in queries.iter().rev() {\\n            if q[0] == 0 {\\n                if !rows.insert(q[1]) { continue };\\n                ans += (n - cols.len() as i64) * q[2] as i64;\\n            } else {\\n                if !cols.insert(q[1]) { continue };\\n                ans += (n - rows.len() as i64) * q[2] as i64;\\n            }\\n        }\\n        \\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602361,
                "title": "rust-simple-solution-o-n-time-and-space",
                "content": "# Idea \\nBypass queries in reverse order. Process only unused rows and columns\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nimpl Solution {\\n    pub fn matrix_sum_queries(n: i32, queries: Vec<Vec<i32>>) -> i64 {\\n        let size = n as usize;\\n        let (mut cnt_rows, mut cnt_cols) = (0, 0);\\n        let mut used_rows = vec![0; size];\\n        let mut used_cols = vec![0; size];\\n        let mut res: i64 = 0;\\n        \\n        for i in (0..queries.len()).rev() {\\n            if queries[i][0] == 0 && used_rows[queries[i][1] as usize] == 0 { // rows\\n                used_rows[queries[i][1] as usize] = 1;\\n                cnt_rows += 1;\\n                res += ((n - cnt_cols) * queries[i][2]) as i64;\\n            } else if queries[i][0] == 1 && used_cols[queries[i][1] as usize] == 0 { // cols\\n                used_cols[queries[i][1] as usize] = 1;\\n                cnt_cols += 1;\\n                res += ((n - cnt_rows) * queries[i][2]) as i64;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn matrix_sum_queries(n: i32, queries: Vec<Vec<i32>>) -> i64 {\\n        let size = n as usize;\\n        let (mut cnt_rows, mut cnt_cols) = (0, 0);\\n        let mut used_rows = vec![0; size];\\n        let mut used_cols = vec![0; size];\\n        let mut res: i64 = 0;\\n        \\n        for i in (0..queries.len()).rev() {\\n            if queries[i][0] == 0 && used_rows[queries[i][1] as usize] == 0 { // rows\\n                used_rows[queries[i][1] as usize] = 1;\\n                cnt_rows += 1;\\n                res += ((n - cnt_cols) * queries[i][2]) as i64;\\n            } else if queries[i][0] == 1 && used_cols[queries[i][1] as usize] == 0 { // cols\\n                used_cols[queries[i][1] as usize] = 1;\\n                cnt_cols += 1;\\n                res += ((n - cnt_rows) * queries[i][2]) as i64;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602264,
                "title": "tc-100-5ms-sc-99-java-sol-with-comments",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Traverse the queries in reverse because for the same row/column, only the last query\\'s results will be preserved (fully or partially)\\n- Use 2 visited arrays to mark if a row or column has already been checked\\n- Use 2 variables rowsRem & colsRem to track unchecked rows & columns\\n- Feel free to comment if you have any question\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        // Create visited array to store if a row or column has been filled\\n        boolean[] visitedRows = new boolean[n];\\n        boolean[] visitedCols = new boolean[n];\\n        int rowsRem = n, colsRem = n;\\n        long ans = 0;\\n        // Starting from last query since only the latest one for each row/column will be preserved\\n        for (int i = queries.length - 1; i >= 0; i--){\\n            // If it is a row query\\n            if (queries[i][0] == 0){\\n                // If the row was already visited, skip\\n                if (visitedRows[queries[i][1]] == true){\\n                    continue;\\n                // Start incrementing answer depending on colRem\\n                // Because you can only fill the cells in empty columns\\n                } else {\\n                    visitedRows[queries[i][1]] = true;\\n                    ans += colsRem * queries[i][2];\\n                    rowsRem--;\\n                }\\n            // If it is a column query\\n            } else {\\n                // If the column was already visited, skip\\n                if (visitedCols[queries[i][1]] == true){\\n                    continue;\\n                // Start incrementing answer depending on rowRem\\n                // Because you can only fill the cells in empty rows\\n                } else {\\n                    visitedCols[queries[i][1]] = true;\\n                    ans += rowsRem * queries[i][2];\\n                    colsRem--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Thanks for reading!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        // Create visited array to store if a row or column has been filled\\n        boolean[] visitedRows = new boolean[n];\\n        boolean[] visitedCols = new boolean[n];\\n        int rowsRem = n, colsRem = n;\\n        long ans = 0;\\n        // Starting from last query since only the latest one for each row/column will be preserved\\n        for (int i = queries.length - 1; i >= 0; i--){\\n            // If it is a row query\\n            if (queries[i][0] == 0){\\n                // If the row was already visited, skip\\n                if (visitedRows[queries[i][1]] == true){\\n                    continue;\\n                // Start incrementing answer depending on colRem\\n                // Because you can only fill the cells in empty columns\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3602224,
                "title": "python-o-lengthof-queries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(len(queries))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        res = 0\\n        # the number of row/col that have been overwritten\\n        writtenRowCount, writtenColCount = 0,0\\n        # mark each row/col whether it is overwritten or not\\n        # we traverse the queries in a reverse order, therefore, \\n        # once we met a row/col that has been overwritten before, we skip them.\\n        # beacause we are in reversed traversal and this row/col will be overwritten in the original case.\\n        writtenRow, writtenCol = [False] * n, [False] * n\\n\\n        for tpy, idx, val in reversed(queries):\\n            if tpy == 0 and not writtenRow[idx]:\\n                # only cells that is not be overwritten will be count into the result\\n                res += val * (n - writtenColCount)\\n                # now this row should be marked as overwritten\\n                writtenRow[idx] = True\\n                # we have one more overwritten row now\\n                writtenRowCount += 1\\n            if tpy == 1 and not writtenCol[idx]:\\n                # only cells that is not be overwritten will be count into the result\\n                res += val * (n - writtenRowCount)\\n                # now this col should be marked as overwritten\\n                writtenCol[idx] = True\\n                # we have one more overwritten col now\\n                writtenColCount += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        res = 0\\n        # the number of row/col that have been overwritten\\n        writtenRowCount, writtenColCount = 0,0\\n        # mark each row/col whether it is overwritten or not\\n        # we traverse the queries in a reverse order, therefore, \\n        # once we met a row/col that has been overwritten before, we skip them.\\n        # beacause we are in reversed traversal and this row/col will be overwritten in the original case.\\n        writtenRow, writtenCol = [False] * n, [False] * n\\n\\n        for tpy, idx, val in reversed(queries):\\n            if tpy == 0 and not writtenRow[idx]:\\n                # only cells that is not be overwritten will be count into the result\\n                res += val * (n - writtenColCount)\\n                # now this row should be marked as overwritten\\n                writtenRow[idx] = True\\n                # we have one more overwritten row now\\n                writtenRowCount += 1\\n            if tpy == 1 and not writtenCol[idx]:\\n                # only cells that is not be overwritten will be count into the result\\n                res += val * (n - writtenRowCount)\\n                # now this col should be marked as overwritten\\n                writtenCol[idx] = True\\n                # we have one more overwritten col now\\n                writtenColCount += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602080,
                "title": "c-602-ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, const vector<vector<int>>& queries)\\n    {\\n        enum { ROW = 0, TYPE = 0, INDEX, VALUE, };\\n        const int len = queries.size();\\n\\n        int row_count = 0;\\n        int col_count = 0;\\n        long long res = 0;\\n        vector<bool> row(n);\\n        vector<bool> col(n);\\n\\n        for(int i = len - 1; i >= 0; --i)\\n        {\\n            int pos = queries[i][INDEX];\\n\\n            if(queries[i][TYPE] == ROW) {\\n                if(row[pos] == true) continue;\\n                row[pos] = true;\\n                res += queries[i][VALUE] * (n - col_count);\\n                ++row_count;\\n            }\\n            else {\\n                if(col[pos] == true) continue;\\n                col[pos] = true;\\n                res += queries[i][VALUE] * (n - row_count);\\n                ++col_count;\\n            }\\n\\n            if(row_count == n and col_count == n) break;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, const vector<vector<int>>& queries)\\n    {\\n        enum { ROW = 0, TYPE = 0, INDEX, VALUE, };\\n        const int len = queries.size();\\n\\n        int row_count = 0;\\n        int col_count = 0;\\n        long long res = 0;\\n        vector<bool> row(n);\\n        vector<bool> col(n);\\n\\n        for(int i = len - 1; i >= 0; --i)\\n        {\\n            int pos = queries[i][INDEX];\\n\\n            if(queries[i][TYPE] == ROW) {\\n                if(row[pos] == true) continue;\\n                row[pos] = true;\\n                res += queries[i][VALUE] * (n - col_count);\\n                ++row_count;\\n            }\\n            else {\\n                if(col[pos] == true) continue;\\n                col[pos] = true;\\n                res += queries[i][VALUE] * (n - row_count);\\n                ++col_count;\\n            }\\n\\n            if(row_count == n and col_count == n) break;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602073,
                "title": "java-o-n-beats-100-using-set-and-reverse-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> row=new HashSet();\\n        Set<Integer> col=new HashSet();\\n        int r=n, c=n;\\n        long sum=0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            int type=queries[i][0];\\n            int index=queries[i][1];\\n            int value=queries[i][2];\\n            \\n            if(type==0 && !row.contains(index)){\\n                sum+=value*r;\\n                c--;\\n                row.add(index);\\n            }\\n            else if(type==1 && !col.contains(index)){\\n                sum+=value*c;\\n                r--;\\n                col.add(index);\\n            }\\n            \\n        }\\n        return sum;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int n, int[][] queries) {\\n        Set<Integer> row=new HashSet();\\n        Set<Integer> col=new HashSet();\\n        int r=n, c=n;\\n        long sum=0;\\n        for(int i=queries.length-1;i>=0;i--){\\n            int type=queries[i][0];\\n            int index=queries[i][1];\\n            int value=queries[i][2];\\n            \\n            if(type==0 && !row.contains(index)){\\n                sum+=value*r;\\n                c--;\\n                row.add(index);\\n            }\\n            else if(type==1 && !col.contains(index)){\\n                sum+=value*c;\\n                r--;\\n                col.add(index);\\n            }\\n            \\n        }\\n        return sum;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601898,
                "title": "easy-solution-o-n-hashmap",
                "content": "# Intuition\\nmake use of 2 maps one for visited rows and one for visited column :::\\n\\n# Approach\\nstart  from the lastmost  query and keep count of both visited index of row and columns .\\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n  O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q ) {\\n         long long  sum = 0 ; \\n         map< int , int > r , c ;\\n         int rows = 0 , cols = 0 ;\\n         for( int i = q.size()-1 ; i>=0 ; i-- ){\\n              if( q[i][0] == 0 ){\\n                   if( r.find(  q[i][1] )  == r.end() ){\\n                       sum+=( (n-c.size())*q[i][2] ) ;\\n                       \\n                       r[q[i][1]]++ ;\\n                   }\\n               }\\n              else {\\n                   if(  c.find( q[i][1] )  == c.end() ){\\n                       sum+=((n-r.size())*q[i][2]) ;\\n                       cols++ ;\\n                       c[q[i][1]]++ ;\\n                   }\\n              }\\n         }\\n         return sum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q ) {\\n         long long  sum = 0 ; \\n         map< int , int > r , c ;\\n         int rows = 0 , cols = 0 ;\\n         for( int i = q.size()-1 ; i>=0 ; i-- ){\\n              if( q[i][0] == 0 ){\\n                   if( r.find(  q[i][1] )  == r.end() ){\\n                       sum+=( (n-c.size())*q[i][2] ) ;\\n                       \\n                       r[q[i][1]]++ ;\\n                   }\\n               }\\n              else {\\n                   if(  c.find( q[i][1] )  == c.end() ){\\n                       sum+=((n-r.size())*q[i][2]) ;\\n                       cols++ ;\\n                       c[q[i][1]]++ ;\\n                   }\\n              }\\n         }\\n         return sum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601548,
                "title": "python-video-walkthrough-time-o-q-space-o-n-three-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/tQPI4lHed_s)\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        A, res = [set(), set()], 0\\n        for t,i,v in queries[::-1]: res, _ = res + v * (n - len(A[(t + 1) % 2])) * int(i not in A[t]), A[t].add(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        A, res = [set(), set()], 0\\n        for t,i,v in queries[::-1]: res, _ = res + v * (n - len(A[(t + 1) % 2])) * int(i not in A[t]), A[t].add(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601110,
                "title": "solution-reverse-iteration-o-n-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nProcess queries from last to first.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) where N = queries.size()\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> visRow(n), visCol(n);\\n        int cntVisRow = 0, cntVisCol = 0;\\n        for(int i = queries.size() - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n            if(type == 0) {\\n                if(visRow[index] == 0) {\\n                    ans += (long long)(n - cntVisCol) * value;\\n                    visRow[index] = 1;\\n                    cntVisRow++;\\n                }\\n            } else {\\n                if(visCol[index] == 0) {\\n                    ans += (long long)(n - cntVisRow) * value;\\n                    visCol[index] = 1;\\n                    cntVisCol++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        long long ans = 0;\\n        vector<int> visRow(n), visCol(n);\\n        int cntVisRow = 0, cntVisCol = 0;\\n        for(int i = queries.size() - 1; i >= 0; i--) {\\n            int type = queries[i][0];\\n            int index = queries[i][1];\\n            int value = queries[i][2];\\n            if(type == 0) {\\n                if(visRow[index] == 0) {\\n                    ans += (long long)(n - cntVisCol) * value;\\n                    visRow[index] = 1;\\n                    cntVisRow++;\\n                }\\n            } else {\\n                if(visCol[index] == 0) {\\n                    ans += (long long)(n - cntVisRow) * value;\\n                    visCol[index] = 1;\\n                    cntVisCol++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601040,
                "title": "easy-solution-by-taking-two-array",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int> row(n,0),col(n,0);\\n        int r=0,c=0;\\n        long long sum=0;\\n        for(int i=queries.size()-1;i>=0;i--)\\n        {\\n            int t=queries[i][0];\\n            int in = queries[i][1];\\n            int v = queries[i][2];\\n            if(t==1)\\n            {\\n                if(!row[in])\\n                {\\n                    sum=sum+(n-c)*v;\\n                    row[in]=1;\\n                    r++;\\n                }\\n            }\\n            if(t==0)\\n            {\\n                if(!col[in])\\n                {\\n                    sum+=(n-r)*v;\\n                    col[in]=1;\\n                    c++;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int> row(n,0),col(n,0);\\n        int r=0,c=0;\\n        long long sum=0;\\n        for(int i=queries.size()-1;i>=0;i--)\\n        {\\n            int t=queries[i][0];\\n            int in = queries[i][1];\\n            int v = queries[i][2];\\n            if(t==1)\\n            {\\n                if(!row[in])\\n                {\\n                    sum=sum+(n-c)*v;\\n                    row[in]=1;\\n                    r++;\\n                }\\n            }\\n            if(t==0)\\n            {\\n                if(!col[in])\\n                {\\n                    sum+=(n-r)*v;\\n                    col[in]=1;\\n                    c++;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600963,
                "title": "golang-o-n-reverse-order-traversal",
                "content": "# Intuition\\nFuture rows and columns will overwrite previous ones\\n\\n# Approach\\n- Traverse the queries array in reversed order\\n- Mark the row or column as visited\\n- Increaes sum\\n    - If `type == 0` inc with `q[i][2]` * `number of columns` then dec `number of rows` by `1`\\n    - If `type == 1` inc with `q[i][2]` * `number of rows` then dec `number of columns` by `1`\\n\\n# Complexity\\n- Time complexity: **O(len(q))**\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\nfunc matrixSumQueries(n int, q [][]int) int64 {\\n    var sum int\\n\\n    nrow := n\\n    ncolumn := n\\n    row := make(map[int]bool)\\n    column := make(map[int]bool)\\n\\n    for i := len(q)-1; i >= 0; i-- {\\n        if q[i][0] == 0 && !row[q[i][1]] {\\n            sum += ncolumn * q[i][2]\\n            row[q[i][1]] = true\\n            nrow--\\n        } \\n        if q[i][0] == 1 && !column[q[i][1]] {\\n            sum += nrow * q[i][2]\\n            column[q[i][1]] = true\\n            ncolumn--\\n        }\\n    }\\n    \\n    return int64(sum)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc matrixSumQueries(n int, q [][]int) int64 {\\n    var sum int\\n\\n    nrow := n\\n    ncolumn := n\\n    row := make(map[int]bool)\\n    column := make(map[int]bool)\\n\\n    for i := len(q)-1; i >= 0; i-- {\\n        if q[i][0] == 0 && !row[q[i][1]] {\\n            sum += ncolumn * q[i][2]\\n            row[q[i][1]] = true\\n            nrow--\\n        } \\n        if q[i][0] == 1 && !column[q[i][1]] {\\n            sum += nrow * q[i][2]\\n            column[q[i][1]] = true\\n            ncolumn--\\n        }\\n    }\\n    \\n    return int64(sum)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600857,
                "title": "typescript-easy-solution",
                "content": "# Approach\\n- Do reverse iteration through queries because latest rows and  cols have contribution to our final answer.\\n- Add visited rows and cols to hash set.\\n\\n# Complexity\\nTime O(length of queries)\\nSpace O(N)\\n\\n\\n# Code\\n```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n    let rowMap: Map<number, boolean> = new Map();\\n    let colMap: Map<number, boolean> = new Map();\\n    let sum: number = 0;\\n    for (let index = queries.length - 1; index >= 0; index--) {\\n        let val: number[] = queries[index];\\n        if (val[0] === 1 && !colMap.get(val[1])) {\\n            sum += val[2] * (n - rowMap.size)\\n            colMap.set(val[1], true);\\n        } else if (val[0] === 0 && !rowMap.get(val[1])) {\\n            sum += val[2] * (n - colMap.size);\\n            rowMap.set(val[1], true);\\n        }\\n    }\\n    return sum;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nfunction matrixSumQueries(n: number, queries: number[][]): number {\\n    let rowMap: Map<number, boolean> = new Map();\\n    let colMap: Map<number, boolean> = new Map();\\n    let sum: number = 0;\\n    for (let index = queries.length - 1; index >= 0; index--) {\\n        let val: number[] = queries[index];\\n        if (val[0] === 1 && !colMap.get(val[1])) {\\n            sum += val[2] * (n - rowMap.size)\\n            colMap.set(val[1], true);\\n        } else if (val[0] === 0 && !rowMap.get(val[1])) {\\n            sum += val[2] * (n - colMap.size);\\n            rowMap.set(val[1], true);\\n        }\\n    }\\n    return sum;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600804,
                "title": "start-from-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart from the end. This helps us in knowning any value will be changed in the future or not. If it is changed we dont add it in sum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q )\\n    {\\n        long long ans =0;\\n        reverse(q.begin(),q.end());\\n        vector<bool> row(n,false), col(n,false);\\n        int r=0,c=0;\\n        for(auto it : q)\\n        {\\n            int x = it[0],y = it[1],z= it[2];\\n            if(it[0] == 0 && !row[y])\\n            {\\n                 ans+= ((n-c)*z);\\n                 row[y] =true;\\n                 r++;\\n            }\\n            else if(it[0] == 1 && !col[y])\\n            {\\n                ans+=((n-r)*z);\\n                col[y]=true;\\n                c++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& q )\\n    {\\n        long long ans =0;\\n        reverse(q.begin(),q.end());\\n        vector<bool> row(n,false), col(n,false);\\n        int r=0,c=0;\\n        for(auto it : q)\\n        {\\n            int x = it[0],y = it[1],z= it[2];\\n            if(it[0] == 0 && !row[y])\\n            {\\n                 ans+= ((n-c)*z);\\n                 row[y] =true;\\n                 r++;\\n            }\\n            else if(it[0] == 1 && !col[y])\\n            {\\n                ans+=((n-r)*z);\\n                col[y]=true;\\n                c++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600575,
                "title": "o-n-solution-reverse-traversal-java",
                "content": "# Approach\\nO(N) solution with reverse order traversal\\n\\n# Complexity\\n- Time complexity:\\nO(q) : number of queries\\n\\n- Space complexity:\\nO(N) : number of row and column\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int N, int[][] queries) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        \\n        int rowSize = 0;\\n        int colSize = 0;\\n        long sum = 0;\\n        int n = queries.length;\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            if(queries[i][0] == 0) {\\n                if(!row.contains(queries[i][1])) {\\n                    row.add(queries[i][1]);\\n                    rowSize++;\\n                    sum += queries[i][2]*(N-colSize);\\n                }\\n            }\\n            else {\\n                if(!col.contains(queries[i][1])) {\\n                    col.add(queries[i][1]);\\n                    colSize++;\\n                    sum += queries[i][2]*(N-rowSize);\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int N, int[][] queries) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        \\n        int rowSize = 0;\\n        int colSize = 0;\\n        long sum = 0;\\n        int n = queries.length;\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            if(queries[i][0] == 0) {\\n                if(!row.contains(queries[i][1])) {\\n                    row.add(queries[i][1]);\\n                    rowSize++;\\n                    sum += queries[i][2]*(N-colSize);\\n                }\\n            }\\n            else {\\n                if(!col.contains(queries[i][1])) {\\n                    col.add(queries[i][1]);\\n                    colSize++;\\n                    sum += queries[i][2]*(N-rowSize);\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600573,
                "title": "o-n-solution-reverse-traversal-java",
                "content": "# Approach\\nO(N) solution with reverse order traversal\\n\\n# Complexity\\n- Time complexity:\\nO(q) : number of queries\\n\\n- Space complexity:\\nO(N) : number of row and column\\n\\n# Code\\n```\\nclass Solution {\\n    public long matrixSumQueries(int N, int[][] queries) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        \\n        int rowSize = 0;\\n        int colSize = 0;\\n        long sum = 0;\\n        int n = queries.length;\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            if(queries[i][0] == 0) {\\n                if(!row.contains(queries[i][1])) {\\n                    row.add(queries[i][1]);\\n                    rowSize++;\\n                    sum += queries[i][2]*(N-colSize);\\n                }\\n            }\\n            else {\\n                if(!col.contains(queries[i][1])) {\\n                    col.add(queries[i][1]);\\n                    colSize++;\\n                    sum += queries[i][2]*(N-rowSize);\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long matrixSumQueries(int N, int[][] queries) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        \\n        int rowSize = 0;\\n        int colSize = 0;\\n        long sum = 0;\\n        int n = queries.length;\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            if(queries[i][0] == 0) {\\n                if(!row.contains(queries[i][1])) {\\n                    row.add(queries[i][1]);\\n                    rowSize++;\\n                    sum += queries[i][2]*(N-colSize);\\n                }\\n            }\\n            else {\\n                if(!col.contains(queries[i][1])) {\\n                    col.add(queries[i][1]);\\n                    colSize++;\\n                    sum += queries[i][2]*(N-rowSize);\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600560,
                "title": "heavily-commented-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf following  by the word of what the question asks you to do and defining a n*n sized array, you will run out of heap space in large test cases and Node JS will throw an error.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe declare 2 sets of n length each instead and traverse the queries from the end since the newest values would have overwritten the older ones.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number}\\n*/\\n\\nvar matrixSumQueries = function(n, queries) {\\n\\n    //instead of declaring a n*n matrix to solve we declare 2 sets , n+n;\\n    let row = new Set(),\\n        col = new Set(),\\n        sum = 0;\\n\\n    queries.reverse(); // staring from end since newer values will overwrite older ones\\n\\n    for( [type,index,val] of queries ){\\n        if(!type){\\n            if(row.has(index))  continue;       //row already parsed by newer query\\n\\n            row.add(index);\\n            sum += val * (n - col.size)         //value * ( total size - number of newer command COLUMNS that overwrote it)\\n\\n        }\\n        else{\\n            if(col.has(index))  continue;       //col already parsed by newer query\\n\\n            col.add(index);\\n            sum += val * (n - row.size)         //value * ( total size - number of newer command ROWS that overwrote it)\\n\\n        }\\n    }\\n\\n    return sum;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number}\\n*/\\n\\nvar matrixSumQueries = function(n, queries) {\\n\\n    //instead of declaring a n*n matrix to solve we declare 2 sets , n+n;\\n    let row = new Set(),\\n        col = new Set(),\\n        sum = 0;\\n\\n    queries.reverse(); // staring from end since newer values will overwrite older ones\\n\\n    for( [type,index,val] of queries ){\\n        if(!type){\\n            if(row.has(index))  continue;       //row already parsed by newer query\\n\\n            row.add(index);\\n            sum += val * (n - col.size)         //value * ( total size - number of newer command COLUMNS that overwrote it)\\n\\n        }\\n        else{\\n            if(col.has(index))  continue;       //col already parsed by newer query\\n\\n            col.add(index);\\n            sum += val * (n - row.size)         //value * ( total size - number of newer command ROWS that overwrote it)\\n\\n        }\\n    }\\n\\n    return sum;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600538,
                "title": "simple-and-concise-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need to pay attention to the latest query operation on the item as it will over write the old value, so we need to track the rows and cols we are changing.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate through the list of queries in reverse order. For each op, use a counter and a set to keep track of the rows/cols you\\'re changing. The counter will help you to determine which all row/col items should be overwritten. The set will help you to avoid redundant overwrites, that is, if your last query overwrites the 2nd row, all previous ops on 2nd row can be ignored.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        r, c = 0, 0\\n        r_set, c_set = set(), set()\\n        sum = 0\\n        for q in reversed(queries):\\n            if q[0] == 0 and q[1] not in r_set:\\n                sum += q[2] * (n - c)\\n                r_set.add(q[1])\\n                r += 1 if r < n else 0\\n            if q[0] == 1 and q[1] not in c_set:\\n                sum += q[2] * (n - r)\\n                c_set.add(q[1])\\n                c += 1 if c < n else 0\\n\\n        return sum\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n        r, c = 0, 0\\n        r_set, c_set = set(), set()\\n        sum = 0\\n        for q in reversed(queries):\\n            if q[0] == 0 and q[1] not in r_set:\\n                sum += q[2] * (n - c)\\n                r_set.add(q[1])\\n                r += 1 if r < n else 0\\n            if q[0] == 1 and q[1] not in c_set:\\n                sum += q[2] * (n - r)\\n                c_set.add(q[1])\\n                c += 1 if c < n else 0\\n\\n        return sum\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600461,
                "title": "simple-o-n-reverse-iteration-full-explanation-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the reverse iteration the operation performed will be fixed and can\\'t be overwriiten.\\nUsing this logic once row or column operation is performed the value is fixed and can\\'t be change for the next column or row operation respectively.\\nWe maintain the row and column count for the fixed values and thus for next column operation we subtract the fixed rows and then add the the value to result, \\nsimilarly for next row operation we subtract the fixed column and then add the value to result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int row=0, col=0;\\n\\n        vector<pair<int,int>> rowhead(n,make_pair(0,-1)), colhead(n,make_pair(0,-1));\\n        long long result = 0;\\n        for(int i=queries.size()-1; i>=0; i--) {\\n            if(queries[i][0]==0) {\\n                if(rowhead[queries[i][1]].second==-1) {\\n                    result += (n-col)*queries[i][2];\\n                    rowhead[queries[i][1]].first = queries[i][2];\\n                    rowhead[queries[i][1]].second = i;\\n                    row++;\\n                }\\n            } else {\\n                if(colhead[queries[i][1]].second==-1) {\\n                    result += (n-row)*queries[i][2];\\n                    colhead[queries[i][1]].first = queries[i][2];\\n                    colhead[queries[i][1]].second = i;\\n                    col++;\\n                }\\n            }\\n        }\\n\\n        \\n        return result;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long matrixSumQueries(int n, vector<vector<int>>& queries) {\\n        int row=0, col=0;\\n\\n        vector<pair<int,int>> rowhead(n,make_pair(0,-1)), colhead(n,make_pair(0,-1));\\n        long long result = 0;\\n        for(int i=queries.size()-1; i>=0; i--) {\\n            if(queries[i][0]==0) {\\n                if(rowhead[queries[i][1]].second==-1) {\\n                    result += (n-col)*queries[i][2];\\n                    rowhead[queries[i][1]].first = queries[i][2];\\n                    rowhead[queries[i][1]].second = i;\\n                    row++;\\n                }\\n            } else {\\n                if(colhead[queries[i][1]].second==-1) {\\n                    result += (n-row)*queries[i][2];\\n                    colhead[queries[i][1]].first = queries[i][2];\\n                    colhead[queries[i][1]].second = i;\\n                    col++;\\n                }\\n            }\\n        }\\n\\n        \\n        return result;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600360,
                "title": "so-what-s-wrong-with-this-code",
                "content": "I can\\'t find what\\'s wrong with this code? \\n\\n\\n```java\\n    public static long matrixSumQueries(int n, int[][] queries) {\\n        Map<Integer, Integer> rows = new HashMap<>();\\n        Map<Integer, Integer> cols = new HashMap<>();\\n\\n        long ans = 0;\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int value = queries[i][2];\\n\\n            if (type == 0) {\\n                int prev = rows.getOrDefault(idx, 0);\\n\\n                ans += (long) (value - prev) * (n - cols.size());\\n\\n                for (int x : cols.values()) {\\n                    ans += value - x;\\n                }\\n\\n                rows.put(idx, value);\\n            } else {\\n                int prev = cols.getOrDefault(idx, 0);\\n\\n                ans += (long) (value - prev) * (n - rows.size());\\n\\n                for (int x : rows.values()) {\\n                    ans += value - x;\\n                }\\n\\n                cols.put(idx, value);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```java\\n    public static long matrixSumQueries(int n, int[][] queries) {\\n        Map<Integer, Integer> rows = new HashMap<>();\\n        Map<Integer, Integer> cols = new HashMap<>();\\n\\n        long ans = 0;\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int type = queries[i][0];\\n            int idx = queries[i][1];\\n            int value = queries[i][2];\\n\\n            if (type == 0) {\\n                int prev = rows.getOrDefault(idx, 0);\\n\\n                ans += (long) (value - prev) * (n - cols.size());\\n\\n                for (int x : cols.values()) {\\n                    ans += value - x;\\n                }\\n\\n                rows.put(idx, value);\\n            } else {\\n                int prev = cols.getOrDefault(idx, 0);\\n\\n                ans += (long) (value - prev) * (n - rows.size());\\n\\n                for (int x : rows.values()) {\\n                    ans += value - x;\\n                }\\n\\n                cols.put(idx, value);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1915956,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916121,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915938,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916145,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916996,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916193,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915953,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916012,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915961,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916447,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915956,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916121,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915938,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916145,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916996,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916193,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915953,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916012,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1915961,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1916447,
                "content": [
                    {
                        "username": "parth2612",
                        "content": "seemed easy at first but gave TLE :\")\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "This question smells like hard."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "But after reversing the queries , smells like easy...\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "TLE \\uD83D\\uDE16"
                    },
                    {
                        "username": "yash_leee",
                        "content": "[@user7189w](/user7189w) same bro\\n"
                    },
                    {
                        "username": "HNcodes",
                        "content": "[@user7189w](/user7189w) same \\n"
                    },
                    {
                        "username": "user7189w",
                        "content": "Mine too. I did the question by looping through each of the queries. What about you?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "Made 3 penalties, but a beautiful problem indeed !!"
                    },
                    {
                        "username": "tejasX",
                        "content": "If only intuition of going from RIGHT to LEFT had clicked !!"
                    },
                    {
                        "username": "15o1",
                        "content": "Iterate the queries in reverse order, and keep track of the already visited row and column number throughout the the iteration.\\n\\nReason : As we have been asked to give the sum of the matrix after all edit queries, the intuition comes up that the recent query will have more impact on the matrix than the least recent ones. Therefore we iterate from right to left and update the row or column which is not visited.\\n\\nHope it helps"
                    },
                    {
                        "username": "CalCreate",
                        "content": "[@ankurgoswami718](/ankurgoswami718) the previous row and col can not be updated again if you are going backwards because only the last overwrite will matter, thus you can ignore completely any call to the row or column before this."
                    },
                    {
                        "username": "15o1",
                        "content": "[@ankurgoswami718](/ankurgoswami718) no, not if we are iterating in reverse order.\\nReason : Suppose a row is update 10 times in queries , then which update will be considered as the most useful? Obviously the latest one. Therefore we traverse in reverse order and process all the latest update and ignore all the updates on the already updated row or column.\\nHope it helps!"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "can the entire same row or col be updated again ?"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "Getting TLE on empty value of n.\nNot sure where exactly I am going wrong.\npasses 2687 of 2688 test cases."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "same"
                    },
                    {
                        "username": "Babu_frik",
                        "content": "[@kumarrounakjha](/kumarrounakjha) Missed those 5 points in the contest :("
                    },
                    {
                        "username": "kumarrounakjha",
                        "content": "Oh my God!!!!!!!!!!"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "Process the queries in reversed order because if you process from forward , you will have to update matrix each time..\\nBy processing in reverse , you make sure that no further changes can be made on that row or column."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@vaibhavtale](/vaibhavtale) You dont have to update the complete matrix , you have to keep updating the sum only . Hence time complexity will be linear ."
                    },
                    {
                        "username": "vaibhavtale",
                        "content": "won\\'t we get TLE for such approach.\\n"
                    },
                    {
                        "username": "Prajju22",
                        "content": "can anyone tell the right approach for such problem? only 2284 / 2688 passed"
                    },
                    {
                        "username": "Prajju22",
                        "content": "[@pranay219](/pranay219) thankyou\\n"
                    },
                    {
                        "username": "pranay219",
                        "content": "I think you have traversed queries in reverse order right..  but you need to make sure that no further changes can be made on already processed  row or column.\\nfor that you can use hashmap or a hashset \\ncheck this testcase..\\n\\n8\\n[[0,6,30094],[0,7,99382],[1,2,18599],[1,3,49292],[1,0,81549],[1,1,38280],[0,0,19405],[0,4,30065],[1,4,60826],[1,5,9241],[0,5,33729],[0,1,41456],[0,2,62692],[0,3,30807],[1,7,70613],[1,6,9506],[0,5,39344],[1,0,44658],[1,1,56485],[1,2,48112],[0,6,43384]]"
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "https://leetcode.com/problems/sum-of-matrix-after-queries/solutions/3595259/on-simple-and-very-easy-to-understand-java/"
                    },
                    {
                        "username": "AulySun",
                        "content": "brute force 2676/2688."
                    },
                    {
                        "username": "nasheerkhan8740",
                        "content": "n = 1 , [[0,0,7]]  expected sum 7 but actual is 21 ? can anyone explain   "
                    },
                    {
                        "username": "ngocdangrby",
                        "content": "matrix\\'s size is nxn is not 3x3. i just figured out"
                    }
                ]
            },
            {
                "id": 1947988,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1939923,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1936163,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1931174,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1918460,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1916908,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1916871,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1916470,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1916257,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            },
            {
                "id": 1916202,
                "content": [
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "Why it shows Memory Limited Exceeded ? \\nis there any other approach suggest me \\n class Solution {\\n    public long matrixSumQueries(int n, int[][] queries) \\n    {\\n        int arr [][] = new int [n][n];\\n        long sum =0;\\n         for(int [] a: queries)\\n         {\\n              if(a[0]==0)\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[a[1]][i] = a[2];\\n            }\\n            else\\n            {\\n                for(int i=0;i<n;i++)\\n                arr[i][a[1]]=a[2];\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n             for(int j=0;j<n;j++)\\n                 sum+=arr[i][j];\\n         return sum;\\n    }  \\n}"
                    },
                    {
                        "username": "anhphamhoang033",
                        "content": "first i thought why it so easy :) until i submitted :)"
                    },
                    {
                        "username": "itsSlumpBro",
                        "content": " `class Solution(object):\\n    def matrixSumQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: inte\\n        \"\"\"\\n        # Initialize an nxn matrix filled with zeroes.\\n        matrix = [[0]*n for _ in range(n)]\\n        for i in range(len(queries)):\\n            #the first position of each subarray contains the type, we check to see if the type is 0 or 1 and do things based on that\\n            if queries[i][0] == 0:\\n                #replace the values in the ROW index to val\\n                #the second position in each subarray of queries tells us which index row to change\\n                #the third position (remember 0-indexed) takes us to the value that we need to use to change the row\\n            #we need to update every value in the row\\n                for j in range(n):\\n                    matrix[queries[i][1]][j] = queries[i][2]\\n            if queries[i][0] == 1:\\n                for j in range(n):\\n                    matrix[j][queries[i][1]] = queries[i][2]\\n        sum = 0\\n        for i in range(n):\\n            for j in range(0, n):\\n                sum += matrix[i][j]\\n        return sum`\\n\\ni am passing all the test cases but getting a time limit exceeded. I am not sure what I\\'m doing wrong here, is the nested loop causing this?"
                    },
                    {
                        "username": "Madian",
                        "content": "why why 2676 / 2688 testcases passed????"
                    },
                    {
                        "username": "_Prashant_Karwasra",
                        "content": "TLE :\") Emotional Damage!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Traverse in reverse order\\n2. Don\\'t sum already calculated row/column"
                    },
                    {
                        "username": "b2kumar",
                        "content": "Any approach without iterating in reverse order..."
                    },
                    {
                        "username": "tanujgarg37",
                        "content": "What is the error in solution in which i am using two sets to see which rows,col have been visited and then when queries is 0 then use (n - col.count(queries[i][1])) * queries[i][2]) and add it to sum and when queries is 1 then add (n - rows.count(queries[i][1])) * queries[i][2]; this to sum\\n"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "I did it using binary search and prefix sums, overcomplicated it"
                    },
                    {
                        "username": "HarishRa9a",
                        "content": "\\uD83D\\uDE02SAME"
                    },
                    {
                        "username": "matthew106",
                        "content": "This is one hard medium :)"
                    }
                ]
            }
        ]
    }
]