[
    {
        "title": "Maximum Product of the Length of Two Palindromic Substrings",
        "question_content": "You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized.\nMore formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive.\nReturn the maximum possible product of the lengths of the two non-intersecting palindromic substrings.\nA palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\n&nbsp;\nExample 1:\n\nInput: s = \"ababbb\"\nOutput: 9\nExplanation: Substrings \"aba\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.\n\nExample 2:\n\nInput: s = \"zaaaxbbby\"\nOutput: 9\nExplanation: Substrings \"aaa\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.\n\n&nbsp;\nConstraints:\n\n\t2 <= s.length <= 105\n\ts consists of lowercase English letters.",
        "solutions": [
            {
                "id": 1389958,
                "title": "manacher-and-queue",
                "content": "Finding the longest palindrome in `[i, j]` is trivial using quadratic DP. Then, we can just find the biggest product of `[0, i] * [i + 1, n)`, moving the split point `i` left-to-right. However, quadratic would be too slow for n = 100,000.\\n \\nManacher\\'s algorithm (easy to find online) can identify all palindromes in O(n). It has two flavors for finding odd and even palindromes. Fortunately, we only care about odd palindromes here,  which is the simpler case.\\n\\nFor each position as the center of the palindrome, the algorithm finds how far the palindrome extends left and right. For example, for string `\"aaabaaaba\"`, the result will be `[1, 2, 1, 4, 1, 2, 2]`. And true - from position `3`, the palindrome extends 4 characters (the initial character is included) left and right, giving us \"aaa**b**aaa\".\\n\\nThis output needs additional massaging to tell the longest palindrome in `[0, i]` and [`i + 1, n)`. Re-using the above example, we are looking for something like this:\\n- Left-to-right (`[0, i]`): `[1, 1, 3, 3, 3, 5, 7, 7, 7]`\\n- Right-to-left (`[i, n]`): `[7, 7, 7, 5, 3, 3, 3, 1, 1]`\\n\\nFor this example, the maximum product is 15, with parts being `[0, 2]` and `[3, 8]`: `3 * 5`.\\n\\nThis transformation was the hardest part for me. I tried a few simpler approaches, which work for some test cases but not for the others. I had to brush up a bit on how Manacher\\'s algorithm works to figure out the transformation using a queue (the front of the queue is the center of the engulfing palindrome).\\n\\n> Update: we can also modify Manacher\\'s algo to produce the output we need. In this case, we will run that algo twice - for the original and inverted string. See approach 2 below. The idea was proposed by [thin_k_ing](https://leetcode.com/thin_k_ing/).\\n\\n#### Approach 1: Manacher and Queue\\n**C++**\\n```cpp\\nlong long maxProduct(string s) {\\n    long long res = 0, l = 0, n = s.size();\\n    vector<int> m(n), r(n);\\n    // Manacher\\'s Algorithm (https://cp-algorithms.com/string/manacher.html)\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    queue<array<int, 2>> q, q1;\\n    // Right-to-left to track max palindrome in [i, n).\\n    for (int i = n - 1; i >= 0; --i) {\\n        while (!q.empty() && q.front()[0] - q.front()[1] > i - 1)\\n            q.pop();\\n        r[i] = 1 + (q.empty() ? 0 : (q.front()[0] - i) * 2);\\n        q.push({i, m[i]});\\n    }\\n    // Left-to-right to track max palindrome in [0, i].\\n    for (int i = 0; i < n - 1; i += 1) {\\n        while (!q1.empty() && q1.front()[0] + q1.front()[1] < i + 1)\\n            q1.pop();\\n        l = max(l, 1ll + (q1.empty() ? 0 : (i - q1.front()[0]) * 2));\\n        res = max(res, l * r[i + 1]);\\n        q1.push({i, m[i]});\\n    }\\n    return res;\\n}\\n```\\n#### Approach 2: Modified Manacher\\n**C++**\\n```cpp\\nvector<int> manachers(string s, int n) {\\n    vector<int> m(n), l2r(n, 1);\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            l2r[i + k] = 2 * k + 1;\\n            k++;\\n        }\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    for(int i = 1; i < n; i++) \\n        l2r[i] = max(l2r[i], l2r[i - 1]);\\n    return l2r;\\n}\\nlong long maxProduct(string s) {\\n    long long res = 1, n = s.size();\\n    auto l2r = manachers(s, n), r2l = manachers(string(rbegin(s), rend(s)), n);\\n    for (int i = 0, j = n - 2; i < n - 1; ++i, --j)\\n        res = max(res, (long long)l2r[i] * r2l[j]);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long maxProduct(string s) {\\n    long long res = 0, l = 0, n = s.size();\\n    vector<int> m(n), r(n);\\n    // Manacher\\'s Algorithm (https://cp-algorithms.com/string/manacher.html)\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    queue<array<int, 2>> q, q1;\\n    // Right-to-left to track max palindrome in [i, n).\\n    for (int i = n - 1; i >= 0; --i) {\\n        while (!q.empty() && q.front()[0] - q.front()[1] > i - 1)\\n            q.pop();\\n        r[i] = 1 + (q.empty() ? 0 : (q.front()[0] - i) * 2);\\n        q.push({i, m[i]});\\n    }\\n    // Left-to-right to track max palindrome in [0, i].\\n    for (int i = 0; i < n - 1; i += 1) {\\n        while (!q1.empty() && q1.front()[0] + q1.front()[1] < i + 1)\\n            q1.pop();\\n        l = max(l, 1ll + (q1.empty() ? 0 : (i - q1.front()[0]) * 2));\\n        res = max(res, l * r[i + 1]);\\n        q1.push({i, m[i]});\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<int> manachers(string s, int n) {\\n    vector<int> m(n), l2r(n, 1);\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            l2r[i + k] = 2 * k + 1;\\n            k++;\\n        }\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    for(int i = 1; i < n; i++) \\n        l2r[i] = max(l2r[i], l2r[i - 1]);\\n    return l2r;\\n}\\nlong long maxProduct(string s) {\\n    long long res = 1, n = s.size();\\n    auto l2r = manachers(s, n), r2l = manachers(string(rbegin(s), rend(s)), n);\\n    for (int i = 0, j = n - 2; i < n - 1; ++i, --j)\\n        res = max(res, (long long)l2r[i] * r2l[j]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389421,
                "title": "python-o-n-with-manacher-explained",
                "content": "In this problem we deal with palindromes, so it is good idea to think about Manachers algorithm, because the length of our string is quite big. For more details, you can go to wikipedia, imagine now that we have result already for manacher algorithm and now we want to work with results it gave to us. On leetcode contest you do not need to code it youself, you can find template online, and you should know how to use it. Let us consider string \\n\\n`abayabyxaba`, \\n\\nthen we have the following result:\\n\\n`[1, 3, 1, 5, 1, 1, 1, 1, 1, 3, 1]`\\n\\nThat is for index `0` we have palindrome `a`, for index `2` it is `aba`, then `a`, then `bayab` and so on. What we need to do with this information? Let us construct intervals:\\n`ints = [(0, 0), (0, 2), (2, 2), (1, 5), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (8, 10), (10, 10)]` it is the size of biggest intervals for each middle point.\\n\\nNow, we need to solve the following problem: let us fix point `i`, so all string `s` will be separated into two parts:\\n`----------|---------`.  What we want to find is the biggest length of palindrom on the left and the biggest length of palindrome on the right, multiply them and do it for every `i` we have. If we do it directly, we will have `O(n^2)`, so we need to think about something better.\\n\\nLet us ask the question: given `i`, what is the maximum length of palindrome, which we meet before `i`? \\n1. Create empty array `arr1 = [0]*n`\\n2. For `a, b in ints`, that is for all intervals we have, update `arr1[b]` with length of interval. It can happen, that we have several intervals ending on the same points, so we use `max` here. After this update we have `[1, 0, 3, 0, 1, 5, 1, 1, 1, 0, 3]`.\\n3. It is imortant, and I forgot it on contest, and was not able to do it on time: we need to check `arr1[i+1] - 2` for each element. Imagine, that we have `[1, 1, 3, 1, 3, 5, 1, 1, 1, 1, 3]`. Note for example that `arr1[4]` was equal to `1` because there is only one segment ending with it. However `arr1[5] = 5` and we have `.bayab...`, so we can be sure that length of palindrome ending with place `4` is at least `arr1[5] - 2 = 3`.\\n4. Finally, we need to evaluate cumulative maximums of `arr1`: `[1, 1, 3, 3, 3, 5, 5, 5, 5, 5, 5]`. Now what we have is answer for the question: given `i`, what is the maximum lengh of palindrome lying before `i`.\\n\\nNow, we need to do exaclty the same logic for question: `what is the maximum length of palindrome after i`? We can use exactly the same function `helper` and reverse results!\\n\\nFinally, when we have answer for two questions:  `what is the maximum length of palindrome after i`? and  `what is the maximum length of palindrome before i`? - we can iterate over all indexes `i` and return `max`.\\n\\n#### Complexity\\nIt is `O(n)` to apply manacher and then we have several `O(n)` passes, so total complexity is `O(n)` both for time and space.\\n\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxProduct(self, s):\\n        def manachers(S):\\n            A = \\'@#\\' + \\'#\\'.join(S) + \\'#$\\'\\n            Z = [0] * len(A)\\n            center = right = 0\\n            for i in range(1, len(A) - 1):\\n                if i < right:\\n                    Z[i] = min(right - i, Z[2 * center - i])\\n                while A[i + Z[i] + 1] == A[i - Z[i] - 1]:\\n                    Z[i] += 1\\n                if i + Z[i] > right:\\n                    center, right = i, i + Z[i]\\n            return Z[2:-2:2]\\n\\n        def helper(s):\\n            man, n = manachers(s), len(s)\\n            ints = [(i - man[i]//2, i + man[i]//2) for i in range(n)]\\n            arr = [0]*n\\n            for a, b in ints: \\n                arr[b] = max(arr[b], b - a + 1)\\n            for i in range(n-2, -1, -1):\\n                arr[i] = max(arr[i], arr[i + 1] - 2)\\n            return list(accumulate(arr, max))\\n        \\n        t1, t2 = helper(s), helper(s[::-1])[::-1][1:] + [0]   \\n        return max(x*y for x, y in zip(t1, t2))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProduct(self, s):\\n        def manachers(S):\\n            A = \\'@#\\' + \\'#\\'.join(S) + \\'#$\\'\\n            Z = [0] * len(A)\\n            center = right = 0\\n            for i in range(1, len(A) - 1):\\n                if i < right:\\n                    Z[i] = min(right - i, Z[2 * center - i])\\n                while A[i + Z[i] + 1] == A[i - Z[i] - 1]:\\n                    Z[i] += 1\\n                if i + Z[i] > right:\\n                    center, right = i, i + Z[i]\\n            return Z[2:-2:2]\\n\\n        def helper(s):\\n            man, n = manachers(s), len(s)\\n            ints = [(i - man[i]//2, i + man[i]//2) for i in range(n)]\\n            arr = [0]*n\\n            for a, b in ints: \\n                arr[b] = max(arr[b], b - a + 1)\\n            for i in range(n-2, -1, -1):\\n                arr[i] = max(arr[i], arr[i + 1] - 2)\\n            return list(accumulate(arr, max))\\n        \\n        t1, t2 = helper(s), helper(s[::-1])[::-1][1:] + [0]   \\n        return max(x*y for x, y in zip(t1, t2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390099,
                "title": "java-rolling-hash-solution-o-n-c-and-python-versions-in-comments",
                "content": "Prepare rolling hash for the string and its reverse. A substring is palindromic if its hash and hash for it\\'s reversion are equal.\\nThis solution don\\'t check possible collisions. Also it uses fact that if maximum palindrome has end at i and its length is L, then there\\'s a palindrome of length L-2 with end at position i-1. Same fact for beginnings of palindromes. Also we don\\'t need to find the longest plaindrome for each position if its length is less than previously found.\\n\\nTime complexity - O(n), space compelxity - O(n).\\n\\nAlso you can see my solution using Manacher\\'s algorithm there\\nhttps://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/discuss/1389859/Java-Manacher-algorithm-O(n)\\n\\n```\\npublic class Solution {\\n    private static final long base = 29L;\\n    private static final long mod = Integer.MAX_VALUE;\\n\\n    private static boolean isPalindromic(int l, int r, long[] lh, long[] rh, long[] pow) {\\n        return lh(l, r, lh, pow) == rh(l, r, rh, pow);\\n    }\\n\\n    private static long lh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[r] - hash[l] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    private static long rh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[l] - hash[r] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n\\n        long[] pow = new long[n + 1]; // pow[i] = BASE^i\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = pow[i - 1] * base % mod;\\n\\n        long[] lh = new long[n + 1]; // hash[i] is hash value from str[0..i)\\n        for (int i = 1; i <= n; i++) lh[i] = (lh[i - 1] * base + s.charAt(i - 1) - \\'a\\') % mod;\\n\\n        long[] rh = new long[n + 1]; // hash[i] is hash value from str[i..n)\\n        for (int i = n - 1; i >= 0; i--) rh[i] = (rh[i + 1] * base + s.charAt(i) - \\'a\\') % mod;\\n\\n        int[] left = new int[n];\\n        for (int i = 0, max = 1; i < n; i++) {\\n            if (max < i && isPalindromic(i - max - 1, i + 1, lh, rh, pow)) max += 2;\\n            left[i] = max;\\n        }\\n\\n        int[] right = new int[n];\\n        for (int i = n - 1, max = 1; i >= 0; i--) {\\n            if (i + max + 2 <= n && isPalindromic(i, i + max + 2, lh, rh, pow)) max += 2;\\n            right[i] = max;\\n        }\\n\\n        long ans = 1;\\n        for (int i = 1; i < n; i++) ans = Math.max(ans, (long) left[i - 1] * right[i]);\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Rolling Hash"
                ],
                "code": "```\\npublic class Solution {\\n    private static final long base = 29L;\\n    private static final long mod = Integer.MAX_VALUE;\\n\\n    private static boolean isPalindromic(int l, int r, long[] lh, long[] rh, long[] pow) {\\n        return lh(l, r, lh, pow) == rh(l, r, rh, pow);\\n    }\\n\\n    private static long lh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[r] - hash[l] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    private static long rh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[l] - hash[r] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n\\n        long[] pow = new long[n + 1]; // pow[i] = BASE^i\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = pow[i - 1] * base % mod;\\n\\n        long[] lh = new long[n + 1]; // hash[i] is hash value from str[0..i)\\n        for (int i = 1; i <= n; i++) lh[i] = (lh[i - 1] * base + s.charAt(i - 1) - \\'a\\') % mod;\\n\\n        long[] rh = new long[n + 1]; // hash[i] is hash value from str[i..n)\\n        for (int i = n - 1; i >= 0; i--) rh[i] = (rh[i + 1] * base + s.charAt(i) - \\'a\\') % mod;\\n\\n        int[] left = new int[n];\\n        for (int i = 0, max = 1; i < n; i++) {\\n            if (max < i && isPalindromic(i - max - 1, i + 1, lh, rh, pow)) max += 2;\\n            left[i] = max;\\n        }\\n\\n        int[] right = new int[n];\\n        for (int i = n - 1, max = 1; i >= 0; i--) {\\n            if (i + max + 2 <= n && isPalindromic(i, i + max + 2, lh, rh, pow)) max += 2;\\n            right[i] = max;\\n        }\\n\\n        long ans = 1;\\n        for (int i = 1; i < n; i++) ans = Math.max(ans, (long) left[i - 1] * right[i]);\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389706,
                "title": "python3-hashing-nlogn-accepted",
                "content": "Idea:\\n1. We can compute hash for all prefixes and suffixes in linear time.\\n2. Then we can find if `a[i-k:i +k]` is palindrome in costant time.\\n3. So we can find the longest palindrome in logarithmic time by applying binary search.\\n4. Then we can find the longest for all `i` in linearithmic time.\\n5. Then just iterate over the finding to get the final result (similar to all other solutions).\\n\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        alphabet_size = 26\\n        mod = 10 ** 9 + 7\\n        straight_hash = [0] * len(s)\\n        reverse_hash = [0] * len(s)\\n        for i in range(len(s)):\\n            straight_hash[i] = (straight_hash[i - 1] * alphabet_size + ord(s[i]) - ord(\"a\")) % mod\\n            reverse_hash[~i] = (reverse_hash[~i + 1] * alphabet_size + ord(s[~i]) - ord(\"a\")) % mod\\n        straight_hash.append(0)\\n        reverse_hash.append(0)\\n\\n        longest_palindrome_from_left = [0] * len(s)\\n        longest_palindrome_from_right = [0] * len(s)\\n        for i in range(len(s)):\\n            low = 1\\n            high = min(i + 1, len(s) - i)\\n            \\n            if 0 < i < len(s) - 1 and s[i - 1] == s[i + 1]:     # hack (otherwise TLE): don\\'t run binary search if adjecent letters are different\\n                while low < high:\\n                    mid = (low + high + 1) // 2\\n                    m = pow(alphabet_size, mid, mod)\\n                    if (straight_hash[i] - straight_hash[i - mid] * m) % mod == (reverse_hash[i] - reverse_hash[i + mid] * m) % mod:\\n                        low = mid\\n                    else:\\n                        high = mid - 1\\n            longest_palindrome_from_left[i + low - 1] = max(low * 2 - 1, longest_palindrome_from_left[i + low - 1])\\n            longest_palindrome_from_right[i - low + 1] = max(low * 2 - 1, longest_palindrome_from_right[i - low + 1])\\n\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[i] = max(longest_palindrome_from_left[i], longest_palindrome_from_left[i - 1])\\n            longest_palindrome_from_right[~i] = max(longest_palindrome_from_right[~i], longest_palindrome_from_right[~i + 1])\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[~i] = max(longest_palindrome_from_left[~i], longest_palindrome_from_left[~i + 1] - 2)\\n            longest_palindrome_from_right[i] = max(longest_palindrome_from_right[i], longest_palindrome_from_right[i - 1] - 2)\\n\\n        res = 0\\n        for i in range(1, len(s)):\\n            res = max(res, longest_palindrome_from_left[i - 1] * longest_palindrome_from_right[i])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        alphabet_size = 26\\n        mod = 10 ** 9 + 7\\n        straight_hash = [0] * len(s)\\n        reverse_hash = [0] * len(s)\\n        for i in range(len(s)):\\n            straight_hash[i] = (straight_hash[i - 1] * alphabet_size + ord(s[i]) - ord(\"a\")) % mod\\n            reverse_hash[~i] = (reverse_hash[~i + 1] * alphabet_size + ord(s[~i]) - ord(\"a\")) % mod\\n        straight_hash.append(0)\\n        reverse_hash.append(0)\\n\\n        longest_palindrome_from_left = [0] * len(s)\\n        longest_palindrome_from_right = [0] * len(s)\\n        for i in range(len(s)):\\n            low = 1\\n            high = min(i + 1, len(s) - i)\\n            \\n            if 0 < i < len(s) - 1 and s[i - 1] == s[i + 1]:     # hack (otherwise TLE): don\\'t run binary search if adjecent letters are different\\n                while low < high:\\n                    mid = (low + high + 1) // 2\\n                    m = pow(alphabet_size, mid, mod)\\n                    if (straight_hash[i] - straight_hash[i - mid] * m) % mod == (reverse_hash[i] - reverse_hash[i + mid] * m) % mod:\\n                        low = mid\\n                    else:\\n                        high = mid - 1\\n            longest_palindrome_from_left[i + low - 1] = max(low * 2 - 1, longest_palindrome_from_left[i + low - 1])\\n            longest_palindrome_from_right[i - low + 1] = max(low * 2 - 1, longest_palindrome_from_right[i - low + 1])\\n\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[i] = max(longest_palindrome_from_left[i], longest_palindrome_from_left[i - 1])\\n            longest_palindrome_from_right[~i] = max(longest_palindrome_from_right[~i], longest_palindrome_from_right[~i + 1])\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[~i] = max(longest_palindrome_from_left[~i], longest_palindrome_from_left[~i + 1] - 2)\\n            longest_palindrome_from_right[i] = max(longest_palindrome_from_right[i], longest_palindrome_from_right[i - 1] - 2)\\n\\n        res = 0\\n        for i in range(1, len(s)):\\n            res = max(res, longest_palindrome_from_left[i - 1] * longest_palindrome_from_right[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396545,
                "title": "python-rolling-hash-binary-search-with-code-comments",
                "content": "Got the idea from post \\nhttps://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/discuss/1389706/Python3.-Hashing.-NlogN.-Accepted.\\nand added more explanations.\\n\\nThe idea is to decompose the problem into subproblems:\\n1. Create rolling hash from left and from right. This is O(n).\\n2. Judge if it is a palindrome with a given center and given radius in O(1) time. This is done by comparing hash value.\\n3. Use each position as center, find the longest parlindrome extension. This is done by binary search, with step 2 as a subproblem, in total O (n log(n) ).\\n4. Now we know the max len parlindrome ending at a position from both left and right, apply next array type idea to get the final answer: to get the max len till a position (not necessarily ending with it), it has two cases to consider, see code comments..\\n\\nOverall, the time limit is pretty tight, guess applying Manacher is faster (O(n) ) but I don\\'t have that knowledge.\\n\\n```\\nclass Solution:\\n    \\n    def maxProduct(self, s: str) -> int:\\n        mod = 10**9 + 7\\n        base = 27\\n        n = len(s)\\n        forward_hash = [0] * (len(s) + 1)\\n        backward_hash = [0] * (len(s) + 1)\\n        for i in range(1, n+1):\\n            forward_hash[i] = (forward_hash[i-1] * base + (ord(s[i-1]) - ord(\\'a\\'))) % mod\\n        for i in range(n-1, -1, -1):\\n            backward_hash[i] = (backward_hash[i+1] * base + (ord(s[i]) - ord(\\'a\\'))) % mod\\n            \\n        def is_parlin(s, center, l):\\n            # check if it is a palin, with l being the radius\\n            # [left, center-1] vs [center+1, right]\\n            p = pow(base, l, mod)\\n            left_hash = (forward_hash[center] - forward_hash[center-l] * p) % mod\\n            right_hash = (backward_hash[center+1] - backward_hash[center+l+1] * p) % mod\\n            return left_hash == right_hash\\n        \\n        # inclusive\\n        before_idx_max_len = [1] * n\\n        after_idx_max_len = [1] * n\\n        \\n        # for each center, expand\\n        for i in range(1, n-1):\\n            max_radius = 1\\n            if s[i-1] != s[i+1]: # radius = 1 fails\\n                continue\\n            # find the largest extention so that [center+1, right] is the same as [left, center-1]\\n            start, end = 1, min(i, n-i)\\n            while start + 1 < end:\\n                mid = (start + end) // 2\\n                if is_parlin(s, i, mid):\\n                    start = mid\\n                else:\\n                    end = mid\\n            if i + end < n and is_parlin(s, i, end):\\n                max_radius = end\\n            else:\\n                max_radius = start\\n                \\n            left = i - max_radius\\n            right = i + max_radius\\n            before_idx_max_len[right] = max(before_idx_max_len[right], 2*max_radius+1)\\n            after_idx_max_len[left] = max(after_idx_max_len[left], 2*max_radius+1)\\n        \\n        # handle trick case1: if ending with i is palin with len, then end with i-1 should be parlin with at least len-2!\\n        for i in range(n-2, -1, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i], before_idx_max_len[i+1]-2)\\n        for i in range(1, n):\\n            after_idx_max_len[i] = max(after_idx_max_len[i], after_idx_max_len[i-1]-2)\\n        \\n        # case2: find max till now using next array\\n        for i in range(n-1, 0, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i-1], before_idx_max_len[i])\\n        for i in range(n-2, -1, -1):\\n            after_idx_max_len[i] = max(after_idx_max_len[i+1], after_idx_max_len[i])\\n        \\n        # print(before_idx_max_len, after_idx_max_len)\\n        # find the best possible\\n        res = 1\\n        for i in range(n-1):\\n            res = max(res, before_idx_max_len[i] * after_idx_max_len[i+1])\\n            \\n        return res\\n",
                "solutionTags": [],
                "code": "Got the idea from post \\nhttps://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/discuss/1389706/Python3.-Hashing.-NlogN.-Accepted.\\nand added more explanations.\\n\\nThe idea is to decompose the problem into subproblems:\\n1. Create rolling hash from left and from right. This is O(n).\\n2. Judge if it is a palindrome with a given center and given radius in O(1) time. This is done by comparing hash value.\\n3. Use each position as center, find the longest parlindrome extension. This is done by binary search, with step 2 as a subproblem, in total O (n log(n) ).\\n4. Now we know the max len parlindrome ending at a position from both left and right, apply next array type idea to get the final answer: to get the max len till a position (not necessarily ending with it), it has two cases to consider, see code comments..\\n\\nOverall, the time limit is pretty tight, guess applying Manacher is faster (O(n) ) but I don\\'t have that knowledge.\\n\\n```\\nclass Solution:\\n    \\n    def maxProduct(self, s: str) -> int:\\n        mod = 10**9 + 7\\n        base = 27\\n        n = len(s)\\n        forward_hash = [0] * (len(s) + 1)\\n        backward_hash = [0] * (len(s) + 1)\\n        for i in range(1, n+1):\\n            forward_hash[i] = (forward_hash[i-1] * base + (ord(s[i-1]) - ord(\\'a\\'))) % mod\\n        for i in range(n-1, -1, -1):\\n            backward_hash[i] = (backward_hash[i+1] * base + (ord(s[i]) - ord(\\'a\\'))) % mod\\n            \\n        def is_parlin(s, center, l):\\n            # check if it is a palin, with l being the radius\\n            # [left, center-1] vs [center+1, right]\\n            p = pow(base, l, mod)\\n            left_hash = (forward_hash[center] - forward_hash[center-l] * p) % mod\\n            right_hash = (backward_hash[center+1] - backward_hash[center+l+1] * p) % mod\\n            return left_hash == right_hash\\n        \\n        # inclusive\\n        before_idx_max_len = [1] * n\\n        after_idx_max_len = [1] * n\\n        \\n        # for each center, expand\\n        for i in range(1, n-1):\\n            max_radius = 1\\n            if s[i-1] != s[i+1]: # radius = 1 fails\\n                continue\\n            # find the largest extention so that [center+1, right] is the same as [left, center-1]\\n            start, end = 1, min(i, n-i)\\n            while start + 1 < end:\\n                mid = (start + end) // 2\\n                if is_parlin(s, i, mid):\\n                    start = mid\\n                else:\\n                    end = mid\\n            if i + end < n and is_parlin(s, i, end):\\n                max_radius = end\\n            else:\\n                max_radius = start\\n                \\n            left = i - max_radius\\n            right = i + max_radius\\n            before_idx_max_len[right] = max(before_idx_max_len[right], 2*max_radius+1)\\n            after_idx_max_len[left] = max(after_idx_max_len[left], 2*max_radius+1)\\n        \\n        # handle trick case1: if ending with i is palin with len, then end with i-1 should be parlin with at least len-2!\\n        for i in range(n-2, -1, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i], before_idx_max_len[i+1]-2)\\n        for i in range(1, n):\\n            after_idx_max_len[i] = max(after_idx_max_len[i], after_idx_max_len[i-1]-2)\\n        \\n        # case2: find max till now using next array\\n        for i in range(n-1, 0, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i-1], before_idx_max_len[i])\\n        for i in range(n-2, -1, -1):\\n            after_idx_max_len[i] = max(after_idx_max_len[i+1], after_idx_max_len[i])\\n        \\n        # print(before_idx_max_len, after_idx_max_len)\\n        # find the best possible\\n        res = 1\\n        for i in range(n-1):\\n            res = max(res, before_idx_max_len[i] * after_idx_max_len[i+1])\\n            \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2017147,
                "title": "manachers-algo-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long max(long long x,long long y)\\n    {\\n        if(x>y)\\n            return x;\\n        return y;\\n    }\\n    \\n    long long maxProduct(string t) {\\n        int n=t.length();\\n        vector<int> left(n,0),lpso(n,0);\\n        int r=0,c=0;\\n\\t    // Manachar\\'s algo\\n        for(int i=0;i<n;i++)\\n        {\\n            int m=2*c-i;\\n            if(i<r)\\n                lpso[i]= min(lpso[m],r-i);\\n            while(i-lpso[i]-1 >=0 && i+lpso[i]+1<n && t[i-lpso[i]-1] == t[i+lpso[i]+1])\\n                lpso[i]++;\\n            if(r<i+lpso[i])\\n                r=i+lpso[i],c=i;\\n        }\\n\\t\\t// Finding the longest palindrome ending before ith index or at ith index \\n        left[0] = 1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=1;i<=n-1;i++)\\n        {\\n            if(lpso[i]>0)\\n                pq.push({i,lpso[i]}),left[i]=1;\\n            if(!pq.empty())\\n            {\\n\\t\\t\\t    // Number of elements between the ith position and the center of palindrome\\n                while(!pq.empty() && pq.top().first+pq.top().second<i)\\n                    pq.pop();\\n                if(!pq.empty())\\n                    left[i]= 2*(i-pq.top().first)+1;\\n                else\\n                    left[i]=1;\\n            }\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n\\t\\t\\n\\t\\t// Finding the longest palindrome ending after ith index or at ith index \\n        priority_queue<pair<int,int>> pql;\\n        int m=1,l=1;\\n        long long ans=0;\\n        ans = max(ans,1LL*left[n-2]*m);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(lpso[i]>0)\\n                pql.push({i,lpso[i]}),l=1;\\n            if(!pql.empty())\\n            {\\n\\t\\t    \\t// Number of elements between the ith position and the center of palindrome\\n                while(!pql.empty() && pql.top().first-pql.top().second>i)\\n                    pql.pop();\\n                if(!pql.empty())\\n                    l= 2*(pql.top().first-i)+1;\\n                else\\n                    l=1;\\n            }\\n            m=max(m,l);\\n\\t\\t\\t// Directly calculating by multiplying (ending before ith) * (ending after or at ith)\\n            if(i>0)\\n                ans= max(ans, 1LL*left[i-1]*m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long max(long long x,long long y)\\n    {\\n        if(x>y)\\n            return x;\\n        return y;\\n    }\\n    \\n    long long maxProduct(string t) {\\n        int n=t.length();\\n        vector<int> left(n,0),lpso(n,0);\\n        int r=0,c=0;\\n\\t    // Manachar\\'s algo\\n        for(int i=0;i<n;i++)\\n        {\\n            int m=2*c-i;\\n            if(i<r)\\n                lpso[i]= min(lpso[m],r-i);\\n            while(i-lpso[i]-1 >=0 && i+lpso[i]+1<n && t[i-lpso[i]-1] == t[i+lpso[i]+1])\\n                lpso[i]++;\\n            if(r<i+lpso[i])\\n                r=i+lpso[i],c=i;\\n        }\\n\\t\\t// Finding the longest palindrome ending before ith index or at ith index \\n        left[0] = 1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=1;i<=n-1;i++)\\n        {\\n            if(lpso[i]>0)\\n                pq.push({i,lpso[i]}),left[i]=1;\\n            if(!pq.empty())\\n            {\\n\\t\\t\\t    // Number of elements between the ith position and the center of palindrome\\n                while(!pq.empty() && pq.top().first+pq.top().second<i)\\n                    pq.pop();\\n                if(!pq.empty())\\n                    left[i]= 2*(i-pq.top().first)+1;\\n                else\\n                    left[i]=1;\\n            }\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n\\t\\t\\n\\t\\t// Finding the longest palindrome ending after ith index or at ith index \\n        priority_queue<pair<int,int>> pql;\\n        int m=1,l=1;\\n        long long ans=0;\\n        ans = max(ans,1LL*left[n-2]*m);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(lpso[i]>0)\\n                pql.push({i,lpso[i]}),l=1;\\n            if(!pql.empty())\\n            {\\n\\t\\t    \\t// Number of elements between the ith position and the center of palindrome\\n                while(!pql.empty() && pql.top().first-pql.top().second>i)\\n                    pql.pop();\\n                if(!pql.empty())\\n                    l= 2*(pql.top().first-i)+1;\\n                else\\n                    l=1;\\n            }\\n            m=max(m,l);\\n\\t\\t\\t// Directly calculating by multiplying (ending before ith) * (ending after or at ith)\\n            if(i>0)\\n                ans= max(ans, 1LL*left[i-1]*m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393832,
                "title": "python3-manacher",
                "content": "\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # Manacher\\'s algo\\n        hlen = [0]*n # half-length\\n        center = right = 0 \\n        for i in range(n): \\n            if i < right: hlen[i] = min(right - i, hlen[2*center - i])\\n            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: \\n                hlen[i] += 1\\n            if right < i+hlen[i]: center, right = i, i+hlen[i]\\n        \\n        prefix = [0]*n\\n        suffix = [0]*n\\n        for i in range(n): \\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)\\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)\\n        \\n        for i in range(1, n): \\n            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)\\n            suffix[i] = max(suffix[i], suffix[i-1]-2)\\n        \\n        for i in range(1, n): \\n            prefix[i] = max(prefix[i-1], prefix[i])\\n            suffix[~i] = max(suffix[~i], suffix[~i+1])\\n        \\n        return max(prefix[i-1]*suffix[i] for i in range(1, n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # Manacher\\'s algo\\n        hlen = [0]*n # half-length\\n        center = right = 0 \\n        for i in range(n): \\n            if i < right: hlen[i] = min(right - i, hlen[2*center - i])\\n            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: \\n                hlen[i] += 1\\n            if right < i+hlen[i]: center, right = i, i+hlen[i]\\n        \\n        prefix = [0]*n\\n        suffix = [0]*n\\n        for i in range(n): \\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)\\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)\\n        \\n        for i in range(1, n): \\n            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)\\n            suffix[i] = max(suffix[i], suffix[i-1]-2)\\n        \\n        for i in range(1, n): \\n            prefix[i] = max(prefix[i-1], prefix[i])\\n            suffix[~i] = max(suffix[~i], suffix[~i+1])\\n        \\n        return max(prefix[i-1]*suffix[i] for i in range(1, n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389279,
                "title": "o-n-with-manacher-s-algorithm",
                "content": "n is in the order of 10^5, so I think O(n^2) will TLE. We need to use Manacher\\'s algorithm to get the longest palindrome substring at each index, which is O(n).\\n\\nFor Manacher\\'s algorithm, go to wiki\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring\\n```\\n    def maxProduct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        T = \\'$#\\' + \\'#\\'.join(s) + \\'#@\\'\\n        P = [0] * len(T) # store the length at each index\\n        right, center = 0, 0\\n        for i in range(1,len(T)-1):\\n            if i < right:\\n                P[i] = min(P[2 * center - i], right - i)\\n            while T[i+(P[i]+1)] == T[i-(P[i]+1)]:\\n                P[i] += 1\\n            if P[i] + i > right:\\n                right = P[i] + i\\n                center = i\\n                \\n        arr = []#the longest length centering at each index of original array, odd length\\n        for i in range(len(T)):\\n            if T[i].isalpha():\\n                arr.append(P[i])\\n                \\n        pre = [1 for _ in range(len(s))]\\n        for i in range(len(s)):# the ending point of each longest substring\\n            pre[i+(arr[i]-1)//2] = max(pre[i+(arr[i]-1)//2],arr[i])\\n        for i in range(len(s)-2,-1,-1):# the end can be shorter, like \"aba\" is a substring of \"cabac\"\\n            pre[i] = max(pre[i],pre[i+1]-2)\\n        for i in range(len(pre)-1):#the maximum length before and at i\\n            pre[i+1] = max(pre[i],pre[i+1])\\n\\n        post = [1 for _ in range(len(s))]#do it again for the suffix array\\n        for i in range(len(s)-1,-1,-1):\\n            post[i-(arr[i]-1)//2] = max(post[i-(arr[i]-1)//2],arr[i])\\n        for i in range(1,len(s)):\\n            post[i] = max(post[i],post[i-1]-2)    \\n        post = post[1:]+[0]\\n        for i in range(len(s)-1,0,-1):#the maximum length after i\\n            post[i-1] = max(post[i-1],post[i])\\n            \\n        res = 0\\n        for i in range(len(pre)):\\n            res = max(res,pre[i]*post[i])\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProduct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        T = \\'$#\\' + \\'#\\'.join(s) + \\'#@\\'\\n        P = [0] * len(T) # store the length at each index\\n        right, center = 0, 0\\n        for i in range(1,len(T)-1):\\n            if i < right:\\n                P[i] = min(P[2 * center - i], right - i)\\n            while T[i+(P[i]+1)] == T[i-(P[i]+1)]:\\n                P[i] += 1\\n            if P[i] + i > right:\\n                right = P[i] + i\\n                center = i\\n                \\n        arr = []#the longest length centering at each index of original array, odd length\\n        for i in range(len(T)):\\n            if T[i].isalpha():\\n                arr.append(P[i])\\n                \\n        pre = [1 for _ in range(len(s))]\\n        for i in range(len(s)):# the ending point of each longest substring\\n            pre[i+(arr[i]-1)//2] = max(pre[i+(arr[i]-1)//2],arr[i])\\n        for i in range(len(s)-2,-1,-1):# the end can be shorter, like \"aba\" is a substring of \"cabac\"\\n            pre[i] = max(pre[i],pre[i+1]-2)\\n        for i in range(len(pre)-1):#the maximum length before and at i\\n            pre[i+1] = max(pre[i],pre[i+1])\\n\\n        post = [1 for _ in range(len(s))]#do it again for the suffix array\\n        for i in range(len(s)-1,-1,-1):\\n            post[i-(arr[i]-1)//2] = max(post[i-(arr[i]-1)//2],arr[i])\\n        for i in range(1,len(s)):\\n            post[i] = max(post[i],post[i-1]-2)    \\n        post = post[1:]+[0]\\n        for i in range(len(s)-1,0,-1):#the maximum length after i\\n            post[i-1] = max(post[i-1],post[i])\\n            \\n        res = 0\\n        for i in range(len(pre)):\\n            res = max(res,pre[i]*post[i])\\n        return res\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1393288,
                "title": "java-100-o-n-time-o-n-space-using-manacher-s-algorithm",
                "content": "```\\n// using manachers algorithm\\n\\nclass Solution {\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n        if (n == 2) return 1;\\n        int[] len = manachers(s);               // get lengths of palindromes at each element\\n        \\n        long left[] = new long[n];                // stores the max length of palindrome to left of each index\\n        \\n        int max = 1;\\n        left[0] = max;\\n        for (int i = 1; i <= n - 1; i++) {\\n            // does any palindrome end at i with length greater than max\\n            if (len[(i - max - 1 + i)/2] > max) max += 2;\\n            left[i] = max;\\n        }\\n        max = 1;\\n        long[] right = new long[n];             // stores the max length of palindrome to right of each index\\n        right[n - 1] = max;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            // does any palindrome start at i with length greater than max\\n            if (len[(i + max + 1 + i)/2] > max) max += 2;\\n            right[i] = max;\\n        }\\n        \\n        long res = 1;\\n        \\n        for (int i = 1; i < n; i++) {            \\n            res = Math.max(res, left[i - 1] * right[i]);\\n        }\\n        return res;\\n    }\\n    \\n\\t// credit : https://hackernoon.com/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f\\n\\tprivate int[] manachers(String s) {\\n        \\n        int len = s.length();\\n        int[] P = new int[len];\\n        int c = 0; //stores the center of the longest palindromic substring until now\\n        int r = 0; //stores the right boundary of the longest palindromic substring until now\\n        int maxLen = 0;\\n       \\n        for(int i = 0; i < len; i++) {\\n            //get mirror index of i\\n            int mirror = (2 * c) - i;\\n            \\n            //see if the mirror of i is expanding beyond the left boundary of current longest palindrome at center c\\n            //if it is, then take r - i as P[i]\\n            //else take P[mirror] as P[i]\\n            if(i < r) {\\n                P[i] = Math.min(r - i, P[mirror]);\\n            }\\n            \\n            //expand at i\\n            int a = i + (1 + P[i]);\\n            int b = i - (1 + P[i]);\\n            while(a < len && b >= 0 && s.charAt(a) == s.charAt(b)) {\\n                P[i]++;\\n                a++;\\n                b--;\\n            }\\n            \\n            //check if the expanded palindrome at i is expanding beyond the right boundary of current longest palindrome at center c\\n            //if it is, the new center is i\\n            if(i + P[i] > r) {\\n                c = i;\\n                r = i + P[i];\\n            }\\n        }\\n        for (int i = 0; i < len; i++) P[i] = 1 + 2*P[i];\\n        return P;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// using manachers algorithm\\n\\nclass Solution {\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n        if (n == 2) return 1;\\n        int[] len = manachers(s);               // get lengths of palindromes at each element\\n        \\n        long left[] = new long[n];                // stores the max length of palindrome to left of each index\\n        \\n        int max = 1;\\n        left[0] = max;\\n        for (int i = 1; i <= n - 1; i++) {\\n            // does any palindrome end at i with length greater than max\\n            if (len[(i - max - 1 + i)/2] > max) max += 2;\\n            left[i] = max;\\n        }\\n        max = 1;\\n        long[] right = new long[n];             // stores the max length of palindrome to right of each index\\n        right[n - 1] = max;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            // does any palindrome start at i with length greater than max\\n            if (len[(i + max + 1 + i)/2] > max) max += 2;\\n            right[i] = max;\\n        }\\n        \\n        long res = 1;\\n        \\n        for (int i = 1; i < n; i++) {            \\n            res = Math.max(res, left[i - 1] * right[i]);\\n        }\\n        return res;\\n    }\\n    \\n\\t// credit : https://hackernoon.com/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f\\n\\tprivate int[] manachers(String s) {\\n        \\n        int len = s.length();\\n        int[] P = new int[len];\\n        int c = 0; //stores the center of the longest palindromic substring until now\\n        int r = 0; //stores the right boundary of the longest palindromic substring until now\\n        int maxLen = 0;\\n       \\n        for(int i = 0; i < len; i++) {\\n            //get mirror index of i\\n            int mirror = (2 * c) - i;\\n            \\n            //see if the mirror of i is expanding beyond the left boundary of current longest palindrome at center c\\n            //if it is, then take r - i as P[i]\\n            //else take P[mirror] as P[i]\\n            if(i < r) {\\n                P[i] = Math.min(r - i, P[mirror]);\\n            }\\n            \\n            //expand at i\\n            int a = i + (1 + P[i]);\\n            int b = i - (1 + P[i]);\\n            while(a < len && b >= 0 && s.charAt(a) == s.charAt(b)) {\\n                P[i]++;\\n                a++;\\n                b--;\\n            }\\n            \\n            //check if the expanded palindrome at i is expanding beyond the right boundary of current longest palindrome at center c\\n            //if it is, the new center is i\\n            if(i + P[i] > r) {\\n                c = i;\\n                r = i + P[i];\\n            }\\n        }\\n        for (int i = 0; i < len; i++) P[i] = 1 + 2*P[i];\\n        return P;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389320,
                "title": "c-manacher-set-priority-queue-to-build-maxl-and-maxr",
                "content": "I got WA at last second because i forgot to cast to long long, got accepted after 1 second of contest end ;(\\n\\nAnyway the idea here is to just use manacher\\'s algorithm and then build the prefix and suffix max palindrome length, by using a priority queue (set here is used to quickly make a min priority queue instead of max priority queue).\\n\\nThen at every index just update the result if we find a new best product.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961860,
                "title": "c-manacher-and-queue-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        vector<int> d1(s.size());\\n        int n=s.size();\\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n        cout<<d1[i]<<\\' \\';\\n    }\\n        vector<int> l(s.size(),1),r(s.size(),1);\\n        queue<int> q;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                l[i] = max(l[i], l[i - 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() + d1[q.front()] - 1 < i)\\n            {\\n                q.pop();\\n            }\\n\\n            l[i] = max(l[i], ((i - q.front()) * 2) + 1);\\n        }\\n        while(!q.empty()) q.pop();\\n      \\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                r[i] = max(r[i], r[i + 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() - d1[q.front()] + 1 > i)\\n            {\\n                q.pop();\\n            }\\n\\n            r[i] = max(r[i], ((q.front() - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) l[i] * (long long)r[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        vector<int> d1(s.size());\\n        int n=s.size();\\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n        cout<<d1[i]<<\\' \\';\\n    }\\n        vector<int> l(s.size(),1),r(s.size(),1);\\n        queue<int> q;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                l[i] = max(l[i], l[i - 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() + d1[q.front()] - 1 < i)\\n            {\\n                q.pop();\\n            }\\n\\n            l[i] = max(l[i], ((i - q.front()) * 2) + 1);\\n        }\\n        while(!q.empty()) q.pop();\\n      \\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                r[i] = max(r[i], r[i + 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() - d1[q.front()] + 1 > i)\\n            {\\n                q.pop();\\n            }\\n\\n            r[i] = max(r[i], ((q.front() - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) l[i] * (long long)r[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2127513,
                "title": "manacher-algorithm-prefix-suffix-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> build_pal(string &s) // Manacher\\'s algo\\n    {\\n        int n=s.length();\\n        vector<long long> d1(n);   // [ i-d1[i]+1 , i+d1[i]-1 ];  length = 2*d1[i] - 1   \\n        for (long long i=0,l=0,r=-1; i<n; i++) \\n        {\\n            long long k = (i>r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i-k && i+k < n && s[i-k] == s[i+k]) k++;\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i-k;\\n                r = i+k;\\n            }\\n        }\\n        return d1;\\n    }\\n\\n\\n    long long maxProduct(string s) \\n    {\\n        int n=s.length();\\n        vector<long long> d1=build_pal(s);\\n        long long l[n+5],r[n+5],ans=0;\\n        memset(l,0,sizeof(l)); memset(r,0,sizeof(r));\\n        for(int i=0;i<n;i++)\\n        {\\n            r[i-d1[i]+1]=max(r[i-d1[i]+1],2*d1[i]-1);\\n            l[i+d1[i]-1]=max(l[i+d1[i]-1],2*d1[i]-1);\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            r[i]=max(r[i],r[i-1]-2);\\n        for(int i=n-2;i>=0;i--)\\n            l[i]=max(l[i],l[i+1]-2);\\n        \\n        for(int i=1;i<n;i++)\\n            l[i]=max(l[i],l[i-1]);\\n        for(int i=n-2;i>=0;i--)\\n            r[i]=max(r[i],r[i+1]);\\n        for(int i=0;i<n;i++)\\n            ans=max(ans,l[i]*r[i+1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> build_pal(string &s) // Manacher\\'s algo\\n    {\\n        int n=s.length();\\n        vector<long long> d1(n);   // [ i-d1[i]+1 , i+d1[i]-1 ];  length = 2*d1[i] - 1   \\n        for (long long i=0,l=0,r=-1; i<n; i++) \\n        {\\n            long long k = (i>r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i-k && i+k < n && s[i-k] == s[i+k]) k++;\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i-k;\\n                r = i+k;\\n            }\\n        }\\n        return d1;\\n    }\\n\\n\\n    long long maxProduct(string s) \\n    {\\n        int n=s.length();\\n        vector<long long> d1=build_pal(s);\\n        long long l[n+5],r[n+5],ans=0;\\n        memset(l,0,sizeof(l)); memset(r,0,sizeof(r));\\n        for(int i=0;i<n;i++)\\n        {\\n            r[i-d1[i]+1]=max(r[i-d1[i]+1],2*d1[i]-1);\\n            l[i+d1[i]-1]=max(l[i+d1[i]-1],2*d1[i]-1);\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            r[i]=max(r[i],r[i-1]-2);\\n        for(int i=n-2;i>=0;i--)\\n            l[i]=max(l[i],l[i+1]-2);\\n        \\n        for(int i=1;i<n;i++)\\n            l[i]=max(l[i],l[i-1]);\\n        for(int i=n-2;i>=0;i--)\\n            r[i]=max(r[i],r[i+1]);\\n        for(int i=0;i<n;i++)\\n            ans=max(ans,l[i]*r[i+1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601474,
                "title": "go-manachers-prefixmax",
                "content": "This problem is a mouthful.. I sure do hate palindromes.\\n\\nAs with many other solutions here, I use Manacher\\'s algorithm to find the maximum palindrome for each position in the input string. For more info on Manacher\\'s, please see\\nhttps://cp-algorithms.com/string/manacher.html\\n\\nWe only need to consider odd-length palindromes for this exercise.\\n\\nOnce a palindrome has been found by Manacher\\'s, store the size of the paindrome just outside the right boundary of the palindrome to the right. This will be used to form a prefix-max.\\n\\nTo get the prefix-max for left-to-right, reverse the string and the result.\\n\\nFinally, find the maximum product by combining the max palindrome to the left/right of each position in the input string.\\n\\n<iframe src=\"https://leetcode.com/playground/HvuT3KuH/shared\" frameBorder=\"0\" width=\"700\" height=\"1200\"></iframe>",
                "solutionTags": [
                    "Go"
                ],
                "code": "This problem is a mouthful.. I sure do hate palindromes.\\n\\nAs with many other solutions here, I use Manacher\\'s algorithm to find the maximum palindrome for each position in the input string. For more info on Manacher\\'s, please see\\nhttps://cp-algorithms.com/string/manacher.html\\n\\nWe only need to consider odd-length palindromes for this exercise.\\n\\nOnce a palindrome has been found by Manacher\\'s, store the size of the paindrome just outside the right boundary of the palindrome to the right. This will be used to form a prefix-max.\\n\\nTo get the prefix-max for left-to-right, reverse the string and the result.\\n\\nFinally, find the maximum product by combining the max palindrome to the left/right of each position in the input string.\\n\\n<iframe src=\"https://leetcode.com/playground/HvuT3KuH/shared\" frameBorder=\"0\" width=\"700\" height=\"1200\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2203333,
                "title": "here-is-simple-o-n-approach-self-explanatory-c-dp",
                "content": "class Solution {\\npublic:\\n    long long int maxProduct(string s) {\\n        long long int n = s.size();\\n        \\n        vector<long long int> dp(n + 1, 1);\\n        vector<long long int> udp(n + 1, 1);\\n        \\n        for (long long int i = 2; i < n; i++) {\\n            // cout << \"i = \" << i << \" i2 = \" << i - dp[i - 1] - 1 <<  endl;\\n            if (i - dp[i - 1] - 1 >= 0 && s[i] == s[i - dp[i - 1] - 1]) {\\n                dp[i] = dp[i - 1] + 2;\\n            }\\n            else\\n                dp[i] = 1;\\n            // cout << \"dpi = \" << dp[i] << endl;\\n        }\\n        \\n        \\n        for (long long int i = n - 3; i >= 0; i--) {\\n            if (i + udp[i + 1] + 1 < n && s[i] == s[i + udp[i + 1] + 1])\\n                udp[i] = udp[i + 1]  + 2;\\n            else\\n                udp[i] = 1;\\n        }\\n        \\n        \\n        vector<long long int> pl(n + 1, 1), pr(n + 1, 1);\\n        \\n        for (int i = 1; i < n; i++) {\\n            pl[i] = max(pl[i - 1], dp[i]);\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            pr[i] = max(pr[i + 1], udp[i]);\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        for (long long int i = 0; i < n - 1; i++) {\\n            ans = max(ans, pl[i] * pr[i + 1]);\\n            if (ans < pl[i] * pr[i + 1])\\n                ans = pl[i] * pr[i + 1];\\n            // long long int t1 = pl[i], t2 = pr[i + 1];\\n            // if (t1 * t2 > 2147385345)\\n            //     cout << t1 * t2 << endl;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long int maxProduct(string s) {\\n        long long int n = s.size();\\n        \\n        vector<long long int> dp(n + 1, 1);\\n        vector<long long int> udp(n + 1, 1);\\n        \\n        for (long long int i = 2; i < n; i++) {\\n            // cout << \"i = \" << i << \" i2 = \" << i - dp[i - 1] - 1 <<  endl;\\n            if (i - dp[i - 1] - 1 >= 0 && s[i] == s[i - dp[i - 1] - 1]) {\\n                dp[i] = dp[i - 1] + 2;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1427632,
                "title": "c-manacher-o-n-103-ms-49-34-26-2-mb-57-73",
                "content": "It is known that the Manacher\\'s algorithm can obtain each maximum palindromic sequence with the odd length at different centers.\\nFrom an array of the maximum length of the given sequence, the maximum length in the interval [0, i] is easily derived.\\nTo derive the maxiimum length in the interval [j, s.size()-1], the desired array is derived when the given string is reversed.\\n\\n```\\nclass Solution {\\npublic:\\ntypedef long long int ll;\\nstd::vector<int> manacher(std::string& s){\\n  std::vector<int> R(s.size());\\n  int i = 0, j = 0;\\n  while (i < s.size()) {\\n    while (i-j >= 0 && i+j < s.size() && s[i-j] == s[i+j]) ++j;\\n    R[i] = j;\\n    int k = 1;\\n    while (i-k >= 0 && k+R[i-k] < j) R[i+k] = R[i-k], ++k;\\n    i += k; j -= k;\\n  }\\n  return std::move(R);\\n}\\n\\n  vector<int> maxlength(string &s){\\n    vector<int> center_l = manacher(s);\\n    vector<int> ans(s.size());\\n    int num = 1;\\n    int maxv = 1;\\n    for(int i=0;i<s.size()-1;i++){\\n        int len = 2 * (center_l[i] - 1) + 1;\\n        int loc = center_l[i] - 1;\\n        ans[i+loc] = max(ans[i+loc], len);\\n    }\\n    int tmp = 0;\\n    for(int i=0;i<s.size();i++){\\n        if(tmp < ans[i])\\n            tmp = ans[i];\\n        ans[i] = tmp;\\n    }\\n    int cnt = ans[s.size()-1];\\n    for(int i=s.size()-2;i>=0;i--){\\n        if(ans[i] < cnt)\\n            cnt = cnt - 2;\\n        ans[i] = cnt;\\n    }\\n    return std::move(ans);\\n  }\\n    \\n  long long maxProduct(string s) {\\n    vector<int> left = maxlength(s);\\n    reverse(s.begin(), s.end());\\n    vector<int> right = maxlength(s);\\n    ll ans = 0;\\n    for(int i=0;i<s.size()-1;i++){\\n        ll l = left[i];\\n        ll r = right[s.size() - i -2];\\n        if(ans < l * r)\\n            ans = l * r;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long int ll;\\nstd::vector<int> manacher(std::string& s){\\n  std::vector<int> R(s.size());\\n  int i = 0, j = 0;\\n  while (i < s.size()) {\\n    while (i-j >= 0 && i+j < s.size() && s[i-j] == s[i+j]) ++j;\\n    R[i] = j;\\n    int k = 1;\\n    while (i-k >= 0 && k+R[i-k] < j) R[i+k] = R[i-k], ++k;\\n    i += k; j -= k;\\n  }\\n  return std::move(R);\\n}\\n\\n  vector<int> maxlength(string &s){\\n    vector<int> center_l = manacher(s);\\n    vector<int> ans(s.size());\\n    int num = 1;\\n    int maxv = 1;\\n    for(int i=0;i<s.size()-1;i++){\\n        int len = 2 * (center_l[i] - 1) + 1;\\n        int loc = center_l[i] - 1;\\n        ans[i+loc] = max(ans[i+loc], len);\\n    }\\n    int tmp = 0;\\n    for(int i=0;i<s.size();i++){\\n        if(tmp < ans[i])\\n            tmp = ans[i];\\n        ans[i] = tmp;\\n    }\\n    int cnt = ans[s.size()-1];\\n    for(int i=s.size()-2;i>=0;i--){\\n        if(ans[i] < cnt)\\n            cnt = cnt - 2;\\n        ans[i] = cnt;\\n    }\\n    return std::move(ans);\\n  }\\n    \\n  long long maxProduct(string s) {\\n    vector<int> left = maxlength(s);\\n    reverse(s.begin(), s.end());\\n    vector<int> right = maxlength(s);\\n    ll ans = 0;\\n    for(int i=0;i<s.size()-1;i++){\\n        ll l = left[i];\\n        ll r = right[s.size() - i -2];\\n        if(ans < l * r)\\n            ans = l * r;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394034,
                "title": "c-1960-maximum-product-of-the-length-of-two-palindromic-substrings",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.size(), center = 0, right = 0; \\n        vector<int> hlen(n, 0), prefix(n, 0), suffix(n, 0); \\n        for (int i = 0; i < n; ++i) {\\n            if (i < right) hlen[i] = min(right - i, hlen[2*center - i]); \\n            while (0 <= i-1-hlen[i] && i+1+hlen[i] < n && s[i-1-hlen[i]] == s[i+1+hlen[i]]) ++hlen[i]; \\n            if (right < i + hlen[i]) {\\n                center = i; \\n                right = i + hlen[i]; \\n            }\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i] + 1); \\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i] + 1); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[n-1-i] = max(prefix[n-1-i], prefix[n-i]-2); \\n            suffix[i] = max(suffix[i], suffix[i-1]-2); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[i] = max(prefix[i-1], prefix[i]); \\n            suffix[n-1-i] = max(suffix[n-1-i], suffix[n-i]); \\n        }\\n        \\n        long long ans = 0ll; \\n        for (int i = 1; i < n; ++i) ans = max(ans, (long long) prefix[i-1] * suffix[i]); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.size(), center = 0, right = 0; \\n        vector<int> hlen(n, 0), prefix(n, 0), suffix(n, 0); \\n        for (int i = 0; i < n; ++i) {\\n            if (i < right) hlen[i] = min(right - i, hlen[2*center - i]); \\n            while (0 <= i-1-hlen[i] && i+1+hlen[i] < n && s[i-1-hlen[i]] == s[i+1+hlen[i]]) ++hlen[i]; \\n            if (right < i + hlen[i]) {\\n                center = i; \\n                right = i + hlen[i]; \\n            }\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i] + 1); \\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i] + 1); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[n-1-i] = max(prefix[n-1-i], prefix[n-i]-2); \\n            suffix[i] = max(suffix[i], suffix[i-1]-2); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[i] = max(prefix[i-1], prefix[i]); \\n            suffix[n-1-i] = max(suffix[n-1-i], suffix[n-i]); \\n        }\\n        \\n        long long ans = 0ll; \\n        for (int i = 1; i < n; ++i) ans = max(ans, (long long) prefix[i-1] * suffix[i]); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391003,
                "title": "c-o-n-manacher-s-algorithm",
                "content": "```csharp\\npublic int[] helper(string s)\\n{\\n\\t// Manacher\\'s Algorithm\\n\\tint[] d = new int[s.Length];\\n\\tint left = 0, right = -1;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tint k = (i > right) ? 1 : Math.Min(d[left + right - i], right - i + 1);\\n\\t\\twhile (0 <= i - k && i + k < s.Length && s[i - k] == s[i + k])\\n\\t\\t{\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\n\\t\\td[i] = k;\\n\\t\\tk--;\\n\\t\\tif (i + k > right)\\n\\t\\t{\\n\\t\\t\\tleft = i - k;\\n\\t\\t\\tright = i + k;\\n\\t\\t}\\n\\t}\\n\\n\\t// Find max range for given element and find max palindrome upto i\\n\\tint[] maxRange = new int[s.Length];\\n\\tint n = s.Length;\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmaxRange[i - d[i] + 1] = i;\\n\\t}\\n\\n\\tint max = 0;\\n\\tint[] maxL = new int[n];\\n\\tArray.Fill(maxL, 1);\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmax = Math.Max(maxRange[i], max);\\n\\t\\tmaxL[i] = Math.Max((max - i) * 2 + 1, maxL[i]);\\n\\t}\\n\\n\\tfor (int i = n - 2; i >= 0; i--)\\n\\t{\\n\\t\\tmaxL[i] = Math.Max(maxL[i + 1], maxL[i]);\\n\\t}\\n\\n\\treturn maxL;\\n}\\n\\npublic long MaxProduct(string s)\\n{\\n\\tint[] left = helper(s);\\n\\tint[] right = helper(new string(s.Reverse().ToArray()));\\n\\n\\tlong result = 0L;\\n\\tfor (int i = 1; i < s.Length; i++)\\n\\t{\\n\\t\\tresult = Math.Max(result, 1L * left[i] * right[s.Length - i]);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[] helper(string s)\\n{\\n\\t// Manacher\\'s Algorithm\\n\\tint[] d = new int[s.Length];\\n\\tint left = 0, right = -1;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tint k = (i > right) ? 1 : Math.Min(d[left + right - i], right - i + 1);\\n\\t\\twhile (0 <= i - k && i + k < s.Length && s[i - k] == s[i + k])\\n\\t\\t{\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\n\\t\\td[i] = k;\\n\\t\\tk--;\\n\\t\\tif (i + k > right)\\n\\t\\t{\\n\\t\\t\\tleft = i - k;\\n\\t\\t\\tright = i + k;\\n\\t\\t}\\n\\t}\\n\\n\\t// Find max range for given element and find max palindrome upto i\\n\\tint[] maxRange = new int[s.Length];\\n\\tint n = s.Length;\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmaxRange[i - d[i] + 1] = i;\\n\\t}\\n\\n\\tint max = 0;\\n\\tint[] maxL = new int[n];\\n\\tArray.Fill(maxL, 1);\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmax = Math.Max(maxRange[i], max);\\n\\t\\tmaxL[i] = Math.Max((max - i) * 2 + 1, maxL[i]);\\n\\t}\\n\\n\\tfor (int i = n - 2; i >= 0; i--)\\n\\t{\\n\\t\\tmaxL[i] = Math.Max(maxL[i + 1], maxL[i]);\\n\\t}\\n\\n\\treturn maxL;\\n}\\n\\npublic long MaxProduct(string s)\\n{\\n\\tint[] left = helper(s);\\n\\tint[] right = helper(new string(s.Reverse().ToArray()));\\n\\n\\tlong result = 0L;\\n\\tfor (int i = 1; i < s.Length; i++)\\n\\t{\\n\\t\\tresult = Math.Max(result, 1L * left[i] * right[s.Length - i]);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389963,
                "title": "rolling-hash-preprocessing-and-binary-search-at-each-position-o-n-log-n",
                "content": "```\\ntypedef long long ll;\\nll H = 1000000007;\\n\\n\\nclass RollingHash {\\npublic:\\n    RollingHash(const string& s) {\\n        int n = s.length();\\n        pre.resize(n + 1);\\n        for (int i = 0; i < n; i++) {\\n            pre[i + 1] = (pre[i] * 26 + s[i]) % H;\\n        }\\n        b.resize(n + 1);\\n        b[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            b[i] = (b[i - 1] * 26) % H;\\n        }\\n    }\\n\\n    // [start, limit)\\n    ll Query(int start, int limit) const {\\n        int len = limit - start;\\n        ll res = (pre[limit] - pre[start] * b[len]) % H;\\n        if (res < 0) res += H;\\n        return res;\\n    }\\n    \\n    private:\\n    vector<ll> pre;\\n    vector<ll> b;\\n};\\n\\nint FindMaxPalLen(int i, int n, const RollingHash& left_rolling, const RollingHash& right_rolling) {\\n    int l = 1;\\n    int r = min<int>(i + 1, n - i);\\n    while (l <= r) {\\n        int m = (l + r) / 2;\\n        ll h1 = left_rolling.Query(i, i + m);\\n        ll h2 = right_rolling.Query(n - 1 - i, n - 1 - i + m);\\n        if (h1 == h2) {\\n            l = m + 1;\\n        } else {\\n            r = m - 1;\\n        }\\n    }\\n    return r;\\n}\\n\\nvector<int> PrefixMaxPalLen(const vector<int>& v) {\\n    int n = v.size();\\n    vector<int> res(n, 1);\\n    for (int i = 0; i < n; i++) {\\n        int& tar = res[i + v[i] - 1];\\n        tar = max(tar, v[i] * 2 - 1);\\n    }\\n    for (int i = 1; i < n; i++) {\\n        res[i] = max(res[i - 1], res[i]);\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n        res[i] = max(res[i], res[i + 1] - 2);\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        RollingHash left_rolling(s);\\n\\n        string r = s;\\n        reverse(r.begin(), r.end());\\n        RollingHash right_rolling(r);\\n        \\n        vector<int> g(n);\\n        for (int i = 0; i < n; i++) {\\n            g[i] = FindMaxPalLen(i, n, left_rolling, right_rolling);\\n        }\\n        \\n        auto vl = PrefixMaxPalLen(g);\\n\\n        vector<int> gr = g;\\n        reverse(gr.begin(), gr.end());\\n        auto vr = PrefixMaxPalLen(gr);\\n\\n        ll res = 0;\\n        for (int i = 1; i < n; i++) {\\n            ll t = vl[i - 1];\\n            t *= vr[n - i - 1];\\n            res = max(res, t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nll H = 1000000007;\\n\\n\\nclass RollingHash {\\npublic:\\n    RollingHash(const string& s) {\\n        int n = s.length();\\n        pre.resize(n + 1);\\n        for (int i = 0; i < n; i++) {\\n            pre[i + 1] = (pre[i] * 26 + s[i]) % H;\\n        }\\n        b.resize(n + 1);\\n        b[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            b[i] = (b[i - 1] * 26) % H;\\n        }\\n    }\\n\\n    // [start, limit)\\n    ll Query(int start, int limit) const {\\n        int len = limit - start;\\n        ll res = (pre[limit] - pre[start] * b[len]) % H;\\n        if (res < 0) res += H;\\n        return res;\\n    }\\n    \\n    private:\\n    vector<ll> pre;\\n    vector<ll> b;\\n};\\n\\nint FindMaxPalLen(int i, int n, const RollingHash& left_rolling, const RollingHash& right_rolling) {\\n    int l = 1;\\n    int r = min<int>(i + 1, n - i);\\n    while (l <= r) {\\n        int m = (l + r) / 2;\\n        ll h1 = left_rolling.Query(i, i + m);\\n        ll h2 = right_rolling.Query(n - 1 - i, n - 1 - i + m);\\n        if (h1 == h2) {\\n            l = m + 1;\\n        } else {\\n            r = m - 1;\\n        }\\n    }\\n    return r;\\n}\\n\\nvector<int> PrefixMaxPalLen(const vector<int>& v) {\\n    int n = v.size();\\n    vector<int> res(n, 1);\\n    for (int i = 0; i < n; i++) {\\n        int& tar = res[i + v[i] - 1];\\n        tar = max(tar, v[i] * 2 - 1);\\n    }\\n    for (int i = 1; i < n; i++) {\\n        res[i] = max(res[i - 1], res[i]);\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n        res[i] = max(res[i], res[i + 1] - 2);\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        RollingHash left_rolling(s);\\n\\n        string r = s;\\n        reverse(r.begin(), r.end());\\n        RollingHash right_rolling(r);\\n        \\n        vector<int> g(n);\\n        for (int i = 0; i < n; i++) {\\n            g[i] = FindMaxPalLen(i, n, left_rolling, right_rolling);\\n        }\\n        \\n        auto vl = PrefixMaxPalLen(g);\\n\\n        vector<int> gr = g;\\n        reverse(gr.begin(), gr.end());\\n        auto vr = PrefixMaxPalLen(gr);\\n\\n        ll res = 0;\\n        for (int i = 1; i < n; i++) {\\n            ll t = vl[i - 1];\\n            t *= vr[n - i - 1];\\n            res = max(res, t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389276,
                "title": "c-57-60",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n    \\n     int n=s.length();\\n       \\n      vector<int> d1(n);\\n       for (int i = 0, l = 0, r = -1; i < n; i++) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            k++;\\n        }\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n           \\n           \\n    }\\n\\n       \\n        vector<int>right(n,0);\\n        vector<int>left(n,0);\\n       \\n        for(int i=n-1;i>=0;i--){\\n            right[i-d1[i]+1]=max(2*d1[i]-1,right[i-d1[i]+1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            left[i+d1[i]-1]=max(2*d1[i]-1,left[i+d1[i]-1]);\\n        }\\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i],right[i+1]);\\n        }\\n        int i=0;\\n       long long  int ans=0;\\n        while(i<n){\\n            \\n            long long int x=d1[i];\\n            while(x){\\n                if(i-x>=0){\\n                ans=max(ans,left[i-x]*1ll*(2*1ll*x-1ll));\\n                }\\n                if(i+x<n){\\n                ans=max(ans,right[i+x]*1ll*(2*1ll*x-1ll));\\n                }\\n                x--;\\n            }\\n            i+=d1[i];\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n    \\n     int n=s.length();\\n       \\n      vector<int> d1(n);\\n       for (int i = 0, l = 0, r = -1; i < n; i++) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            k++;\\n        }\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n           \\n           \\n    }\\n\\n       \\n        vector<int>right(n,0);\\n        vector<int>left(n,0);\\n       \\n        for(int i=n-1;i>=0;i--){\\n            right[i-d1[i]+1]=max(2*d1[i]-1,right[i-d1[i]+1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            left[i+d1[i]-1]=max(2*d1[i]-1,left[i+d1[i]-1]);\\n        }\\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i],right[i+1]);\\n        }\\n        int i=0;\\n       long long  int ans=0;\\n        while(i<n){\\n            \\n            long long int x=d1[i];\\n            while(x){\\n                if(i-x>=0){\\n                ans=max(ans,left[i-x]*1ll*(2*1ll*x-1ll));\\n                }\\n                if(i+x<n){\\n                ans=max(ans,right[i+x]*1ll*(2*1ll*x-1ll));\\n                }\\n                x--;\\n            }\\n            i+=d1[i];\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886037,
                "title": "o-n-manacher-dp-easy-to-understand-link-to-manacher-blog",
                "content": "Before checking out the solution please check out this blog(https://cp-algorithms.com/string/manacher.html#implementation-of-manachers-algorithm)for manacher algorithm.\\nJust used manacher to find odd palindromes and then use dp to store the length of palindrome and compute the value of ans at each step.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maxProduct(string str) {\\n        int n = str.length();\\n        ll ans = 1;\\n\\n        str = \"!\" + str + \"?\";\\n        vector<ll > p(n + 2, 1);\\n        vector<ll > dp(n + 1, 0);\\n        dp[2] = 1;\\n        ll l = 1; ll r = 1;\\n        for(ll i = 1; i <= n; i++)\\n        {\\n            p[i] = max(0LL, min(r - i, p[l + (r - i)]));\\n            while(str[i - p[i]] == str[i + p[i]])\\n            {\\n                p[i]++;\\n                dp[i + p[i] - 1] = max(dp[i + p[i] - 1], (2 * p[i] - 1));\\n                ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            }\\n            ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            dp[i] = max(dp[i], dp[i - 1]);\\n            if(i + p[i] > r){r = i + p[i], l = i - p[i];}\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maxProduct(string str) {\\n        int n = str.length();\\n        ll ans = 1;\\n\\n        str = \"!\" + str + \"?\";\\n        vector<ll > p(n + 2, 1);\\n        vector<ll > dp(n + 1, 0);\\n        dp[2] = 1;\\n        ll l = 1; ll r = 1;\\n        for(ll i = 1; i <= n; i++)\\n        {\\n            p[i] = max(0LL, min(r - i, p[l + (r - i)]));\\n            while(str[i - p[i]] == str[i + p[i]])\\n            {\\n                p[i]++;\\n                dp[i + p[i] - 1] = max(dp[i + p[i] - 1], (2 * p[i] - 1));\\n                ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            }\\n            ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            dp[i] = max(dp[i], dp[i - 1]);\\n            if(i + p[i] > r){r = i + p[i], l = i - p[i];}\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808911,
                "title": "manachers-s-algo-beats-90-time",
                "content": "# Complexity\\n- Time complexity:\\n4 * O(N)\\n\\n- Space complexity:\\n3 * O(N)\\n\\n# Code\\n```\\nclass Solution {\\n  public long maxProduct(String s) {\\n    if (s.length() == 2) {\\n      return 1;\\n    }\\n\\n    long[] starts = new long[s.length()];\\n    long[] ends = new long[s.length()];\\n    long[] lps = new long[s.length()];\\n    Arrays.fill(starts, 1);\\n    Arrays.fill(ends, 1);\\n    int center = 0, r = 0;\\n    for (int i = 0; i < s.length(); i++) {\\n      int cl = i - 1;\\n      int cr = i + 1;\\n      if (i != center && i < r) {\\n        int mirrEl = center - (i - center);\\n        if (lps[mirrEl] < r - i) {\\n          lps[i] = lps[mirrEl];\\n          starts[i - (int)lps[i]] = Math.max(starts[i - (int)lps[i]], 2 * lps[i] + 1);\\n          continue;\\n        }\\n\\n        cl = 2 * i  - r - 1;\\n        cr = r + 1;\\n        lps[i] = r - i;\\n        starts[cl + 1] = Math.max(starts[cl + 1], 2 * lps[i] + 1);\\n      }\\n\\n      center = i;\\n      while (cl >= 0 && cr < s.length() &&\\n        s.charAt(cl) == s.charAt(cr)) {\\n        lps[i]++;\\n        starts[cl] = 2 * lps[i] + 1;\\n        ends[cr] = 2 * lps[i] + 1;\\n        cl--;\\n        cr++;\\n      }\\n      \\n      r = cr - 1;\\n    }\\n\\n    long maxProd = 1;\\n    for (int i = 1; i < s.length(); i++) {\\n      if (starts[i - 1] > 1 && starts[i] == 1) {\\n        starts[i] = starts[i - 1] - 2;\\n      }\\n\\n      ends[i] = Math.max(ends[i - 1], ends[i]);\\n    }\\n\\n    for (int j = s.length() - 2; j >= 0; j--) {\\n      starts[j] = Math.max(starts[j + 1], starts[j]);\\n      maxProd = Math.max(maxProd, ends[j] * starts[j + 1]);\\n    }\\n\\n    return maxProd;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long maxProduct(String s) {\\n    if (s.length() == 2) {\\n      return 1;\\n    }\\n\\n    long[] starts = new long[s.length()];\\n    long[] ends = new long[s.length()];\\n    long[] lps = new long[s.length()];\\n    Arrays.fill(starts, 1);\\n    Arrays.fill(ends, 1);\\n    int center = 0, r = 0;\\n    for (int i = 0; i < s.length(); i++) {\\n      int cl = i - 1;\\n      int cr = i + 1;\\n      if (i != center && i < r) {\\n        int mirrEl = center - (i - center);\\n        if (lps[mirrEl] < r - i) {\\n          lps[i] = lps[mirrEl];\\n          starts[i - (int)lps[i]] = Math.max(starts[i - (int)lps[i]], 2 * lps[i] + 1);\\n          continue;\\n        }\\n\\n        cl = 2 * i  - r - 1;\\n        cr = r + 1;\\n        lps[i] = r - i;\\n        starts[cl + 1] = Math.max(starts[cl + 1], 2 * lps[i] + 1);\\n      }\\n\\n      center = i;\\n      while (cl >= 0 && cr < s.length() &&\\n        s.charAt(cl) == s.charAt(cr)) {\\n        lps[i]++;\\n        starts[cl] = 2 * lps[i] + 1;\\n        ends[cr] = 2 * lps[i] + 1;\\n        cl--;\\n        cr++;\\n      }\\n      \\n      r = cr - 1;\\n    }\\n\\n    long maxProd = 1;\\n    for (int i = 1; i < s.length(); i++) {\\n      if (starts[i - 1] > 1 && starts[i] == 1) {\\n        starts[i] = starts[i - 1] - 2;\\n      }\\n\\n      ends[i] = Math.max(ends[i - 1], ends[i]);\\n    }\\n\\n    for (int j = s.length() - 2; j >= 0; j--) {\\n      starts[j] = Math.max(starts[j + 1], starts[j]);\\n      maxProd = Math.max(maxProd, ends[j] * starts[j + 1]);\\n    }\\n\\n    return maxProd;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776217,
                "title": "lines-sweep-on-largest-pall-from-center",
                "content": "# Intuition\\nyou must be clear with the concept that we can check weather string is pallindrome or not by matching string\\'s hash and it\\'s reverse hash. After then we can use computation of largest pallindrome possible from any index as center to get desired solution \\n\\n# Approach\\nfirst find hashes for string and it\\'s reverse, such that we can find hash of any substring in O(1) and hence check for pallindrome of some substring becomes O(1). \\n    After then find largest pallindrome that is possible taking every index as center, this can be optimized using binary search. \\n    Now we are required to find largest pallindrome possible for some prefix starting at i , and for some suffix starting from i, this is required to make computation of product by considering each breaking point (i,i+1)th indexes. \\n    These computations are performed using something like line sweep which can be easily understood by implementation, basically idea is to remove elements from our set when they have gone out of bound, and use elements in our set to make computation. \\n    After then we can find largest pallindromic string possible in some prefix i/suffix i (not necessarily ending at i), that will make product computation faster as shown in implemenation \\n\\n# Complexity\\n- Time complexity:\\nNlogN\\n\\n- Space complexity:\\nN\\n\\n# Code\\n```\\n#define ll long long\\nclass Hashing{\\n    int prime = 35, MOD = 1e9+7; \\n    vector<ll> power, left, right;\\n    long long lhash(int l, int r){\\n        return (left[r+1] - (left[l]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    long long rhash(int l, int r){\\n        return (right[l] - (right[r+1]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    public: \\n    bool isPalindrome(int l, int r){\\n        return lhash(l,r) == rhash(l,r);\\n    }\\n    Hashing(string &s): power(s.length()+1,1),left(s.length()+1),right(s.length()+1){\\n        int n = s.length();\\n        for(int i=1;i<n;i+=1) power[i] = (power[i-1]*prime)%MOD; \\n        left[0] = right[n] = 1; \\n        for(int i=0; i<n; i++){\\n            left[i+1] = (prime*left[i] + s[i] - \\'a\\')%MOD;\\n        }\\n        for(int i=n-1;i>=0;i-=1){\\n            right[i] = (right[i+1]*prime + s[i] - \\'a\\')%MOD; \\n        }\\n    }\\n}; \\nint search(Hashing &hash,string &s,int i){\\n    // find index after which increasing length will result in non pall string\\n    int left = 0,right = s.length(); \\n    while(left < right){\\n        int mid = (left + right+1)/2; \\n        if(i-mid >=0 and i+mid < s.length() and hash.isPalindrome(i-mid,i + mid)){\\n            // then try to increase it further \\n            left = mid; \\n        }\\n        else{\\n            right = mid-1; \\n        }\\n    }\\n    return left;  \\n}\\nvector<int> findSuffix(vector<int> &centers){\\n    int n = centers.size(); \\n    vector<int> left(n); \\n    set<pair<int,int> > end; \\n    set<int> center; \\n    for(int i=0;i<n;i+=1){\\n        // insertion time \\n        end.insert({i + centers[i],i}); \\n        center.insert(i); \\n        // removal time \\n        while(end.begin()->first < i) center.erase(end.begin()->second),end.erase(end.begin()); \\n\\n        // value finding time \\n        int minLeftCenter = *center.begin(); \\n        left[i] = 2*(i - minLeftCenter) + 1; \\n\\n        // one of important step \\n        if(i) left[i] = max(left[i],left[i-1]); \\n    }\\n    return left; \\n}\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(); \\n        Hashing hash(s);  // creates hash of string and reverseString then tells weather l,r is pall or not\\n        vector<int> centers(n,1);\\n        for(int i=0;i<n;i+=1) centers[i] = search(hash,s,i);\\n        vector<int> left = findSuffix(centers); \\n        reverse(centers.begin(),centers.end()); \\n        vector<int> right = findSuffix(centers); \\n        reverse(right.begin(),right.end());\\n        ll ans =0 ; \\n        for(int i=0;i<n-1;i+=1){\\n            ans = max(ans,left[i]*1ll*right[i+1]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Hashing{\\n    int prime = 35, MOD = 1e9+7; \\n    vector<ll> power, left, right;\\n    long long lhash(int l, int r){\\n        return (left[r+1] - (left[l]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    long long rhash(int l, int r){\\n        return (right[l] - (right[r+1]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    public: \\n    bool isPalindrome(int l, int r){\\n        return lhash(l,r) == rhash(l,r);\\n    }\\n    Hashing(string &s): power(s.length()+1,1),left(s.length()+1),right(s.length()+1){\\n        int n = s.length();\\n        for(int i=1;i<n;i+=1) power[i] = (power[i-1]*prime)%MOD; \\n        left[0] = right[n] = 1; \\n        for(int i=0; i<n; i++){\\n            left[i+1] = (prime*left[i] + s[i] - \\'a\\')%MOD;\\n        }\\n        for(int i=n-1;i>=0;i-=1){\\n            right[i] = (right[i+1]*prime + s[i] - \\'a\\')%MOD; \\n        }\\n    }\\n}; \\nint search(Hashing &hash,string &s,int i){\\n    // find index after which increasing length will result in non pall string\\n    int left = 0,right = s.length(); \\n    while(left < right){\\n        int mid = (left + right+1)/2; \\n        if(i-mid >=0 and i+mid < s.length() and hash.isPalindrome(i-mid,i + mid)){\\n            // then try to increase it further \\n            left = mid; \\n        }\\n        else{\\n            right = mid-1; \\n        }\\n    }\\n    return left;  \\n}\\nvector<int> findSuffix(vector<int> &centers){\\n    int n = centers.size(); \\n    vector<int> left(n); \\n    set<pair<int,int> > end; \\n    set<int> center; \\n    for(int i=0;i<n;i+=1){\\n        // insertion time \\n        end.insert({i + centers[i],i}); \\n        center.insert(i); \\n        // removal time \\n        while(end.begin()->first < i) center.erase(end.begin()->second),end.erase(end.begin()); \\n\\n        // value finding time \\n        int minLeftCenter = *center.begin(); \\n        left[i] = 2*(i - minLeftCenter) + 1; \\n\\n        // one of important step \\n        if(i) left[i] = max(left[i],left[i-1]); \\n    }\\n    return left; \\n}\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(); \\n        Hashing hash(s);  // creates hash of string and reverseString then tells weather l,r is pall or not\\n        vector<int> centers(n,1);\\n        for(int i=0;i<n;i+=1) centers[i] = search(hash,s,i);\\n        vector<int> left = findSuffix(centers); \\n        reverse(centers.begin(),centers.end()); \\n        vector<int> right = findSuffix(centers); \\n        reverse(right.begin(),right.end());\\n        ll ans =0 ; \\n        for(int i=0;i<n-1;i+=1){\\n            ans = max(ans,left[i]*1ll*right[i+1]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721119,
                "title": "c-manacher-s-algorithm-easy-to-understand-well-documented",
                "content": "# Intuition\\nUse Recursion and DP will still be too slow to solve the question.\\n\\nInstead, use Manacher\\'s algorithm to solve this.\\nManacher\\'s algorithm finds the odd palindrome length on different s[i]\\n\\nAnd then we can calculate the max palindrome len when cutting the string on different s[i].\\n\\n# Approach\\n1. Find all odd palindrome on different s[i]\\n2. Calculate all the max palindrome len on different cut on the left\\n3. Calculate all the max palindrome len on different cut on the right\\n4. For each cut i, times the max len on both side\\n5. Return the max product\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n``` C++\\nclass Solution {\\npublic:\\n\\n    long long maxProduct(string s) {\\n        vector<int> result = getOddPalindromeManacher(s, 0, s.size()-1);\\n        vector<int> left_result = maxLeftOnDifferentCut(result);\\n        vector<int> right_result = maxRightOnDifferentCut(result);\\n\\n        long long max_product = 0;\\n        for(int i=0; i<s.size()-1; i++){\\n            long long product = (long long)left_result[i] * right_result[i+1];\\n            if(product>max_product)\\n                max_product = product;\\n        }\\n        return max_product;\\n    }\\n\\n    vector<int> getOddPalindromeManacher(string& s, int f, int t){\\n        \\n        vector<int> result(s.size(), 1);\\n\\n        int previous_center = -1;\\n        int previous_left = -1;\\n        int previous_right = -1;\\n        for(int i=f; i<=t; i++){\\n            int temp_l = i;\\n            int temp_r = i;\\n            if(previous_right > i){\\n                int mirror_i = previous_center - (i-previous_center);\\n                int mirror_len = result[mirror_i];\\n                int mirror_left = mirror_i - mirror_len/2;\\n                if(mirror_left > previous_left){\\n                    result[i] = mirror_len;\\n                    continue;\\n                }\\n                temp_r = previous_right;\\n                temp_l = i - (previous_right - i);\\n            }\\n\\n            auto [l, r] = getPalindromeRange(s, f, t, i, temp_l, temp_r);\\n            previous_center = i;\\n            previous_left = l;\\n            previous_right = r;\\n            result[i] = r-l+1;\\n\\n        }\\n        return result;\\n    }\\n\\n    inline tuple<int, int> getPalindromeRange(string& s, int f, int t, int i, int l, int r){\\n        l--; r++;\\n\\n        while(l>=f && r<=t){\\n            if(s[l]!=s[r])\\n                break;\\n\\n            l--; r++;\\n        }\\n\\n        l++; r--;\\n        return {l, r};\\n    }\\n\\n    vector<int> maxLeftOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the left on different cut\\n        left_result[i] = the max palindrome len when cutting the array into [0, i] (i, result.size()-1] two slices\\n                         the max_len on the [0, i] side\\n\\n        left_result[i] means the max palindrome len on the left side when s[i] is included in the left side\\n        */\\n        vector<int> left_result = vector<int>(result.size());\\n\\n        left_result[0] = 1;\\n        int limit = 1;\\n        int max_len = 1;\\n        for (int center = 0; center < left_result.size(); center++) {\\n            int most_right = center + ( result[center]-1 ) / 2;\\n\\n            while (limit <= most_right) {\\n                int len = ( limit - center ) * 2 + 1;\\n                if(len>max_len)\\n                    max_len = len;\\n                left_result[limit++] = max_len;\\n            }\\n        }\\n        return left_result;\\n    }\\n\\n    vector<int> maxRightOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the right on different cut\\n        right_result[i] = the max palindrome len when cutting the array into [0, i) [i, result.size()-1] two slices\\n                          the max_len on the [i, result.size()-1] side\\n        \\n        right_result[i] means the max palindrome len on the right side when s[i] is included in the right side\\n        */\\n        vector<int> right_result = vector<int>(result.size());\\n\\n        right_result[result.size()-1] = 1;\\n        int limit = result.size()-2;\\n        int max_len = 1;\\n        for (int center = right_result.size()-1; center >= 0; center--) {\\n            int most_left = center - ( result[center]-1 ) / 2;\\n            \\n            while (most_left <= limit) {\\n                int len = ( center - limit ) * 2 + 1;\\n                if(len > max_len){\\n                    max_len = len;\\n                }\\n                right_result[limit--] = max_len;\\n            }\\n        }\\n        return right_result;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++\\nclass Solution {\\npublic:\\n\\n    long long maxProduct(string s) {\\n        vector<int> result = getOddPalindromeManacher(s, 0, s.size()-1);\\n        vector<int> left_result = maxLeftOnDifferentCut(result);\\n        vector<int> right_result = maxRightOnDifferentCut(result);\\n\\n        long long max_product = 0;\\n        for(int i=0; i<s.size()-1; i++){\\n            long long product = (long long)left_result[i] * right_result[i+1];\\n            if(product>max_product)\\n                max_product = product;\\n        }\\n        return max_product;\\n    }\\n\\n    vector<int> getOddPalindromeManacher(string& s, int f, int t){\\n        \\n        vector<int> result(s.size(), 1);\\n\\n        int previous_center = -1;\\n        int previous_left = -1;\\n        int previous_right = -1;\\n        for(int i=f; i<=t; i++){\\n            int temp_l = i;\\n            int temp_r = i;\\n            if(previous_right > i){\\n                int mirror_i = previous_center - (i-previous_center);\\n                int mirror_len = result[mirror_i];\\n                int mirror_left = mirror_i - mirror_len/2;\\n                if(mirror_left > previous_left){\\n                    result[i] = mirror_len;\\n                    continue;\\n                }\\n                temp_r = previous_right;\\n                temp_l = i - (previous_right - i);\\n            }\\n\\n            auto [l, r] = getPalindromeRange(s, f, t, i, temp_l, temp_r);\\n            previous_center = i;\\n            previous_left = l;\\n            previous_right = r;\\n            result[i] = r-l+1;\\n\\n        }\\n        return result;\\n    }\\n\\n    inline tuple<int, int> getPalindromeRange(string& s, int f, int t, int i, int l, int r){\\n        l--; r++;\\n\\n        while(l>=f && r<=t){\\n            if(s[l]!=s[r])\\n                break;\\n\\n            l--; r++;\\n        }\\n\\n        l++; r--;\\n        return {l, r};\\n    }\\n\\n    vector<int> maxLeftOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the left on different cut\\n        left_result[i] = the max palindrome len when cutting the array into [0, i] (i, result.size()-1] two slices\\n                         the max_len on the [0, i] side\\n\\n        left_result[i] means the max palindrome len on the left side when s[i] is included in the left side\\n        */\\n        vector<int> left_result = vector<int>(result.size());\\n\\n        left_result[0] = 1;\\n        int limit = 1;\\n        int max_len = 1;\\n        for (int center = 0; center < left_result.size(); center++) {\\n            int most_right = center + ( result[center]-1 ) / 2;\\n\\n            while (limit <= most_right) {\\n                int len = ( limit - center ) * 2 + 1;\\n                if(len>max_len)\\n                    max_len = len;\\n                left_result[limit++] = max_len;\\n            }\\n        }\\n        return left_result;\\n    }\\n\\n    vector<int> maxRightOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the right on different cut\\n        right_result[i] = the max palindrome len when cutting the array into [0, i) [i, result.size()-1] two slices\\n                          the max_len on the [i, result.size()-1] side\\n        \\n        right_result[i] means the max palindrome len on the right side when s[i] is included in the right side\\n        */\\n        vector<int> right_result = vector<int>(result.size());\\n\\n        right_result[result.size()-1] = 1;\\n        int limit = result.size()-2;\\n        int max_len = 1;\\n        for (int center = right_result.size()-1; center >= 0; center--) {\\n            int most_left = center - ( result[center]-1 ) / 2;\\n            \\n            while (most_left <= limit) {\\n                int len = ( center - limit ) * 2 + 1;\\n                if(len > max_len){\\n                    max_len = len;\\n                }\\n                right_result[limit--] = max_len;\\n            }\\n        }\\n        return right_result;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669026,
                "title": "rolling-hash-binary-search",
                "content": "We have to do hashing of string and its reverse string so that we can compare two strings by their hash value.\\nIf string and its reverse have same hashed value, then are palindrome.\\nWe will continue expanding from each center to left and right and apply binary search to find maximum length.\\nYou can read about string hashing from here: https://cp-algorithms.com/string/string-hashing.html#search-for-duplicate-strings-in-an-array-of-strings\\n\\nNote: We having followed rolling hash algorithm which itself is deterministic algorithm. \\n\\n**BUT WHO CARES AS LONG AS WE GET AC AND WE DON\\'T WANT TO DEAL WITH GARBAGE ALGORITHM SUCH AS MANACHER WHICH IS NOT INTUITIVE AT ALL.\\nREMEMBER, ANY INTERVIEWER WHO ASKS MANACHER IS PURE EVIL AND DON\\'T WANT YOU IN THEIR COMPANY. **\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    const ll mod=1e9+7;\\n    const ll p=31;\\n    ll n;\\n    \\n    vector<ll> p_pow;\\n    vector<ll> p_inv;\\n    vector<ll> hash,rev_hash;\\n    \\n    \\n    ll fpm(ll x,ll y,ll mod){\\n        ll ans=1;\\n        while(y>0){\\n            if(y&1){\\n                ans=(ans*x)%mod;\\n            }\\n            y>>=1;\\n            x=(x*x)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    ll substr_hash(ll l,ll r,vector<ll> &h){\\n        ll ans=0;\\n        ans+=h[r];\\n        if(l-1>=0){\\n            ans-=h[l-1];\\n        }\\n        if(ans<0){\\n            ans+=mod;\\n        }\\n        ans%=mod;\\n        ans*=p_inv[l];\\n        ans%=mod;\\n        return ans;\\n    }\\n    \\n    // asdsahjkl\\n    // _____\\n    \\n    // lkjhasdsa\\n    //     _____  \\n    \\n    bool pal(ll idx,ll len){\\n        return substr_hash(idx-len,idx,hash)==substr_hash(n-1-idx-len,n-1-idx,rev_hash);\\n    }\\n        \\n    long long maxProduct(string s) {\\n        this->n=s.size();\\n        \\n        p_pow.resize(n);\\n        p_inv.resize(n);\\n        p_pow[0]=1;\\n        p_inv[0]=1;\\n        for(ll i=1;i<n;i++){\\n            p_pow[i]=(p_pow[i-1]*p)%mod;\\n            p_inv[i]=fpm(p_pow[i],mod-2,mod);\\n        }\\n        \\n        hash.resize(n);\\n        hash[0]=(s[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            hash[i]=(hash[i-1]+((s[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        string t=s;\\n        reverse(t.begin(),t.end());\\n        rev_hash.resize(n);\\n        rev_hash[0]=(t[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            rev_hash[i]=(rev_hash[i-1]+((t[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        vector<ll> pref(n,1),suff(n,1);\\n        \\n        for(ll i=0;i<n;i++){\\n            ll l=0, r=min(i,n-i-1);\\n            ll len=0;\\n            while(l<=r){\\n                ll mid=(l+r)/2;\\n                if(pal(i,mid)){\\n                    len=mid;\\n                    l=mid+1;\\n                }else{\\n                    r=mid-1;\\n                }\\n            }\\n            pref[i+len]=max(pref[i+len],2*len+1);\\n            suff[i-len]=max(suff[i-len],2*len+1);\\n        }\\n        \\n        for(ll i=n-2;i>=0;i--){\\n            pref[i]=max(pref[i],pref[i+1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            suff[i]=max(suff[i],suff[i-1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            pref[i]=max(pref[i],pref[i-1]);\\n        }\\n        for(ll i=n-2;i>=0;i--){\\n            suff[i]=max(suff[i],suff[i+1]);\\n        }\\n        \\n        ll ans=1;\\n        for(ll i=1;i<n;i++){\\n            ans=max(ans,pref[i-1]*suff[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    const ll mod=1e9+7;\\n    const ll p=31;\\n    ll n;\\n    \\n    vector<ll> p_pow;\\n    vector<ll> p_inv;\\n    vector<ll> hash,rev_hash;\\n    \\n    \\n    ll fpm(ll x,ll y,ll mod){\\n        ll ans=1;\\n        while(y>0){\\n            if(y&1){\\n                ans=(ans*x)%mod;\\n            }\\n            y>>=1;\\n            x=(x*x)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    ll substr_hash(ll l,ll r,vector<ll> &h){\\n        ll ans=0;\\n        ans+=h[r];\\n        if(l-1>=0){\\n            ans-=h[l-1];\\n        }\\n        if(ans<0){\\n            ans+=mod;\\n        }\\n        ans%=mod;\\n        ans*=p_inv[l];\\n        ans%=mod;\\n        return ans;\\n    }\\n    \\n    // asdsahjkl\\n    // _____\\n    \\n    // lkjhasdsa\\n    //     _____  \\n    \\n    bool pal(ll idx,ll len){\\n        return substr_hash(idx-len,idx,hash)==substr_hash(n-1-idx-len,n-1-idx,rev_hash);\\n    }\\n        \\n    long long maxProduct(string s) {\\n        this->n=s.size();\\n        \\n        p_pow.resize(n);\\n        p_inv.resize(n);\\n        p_pow[0]=1;\\n        p_inv[0]=1;\\n        for(ll i=1;i<n;i++){\\n            p_pow[i]=(p_pow[i-1]*p)%mod;\\n            p_inv[i]=fpm(p_pow[i],mod-2,mod);\\n        }\\n        \\n        hash.resize(n);\\n        hash[0]=(s[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            hash[i]=(hash[i-1]+((s[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        string t=s;\\n        reverse(t.begin(),t.end());\\n        rev_hash.resize(n);\\n        rev_hash[0]=(t[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            rev_hash[i]=(rev_hash[i-1]+((t[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        vector<ll> pref(n,1),suff(n,1);\\n        \\n        for(ll i=0;i<n;i++){\\n            ll l=0, r=min(i,n-i-1);\\n            ll len=0;\\n            while(l<=r){\\n                ll mid=(l+r)/2;\\n                if(pal(i,mid)){\\n                    len=mid;\\n                    l=mid+1;\\n                }else{\\n                    r=mid-1;\\n                }\\n            }\\n            pref[i+len]=max(pref[i+len],2*len+1);\\n            suff[i-len]=max(suff[i-len],2*len+1);\\n        }\\n        \\n        for(ll i=n-2;i>=0;i--){\\n            pref[i]=max(pref[i],pref[i+1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            suff[i]=max(suff[i],suff[i-1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            pref[i]=max(pref[i],pref[i-1]);\\n        }\\n        for(ll i=n-2;i>=0;i--){\\n            suff[i]=max(suff[i],suff[i+1]);\\n        }\\n        \\n        ll ans=1;\\n        for(ll i=1;i<n;i++){\\n            ans=max(ans,pref[i-1]*suff[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485021,
                "title": "manchter-algo-c-solution-with-intitution",
                "content": "# Intuition\\n\\nFirst i figure that it is a string question . \\nSo generally people may know only kmp and rabin carp . \\nAfter 20-30 min you may figure that both cannot be used to find palindromes in o(n) ;\\nNow there should another algo , \\nthat is :  manchter algo to find maximum length string centered at i for whole string from (i = 1 to n ) in o(n) time . \\nand the rest is manchter algo theory .\\nYou may refer cp algorithm for this . \\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nTC = o(n) .\\nas outer loop from 1 to n . \\nfor inner while loop . if statement will overcome that \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> manacher_odd(string s ){\\n        int n = s.length();\\n        s = \"^\" + s + \"$\" ; \\n        vector<int> p(n+2 , 1);\\n        vector<int> lr(n+2 , 1 );\\n        int l = 1 , r = 1 ;\\n        for(int i = 1 ; i<= n ; ++i ){\\n        \\n            if( r >= i )p[i] = max(p[i] , min( 2*(r-i) + 1 , p[l+(r-i)] )) ;\\n            int c = (p[i] + 1 ) / 2  ;\\n            while(s[i-c] == s[c+i]){\\n                p[i] += 2 ;\\n                lr[i + c] = p[i] ;\\n                ++c ;\\n            } \\n            --c;\\n            if(i+c > r ){\\n                l = i-c ;\\n                r = i+c ;\\n            }\\n        }\\n        for(int i = 1 ; i<= n ; ++i ){\\n            lr[i] = max( lr[i] , lr[i-1] ) ;\\n        }\\n        return vector<int>(begin(lr) +1 , end(lr) -1) ;\\n    }\\n\\n    long long maxProduct(string s) {\\n        vector<int> pre = manacher_odd(s) ;\\n        reverse(s.begin() , s.end() ) ; \\n        vector<int> suff = manacher_odd(s) ;\\n        reverse(suff.begin() , suff.end() ) ;\\n        int n = pre.size() ;\\n        \\n        long long res = 1 ;\\n        for(int i = 0 ; i< n-1 ; ++i ){\\n            res = max( pre[i] * 1LL * suff[i+1] , res ) ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> manacher_odd(string s ){\\n        int n = s.length();\\n        s = \"^\" + s + \"$\" ; \\n        vector<int> p(n+2 , 1);\\n        vector<int> lr(n+2 , 1 );\\n        int l = 1 , r = 1 ;\\n        for(int i = 1 ; i<= n ; ++i ){\\n        \\n            if( r >= i )p[i] = max(p[i] , min( 2*(r-i) + 1 , p[l+(r-i)] )) ;\\n            int c = (p[i] + 1 ) / 2  ;\\n            while(s[i-c] == s[c+i]){\\n                p[i] += 2 ;\\n                lr[i + c] = p[i] ;\\n                ++c ;\\n            } \\n            --c;\\n            if(i+c > r ){\\n                l = i-c ;\\n                r = i+c ;\\n            }\\n        }\\n        for(int i = 1 ; i<= n ; ++i ){\\n            lr[i] = max( lr[i] , lr[i-1] ) ;\\n        }\\n        return vector<int>(begin(lr) +1 , end(lr) -1) ;\\n    }\\n\\n    long long maxProduct(string s) {\\n        vector<int> pre = manacher_odd(s) ;\\n        reverse(s.begin() , s.end() ) ; \\n        vector<int> suff = manacher_odd(s) ;\\n        reverse(suff.begin() , suff.end() ) ;\\n        int n = pre.size() ;\\n        \\n        long long res = 1 ;\\n        for(int i = 0 ; i< n-1 ; ++i ){\\n            res = max( pre[i] * 1LL * suff[i+1] , res ) ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450051,
                "title": "find-the-maximum-product-of-two-non-intersecting-palindromic-substrings-in-javascript",
                "content": "# Intuition\\nThe code uses dynamic programming to solve the problem of finding the maximum product of the lengths of two non-intersecting palindromic substrings of odd length in a given string.\\n\\nThe approach is to first calculate the longest palindrome centered at each index of the string using Manacher\\'s algorithm. This is done by maintaining two pointers c and r that keep track of the center and right boundary of the palindrome, respectively. For each index i, we check if it is within the current palindrome (i.e., i <= r). If it is, we can take advantage of the palindrome\\'s symmetry to determine the length of the palindrome centered at i. Otherwise, we start a new palindrome centered at i and expand it until it can no longer be extended.\\n\\nOnce we have computed the length of the longest palindrome centered at each index, we can use this information to calculate the length of the longest palindrome to the left and right of each index. This is done by iterating through the string and keeping track of the maximum length of palindrome seen so far to the left and right of each index.\\n\\nFinally, we iterate through the string and calculate the product of the lengths of the two non-intersecting palindromic substrings of odd length that can be formed using the palindromes to the left and right of each index. We keep track of the maximum product seen so far and return it as the result.\\n\\n# Approach\\nThe approach used in the code is to find all the palindromic substrings in the given string and then choose two non-intersecting palindromic substrings of odd length such that their product of lengths is maximized.\\n\\nThe algorithm uses Manacher\\'s algorithm to find all palindromic substrings in the given string. Manacher\\'s algorithm is a linear time algorithm that finds all palindromic substrings in a given string.\\n\\nThe algorithm uses three arrays to keep track of information about each character in the string:\\n\\n1. dp[i]: the length of the longest palindromic substring centered at i.\\n\\n2. before[i]: the length of the longest palindromic substring to the left of i.\\n\\n3. after[i]: the length of the longest palindromic substring to the right of i.\\n\\nTo find the palindromic substrings, the algorithm iterates through the string and uses two pointers, p and q, to expand around each character in the string. It checks if the characters at positions p and q are equal, and if they are, it updates the before and after arrays accordingly. It also updates the dp array to keep track of the longest palindromic substring centered at each character.\\n\\nOnce the algorithm has found all the palindromic substrings in the string, it iterates through the string again and computes the product of the lengths of the two non-intersecting palindromic substrings of odd length that have the maximum product. It does this by computing the maximum product for each position in the string and keeping track of the maximum product seen so far.\\n\\nFinally, the algorithm returns the maximum product of the lengths of the two non-intersecting palindromic substrings of odd length.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Title: Maximum Product of the Length of Two Palindromic Substrings\\n * Description: You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive. Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\\n * Author: Hasibul Islam\\n * Date: 24/04/2023\\n */\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction maxProduct(s) {\\n    let n = s.length;\\n\\n    let dp = new Array(n).fill(0);\\n    let before = new Array(n).fill(0);\\n    let after = new Array(n).fill(0);\\n\\n    let c = -1;\\n    let r = -1;\\n\\n    for (let i = 0; i < n; i++) {\\n        let k = i <= r ? Math.min(dp[2 * c - i], r - i) : 0;\\n        let p = i - k;\\n        let q = i + k;\\n\\n        while (p >= 0 && q < n && s[p] === s[q]) {\\n            before[q] = Math.max(before[q], q - p + 1);\\n            after[p] = Math.max(after[p], q - p + 1);\\n            p--;\\n            q++;\\n        }\\n\\n        dp[i] = q - i - 1;\\n\\n        if (q - 1 > r) {\\n            c = i;\\n            r = q - 1;\\n        }\\n    }\\n\\n    for (let i = 1; i < n; i++) {\\n        before[i] = Math.max(before[i - 1], before[i]);\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        after[i] = Math.max(after[i + 1], after[i]);\\n    }\\n\\n    let result = 0;\\n\\n    for (let i = 1; i < n; i++) {\\n        result = Math.max(result, before[i - 1] * after[i]);\\n    }\\n\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Title: Maximum Product of the Length of Two Palindromic Substrings\\n * Description: You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive. Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\\n * Author: Hasibul Islam\\n * Date: 24/04/2023\\n */\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction maxProduct(s) {\\n    let n = s.length;\\n\\n    let dp = new Array(n).fill(0);\\n    let before = new Array(n).fill(0);\\n    let after = new Array(n).fill(0);\\n\\n    let c = -1;\\n    let r = -1;\\n\\n    for (let i = 0; i < n; i++) {\\n        let k = i <= r ? Math.min(dp[2 * c - i], r - i) : 0;\\n        let p = i - k;\\n        let q = i + k;\\n\\n        while (p >= 0 && q < n && s[p] === s[q]) {\\n            before[q] = Math.max(before[q], q - p + 1);\\n            after[p] = Math.max(after[p], q - p + 1);\\n            p--;\\n            q++;\\n        }\\n\\n        dp[i] = q - i - 1;\\n\\n        if (q - 1 > r) {\\n            c = i;\\n            r = q - 1;\\n        }\\n    }\\n\\n    for (let i = 1; i < n; i++) {\\n        before[i] = Math.max(before[i - 1], before[i]);\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        after[i] = Math.max(after[i + 1], after[i]);\\n    }\\n\\n    let result = 0;\\n\\n    for (let i = 1; i < n; i++) {\\n        result = Math.max(result, before[i - 1] * after[i]);\\n    }\\n\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442147,
                "title": "python-simple-manacher-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n\\n        dp, before, after = [0]*n, [0]*n, [0]*n\\n\\n        c, r = -1, -1\\n\\n        for i in range(n):\\n            k = min(dp[2*c-i],r-i) if i<=r else 0\\n            p, q = i-k, i+k\\n\\n            while p>=0 and q<n and s[p] == s[q]:\\n                before[q] = max(before[q],q-p+1)\\n                after[p] = max(after[p],q-p+1)\\n                p -= 1\\n                q += 1\\n\\n            dp[i] = q-i-1\\n\\n            if q-1 > r: c, r = i, q-1\\n\\n        for i in range(1,n):\\n            before[i] = max(before[i-1],before[i])\\n\\n        for i in range(n-2,-1,-1):\\n            after[i] = max(after[i+1],after[i])\\n\\n        return max([before[i-1]*after[i] for i in range(1,n)])\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n\\n        dp, before, after = [0]*n, [0]*n, [0]*n\\n\\n        c, r = -1, -1\\n\\n        for i in range(n):\\n            k = min(dp[2*c-i],r-i) if i<=r else 0\\n            p, q = i-k, i+k\\n\\n            while p>=0 and q<n and s[p] == s[q]:\\n                before[q] = max(before[q],q-p+1)\\n                after[p] = max(after[p],q-p+1)\\n                p -= 1\\n                q += 1\\n\\n            dp[i] = q-i-1\\n\\n            if q-1 > r: c, r = i, q-1\\n\\n        for i in range(1,n):\\n            before[i] = max(before[i-1],before[i])\\n\\n        for i in range(n-2,-1,-1):\\n            after[i] = max(after[i+1],after[i])\\n\\n        return max([before[i-1]*after[i] for i in range(1,n)])\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357650,
                "title": "c-manacher-s-prefix-max-array",
                "content": "# Approach\\nFirst we need to find Longest Palindromic Substring using Manacher\\'s.\\n\\nWhen expanding palindroms in Manacher\\'s, we also update `L` and `R`\\n- `L[i]`: the max length of palindrom that ends at `i`\\n- `R[i]`: the max length of palindrom that starts at `i`\\n\\nThen we compute a prefix for `R` from right to left, and try to combine it with `L` to find the answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maxProduct(string s0) {\\n      int n = s0.size();\\n      string s(n*2+1, \\'-\\');\\n      for (int i = 0; i < n; ++i) s[2*i+1] = s0[i];\\n      vector<int> DP(s.size(), 0), L(n, 0), R(n, 0);\\n      auto update = [&](int i, int len) {\\n        int j = (i-1)/2, h = len/2;\\n        int l = j-h, r = j+h;\\n        if (s[i] != \\'-\\') L[r] = max(L[r], len), R[l] = max(R[l], len);\\n        DP[i] = len;\\n      };\\n      for (int i = 0, r = 0, c = 0; i < s.size(); ++i) {\\n        auto& len = DP[i];\\n        if (i < r) update(i, min(DP[2*c-i], r-i));\\n        while (i+len+1 < s.size() && i-len-1 >= 0 && s[i+len+1] == s[i-len-1]) {\\n          update(i, len+1);\\n        }\\n        if (i+len > r) c = i, r = i+len;\\n      }\\n      for (int i = R.size()-2; i >= 0; --i) {\\n        R[i] = max(R[i], R[i+1]);\\n      }\\n      ll res = 0;\\n      for (int i = 1; i < n; ++i) {\\n        res = max(res, (ll)L[i-1]*R[i]);\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maxProduct(string s0) {\\n      int n = s0.size();\\n      string s(n*2+1, \\'-\\');\\n      for (int i = 0; i < n; ++i) s[2*i+1] = s0[i];\\n      vector<int> DP(s.size(), 0), L(n, 0), R(n, 0);\\n      auto update = [&](int i, int len) {\\n        int j = (i-1)/2, h = len/2;\\n        int l = j-h, r = j+h;\\n        if (s[i] != \\'-\\') L[r] = max(L[r], len), R[l] = max(R[l], len);\\n        DP[i] = len;\\n      };\\n      for (int i = 0, r = 0, c = 0; i < s.size(); ++i) {\\n        auto& len = DP[i];\\n        if (i < r) update(i, min(DP[2*c-i], r-i));\\n        while (i+len+1 < s.size() && i-len-1 >= 0 && s[i+len+1] == s[i-len-1]) {\\n          update(i, len+1);\\n        }\\n        if (i+len > r) c = i, r = i+len;\\n      }\\n      for (int i = R.size()-2; i >= 0; --i) {\\n        R[i] = max(R[i], R[i+1]);\\n      }\\n      ll res = 0;\\n      for (int i = 1; i < n; ++i) {\\n        res = max(res, (ll)L[i-1]*R[i]);\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141405,
                "title": "python-manacher",
                "content": "```\\n    def maxProduct(self, s: str) -> int:\\n        dp, before, after = [0] * len(s), [0] * len(s), [0] * len(s)\\n        c, r = -1, -1\\n        for i in range(len(s)):\\n            k = min(dp[2 * c - i], r - i) if i <= r else 0\\n            p, q = i - k, i + k\\n            while p >= 0 and q < len(s) and s[p] == s[q]:\\n                before[q] = max(before[q], q - p + 1)\\n                after[p] = max(after[p], q - p + 1)\\n                p -= 1; q += 1\\n            dp[i] = q - i - 1\\n            if q - 1 > r: c, r = i, q - 1\\n        for i in range(1, len(s)): before[i] = max(before[i - 1], before[i])\\n        for i in range(len(s) - 2, -1, -1): after[i] = max(after[i + 1], after[i])\\n        return max(before[i - 1] * after[i] for i in range(1, len(s)))\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProduct(self, s: str) -> int:\\n        dp, before, after = [0] * len(s), [0] * len(s), [0] * len(s)\\n        c, r = -1, -1\\n        for i in range(len(s)):\\n            k = min(dp[2 * c - i], r - i) if i <= r else 0\\n            p, q = i - k, i + k\\n            while p >= 0 and q < len(s) and s[p] == s[q]:\\n                before[q] = max(before[q], q - p + 1)\\n                after[p] = max(after[p], q - p + 1)\\n                p -= 1; q += 1\\n            dp[i] = q - i - 1\\n            if q - 1 > r: c, r = i, q - 1\\n        for i in range(1, len(s)): before[i] = max(before[i - 1], before[i])\\n        for i in range(len(s) - 2, -1, -1): after[i] = max(after[i + 1], after[i])\\n        return max(before[i - 1] * after[i] for i in range(1, len(s)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3099551,
                "title": "premium-limited-explained-solution",
                "content": "\\n```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854992,
                "title": "o-n-log-n-rolling-hash-binary-search-dp-w-priority-queue",
                "content": "The idea is that we treat every `i` as the center of the palindrome and do a binary search on the side length of the palindrome. To make comparing the sides of the palindrome O(1), we precompute the rolling hash for the string in both directions (because palindrome mirrors each other at the center). We store for every `i` the width of the side length of the longest palindrome when `i` is the center.\\n\\nAfter that, we\\'d like a DP to tell us the longest palindrome to either the left or the right of the current position, so that in the end we can do `left_dp[i] * right_dp[i + 1]`. To do this, we\\'ll take `left_dp` as an example. We want to keep track of the **leftmost center of the palindrome that can reach the current position**, because that\\'d give us the longest palindrome that can reach the current position. Let\\'s keep track of that via a priority queue, and we\\'ll pop off the palindromes that can\\'t reach here. What if the longest palindrome to the left isn\\'t directly reaching the current `i`? well we\\'ll just take the maximum answer so far from the left, via `left_dp[i - 1]`. This way, the longest palindrome will be carried over and updated at a certain point if necessary. Then, we use this logic for `right_dp` too.\\n\\n---\\n\\n```cpp\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\n\\ntemplate <int MOD = 1\\'000\\'000\\'007> struct mod_int {\\n  long long v{};\\n  mod_int() = default;\\n  mod_int(long long vx) : v((vx + MOD) % MOD) {}\\n  mod_int &operator=(long long vx) {\\n    v = (vx + MOD) % MOD;\\n    return *this;\\n  }\\n  friend mod_int operator+(const mod_int &a, const mod_int &b) { return (a.v + b.v) % MOD; }\\n  friend mod_int operator+(long long a, const mod_int &b) { return ((a + MOD) % MOD + b.v) % MOD; }\\n  friend mod_int operator+(const mod_int &a, long long b) { return (a.v + (b + MOD) % MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, const mod_int &b) { return (a.v - b.v + MOD) % MOD; }\\n  friend mod_int operator-(long long a, const mod_int &b) { return ((a + MOD) % MOD - b.v + MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, long long b) { return (a.v - (b + MOD) % MOD + MOD) % MOD; }\\n  friend mod_int operator*(const mod_int &a, const mod_int &b) { return (a.v * b.v) % MOD; }\\n  friend mod_int operator*(long long a, const mod_int &b) { return (((a + MOD) % MOD) * b.v) % MOD; }\\n  friend mod_int operator*(const mod_int &a, long long b) { return (a.v * ((b + MOD) % MOD)) % MOD; }\\n  friend bool operator==(const mod_int &a, const mod_int &b) { return a.v == b.v; }\\n  friend bool operator!=(const mod_int &a, const mod_int &b) { return a.v != b.v; }\\n};\\n\\nclass Solution {\\npublic:\\n  long long maxProduct(string s) {\\n    int n = s.size();\\n    constexpr int P1 = 31, P2 = 33, M1 = 1e9 + 7, M2 = 1e9 + 9;\\n\\n    using num1 = mod_int<M1>;\\n    using num2 = mod_int<M2>;\\n\\n    vector<pair<num1, num2>> powers(n + 1, {1, 1});\\n    for (int i = 1; i <= n; i++) {\\n      powers[i].first = powers[i - 1].first * P1;\\n      powers[i].second = powers[i - 1].second * P2;\\n    }\\n\\n    vector<pair<num1, num2>> fwd_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      fwd_hash[i + 1].first = fwd_hash[i].first + (s[i] - \\'a\\' + 1) * powers[i].first;\\n      fwd_hash[i + 1].second = fwd_hash[i].second + (s[i] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<pair<num1, num2>> back_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      back_hash[i + 1].first = back_hash[i].first + (s[n - i - 1] - \\'a\\' + 1) * powers[i].first;\\n      back_hash[i + 1].second = back_hash[i].second + (s[n - i - 1] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<int> center_width(n);\\n    for (int i = 0; i < n; i++) {\\n      int l = 1, r = min(n - i, n - (n - i - 1)), res = 1;\\n      while (l <= r) {\\n        int m = (l + r) / 2;\\n\\n        num1 fwd_hash1 = fwd_hash[i + m].first - fwd_hash[i].first;\\n        num2 fwd_hash2 = fwd_hash[i + m].second - fwd_hash[i].second;\\n        num1 back_hash1 = back_hash[n - i - 1 + m].first - back_hash[n - i - 1].first;\\n        num2 back_hash2 = back_hash[n - i - 1 + m].second - back_hash[n - i - 1].second;\\n\\n        num1 fwd_hash1_exp = 1;\\n        num2 fwd_hash2_exp = 1;\\n        num1 back_hash1_exp = 1;\\n        num2 back_hash2_exp = 1;\\n        int dist1 = i + 1, dist2 = n - i;\\n        if (dist1 > dist2) {\\n          back_hash1_exp = powers[dist1 - dist2].first;\\n          back_hash2_exp = powers[dist1 - dist2].second;\\n        } else if (dist1 < dist2) {\\n          fwd_hash1_exp = powers[dist2 - dist1].first;\\n          fwd_hash2_exp = powers[dist2 - dist1].second;\\n        }\\n\\n        if (fwd_hash1 * fwd_hash1_exp == back_hash1 * back_hash1_exp &&\\n            fwd_hash2 * fwd_hash2_exp == back_hash2 * back_hash2_exp) {\\n          l = m + 1;\\n          res = m;\\n        } else {\\n          r = m - 1;\\n        }\\n      }\\n      center_width[i] = res;\\n    }\\n\\n    using T = pair<int, int>; // [center, end]\\n\\n    priority_queue<T, vector<T>, greater<T>> min_centers;\\n    vector<int> left_dp(n + 1, 1);\\n    for (int i = 0; i < n; i++) {\\n      left_dp[i + 1] = left_dp[i];\\n\\n      min_centers.emplace(i, i + center_width[i] - 1);\\n      while (!min_centers.empty() && min_centers.top().second < i) {\\n        min_centers.pop();\\n      }\\n      if (!min_centers.empty()) {\\n        amax(left_dp[i + 1], (i - min_centers.top().first) * 2 + 1);\\n      }\\n    }\\n\\n    priority_queue<T> max_centers;\\n    vector<int> right_dp(n + 1, 1);\\n    for (int i = 0, j = n - 1; i < n; i++, j--) {\\n      right_dp[i + 1] = right_dp[i];\\n\\n      max_centers.emplace(j, j - center_width[j] + 1);\\n      while (!max_centers.empty() && max_centers.top().second > j) {\\n        max_centers.pop();\\n      }\\n      if (!max_centers.empty()) {\\n        amax(right_dp[i + 1], (max_centers.top().first - j) * 2 + 1);\\n      }\\n    }\\n\\n    long long ans = 1;\\n    for (int i = 1, j = n - 1; i < n; i++, j--) {\\n      amax(ans, (long long)left_dp[i] * (long long)right_dp[j]);\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Rolling Hash",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\n\\ntemplate <int MOD = 1\\'000\\'000\\'007> struct mod_int {\\n  long long v{};\\n  mod_int() = default;\\n  mod_int(long long vx) : v((vx + MOD) % MOD) {}\\n  mod_int &operator=(long long vx) {\\n    v = (vx + MOD) % MOD;\\n    return *this;\\n  }\\n  friend mod_int operator+(const mod_int &a, const mod_int &b) { return (a.v + b.v) % MOD; }\\n  friend mod_int operator+(long long a, const mod_int &b) { return ((a + MOD) % MOD + b.v) % MOD; }\\n  friend mod_int operator+(const mod_int &a, long long b) { return (a.v + (b + MOD) % MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, const mod_int &b) { return (a.v - b.v + MOD) % MOD; }\\n  friend mod_int operator-(long long a, const mod_int &b) { return ((a + MOD) % MOD - b.v + MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, long long b) { return (a.v - (b + MOD) % MOD + MOD) % MOD; }\\n  friend mod_int operator*(const mod_int &a, const mod_int &b) { return (a.v * b.v) % MOD; }\\n  friend mod_int operator*(long long a, const mod_int &b) { return (((a + MOD) % MOD) * b.v) % MOD; }\\n  friend mod_int operator*(const mod_int &a, long long b) { return (a.v * ((b + MOD) % MOD)) % MOD; }\\n  friend bool operator==(const mod_int &a, const mod_int &b) { return a.v == b.v; }\\n  friend bool operator!=(const mod_int &a, const mod_int &b) { return a.v != b.v; }\\n};\\n\\nclass Solution {\\npublic:\\n  long long maxProduct(string s) {\\n    int n = s.size();\\n    constexpr int P1 = 31, P2 = 33, M1 = 1e9 + 7, M2 = 1e9 + 9;\\n\\n    using num1 = mod_int<M1>;\\n    using num2 = mod_int<M2>;\\n\\n    vector<pair<num1, num2>> powers(n + 1, {1, 1});\\n    for (int i = 1; i <= n; i++) {\\n      powers[i].first = powers[i - 1].first * P1;\\n      powers[i].second = powers[i - 1].second * P2;\\n    }\\n\\n    vector<pair<num1, num2>> fwd_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      fwd_hash[i + 1].first = fwd_hash[i].first + (s[i] - \\'a\\' + 1) * powers[i].first;\\n      fwd_hash[i + 1].second = fwd_hash[i].second + (s[i] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<pair<num1, num2>> back_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      back_hash[i + 1].first = back_hash[i].first + (s[n - i - 1] - \\'a\\' + 1) * powers[i].first;\\n      back_hash[i + 1].second = back_hash[i].second + (s[n - i - 1] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<int> center_width(n);\\n    for (int i = 0; i < n; i++) {\\n      int l = 1, r = min(n - i, n - (n - i - 1)), res = 1;\\n      while (l <= r) {\\n        int m = (l + r) / 2;\\n\\n        num1 fwd_hash1 = fwd_hash[i + m].first - fwd_hash[i].first;\\n        num2 fwd_hash2 = fwd_hash[i + m].second - fwd_hash[i].second;\\n        num1 back_hash1 = back_hash[n - i - 1 + m].first - back_hash[n - i - 1].first;\\n        num2 back_hash2 = back_hash[n - i - 1 + m].second - back_hash[n - i - 1].second;\\n\\n        num1 fwd_hash1_exp = 1;\\n        num2 fwd_hash2_exp = 1;\\n        num1 back_hash1_exp = 1;\\n        num2 back_hash2_exp = 1;\\n        int dist1 = i + 1, dist2 = n - i;\\n        if (dist1 > dist2) {\\n          back_hash1_exp = powers[dist1 - dist2].first;\\n          back_hash2_exp = powers[dist1 - dist2].second;\\n        } else if (dist1 < dist2) {\\n          fwd_hash1_exp = powers[dist2 - dist1].first;\\n          fwd_hash2_exp = powers[dist2 - dist1].second;\\n        }\\n\\n        if (fwd_hash1 * fwd_hash1_exp == back_hash1 * back_hash1_exp &&\\n            fwd_hash2 * fwd_hash2_exp == back_hash2 * back_hash2_exp) {\\n          l = m + 1;\\n          res = m;\\n        } else {\\n          r = m - 1;\\n        }\\n      }\\n      center_width[i] = res;\\n    }\\n\\n    using T = pair<int, int>; // [center, end]\\n\\n    priority_queue<T, vector<T>, greater<T>> min_centers;\\n    vector<int> left_dp(n + 1, 1);\\n    for (int i = 0; i < n; i++) {\\n      left_dp[i + 1] = left_dp[i];\\n\\n      min_centers.emplace(i, i + center_width[i] - 1);\\n      while (!min_centers.empty() && min_centers.top().second < i) {\\n        min_centers.pop();\\n      }\\n      if (!min_centers.empty()) {\\n        amax(left_dp[i + 1], (i - min_centers.top().first) * 2 + 1);\\n      }\\n    }\\n\\n    priority_queue<T> max_centers;\\n    vector<int> right_dp(n + 1, 1);\\n    for (int i = 0, j = n - 1; i < n; i++, j--) {\\n      right_dp[i + 1] = right_dp[i];\\n\\n      max_centers.emplace(j, j - center_width[j] + 1);\\n      while (!max_centers.empty() && max_centers.top().second > j) {\\n        max_centers.pop();\\n      }\\n      if (!max_centers.empty()) {\\n        amax(right_dp[i + 1], (max_centers.top().first - j) * 2 + 1);\\n      }\\n    }\\n\\n    long long ans = 1;\\n    for (int i = 1, j = n - 1; i < n; i++, j--) {\\n      amax(ans, (long long)left_dp[i] * (long long)right_dp[j]);\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783052,
                "title": "c-manacher",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        auto t = s;\\n        reverse(t.begin(), t.end());\\n        auto v =prefixLen(s), u = prefixLen(t);\\n        long long res = 0;\\n        for(int i=0, n = s.size();i<n-1;i++){\\n            res = max(res, (long long)v[i] * u[n-i-2]);\\n        }\\n        return res;\\n    }\\n    \\n    //https://cp-algorithms.com/string/manacher.html#solution\\n    vector<int> manacher_odd(string s) {\\n        int n = s.size();\\n        s = \"$\" + s + \"^\";\\n        vector<int> p(n + 2);\\n        int l = 1, r = 1;\\n        for(int i = 1; i <= n; i++) {\\n            p[i] = max(0, min(r - i, p[l + (r - i)]));\\n            while(s[i - p[i]] == s[i + p[i]]) {\\n                p[i]++;\\n            }\\n            if(i + p[i] > r) {\\n                l = i - p[i], r = i + p[i];\\n            }\\n        }\\n        return vector<int>(begin(p) + 1, end(p) - 1);\\n    }\\n    \\n    vector<int> prefixLen(const string& s){\\n        int maxLen = 0;\\n        auto manacher = manacher_odd(s);\\n        const int n = s.size();\\n        vector<int> res(n, 1);\\n        for(int i=0, j=0;i<n;i++){\\n            int len = manacher[i]-1;\\n            for(; j <= i+len; j++){\\n                maxLen = max(maxLen, 1+2*(j-i));\\n                res[j] = maxLen;\\n            } \\n        }\\n        return res;\\n    }   \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        auto t = s;\\n        reverse(t.begin(), t.end());\\n        auto v =prefixLen(s), u = prefixLen(t);\\n        long long res = 0;\\n        for(int i=0, n = s.size();i<n-1;i++){\\n            res = max(res, (long long)v[i] * u[n-i-2]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2664337,
                "title": "rust-solution-using-manacher-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt needs something no worse than O(NLogN) since N could be as  big as 100000. Manacher algorithm is a good candidate since it calculates all odd length palindromic substrings in O(N) time.      \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce we the length vector of palindromic substrings  calculated using Manacher algorithm, we can use VecDeque to calculate the max lengths of odd length palindromic substrings for two groups [..i] &  [i+1..].\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn max_product(s: String) -> i64 {\\n        let data = Self::manacher_odd(&s);\\n        //for d in v { println![\"{}\", d]; } \\n        \\n        let n = data.len();\\n        let mut q = VecDeque::<(i32, i32)>::new();\\n        let mut right= vec![1; n];\\n\\n        for i in (0..n).rev() {\\n            while let Some(a) = q.front() {\\n                if a.0 - a.1 <= i as i32 { break }\\n                q.pop_front();\\n            }\\n            \\n            if let Some(a) = q.front() {\\n                right[i] += (a.0 - i as i32) * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n        }\\n\\n        while q.is_empty() == false { q.pop_front(); } \\n        let (mut ret, mut mx_left) = (1, 1);\\n        for i in 0..n - 1 {\\n            let mut temp = 1;\\n\\n            while let Some(a) = q.front() {\\n                if a.0 + a.1 >= i as i32 { break }\\n                q.pop_front();\\n            }\\n\\n            if let Some(a) = q.front() {\\n                temp += (i as i32 - a.0) as i64 * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n\\n            mx_left = mx_left.max(temp);\\n            ret = ret.max(mx_left * right[i + 1] as i64);\\n        }\\n\\n        ret\\n    }\\n\\n    // Adapted from:   https://cp-algorithms.com/string/manacher.html\\n    fn manacher_odd(s: &String) -> Vec<i32> {\\n        let n = s.len();\\n        let s = String::from(\"$\") + s + &String::from(\"^\");\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut p = vec![0; n + 2];\\n        \\n        let (mut l, mut r) = (1, 1);\\n\\n        for i in 1..=n {\\n            p[i] = i32::max(0, i32::min(r - i as i32, p[(l + (r - i as i32)) as usize]));\\n            while (s[i - p[i] as usize] == s[i + p[i] as usize]) {\\n                p[i] += 1;\\n            }\\n\\n            if i as i32 + p[i] > r {\\n                l = i as i32 - p[i];\\n                r = i as i32 + p[i];\\n            }\\n        }\\n\\n         p.pop();\\n         p.remove(0);         \\n         p\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn max_product(s: String) -> i64 {\\n        let data = Self::manacher_odd(&s);\\n        //for d in v { println![\"{}\", d]; } \\n        \\n        let n = data.len();\\n        let mut q = VecDeque::<(i32, i32)>::new();\\n        let mut right= vec![1; n];\\n\\n        for i in (0..n).rev() {\\n            while let Some(a) = q.front() {\\n                if a.0 - a.1 <= i as i32 { break }\\n                q.pop_front();\\n            }\\n            \\n            if let Some(a) = q.front() {\\n                right[i] += (a.0 - i as i32) * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n        }\\n\\n        while q.is_empty() == false { q.pop_front(); } \\n        let (mut ret, mut mx_left) = (1, 1);\\n        for i in 0..n - 1 {\\n            let mut temp = 1;\\n\\n            while let Some(a) = q.front() {\\n                if a.0 + a.1 >= i as i32 { break }\\n                q.pop_front();\\n            }\\n\\n            if let Some(a) = q.front() {\\n                temp += (i as i32 - a.0) as i64 * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n\\n            mx_left = mx_left.max(temp);\\n            ret = ret.max(mx_left * right[i + 1] as i64);\\n        }\\n\\n        ret\\n    }\\n\\n    // Adapted from:   https://cp-algorithms.com/string/manacher.html\\n    fn manacher_odd(s: &String) -> Vec<i32> {\\n        let n = s.len();\\n        let s = String::from(\"$\") + s + &String::from(\"^\");\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut p = vec![0; n + 2];\\n        \\n        let (mut l, mut r) = (1, 1);\\n\\n        for i in 1..=n {\\n            p[i] = i32::max(0, i32::min(r - i as i32, p[(l + (r - i as i32)) as usize]));\\n            while (s[i - p[i] as usize] == s[i + p[i] as usize]) {\\n                p[i] += 1;\\n            }\\n\\n            if i as i32 + p[i] > r {\\n                l = i as i32 - p[i];\\n                r = i as i32 + p[i];\\n            }\\n        }\\n\\n         p.pop();\\n         p.remove(0);         \\n         p\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2216044,
                "title": "manachers-algo-without-queue-with-explanation",
                "content": "We need to find a place to split the string so that we can use the max lengths of the palindrom of the two substrings to multiply. The manachers algo can give us the longest palindrom at each center location. So the idea becomes how to convert the center to its left and right boundary, then we can scan the boundaries to find the largest palindrom on the left or right of a particular index.\\n\\nAs a starting point, below is the original manachers algo code with some explanation for reference.\\n\\n```\\n    int longestPalindrom(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1);\\n        \\n        int lp = 0;   // the index of the center position of previous longer palindrom, used as mirror\\n\\t\\tint ans = 1;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {                                   // check if a mirrored version exists.\\n                int j = lp - (i - lp);                                // this is the mirror of the current number\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;  // using the portion contained within the longer palindrom\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {                              // try to extend the new palindrom over the longer palindrom\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n\\t\\t\\tans = max(l, ans);\\n        }\\n        return ans;\\n\\t}\\n```\\n\\nNow, we need to add some statements to keep track of the boundaries of the palindroms.\\n\\n```\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1), lb(n,1), rb(n,1); // two more array to keep track of the size at left and right boundaries\\n        \\n        int lp = 0;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {\\n                int j = lp - (i - lp);\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    rb[i+l/2+1] = max(rb[i+l/2+1], l+2);                     // store the size at the right boundary of the palingdrom\\n                    lb[i-l/2-1] = max(lb[i-l/2-1], l+2);                     // now on the left boundary\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n            lb[i-p[i]/2] = max(lb[i-p[i]/2], p[i]);              // in case we dont get to store it during the extending part\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // why do we only fix the left boundaries here? think about it \\n        }\\n\\n\\t\\t// ...\\n\\t\\t// to be continued\\n\\t\\t// ...\\n\\t}\\n```\\n\\nNow, aggregate on the boundaries to get the maxmum on each side of each indices.\\n\\n```\\n        for(int i=1;i<n;i++) rb[i] = max(rb[i],rb[i-1]);  // each position now stores the largest size of palingroms on its left side\\n        for(int i=n-2;i>=0;i--) lb[i] = max(lb[i], lb[i+1]);  // same on the right side\\n```\\n\\nIn the end, get the max products.\\n\\n```\\n        long long product = 0;\\n        for(int i=0;i<n-1;i++) {\\n            product = max(product, (long long)rb[i]*lb[i+1]); // max palindrom to the left of i is rb[i] (inclusive), and\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // max palindrom to the right of i is lb[i+1](exclusive)\\n        }\\n        return product;\\n```\\nPlease vote if you feel this is helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int longestPalindrom(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1);\\n        \\n        int lp = 0;   // the index of the center position of previous longer palindrom, used as mirror\\n\\t\\tint ans = 1;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {                                   // check if a mirrored version exists.\\n                int j = lp - (i - lp);                                // this is the mirror of the current number\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;  // using the portion contained within the longer palindrom\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {                              // try to extend the new palindrom over the longer palindrom\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n\\t\\t\\tans = max(l, ans);\\n        }\\n        return ans;\\n\\t}\\n```\n```\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1), lb(n,1), rb(n,1); // two more array to keep track of the size at left and right boundaries\\n        \\n        int lp = 0;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {\\n                int j = lp - (i - lp);\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    rb[i+l/2+1] = max(rb[i+l/2+1], l+2);                     // store the size at the right boundary of the palingdrom\\n                    lb[i-l/2-1] = max(lb[i-l/2-1], l+2);                     // now on the left boundary\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n            lb[i-p[i]/2] = max(lb[i-p[i]/2], p[i]);              // in case we dont get to store it during the extending part\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // why do we only fix the left boundaries here? think about it \\n        }\\n\\n\\t\\t// ...\\n\\t\\t// to be continued\\n\\t\\t// ...\\n\\t}\\n```\n```\\n        for(int i=1;i<n;i++) rb[i] = max(rb[i],rb[i-1]);  // each position now stores the largest size of palingroms on its left side\\n        for(int i=n-2;i>=0;i--) lb[i] = max(lb[i], lb[i+1]);  // same on the right side\\n```\n```\\n        long long product = 0;\\n        for(int i=0;i<n-1;i++) {\\n            product = max(product, (long long)rb[i]*lb[i+1]); // max palindrom to the left of i is rb[i] (inclusive), and\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // max palindrom to the right of i is lb[i+1](exclusive)\\n        }\\n        return product;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2193011,
                "title": "manacher-algorithm-dp-90-100",
                "content": "```\\nclass Solution {\\n    public long maxProduct(String s) {\\n        return this.maxP(s);\\n    }\\n    int[] left(int[] ps) {\\n        int[] ret = new int[ps.length];\\n        ret[0] = 1;\\n        int j = 1;\\n        for (int i = 0; i < ps.length; i++) {\\n            int r = i + (ps[i]-1)/2;\\n            while (j <= r) {\\n                ret[j] = (j-i)*2+1;\\n                j++;\\n            }\\n        }\\n        return ret;\\n    }\\n    long maxP(String s) {\\n        int[] ps = this.computePalindrome(s);\\n        int[] ls = this.left(ps);\\n        //System.out.println(Arrays.toString(ls));\\n        long c = 0, maxr = 0;\\n        int j = s.length()-1;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            int l = i - (ps[i]-1)/2;\\n            while (j >= l) {\\n                int k = (i - j)*2 + 1;\\n                if (j > 0) {\\n                    maxr = Math.max(maxr, k);\\n                    c = Math.max(c, maxr * ls[j-1]);\\n                }\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n    int[] computePalindrome(String s) {\\n        int j = 0, l = 0, r = 0;\\n        int[] ret = new int[s.length()];\\n        ret[0] = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (i > r) {\\n                j = i; \\n                l=r=i;\\n                while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                    l--; r++;\\n                }\\n                l++; r--;\\n                ret[i] = r -l + 1;\\n            } else {\\n                int k = l + r -i;\\n                if ((ret[k] -1)/2 < (r-i)) {\\n                    ret[i] = ret[k];\\n                } else {\\n                    ret[i] = 1 + 2*(r-i);\\n                    l = i - (r-i);\\n                    r = i + (r-i);\\n                    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                        l--;r++;\\n                    }\\n                    l++; r--;\\n                    ret[i] = r -l +1;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxProduct(String s) {\\n        return this.maxP(s);\\n    }\\n    int[] left(int[] ps) {\\n        int[] ret = new int[ps.length];\\n        ret[0] = 1;\\n        int j = 1;\\n        for (int i = 0; i < ps.length; i++) {\\n            int r = i + (ps[i]-1)/2;\\n            while (j <= r) {\\n                ret[j] = (j-i)*2+1;\\n                j++;\\n            }\\n        }\\n        return ret;\\n    }\\n    long maxP(String s) {\\n        int[] ps = this.computePalindrome(s);\\n        int[] ls = this.left(ps);\\n        //System.out.println(Arrays.toString(ls));\\n        long c = 0, maxr = 0;\\n        int j = s.length()-1;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            int l = i - (ps[i]-1)/2;\\n            while (j >= l) {\\n                int k = (i - j)*2 + 1;\\n                if (j > 0) {\\n                    maxr = Math.max(maxr, k);\\n                    c = Math.max(c, maxr * ls[j-1]);\\n                }\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n    int[] computePalindrome(String s) {\\n        int j = 0, l = 0, r = 0;\\n        int[] ret = new int[s.length()];\\n        ret[0] = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (i > r) {\\n                j = i; \\n                l=r=i;\\n                while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                    l--; r++;\\n                }\\n                l++; r--;\\n                ret[i] = r -l + 1;\\n            } else {\\n                int k = l + r -i;\\n                if ((ret[k] -1)/2 < (r-i)) {\\n                    ret[i] = ret[k];\\n                } else {\\n                    ret[i] = 1 + 2*(r-i);\\n                    l = i - (r-i);\\n                    r = i + (r-i);\\n                    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                        l--;r++;\\n                    }\\n                    l++; r--;\\n                    ret[i] = r -l +1;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863436,
                "title": "incorrected-expected-output",
                "content": "\"rofcjxfkbzcvvlbkgcwtcjctwcgkblvvczbkfxjcfor\" is a of length 43 which is a palendrome but expected output is 41 , any reason why?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1428950,
                "title": "using-manacher-and-queue",
                "content": "```\\nclass Solution {\\n    vector<int> pref, suf, lps;\\n    int sz;\\npublic:\\n    long long maxProduct(string s) {\\n        sz = s.size();\\n        lps.resize(sz); \\n        pref.resize(sz, 1);\\n        suf.resize(sz, 1);\\n        manacher(s);\\n        construct();\\n        \\n        for(int i =1 ; i<sz; i++){\\n            pref[i] = max(pref[i-1], pref[i]);\\n        }\\n        for(int i =sz-2 ; i>-1; i--){\\n            suf[i] = max(suf[i+1], suf[i]);\\n        }\\n        long long ret = 1;\\n        \\n        \\n        for(int i= 0; i< sz-1; i++){\\n            ret = max(ret, 1LL*pref[i]*suf[i+1]);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    \\n    void construct(){\\n        queue<int> bag1, bag2;\\n        \\n        for(int i = 0 ;i < sz; i++){\\n            bag1.push(i);\\n            while(bag1.front() + lps[bag1.front()] < i){\\n                bag1.pop();\\n            }\\n            if(i!=0) pref[i] = max(pref[i-1], 2*(i - bag1.front()) + 1); \\n        }\\n        \\n        for(int i = sz-1; i > -1; i--){\\n            bag2.push(i);\\n            while(bag2.front() - lps[bag2.front()] > i){\\n                bag2.pop();\\n            }\\n            if(i!=sz-1) suf[i] = max(suf[i+1], 2*(bag2.front() - i) + 1); \\n        }\\n    }\\n    \\n    \\n    void manacher(string & s){\\n        int center = -1, right  = -1;\\n        for(int i = 0; i<sz; i++){\\n            int d = (i>right? 1:min(lps[2*center - i] + 1, right+1- i));\\n            while(i+d< sz && i-d >-1 && s[i-d] == s[i+d]) d++;\\n            lps[i] = d - 1;\\n            if(i+d-1 > right){\\n                center = i, right = i + d - 1 ;\\n            }  \\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> pref, suf, lps;\\n    int sz;\\npublic:\\n    long long maxProduct(string s) {\\n        sz = s.size();\\n        lps.resize(sz); \\n        pref.resize(sz, 1);\\n        suf.resize(sz, 1);\\n        manacher(s);\\n        construct();\\n        \\n        for(int i =1 ; i<sz; i++){\\n            pref[i] = max(pref[i-1], pref[i]);\\n        }\\n        for(int i =sz-2 ; i>-1; i--){\\n            suf[i] = max(suf[i+1], suf[i]);\\n        }\\n        long long ret = 1;\\n        \\n        \\n        for(int i= 0; i< sz-1; i++){\\n            ret = max(ret, 1LL*pref[i]*suf[i+1]);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    \\n    void construct(){\\n        queue<int> bag1, bag2;\\n        \\n        for(int i = 0 ;i < sz; i++){\\n            bag1.push(i);\\n            while(bag1.front() + lps[bag1.front()] < i){\\n                bag1.pop();\\n            }\\n            if(i!=0) pref[i] = max(pref[i-1], 2*(i - bag1.front()) + 1); \\n        }\\n        \\n        for(int i = sz-1; i > -1; i--){\\n            bag2.push(i);\\n            while(bag2.front() - lps[bag2.front()] > i){\\n                bag2.pop();\\n            }\\n            if(i!=sz-1) suf[i] = max(suf[i+1], 2*(bag2.front() - i) + 1); \\n        }\\n    }\\n    \\n    \\n    void manacher(string & s){\\n        int center = -1, right  = -1;\\n        for(int i = 0; i<sz; i++){\\n            int d = (i>right? 1:min(lps[2*center - i] + 1, right+1- i));\\n            while(i+d< sz && i-d >-1 && s[i-d] == s[i+d]) d++;\\n            lps[i] = d - 1;\\n            if(i+d-1 > right){\\n                center = i, right = i + d - 1 ;\\n            }  \\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426256,
                "title": "how-do-you-get-a-length-product-of-45-for-this-input-string",
                "content": "LeetCode has 45 as the answer for this input: \"ggbswiymmlevedhkbdhntnhdbkhdevelmmyiwsbgg\"\\nWhat two odd-length palindrome lengths form that product? I use a brute-force palidrome algoirithm which comes up with only 3 odd-length palidromes that aren\\'t single letter:\\n\\n(center at index, total length)\\n(11,3)\\n(20,41)\\n(29,3)\\n\\nMy algo therefore says the max product is 9\\n",
                "solutionTags": [],
                "code": "LeetCode has 45 as the answer for this input: \"ggbswiymmlevedhkbdhntnhdbkhdevelmmyiwsbgg\"\\nWhat two odd-length palindrome lengths form that product? I use a brute-force palidrome algoirithm which comes up with only 3 odd-length palidromes that aren\\'t single letter:\\n\\n(center at index, total length)\\n(11,3)\\n(20,41)\\n(29,3)\\n\\nMy algo therefore says the max product is 9\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1402462,
                "title": "c-28-ms-faster-than-98-10-5-mb-less-space-than-100",
                "content": "class Solution {\\npublic:\\n    long long maxProduct(string &s) {\\n        \\n        int n = s.size(),c=0,r=0,mx=1,p[n],left[100000]={0};\\n        left[0]=1;\\n        for(int i=0;i<n;i++){\\n            p[i]=1;\\n            if(i<r)\\n                p[i] = min((r-i)*2+1,p[c-(i-c)]);\\n            \\n            int dist=p[i]/2 + 1;\\n            while(i+dist<n && i-dist>=0 && s[i+dist]==s[i-dist])\\n                p[i]+=2, dist++;\\n            \\n            if(i+dist-1>r)\\n                c=i, r= i + dist-1;\\n            for(int val = p[i],x=i+p[i]/2;left[x]==0;x--,val-=2)\\n                left[x]=max(mx,val);\\n            mx = max(mx,p[i]);\\n        }\\n        mx=1;\\n        long long ans = 1;\\n        int lefti = n;\\n        for(int i=n-1;i>=1;i--){\\n            int l, r, x=i-p[i]/2, val=p[i];\\n            \\n            if(i-p[i]/2 <1)\\n                x++,val-=2;\\n\\t\\t\\tr = left[x-1];\\n\\t\\t\\t\\n            for(;x<lefti ; x++,val-=2){\\n                l = r, r = left[x], left[x]=max(mx,val);\\n                ans = max(ans,1ll*l*left[x]);\\n            }\\n            mx = max(mx,p[i]);\\n            lefti = min(lefti,i-p[i]/2);\\n        }\\n        return ans;\\n    }                                               \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxProduct(string &s) {\\n        \\n        int n = s.size(),c=0,r=0,mx=1,p[n],left[100000]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1399400,
                "title": "c-manacher",
                "content": "```\\nclass Solution {\\npublic:\\n\\tlong long maxProduct(string s) {\\n\\t\\tvector<long long> len(s.size());\\n\\t\\tint mx = 0;\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tif (i < mx + len[mx]) {\\n\\t\\t\\t\\tlen[i] = min(len[2 * mx - i], (long long)mx + len[mx] - i);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (i - len[i] >= 0 && i + len[i] < s.size() && s[i - len[i]] == s[i + len[i]]) {\\n\\t\\t\\t\\tlen[i]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (mx + len[mx] < i + len[i]) {\\n\\t\\t\\t\\tmx = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> left(s.size()) , right(s.size());\\n\\n\\t\\tleft[0] = 1;\\n\\t\\tfor (int i = 1, p = 0; i < s.size(); ++i) {\\n\\t\\t\\twhile (p + len[p] - 1 < i) ++p;\\n\\t\\t\\tleft[i] = max(left[i - 1], 2 * (i - p) + 1);\\n\\t\\t}\\n\\n\\t\\tright[s.size() - 1] = 1;\\n\\t\\tfor (int i = s.size() - 2, p = s.size() - 1; i >= 0; --i) {\\n\\t\\t\\twhile (p - len[p] + 1 > i) --p;\\n\\t\\t\\tright[i] = max(right[i + 1], 2 * (p - i) + 1);\\n\\t\\t}\\n\\n\\t\\tlong long ret = 0;\\n\\t\\tfor (int i = 0; i + 1 < s.size(); ++i)\\n\\t\\t\\tret = max(ret, 1ll * left[i] * right[i + 1]);\\n\\t\\treturn ret;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tlong long maxProduct(string s) {\\n\\t\\tvector<long long> len(s.size());\\n\\t\\tint mx = 0;\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tif (i < mx + len[mx]) {\\n\\t\\t\\t\\tlen[i] = min(len[2 * mx - i], (long long)mx + len[mx] - i);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (i - len[i] >= 0 && i + len[i] < s.size() && s[i - len[i]] == s[i + len[i]]) {\\n\\t\\t\\t\\tlen[i]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (mx + len[mx] < i + len[i]) {\\n\\t\\t\\t\\tmx = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> left(s.size()) , right(s.size());\\n\\n\\t\\tleft[0] = 1;\\n\\t\\tfor (int i = 1, p = 0; i < s.size(); ++i) {\\n\\t\\t\\twhile (p + len[p] - 1 < i) ++p;\\n\\t\\t\\tleft[i] = max(left[i - 1], 2 * (i - p) + 1);\\n\\t\\t}\\n\\n\\t\\tright[s.size() - 1] = 1;\\n\\t\\tfor (int i = s.size() - 2, p = s.size() - 1; i >= 0; --i) {\\n\\t\\t\\twhile (p - len[p] + 1 > i) --p;\\n\\t\\t\\tright[i] = max(right[i + 1], 2 * (p - i) + 1);\\n\\t\\t}\\n\\n\\t\\tlong long ret = 0;\\n\\t\\tfor (int i = 0; i + 1 < s.size(); ++i)\\n\\t\\t\\tret = max(ret, 1ll * left[i] * right[i + 1]);\\n\\t\\treturn ret;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399080,
                "title": "java-o-n-modified-odd-manacher",
                "content": "Didn\\'t know anything about Manacher algorithm so far.\\nhttps://cp-algorithms.com/string/manacher.html#toc-tgt-6\\n\\n```\\n    public long maxProduct(String str) {\\n        StringBuilder sb = new StringBuilder(str);\\n        int len = sb.length();\\n        int[] dpl = new int[len];\\n        int[] dpr = new int[len];\\n        modifiedOddManacher(sb.toString(), dpl);\\n        modifiedOddManacher(sb.reverse().toString(), dpr);\\n        long max=1;\\n        for(int i=0;i<len-1;i++)\\n            max=Math.max(max, (1+(dpl[i]-1)*2L)*(1+(dpr[len-(i+1)-1]-1)*2L));\\n        return max;\\n    }\\n    private void modifiedOddManacher(String str, int[] dp){\\n        int len = str.length();\\n        int[] center = new int[len];\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n               while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) {\\n                  dp[i+radius] = radius+1;\\n                  radius++;\\n               }\\n            center[i] = radius--;\\n            if(i+radius>r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n        for(int i=0, max=1;i<len;i++){\\n            max = Math.max(max, dp[i]);\\n            dp[i] = max;\\n        }\\n    }\\n```\\n\\nJust comapare with basic odd Manacher for better understanding.\\n```\\n   private void oddManacher(String str){\\n        int len = str.length();\\n        int[] center = new int[len];\\n\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n            while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) \\n                radius++;\\n\\n            center[i] = radius--;\\n            if(i+radius > r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long maxProduct(String str) {\\n        StringBuilder sb = new StringBuilder(str);\\n        int len = sb.length();\\n        int[] dpl = new int[len];\\n        int[] dpr = new int[len];\\n        modifiedOddManacher(sb.toString(), dpl);\\n        modifiedOddManacher(sb.reverse().toString(), dpr);\\n        long max=1;\\n        for(int i=0;i<len-1;i++)\\n            max=Math.max(max, (1+(dpl[i]-1)*2L)*(1+(dpr[len-(i+1)-1]-1)*2L));\\n        return max;\\n    }\\n    private void modifiedOddManacher(String str, int[] dp){\\n        int len = str.length();\\n        int[] center = new int[len];\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n               while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) {\\n                  dp[i+radius] = radius+1;\\n                  radius++;\\n               }\\n            center[i] = radius--;\\n            if(i+radius>r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n        for(int i=0, max=1;i<len;i++){\\n            max = Math.max(max, dp[i]);\\n            dp[i] = max;\\n        }\\n    }\\n```\n```\\n   private void oddManacher(String str){\\n        int len = str.length();\\n        int[] center = new int[len];\\n\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n            while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) \\n                radius++;\\n\\n            center[i] = radius--;\\n            if(i+radius > r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1396294,
                "title": "java-dp-bottom-up-easy-to-understand-beats-100",
                "content": "- cost[i][j] denotes the minimum space wasted between index i to j\\n- dp[i][k] denotes the minumum space wasted between index 0 to i with k resizing operations\\n```\\npublic int minSpaceWastedKResizing(int[] nums, int K) {\\n\\tfinal int n = nums.length;\\n\\tint[][] cost = new int[n][n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint max = nums[i];\\n\\t\\tint sum = 0;\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tsum += nums[j];\\n\\t\\t\\tmax = Math.max(max, nums[j]);\\n\\t\\t\\tcost[i][j] = max * (j - i + 1) - sum;\\n\\t\\t}\\n\\t}\\n\\tint[][] dp = new int[n][K+1];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i][0] = cost[0][i];\\n\\t}\\n\\tfor (int k = 1; k <= K; k++) {\\n\\t\\tdp[0][k] = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tdp[i][k] = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tdp[i][k] = Math.min(dp[i][k], dp[j][k-1] + cost[j+1][i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n-1][K];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSpaceWastedKResizing(int[] nums, int K) {\\n\\tfinal int n = nums.length;\\n\\tint[][] cost = new int[n][n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint max = nums[i];\\n\\t\\tint sum = 0;\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tsum += nums[j];\\n\\t\\t\\tmax = Math.max(max, nums[j]);\\n\\t\\t\\tcost[i][j] = max * (j - i + 1) - sum;\\n\\t\\t}\\n\\t}\\n\\tint[][] dp = new int[n][K+1];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i][0] = cost[0][i];\\n\\t}\\n\\tfor (int k = 1; k <= K; k++) {\\n\\t\\tdp[0][k] = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tdp[i][k] = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tdp[i][k] = Math.min(dp[i][k], dp[j][k-1] + cost[j+1][i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n-1][K];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395341,
                "title": "c-kmp-like-without-manacher-o-n-time-o-n-space",
                "content": "1. Let\\'s go left ot right and remember all palindroms ends on position and hold in in allpals = std::vector<std::vector<int>>. So    allpals[5] == {1,3,5} means we have 3 palindroms size 1 (subsbring [5,5]), 3 ([3,5]) and 5 ([1,5])\\n2. allpals[0] == {1}\\n3. On position pos > 1 we could check all palindroms allpals[pos - 1] and for palindrom p_i we check if s[pos] == s[pos - p_i - 1]. This is enough for add new palindrom with len (p_i + 2) to allpals[pos]\\n\\n```\\n\\n....?PPPPPPPPC\\nc - is current position,\\n(P) - is palindrome with len = p_i\\n\\n```\\n4. But this it require O(n* n) mem &time.\\n6.  Lets see closer to all palindroms, end on pos = pos.   \\np_1...p_n\\n```\\nour string\\n............................\\n...........PPPPPPPPP    -first palindrome\\n.............DDDDDDD   -second palindrome\\n...........DDDDDDD..   -second palindrome reverse (because P - is palindrome)\\n```\\n8.    As we see below, d* and D* also palindrome\\n9.    all palindrome which less than d for pos = pos, are alse palindrome for (pos - 2) (in this example.\\n10.    So, we just need take largest palindrome P, and second appropriate (D). and store position, when D is holds. (in this example pos - 2)\\n11.    Idea is the same, as for prefix-function KMP algo or Aho\\u2013Corasick (for backlinks)\\n12. so, we need to store largest palindrom. and link to previous. So, jump to this links we can enumerate all palindroms, ends on position.\\n13. for this task there is smaxforw array for max palindrome, end no far than pos\\n14. This algo works good for odd & even palindroms. (rather than manacher ;)\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        const int nsize = s.size();\\n        \\n        using vi = std::vector<long long>;\\n        \\n        auto make_buf = [&]() {\\n            vi maxforw(nsize, 1);\\n            vi smaxforw(nsize, 1);\\n            vi prevpos(nsize, -1);\\n\\n\\n            maxforw[0] = 1;\\n            smaxforw[0] = 1;\\n            prevpos[0] = -1;\\n\\n            for (int pos = 1; pos < nsize; ++pos) {\\n                int prev = pos - 1;\\n                int curmax = 1;\\n                while (prev >= 0) {\\n                    int prevlen = maxforw[prev];\\n                    int pp = pos - prevlen - 1;\\n                    if (pp >= 0 && s[pos] == s[pp]) {\\n                        curmax = prevlen + 2;\\n                        break;\\n                    }\\n                    prev = prevpos[prev];\\n                }\\n                prevpos[pos] = prev;\\n                maxforw[pos] = curmax;\\n                smaxforw[pos] = std::max(smaxforw[pos - 1], maxforw[pos]);\\n            }\\n            return std::move(smaxforw);\\n        };\\n        \\n        auto&& forw = make_buf();\\n        std::reverse(s.begin(), s.end());\\n        auto&& rev = make_buf();\\n        \\n        long long best = 1;\\n        \\n        for (int pos = 1; pos < nsize; ++pos) {\\n            best = std::max(best, forw[pos - 1] * rev[nsize - 1 - pos]);\\n        }\\n        return best;\\n    }\\n};\\n```\\n\\nalgo need  2 * n memorty. (value + prev position for each posigion)",
                "solutionTags": [],
                "code": "```\\n\\n....?PPPPPPPPC\\nc - is current position,\\n(P) - is palindrome with len = p_i\\n\\n```\n```\\nour string\\n............................\\n...........PPPPPPPPP    -first palindrome\\n.............DDDDDDD   -second palindrome\\n...........DDDDDDD..   -second palindrome reverse (because P - is palindrome)\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        const int nsize = s.size();\\n        \\n        using vi = std::vector<long long>;\\n        \\n        auto make_buf = [&]() {\\n            vi maxforw(nsize, 1);\\n            vi smaxforw(nsize, 1);\\n            vi prevpos(nsize, -1);\\n\\n\\n            maxforw[0] = 1;\\n            smaxforw[0] = 1;\\n            prevpos[0] = -1;\\n\\n            for (int pos = 1; pos < nsize; ++pos) {\\n                int prev = pos - 1;\\n                int curmax = 1;\\n                while (prev >= 0) {\\n                    int prevlen = maxforw[prev];\\n                    int pp = pos - prevlen - 1;\\n                    if (pp >= 0 && s[pos] == s[pp]) {\\n                        curmax = prevlen + 2;\\n                        break;\\n                    }\\n                    prev = prevpos[prev];\\n                }\\n                prevpos[pos] = prev;\\n                maxforw[pos] = curmax;\\n                smaxforw[pos] = std::max(smaxforw[pos - 1], maxforw[pos]);\\n            }\\n            return std::move(smaxforw);\\n        };\\n        \\n        auto&& forw = make_buf();\\n        std::reverse(s.begin(), s.end());\\n        auto&& rev = make_buf();\\n        \\n        long long best = 1;\\n        \\n        for (int pos = 1; pos < nsize; ++pos) {\\n            best = std::max(best, forw[pos - 1] * rev[nsize - 1 - pos]);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391496,
                "title": "rolling-hash-cpp-nlogn-solution",
                "content": "First we find the longest palindrome we can get from each point, for this we can use [Manacher\\'s Algorithm](https://cp-algorithms.com/string/manacher.html) or we can use [polynomial hashing](https://codeforces.com/blog/entry/60445) .\\n\\\\\\nHere we used polynomial hashing with binary search to optimise our palindrome search\\n\\n```\\nvector<long long> pows;\\nlong long hash = 3137;\\nbool done = true;\\nconst int mod = 1e9 + 7;\\nlong long LeftHash[100005], RightHash[100005];\\nvoid init() {\\n    done = false;\\n    pows.resize(100005, 1);\\n    for(int i = 1; i < 100005; i++){\\n        pows[i] = (1LL*pows[i-1]*(::hash)) % mod;\\n    }\\n}\\nlong long HashValue(int ind, int len, long long a[100005]) {\\n    long long retval =  a[ind + len] - a[ind]*pows[len];\\n    retval %= mod;\\n    if(retval < 0) retval += mod;\\n    return retval;\\n}\\n\\nlong long Find_Longest_Palindrome_From_Current_Index(string &str, int i) {\\n    int n = str.length();\\n    int s = 0, e = min(i , n - i - 1);\\n    while(s < e) {\\n        int lens = (s + e + 1) >> 1;\\n        if(HashValue(i - lens, lens, LeftHash) ==  HashValue(n - i - lens - 1, lens, RightHash)) {\\n            s = lens;\\n        } else {\\n            e = lens - 1;\\n        }\\n    }\\n    return s;\\n }\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        if(done) init();\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            LeftHash[i+1] = (LeftHash[i]* ::hash + s[i]) % mod;\\n            RightHash[i+1] = (RightHash[i]*::hash + s[n - i - 1]) % mod;\\n        }\\n        vector<long long> left(n, 1), right(n,1);\\n        for(int i = 0; i < n; i++) {\\n            int get =  Find_Longest_Palindrome_From_Current_Index(s,i);\\n            left[i + get] = max<long long>(left[i + get], 2*get + 1);\\n            right[i - get] = max<long long>(right[i - get], 2*get + 1);\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n            left[i] = max<long long>(left[i], left[i+1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            right[i] = max<long long>(right[i], right[i-1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            left[i] = max<long long>(left[i-1], left[i]);\\n            right[n-i-1] = max<long long>(right[n-i], right[n-i-1]);\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            ans = max<long long>(ans, left[i-1]*right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvector<long long> pows;\\nlong long hash = 3137;\\nbool done = true;\\nconst int mod = 1e9 + 7;\\nlong long LeftHash[100005], RightHash[100005];\\nvoid init() {\\n    done = false;\\n    pows.resize(100005, 1);\\n    for(int i = 1; i < 100005; i++){\\n        pows[i] = (1LL*pows[i-1]*(::hash)) % mod;\\n    }\\n}\\nlong long HashValue(int ind, int len, long long a[100005]) {\\n    long long retval =  a[ind + len] - a[ind]*pows[len];\\n    retval %= mod;\\n    if(retval < 0) retval += mod;\\n    return retval;\\n}\\n\\nlong long Find_Longest_Palindrome_From_Current_Index(string &str, int i) {\\n    int n = str.length();\\n    int s = 0, e = min(i , n - i - 1);\\n    while(s < e) {\\n        int lens = (s + e + 1) >> 1;\\n        if(HashValue(i - lens, lens, LeftHash) ==  HashValue(n - i - lens - 1, lens, RightHash)) {\\n            s = lens;\\n        } else {\\n            e = lens - 1;\\n        }\\n    }\\n    return s;\\n }\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        if(done) init();\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            LeftHash[i+1] = (LeftHash[i]* ::hash + s[i]) % mod;\\n            RightHash[i+1] = (RightHash[i]*::hash + s[n - i - 1]) % mod;\\n        }\\n        vector<long long> left(n, 1), right(n,1);\\n        for(int i = 0; i < n; i++) {\\n            int get =  Find_Longest_Palindrome_From_Current_Index(s,i);\\n            left[i + get] = max<long long>(left[i + get], 2*get + 1);\\n            right[i - get] = max<long long>(right[i - get], 2*get + 1);\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n            left[i] = max<long long>(left[i], left[i+1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            right[i] = max<long long>(right[i], right[i-1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            left[i] = max<long long>(left[i-1], left[i]);\\n            right[n-i-1] = max<long long>(right[n-i], right[n-i-1]);\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            ans = max<long long>(ans, left[i-1]*right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390752,
                "title": "c-manacher-no-queue-o-n",
                "content": "Manacher algorithm with a small patch: every time we find a new palindrome, we record it in two arrays: left and right.\\nleft(x) means there is a palindrome on the left side of x ending at x, right(x) means there is a palindrome on the right side of x.\\nThe arrays hold the radii of the respective palindromes.\\nIf a few palindromes end at the same x, we store the largest radius only.\\n\\nIn the end, we do two passes over the arrays to find for each x the largest palindrome ending at x or before, and starting at x or later.\\n\\nThen we consider all pairs (left(x-1)\\\\*2+1) * (right(x)\\\\*2+1) to find the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(), c = 0, r = 0;\\n        vector<int> rr(n), left(n), right(n);\\n        while(c < n)\\n        {\\n            // grow the palindrome\\n            while(c-(r+1)>=0 && c+(r+1)<n && s[c-(r+1)]==s[c+(r+1)])\\n            {\\n                r++;\\n                // record palindrome radius r ending at c+r and c-r\\n                left [c+r] = max(left [c+r],r);\\n                right[c-r] = max(right[c-r],r);\\n            }\\n\\n            // done at c, move on\\n            int c_old = c, r_old = r;\\n            rr[c++] = r;\\n            r = 0;\\n            \\n            // Manacher\\'s mirror\\n            for(;c-c_old <= r_old && c-c_old <= c_old;c++)\\n            {\\n                int c_mirr = c_old - (c-c_old);\\n                int r_mirr = r_old - (c-c_old);\\n                if(rr[c_mirr]==r_mirr) {r = r_mirr; break;}\\n                rr[c] = min(r_mirr,rr[c_mirr]);\\n                \\n                // record palindrom radius rr[c] ending at c+rr[c], c-rr[c]\\n                left [c+rr[c]] = max(left [c+rr[c]],rr[c]);\\n                right[c-rr[c]] = max(right[c-rr[c]],rr[c]);\\n            }\\n        }\\n        \\n\\t\\t// process the arrays to track the best palindromes found on the left and the right side\\n        int mx = 0; for(int i = 0;   i <  n; i++) left[i]  = max( left [i], mx = max(mx,left [i]) );\\n            mx = 0; for(int i = n-1; i >= 0; i--) right[i] = max( right[i], mx = max(mx,right[i]) );\\n\\n        // consider all left[x-1] * right[x] pairs, but remember to convert radii to lengths\\n        long long o = 0;\\n        for(int i = 1; i < n; i++) o = max(o, (left[i-1]*2+1)*(long long)(right[i]*2+1));\\n        return o;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(), c = 0, r = 0;\\n        vector<int> rr(n), left(n), right(n);\\n        while(c < n)\\n        {\\n            // grow the palindrome\\n            while(c-(r+1)>=0 && c+(r+1)<n && s[c-(r+1)]==s[c+(r+1)])\\n            {\\n                r++;\\n                // record palindrome radius r ending at c+r and c-r\\n                left [c+r] = max(left [c+r],r);\\n                right[c-r] = max(right[c-r],r);\\n            }\\n\\n            // done at c, move on\\n            int c_old = c, r_old = r;\\n            rr[c++] = r;\\n            r = 0;\\n            \\n            // Manacher\\'s mirror\\n            for(;c-c_old <= r_old && c-c_old <= c_old;c++)\\n            {\\n                int c_mirr = c_old - (c-c_old);\\n                int r_mirr = r_old - (c-c_old);\\n                if(rr[c_mirr]==r_mirr) {r = r_mirr; break;}\\n                rr[c] = min(r_mirr,rr[c_mirr]);\\n                \\n                // record palindrom radius rr[c] ending at c+rr[c], c-rr[c]\\n                left [c+rr[c]] = max(left [c+rr[c]],rr[c]);\\n                right[c-rr[c]] = max(right[c-rr[c]],rr[c]);\\n            }\\n        }\\n        \\n\\t\\t// process the arrays to track the best palindromes found on the left and the right side\\n        int mx = 0; for(int i = 0;   i <  n; i++) left[i]  = max( left [i], mx = max(mx,left [i]) );\\n            mx = 0; for(int i = n-1; i >= 0; i--) right[i] = max( right[i], mx = max(mx,right[i]) );\\n\\n        // consider all left[x-1] * right[x] pairs, but remember to convert radii to lengths\\n        long long o = 0;\\n        for(int i = 1; i < n; i++) o = max(o, (left[i-1]*2+1)*(long long)(right[i]*2+1));\\n        return o;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566188,
                "content": [
                    {
                        "username": "megaspazz",
                        "content": "I was unable to come up with any alternatives, and ended up using Manacher\\'s Algorithm, but I had thought that this was typically out of the scope of LeetCode problems.\\n\\nIt is mentioned in [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/solution/), which I\\'d consider to be the most direct application / use of Manacher\\'s Algorithm, but even for that problem, it was optional as an O(N^2) solution was accepted due to the smaller constraints.\\n\\nIn my memory, this is the first problem to actually need Manacher\\'s Algorithm to pass all test cases, but was wondering if this isn\\'t the first one and/or if there were alternate solutions to this problem.\\n\\nHas LeetCode has raised the bar of difficulty on contest problems?"
                    }
                ]
            }
        ]
    }
]