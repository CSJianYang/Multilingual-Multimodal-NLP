[
    {
        "title": "Triangle",
        "question_content": "Given a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n&nbsp;\nExample 1:\n\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\nExample 2:\n\nInput: triangle = [[-10]]\nOutput: -10\n\n&nbsp;\nConstraints:\n\n\t1 <= triangle.length <= 200\n\ttriangle[0].length == 1\n\ttriangle[i].length == triangle[i - 1].length + 1\n\t-104 <= triangle[i][j] <= 104\n\n&nbsp;\nFollow up: Could you&nbsp;do this using only O(n) extra space, where n is the total number of rows in the triangle?",
        "solutions": [
            {
                "id": 38730,
                "title": "dp-solution-for-triangle",
                "content": "This problem is quite well-formed in my opinion. The triangle has a tree-like structure, which would lead people to think about traversal algorithms such as DFS. However, if you look closely, you would notice that the adjacent nodes always share a 'branch'. In other word, there are **overlapping subproblems**. Also, suppose x and y are 'children' of k. Once minimum paths from x and y to the bottom are known, the minimum path starting from k can be decided in O(1), that is **optimal substructure**. Therefore, dynamic programming would be the best solution to this problem in terms of time complexity.\\n\\nWhat I like about this problem even more is that the difference between 'top-down' and 'bottom-up' DP can be 'literally' pictured in the input triangle. For 'top-down' DP, starting from the node on the very top, we recursively find the minimum path sum of each node. When a path sum is calculated, we store it in an array (memoization); the next time we need to calculate the path sum of the same node, just retrieve it from the array. However, you will need a cache that is at least the same size as the input triangle itself to store the pathsum, which takes O(N^2) space. With some clever thinking, it might be possible to release some of the memory that will never be used after a particular point, but the order of the nodes being processed is not straightforwardly seen in a recursive solution, so deciding which part of the cache to discard can be a hard job.\\n\\n'Bottom-up' DP, on the other hand, is very straightforward: we start from the nodes on the bottom row; the min pathsums for these nodes are the values of the nodes themselves. From there, the min pathsum at the ith node on the kth row would be the lesser of the pathsums of its two children plus the value of itself, i.e.:\\n\\n    minpath[k][i] = min( minpath[k+1][i], minpath[k+1][i+1]) + triangle[k][i];\\n\\nOr even better, since the row minpath[k+1] would be useless after minpath[k] is computed, we can simply set minpath as a 1D array, and iteratively update itself:\\n\\n    For the kth level:\\n    minpath[i] = min( minpath[i], minpath[i+1]) + triangle[k][i]; \\n\\nThus, we have the following solution\\n\\n    int minimumTotal(vector<vector<int> > &triangle) {\\n        int n = triangle.size();\\n        vector<int> minlen(triangle.back());\\n        for (int layer = n-2; layer >= 0; layer--) // For each layer\\n        {\\n            for (int i = 0; i <= layer; i++) // Check its every 'node'\\n            {\\n                // Find the lesser of its two children, and sum the current value in the triangle with it.\\n                minlen[i] = min(minlen[i], minlen[i+1]) + triangle[layer][i]; \\n            }\\n        }\\n        return minlen[0];\\n    }",
                "solutionTags": [],
                "code": "This problem is quite well-formed in my opinion. The triangle has a tree-like structure, which would lead people to think about traversal algorithms such as DFS. However, if you look closely, you would notice that the adjacent nodes always share a 'branch'. In other word, there are **overlapping subproblems**. Also, suppose x and y are 'children' of k. Once minimum paths from x and y to the bottom are known, the minimum path starting from k can be decided in O(1), that is **optimal substructure**. Therefore, dynamic programming would be the best solution to this problem in terms of time complexity.\\n\\nWhat I like about this problem even more is that the difference between 'top-down' and 'bottom-up' DP can be 'literally' pictured in the input triangle. For 'top-down' DP, starting from the node on the very top, we recursively find the minimum path sum of each node. When a path sum is calculated, we store it in an array (memoization); the next time we need to calculate the path sum of the same node, just retrieve it from the array. However, you will need a cache that is at least the same size as the input triangle itself to store the pathsum, which takes O(N^2) space. With some clever thinking, it might be possible to release some of the memory that will never be used after a particular point, but the order of the nodes being processed is not straightforwardly seen in a recursive solution, so deciding which part of the cache to discard can be a hard job.\\n\\n'Bottom-up' DP, on the other hand, is very straightforward: we start from the nodes on the bottom row; the min pathsums for these nodes are the values of the nodes themselves. From there, the min pathsum at the ith node on the kth row would be the lesser of the pathsums of its two children plus the value of itself, i.e.:\\n\\n    minpath[k][i] = min( minpath[k+1][i], minpath[k+1][i+1]) + triangle[k][i];\\n\\nOr even better, since the row minpath[k+1] would be useless after minpath[k] is computed, we can simply set minpath as a 1D array, and iteratively update itself:\\n\\n    For the kth level:\\n    minpath[i] = min( minpath[i], minpath[i+1]) + triangle[k][i]; \\n\\nThus, we have the following solution\\n\\n    int minimumTotal(vector<vector<int> > &triangle) {\\n        int n = triangle.size();\\n        vector<int> minlen(triangle.back());\\n        for (int layer = n-2; layer >= 0; layer--) // For each layer\\n        {\\n            for (int i = 0; i <= layer; i++) // Check its every 'node'\\n            {\\n                // Find the lesser of its two children, and sum the current value in the triangle with it.\\n                minlen[i] = min(minlen[i], minlen[i+1]) + triangle[layer][i]; \\n            }\\n        }\\n        return minlen[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38724,
                "title": "7-lines-neat-java-solution",
                "content": "    public int minimumTotal(List<List<Integer>> triangle) {\\n        int[] A = new int[triangle.size()+1];\\n        for(int i=triangle.size()-1;i>=0;i--){\\n            for(int j=0;j<triangle.get(i).size();j++){\\n                A[j] = Math.min(A[j],A[j+1])+triangle.get(i).get(j);\\n            }\\n        }\\n        return A[0];\\n    }",
                "solutionTags": [],
                "code": "    public int minimumTotal(List<List<Integer>> triangle) {\\n        int[] A = new int[triangle.size()+1];\\n        for(int i=triangle.size()-1;i>=0;i--){\\n            for(int j=0;j<triangle.get(i).size();j++){\\n                A[j] = Math.min(A[j],A[j+1])+triangle.get(i).get(j);\\n            }\\n        }\\n        return A[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2146264,
                "title": "c-python-simple-solution-w-explanation-recursion-dp",
                "content": "Given a triangle array, we need to return the path whose sum from top to bottom is minimum.\\nThere is one constraint: we can only move to lower-left or lower-right elements.\\nFor example, in the triangle depicted below, the only valid path from `5` are `5 -> 1` and `5 -> 8`. The paths `5 -> 4` or `5 -> 3` are invalid.\\n\\n```text\\n   2\\n  3 4\\n 6 5 7\\n4 1 8 3\\n```\\n\\nNow the question is, can we solve it greedily, i.e., simply check the immediate step and choose the smaller element?\\nThe answer is no. Because the current choice will affect the later decisions. This is illustrated in the following example:\\n\\n```text\\n   2\\n  4 5\\n 6 5 1\\n4 1 8 2\\n```\\n\\nThe greedy strategy will use the path `2 -> 4 -> 5 -> 1`. But, the optimal path is `2 -> 5 -> 1 -> 2`.\\nWe need to use `Dynamic Programming` to solve this problem. Solving a problem using DP is generally tricky. This post will help you understand how to develop a DP approach. So, I highly recommend reading all three methods.\\n\\n___\\n___\\n\\u274C **Solution I: Recursion [TLE]**\\n\\nWe can try all valid paths and calculate the sum. Out of all those, return the minimum sum. At each step, we have two choices:\\n\\n1. Move to lower-left element (`i + 1` and `j`)\\n2. Move to lower-right element (`i + 1` and `j + 1`)\\n\\n<iframe src=\"https://leetcode.com/playground/7GJqkRP3/shared\" frameBorder=\"0\" width=\"1080\" height=\"280\"></iframe>\\n\\nWhy have I named the inside function as `dfs`? Because if we trace our actions, we can observe that it forms a binary tree. **Don\\'t worry** if you are not familiar with this term. The following visualization will help you to understand what I mean.\\n\\n```text\\n                                                  \\u250F\\u2501\\u2501\\u2501\\u2513\\n                            \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 2 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E\\n                            \\u2502                     \\u2517\\u2501\\u2501\\u2501\\u251B                     \\u2502\\n                          \\u250F\\u2501\\u2537\\u2501\\u2513                                           \\u250F\\u2501\\u2537\\u2501\\u2513     \\n                \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 3 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                       \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 4 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                 \\n                \\u2502         \\u2517\\u2501\\u2501\\u2501\\u251B         \\u2502                       \\u2502         \\u2517\\u2501\\u2501\\u2501\\u251B         \\u2502 \\n              \\u250F\\u2501\\u2537\\u2501\\u2513                   \\u250F\\u2501\\u2537\\u2501\\u2513                   \\u250F\\u2501\\u2537\\u2501\\u2513                   \\u250F\\u2501\\u2537\\u2501\\u2513  \\n        \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 6 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E       \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 5 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E       \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 5 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E       \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 7 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E \\n        \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502       \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502       \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502       \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502 \\n      \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513   \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513   \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513   \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513 \\n      \\u2503 4 \\u2503           \\u2503 1 \\u2503   \\u2503 1 \\u2503           \\u2503 8 \\u2503   \\u2503 1 \\u2503           \\u2503 8 \\u2503   \\u2503 8 \\u2503           \\u2503 3 \\u2503\\n      \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B   \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B   \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B   \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B\\n```\\n\\nIn dfs, we traverse all the paths one by one. So, here our paths will be:\\n\\n1. 2 -> 3 -> 6 -> 4\\n2. 2 -> 3 -> 6 -> 1\\n3. 2 -> 3 -> 5 -> 1\\n.\\n.\\n.\\n\\n- **Time Complexity:** `O(2\\u207F)`\\n- **Space Complexity:** `O(n)`\\n\\n___\\n\\u2705 **Solution II: Top-Down DP or Memoization [Accepted]**\\n\\nWe are doing a lot of repetitive work in the above recursive solution. How?\\nHave a look at the above example. The subtree with head 5 is repeated twice. We need to compute the minimum sum path during the first time `(2 -> 3 -> 5 -> ...)`. During the second time from `2 -> 4 -> 5`, we can simply use the result from the first time instead of traversing again. This is the essence of memoization.\\n\\n```text\\n                                                  \\u250F\\u2501\\u2501\\u2501\\u2513\\n                            \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 2 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E\\n                            \\u2502                     \\u2517\\u2501\\u2501\\u2501\\u251B                     \\u2502\\n                          \\u250F\\u2501\\u2537\\u2501\\u2513                                           \\u250F\\u2501\\u2537\\u2501\\u2513     \\n                \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 3 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                       \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 4 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                 \\n                \\u2502         \\u2517\\u2501\\u2501\\u2501\\u251B         \\u2502                       \\u2502         \\u2517\\u2501\\u2501\\u2501\\u251B         \\u2502 \\n              \\u250F\\u2501\\u2537\\u2501\\u2513          .........\\u250F\\u2501\\u2537\\u2501\\u2513......... .........\\u250F\\u2501\\u2537\\u2501\\u2513 ........          \\u250F\\u2501\\u2537\\u2501\\u2513  \\n        \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 6 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E    .  \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 5 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E  . .  \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 5 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E  .    \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 7 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E \\n        \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502    .  \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502  . .  \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502  .    \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502 \\n      \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513  .\\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513. .\\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513.  \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513 \\n      \\u2503 4 \\u2503           \\u2503 1 \\u2503  .\\u2503 1 \\u2503           \\u2503 8 \\u2503. .\\u2503 1 \\u2503           \\u2503 8 \\u2503.  \\u2503 8 \\u2503           \\u2503 3 \\u2503\\n      \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B  .\\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B. .\\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B.  \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B\\n                             ....................... ....................... \\n```\\n\\nIn Python, it is as simple as adding the `@cache` decorator. But, this won\\'t be accepted in the interviews and have many limitations.\\n\\n```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        @cache\\n        def dfs(i, j):\\n            if i == len(triangle):\\n                return 0\\n\\n            lower_left = triangle[i][j] + dfs(i + 1, j)\\n            lower_right = triangle[i][j] + dfs(i + 1, j + 1)\\n\\n            return min(lower_left, lower_right)\\n\\n        return dfs(0, 0)\\n```\\n\\nWe can manually use a way to store the information and use it later. Here, two variables (`i` and `j`) are changing and can be used to store a state. So, we can use a matrix. The following code will make it clear.\\n\\n<iframe src=\"https://leetcode.com/playground/mbJEU5da/shared\" frameBorder=\"0\" width=\"1080\" height=\"360\"></iframe>\\n\\n- **Time Complexity:** `O(n\\xB2)`\\n- **Space Complexity:** `O(n\\xB2)`\\n\\n___\\n\\u2705 **Solution III (a): Bottom Up DP or Tabulation [Accepted]**\\n\\nRecursion is slower than the iterative approach. So, we can further optimize the above solution by using bottom-up DP.\\nWe can do a bottom-up traversal instead of traversing from top to bottom. Coming up with a bottom-up DP is challenging at first and requires practice. Instead of looking at the bigger problem, we look at smaller sub-problems and try to build up the solution. The following example will help you to understand:\\n\\n```text\\n1. Suppose that only the last level is given. \\n\\n4 1 8 3\\n\\nThen what should be your answer?\\n\\nIf you thought 1, then congratulations \\uD83C\\uDF89 you are correct. This is our first subproblem. \\n\\n2. Now, the last two levels are given.\\n\\n 6 5 7\\n4 1 8 3\\n\\nHere, what should be the answer and what information do you need to store?\\n\\nClearly, the answer is 6 (5 -> 1). But, this may not be the optimal path. So, we need to store all the optimal paths, i.e.,\\n[(6 -> 1), (5 -> 1), 7 -> 3)] or [7, 6, 10]. This is our second subproblem.\\n\\n3. Last 3 levels are given.\\n\\n  3 4\\n 6 5 7\\n4 1 8 3\\n\\nAgain, what should be the answer and what information do you need to store (or use)?\\n\\nAnswer is 9 (3 -> 5 -> 1). Do we need to look again at all the paths? Can we use the information that we previously stored?\\nNo and Yes.\\nIf we replace the triangle as\\n  3 4\\n 7 6 10\\nthen also, we\\'ll get the same answer. And we can store this information as [(3 -> 6), (4 -> 6)] or [9, 10].\\n\\n4. All levels are given\\n\\n   2\\n  3 4\\n 6 5 7\\n4 1 8 3\\n\\nWhich can be replaced as:\\n   2\\n  9 10\\n\\nAnd hence, our answer is 11 (2 -> 9)\\n\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/deK2NY3Q/shared\" frameBorder=\"0\" width=\"1080\" height=\"330\"></iframe>\\n\\n- **Time Complexity:** `O(n\\xB2)`\\n- **Space Complexity:** `O(n\\xB2)`\\n\\n___\\n\\u2705 **Solution III (b): Bottom Up DP or Tabulation (Space Optimized) [Accepted]**\\n\\nNotice that we only require the information about the next row. So, instead of creating a `2D` matrix, a `1D` array is sufficient.\\n\\n<iframe src=\"https://leetcode.com/playground/FJAZiaam/shared\" frameBorder=\"0\" width=\"1080\" height=\"350\"></iframe>\\n\\n- **Time Complexity:** `O(n\\xB2)`\\n- **Space Complexity:** `O(n)`\\n\\n___\\n___\\nIf you like the solution, please **upvote**! \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```text\\n   2\\n  3 4\\n 6 5 7\\n4 1 8 3\\n```\n```text\\n   2\\n  4 5\\n 6 5 1\\n4 1 8 2\\n```\n```text\\n                                                  \\u250F\\u2501\\u2501\\u2501\\u2513\\n                            \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 2 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E\\n                            \\u2502                     \\u2517\\u2501\\u2501\\u2501\\u251B                     \\u2502\\n                          \\u250F\\u2501\\u2537\\u2501\\u2513                                           \\u250F\\u2501\\u2537\\u2501\\u2513     \\n                \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 3 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                       \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 4 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                 \\n                \\u2502         \\u2517\\u2501\\u2501\\u2501\\u251B         \\u2502                       \\u2502         \\u2517\\u2501\\u2501\\u2501\\u251B         \\u2502 \\n              \\u250F\\u2501\\u2537\\u2501\\u2513                   \\u250F\\u2501\\u2537\\u2501\\u2513                   \\u250F\\u2501\\u2537\\u2501\\u2513                   \\u250F\\u2501\\u2537\\u2501\\u2513  \\n        \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 6 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E       \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 5 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E       \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 5 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E       \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 7 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E \\n        \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502       \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502       \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502       \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502 \\n      \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513   \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513   \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513   \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513 \\n      \\u2503 4 \\u2503           \\u2503 1 \\u2503   \\u2503 1 \\u2503           \\u2503 8 \\u2503   \\u2503 1 \\u2503           \\u2503 8 \\u2503   \\u2503 8 \\u2503           \\u2503 3 \\u2503\\n      \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B   \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B   \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B   \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B\\n```\n```text\\n                                                  \\u250F\\u2501\\u2501\\u2501\\u2513\\n                            \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 2 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E\\n                            \\u2502                     \\u2517\\u2501\\u2501\\u2501\\u251B                     \\u2502\\n                          \\u250F\\u2501\\u2537\\u2501\\u2513                                           \\u250F\\u2501\\u2537\\u2501\\u2513     \\n                \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 3 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                       \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 4 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E                 \\n                \\u2502         \\u2517\\u2501\\u2501\\u2501\\u251B         \\u2502                       \\u2502         \\u2517\\u2501\\u2501\\u2501\\u251B         \\u2502 \\n              \\u250F\\u2501\\u2537\\u2501\\u2513          .........\\u250F\\u2501\\u2537\\u2501\\u2513......... .........\\u250F\\u2501\\u2537\\u2501\\u2513 ........          \\u250F\\u2501\\u2537\\u2501\\u2513  \\n        \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 6 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E    .  \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 5 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E  . .  \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 5 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E  .    \\u256D\\u2500\\u2500\\u2500\\u2500\\u2500\\u2528 7 \\u2520\\u2500\\u2500\\u2500\\u2500\\u2500\\u256E \\n        \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502    .  \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502  . .  \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502  .    \\u2502     \\u2517\\u2501\\u2501\\u2501\\u251B     \\u2502 \\n      \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513  .\\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513. .\\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513.  \\u250F\\u2501\\u2537\\u2501\\u2513           \\u250F\\u2501\\u2537\\u2501\\u2513 \\n      \\u2503 4 \\u2503           \\u2503 1 \\u2503  .\\u2503 1 \\u2503           \\u2503 8 \\u2503. .\\u2503 1 \\u2503           \\u2503 8 \\u2503.  \\u2503 8 \\u2503           \\u2503 3 \\u2503\\n      \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B  .\\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B. .\\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B.  \\u2517\\u2501\\u2501\\u2501\\u251B           \\u2517\\u2501\\u2501\\u2501\\u251B\\n                             ....................... ....................... \\n```\n```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        @cache\\n        def dfs(i, j):\\n            if i == len(triangle):\\n                return 0\\n\\n            lower_left = triangle[i][j] + dfs(i + 1, j)\\n            lower_right = triangle[i][j] + dfs(i + 1, j + 1)\\n\\n            return min(lower_left, lower_right)\\n\\n        return dfs(0, 0)\\n```\n```text\\n1. Suppose that only the last level is given. \\n\\n4 1 8 3\\n\\nThen what should be your answer?\\n\\nIf you thought 1, then congratulations \\uD83C\\uDF89 you are correct. This is our first subproblem. \\n\\n2. Now, the last two levels are given.\\n\\n 6 5 7\\n4 1 8 3\\n\\nHere, what should be the answer and what information do you need to store?\\n\\nClearly, the answer is 6 (5 -> 1). But, this may not be the optimal path. So, we need to store all the optimal paths, i.e.,\\n[(6 -> 1), (5 -> 1), 7 -> 3)] or [7, 6, 10]. This is our second subproblem.\\n\\n3. Last 3 levels are given.\\n\\n  3 4\\n 6 5 7\\n4 1 8 3\\n\\nAgain, what should be the answer and what information do you need to store (or use)?\\n\\nAnswer is 9 (3 -> 5 -> 1). Do we need to look again at all the paths? Can we use the information that we previously stored?\\nNo and Yes.\\nIf we replace the triangle as\\n  3 4\\n 7 6 10\\nthen also, we\\'ll get the same answer. And we can store this information as [(3 -> 6), (4 -> 6)] or [9, 10].\\n\\n4. All levels are given\\n\\n   2\\n  3 4\\n 6 5 7\\n4 1 8 3\\n\\nWhich can be replaced as:\\n   2\\n  9 10\\n\\nAnd hence, our answer is 11 (2 -> 9)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38735,
                "title": "python-easy-to-understand-solutions-top-down-bottom-up",
                "content": "        \\n    # O(n*n/2) space, top-down \\n    def minimumTotal1(self, triangle):\\n        if not triangle:\\n            return \\n        res = [[0 for i in xrange(len(row))] for row in triangle]\\n        res[0][0] = triangle[0][0]\\n        for i in xrange(1, len(triangle)):\\n            for j in xrange(len(triangle[i])):\\n                if j == 0:\\n                    res[i][j] = res[i-1][j] + triangle[i][j]\\n                elif j == len(triangle[i])-1:\\n                    res[i][j] = res[i-1][j-1] + triangle[i][j]\\n                else:\\n                    res[i][j] = min(res[i-1][j-1], res[i-1][j]) + triangle[i][j]\\n        return min(res[-1])\\n        \\n    # Modify the original triangle, top-down\\n    def minimumTotal2(self, triangle):\\n        if not triangle:\\n            return \\n        for i in xrange(1, len(triangle)):\\n            for j in xrange(len(triangle[i])):\\n                if j == 0:\\n                    triangle[i][j] += triangle[i-1][j]\\n                elif j == len(triangle[i])-1:\\n                    triangle[i][j] += triangle[i-1][j-1]\\n                else:\\n                    triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j])\\n        return min(triangle[-1])\\n        \\n    # Modify the original triangle, bottom-up\\n    def minimumTotal3(self, triangle):\\n        if not triangle:\\n            return \\n        for i in xrange(len(triangle)-2, -1, -1):\\n            for j in xrange(len(triangle[i])):\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\\n        return triangle[0][0]\\n    \\n    # bottom-up, O(n) space\\n    def minimumTotal(self, triangle):\\n        if not triangle:\\n            return \\n        res = triangle[-1]\\n        for i in xrange(len(triangle)-2, -1, -1):\\n            for j in xrange(len(triangle[i])):\\n                res[j] = min(res[j], res[j+1]) + triangle[i][j]\\n        return res[0]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # O(n*n/2) space, top-down \\n    def minimumTotal1(self, triangle):\\n        if not triangle:\\n            return \\n        res = [[0 for i in xrange(len(row))] for row in triangle]\\n        res[0][0] = triangle[0][0]\\n        for i in xrange(1, len(triangle)):\\n            for j in xrange(len(triangle[i])):\\n                if j == 0:\\n                    res[i][j] = res[i-1][j] + triangle[i][j]\\n                elif j == len(triangle[i])-1:\\n                    res[i][j] = res[i-1][j-1] + triangle[i][j]\\n                else:\\n                    res[i][j] = min(res[i-1][j-1], res[i-1][j]) + triangle[i][j]\\n        return min(res[-1])\\n        \\n    # Modify the original triangle, top-down\\n    def minimumTotal2(self, triangle):\\n        if not triangle:\\n            return \\n        for i in xrange(1, len(triangle)):\\n            for j in xrange(len(triangle[i])):\\n                if j == 0:\\n                    triangle[i][j] += triangle[i-1][j]\\n                elif j == len(triangle[i])-1:\\n                    triangle[i][j] += triangle[i-1][j-1]\\n                else:\\n                    triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j])\\n        return min(triangle[-1])\\n        \\n    # Modify the original triangle, bottom-up\\n    def minimumTotal3(self, triangle):\\n        if not triangle:\\n            return \\n        for i in xrange(len(triangle)-2, -1, -1):\\n            for j in xrange(len(triangle[i])):\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\\n        return triangle[0][0]\\n    \\n    # bottom-up, O(n) space\\n    def minimumTotal(self, triangle):\\n        if not triangle:\\n            return \\n        res = triangle[-1]\\n        for i in xrange(len(triangle)-2, -1, -1):\\n            for j in xrange(len(triangle[i])):\\n                res[j] = min(res[j], res[j+1]) + triangle[i][j]\\n        return res[0]",
                "codeTag": "Python3"
            },
            {
                "id": 38732,
                "title": "my-8-line-dp-java-code-4-meaningful-lines-with-o-1-space",
                "content": "    public class Solution {\\n        public int minimumTotal(List<List<Integer>> triangle) {\\n            for(int i = triangle.size() - 2; i >= 0; i--)\\n                for(int j = 0; j <= i; j++)\\n                    triangle.get(i).set(j, triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1)));\\n            return triangle.get(0).get(0);\\n        }\\n    }\\n\\nThe idea is simple. \\n\\n1) Go from bottom to top.\\n\\n2) We start form the row above the bottom row [size()-2].\\n\\n3) Each number add the smaller number of two numbers that below it. \\n\\n4) And finally we get to the top we the smallest sum.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minimumTotal(List<List<Integer>> triangle) {\\n            for(int i = triangle.size() - 2; i >= 0; i--)\\n                for(int j = 0; j <= i; j++)\\n                    triangle.get(i).set(j, triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1)));\\n            return triangle.get(0).get(0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2145266,
                "title": "c-4-approaches-recursion-memoization-tabulation-space-optimal",
                "content": "**1. Recursion\\nCODE:**\\n\\n\\t // Recursion *** Will Give TLE ***\\n\\t\\tint solve(int i, int j, int n, vector<vector<int>>&triangle) {\\n\\t\\t\\tif(i == n - 1)\\n\\t\\t\\t\\treturn triangle[i][j];\\n\\t\\t\\tint bottom = triangle[i][j] + solve(i+1, j, n, triangle);\\n\\t\\t\\tint  bottom_right = triangle[i][j] + solve(i+1, j+1, n, triangle);\\n\\t\\t\\treturn min(bottom, bottom_right);\\n\\t\\t}\\n\\t\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\t\\tint n = triangle.size();\\n\\t\\t\\treturn solve(0, 0, n, triangle);\\n\\t\\t}\\n\\t\\t\\n**2. Memoization\\nCODE:**\\n\\n\\t // Memoization\\n\\t\\tint solve(int i, int j, int n, vector<vector<int>>&triangle, vector<vector<int>>&dp) {\\n\\t\\t\\tif(i == n - 1)\\n\\t\\t\\t\\treturn triangle[i][j];\\n\\t\\t\\tif(dp[i][j] != -1)\\n\\t\\t\\t\\treturn dp[i][j];\\n\\t\\t\\tint bottom = triangle[i][j] + solve(i+1, j, n, triangle, dp);\\n\\t\\t\\tint  bottom_right = triangle[i][j] + solve(i+1, j+1, n, triangle, dp);\\n\\t\\t\\treturn dp[i][j] = min(bottom, bottom_right);\\n\\t\\t}\\n\\t\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\t\\tint n = triangle.size();\\n\\t\\t\\tvector<vector<int>>dp(n, vector<int>(n, -1));\\n\\t\\t\\treturn solve(0, 0, n, triangle, dp);\\n\\t\\t}\\n\\t\\t\\n**3. Tabulation\\nCODE:**\\n\\n\\t // Tabulation\\n\\t\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\t\\tint n = triangle.size();\\n\\t\\t\\tvector<vector<int>>dp(n, vector<int>(n, -1));\\n\\t\\t\\tfor(int i = 0; i < n; i++) \\n\\t\\t\\t\\tdp[n-1][i] = triangle[n-1][i];\\n\\t\\t\\tfor(int i = n-2; i >= 0; i--) {\\n\\t\\t\\t\\tfor(int j = i; j >= 0; j--) {\\n\\t\\t\\t\\t\\tint up = triangle[i][j] + dp[i+1][j];\\n\\t\\t\\t\\t\\tint up_left = triangle[i][j] + dp[i+1][j+1];\\n\\t\\t\\t\\t\\tdp[i][j] = min(up, up_left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][0];\\n\\t\\t}\\n\\t\\t\\n**4. Space Optimal\\nCODE:**\\n\\n\\t// Space Optimization\\n\\t\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\t\\tint n = triangle.size();\\n\\t\\t\\tvector<int>next(n);\\n\\t\\t\\tfor(int i = n-1; i >= 0; i--) {\\n\\t\\t\\t\\tvector<int>curr(n);\\n\\t\\t\\t\\tfor(int j = i; j >= 0; j--) {\\n\\t\\t\\t\\t\\tif(i == n-1)\\n\\t\\t\\t\\t\\t\\tcurr[j] = triangle[i][j];\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tint up = triangle[i][j] + next[j];\\n\\t\\t\\t\\t\\t\\tint up_left = triangle[i][j] + next[j+1];\\n\\t\\t\\t\\t\\t\\tcurr[j] = min(up, up_left);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnext = curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn next[0];\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "**1. Recursion\\nCODE:**\\n\\n\\t // Recursion *** Will Give TLE ***\\n\\t\\tint solve(int i, int j, int n, vector<vector<int>>&triangle) {\\n\\t\\t\\tif(i == n - 1)\\n\\t\\t\\t\\treturn triangle[i][j];\\n\\t\\t\\tint bottom = triangle[i][j] + solve(i+1, j, n, triangle);\\n\\t\\t\\tint  bottom_right = triangle[i][j] + solve(i+1, j+1, n, triangle);\\n\\t\\t\\treturn min(bottom, bottom_right);\\n\\t\\t}\\n\\t\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\t\\tint n = triangle.size();\\n\\t\\t\\treturn solve(0, 0, n, triangle);\\n\\t\\t}\\n\\t\\t\\n**2. Memoization\\nCODE:**\\n\\n\\t // Memoization\\n\\t\\tint solve(int i, int j, int n, vector<vector<int>>&triangle, vector<vector<int>>&dp) {\\n\\t\\t\\tif(i == n - 1)\\n\\t\\t\\t\\treturn triangle[i][j];\\n\\t\\t\\tif(dp[i][j] != -1)\\n\\t\\t\\t\\treturn dp[i][j];\\n\\t\\t\\tint bottom = triangle[i][j] + solve(i+1, j, n, triangle, dp);\\n\\t\\t\\tint  bottom_right = triangle[i][j] + solve(i+1, j+1, n, triangle, dp);\\n\\t\\t\\treturn dp[i][j] = min(bottom, bottom_right);\\n\\t\\t}\\n\\t\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\t\\tint n = triangle.size();\\n\\t\\t\\tvector<vector<int>>dp(n, vector<int>(n, -1));\\n\\t\\t\\treturn solve(0, 0, n, triangle, dp);\\n\\t\\t}\\n\\t\\t\\n**3. Tabulation\\nCODE:**\\n\\n\\t // Tabulation\\n\\t\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\t\\tint n = triangle.size();\\n\\t\\t\\tvector<vector<int>>dp(n, vector<int>(n, -1));\\n\\t\\t\\tfor(int i = 0; i < n; i++) \\n\\t\\t\\t\\tdp[n-1][i] = triangle[n-1][i];\\n\\t\\t\\tfor(int i = n-2; i >= 0; i--) {\\n\\t\\t\\t\\tfor(int j = i; j >= 0; j--) {\\n\\t\\t\\t\\t\\tint up = triangle[i][j] + dp[i+1][j];\\n\\t\\t\\t\\t\\tint up_left = triangle[i][j] + dp[i+1][j+1];\\n\\t\\t\\t\\t\\tdp[i][j] = min(up, up_left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][0];\\n\\t\\t}\\n\\t\\t\\n**4. Space Optimal\\nCODE:**\\n\\n\\t// Space Optimization\\n\\t\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\t\\tint n = triangle.size();\\n\\t\\t\\tvector<int>next(n);\\n\\t\\t\\tfor(int i = n-1; i >= 0; i--) {\\n\\t\\t\\t\\tvector<int>curr(n);\\n\\t\\t\\t\\tfor(int j = i; j >= 0; j--) {\\n\\t\\t\\t\\t\\tif(i == n-1)\\n\\t\\t\\t\\t\\t\\tcurr[j] = triangle[i][j];\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tint up = triangle[i][j] + next[j];\\n\\t\\t\\t\\t\\t\\tint up_left = triangle[i][j] + next[j+1];\\n\\t\\t\\t\\t\\t\\tcurr[j] = min(up, up_left);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnext = curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn next[0];\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 342223,
                "title": "clean-javascript-4-lines-beats-98",
                "content": "Clean Javascript, 4 lines, beats 98%.\\n\\nStart at the second to last row, then add the smallest element under the current element. Continue till you reach the top.\\n\\n```javascript\\n/**\\n * @param {number[][]} triangle\\n * @return {number}\\n */\\nvar minimumTotal = function(triangle) {\\n    for (let i = triangle.length-2; i >= 0; i--)\\n        for (let j = 0; j < triangle[i].length; j++)\\n            triangle[i][j] += Math.min(triangle[i+1][j], triangle[i+1][j+1])\\n    return triangle[0][0]\\n}\\n```\\n\\nFor example, for a small triangle this is what the algorithm will do:\\n\\n**Starting Triangle**\\n```\\n  1\\n 2 3    <-- Algorithm starts here, at the second to last row\\n4 5 6\\n```\\n\\n**Step 1**\\n```\\n  1\\n 6 8    <-- 2 + min(4, 5) and 3 + min(5, 6)\\n4 5 6\\n```\\n\\n**Step 2**\\n```\\n  7    <-- 1 + min(6, 8)\\n 6 8\\n4 5 6\\n```\\n\\n**Step 3**\\nFinally, return `triangle[0][0]` and you have the answer. It\\'s quite elegant, beautiful in a way. Each layer passes on knowledge from the previous layer, until you reach the top. It is the most efficient solution because it\\'s done in O(1) memory and O(elements) time. Every element is processed exactly once.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} triangle\\n * @return {number}\\n */\\nvar minimumTotal = function(triangle) {\\n    for (let i = triangle.length-2; i >= 0; i--)\\n        for (let j = 0; j < triangle[i].length; j++)\\n            triangle[i][j] += Math.min(triangle[i+1][j], triangle[i+1][j+1])\\n    return triangle[0][0]\\n}\\n```\n```\\n  1\\n 2 3    <-- Algorithm starts here, at the second to last row\\n4 5 6\\n```\n```\\n  1\\n 6 8    <-- 2 + min(4, 5) and 3 + min(5, 6)\\n4 5 6\\n```\n```\\n  7    <-- 1 + min(6, 8)\\n 6 8\\n4 5 6\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38737,
                "title": "bottom-up-5-line-c-solution",
                "content": "    class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int> > &triangle) \\n        {\\n            vector<int> mini = triangle[triangle.size()-1];\\n            for ( int i = triangle.size() - 2; i>= 0 ; --i )\\n                for ( int j = 0; j < triangle[i].size() ; ++ j )\\n                    mini[j] = triangle[i][j] + min(mini[j],mini[j+1]);\\n            return mini[0];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int> > &triangle) \\n        {\\n            vector<int> mini = triangle[triangle.size()-1];\\n            for ( int i = triangle.size() - 2; i>= 0 ; --i )\\n                for ( int j = 0; j < triangle[i].size() ; ++ j )\\n                    mini[j] = triangle[i][j] + min(mini[j],mini[j+1]);\\n            return mini[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1169431,
                "title": "short-simple-solutions-w-explanation-4-lines-of-code-w-comments",
                "content": "We are given a triangle. We start at the top of the triangle and want to move to the bottom with minimum possible sum. We can either move down to the same index *`i`* or to the index *`i + 1`*.\\n\\n----\\n\\n\\u2714\\uFE0F ***Solution - I (In-Place Bottom-Up Dynamic Programming)***\\n\\nWe can easily see that directly just choosing the minimum value in the next row(amongst `triangle[nextRow][i]` and  `triangle[nextRow][i+1]`) won\\'t fetch us the optimal final result since it maybe the case that the latter values of previous chosen path turn out to be huge. \\n\\nWe need to observe that to get the minimum possible sum, **we must use a path that has Optimal Value for each intermediate stop in the path**. Thus, we can use **Dynamic Programming** to find the optimal value to reach each position of the triangle level by level. We can do this by accumulating the sum of path(or more specifically sum of values of optimal stops in a path) for each cell of a level from top to the bottom of triangle.\\n\\n We are given that, at each cell in the triangle, we can move to the next row using two choices - \\n \\n 1. Move to the same index `i`.\\n 2. Move to the next index `i + 1`\\n\\nSince we are following **a bottom-up approach, the above can also be interpreted as** :- \\n\\nFor cell in the triangle, we could have reached here either from the previous row/level either from -\\n\\n1. the same index `i`, or\\n2. the index `i - 1`\\n\\nSo, obviously the optimal choice to arrive at the current position in triangle would be to come from the cell having minimum value of these two choices. \\n\\nWe will keep adding the result from the lower level to the next/higher level by each time choosing the optimal cell to arrive at the current cell. Finally, we can return the minimum value that we get at the bottom-most row of the triangle. Here, no auxillary space is used and I have modified the *`triangle`* itself to achieve a space complexity of `O(1)`.\\n\\n**C++**\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\t// start from level 1 till the bottom-most level. Each time determine the best path to arrive at current cell\\n\\tfor(int level = 1; level < size(triangle); level++) \\n\\t\\tfor(int i = 0; i <= level; i++)  // triangle[level].size() == level + 1 (level starts from 0)\\n\\t\\t\\t// for the current level: \\n\\t\\t\\ttriangle[level][i] += min(triangle[level - 1][min(i, (int)size(triangle[level - 1]) - 1)], // we can either come from previous level and same index\\n\\t\\t\\t                          triangle[level - 1][max(i - 1, 0)]); // or the previous level and index-1\\n\\t// finally return the last element of the bottom level\\n\\treturn *min_element(begin(triangle.back()), end(triangle.back())); \\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    for level in range(1, len(triangle)):\\n        for i in range(level+1):\\n            triangle[level][i] += min(triangle[level-1][min(i, level-1)], triangle[level-1][max(i-1,0)])\\n    return min(triangle[-1])\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**, where `N` are the total number of levels in *`triangle`*.\\n***Space Complexity :*** **`O(1)`**\\n\\nThe `min` and `max` in the above code are used to do bound-checks.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (In-Place Top-Down Dynamic Programming)***\\n\\n\\nWe chose to go from **top-level to the bottom-level of triangle in the previous approach**. We can also choose to start from the bottom of triangle and move all the way to the top. We will again follow the same DP strategy as used in the above solution.\\n\\nAt each cell of the triangle, we could have moved here from the below level in 2 ways, either from -\\n\\n1. the same index `i` in below row, or\\n2. the index `i+1`.\\n\\nAnd again, we will choose the minimum of these two to arrive at the optimal solution. Finally at last, we will reach at `triangle[0][0]`, which will hold the optimal (minimum) sum of path.\\n\\nActually, this approach will make the code a lot more clean and concise by avoiding the need of bound checks.\\n\\n**C++**\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tfor(int level = size(triangle) - 2; level >= 0; level--) // start from bottom-1 level\\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\t // for every cell: we could have moved here from same index or index+1 of next level\\n\\t\\t\\ttriangle[level][i] += min(triangle[level + 1][i], triangle[level + 1][i + 1]);\\n\\treturn triangle[0][0]; // lastly t[0][0] will contain accumulated sum of minimum path\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    for level in range(len(triangle)-2,-1,-1):\\n        for i in range(level+1):\\n            triangle[level][i] += min(triangle[level+1][i], triangle[level+1][i+1])\\n    return triangle[0][0]\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n---\\n\\n***Solution - III (Bottom-Up Dynamic Programming w/ Auxillary Space)***\\n\\nMore often than not, you would not be allowed to modify the given input. In such a situation, we can obviously opt for making a copy of the given input(*`triangle`* in this case). This would lead to a space complexity of **`O(N^2)`**. I won\\'t show this solution since the only change needed in above solutions would be adding the line `vector<vector<int>>dp(triangle);` and replacing `triangle` with `dp` (Or better yet just pass triangle by value instead of reference & keep using that itself \\uD83E\\uDD37\\u200D\\u2642\\uFE0F).\\n\\nHere, I will present a **solution with linear space complexity without input modification**. We can observe in the above solutions that we really ever **access only two rows of the input at the same time**. So, we can just maintain two rows and alternate between those two in our loop.\\n\\nI have used `level & 1` in the below solution to alternate between these two rows of *`dp`*. It\\'s very common way to go when we are converting from 2d DP to linear space. If you are not comfortable with it, you can also choose to maintain two separate rows and swap them at end of each iteration.\\n\\nAll the other things and idea remains the same as in the *`solution - I`*\\n\\n**C++**\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tint n = size(triangle), level = 1;\\n\\tvector<vector<int> > dp(2, vector<int>(n, INT_MAX));\\n\\tdp[0][0]=triangle[0][0];  // assign top-most row to dp[0] as we will be starting from level 1\\n\\tfor(; level < n; level++) \\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\tdp[level & 1][i] = triangle[level][i] + min(dp[(level - 1) & 1][min(i, n - 1)], dp[(level - 1) & 1][max(i - 1, 0)]); \\n\\tlevel--; // level becomes n after for loop ends. We need minimum value from level - 1\\n\\treturn *min_element(begin(dp[level & 1]), end(dp[level & 1])); \\n}\\n```\\n\\n---\\n\\n**Python**\\n\\nThe below solution is using the two separate rows method that I described above  and swapping after each iteration to alternate between them -\\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\tn = len(triangle)\\n\\tcur_row, prev_row = [0]*n, [0]*n\\n\\tprev_row[0] = triangle[0][0]  \\n\\tfor level in range(1, n):\\n\\t\\tfor i in range(level+1):\\n\\t\\t\\tcur_row[i] = triangle[level][i] + min(prev_row[min(i, level-1)], prev_row[max(i-1,0)])\\n\\t\\tcur_row, prev_row = prev_row, cur_row\\n\\treturn min(prev_row)\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n***Solution - IV (Top-Down Dynamic Programming w/ Auxillary Space)***\\n\\nHere is the Top-Down version of *`Solution - II`*, without input array modification and using linear auxillary space.\\n\\n**C++**\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tint n = size(triangle), level = n - 1;\\n\\tvector<vector<int> > dp(2, vector<int>(n, 0));\\n\\tdp[level-- & 1] = triangle[n - 1];\\n\\tfor(; level >= 0; level--)\\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\tdp[level & 1][i] = triangle[level][i] + min(dp[(level + 1) & 1][i], dp[(level + 1) & 1][i + 1]);\\n\\treturn dp[0][0];\\n}\\n```\\n\\n---\\n\\n**Python**\\n\\nAgain, I have used to two separate rows method here -\\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    n = len(triangle)\\n    cur_row, next_row = [0]*n, triangle[n-1]        \\n    for level in range(n-2,-1,-1):\\n        for i in range(level+1):\\n            cur_row[i] = triangle[level][i] + min(next_row[i], next_row[i+1])\\n        cur_row, next_row = next_row, cur_row\\n    return next_row[0]\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/0f015916-9fb1-4b39-9048-497255edac1a_1619015402.2332594.png /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\t// start from level 1 till the bottom-most level. Each time determine the best path to arrive at current cell\\n\\tfor(int level = 1; level < size(triangle); level++) \\n\\t\\tfor(int i = 0; i <= level; i++)  // triangle[level].size() == level + 1 (level starts from 0)\\n\\t\\t\\t// for the current level: \\n\\t\\t\\ttriangle[level][i] += min(triangle[level - 1][min(i, (int)size(triangle[level - 1]) - 1)], // we can either come from previous level and same index\\n\\t\\t\\t                          triangle[level - 1][max(i - 1, 0)]); // or the previous level and index-1\\n\\t// finally return the last element of the bottom level\\n\\treturn *min_element(begin(triangle.back()), end(triangle.back())); \\n}\\n```\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    for level in range(1, len(triangle)):\\n        for i in range(level+1):\\n            triangle[level][i] += min(triangle[level-1][min(i, level-1)], triangle[level-1][max(i-1,0)])\\n    return min(triangle[-1])\\n```\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tfor(int level = size(triangle) - 2; level >= 0; level--) // start from bottom-1 level\\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\t // for every cell: we could have moved here from same index or index+1 of next level\\n\\t\\t\\ttriangle[level][i] += min(triangle[level + 1][i], triangle[level + 1][i + 1]);\\n\\treturn triangle[0][0]; // lastly t[0][0] will contain accumulated sum of minimum path\\n}\\n```\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    for level in range(len(triangle)-2,-1,-1):\\n        for i in range(level+1):\\n            triangle[level][i] += min(triangle[level+1][i], triangle[level+1][i+1])\\n    return triangle[0][0]\\n```\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tint n = size(triangle), level = 1;\\n\\tvector<vector<int> > dp(2, vector<int>(n, INT_MAX));\\n\\tdp[0][0]=triangle[0][0];  // assign top-most row to dp[0] as we will be starting from level 1\\n\\tfor(; level < n; level++) \\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\tdp[level & 1][i] = triangle[level][i] + min(dp[(level - 1) & 1][min(i, n - 1)], dp[(level - 1) & 1][max(i - 1, 0)]); \\n\\tlevel--; // level becomes n after for loop ends. We need minimum value from level - 1\\n\\treturn *min_element(begin(dp[level & 1]), end(dp[level & 1])); \\n}\\n```\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\tn = len(triangle)\\n\\tcur_row, prev_row = [0]*n, [0]*n\\n\\tprev_row[0] = triangle[0][0]  \\n\\tfor level in range(1, n):\\n\\t\\tfor i in range(level+1):\\n\\t\\t\\tcur_row[i] = triangle[level][i] + min(prev_row[min(i, level-1)], prev_row[max(i-1,0)])\\n\\t\\tcur_row, prev_row = prev_row, cur_row\\n\\treturn min(prev_row)\\n```\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tint n = size(triangle), level = n - 1;\\n\\tvector<vector<int> > dp(2, vector<int>(n, 0));\\n\\tdp[level-- & 1] = triangle[n - 1];\\n\\tfor(; level >= 0; level--)\\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\tdp[level & 1][i] = triangle[level][i] + min(dp[(level + 1) & 1][i], dp[(level + 1) & 1][i + 1]);\\n\\treturn dp[0][0];\\n}\\n```\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    n = len(triangle)\\n    cur_row, next_row = [0]*n, triangle[n-1]        \\n    for level in range(n-2,-1,-1):\\n        for i in range(level+1):\\n            cur_row[i] = triangle[level][i] + min(next_row[i], next_row[i+1])\\n        cur_row, next_row = next_row, cur_row\\n    return next_row[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2144980,
                "title": "from-memoization-to-dp-java-explanation",
                "content": "### Introduction\\nI personally find it much easier to think of a top-down memoization approach first before tackling a DP solution. As such, I\\'ll try my best to demonstrate how one might make the transition from top-down to bottom-up. Before that, let\\'s make sure we\\'re on the same page regarding the top-down approach.\\n\\nJust to make it clear why the left and right cells are chosen using `i` and `i+1`, I\\'ve illustrated the logic below:\\n![image](https://assets.leetcode.com/users/images/6fbb6fbb-3f8a-4ba0-9f99-b78247b66791_1655082032.7091029.png)\\n\\n___\\n### Top-Down Memoization Approach:\\nThe easiest way to implement this is through recursion. It\\'s quite simply DFS; from the current cell, find the minimum path between the left cell and the right cell. \\nWe simply start from the root cell (i.e. the top of the triangle) and work our way down. The results of each individual cell will bubble all the way up to our root and we can simply return that answer. I\\'ve written the code for this approach below. The fundamental logic for the recursive call is this:\\n```java\\nint path = triangle.get(level).get(index); // get the current value\\nif (level < triangle.size() - 1) \\n\\tpath += Math.min(dfs(level + 1, index, triangle), dfs(level + 1, index + 1, triangle)); // add that to the minimum path\\n```\\n <ins>This will be the key to converting from top-down to bottom-up</ins>.\\n \\nTo address the memoization aspect of this approach: \\nSince we\\'re doing a lot of repetitive work, we would like to cache our results at each cell in a memo table to avoid recomputing the shortest path for a particular cell. This is possible since the shortest path from any cell in the triangle is *always* going to be the same.\\n\\n___\\n### Bottom-Up DP Approach:\\nIt can sometimes be tricky knowing how to convert to a DP solution. However, I\\'ll try to make it as clear as possible. We can essentially boil down the conversion to the following steps:\\n1. Identify where our top-down approach starts and ends. Then, flip them around in our DP approach.\\n\\t* In this question, we start at the top level of the triangle and end at the bottom level. We\\'ll do it the other way around for DP.\\n\\n2. Convert from recursive calls to a for-loop. \\n\\t* In this question, each call represents a different level and at each level we look at different indices (cells) on that same level.\\n\\t* This is basically just two for loops: one looping through each level, and another looping through each cell of that level.\\n\\n3. Observe how the top-down approach collects information from the *next* recursive call.\\n\\t* In this question, as aforementioned, we get the <ins>current cell value + the minimum path between the left and right cells on the next level</ins>.\\n\\t* This is identical to how we do it in DP: `dp[level][i] = triangle.get(level).get(i) + Math.min(dp[level+1][i], dp[level+1][i+1]);`\\n\\nThe most important step here is step 3. Another way to think about it is transfering what\\'s stored in the memo table into the dp table. If it doesn\\'t quite make sense yet, have a look at the two approaches in code below and note down as many similarities as you can. Hope this helps! \\n\\n![image](https://assets.leetcode.com/users/images/3e826562-baec-4b76-8757-0d9b31fdbead_1655084237.4187193.png)\\n\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thanks for reading!\\n\\n**Top-Down Memoization:**\\n> Time complexity: `O(n^2)`\\n> Space complexity: `O(n^2)` \\n```java\\nprivate Integer[][] memo;\\n\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n\\tint n = triangle.size();\\n\\tmemo = new Integer[n][n];\\n\\treturn dfs(0, 0, triangle);\\n}\\n\\nprivate int dfs(int level, int i, List<List<Integer>> triangle) {\\n\\tif (memo[level][i] != null) return memo[level][i];\\n\\n\\tint path = triangle.get(level).get(i);\\n\\tif (level < triangle.size() - 1) \\n\\t\\tpath += Math.min(dfs(level + 1, i, triangle), dfs(level + 1, i + 1, triangle));\\n\\n\\treturn memo[level][i] = path;\\n}\\n```\\n\\n**Bottom-Up DP:**\\n> Time Complexity: `O(n^2)`\\n> Space Complexity: `O(n^2)`\\n```java\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n\\tint n = triangle.size();\\n\\tint[][] dp = new int[n+1][n+1];\\n\\n\\tfor (int level=n-1; level>=0; level--)\\n\\t\\tfor (int i=0; i<=level; i++)\\n\\t\\t\\tdp[level][i] = triangle.get(level).get(i) + Math.min(dp[level+1][i], dp[level+1][i+1]);\\n\\n\\treturn dp[0][0];\\n}\\n```\\n(We can make our DP solution `O(n)` space by only storing the level immediately above the current one since we don\\'t need to store the whole thing).",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```java\\nint path = triangle.get(level).get(index); // get the current value\\nif (level < triangle.size() - 1) \\n\\tpath += Math.min(dfs(level + 1, index, triangle), dfs(level + 1, index + 1, triangle)); // add that to the minimum path\\n```\n```java\\nprivate Integer[][] memo;\\n\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n\\tint n = triangle.size();\\n\\tmemo = new Integer[n][n];\\n\\treturn dfs(0, 0, triangle);\\n}\\n\\nprivate int dfs(int level, int i, List<List<Integer>> triangle) {\\n\\tif (memo[level][i] != null) return memo[level][i];\\n\\n\\tint path = triangle.get(level).get(i);\\n\\tif (level < triangle.size() - 1) \\n\\t\\tpath += Math.min(dfs(level + 1, i, triangle), dfs(level + 1, i + 1, triangle));\\n\\n\\treturn memo[level][i] = path;\\n}\\n```\n```java\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n\\tint n = triangle.size();\\n\\tint[][] dp = new int[n+1][n+1];\\n\\n\\tfor (int level=n-1; level>=0; level--)\\n\\t\\tfor (int i=0; i<=level; i++)\\n\\t\\t\\tdp[level][i] = triangle.get(level).get(i) + Math.min(dp[level+1][i], dp[level+1][i+1]);\\n\\n\\treturn dp[0][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38741,
                "title": "python-bottom-up-dp-o-n-o-n-solution-5-lines",
                "content": "Source code worth thousand words:\\n\\n    def minimumTotal(self, triangle):\\n        f = [0] * (len(triangle) + 1)\\n        for row in triangle[::-1]:\\n            for i in xrange(len(row)):\\n                f[i] = row[i] + min(f[i], f[i + 1])\\n        return f[0]]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "Source code worth thousand words:\\n\\n    def minimumTotal(self, triangle):\\n        f = [0] * (len(triangle) + 1)\\n        for row in triangle[::-1]:\\n            for i in xrange(len(row)):\\n                f[i] = row[i] + min(f[i], f[i + 1])\\n        return f[0]]",
                "codeTag": "Python3"
            },
            {
                "id": 773863,
                "title": "simple-step-by-step-recursive-memoization-dp-three-solutions-easy-to-understand",
                "content": "***Resources: https://github.com/AJAYKR00KJ/LeetCode_Solution***\\n\\n**Here is three solution Recursive -> Memoization -> DP\\nStep By Step.**\\n\\n**1.Recursive (It may give TLE , but good understanding of memoization and dp you should understand it first)**\\n\\n**42 / 43 test cases passed.**\\n\\n```\\nclass Solution {\\npublic:\\n   int minTotalUtil(vector<vector<int>>& triangle, int h, int j) {\\n        \\n       if(h == triangle.size()) {\\n             return 0;\\n        }  \\n        \\n        return triangle[h][j]+min(minTotalUtil(triangle, h+1, j),minTotalUtil(triangle, h+1, j+1));\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n         \\n          return minTotalUtil(triangle, 0, 0);\\n    }\\n};\\n```\\n\\n**2. Memoization of  recursive solution :**\\n\\n**Runtime: 12 ms\\nMemory Usage: 8.9 MB**\\n\\n```\\nclass Solution {\\npublic:\\n   int minTotalUtil(vector<vector<int>>& triangle, int h, int j,vector<vector<int>> &v) {\\n        if(h == triangle.size()) {\\n             \\n            return 0;\\n        }\\n         if(v[h][j]!=-1) return v[h][j];  \\n        \\n        return v[h][j]=triangle[h][j]+min(minTotalUtil(triangle, h+1, j,v),minTotalUtil(triangle, h+1, j+1,v));\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int minSum = INT_MAX;\\n          int h=triangle.size(),j;\\n         j=h;\\n        vector<vector<int>> v(h,vector<int> (j,-1));\\n          minSum=minTotalUtil(triangle, 0, 0,v);\\n        \\n        cout << minSum << endl;\\n        return minSum;\\n        \\n    }\\n};\\n```\\n\\n**3. Last and best DP**\\n\\n**Runtime: 8 ms\\nMemory Usage: 8.8 MB**\\n```\\n class Solution {\\npublic:\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int minSum = INT_MAX;\\n          int h=triangle.size(),j;\\n         j=h;\\n        vector<vector<int>> v(h,vector<int> (j,0));\\n         v[0][0]=triangle[0][0];\\n         for(int i=1;i<h;i++)\\n         {\\n             for(int j=0;j<triangle[i].size();j++)\\n             {\\n                 if(j==0) v[i][j]=v[i-1][j]+triangle[i][j];\\n                 else if(j==triangle[i].size()-1) v[i][j]=v[i-1][j-1]+triangle[i][j];\\n                 else\\n                 v[i][j]=min(v[i-1][j-1],v[i-1][j])+triangle[i][j];\\n             }\\n              \\n         }\\n         \\n        return *min_element(v[h-1].begin(),v[h-1].end());\\n         \\n        \\n    }\\n};\\n```\\n\\n**Or you can refer this also**\\n\\n**Runtime: 16 ms \\nMemory Usage: 8.5 MB**\\n```\\nclass Solution {\\npublic:\\n    \\n    int minimumTotal(vector<vector<int>>& tri) {\\n          int h=tri.size();\\n         for(int i=1;i<tri.size();i++)\\n         {\\n             for(int j=0;j<tri[i].size();j++)\\n             {\\n                 if(j==0) tri[i][j]=tri[i-1][j]+tri[i][j];\\n                 else if(j==tri[i].size()-1) tri[i][j]=tri[i-1][j-1]+tri[i][j];\\n                 else\\n                 tri[i][j]=min(tri[i-1][j-1],tri[i-1][j])+tri[i][j];\\n             }\\n              \\n         }\\n         \\n        return *min_element(tri[h-1].begin(),tri[h-1].end());\\n         \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minTotalUtil(vector<vector<int>>& triangle, int h, int j) {\\n        \\n       if(h == triangle.size()) {\\n             return 0;\\n        }  \\n        \\n        return triangle[h][j]+min(minTotalUtil(triangle, h+1, j),minTotalUtil(triangle, h+1, j+1));\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n         \\n          return minTotalUtil(triangle, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   int minTotalUtil(vector<vector<int>>& triangle, int h, int j,vector<vector<int>> &v) {\\n        if(h == triangle.size()) {\\n             \\n            return 0;\\n        }\\n         if(v[h][j]!=-1) return v[h][j];  \\n        \\n        return v[h][j]=triangle[h][j]+min(minTotalUtil(triangle, h+1, j,v),minTotalUtil(triangle, h+1, j+1,v));\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int minSum = INT_MAX;\\n          int h=triangle.size(),j;\\n         j=h;\\n        vector<vector<int>> v(h,vector<int> (j,-1));\\n          minSum=minTotalUtil(triangle, 0, 0,v);\\n        \\n        cout << minSum << endl;\\n        return minSum;\\n        \\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int minSum = INT_MAX;\\n          int h=triangle.size(),j;\\n         j=h;\\n        vector<vector<int>> v(h,vector<int> (j,0));\\n         v[0][0]=triangle[0][0];\\n         for(int i=1;i<h;i++)\\n         {\\n             for(int j=0;j<triangle[i].size();j++)\\n             {\\n                 if(j==0) v[i][j]=v[i-1][j]+triangle[i][j];\\n                 else if(j==triangle[i].size()-1) v[i][j]=v[i-1][j-1]+triangle[i][j];\\n                 else\\n                 v[i][j]=min(v[i-1][j-1],v[i-1][j])+triangle[i][j];\\n             }\\n              \\n         }\\n         \\n        return *min_element(v[h-1].begin(),v[h-1].end());\\n         \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minimumTotal(vector<vector<int>>& tri) {\\n          int h=tri.size();\\n         for(int i=1;i<tri.size();i++)\\n         {\\n             for(int j=0;j<tri[i].size();j++)\\n             {\\n                 if(j==0) tri[i][j]=tri[i-1][j]+tri[i][j];\\n                 else if(j==tri[i].size()-1) tri[i][j]=tri[i-1][j-1]+tri[i][j];\\n                 else\\n                 tri[i][j]=min(tri[i-1][j-1],tri[i-1][j])+tri[i][j];\\n             }\\n              \\n         }\\n         \\n        return *min_element(tri[h-1].begin(),tri[h-1].end());\\n         \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 38827,
                "title": "one-liner-in-python",
                "content": "**Solution**\\n\\n    def minimumTotal(self, t):\\n        return reduce(lambda a,b:[f+min(d,e)for d,e,f in zip(a,a[1:],b)],t[::-1])[0]\\n\\n---\\n\\n**Explanation**\\n\\nStarting with the bottom row, I move upwards, always combining the current row and the next upper row. At the end, I have combined everything into the top row and simply return its only element. Here's a longer version with meaningful variable names:\\n\\n    def minimumTotal(self, triangle):\\n        def combine_rows(lower_row, upper_row):\\n            return [upper + min(lower_left, lower_right)\\n                    for upper, lower_left, lower_right in\\n                    zip(upper_row, lower_row, lower_row[1:])]\\n        return reduce(combine_rows, triangle[::-1])[0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution**\\n\\n    def minimumTotal(self, t):\\n        return reduce(lambda a,b:[f+min(d,e)for d,e,f in zip(a,a[1:],b)],t[::-1])[0]\\n\\n---\\n\\n**Explanation**\\n\\nStarting with the bottom row, I move upwards, always combining the current row and the next upper row. At the end, I have combined everything into the top row and simply return its only element. Here's a longer version with meaningful variable names:\\n\\n    def minimumTotal(self, triangle):\\n        def combine_rows(lower_row, upper_row):\\n            return [upper + min(lower_left, lower_right)\\n                    for upper, lower_left, lower_right in\\n                    zip(upper_row, lower_row, lower_row[1:])]\\n        return reduce(combine_rows, triangle[::-1])[0]",
                "codeTag": "Python3"
            },
            {
                "id": 38918,
                "title": "c-top-down-and-bottom-up-solutions",
                "content": "        \\n    // top-down \\n    int minimumTotal1(vector<vector<int>>& triangle) {\\n        vector<int> res(triangle.size(), triangle[0][0]);\\n        for (unsigned int i = 1; i < triangle.size(); i++) \\n            for (int j = i; j >= 0; j--) {\\n                if (j == 0)\\n                    res[0] += triangle[i][j];\\n                else if (j == i)\\n                    res[j] = triangle[i][j] + res[j-1];\\n                else \\n                    res[j] = triangle[i][j] + min(res[j-1], res[j]);\\n            }\\n        return *min_element(res.begin(), res.end());\\n    }\\n    \\n    // bottom-up\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<int> res = triangle.back();\\n        for (int i = triangle.size()-2; i >= 0; i--) \\n            for (unsigned int j = 0; j <= i; j++) \\n                res[j] = triangle[i][j] + min(res[j], res[j+1]);\\n        return res[0];\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    // top-down \\n    int minimumTotal1(vector<vector<int>>& triangle) {\\n        vector<int> res(triangle.size(), triangle[0][0]);\\n        for (unsigned int i = 1; i < triangle.size(); i++) \\n            for (int j = i; j >= 0; j--) {\\n                if (j == 0)\\n                    res[0] += triangle[i][j];\\n                else if (j == i)\\n                    res[j] = triangle[i][j] + res[j-1];\\n                else \\n                    res[j] = triangle[i][j] + min(res[j-1], res[j]);\\n            }\\n        return *min_element(res.begin(), res.end());\\n    }\\n    \\n    // bottom-up\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<int> res = triangle.back();\\n        for (int i = triangle.size()-2; i >= 0; i--) \\n            for (unsigned int j = 0; j <= i; j++) \\n                res[j] = triangle[i][j] + min(res[j], res[j+1]);\\n        return res[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 159686,
                "title": "java-recursive-top-down-bottom-up-bottom-up-optimal-space",
                "content": "```\\n//Recursive\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n       if (triangle == null || triangle.size() == 0) return 0;\\n\\n       return dfs(0, 0, triangle);\\n   }\\n\\n\\n   int dfs(int row, int pos, List<List<Integer>> triangle){\\n       //Out of bounds so just return sum previous value must be leaf node\\n       if (row+1 >= triangle.size()) return triangle.get(row).get(pos);\\n\\n     return  triangle.get(row).get(pos) + Math.min (dfs(row+1, pos,triangle), dfs(row+1, pos+1, triangle));\\n\\n  }\\n\\n}\\n\\n//Top down\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        if (triangle == null || triangle.size() == 0) return 0;\\n        Integer[][] cache = new Integer[triangle.size()][triangle.size()];\\n        return dfs(0, 0,triangle, cache);\\n    }\\n    \\n    \\n    int dfs(int row, int pos, List<List<Integer>> triangle, Integer[][] cache){\\n        //Out of bounds so just return sum previous value must be leaf node\\n        if (row+1 >= triangle.size()) {\\n            return triangle.get(row).get(pos); \\n        }\\n        if(cache[row][pos] != null) return cache[row][pos];\\n        \\n      cache[row][pos] =  triangle.get(row).get(pos) + Math.min ( dfs(row+1, pos,triangle, cache), dfs(row+1, pos+1,triangle, cache));\\n        \\n        return cache[row][pos];\\n        \\n    }\\n\\n\\n\\n\\n\\n//Bottom up\\n\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n\\n    int[][]dp = new int[triangle.size()][triangle.size()];\\n    //Remember base case is just returning leaf nodes\\n    for (int i = 0; i < triangle.size(); i++){\\n        dp[triangle.size()-1][i] = triangle.get(triangle.size()-1).get(i);\\n    }\\n\\n    for (int row = triangle.size()-2; row >= 0; row--){\\n        for (int pos = 0; pos < triangle.get(row).size(); pos++){\\n            dp[row][pos] = triangle.get(row).get(pos) + Math.min(dp[row+1][pos+1], dp[row+1][pos]);\\n        }\\n    }\\n\\n    return dp[0][0];\\n}\\n\\n//Bottom up O(n) space complexity.\\nclass Solution {\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n\\n    int[]dp = new int[triangle.size()];\\n    int[]dp1 = new int[triangle.size()];\\n    //Remember base case is just returning leaf nodes\\n    for (int i = 0; i < triangle.size(); i++){\\n        dp[i] = triangle.get(triangle.size()-1).get(i);\\n    }\\n\\n    for (int row = triangle.size()-2; row >= 0; row--){\\n        for (int pos = 0; pos < triangle.get(row).size(); pos++){\\n            dp1[pos] = triangle.get(row).get(pos) + Math.min(dp[pos+1], dp[pos]);\\n        }\\n        dp = dp1;\\n    }\\n\\n    return dp[0];\\n}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//Recursive\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n       if (triangle == null || triangle.size() == 0) return 0;\\n\\n       return dfs(0, 0, triangle);\\n   }\\n\\n\\n   int dfs(int row, int pos, List<List<Integer>> triangle){\\n       //Out of bounds so just return sum previous value must be leaf node\\n       if (row+1 >= triangle.size()) return triangle.get(row).get(pos);\\n\\n     return  triangle.get(row).get(pos) + Math.min (dfs(row+1, pos,triangle), dfs(row+1, pos+1, triangle));\\n\\n  }\\n\\n}\\n\\n//Top down\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        if (triangle == null || triangle.size() == 0) return 0;\\n        Integer[][] cache = new Integer[triangle.size()][triangle.size()];\\n        return dfs(0, 0,triangle, cache);\\n    }\\n    \\n    \\n    int dfs(int row, int pos, List<List<Integer>> triangle, Integer[][] cache){\\n        //Out of bounds so just return sum previous value must be leaf node\\n        if (row+1 >= triangle.size()) {\\n            return triangle.get(row).get(pos); \\n        }\\n        if(cache[row][pos] != null) return cache[row][pos];\\n        \\n      cache[row][pos] =  triangle.get(row).get(pos) + Math.min ( dfs(row+1, pos,triangle, cache), dfs(row+1, pos+1,triangle, cache));\\n        \\n        return cache[row][pos];\\n        \\n    }\\n\\n\\n\\n\\n\\n//Bottom up\\n\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n\\n    int[][]dp = new int[triangle.size()][triangle.size()];\\n    //Remember base case is just returning leaf nodes\\n    for (int i = 0; i < triangle.size(); i++){\\n        dp[triangle.size()-1][i] = triangle.get(triangle.size()-1).get(i);\\n    }\\n\\n    for (int row = triangle.size()-2; row >= 0; row--){\\n        for (int pos = 0; pos < triangle.get(row).size(); pos++){\\n            dp[row][pos] = triangle.get(row).get(pos) + Math.min(dp[row+1][pos+1], dp[row+1][pos]);\\n        }\\n    }\\n\\n    return dp[0][0];\\n}\\n\\n//Bottom up O(n) space complexity.\\nclass Solution {\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n\\n    int[]dp = new int[triangle.size()];\\n    int[]dp1 = new int[triangle.size()];\\n    //Remember base case is just returning leaf nodes\\n    for (int i = 0; i < triangle.size(); i++){\\n        dp[i] = triangle.get(triangle.size()-1).get(i);\\n    }\\n\\n    for (int row = triangle.size()-2; row >= 0; row--){\\n        for (int pos = 0; pos < triangle.get(row).size(); pos++){\\n            dp1[pos] = triangle.get(row).get(pos) + Math.min(dp[pos+1], dp[pos]);\\n        }\\n        dp = dp1;\\n    }\\n\\n    return dp[0];\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38831,
                "title": "java-solution-dynamic-programming",
                "content": "    public int minimumTotal(List<List<Integer>> trgl) {\\n        int sz = trgl.size();\\n        int[] results = new int[sz+1];\\n        \\n        for(int i=sz-1; i>=0; i--) {\\n            List<Integer> tmp = trgl.get(i);\\n            \\n            for(int j=0; j<tmp.size(); j++) {\\n                results[j] = Math.min(results[j], results[j+1]) + tmp.get(j);\\n            }\\n        }\\n        return results[0];\\n    }",
                "solutionTags": [],
                "code": "    public int minimumTotal(List<List<Integer>> trgl) {\\n        int sz = trgl.size();\\n        int[] results = new int[sz+1];\\n        \\n        for(int i=sz-1; i>=0; i--) {\\n            List<Integer> tmp = trgl.get(i);\\n            \\n            for(int j=0; j<tmp.size(); j++) {\\n                results[j] = Math.min(results[j], results[j+1]) + tmp.get(j);\\n            }\\n        }\\n        return results[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1169353,
                "title": "js-python-java-c-simple-o-1-space-in-place-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to find the best path from the top of the input triangle array (**T**) to the bottom, we should be able to find the best path to any intermediate spot along that path, as well. That should immediately bring to mind a **dynamic programming** (**DP**) solution, as we can divide this solution up into smaller pieces and then build those up to our eventual solution.\\n\\nThe naive idea here might be to do a **bottom-up** DP approach (which is actually from the start of the path, or the top of **T**, to the end of the path, or the bottom of **T**), since that reflects the normal path progression and branching. If we do this, however, we\\'ll need to write extra code to avoid going out-of-bounds when checking the previously completed rows of the DP array. We\\'ll also have to then check the entire bottom row of our DP array to find the best value.\\n\\nIf we use a **top-down** DP approach (visually bottom to top of **T**), however, we can avoid having to check for out-of-bounds conditions, as we\\'ll be going from larger rows to smaller rows. Also, we won\\'t need to search for the best solution, because it will automatically be isolated in **T[0][0]**.\\n\\nFurthermore, since we\\'ll never need to backtrack to previous rows, we can use **T** as its own **in-place** DP array, updating the values as we go, in order to achieve a **space complexity** of **O(1)** extra space.\\n\\nIn order to accomplish this, we\\'ll just need to iterate backwards through the rows, starting from the second to the last, and figure out what the best path to the bottom would be from each location in the row. Since the values in the row below will already represent the best path from that point, we can just add the lower of the two possible branches to the current location (**T[i][j]**) at each iteration.\\n\\nOnce we\\'re done, we can simply **return T[0][0]**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Java, using an **in-place DP** approach, while saving on **space complexity**, is significantly less performant than using an **O(N)** DP array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.8MB** (beats 98% / 93%).\\n```javascript\\nvar minimumTotal = function(T) {\\n    for (let i = T.length - 2; ~i; i--) \\n        for (let j = T[i].length - 1; ~j; j--) \\n            T[i][j] += Math.min(T[i+1][j], T[i+1][j+1])\\n    return T[0][0]\\n}\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **48ms / 14.9MB** (beats 99% / 85%).\\n```python\\nclass Solution:\\n    def minimumTotal(self, T: List[List[int]]) -> int:\\n        for i in range(len(T)-2,-1,-1):\\n            for j in range(len(T[i])-1,-1,-1):\\n                T[i][j] += min(T[i+1][j], T[i+1][j+1])\\n        return T[0][0]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **4ms / 38.6MB** (beats 32% / 96%).\\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> T) {\\n        for (int i = T.size() - 2; i >= 0; i--) \\n            for (int j = T.get(i).size() - 1; j >= 0; j--) {\\n                int min = Math.min(T.get(i+1).get(j), T.get(i+1).get(j+1));\\n                T.get(i).set(j, T.get(i).get(j) + min);\\n            }\\n        return T.get(0).get(0);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 8.3MB** (beats 100% / 94%).\\n```c++\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& T) {\\n        for (int i = T.size() - 2; ~i; i--) \\n            for (int j = T[i].size() - 1; ~j; j--) \\n                T[i][j] += min(T[i+1][j], T[i+1][j+1]);\\n        return T[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minimumTotal = function(T) {\\n    for (let i = T.length - 2; ~i; i--) \\n        for (let j = T[i].length - 1; ~j; j--) \\n            T[i][j] += Math.min(T[i+1][j], T[i+1][j+1])\\n    return T[0][0]\\n}\\n```\n```python\\nclass Solution:\\n    def minimumTotal(self, T: List[List[int]]) -> int:\\n        for i in range(len(T)-2,-1,-1):\\n            for j in range(len(T[i])-1,-1,-1):\\n                T[i][j] += min(T[i+1][j], T[i+1][j+1])\\n        return T[0][0]\\n```\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> T) {\\n        for (int i = T.size() - 2; i >= 0; i--) \\n            for (int j = T.get(i).size() - 1; j >= 0; j--) {\\n                int min = Math.min(T.get(i+1).get(j), T.get(i+1).get(j+1));\\n                T.get(i).set(j, T.get(i).get(j) + min);\\n            }\\n        return T.get(0).get(0);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& T) {\\n        for (int i = T.size() - 2; ~i; i--) \\n            for (int j = T[i].size() - 1; ~j; j--) \\n                T[i][j] += min(T[i+1][j], T[i+1][j+1]);\\n        return T[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292900,
                "title": "from-recursion-to-dp-approach-and-4-solutions-java",
                "content": "**Approach**\\n\\nThe only way to find out which path is the shortest is to try all the paths and return the minimum. Recursion is helpful for solving such problems. We start from the initial position (top of the triangle), then choose between two paths. We can go to the same column or one ahead (column + 1). In terms of row, we have no choice but to move on to the next row (row + 1). Hence the two choices are,\\n1. go to triangle[row + 1][col]\\n2. go to triangle[row + 1][col + 1]\\n\\nThis forms a recursive structure and the base case is when we pass the last row, where the answer will always be 0. After implementing this you will realize that some rows and columns are recursed over multiple times. To optimize this, we can store answers for the positions we have already computed. This is where we enter Dynamic Programming territory. Finally, we can observe that we only need row + 1 to compute answers for the current row. So, the space can also be optimized to linear.\\n\\nNote that for the dp table, in solution 3, I have tried an ArrayList. This is because due to the structure of the triangle the N by N space of table will waste some memory. Swapping Array and ArrayList for one another will not improve asymptotic complexity, but Arrays are initialized slightly faster and used slightly more space in my test runs. The final choice is upto you.\\n\\n**Solutions**\\nN = number of rows = maximum number of columns\\n\\n**1. Recursion**\\nTime complexity: O(2^N)\\nSpace complexity: O(N)\\n\\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        // start from the top of the triangle\\n        return recurse(triangle, 0, 0);\\n    }\\n    \\n    private int recurse(List<List<Integer>> triangle, int row, int col) {\\n        // base case\\n        if (row == triangle.size())\\n            return 0;\\n        \\n        // either go to [row + 1, col] or [row + 1, col + 1]\\n        int remain = Math.min(recurse(triangle, row + 1, col),\\n                              recurse(triangle, row + 1, col + 1));\\n        \\n        // combine answer with current value\\n        return triangle.get(row).get(col) + remain;\\n    }\\n}\\n```\\n\\n**2. Memoization**\\nTime complexity: O(N^2)\\nSpace complexity: O(N^2)\\n\\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        // create dp table\\n        int[][] memo = new int[triangle.size()][triangle.get(triangle.size() - 1).size()];\\n        for (int[] row: memo)\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        \\n        // start from the top of the triangle\\n        return recurse(triangle, 0, 0, memo);\\n    }\\n    \\n    private int recurse(List<List<Integer>> triangle, int row, int col, int[][] memo) {\\n        // base case\\n        if (row == triangle.size())\\n            return 0;\\n        \\n        // check dp table\\n        if (memo[row][col] != Integer.MAX_VALUE)\\n            return memo[row][col];\\n        \\n        // either go to [row + 1, col] or [row + 1, col + 1]\\n        int remain = Math.min(recurse(triangle, row + 1, col, memo),\\n                              recurse(triangle, row + 1, col + 1, memo));\\n        \\n        // combine answer with current value\\n        memo[row][col] = triangle.get(row).get(col) + remain;\\n        return memo[row][col];\\n    }\\n}\\n```\\n\\n**3. Tabulation**\\nTime complexity: O(N^2)\\nSpace complexity: O(N^2)\\n\\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        // create dp table by copying the input triangle\\n        List<List<Integer>> table = new ArrayList<>();\\n        for (List<Integer> row: triangle) \\n            table.add(new ArrayList<>(row));\\n        \\n        // iterate over the entire triangle from bottom to top\\n        for (int row = triangle.size() - 2; row >= 0; row--) {\\n            for (int col = 0; col < triangle.get(row).size(); col++) {\\n                // either go to [row + 1, col] or [row + 1, col + 1]\\n                int remain = Math.min(table.get(row + 1).get(col),\\n                                      table.get(row + 1).get(col + 1));\\n                \\n                // combine answer with current value\\n                table.get(row).set(col, triangle.get(row).get(col) + remain);\\n            }\\n        }\\n        \\n        // return answer for the top of the triangle\\n        return table.get(0).get(0);\\n    }\\n}\\n```\\n\\n**4. Tabulation With Optimized Space**\\nTime complexity: O(N^2)\\nSpace complexity: O(N)\\n\\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        // create dp table with size of the largest column (which is number of rows)\\n        int[] table = new int[triangle.size() + 1];\\n        Arrays.fill(table, 0);\\n                \\n        // iterate over the entire triangle from bottom to top\\n        for (int row = triangle.size() - 1; row >= 0; row--) {\\n            for (int col = 0; col <= row; col++) {\\n                // either go to [row + 1, col] or [row + 1, col + 1]\\n                int remain = Math.min(table[col],\\n                                      table[col + 1]);\\n                \\n                // combine answer with current value\\n                table[col] = triangle.get(row).get(col) + remain;\\n            }\\n        }\\n        \\n        return table[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        // start from the top of the triangle\\n        return recurse(triangle, 0, 0);\\n    }\\n    \\n    private int recurse(List<List<Integer>> triangle, int row, int col) {\\n        // base case\\n        if (row == triangle.size())\\n            return 0;\\n        \\n        // either go to [row + 1, col] or [row + 1, col + 1]\\n        int remain = Math.min(recurse(triangle, row + 1, col),\\n                              recurse(triangle, row + 1, col + 1));\\n        \\n        // combine answer with current value\\n        return triangle.get(row).get(col) + remain;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        // create dp table\\n        int[][] memo = new int[triangle.size()][triangle.get(triangle.size() - 1).size()];\\n        for (int[] row: memo)\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        \\n        // start from the top of the triangle\\n        return recurse(triangle, 0, 0, memo);\\n    }\\n    \\n    private int recurse(List<List<Integer>> triangle, int row, int col, int[][] memo) {\\n        // base case\\n        if (row == triangle.size())\\n            return 0;\\n        \\n        // check dp table\\n        if (memo[row][col] != Integer.MAX_VALUE)\\n            return memo[row][col];\\n        \\n        // either go to [row + 1, col] or [row + 1, col + 1]\\n        int remain = Math.min(recurse(triangle, row + 1, col, memo),\\n                              recurse(triangle, row + 1, col + 1, memo));\\n        \\n        // combine answer with current value\\n        memo[row][col] = triangle.get(row).get(col) + remain;\\n        return memo[row][col];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        // create dp table by copying the input triangle\\n        List<List<Integer>> table = new ArrayList<>();\\n        for (List<Integer> row: triangle) \\n            table.add(new ArrayList<>(row));\\n        \\n        // iterate over the entire triangle from bottom to top\\n        for (int row = triangle.size() - 2; row >= 0; row--) {\\n            for (int col = 0; col < triangle.get(row).size(); col++) {\\n                // either go to [row + 1, col] or [row + 1, col + 1]\\n                int remain = Math.min(table.get(row + 1).get(col),\\n                                      table.get(row + 1).get(col + 1));\\n                \\n                // combine answer with current value\\n                table.get(row).set(col, triangle.get(row).get(col) + remain);\\n            }\\n        }\\n        \\n        // return answer for the top of the triangle\\n        return table.get(0).get(0);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        // create dp table with size of the largest column (which is number of rows)\\n        int[] table = new int[triangle.size() + 1];\\n        Arrays.fill(table, 0);\\n                \\n        // iterate over the entire triangle from bottom to top\\n        for (int row = triangle.size() - 1; row >= 0; row--) {\\n            for (int col = 0; col <= row; col++) {\\n                // either go to [row + 1, col] or [row + 1, col + 1]\\n                int remain = Math.min(table[col],\\n                                      table[col + 1]);\\n                \\n                // combine answer with current value\\n                table[col] = triangle.get(row).get(col) + remain;\\n            }\\n        }\\n        \\n        return table[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169429,
                "title": "triangle-short-simple-o-1-dp-w-explanation-4-lines-of-code",
                "content": "We are given a triangle. We start at the top of the triangle and want to move to the bottom with minimum possible sum. We can either move down to the same index *`i`* or to the index *`i + 1`*.\\n\\n----\\n\\n\\u2714\\uFE0F ***Solution - I (In-Place Bottom-Up Dynamic Programming)***\\n\\nWe can easily see that directly just choosing the minimum value in the next row(amongst `triangle[nextRow][i]` and  `triangle[nextRow][i+1]`) won\\'t fetch us the optimal final result since it maybe the case that the latter values of previous chosen path turn out to be huge. \\n\\nWe need to observe that to get the minimum possible sum, **we must use a path that has Optimal Value for each intermediate stop in the path**. Thus, we can use **Dynamic Programming** to find the optimal value to reach each position of the triangle level by level. We can do this by accumulating the sum of path(or more specifically sum of values of optimal stops in a path) for each cell of a level from top to the bottom of triangle.\\n\\n We are given that, at each cell in the triangle, we can move to the next row using two choices - \\n \\n 1. Move to the same index `i`.\\n 2. Move to the next index `i + 1`\\n\\nSince we are following **a bottom-up approach, the above can also be interpreted as** :- \\n\\nFor cell in the triangle, we could have reached here either from the previous row/level either from -\\n\\n1. the same index `i`, or\\n2. the index `i - 1`\\n\\nSo, obviously the optimal choice to arrive at the current position in triangle would be to come from the cell having minimum value of these two choices. \\n\\nWe will keep adding the result from the lower level to the next/higher level by each time choosing the optimal cell to arrive at the current cell. Finally, we can return the minimum value that we get at the bottom-most row of the triangle. Here, no auxillary space is used and I have modified the *`triangle`* itself to achieve a space complexity of `O(1)`.\\n\\n**C++**\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\t// start from level 1 till the bottom-most level. Each time determine the best path to arrive at current cell\\n\\tfor(int level = 1; level < size(triangle); level++) \\n\\t\\tfor(int i = 0; i <= level; i++)  // triangle[level].size() == level + 1 (level starts from 0)\\n\\t\\t\\t// for the current level: \\n\\t\\t\\ttriangle[level][i] += min(triangle[level - 1][min(i, (int)size(triangle[level - 1]) - 1)], // we can either come from previous level and same index\\n\\t\\t\\t                          triangle[level - 1][max(i - 1, 0)]); // or the previous level and index-1\\n\\t// finally return the last element of the bottom level\\n\\treturn *min_element(begin(triangle.back()), end(triangle.back())); \\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    for level in range(1, len(triangle)):\\n        for i in range(level+1):\\n            triangle[level][i] += min(triangle[level-1][min(i, level-1)], triangle[level-1][max(i-1,0)])\\n    return min(triangle[-1])\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**, where `N` are the total number of levels in *`triangle`*.\\n***Space Complexity :*** **`O(1)`**\\n\\nThe `min` and `max` in the above code are used to do bound-checks.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (In-Place Top-Down Dynamic Programming)***\\n\\n\\nWe chose to go from **top-level to the bottom-level of triangle in the previous approach**. We can also choose to start from the bottom of triangle and move all the way to the top. We will again follow the same DP strategy as used in the above solution.\\n\\nAt each cell of the triangle, we could have moved here from the below level in 2 ways, either from -\\n\\n1. the same index `i` in below row, or\\n2. the index `i+1`.\\n\\nAnd again, we will choose the minimum of these two to arrive at the optimal solution. Finally at last, we will reach at `triangle[0][0]`, which will hold the optimal (minimum) sum of path.\\n\\nActually, this approach will make the code a lot more clean and concise by avoiding the need of bound checks.\\n\\n**C++**\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tfor(int level = size(triangle) - 2; level >= 0; level--) // start from bottom-1 level\\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\t // for every cell: we could have moved here from same index or index+1 of next level\\n\\t\\t\\ttriangle[level][i] += min(triangle[level + 1][i], triangle[level + 1][i + 1]);\\n\\treturn triangle[0][0]; // lastly t[0][0] will contain accumulated sum of minimum path\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    for level in range(len(triangle)-2,-1,-1):\\n        for i in range(level+1):\\n            triangle[level][i] += min(triangle[level+1][i], triangle[level+1][i+1])\\n    return triangle[0][0]\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n---\\n\\n***Solution - III (Bottom-Up Dynamic Programming w/ Auxillary Space)***\\n\\nMore often than not, you would not be allowed to modify the given input. In such a situation, we can obviously opt for making a copy of the given input(*`triangle`* in this case). This would lead to a space complexity of **`O(N^2)`**. I won\\'t show this solution since the only change needed in above solutions would be adding the line `vector<vector<int>>dp(triangle);` and replacing `triangle` with `dp` (Or better yet just pass triangle by value instead of reference & keep using that itself \\uD83E\\uDD37\\u200D\\u2642\\uFE0F).\\n\\nHere, I will present a **solution with linear space complexity without input modification**. We can observe in the above solutions that we really ever **access only two rows of the input at the same time**. So, we can just maintain two rows and alternate between those two in our loop.\\n\\nI have used `level & 1` in the below solution to alternate between these two rows of *`dp`*. It\\'s very common way to go when we are converting from 2d DP to linear space. If you are not comfortable with it, you can also choose to maintain two separate rows and swap them at end of each iteration.\\n\\nAll the other things and idea remains the same as in the *`solution - I`*\\n\\n**C++**\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tint n = size(triangle), level = 1;\\n\\tvector<vector<int> > dp(2, vector<int>(n, INT_MAX));\\n\\tdp[0][0]=triangle[0][0];  // assign top-most row to dp[0] as we will be starting from level 1\\n\\tfor(; level < n; level++) \\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\tdp[level & 1][i] = triangle[level][i] + min(dp[(level - 1) & 1][min(i, n - 1)], dp[(level - 1) & 1][max(i - 1, 0)]); \\n\\tlevel--; // level becomes n after for loop ends. We need minimum value from level - 1\\n\\treturn *min_element(begin(dp[level & 1]), end(dp[level & 1])); \\n}\\n```\\n\\n---\\n\\n**Python**\\n\\nThe below solution is using the two separate rows method that I described above  and swapping after each iteration to alternate between them -\\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\tn = len(triangle)\\n\\tcur_row, prev_row = [0]*n, [0]*n\\n\\tprev_row[0] = triangle[0][0]  \\n\\tfor level in range(1, n):\\n\\t\\tfor i in range(level+1):\\n\\t\\t\\tcur_row[i] = triangle[level][i] + min(prev_row[min(i, level-1)], prev_row[max(i-1,0)])\\n\\t\\tcur_row, prev_row = prev_row, cur_row\\n\\treturn min(prev_row)\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n***Solution - IV (Top-Down Dynamic Programming w/ Auxillary Space)***\\n\\nHere is the Top-Down version of *`Solution - II`*, without input array modification and using linear auxillary space.\\n\\n**C++**\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tint n = size(triangle), level = n - 1;\\n\\tvector<vector<int> > dp(2, vector<int>(n, 0));\\n\\tdp[level-- & 1] = triangle[n - 1];\\n\\tfor(; level >= 0; level--)\\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\tdp[level & 1][i] = triangle[level][i] + min(dp[(level + 1) & 1][i], dp[(level + 1) & 1][i + 1]);\\n\\treturn dp[0][0];\\n}\\n```\\n\\n---\\n\\n**Python**\\n\\nAgain, I have used to two separate rows method here -\\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    n = len(triangle)\\n    cur_row, next_row = [0]*n, triangle[n-1]        \\n    for level in range(n-2,-1,-1):\\n        for i in range(level+1):\\n            cur_row[i] = triangle[level][i] + min(next_row[i], next_row[i+1])\\n        cur_row, next_row = next_row, cur_row\\n    return next_row[0]\\n```\\n\\n***Time Complexity :*** **`O(N^2)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/0f015916-9fb1-4b39-9048-497255edac1a_1619015402.2332594.png /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\t// start from level 1 till the bottom-most level. Each time determine the best path to arrive at current cell\\n\\tfor(int level = 1; level < size(triangle); level++) \\n\\t\\tfor(int i = 0; i <= level; i++)  // triangle[level].size() == level + 1 (level starts from 0)\\n\\t\\t\\t// for the current level: \\n\\t\\t\\ttriangle[level][i] += min(triangle[level - 1][min(i, (int)size(triangle[level - 1]) - 1)], // we can either come from previous level and same index\\n\\t\\t\\t                          triangle[level - 1][max(i - 1, 0)]); // or the previous level and index-1\\n\\t// finally return the last element of the bottom level\\n\\treturn *min_element(begin(triangle.back()), end(triangle.back())); \\n}\\n```\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    for level in range(1, len(triangle)):\\n        for i in range(level+1):\\n            triangle[level][i] += min(triangle[level-1][min(i, level-1)], triangle[level-1][max(i-1,0)])\\n    return min(triangle[-1])\\n```\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tfor(int level = size(triangle) - 2; level >= 0; level--) // start from bottom-1 level\\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\t // for every cell: we could have moved here from same index or index+1 of next level\\n\\t\\t\\ttriangle[level][i] += min(triangle[level + 1][i], triangle[level + 1][i + 1]);\\n\\treturn triangle[0][0]; // lastly t[0][0] will contain accumulated sum of minimum path\\n}\\n```\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    for level in range(len(triangle)-2,-1,-1):\\n        for i in range(level+1):\\n            triangle[level][i] += min(triangle[level+1][i], triangle[level+1][i+1])\\n    return triangle[0][0]\\n```\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tint n = size(triangle), level = 1;\\n\\tvector<vector<int> > dp(2, vector<int>(n, INT_MAX));\\n\\tdp[0][0]=triangle[0][0];  // assign top-most row to dp[0] as we will be starting from level 1\\n\\tfor(; level < n; level++) \\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\tdp[level & 1][i] = triangle[level][i] + min(dp[(level - 1) & 1][min(i, n - 1)], dp[(level - 1) & 1][max(i - 1, 0)]); \\n\\tlevel--; // level becomes n after for loop ends. We need minimum value from level - 1\\n\\treturn *min_element(begin(dp[level & 1]), end(dp[level & 1])); \\n}\\n```\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\tn = len(triangle)\\n\\tcur_row, prev_row = [0]*n, [0]*n\\n\\tprev_row[0] = triangle[0][0]  \\n\\tfor level in range(1, n):\\n\\t\\tfor i in range(level+1):\\n\\t\\t\\tcur_row[i] = triangle[level][i] + min(prev_row[min(i, level-1)], prev_row[max(i-1,0)])\\n\\t\\tcur_row, prev_row = prev_row, cur_row\\n\\treturn min(prev_row)\\n```\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\tint n = size(triangle), level = n - 1;\\n\\tvector<vector<int> > dp(2, vector<int>(n, 0));\\n\\tdp[level-- & 1] = triangle[n - 1];\\n\\tfor(; level >= 0; level--)\\n\\t\\tfor(int i = 0; i <= level; i++)\\n\\t\\t\\tdp[level & 1][i] = triangle[level][i] + min(dp[(level + 1) & 1][i], dp[(level + 1) & 1][i + 1]);\\n\\treturn dp[0][0];\\n}\\n```\n```\\ndef minimumTotal(self, triangle: List[List[int]]) -> int:\\n    n = len(triangle)\\n    cur_row, next_row = [0]*n, triangle[n-1]        \\n    for level in range(n-2,-1,-1):\\n        for i in range(level+1):\\n            cur_row[i] = triangle[level][i] + min(next_row[i], next_row[i+1])\\n        cur_row, next_row = next_row, cur_row\\n    return next_row[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 38797,
                "title": "java-dp-solution-for-beginner",
                "content": "![alt text](https://raw.githubusercontent.com/hot13399/leetcode-graphic-answer/master/120.%20Triangle.jpg)\\n```\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n    \\tint n = triangle.size();\\n    \\t// opt[i][j] is the path sum start from one node of bottom layer to node (i,j)\\n    \\tint[][] opt = new int[n+1][n+1];\\n    \\tfor(int i = n-1;i>=0;i--){\\n    \\t\\tfor(int j=0;j<=i;j++){\\n    \\t\\t\\topt[i][j] = Math.min(opt[i+1][j],opt[i+1][j+1]) + triangle.get(i).get(j);\\n    \\t\\t}\\n    \\t}\\n    \\treturn opt[0][0];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "![alt text](https://raw.githubusercontent.com/hot13399/leetcode-graphic-answer/master/120.%20Triangle.jpg)\\n```\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n    \\tint n = triangle.size();\\n    \\t// opt[i][j] is the path sum start from one node of bottom layer to node (i,j)\\n    \\tint[][] opt = new int[n+1][n+1];\\n    \\tfor(int i = n-1;i>=0;i--){\\n    \\t\\tfor(int j=0;j<=i;j++){\\n    \\t\\t\\topt[i][j] = Math.min(opt[i+1][j],opt[i+1][j+1]) + triangle.get(i).get(j);\\n    \\t\\t}\\n    \\t}\\n    \\treturn opt[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2144882,
                "title": "python-in-place-dp-with-explanation",
                "content": "### Intuition\\n\\nWe can use the ```triangle``` array to perform our DP. This allows us to use O(1) auxiliary space. Why?\\n\\n- For any given coordinate in the triangle ```(x, y)``` where ```0 <= x < len(triangle)``` and ```0 <= y < len(triangle[x])```, the minimum path sum of the path that ends up on ```(x, y)``` is given by **```triangle[x][y]``` plus the minimum path sum of the previous coordinate**.\\n- Once we compute the minimum path sum at ```(x, y)```, we **no longer require the standalone value for ```(x, y)``` to perform any calculation**. Instead, per above, we will use the minimum sum.\\n\\nWhich coordinates are considered \"previous\" to any given coordinate ```(x, y)```? Since from any ```(x, y)``` in the ```triangle``` we can move to ```(x+1, y)``` or ```(x+1, y+1)```, we can use this information in reverse: **For any given coordinate ```(x, y)```, its \"previous\" coordinates are either ```(x-1, y-1)``` or ```(x-1, y)```**.\\n\\n---\\n\\n### Approach 1: Top-Down Approach\\n\\nFrom the discussion above, we can implement a top-down DP using the following pseudocode:\\n\\n- For each row in the ```triangle```, calculate the minimum sum at each element.\\n- After all computation is complete, return the minimum sum from the last row (i.e. ```min(triangle[-1])```).\\n\\n```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(1, len(triangle)):  # for each row in triangle (skipping the first),\\n            for j in range(i+1):           # loop through each element in the row\\n                triangle[i][j] += min(triangle[i-1][j-(j==i)],  # minimum sum from coordinate (x-1, y)\\n                                      triangle[i-1][j-(j>0)])   # minimum sum from coordinate (x-1, y-1)\\n        return min(triangle[-1])  # obtain minimum sum from last row\\n```\\n\\n**TC: O(n<sup>2</sup>)**, since we visit each element in the array\\n**SC: O(1)**, as discussed above.\\n\\n---\\n\\n### Approach 2: Bottom-Up Approach\\n\\nWe can use the same pseudocode but implement it in reverse. This saves on the min check at the end (which runs in O(n) time), since we know that **the last element for a bottom-up approach has to be `triangle[0][0]`, and therefore that is where our answer is stored**.\\n\\n```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(len(triangle)-2, -1, -1):  # for each row in triangle (skipping the last),\\n            for j in range(i+1):                  # loop through each element in the row\\n                triangle[i][j] += min(triangle[i+1][j],    # minimum sum from coordinate (x+1, y)\\n                                      triangle[i+1][j+1])  # minimum sum from coordinate (x+1, y+1)\\n        return triangle[0][0]\\n```\\n\\n**TC: O(n<sup>2</sup>)**, as discussed above.\\n**SC: O(1)**, as discussed above.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```triangle```\n```(x, y)```\n```0 <= x < len(triangle)```\n```0 <= y < len(triangle[x])```\n```(x, y)```\n```triangle[x][y]```\n```(x, y)```\n```(x, y)```\n```(x, y)```\n```(x, y)```\n```triangle```\n```(x+1, y)```\n```(x+1, y+1)```\n```(x, y)```\n```(x-1, y-1)```\n```(x-1, y)```\n```triangle```\n```min(triangle[-1])```\n```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(1, len(triangle)):  # for each row in triangle (skipping the first),\\n            for j in range(i+1):           # loop through each element in the row\\n                triangle[i][j] += min(triangle[i-1][j-(j==i)],  # minimum sum from coordinate (x-1, y)\\n                                      triangle[i-1][j-(j>0)])   # minimum sum from coordinate (x-1, y-1)\\n        return min(triangle[-1])  # obtain minimum sum from last row\\n```\n```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(len(triangle)-2, -1, -1):  # for each row in triangle (skipping the last),\\n            for j in range(i+1):                  # loop through each element in the row\\n                triangle[i][j] += min(triangle[i+1][j],    # minimum sum from coordinate (x+1, y)\\n                                      triangle[i+1][j+1])  # minimum sum from coordinate (x+1, y+1)\\n        return triangle[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040229,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n    int[] A = new int[triangle.size()+1];\\n    for(int i=triangle.size()-1;i>=0;i--){\\n        for(int j=0;j<triangle.get(i).size();j++){\\n            A[j] = Math.min(A[j],A[j+1])+triangle.get(i).get(j);\\n        }\\n    }\\n    return A[0];\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n   int minTotalUtil(vector<vector<int>>& triangle, int h, int j) {\\n        \\n       if(h == triangle.size()) {\\n             return 0;\\n        }  \\n        \\n        return triangle[h][j]+min(minTotalUtil(triangle, h+1, j),minTotalUtil(triangle, h+1, j+1));\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n         \\n          return minTotalUtil(triangle, 0, 0);\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        if not triangle:\\n            return \\n        res = triangle[-1]\\n        for i in range(len(triangle)-2, -1, -1):\\n            for j in range(len(triangle[i])):\\n                res[j] = min(res[j], res[j+1]) + triangle[i][j]\\n        return res[0]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nfunction minimumTotal(triangle: number[][]): number {\\n    if (triangle.length === 1) return triangle[0][0];\\n    \\n    let height = triangle.length - 2;\\n    \\n    for (let level: number = height; level >= 0; level--) {\\n        for (let col: number = 0; col < triangle[level].length; col++) {\\n            triangle[level][col] += Math.min(triangle[level + 1][col], triangle[level + 1][col + 1]);\\n        }\\n    }\\n    \\n    return triangle[0][0];\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n\\tfun minimumTotal(triangle: List<MutableList<Int>>): Int {\\n\\t\\tval row = triangle.size\\n\\t\\tfor (idx in row-1 downTo 0) {\\n\\t\\t\\tval size = triangle[idx].size\\n\\t\\t\\tfor (col in 0 until size-1) {\\n\\t\\t\\t\\tval num1 = triangle[idx][col]\\n\\t\\t\\t\\tval num2 = if (col+1<size) triangle[idx][col+1] else MAX_VALUE\\n\\t\\t\\t\\ttriangle[idx-1][col] += min(num1, num2)\\n\\t\\t\\t}\\n\\t\\t\\tif (size == 2) break\\n\\t\\t}\\n\\t\\treturn triangle[0][0]\\n\\t}\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func minimumTotal(_ triangle: [[Int]]) -> Int {\\n        let len = triangle.count\\n        guard len >= 1 && len <= 200 else { return 0 }\\n        var last = triangle.last!\\n        for i in stride(from: len - 2, through: 0, by: -1) {\\n            for j in 0...i { last[j] = min(last[j], last[j+1]) + triangle[i][j] }\\n        }\\n        return last[0]\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n    int[] A = new int[triangle.size()+1];\\n    for(int i=triangle.size()-1;i>=0;i--){\\n        for(int j=0;j<triangle.get(i).size();j++){\\n            A[j] = Math.min(A[j],A[j+1])+triangle.get(i).get(j);\\n        }\\n    }\\n    return A[0];\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n   int minTotalUtil(vector<vector<int>>& triangle, int h, int j) {\\n        \\n       if(h == triangle.size()) {\\n             return 0;\\n        }  \\n        \\n        return triangle[h][j]+min(minTotalUtil(triangle, h+1, j),minTotalUtil(triangle, h+1, j+1));\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n         \\n          return minTotalUtil(triangle, 0, 0);\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        if not triangle:\\n            return \\n        res = triangle[-1]\\n        for i in range(len(triangle)-2, -1, -1):\\n            for j in range(len(triangle[i])):\\n                res[j] = min(res[j], res[j+1]) + triangle[i][j]\\n        return res[0]\\n```\n```\\n```\n```\\n```\n```\\nfunction minimumTotal(triangle: number[][]): number {\\n    if (triangle.length === 1) return triangle[0][0];\\n    \\n    let height = triangle.length - 2;\\n    \\n    for (let level: number = height; level >= 0; level--) {\\n        for (let col: number = 0; col < triangle[level].length; col++) {\\n            triangle[level][col] += Math.min(triangle[level + 1][col], triangle[level + 1][col + 1]);\\n        }\\n    }\\n    \\n    return triangle[0][0];\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n\\tfun minimumTotal(triangle: List<MutableList<Int>>): Int {\\n\\t\\tval row = triangle.size\\n\\t\\tfor (idx in row-1 downTo 0) {\\n\\t\\t\\tval size = triangle[idx].size\\n\\t\\t\\tfor (col in 0 until size-1) {\\n\\t\\t\\t\\tval num1 = triangle[idx][col]\\n\\t\\t\\t\\tval num2 = if (col+1<size) triangle[idx][col+1] else MAX_VALUE\\n\\t\\t\\t\\ttriangle[idx-1][col] += min(num1, num2)\\n\\t\\t\\t}\\n\\t\\t\\tif (size == 2) break\\n\\t\\t}\\n\\t\\treturn triangle[0][0]\\n\\t}\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func minimumTotal(_ triangle: [[Int]]) -> Int {\\n        let len = triangle.count\\n        guard len >= 1 && len <= 200 else { return 0 }\\n        var last = triangle.last!\\n        for i in stride(from: len - 2, through: 0, by: -1) {\\n            for j in 0...i { last[j] = min(last[j], last[j+1]) + triangle[i][j] }\\n        }\\n        return last[0]\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145082,
                "title": "c-bottom-up-dp-4-line-code-o-1-space",
                "content": "**Approach #1 ( Inplace )**  \\nWe will store the minimum sum for each ` triangle [ i ][ j ] `going from down to up . So,every row in the triangle is dependent only on the next row to get sum.\\nThe last row is kept as it is because the minimum sum will be the values itself and we go from row `n-2` to  row` 0`.\\n# Time Complexity : O(n x n)  (n : no. of rows / column )\\n# Space Complexity : O(1)\\n\\n```\\nfor(int i =triangle.size()-2;i>=0;i--){\\n         for(int j=0;j<triangle[i].size();j++){    \\n             triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]); }}\\n    \\n        return triangle[0][0];\\n```\\n\\n**Approach #2 (Creating vector)** *follow up !*\\nIf it were given in the problem that we cannot alter the triangle then instead of changing the elements of the triangle , we can make another vector having size equal to that of last row and apply the same bottom up logic as in approach 1.\\n\\n# Time Complexity : O(n x n) \\n# Space Complexity : O(n)\\n\\n\\n```\\n int n = triangle.size();\\n        vector<int> vec = triangle[n-1];\\n        \\n        for(int i =n-2;i>=0;i--){\\n            for(int j=0;j<triangle[i].size();j++){\\n                  vec[j] = triangle[i][j] + min(vec[j],vec[j+1]);        \\n            }\\n        }\\n        return vec[0];\\n```",
                "solutionTags": [],
                "code": "```\\nfor(int i =triangle.size()-2;i>=0;i--){\\n         for(int j=0;j<triangle[i].size();j++){    \\n             triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]); }}\\n    \\n        return triangle[0][0];\\n```\n```\\n int n = triangle.size();\\n        vector<int> vec = triangle[n-1];\\n        \\n        for(int i =n-2;i>=0;i--){\\n            for(int j=0;j<triangle[i].size();j++){\\n                  vec[j] = triangle[i][j] + min(vec[j],vec[j+1]);        \\n            }\\n        }\\n        return vec[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436770,
                "title": "python-simple-solution-with-detailed-explanation-5-lines",
                "content": "The idea is simple, we start from the bottom and at each step we take the minimum between the two choices we can and add it to the row above us, in the end the result will be the value in the first row , so for example if we have this triangle \\n```\\n   2\\n  3 4\\n 6 5 7\\n4 1 8 3\\n```\\n\\nwe start from the last row, take the minimum between 1 and 4, add that to 6.\\nthen take the minimum between 1 and 8, add that to 5, take the minimum between 8 and 3, add that to 7.\\nso now our triangle looks like this: \\n```\\n   2\\n  3 4\\n 7 6 10\\n 4 1 8 3\\n```\\nrepeating the process, we take the minimum between 6 and 7, add it to 3\\ntake the minimum between 6 and 10, add it to 4, we get:\\n```\\n   2\\n  9 10\\n 7 6 10\\n 4 1 8 3\\n```\\nfinally we have one last step, take the minimum between 9 and 10, add it to 2\\nand the final triangle is:\\n\\n```\\n   11\\n  9 10\\n 7 6 10\\n 4 1 8 3\\n```\\n\\nand we can see 11 is our answer! :)\\n\\nCode:\\n\\n```\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        n = len(triangle)\\n\\t\\t\\n        for i in range(n-1, 0, -1):\\n            for j in range(0, len(triangle[i])-1):\\n                triangle[i-1][j] += min(triangle[i][j], triangle[i][j+1])\\n        \\n        return triangle[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n   2\\n  3 4\\n 6 5 7\\n4 1 8 3\\n```\n```\\n   2\\n  3 4\\n 7 6 10\\n 4 1 8 3\\n```\n```\\n   2\\n  9 10\\n 7 6 10\\n 4 1 8 3\\n```\n```\\n   11\\n  9 10\\n 7 6 10\\n 4 1 8 3\\n```\n```\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        n = len(triangle)\\n\\t\\t\\n        for i in range(n-1, 0, -1):\\n            for j in range(0, len(triangle[i])-1):\\n                triangle[i-1][j] += min(triangle[i][j], triangle[i][j+1])\\n        \\n        return triangle[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2145142,
                "title": "python-easy-4-lines-two-approaches",
                "content": "\\n**Time - O(n * n)\\nSpace - O(n * n)**\\n\\n## \\u2714\\uFE0F*Solution I - Memoization - Top Down*\\n```\\nclass Solution:\\n    def minimumTotal(self, a: List[List[int]]) -> int:\\n        @cache\\n        def dfs(level, i):            \\n            return 0 if level >= len(a) else a[level][i] + min(dfs(level + 1, i), dfs(level + 1, i+1))        \\n        return dfs(0, 0)            \\n```\\n\\n## \\u2714\\uFE0F*Solution I I - Tabulation - Bottom Up*\\n```\\nclass Solution:\\n    def minimumTotal(self, a: List[List[int]]) -> int:\\n        n=len(a)\\n        dp=[[0] * (n+1) for _ in range(n+1)]\\n        for level in range(n-1,-1,-1):\\n            for i in range(level+1):\\n                dp[level][i]=a[level][i] + min(dp[level+1][i], dp[level+1][i+1])\\n        return dp[0][0]            \\n```\\n\\n**Note**: The solution should also work with BFS technically. I tried with BFS but got a memory limit exceeded issue on leetcode.\\n\\n---\\n\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotal(self, a: List[List[int]]) -> int:\\n        @cache\\n        def dfs(level, i):            \\n            return 0 if level >= len(a) else a[level][i] + min(dfs(level + 1, i), dfs(level + 1, i+1))        \\n        return dfs(0, 0)            \\n```\n```\\nclass Solution:\\n    def minimumTotal(self, a: List[List[int]]) -> int:\\n        n=len(a)\\n        dp=[[0] * (n+1) for _ in range(n+1)]\\n        for level in range(n-1,-1,-1):\\n            for i in range(level+1):\\n                dp[level][i]=a[level][i] + min(dp[level+1][i], dp[level+1][i+1])\\n        return dp[0][0]            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 38857,
                "title": "1-ms-java-dp-solution-beats-99-91-o-n-extra-space-without-modifying-the-triangle",
                "content": "The idea is to storage the min path sum so far at current level in the array dp[] of max length triangle.size(), then deduce the array values at the next level. When it reaches the triangle.size(), return the minimum of the dp[] array.\\n\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n\\t\\t\\tif (triangle.size() == 0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif (triangle.size() == 1)\\n\\t\\t\\t\\treturn triangle.get(0).get(0);\\n\\n\\t\\t\\tint[] dp = new int[triangle.size()];\\n\\t\\t\\tdp[0] = triangle.get(0).get(0);\\n\\t\\t\\treturn minimumTotal(triangle, dp, 1);\\n\\t\\t}\\n\\n\\t\\tpublic int minimumTotal(List<List<Integer>> triangle, int[] dp, int lvlidx) {\\n\\t\\t\\t/**\\n\\t\\t\\t * dp: dp[i]_lvlidx = the min path sum up to current level and up to\\n\\t\\t\\t * index i\\n\\t\\t\\t * \\n\\t\\t\\t * dp[0]_lvlidx = this_level_list[0] + dp[0]_(lvlidx-1);\\n\\t\\t\\t * dp[end]_lvlidx = this_level_list[end] + dp[end-1]_(lvlidx-1);\\n\\t\\t\\t * \\n\\t\\t\\t * dp[i]_lvlidx = this_level_list[i] + min{ dp[i-1]_(lvlidx-1),\\n\\t\\t\\t * dp[i]_(lvlidx-1) };\\n\\t\\t\\t */\\n\\n\\t\\t\\tList<Integer> list = triangle.get(lvlidx);\\n\\t\\t\\tint pre = dp[0], temp;\\n\\t\\t\\tdp[0] += list.get(0);\\n\\t\\t\\tfor (int i = 1; i < lvlidx; i++) {\\n\\t\\t\\t\\ttemp = dp[i];\\n\\t\\t\\t\\tdp[i] = list.get(i) + Math.min(pre, dp[i]);\\n\\t\\t\\t\\tpre = temp;\\n\\t\\t\\t}\\n\\t\\t\\tdp[lvlidx] = pre + list.get(lvlidx);\\n\\n\\t\\t\\tif (lvlidx + 1 == triangle.size()) {\\n\\t\\t\\t\\tint res = dp[0];\\n\\t\\t\\t\\tfor (int i = 1; i <= lvlidx; i++)\\n\\t\\t\\t\\t\\tres = Math.min(res, dp[i]);\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn minimumTotal(triangle, dp, lvlidx + 1);\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "The idea is to storage the min path sum so far at current level in the array dp[] of max length triangle.size(), then deduce the array values at the next level. When it reaches the triangle.size(), return the minimum of the dp[] array.\\n\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n\\t\\t\\tif (triangle.size() == 0)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tif (triangle.size() == 1)\\n\\t\\t\\t\\treturn triangle.get(0).get(0);\\n\\n\\t\\t\\tint[] dp = new int[triangle.size()];\\n\\t\\t\\tdp[0] = triangle.get(0).get(0);\\n\\t\\t\\treturn minimumTotal(triangle, dp, 1);\\n\\t\\t}\\n\\n\\t\\tpublic int minimumTotal(List<List<Integer>> triangle, int[] dp, int lvlidx) {\\n\\t\\t\\t/**\\n\\t\\t\\t * dp: dp[i]_lvlidx = the min path sum up to current level and up to\\n\\t\\t\\t * index i\\n\\t\\t\\t * \\n\\t\\t\\t * dp[0]_lvlidx = this_level_list[0] + dp[0]_(lvlidx-1);\\n\\t\\t\\t * dp[end]_lvlidx = this_level_list[end] + dp[end-1]_(lvlidx-1);\\n\\t\\t\\t * \\n\\t\\t\\t * dp[i]_lvlidx = this_level_list[i] + min{ dp[i-1]_(lvlidx-1),\\n\\t\\t\\t * dp[i]_(lvlidx-1) };\\n\\t\\t\\t */\\n\\n\\t\\t\\tList<Integer> list = triangle.get(lvlidx);\\n\\t\\t\\tint pre = dp[0], temp;\\n\\t\\t\\tdp[0] += list.get(0);\\n\\t\\t\\tfor (int i = 1; i < lvlidx; i++) {\\n\\t\\t\\t\\ttemp = dp[i];\\n\\t\\t\\t\\tdp[i] = list.get(i) + Math.min(pre, dp[i]);\\n\\t\\t\\t\\tpre = temp;\\n\\t\\t\\t}\\n\\t\\t\\tdp[lvlidx] = pre + list.get(lvlidx);\\n\\n\\t\\t\\tif (lvlidx + 1 == triangle.size()) {\\n\\t\\t\\t\\tint res = dp[0];\\n\\t\\t\\t\\tfor (int i = 1; i <= lvlidx; i++)\\n\\t\\t\\t\\t\\tres = Math.min(res, dp[i]);\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn minimumTotal(triangle, dp, lvlidx + 1);\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1169404,
                "title": "python-short-dp-using-lru-cache-explained",
                "content": "Let `dp(i, j)` be the answer to the question: what is the minimum length of path, ending in `i`-th line and `j`-th element of this line. Then we can have two options:\\n\\n1. If we reached the last line, we do not have options to go next, so we just return `triangle[i][j]`.\\n2. If we did not reached the last line, we can go either to `(i + 1, j)` or to `(i +1, j + 1)`, so we choose the minumum of two this values.\\n\\n#### Complexity\\nTime and space complexity is `O(n^2)`, because we have this number of states and only 2 transactions from one state. Note, that space complexity can be reduced to `O(n)`, because in fact we need only last line, or it can be even reduced to `O(1)` if we allowed to change original triangle.\\n\\n#### Code\\n```\\nclass Solution:\\n    def minimumTotal(self, triangle):\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == len(triangle) - 1: return triangle[i][j]\\n            return min(dp(i+1, j), dp(i+1, j+1)) + triangle[i][j]\\n        \\n        return dp(0, 0)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotal(self, triangle):\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == len(triangle) - 1: return triangle[i][j]\\n            return min(dp(i+1, j), dp(i+1, j+1)) + triangle[i][j]\\n        \\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169356,
                "title": "triangle-js-python-java-c-simple-o-1-space-in-place-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to find the best path from the top of the input triangle array (**T**) to the bottom, we should be able to find the best path to any intermediate spot along that path, as well. That should immediately bring to mind a **dynamic programming** (**DP**) solution, as we can divide this solution up into smaller pieces and then build those up to our eventual solution.\\n\\nThe naive idea here might be to do a **bottom-up** DP approach (which is actually from the start of the path, or the top of **T**, to the end of the path, or the bottom of **T**), since that reflects the normal path progression and branching. If we do this, however, we\\'ll need to write extra code to avoid going out-of-bounds when checking the previously completed rows of the DP array. We\\'ll also have to then check the entire bottom row of our DP array to find the best value.\\n\\nIf we use a **top-down** DP approach (visually bottom to top of **T**), however, we can avoid having to check for out-of-bounds conditions, as we\\'ll be going from larger rows to smaller rows. Also, we won\\'t need to search for the best solution, because it will automatically be isolated in **T[0][0]**.\\n\\nFurthermore, since we\\'ll never need to backtrack to previous rows, we can use **T** as its own **in-place** DP array, updating the values as we go, in order to achieve a **space complexity** of **O(1)** extra space.\\n\\nIn order to accomplish this, we\\'ll just need to iterate backwards through the rows, starting from the second to the last, and figure out what the best path to the bottom would be from each location in the row. Since the values in the row below will already represent the best path from that point, we can just add the lower of the two possible branches to the current location (**T[i][j]**) at each iteration.\\n\\nOnce we\\'re done, we can simply **return T[0][0]**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Java, using an **in-place DP** approach, while saving on **space complexity**, is significantly less performant than using an **O(N)** DP array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.8MB** (beats 98% / 93%).\\n```javascript\\nvar minimumTotal = function(T) {\\n    for (let i = T.length - 2; ~i; i--) \\n        for (let j = T[i].length - 1; ~j; j--) \\n            T[i][j] += Math.min(T[i+1][j], T[i+1][j+1])\\n    return T[0][0]\\n}\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **48ms / 14.9MB** (beats 99% / 85%).\\n```python\\nclass Solution:\\n    def minimumTotal(self, T: List[List[int]]) -> int:\\n        for i in range(len(T)-2,-1,-1):\\n            for j in range(len(T[i])-1,-1,-1):\\n                T[i][j] += min(T[i+1][j], T[i+1][j+1])\\n        return T[0][0]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **4ms / 38.6MB** (beats 32% / 96%).\\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> T) {\\n        for (int i = T.size() - 2; i >= 0; i--) \\n            for (int j = T.get(i).size() - 1; j >= 0; j--) {\\n                int min = Math.min(T.get(i+1).get(j), T.get(i+1).get(j+1));\\n                T.get(i).set(j, T.get(i).get(j) + min);\\n            }\\n        return T.get(0).get(0);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 8.3MB** (beats 100% / 94%).\\n```c++\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& T) {\\n        for (int i = T.size() - 2; ~i; i--) \\n            for (int j = T[i].size() - 1; ~j; j--) \\n                T[i][j] += min(T[i+1][j], T[i+1][j+1]);\\n        return T[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar minimumTotal = function(T) {\\n    for (let i = T.length - 2; ~i; i--) \\n        for (let j = T[i].length - 1; ~j; j--) \\n            T[i][j] += Math.min(T[i+1][j], T[i+1][j+1])\\n    return T[0][0]\\n}\\n```\n```python\\nclass Solution:\\n    def minimumTotal(self, T: List[List[int]]) -> int:\\n        for i in range(len(T)-2,-1,-1):\\n            for j in range(len(T[i])-1,-1,-1):\\n                T[i][j] += min(T[i+1][j], T[i+1][j+1])\\n        return T[0][0]\\n```\n```java\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> T) {\\n        for (int i = T.size() - 2; i >= 0; i--) \\n            for (int j = T.get(i).size() - 1; j >= 0; j--) {\\n                int min = Math.min(T.get(i+1).get(j), T.get(i+1).get(j+1));\\n                T.get(i).set(j, T.get(i).get(j) + min);\\n            }\\n        return T.get(0).get(0);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& T) {\\n        for (int i = T.size() - 2; ~i; i--) \\n            for (int j = T[i].size() - 1; ~j; j--) \\n                T[i][j] += min(T[i+1][j], T[i+1][j+1]);\\n        return T[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580865,
                "title": "triangle-memoization-tabulation-space-optimization-7-line-code",
                "content": "# Memoization Approach\\n\\nTime Complexity : O(N*M)\\nSpace complexity: O(N*M)+O(M)\\n\\n```\\nint solve(int i,int j,int n,vector<vector<int>>& triangle,vector<vector<int>>& dp){\\n        if(i==n-1) return triangle[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ind0=triangle[i][j]+solve(i+1,j,n,triangle,dp);\\n        int ind1=triangle[i][j]+solve(i+1,j+1,n,triangle,dp);\\n        return dp[i][j]=min(ind0,ind1);\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return solve(0,0,n,triangle,dp);\\n        \\n    }\\n```\\n\\n# Tabulation Method\\n\\nTime Complexity : O(N*M)+O(M)\\nSpace complexity: O(N*M)\\n\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        int dp[n][n];\\n        for(int j=0;j<n;j++) dp[n-1][j]=triangle[n-1][j];\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i;j>=0;j--){\\n                int ind0=triangle[i][j]+dp[i+1][j];\\n                int ind1=triangle[i][j]+dp[i+1][j+1];\\n                dp[i][j]=min(ind0,ind1);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```\\n\\n# Space Optimization\\n\\nTime Complexity : O(N*M)+O(M)\\nSpace complexity: O(N)\\n\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        vector<int> front(n,0), curr(n,0);\\n        for(int j=0; j<n; j++) front[j] = triangle[n-1][j];\\n        for(int i=n-2; i>=0; i--) {\\n            for(int j=i; j>=0; j--) {\\n               int down = triangle[i][j] + front[j];\\n               int diag = triangle[i][j] + front[j+1];\\n               curr[j] = min(down, diag);\\n             }\\n            front = curr;\\n        }\\n        return front[0];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(int i,int j,int n,vector<vector<int>>& triangle,vector<vector<int>>& dp){\\n        if(i==n-1) return triangle[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ind0=triangle[i][j]+solve(i+1,j,n,triangle,dp);\\n        int ind1=triangle[i][j]+solve(i+1,j+1,n,triangle,dp);\\n        return dp[i][j]=min(ind0,ind1);\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return solve(0,0,n,triangle,dp);\\n        \\n    }\\n```\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        int dp[n][n];\\n        for(int j=0;j<n;j++) dp[n-1][j]=triangle[n-1][j];\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i;j>=0;j--){\\n                int ind0=triangle[i][j]+dp[i+1][j];\\n                int ind1=triangle[i][j]+dp[i+1][j+1];\\n                dp[i][j]=min(ind0,ind1);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        vector<int> front(n,0), curr(n,0);\\n        for(int j=0; j<n; j++) front[j] = triangle[n-1][j];\\n        for(int i=n-2; i>=0; i--) {\\n            for(int j=i; j>=0; j--) {\\n               int down = triangle[i][j] + front[j];\\n               int diag = triangle[i][j] + front[j+1];\\n               curr[j] = min(down, diag);\\n             }\\n            front = curr;\\n        }\\n        return front[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1169296,
                "title": "c-dynamic-programming-simple-and-short-solution",
                "content": "We loop through the triangle from the bottom.\\nFor each number in the current row we loop through the next row and keep in dp the minimum.\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<int> dp(triangle.back());\\n        int n = triangle.size();\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            \\n            for (int j = 0; j < triangle[i].size(); j++)\\n                \\n                dp[j] = triangle[i][j] + min(dp[j], dp[j+1]);\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<int> dp(triangle.back());\\n        int n = triangle.size();\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            \\n            for (int j = 0; j < triangle[i].size(); j++)\\n                \\n                dp[j] = triangle[i][j] + min(dp[j], dp[j+1]);\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38943,
                "title": "my-c-code-bottom-up-dp-8ms",
                "content": "Just do bottom up DP, it is easier and cleaner than top-down DP.\\n\\n    class Solution {\\n    \\n        public:\\n            int minimumTotal(vector<vector<int>>& triangle) {\\n                for(int i= triangle.size()-2; i>=0; --i)\\n                    for(int j=0; j<triangle[i].size();++j)\\n                        triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]);\\n                return triangle[0][0];        \\n            }\\n        };\\n\\n// another version, without modifying the input array\\n\\n    class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int>>& triangle) {\\n            vector<int> res(triangle[triangle.size()-1]);\\n            for(int i= triangle.size()-2; i>=0; --i)\\n                for(int j=0; j<triangle[i].size();++j)\\n                    res[j] = triangle[i][j] + min(res[j],res[j+1]);\\n            return res[0];        \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n        public:\\n            int minimumTotal(vector<vector<int>>& triangle) {\\n                for(int i= triangle.size()-2; i>=0; --i)\\n                    for(int j=0; j<triangle[i].size();++j)\\n                        triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]);\\n                return triangle[0][0];        \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2144983,
                "title": "dp-4ms-3-line-logic-only",
                "content": "\\n\\n\\n\\n``` \\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n       int n = triangle.size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j< triangle[i].size();j++){\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n       int n = triangle.size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j< triangle[i].size();j++){\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932143,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func minimumTotal(_ triangle: [[Int]]) -> Int {\\n\\t\\tvar paths: [Int] = Array(repeating: Int.max, count: triangle.count)\\n        var minimum = Int.max\\n        \\n        paths[0] = triangle[0][0]\\n        for i in 0..<triangle.count {\\n\\t\\t\\tfor j in 0...i {\\n\\t\\t\\t\\tlet index = i - j\\n\\t\\t\\t\\tlet path = index > 0 ? min(paths[index], paths[index - 1]) : paths[index]\\n\\t\\t\\t\\tlet current = i > 0 ? triangle[i][index] : 0\\n\\t\\t\\t\\tpaths[index] = current + path\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tfor path in paths { minimum = minimum < path ? minimum : path }\\n        return minimum\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumTotal(_ triangle: [[Int]]) -> Int {\\n\\t\\tvar paths: [Int] = Array(repeating: Int.max, count: triangle.count)\\n        var minimum = Int.max\\n        \\n        paths[0] = triangle[0][0]\\n        for i in 0..<triangle.count {\\n\\t\\t\\tfor j in 0...i {\\n\\t\\t\\t\\tlet index = i - j\\n\\t\\t\\t\\tlet path = index > 0 ? min(paths[index], paths[index - 1]) : paths[index]\\n\\t\\t\\t\\tlet current = i > 0 ? triangle[i][index] : 0\\n\\t\\t\\t\\tpaths[index] = current + path\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tfor path in paths { minimum = minimum < path ? minimum : path }\\n        return minimum\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38852,
                "title": "5-lines-c-short-and-sweet",
                "content": "    class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int>>& triangle) {\\n            for(int i=triangle.size()-2;i>=0;i--)\\n                for(int j=0;j<=i;j++)\\n                    triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);\\n            return triangle[0][0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int>>& triangle) {\\n            for(int i=triangle.size()-2;i>=0;i--)\\n                for(int j=0;j<=i;j++)\\n                    triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);\\n            return triangle[0][0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 38875,
                "title": "java-solution-using-o-n-space-without-modify-triangle",
                "content": "    public int minimumTotal(List<List<Integer>> triangle) {\\n        int len = triangle.size();\\n        int[] dp = new int[len];\\n        for(int i = len-1;i >= 0; i--){\\n            for(int j = 0; j <= i; j++){\\n                if(i == len-1) dp[j]= triangle.get(i).get(j);\\n                else{\\n                    dp[j] = Math.min(dp[j],dp[j+1])+triangle.get(i).get(j);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    public int minimumTotal(List<List<Integer>> triangle) {\\n        int len = triangle.size();\\n        int[] dp = new int[len];\\n        for(int i = len-1;i >= 0; i--){\\n            for(int j = 0; j <= i; j++){\\n                if(i == len-1) dp[j]= triangle.get(i).get(j);\\n                else{\\n                    dp[j] = Math.min(dp[j],dp[j+1])+triangle.get(i).get(j);\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38955,
                "title": "another-accepted-java-solution",
                "content": "The idea is do a bottom up comparison.\\n\\n    public class Solution {\\n        public int minimumTotal(List<List<Integer>> triangle) {\\n            int n = triangle.size();\\n            \\n            // initialize arr with the last row\\n            int[] arr = new int[n];\\n            for (int i = 0; i < n; i++) \\n                arr[i] = triangle.get(n - 1).get(i);\\n            \\n            // bottom up comparion\\n            for (int i = n - 2; i >= 0; i--) \\n                for (int j = 0; j <= i; j++) \\n                    arr[j] = Math.min(arr[j], arr[j + 1]) + triangle.get(i).get(j);\\n            \\n            return arr[0];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minimumTotal(List<List<Integer>> triangle) {\\n            int n = triangle.size();\\n            \\n            // initialize arr with the last row\\n            int[] arr = new int[n];\\n            for (int i = 0; i < n; i++) \\n                arr[i] = triangle.get(n - 1).get(i);\\n            \\n            // bottom up comparion\\n            for (int i = n - 2; i >= 0; i--) \\n                for (int j = 0; j <= i; j++) \\n                    arr[j] = Math.min(arr[j], arr[j + 1]) + triangle.get(i).get(j);\\n            \\n            return arr[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39012,
                "title": "my-solution-without-extra-space",
                "content": "    class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int> > &triangle) {\\n            for(int i=triangle.size()-2;i>=0;i--)\\n            {\\n                for(int j=0;j<=i;j++)\\n                {\\n                    triangle[i][j]=min(triangle[i+1][j],triangle[i+1][j+1])+triangle[i][j];\\n                }\\n            }\\n            return triangle[0][0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int> > &triangle) {\\n            for(int i=triangle.size()-2;i>=0;i--)\\n            {\\n                for(int j=0;j<=i;j++)\\n                {\\n                    triangle[i][j]=min(triangle[i+1][j],triangle[i+1][j+1])+triangle[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 705169,
                "title": "java-simple-recursive-1ms",
                "content": "![image](https://assets.leetcode.com/users/images/681e4626-fdd0-4b89-9889-bee43c5d7e03_1593100247.1454384.png)\\n\\nTaking the example given in question, we can see the indices have a pattern to follow, at each level its left and right child are previous_index, previous_index+1, this can be understood in seconds once u jot it down on paper.\\n\\nFinally, you can think of it as a tree and find the path with minium value, the only important fact being that two or more nodes at the same level will encounter same children on the next node which would mean multiple computations so you can just save those results to be used again next time without going through the whole recursive process again.\\n\\nTranslated to code, it looks like this.\\n\\n```\\nclass Solution {\\n    Integer[][]c;\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        c=new Integer[triangle.size()][triangle.size()];\\n        return triangle.get(0).get(0)\\n+dfs(0,triangle,1);        \\n    }\\n    public int dfs(int index,List<List<Integer>> triangle,int level){\\n        if(level==triangle.size()) return 0;\\n        if(c[level][index]!=null) return c[level][index];\\n        int left=triangle.get(level).get(index)+dfs(index,triangle,level+1);\\n        int right=triangle.get(level).get(index+1)+dfs(index+1,triangle,level+1);\\n        return c[level][index]=Math.min(left,right);\\n    }\\n}\\n\\n```\\n\\nConverting to this into an iterative one isn\\'t much of a task with practice.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][]c;\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        c=new Integer[triangle.size()][triangle.size()];\\n        return triangle.get(0).get(0)\\n+dfs(0,triangle,1);        \\n    }\\n    public int dfs(int index,List<List<Integer>> triangle,int level){\\n        if(level==triangle.size()) return 0;\\n        if(c[level][index]!=null) return c[level][index];\\n        int left=triangle.get(level).get(index)+dfs(index,triangle,level+1);\\n        int right=triangle.get(level).get(index+1)+dfs(index+1,triangle,level+1);\\n        return c[level][index]=Math.min(left,right);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857340,
                "title": "easiest-code-c-explanation",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Traversing from the second last row and updating every element.\\n- ele += min(element_just_below, element_below\\'s_next)\\n- So the answer would be t[0][0]\\n\\n\\n# Complexity\\n- Time complexity: O(n\\xB2): worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1): We edited the same triangle, however we can create our own vector, which will store only the intermediate result. In that case SC: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    int minimumTotal(vector<vector<int>>& t) {\\n        for(int i=t.size()-2; i>=0; i--){\\n            for(int j=0; j<=i; j++){\\n                t[i][j] += min(t[i+1][j], t[i+1][j+1]);\\n            }\\n        }\\n        return t[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    int minimumTotal(vector<vector<int>>& t) {\\n        for(int i=t.size()-2; i>=0; i--){\\n            for(int j=0; j<=i; j++){\\n                t[i][j] += min(t[i+1][j], t[i+1][j+1]);\\n            }\\n        }\\n        return t[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38800,
                "title": "4-line-c-solution-using-dp-no-need-for-extra-space",
                "content": "If the triangle is allowed to be modified, then we don't need extra space. A very simple DP solution\\n\\n    class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int>>& triangle) {\\n            for(int bot = triangle.size() - 1; bot >= 0; bot--)\\n                for(int i = 0; i < triangle[bot].size() - 1; i++)\\n                    triangle[bot-1][i] += min(triangle[bot][i], triangle[bot][i+1]);\\n            return triangle[0][0];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int>>& triangle) {\\n            for(int bot = triangle.size() - 1; bot >= 0; bot--)\\n                for(int i = 0; i < triangle[bot].size() - 1; i++)\\n                    triangle[bot-1][i] += min(triangle[bot][i], triangle[bot][i+1]);\\n            return triangle[0][0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2146197,
                "title": "c-2-approaches-recursion-memoization",
                "content": "**Please Upvote If It Helps**\\n\\n**Approach 1 : Using Recursion (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int helper(int i,int j,int n,vector<vector<int>> &triangle)\\n    {\\n        // if i reached to bottom\\n        if(i==n-1)\\n            return triangle[i][j];\\n        \\n        // I can move in two directions bottom (i+1,j) or bottom right (i+1,j+1)\\n        // so try to move in both the directions with adding current cost\\n        int move1 = triangle[i][j] + helper(i+1,j,n,triangle);\\n        int move2 = triangle[i][j] + helper(i+1,j+1,n,triangle);\\n        \\n        // take min of both of them as given in the question\\n        return min(move1,move2);\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) \\n    {\\n        int n = triangle.size();\\n        return helper(0,0,n,triangle);\\n    }\\n};\\n```\\n\\n\\n**Approach 2 : Using Memoization (Submitted)**\\n```\\nclass Solution {\\npublic:\\n    int helper(int i,int j,int n,vector<vector<int>> &triangle,vector<vector<int>> &dp)\\n    {\\n        // if i reached to bottom\\n        if(i==n-1)\\n            return triangle[i][j];\\n        \\n        // if already calculated\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // I can move in two directions bottom (i+1,j) or bottom right (i+1,j+1)\\n        // so try to move in both the directions with adding current cost\\n        int move1 = triangle[i][j] + helper(i+1,j,n,triangle,dp);\\n        int move2 = triangle[i][j] + helper(i+1,j+1,n,triangle,dp);\\n        \\n        // take min of both of them as given in the question\\n        return dp[i][j] = min(move1,move2);\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) \\n    {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        \\n        return helper(0,0,n,triangle,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i,int j,int n,vector<vector<int>> &triangle)\\n    {\\n        // if i reached to bottom\\n        if(i==n-1)\\n            return triangle[i][j];\\n        \\n        // I can move in two directions bottom (i+1,j) or bottom right (i+1,j+1)\\n        // so try to move in both the directions with adding current cost\\n        int move1 = triangle[i][j] + helper(i+1,j,n,triangle);\\n        int move2 = triangle[i][j] + helper(i+1,j+1,n,triangle);\\n        \\n        // take min of both of them as given in the question\\n        return min(move1,move2);\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) \\n    {\\n        int n = triangle.size();\\n        return helper(0,0,n,triangle);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int i,int j,int n,vector<vector<int>> &triangle,vector<vector<int>> &dp)\\n    {\\n        // if i reached to bottom\\n        if(i==n-1)\\n            return triangle[i][j];\\n        \\n        // if already calculated\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // I can move in two directions bottom (i+1,j) or bottom right (i+1,j+1)\\n        // so try to move in both the directions with adding current cost\\n        int move1 = triangle[i][j] + helper(i+1,j,n,triangle,dp);\\n        int move2 = triangle[i][j] + helper(i+1,j+1,n,triangle,dp);\\n        \\n        // take min of both of them as given in the question\\n        return dp[i][j] = min(move1,move2);\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) \\n    {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        \\n        return helper(0,0,n,triangle,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145060,
                "title": "explained-java-solution-without-extra-space-bottom-up-approach",
                "content": "let the given triangle be - \\n<img src=\"https://assets.leetcode.com/users/images/5eb3b4f0-4087-4170-a887-e64e5ae9a95e_1655084796.5711522.png\" height = 400>\\n\\n\\nthere may be two case either go from top or from bottom. we can use recursive approach in the top by deciding whether we should take the jth element or j+1 element in the i+1 row . this will create the whole tree structure of triangle and then we will return the min element at the end. we can keep on adding all the min sum which will be the answer.(time limit is exceeding in this case).\\n\\nif we go from bottom approach we can do using for loops, the idea is **For any ith row, we will start traversing each jth element and we will add current jth element with minimum value of j and j+1 element of (i+1) row.**\\nNote - since we need to consider the row below it, we are going to start from second last row.\\n<img src =\"https://assets.leetcode.com/users/images/5e3222a5-93f7-495b-ad06-714464d8e94f_1655085200.5484922.png\"  height = 400>\\n\\nHere for element -1 and -3 in the 3rd row, we will add -1 which is minimum for both.\\n<img src=\"https://assets.leetcode.com/users/images/5bf1d73f-c718-4f3d-a5a7-f6f99d02ac1f_1655085352.0941546.png\"  height = 400>\\n\\nby doing the same process the element at the top will be changed to its minimum value and that is the answer.\\n\\n<img src=\"https://assets.leetcode.com/users/images/8a7b45a3-1ae5-4a89-ac05-f2190128123f_1655085626.5691237.png\"  height = 400>\\n\\n\\n\\n**Please upvote this if you find useful**\\n### Recursive solution\\n> Time complexity - O(2^n)\\n> Space complexity - O(n)\\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        return rec(triangle,0,0);\\n    }\\n    public int rec(List<List<Integer>> arr,int index,int j){\\n        if(index==arr.size()-1) return arr.get(index).get(j);\\n        \\n        int down = arr.get(index).get(j) + rec(arr,index+1,j);\\n        int down_right = arr.get(index).get(j) + rec(arr,index+1,j+1);\\n        \\n        return Math.min(down,down_right);\\n    }\\n}\\n```\\n\\n### Iterative solution\\n> Time complexity - O(n^2)\\n> Space complexity - O(1)\\n\\nCode -\\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        int n = triangle.size();\\n        for(int i = n-2 ; i >=0 ; --i){\\n            for(int j = 0 ; j < triangle.get(i).size() ; ++j){\\n                triangle.get(i).set(j, triangle.get(i).get(j)+Math.min(triangle.get(i+1).get(j), triangle.get(i+1).get(j+1)));\\n            }\\n        }\\n        return triangle.get(0).get(0);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        return rec(triangle,0,0);\\n    }\\n    public int rec(List<List<Integer>> arr,int index,int j){\\n        if(index==arr.size()-1) return arr.get(index).get(j);\\n        \\n        int down = arr.get(index).get(j) + rec(arr,index+1,j);\\n        int down_right = arr.get(index).get(j) + rec(arr,index+1,j+1);\\n        \\n        return Math.min(down,down_right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        int n = triangle.size();\\n        for(int i = n-2 ; i >=0 ; --i){\\n            for(int j = 0 ; j < triangle.get(i).size() ; ++j){\\n                triangle.get(i).set(j, triangle.get(i).get(j)+Math.min(triangle.get(i+1).get(j), triangle.get(i+1).get(j+1)));\\n            }\\n        }\\n        return triangle.get(0).get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353194,
                "title": "python-4-approaches-dp-recursive-and-iterative-dfs-dijkstra-explained-visualized",
                "content": "- This problem is very similar to **64. Minimum Path Sum** - check out link below\\n\\t- https://leetcode.com/problems/minimum-path-sum/discuss/360106/Python-or-5-Approaches-(Dijkstra-A*-DP-DFS)-explained-and-visulaized\\n\\n- The following approaches to solve the problem are presented:\\n        **1- Bottom - up, DP with tabulation \\n        2- Top - down, itertaive - dfs without memoization\\n        3- Top - down, recursive dfs with memoization\\n        4- Dijkstra/ A***\\n        \\n------------------------------------------------------------------------------------\\n# [1] bottom - up DP with tabulation | 44 ms, faster than 99.96% of Python3 \\n------------------------------------------------------------------------------------\\n![image](https://assets.leetcode.com/users/images/a19bc1df-0ba6-4c53-a6c4-3a254fd69fb7_1626883545.6432374.jpeg)\\n\\n- **Time:**\\n\\t- `O(N)` where N is the number of nodes\\n\\t- `O(R^2)` where R = number of rows\\n\\t\\t- a trinagle with R rows conatins => `R(R+1)/2` cells/nodes\\n- **Code:**\\t\\n\\t```\\n\\tdef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\t\\t\\tgrid = triangle\\n\\t\\t\\tfor i in range(1, len(grid)):\\n\\t\\t\\t\\tfor j in range(len(grid[i])):\\n\\t\\t\\t\\t\\tif j > 0 and j < len(grid[i])-1: # aka. intermendiate node\\n\\t\\t\\t\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i-1][j-1])\\n\\t\\t\\t\\t\\telif j == 0:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] += grid[i-1][j]\\n\\t\\t\\t\\t\\telif j == len(grid[i])-1:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] += grid[i-1][j-1]\\n\\t\\t\\t# print(grid)\\n\\t\\t\\treturn min(grid[-1])\\n\\t```\\n\\t\\n-**A Different way of looking at it**\\n- We divide the triangle grid into 2 main cases/regions:\\n\\n\\t- left-most column (orange)\\n\\t- Triangle part (yellow)\\n\\t\\t- Exception: The Pythagorean side of the right triangle (green)\\n\\t\\n  ![image](https://assets.leetcode.com/users/images/17eee041-0ed8-4fd2-964d-099c4d9c5f54_1638253870.2833683.png)\\n\\n\\t- left-most column : only one movement is allowed - from above (same as 64. Minimum Path Sum)\\n\\t- Triangle part (yellow) : \\n\\t\\t- The Pythagorean side of the right triangle (green) : only one movement \\n\\n\\t```\\n\\tdef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\t\\n\\t\\tgrid = triangle\\n\\t\\t# left-most column\\n\\t\\tfor i in range(1, len(grid)):\\n\\t\\t\\tgrid[i][0] += grid[i-1][0]\\n\\n\\t\\t# rest\\n\\t\\tfor i in range(1, len(grid)):\\n\\t\\t\\tfor j in range(1, len(grid[i])):\\n\\t\\t\\t\\tif j == len(grid[i])-1: # last cell in row -> only 1 move\\n\\t\\t\\t\\t\\tgrid[i][j] += grid[i-1][j-1] # from diagonal\\n\\t\\t\\t\\telse: # 2 moves min(above, diagonal)\\n\\t\\t\\t\\t\\tgrid[i][j] += min(grid[i-1][j-1], grid[i-1][j])\\n\\t\\treturn min(grid[-1])\\n\\t```\\n\\n\\t\\n------------------------------------------------------------------------------------\\n# [2] Iterative DFS without memo | TLE 42 / 43 test cases passed.\\n------------------------------------------------------------------------------------\\n![image](https://assets.leetcode.com/users/images/faa1eeb2-c8c5-428a-9fc9-1d53a6d4911c_1626883570.8056035.jpeg)\\n\\n- **Time:**\\n\\t- O(K * N) \\n\\t\\t- where N = number of nodes\\n\\t\\t- K = \\n\\t\\t\\t**lower limit** -> 1\\n\\t\\t\\t**upper limit** -> the max number of paths shared by a node\\n\\t\\t\\t\\n\\t\\t\\t![image](https://assets.leetcode.com/users/images/514c76d7-b436-40e8-b93f-f1bd558a8c14_1626883752.0781817.jpeg)\\n\\n\\n\\t\\t- number of paths = `((m-1) + (n-1)) ! / ( (m-1)! * (n-1)! )`, that is because for every node, we can choose to make one of two moves\\n\\t\\t\\t- move downward vertically\\n\\t\\t\\t- move downwards diagonllay\\n\\t\\t\\t- where m and n are num of rows and num of cols\\n\\n\\t\\thowever, these paths do not all converge into one leaf node (like in the square grid DAG*)\\n\\n\\t\\t( * ) [**For more details on square grid DAG, see my solution to***  : **797. All Paths From Source to Target**]\\n\\t\\there -> https://leetcode.com/problems/all-paths-from-source-to-target/discuss/986429/Python-Iterative-DFS-with-detailed-time-complexity-and-visuals\\n\\t\\t\\n\\t\\tSince this is a trinagular-grid DAG, the paths are shared among mutiple leaves\\n\\t\\tWe know, the number of leaves sharing more than a single path is\\n\\t\\t\\t=` the number of nodes/cells in the bottom most layer - 2` \\n\\t\\t(because we need to exclude the first and last nodes as each only relates to a single path)\\n\\n\\t\\thence\\n\\t\\tnumber of sharing leaves = `m - 2 `\\n\\t\\tfinal upper limit = `[ ((m-1) + (m-1)) ! / ( (m-1)! * (m-1)! ) - 2 ] / m - 2`\\n                \\n- **Code:**\\n\\t```        \\n\\t\\tdef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\t\\t\\t\\tgrid = triangle\\n\\t\\t\\t\\troot = (0,0)\\n\\t\\t\\t\\tminPathSum = float(\\'inf\\')\\n\\t\\t\\t\\tstack = [(root, grid[0][0])] # rot, pathSum\\n\\t\\t\\t\\tdirs = [(1,0), (1,1)] # down - vert and dia \\n\\t\\t\\t\\t# not use visited set\\n\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\tnode, pathSum = stack.pop()\\n\\t\\t\\t\\t\\tx, y = node\\n\\n\\t\\t\\t\\t\\tif x == len(grid)-1: # bottom most layer reached\\n\\t\\t\\t\\t\\t\\tminPathSum = min(minPathSum, pathSum)\\n\\n\\t\\t\\t\\t\\tfor dir in dirs:\\n\\t\\t\\t\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\n\\t\\t\\t\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[newX])-1: # within bounds - be aware than horz boundary increases as we go down\\n\\t\\t\\t\\t\\t\\t\\tstack.append(((newX, newY), pathSum + grid[newX][newY]))\\n\\n\\t\\t\\t\\treturn minPathSum\\n\\t```\\n\\t\\n------------------------------------------------------------------------------------\\n# [3] Dijkstra | 96 ms, faster than 10.98% of Python3\\n ------------------------------------------------------------------------------------\\n \\n- node values      -> serve as edge weights\\n- node coordinates -> serve as nodes\\n\\n\\t![image](https://assets.leetcode.com/users/images/33a8b141-4c52-4bec-82e8-caca44610810_1626884130.149893.jpeg)\\n\\n- apply Dijkstra -> return the minimum out of the (minCost to reach the leaves aka bottom most layer)\\n- **Run dijkstra until it finishes - no early break**\\n\\t- Unlike the rectangular grid where we had a single target/leaf (bottom-rigth corner), we have multiple leaves, hence cannot afford to have an early eixt condition and we must wait for Dijkstra to finish.\\n\\n- **Time:**\\n\\t- `O(E logV)` where E = edges and V = verticies\\n\\t- `V = R^2`\\n\\t- `E = V roughly `\\n\\t- `O(R^2 log R^2)` where R = number of rows\\n\\t- Or `O(N log N)` where N = number of nodes\\n\\n- **Code:**\\t\\t\\n\\t```\\n\\t\\tdef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\t\\t\\t\\th = []\\n\\t\\t\\t\\tfrom heapq import heappush, heappop\\n\\t\\t\\t\\tgrid = triangle\\n\\t\\t\\t\\tstartNode = (grid[0][0], (0,0))\\n\\t\\t\\t\\theappush(h, startNode)\\n\\t\\t\\t\\tcost_so_far = {(0,0): grid[0][0]}\\n\\t\\t\\t\\tdirs = [(1,0), (1,1)]\\n\\t\\t\\t\\twhile h:\\n\\t\\t\\t\\t\\tcost, node = heappop(h)\\n\\t\\t\\t\\t\\tx, y = node\\n\\n\\t\\t\\t\\t\\tfor dir in dirs:\\n\\t\\t\\t\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[newX])-1: # bounds\\n\\t\\t\\t\\t\\t\\t\\tedgeCost = grid[newX][newY]\\n\\t\\t\\t\\t\\t\\t\\tnewCost = cost + edgeCost\\n\\t\\t\\t\\t\\t\\t\\tif (newX, newY) not in cost_so_far or ( (newX, newY) in cost_so_far and newCost < cost_so_far[(newX, newY)] ):\\n\\t\\t\\t\\t\\t\\t\\t\\tcost_so_far[(newX, newY)] = newCost\\n\\t\\t\\t\\t\\t\\t\\t\\theappush(h, (newCost, (newX, newY) ))\\n\\n\\t\\t\\t\\t# find the least of the minCosts in the bottom most row\\n\\t\\t\\t\\tglobalMin = float(\\'inf\\')\\n\\t\\t\\t\\tfor (x,y) in cost_so_far:\\n\\t\\t\\t\\t\\tif x == len(grid)-1:\\n\\t\\t\\t\\t\\t\\tglobalMin = min(globalMin, cost_so_far[(x,y)])  \\n\\t\\t\\t\\treturn globalMin\\n\\t```  \\n\\n------------------------------------------------------------------------------------\\n# [4] recursive dfs with memoization | 68 ms, faster than 34.75% of Python3\\n------------------------------------------------------------------------------------\\n\\n- **Time:**\\n\\t-  the cost of the recursive call -> `O(1)`\\n\\t-  at each cell -> we call the recursive func once -> we have N cells where \\n\\t\\t-> `O(N)` where N = num of cells/nodes\\n\\t\\t-> `O(R*(R-1)/2) -> O(R^2)`\\n- **Code:**\\n\\n\\t```\\n\\tdef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\t\\t# helper\\n\\t\\tdef recurse(r,c):\\n\\n\\t\\t\\t# base\\n\\t\\t\\tif r == len(grid)-1:\\n\\t\\t\\t\\treturn grid[r][c] # - if at base of triangle -> return the value inside the cell\\n\\n\\t\\t\\tif c > len(grid[c])-1: # out of bounds - only horiz boun dis needed as vert bound already covered by base case (unlike rectangular grid with one leaf)\\n\\t\\t\\t\\treturn float(\\'inf\\')\\n\\n\\t\\t\\t# memo cond\\n\\t\\t\\tif (r,c) in memo:\\n\\t\\t\\t\\treturn memo[(r,c)]\\n\\n\\t\\t\\t# recursive - O(1) is the cost of the recursive call.- isolated\\n\\t\\t\\tresult = grid[r][c] + min(recurse(r+1, c), recurse(r+1, c+1))\\n\\t\\t\\tmemo[(r,c)] = result\\n\\t\\t\\treturn result\\n\\n\\t\\t# main \\n\\t\\tmemo = {}\\n\\t\\tgrid = triangle\\n\\t\\treturn recurse(0,0)\\n\\n\\n\\t\\t# ----\\n\\t\\t# Calculate time complexity \\n\\t\\t# the cost of the recursive call -> O(1)\\n\\t\\t# at each cell -> we call the recursive func once -> we have N cells where \\n\\t\\t# -> O(N) where N = num of cells/nodes\\n\\t\\t# -> O(R*(R-1)/2) -> O(R^2)\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\n\\tdef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\t\\t\\tgrid = triangle\\n\\t\\t\\tfor i in range(1, len(grid)):\\n\\t\\t\\t\\tfor j in range(len(grid[i])):\\n\\t\\t\\t\\t\\tif j > 0 and j < len(grid[i])-1: # aka. intermendiate node\\n\\t\\t\\t\\t\\t\\tgrid[i][j] += min(grid[i-1][j], grid[i-1][j-1])\\n\\t\\t\\t\\t\\telif j == 0:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] += grid[i-1][j]\\n\\t\\t\\t\\t\\telif j == len(grid[i])-1:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] += grid[i-1][j-1]\\n\\t\\t\\t# print(grid)\\n\\t\\t\\treturn min(grid[-1])\\n\\t```\n```\\n\\tdef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\t\\n\\t\\tgrid = triangle\\n\\t\\t# left-most column\\n\\t\\tfor i in range(1, len(grid)):\\n\\t\\t\\tgrid[i][0] += grid[i-1][0]\\n\\n\\t\\t# rest\\n\\t\\tfor i in range(1, len(grid)):\\n\\t\\t\\tfor j in range(1, len(grid[i])):\\n\\t\\t\\t\\tif j == len(grid[i])-1: # last cell in row -> only 1 move\\n\\t\\t\\t\\t\\tgrid[i][j] += grid[i-1][j-1] # from diagonal\\n\\t\\t\\t\\telse: # 2 moves min(above, diagonal)\\n\\t\\t\\t\\t\\tgrid[i][j] += min(grid[i-1][j-1], grid[i-1][j])\\n\\t\\treturn min(grid[-1])\\n\\t```\n```        \\n\\t\\tdef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\t\\t\\t\\tgrid = triangle\\n\\t\\t\\t\\troot = (0,0)\\n\\t\\t\\t\\tminPathSum = float(\\'inf\\')\\n\\t\\t\\t\\tstack = [(root, grid[0][0])] # rot, pathSum\\n\\t\\t\\t\\tdirs = [(1,0), (1,1)] # down - vert and dia \\n\\t\\t\\t\\t# not use visited set\\n\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\tnode, pathSum = stack.pop()\\n\\t\\t\\t\\t\\tx, y = node\\n\\n\\t\\t\\t\\t\\tif x == len(grid)-1: # bottom most layer reached\\n\\t\\t\\t\\t\\t\\tminPathSum = min(minPathSum, pathSum)\\n\\n\\t\\t\\t\\t\\tfor dir in dirs:\\n\\t\\t\\t\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\n\\t\\t\\t\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[newX])-1: # within bounds - be aware than horz boundary increases as we go down\\n\\t\\t\\t\\t\\t\\t\\tstack.append(((newX, newY), pathSum + grid[newX][newY]))\\n\\n\\t\\t\\t\\treturn minPathSum\\n\\t```\n```\\n\\t\\tdef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\t\\t\\t\\th = []\\n\\t\\t\\t\\tfrom heapq import heappush, heappop\\n\\t\\t\\t\\tgrid = triangle\\n\\t\\t\\t\\tstartNode = (grid[0][0], (0,0))\\n\\t\\t\\t\\theappush(h, startNode)\\n\\t\\t\\t\\tcost_so_far = {(0,0): grid[0][0]}\\n\\t\\t\\t\\tdirs = [(1,0), (1,1)]\\n\\t\\t\\t\\twhile h:\\n\\t\\t\\t\\t\\tcost, node = heappop(h)\\n\\t\\t\\t\\t\\tx, y = node\\n\\n\\t\\t\\t\\t\\tfor dir in dirs:\\n\\t\\t\\t\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t\\t\\t\\tif newX <= len(grid)-1 and newY <= len(grid[newX])-1: # bounds\\n\\t\\t\\t\\t\\t\\t\\tedgeCost = grid[newX][newY]\\n\\t\\t\\t\\t\\t\\t\\tnewCost = cost + edgeCost\\n\\t\\t\\t\\t\\t\\t\\tif (newX, newY) not in cost_so_far or ( (newX, newY) in cost_so_far and newCost < cost_so_far[(newX, newY)] ):\\n\\t\\t\\t\\t\\t\\t\\t\\tcost_so_far[(newX, newY)] = newCost\\n\\t\\t\\t\\t\\t\\t\\t\\theappush(h, (newCost, (newX, newY) ))\\n\\n\\t\\t\\t\\t# find the least of the minCosts in the bottom most row\\n\\t\\t\\t\\tglobalMin = float(\\'inf\\')\\n\\t\\t\\t\\tfor (x,y) in cost_so_far:\\n\\t\\t\\t\\t\\tif x == len(grid)-1:\\n\\t\\t\\t\\t\\t\\tglobalMin = min(globalMin, cost_so_far[(x,y)])  \\n\\t\\t\\t\\treturn globalMin\\n\\t```\n```\\n\\tdef minimumTotal(self, triangle: List[List[int]]) -> int:\\n\\t\\t# helper\\n\\t\\tdef recurse(r,c):\\n\\n\\t\\t\\t# base\\n\\t\\t\\tif r == len(grid)-1:\\n\\t\\t\\t\\treturn grid[r][c] # - if at base of triangle -> return the value inside the cell\\n\\n\\t\\t\\tif c > len(grid[c])-1: # out of bounds - only horiz boun dis needed as vert bound already covered by base case (unlike rectangular grid with one leaf)\\n\\t\\t\\t\\treturn float(\\'inf\\')\\n\\n\\t\\t\\t# memo cond\\n\\t\\t\\tif (r,c) in memo:\\n\\t\\t\\t\\treturn memo[(r,c)]\\n\\n\\t\\t\\t# recursive - O(1) is the cost of the recursive call.- isolated\\n\\t\\t\\tresult = grid[r][c] + min(recurse(r+1, c), recurse(r+1, c+1))\\n\\t\\t\\tmemo[(r,c)] = result\\n\\t\\t\\treturn result\\n\\n\\t\\t# main \\n\\t\\tmemo = {}\\n\\t\\tgrid = triangle\\n\\t\\treturn recurse(0,0)\\n\\n\\n\\t\\t# ----\\n\\t\\t# Calculate time complexity \\n\\t\\t# the cost of the recursive call -> O(1)\\n\\t\\t# at each cell -> we call the recursive func once -> we have N cells where \\n\\t\\t# -> O(N) where N = num of cells/nodes\\n\\t\\t# -> O(R*(R-1)/2) -> O(R^2)\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 828852,
                "title": "python-dfs-dfs-memo-dp-1-dp-2-last-solution-o-1-extra-space",
                "content": "As I\\'m getting used to dynamic programming problems, I realize it\\'s helpful starting always with a *simple* DFS solution, then think about memoization, and then go for the DP table if you feel comfortable. I\\'m learning.\\n\\nFor this reason I want to share my approach to this problem, step by step, and it\\'s evolution process. Let\\'s start by solving the case in which we don\\'t have anything in the triangle and declaring the initial code structure.\\n\\n```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        if not triangle:\\n            return 0\\n\\n        return dfs(triangle, 0, 0)\\n        # return dfsmemo(triangle, 0, 0)\\n        # return dyn(triangle)\\n        # return propagation(triangle)\\n```\\n\\n**Simple DFS**\\n\\nThe last recursive instances stop when they are at the last row. Just check whatever is minimum in the backtracking and sum it\\'s own value. \\n\\n```python\\ndef dfs(triangle, r, c):\\n    if r == len(triangle)-1:\\n        return triangle[r][c]\\n    return triangle[r][c] + min(\\n        dfs(triangle, r+1, c),\\n        dfs(triangle, r+1, c+1)\\n    )\\n```\\n\\nWe can see some patterns here. So after this we should think about some memoization technique. The minimum value from `triangle[row][column]` onwards is alwais going to be the same, that\\'s what we have to think about.\\n\\n**DFS + MEMO**\\n\\nIn this case we will use a dictionary for this memo, with coordinate tuples as keys, and minimum value starting from that point in the triangle.\\n\\n```python\\ndef dfsmemo(triangle, r, c, memo={}):\\n    if r == len(triangle)-1:\\n        return triangle[r][c]\\n    if (r, c) not in memo:\\n        memo[(r, c)] = triangle[r][c] + min(\\n            dfs(triangle, r+1, c, memo),\\n            dfs(triangle, r+1, c+1, memo)\\n        )\\n    return memo[(r, c)]\\n```\\n\\nThat\\'s cool. Now we won\\'t have to compute recursive call when the DFS comes to a value that already saw. As long as we see that the memoization is being resolved in the **backtracking** process (after the recursive calls), we can next think about and iterative solution, filling the table from **behind** (from last to first rows in the triangle).\\n\\n**DP 1**\\n\\nWe initialize our DP table (again a `dict` to save half of the memory since it\\'s a triangle) with only the last row, and start iterating from the penultimate row. The returning value is whatever is at (0, 0). \\n\\n```python\\ndef dyn(triangle):\\n    dp = {(len(triangle)-1, c): triangle[-1][c] for c in range(len(triangle[-1]))}\\n    for r in range(len(triangle)-2, -1, -1):\\n        for c in range(len(triangle[r])):\\n            dp[(r, c)] = triangle[r][c] + min(\\n                dp[(r+1, c)],\\n                dp[(r+1, c+1)]\\n            )\\n    return dp[(0, 0)]\\n```\\n\\nWait, wait, we are filling one element in the dict for every element in the triangle, right? We can improve this by using the triangle itself in this specific case.\\n\\n**DP 2**\\n\\nBy using the triangle, we don\\'t need any extra space. We just need to modify the values starting from the penultimate row.\\n\\n```python\\ndef propagation(triangle):\\n    for r in range(len(triangle)-2, -1, -1):\\n        for c in range(len(triangle[r])):\\n            triangle[r][c] += min(\\n                triangle[r+1][c],\\n                triangle[r+1][c+1]\\n            )\\n    return triangle[0][0]\\n```\\n\\nAnd I\\'m firmly convinced that this, guys, is the way we should learn to approach DP problems. I\\'m taking baby steps, super stuck with this matter. Observing DP problems from this perspective is helping me a lot. I hope it helps you too.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        if not triangle:\\n            return 0\\n\\n        return dfs(triangle, 0, 0)\\n        # return dfsmemo(triangle, 0, 0)\\n        # return dyn(triangle)\\n        # return propagation(triangle)\\n```\n```python\\ndef dfs(triangle, r, c):\\n    if r == len(triangle)-1:\\n        return triangle[r][c]\\n    return triangle[r][c] + min(\\n        dfs(triangle, r+1, c),\\n        dfs(triangle, r+1, c+1)\\n    )\\n```\n```python\\ndef dfsmemo(triangle, r, c, memo={}):\\n    if r == len(triangle)-1:\\n        return triangle[r][c]\\n    if (r, c) not in memo:\\n        memo[(r, c)] = triangle[r][c] + min(\\n            dfs(triangle, r+1, c, memo),\\n            dfs(triangle, r+1, c+1, memo)\\n        )\\n    return memo[(r, c)]\\n```\n```python\\ndef dyn(triangle):\\n    dp = {(len(triangle)-1, c): triangle[-1][c] for c in range(len(triangle[-1]))}\\n    for r in range(len(triangle)-2, -1, -1):\\n        for c in range(len(triangle[r])):\\n            dp[(r, c)] = triangle[r][c] + min(\\n                dp[(r+1, c)],\\n                dp[(r+1, c+1)]\\n            )\\n    return dp[(0, 0)]\\n```\n```python\\ndef propagation(triangle):\\n    for r in range(len(triangle)-2, -1, -1):\\n        for c in range(len(triangle[r])):\\n            triangle[r][c] += min(\\n                triangle[r+1][c],\\n                triangle[r+1][c+1]\\n            )\\n    return triangle[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304092,
                "title": "dynamic-programming-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        list1=[0]*(len(triangle)+1)\\n        for row in triangle[::-1]:\\n            for i,v in enumerate(row):\\n                list1[i]= v + min(list1[i],list1[i+1])\\n        return list1[0]\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        list1=[0]*(len(triangle)+1)\\n        for row in triangle[::-1]:\\n            for i,v in enumerate(row):\\n                list1[i]= v + min(list1[i],list1[i+1])\\n        return list1[0]\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161377,
                "title": "python-bottom-up-84-06-runtime-92-08-memory",
                "content": "# Simple bottom up approach\\nwe see that the **TRIANGLE**  form a kind of binary **\"tree\"**\\nwith each node you\\'re capable of visiting the same position of the next level or the immediate next position in the next level\\nso our problem can be broken down into sub problems: Classic DP\\nwe start with the last row, and iterate towards the top, taking the min cost for each node as:\\n*cost of  jth node + min(min cost of jth node on next level, min cost of j+1 th node on next level)*\\n\\n```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        dp = [0]*(len(triangle)+1)\\n        \\n        for i in range (len(triangle)-1,-1,-1):\\n            curr = triangle[i]\\n            for j in range (len(triangle[i])-1,-1,-1):\\n                curr[j] = curr[j]+min(dp[j],dp[j+1])\\n            dp = curr\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        dp = [0]*(len(triangle)+1)\\n        \\n        for i in range (len(triangle)-1,-1,-1):\\n            curr = triangle[i]\\n            for j in range (len(triangle[i])-1,-1,-1):\\n                curr[j] = curr[j]+min(dp[j],dp[j+1])\\n            dp = curr\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146127,
                "title": "greedy-fails-intuition-counter-example-dynamic-programming",
                "content": "# \\uD83D\\uDCA1  Why Greedy Fails?\\n\\n\\u2714 This post aims to give intuiton on one of the most common question which might arise in reader\\'s mind that **why Greedy Approach Fails** here. \\n\\n> Another problem where greedy fails is [1770. Maximum Score from Performing Multiplication Operations](https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/). You can check it\\'s approach [here](https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/discuss/2156486/Greedy-Failed-From-Level-Zero-or-Beginner-Friendly-or-Fully-Explained-or-Python-or-C). This was asked on [Computer Science Stack Exchange](https://cs.stackexchange.com/q/151534/143377), and the [answer](https://cs.stackexchange.com/a/151551/143377) and [comments](https://cs.stackexchange.com/questions/151534/formal-proof-on-why-greedy-isnt-working-on-one-particular-problem#comment318613_151534) there suggests that \\n>> - \"To show that the greedy approach fails, all you have to do is come up with a counterexample. \" \\n>> - \"To prove that the greedy algorithm is not optimal, it suffices to give one counterexample\"\\n \\n\\nThus, we can form multiple-counter example for the same. One such-counter example is :\\n```\\n            02\\n         01    09\\n      17    16    01\\n   88   22     23    12\\n20    90    45    08    13\\n```\\n\\n\\n- \\uD83D\\uDE44 Going **Greedy** \\n2 \\u2192 1 \\u2192 16 \\u2192 22 \\u2192 45 will give **86**  \\n\\n- \\uD83D\\uDE15 But, we have another path\\n2 \\u2192 1 \\u2192 16 \\u2192 23 \\u2192 8 which will give **50**  \\n\\n- \\uD83D\\uDE0E And **optimal** is\\n2 \\u2192 9 \\u2192 1 \\u2192 12 \\u2192 8 which will ultimately give **32**\\n\\nThus, Greedy is **not optimal** in **this** problem.\\n\\n---\\n\\nGreedy Algorithmic Paradigm is `short-sighted`.   \\n\\n>Thus, We HAVE to look for every possible combination since greedy isn\\'t optimal. \\nWe should not only choose **minimum**, but should choose **minimum of available optimal paths**\\n\\n> At every step, decision should be `far-sighted`. <ins>*If we choose a path, we should know the final optimal cost it will incur, not only initial sub-cost*</ins>\\n\\n\\u2666 Looking for every possible combination, is, in general not very Efficient.  \\n\\u2666 But, this problem has certain properties.\\n\\n1. **Optimal Substructure :** To get minimum cost from Top to Bottom, we should have minimum from Middle to Bottom. Assume `a` and `b` are \\'children\\' of `p`. Once minimum paths from `a` and `b` to the bottom are known, the minimum path starting from `p` can be decided. <br><br>\\n2. **Overlapping Subproblem :** Need to compute/ponder about node 45 (assume there are further rows ahead of 45) multiple times. \\n     - 2 \\u2192 1 \\u2192 17 \\u2192 22 \\u2192 45\\n     - 2 \\u2192 1 \\u2192 16 \\u2192 22 \\u2192 45\\n     - 2 \\u2192 9 \\u2192 16 \\u2192 23 \\u2192 45\\n     - 2 \\u2192 9 \\u2192 01 \\u2192 23 \\u2192 45\\n\\nHence, **Dynamic Programming**. Choose best from all possible paths. And, instead of computing again and again, save what you have already computed.\\n\\n----\\n\\n<br>\\n\\n\\n- \\u2B06\\uFE0F If you have gained some insights, feel free to upvote. Button Below \\n- \\u2B50 Feel free to add to your Favorite Solutions by clicking on Star.\\n- \\uD83D\\uDE15 If you are confused, or have some doubts, post comments.\\n- \\uD83D\\uDCA1 Any mistake or Have another idea? Share in Comments. \\n\\n\\n----\\n\\n\\n# \\uD83E\\uDD16 \\uD835\\uDDD8\\uD835\\uDDF1\\uD835\\uDDF6\\uD835\\uDE01\\uD835\\uDE00/\\uD835\\uDDE5\\uD835\\uDDF2\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDE06\\uD835\\uDDF6\\uD835\\uDDFB\\uD835\\uDDF4 \\uD835\\uDE01\\uD835\\uDDFC \\uD835\\uDDE4\\uD835\\uDE02\\uD835\\uDDF2\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDF2\\uD835\\uDE00\\n\\nSpace for your feedback. This Section will take care of Edits and Reply to Comments/Doubts.\\n\\n---------- \\n  <br>\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n            02\\n         01    09\\n      17    16    01\\n   88   22     23    12\\n20    90    45    08    13\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2145156,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> t) {\\n        if(t.size()==1)\\n            return t.get(0).get(0);\\n        int k=t.size();\\n        int a[]=new int[k+1];\\n        for(int i=k-1;i>=0;i--)\\n        {\\n            int m=t.get(i).size();\\n            for(int j=0;j<m;j++)\\n            {\\n                a[j]=Math.min(a[j],a[j+1])+t.get(i).get(j);\\n            }\\n        }\\n        return a[0];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minimumTotal(List<List<Integer>> t) {\\n        if(t.size()==1)\\n            return t.get(0).get(0);\\n        int k=t.size();\\n        int a[]=new int[k+1];\\n        for(int i=k-1;i>=0;i--)\\n        {\\n            int m=t.get(i).size();\\n            for(int j=0;j<m;j++)\\n            {\\n                a[j]=Math.min(a[j],a[j+1])+t.get(i).get(j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1973569,
                "title": "python-o-n-time-o-1-space-in-depth-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/a6cecb4e-6b92-46bf-9d25-511f71576086_1650666283.0780942.png)\\nThis problem is much simpler once you realize that you can start from the end. This problem also illustrates how dynamic programming helps with \"pathfinding.\" The key here is that, once we\\'ve calculated a \"minimum total\" path for a given row, the \"minimum total\" row above that can be calculated, by choosing the minimum total from the below row, and adding its values to that. For example, with the following triangle:\\n[1]\\n[2,3]\\nSo when we\\'re trying to figure out the \"minimum total\" path from 1, we immediately look to 2 and 3. We choose 2, rather than 3, giving a min total of 3. Now let\\'s add another row:\\n[1]\\n[2,3]\\n[4,5,6]\\nNow we can\\'t do anything by starting at 1, because the \"2\" and \"3\" don\\'t mean very much. So we need to address them first. 2 leads to 4 and 5, so its minimum total path is *always* 6. There\\'s no world where 2 will lead to 5. We know that because 4 and 5 are the bottom row, so they\\'re already decided. Otherwise, they could lead to other paths that could make 5 the better option. With 3, we always pick 5. So now we know that any path that traverses through 2 will have 6 added to its sum to reach the end, and any path through 3 will have 8 added to it. So now our triangle can be updated to look something like this:\\n[1]\\n[6,8]\\n[4,5,6]\\nAnd *now* we can look at 1, to see which of the two paths is smallest. This is because we\\'ve examined everything below 1 to decide the optimal paths.\\n\\nWith that in mind, we can implement code that does the following:\\n* Loop backwards, starting at the second-to-bottom row\\n* For each row, look at the row below. For each int in the current row, pick one of the two available \"paths\" from the row below (which are triangle[i+1][j], and triangle[i+1][j+1]). Add whichever is less to the current int (triangle[i][j]). This is now the minimum path starting from that index.\\n* Move to the next row up, and examine those newly updated values, to determine the minimum path for every index.\\n* Continue up to the top index, triangle[0][0], and return that value.\\n\\n\\nThis is what that code looks like:\\n```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(len(triangle)-2, -1, -1):\\n            for j in range(len(triangle[i])):\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\\n        return triangle[0][0]\\n```\\nThe big optimization with this code is using the input List[List[int]] triangle *itself* as our cached memory, in our DP approach. Often Dynamic Programming problems allow you to store your information either in the input variable, or the output variable, rather than needing to create your own data-structure to keep track of everything. It makes the solution look a little less like a straightforward \"DP approach\", but then you get to have it be O(1) memory.\\nYou could technically do this in 3 lines by collapsing the inner loop to a single line, but that\\'s a readability nightmare. However I think the interpreter might parse through the code slightly quicker if it were one line. I\\'m not sure with Python, but in most languages, the interpreter/compiler typically doesn\\'t need to differentiate between what\\'s \"in\" a loop vs outside when it\\'s a 1-liner, saving precious miliseconds.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(len(triangle)-2, -1, -1):\\n            for j in range(len(triangle[i])):\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\\n        return triangle[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520400,
                "title": "python-in-place-dp-easy-to-understand-w-explanation",
                "content": "### Intuition\\n\\nWe can use the ```triangle``` array to perform our DP. This allows us to use O(1) auxillary space. Why?\\n\\n- For any given coordinate in the triangle ```(x, y)``` where ```0 <= x < len(triangle)``` and ```0 <= y < len(triangle[x])```, the minimum path sum of the path that ends up on ```(x, y)``` is given by **```triangle[x][y]``` plus the minimum path sum of the previous coordinate**.\\n- Once we compute the minimum path sum at ```(x, y)```, we **no longer require the standalone value for ```(x, y)``` to perform any calculation**. Instead, per above, we will use the minimum sum.\\n\\nWhich coordinates are considered \"previous\" to any given coordinate ```(x, y)```? Since from any ```(x, y)``` in the ```triangle``` we can move to ```(x+1, y)``` or ```(x+1, y+1)```, we can use this information in reverse: **For any given coordinate ```(x, y)```, its \"previous\" coordinates are either ```(x-1, y-1)``` or ```(x-1, y)```**.\\n\\nThus, we have the following implementation:\\n\\n- For each row in the ```triangle```, calculate the minimum sum at each element.\\n- After all computation is complete, return the minimum sum from the last row (i.e. ```min(triangle[-1])```).\\n\\n---\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(1, len(triangle)):  # for each row in triangle (skipping the first),\\n            for j in range(i+1):           # loop through each element in the row\\n                triangle[i][j] += min(triangle[i-1][j-(j==i)],  # minimum sum from coordinate (x-1, y)\\n                                      triangle[i-1][j-(j>0)])   # minimum sum from coordinate (x-1, y-1)\\n        return min(triangle[-1])  # obtain minimum sum from last row\\n```\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/5c0acf02-1aef-43fe-91e1-e84b2d67b108_1634185250.7398498.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```triangle```\n```(x, y)```\n```0 <= x < len(triangle)```\n```0 <= y < len(triangle[x])```\n```(x, y)```\n```triangle[x][y]```\n```(x, y)```\n```(x, y)```\n```(x, y)```\n```(x, y)```\n```triangle```\n```(x+1, y)```\n```(x+1, y+1)```\n```(x, y)```\n```(x-1, y-1)```\n```(x-1, y)```\n```triangle```\n```min(triangle[-1])```\n```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(1, len(triangle)):  # for each row in triangle (skipping the first),\\n            for j in range(i+1):           # loop through each element in the row\\n                triangle[i][j] += min(triangle[i-1][j-(j==i)],  # minimum sum from coordinate (x-1, y)\\n                                      triangle[i-1][j-(j>0)])   # minimum sum from coordinate (x-1, y-1)\\n        return min(triangle[-1])  # obtain minimum sum from last row\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996782,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        int m = triangle.size();\\n        int dp[m+1];\\n        for(int i = 0;i<=m;i++)\\n            dp[i] = 0;\\n        for(int i = m-1;i>=0;i--)\\n        {\\n            for(int j = 0;j<triangle[i].size();j++)\\n            {\\n                dp[j] = min(dp[j],dp[j+1]) + triangle[i][j];\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        int m = triangle.size();\\n        int dp[m+1];\\n        for(int i = 0;i<=m;i++)\\n            dp[i] = 0;\\n        for(int i = m-1;i>=0;i--)\\n        {\\n            for(int j = 0;j<triangle[i].size();j++)\\n            {\\n                dp[j] = min(dp[j],dp[j+1]) + triangle[i][j];\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709778,
                "title": "3-liner-c-dp-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n       int n = triangle.size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j< triangle[i].size();j++){\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n       int n = triangle.size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j< triangle[i].size();j++){\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38906,
                "title": "5-python-solutions-one-achieved-fastest-44-ms-in-python",
                "content": "    class Solution:\\n    # @param triangle, a list of lists of integers\\n    # @return an integer\\n\\n\\n    # this is a one liner for fun :)  Node that this creates a new triangle [::-1] was used, so unfortunately space was not k. \\n    def minimumTotal(self, triangle):\\n\\n        return reduce(lambda x, y: [min(x[b], x[b+1])+y[b] for b in xrange(len(y))], triangle[::-1], [0]*(len(triangle)+1))[0]\\n\\n\\n    # this is my original expended version of that one liner, somehow faster than that, achieved 44ms, but I guess the running time varies enough each time you submit, \\n    # so that the real difference is not significant\\n    def minimumTotalExpended(self, triangle):\\n\\n        triangle.append([0]*(len(triangle)+1))\\n        return reduce(lambda x, y: [min(x[b], x[b+1])+y[b] for b in xrange(len(y))], triangle[::-1])[0]\\n\\n\\n    # further expend, in this one, no extra triangle was created, only one line each time, so space is k.\\n    def minimumTotalDP(self, triangle):\\n        \\n        base=[0]*(len(triangle)+1)\\n        for i in xrange(len(triangle)-1, -1, -1):\\n            base=[min(base[b], base[b+1])+triangle[i][b] for b in xrange(i+1)]\\n        return base[0]\\n\\n\\n\\n    #recursive, top down, slower.  I think this is not well written, could be imporved much.\\n    def minimumTotalRecurse(self, triangle):\\n        self.triangle=triangle\\n        self.cache=dict()\\n        return self.recurse(0,0) if triangle else 0\\n\\n    def recurse(self, level, i):\\n        if (level,i) in self.cache:\\n            return self.cache[(level,i)]\\n\\n        if level==len(self.triangle)-1:\\n            return self.triangle[level][i]\\n\\n        res=self.triangle[level][i]+min(self.recurse(level+1, i), self.recurse(level+1, i+1))\\n        self.cache[(level, i)]=res\\n\\n        return res\\n\\n\\n    # DP from top down, I wrote this one when I started learning programing.  Not a good piece for sure...speed was not bad though.\\n    def minimumTotalTopDownDP(self, triangle):\\n        minSum=float('inf')\\n        if not triangle:\\n            return 0\\n        level1Sum=[triangle[0][0]]\\n        level2Sum=[]\\n        while len(triangle)>len(level1Sum):\\n            level2Sum=[triangle[len(level1Sum)][i]+min((level1Sum[i] if i < len(level1Sum) else float('inf')),(level1Sum[i-1] if i>=1 else float('inf')) ) \\\\\\n            for i in xrange(len(level1Sum)+1)]\\n            level1Sum=level2Sum\\n            level2Sum=[]",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param triangle, a list of lists of integers\\n    # @return an integer\\n\\n\\n    # this is a one liner for fun :)  Node that this creates a new triangle [::-1] was used, so unfortunately space was not k. \\n    def minimumTotal(self, triangle):\\n\\n        return reduce(lambda x, y: [min(x[b], x[b+1])+y[b] for b in xrange(len(y))], triangle[::-1], [0]*(len(triangle)+1))[0]\\n\\n\\n    # this is my original expended version of that one liner, somehow faster than that, achieved 44ms, but I guess the running time varies enough each time you submit, \\n    # so that the real difference is not significant\\n    def minimumTotalExpended(self, triangle):\\n\\n        triangle.append([0]*(len(triangle)+1))\\n        return reduce(lambda x, y: [min(x[b], x[b+1])+y[b] for b in xrange(len(y))], triangle[::-1])[0]\\n\\n\\n    # further expend, in this one, no extra triangle was created, only one line each time, so space is k.\\n    def minimumTotalDP(self, triangle):\\n        \\n        base=[0]*(len(triangle)+1)\\n        for i in xrange(len(triangle)-1, -1, -1):\\n            base=[min(base[b], base[b+1])+triangle[i][b] for b in xrange(i+1)]\\n        return base[0]\\n\\n\\n\\n    #recursive, top down, slower.  I think this is not well written, could be imporved much.\\n    def minimumTotalRecurse(self, triangle):\\n        self.triangle=triangle\\n        self.cache=dict()\\n        return self.recurse(0,0) if triangle else 0\\n\\n    def recurse(self, level, i):\\n        if (level,i) in self.cache:\\n            return self.cache[(level,i)]\\n\\n        if level==len(self.triangle)-1:\\n            return self.triangle[level][i]\\n\\n        res=self.triangle[level][i]+min(self.recurse(level+1, i), self.recurse(level+1, i+1))\\n        self.cache[(level, i)]=res\\n\\n        return res\\n\\n\\n    # DP from top down, I wrote this one when I started learning programing.  Not a good piece for sure...speed was not bad though.\\n    def minimumTotalTopDownDP(self, triangle):\\n        minSum=float('inf')\\n        if not triangle:\\n            return 0\\n        level1Sum=[triangle[0][0]]\\n        level2Sum=[]\\n        while len(triangle)>len(level1Sum):\\n            level2Sum=[triangle[len(level1Sum)][i]+min((level1Sum[i] if i < len(level1Sum) else float('inf')),(level1Sum[i-1] if i>=1 else float('inf')) ) \\\\\\n            for i in xrange(len(level1Sum)+1)]\\n            level1Sum=level2Sum\\n            level2Sum=[]",
                "codeTag": "Java"
            },
            {
                "id": 38944,
                "title": "my-4-line-python-solution-with-o-1-space",
                "content": "    class Solution:\\n        # @param triangle, a list of lists of integers\\n        # @return an integer\\n        def minimumTotal(self, triangle):\\n            for i in reversed(range(len(triangle) - 1)):\\n                for j in range(0, i + 1):\\n                    triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1])\\n            return triangle[0][0]\\n\\nIt's a bottom-up dp, and direct modify the input array instead of using an extra array",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param triangle, a list of lists of integers\\n        # @return an integer\\n        def minimumTotal(self, triangle):\\n            for i in reversed(range(len(triangle) - 1)):\\n                for j in range(0, i + 1):\\n                    triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1])\\n            return triangle[0][0]\\n\\nIt's a bottom-up dp, and direct modify the input array instead of using an extra array",
                "codeTag": "Java"
            },
            {
                "id": 3386675,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& t) {\\n        vector<vector<int>>dp;\\n        dp.push_back({t[0][0]});\\n        if(t.size()==1)\\n        return t[0][0];\\n        int mn=INT_MAX;\\n        for(int i=1;i<t.size();i++){\\n            vector<int>d;\\n            for(int j=0;j<t[i].size();j++){\\n                int g=t[i][j];\\n                if(j==0)g+=dp[i-1][j];\\n                else if(j==t[i].size()-1)g+=dp[i-1][j-1];\\n                else {\\n                    g += min(dp[i-1][j-1],dp[i-1][j]);\\n                }\\n                if(i==t.size()-1)mn=min(mn,g);\\n                d.push_back(g);\\n            }\\n            dp.push_back(d);\\n        }\\n         return mn;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/f71c5f16-b8dc-4136-afe0-766680b63e43_1680789068.5183425.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& t) {\\n        vector<vector<int>>dp;\\n        dp.push_back({t[0][0]});\\n        if(t.size()==1)\\n        return t[0][0];\\n        int mn=INT_MAX;\\n        for(int i=1;i<t.size();i++){\\n            vector<int>d;\\n            for(int j=0;j<t[i].size();j++){\\n                int g=t[i][j];\\n                if(j==0)g+=dp[i-1][j];\\n                else if(j==t[i].size()-1)g+=dp[i-1][j-1];\\n                else {\\n                    g += min(dp[i-1][j-1],dp[i-1][j]);\\n                }\\n                if(i==t.size()-1)mn=min(mn,g);\\n                d.push_back(g);\\n            }\\n            dp.push_back(d);\\n        }\\n         return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146724,
                "title": "c-use-dp-simple-explanation-through-comments-dlc-june-day-13",
                "content": "**Please upvote if it helps :)**\\n```\\nclass Solution {\\npublic:\\n    int find_path(int i, int j, int n, vector<vector<int>>& triangle, vector<vector<int>>& dp)\\n    {\\n        if(i==n-1) return triangle[i][j]; //base condition: if all rows are covered then return; \\n        \\n        if(dp[i][j] != -1) return dp[i][j]; //condition for using calculated path sum by dp\\n        \\n        //We can move in two directions bottom(i+1,j) and bottom right(i+1,j+1)\\n        //so we add current path value and move in these directions \\n        int bottom = triangle[i][j] + find_path(i+1, j, n, triangle, dp); \\n        int bottom_right = triangle[i][j] + find_path(i+1, j+1, n, triangle, dp);\\n        \\n        //store minimum path sum in dp for further use\\n        return dp[i][j] = min(bottom, bottom_right);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) \\n    {   \\n        int n = triangle.size();\\n        vector<vector<int>> dp(n, vector<int> (n,-1)); //create vector dp for storing calculated path sum\\n        return find_path(0, 0, n, triangle, dp); //return minimum path sum\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_path(int i, int j, int n, vector<vector<int>>& triangle, vector<vector<int>>& dp)\\n    {\\n        if(i==n-1) return triangle[i][j]; //base condition: if all rows are covered then return; \\n        \\n        if(dp[i][j] != -1) return dp[i][j]; //condition for using calculated path sum by dp\\n        \\n        //We can move in two directions bottom(i+1,j) and bottom right(i+1,j+1)\\n        //so we add current path value and move in these directions \\n        int bottom = triangle[i][j] + find_path(i+1, j, n, triangle, dp); \\n        int bottom_right = triangle[i][j] + find_path(i+1, j+1, n, triangle, dp);\\n        \\n        //store minimum path sum in dp for further use\\n        return dp[i][j] = min(bottom, bottom_right);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) \\n    {   \\n        int n = triangle.size();\\n        vector<vector<int>> dp(n, vector<int> (n,-1)); //create vector dp for storing calculated path sum\\n        return find_path(0, 0, n, triangle, dp); //return minimum path sum\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146141,
                "title": "bottom-up-approach",
                "content": "\\'\\'\\'\\n\\n    int minTotal(vector<vector<int>>& triangle) {\\n        int len = triangle.size();\\n\\t\\tvector<int>nxt=triangle[len-1];\\n\\t\\tfor(int i = len-2; i >= 0; i--) {\\n\\t\\t\\tfor(int j = 0; j <=i; j++) {\\n                nxt[j] = triangle[i][j] + min(nxt[j],nxt[j+1]);  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nxt[0];\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\n\\n    int minTotal(vector<vector<int>>& triangle) {\\n        int len = triangle.size();\\n\\t\\tvector<int>nxt=triangle[len-1];\\n\\t\\tfor(int i = len-2; i >= 0; i--) {\\n\\t\\t\\tfor(int j = 0; j <=i; j++) {\\n                nxt[j] = triangle[i][j] + min(nxt[j],nxt[j+1]);  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nxt[0];\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2145415,
                "title": "daily-leetcoding-challenge-june-day-13-c-bottom-up-not-modifying-original-matrix",
                "content": "We can call this solution true O(n) beacuse it does not modifiy the original matrix that has been provided in the solution \\n\\nplease upvote if you agree.\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {  \\n        //Time complexity O(n^2) and space complexity is O(n) \\n        \\n        int n=triangle.size();\\n        vector<int> store=triangle[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<triangle[i].size();j++){\\n                store[j]=triangle[i][j]+min(store[j],store[j+1]);\\n            }\\n        }\\n        return store[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {  \\n        //Time complexity O(n^2) and space complexity is O(n) \\n        \\n        int n=triangle.size();\\n        vector<int> store=triangle[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<triangle[i].size();j++){\\n                store[j]=triangle[i][j]+min(store[j],store[j+1]);\\n            }\\n        }\\n        return store[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144956,
                "title": "c-in-place-top-down-dynamic-programming",
                "content": "**Please upvote the post if you like it :)**\\n\\n***Solution - (In-Place Top-Down Dynamic Programming)***\\n**Intuition :**\\nSo we basically we chose to start from `bottom-level` of triangle and move all the way to the `top-level. `\\nThis indicates use of a technique known as `DP` (`Dynamic Programming`)\\n\\nAs given, at every cell of the triangle, we could have moved here from the below level in 2 ways, either from -\\n\\n* The same index `i` in below row, or\\n* the index `i+1.`\\n\\nAnd finally, we choose the `minimum` of these two to arrive at the optimal solution & at last, we will reach at `triangle[0][0]`, which will hold the optimal (minimum) sum of path.\\n\\n****\\n**C++**\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\t// we are starting from level 1 till the bottom-most level. \\n\\t// & each time we determine the best path to arrive at current cell\\n\\tfor(int level = 1; level < size(triangle); level++) \\n\\t\\tfor(int i = 0; i <= level; i++)  \\n\\t\\t\\t// for the current level \\n\\t\\t\\t// we can either come from previous level and same index\\n\\t\\t\\t// or the previous level and index-1\\n\\t\\t\\ttriangle[level][i] += min(triangle[level - 1][min(i, (int)size(triangle[level - 1]) - 1)], triangle[level - 1][max(i - 1, 0)]); \\n\\t// finally return the last element of the bottom level\\n\\treturn *min_element(begin(triangle.back()), end(triangle.back())); \\n}\\n```\\n****\\n**`Time Complexity : O(N^2)`**\\n**`Space Complexity : O(1)`**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n\\t// we are starting from level 1 till the bottom-most level. \\n\\t// & each time we determine the best path to arrive at current cell\\n\\tfor(int level = 1; level < size(triangle); level++) \\n\\t\\tfor(int i = 0; i <= level; i++)  \\n\\t\\t\\t// for the current level \\n\\t\\t\\t// we can either come from previous level and same index\\n\\t\\t\\t// or the previous level and index-1\\n\\t\\t\\ttriangle[level][i] += min(triangle[level - 1][min(i, (int)size(triangle[level - 1]) - 1)], triangle[level - 1][max(i - 1, 0)]); \\n\\t// finally return the last element of the bottom level\\n\\treturn *min_element(begin(triangle.back()), end(triangle.back())); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869148,
                "title": "c-easy-and-concise-solution-faster-than-98",
                "content": "class Solution {\\npublic:int dp[201][201];\\n int solve(vector<vector< int>>& triangle, int i, int j){\\nif(i>=triangle.size())      \\nreturn 0;\\nif(dp[i][j]!=-1)       \\nreturn dp[i][j];\\nreturn dp[i][j]=triangle[i][j]   +   min(solve(triangle,i+1,j),solve(triangle,i+1,j+1));    \\n}\\nint minimumTotal(vector<vector< int>>& triangle) {\\nmemset(dp,-1,sizeof(dp));\\nreturn solve(triangle,0,0);       \\n}};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:int dp[201][201];\\n int solve(vector<vector< int>>& triangle, int i, int j){\\nif(i>=triangle.size())      \\nreturn 0;\\nif(dp[i][j]!=-1)       \\nreturn dp[i][j];\\nreturn dp[i][j]=triangle[i][j]   +   min(solve(triangle,i+1,j),solve(triangle,i+1,j+1));    \\n}",
                "codeTag": "Java"
            },
            {
                "id": 1766431,
                "title": "c-memoization-tabulation",
                "content": "**1. Memoization**\\n```\\nint path(int rows, int ele, vector<vector<int>>& triangle, vector<vector<int>>& dp) {\\n        if(rows == triangle.size() - 1)\\n            return triangle[rows][ele];\\n        if(dp[rows][ele] != -1)\\n            return dp[rows][ele];\\n        \\n        int down = path(rows + 1, ele, triangle, dp);\\n        int diaDown = path(rows + 1, ele + 1, triangle, dp);\\n        \\n        return dp[rows][ele] = triangle[rows][ele] + min(down, diaDown);\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        if(triangle.size() == 1) return triangle[0][0];\\n        int rows = triangle.size();\\n        vector<vector<int>> dp(rows, vector<int> (rows, -1));\\n        return path(0, 0, triangle, dp);\\n    }\\n```\\n\\n**2. Tabulation**\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n    if(triangle.size() == 1) return triangle[0][0];\\n    \\n    int rows = triangle.size();\\n    vector<vector<int>> dp(rows, vector<int> (rows, -1));\\n    \\n    for(int i = 0; i < rows; i++) {\\n        for(int j = 0; j < i + 1; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = triangle[i][j];\\n            else {\\n                int up = 100000, diaUp = 100000;\\n                if(j <= i - 1 && i - 1 >= 0) up = dp[i - 1][j];\\n                if(j - 1 <= i - 1 && i - 1 >= 0 && j - 1 >= 0) diaUp = dp[i - 1][j - 1];\\n                dp[i][j] = triangle[i][j] + min(up, diaUp);\\n            }\\n        }\\n    }\\n    int minPath = INT_MAX;\\n    for(auto it : dp[rows - 1])\\n        minPath = min(minPath, it);\\n    \\n    return minPath;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint path(int rows, int ele, vector<vector<int>>& triangle, vector<vector<int>>& dp) {\\n        if(rows == triangle.size() - 1)\\n            return triangle[rows][ele];\\n        if(dp[rows][ele] != -1)\\n            return dp[rows][ele];\\n        \\n        int down = path(rows + 1, ele, triangle, dp);\\n        int diaDown = path(rows + 1, ele + 1, triangle, dp);\\n        \\n        return dp[rows][ele] = triangle[rows][ele] + min(down, diaDown);\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        if(triangle.size() == 1) return triangle[0][0];\\n        int rows = triangle.size();\\n        vector<vector<int>> dp(rows, vector<int> (rows, -1));\\n        return path(0, 0, triangle, dp);\\n    }\\n```\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n    if(triangle.size() == 1) return triangle[0][0];\\n    \\n    int rows = triangle.size();\\n    vector<vector<int>> dp(rows, vector<int> (rows, -1));\\n    \\n    for(int i = 0; i < rows; i++) {\\n        for(int j = 0; j < i + 1; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = triangle[i][j];\\n            else {\\n                int up = 100000, diaUp = 100000;\\n                if(j <= i - 1 && i - 1 >= 0) up = dp[i - 1][j];\\n                if(j - 1 <= i - 1 && i - 1 >= 0 && j - 1 >= 0) diaUp = dp[i - 1][j - 1];\\n                dp[i][j] = triangle[i][j] + min(up, diaUp);\\n            }\\n        }\\n    }\\n    int minPath = INT_MAX;\\n    for(auto it : dp[rows - 1])\\n        minPath = min(minPath, it);\\n    \\n    return minPath;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1721645,
                "title": "recursion-memoization-tabulation-space-optimized-c",
                "content": "Recursion **(TLE):**\\n```\\nclass Solution {\\n    int helper(vector<vector<int>>& triangle, int i, int j){\\n      \\n        if(i == triangle.size() ){\\n            return 0 ;\\n        }\\n        \\n        return triangle[i][j] + min(helper(triangle, i+1,j), helper(triangle,i+1, j+1)) ;\\n        \\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return helper(triangle, 0, 0) ;\\n    }\\n};\\n```\\n\\nMemoization : **Top - Down**\\n```\\nclass Solution {\\n    int helper(vector<vector<int>>& triangle, int i, int j, vector<vector<int>>& dp){\\n      \\n        if(i == triangle.size() ){\\n            return 0 ;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j] ;\\n        }   \\n        \\n        return dp[i][j] = triangle[i][j] + min(helper(triangle, i+1,j, dp), helper(triangle,i+1, j+1, dp)) ;\\n        \\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) { \\n        int n = triangle.size() ;\\n        vector<vector<int>> dp(n, vector<int>(n, -1) ) ;\\n        return helper(triangle, 0, 0, dp) ;\\n    }\\n};\\n```\\n\\nTabulation **Bottom - Up**\\n```\\nclass Solution {\\n    int helper(vector<vector<int>>& triangle, int i, int j, vector<vector<int>>& dp){\\n        int n = triangle.size() ;\\n        for(int j = 0; j < n; j++ ){\\n            dp[n-1][j] = triangle[n-1][j] ; \\n        }\\n        \\n        for(int i = n-2; i >= 0; i--){\\n            for(int j = i; j >= 0; j-- ){\\n                dp[i][j] = triangle[i][j] + min(dp[i+1][j] , dp[i+1][j+1]) ;\\n            }\\n        }\\n        \\n        return dp[0][0] ;\\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) { \\n        int n = triangle.size() ;\\n        vector<vector<int>> dp(n, vector<int>(n, -1) ) ;\\n        return helper(triangle, 0, 0, dp) ;\\n    }\\n};\\n```\\n\\nTabulation : **Bottom - Up Space Optimization**\\n```\\nclass Solution {\\n    int helper(vector<vector<int>>& triangle, int i, int j){\\n         int n = triangle.size() ;\\n        vector<int> front(n, -1) , curr(n, -1) ;\\n       \\n        for(int j = 0; j < n; j++ ){\\n            front[j] = triangle[n-1][j] ; \\n        }\\n        \\n        for(int i = n-2; i >= 0; i--){\\n            for(int j = i; j >= 0; j-- ){\\n                curr[j] = triangle[i][j] + min(front[j] , front[j+1]) ;\\n            }\\n            front = curr ;\\n        }\\n        \\n        return front[0] ;\\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) { \\n        int n = triangle.size() ;\\n     \\n        return helper(triangle, 0, 0) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int helper(vector<vector<int>>& triangle, int i, int j){\\n      \\n        if(i == triangle.size() ){\\n            return 0 ;\\n        }\\n        \\n        return triangle[i][j] + min(helper(triangle, i+1,j), helper(triangle,i+1, j+1)) ;\\n        \\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return helper(triangle, 0, 0) ;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int helper(vector<vector<int>>& triangle, int i, int j, vector<vector<int>>& dp){\\n      \\n        if(i == triangle.size() ){\\n            return 0 ;\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j] ;\\n        }   \\n        \\n        return dp[i][j] = triangle[i][j] + min(helper(triangle, i+1,j, dp), helper(triangle,i+1, j+1, dp)) ;\\n        \\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) { \\n        int n = triangle.size() ;\\n        vector<vector<int>> dp(n, vector<int>(n, -1) ) ;\\n        return helper(triangle, 0, 0, dp) ;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int helper(vector<vector<int>>& triangle, int i, int j, vector<vector<int>>& dp){\\n        int n = triangle.size() ;\\n        for(int j = 0; j < n; j++ ){\\n            dp[n-1][j] = triangle[n-1][j] ; \\n        }\\n        \\n        for(int i = n-2; i >= 0; i--){\\n            for(int j = i; j >= 0; j-- ){\\n                dp[i][j] = triangle[i][j] + min(dp[i+1][j] , dp[i+1][j+1]) ;\\n            }\\n        }\\n        \\n        return dp[0][0] ;\\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) { \\n        int n = triangle.size() ;\\n        vector<vector<int>> dp(n, vector<int>(n, -1) ) ;\\n        return helper(triangle, 0, 0, dp) ;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int helper(vector<vector<int>>& triangle, int i, int j){\\n         int n = triangle.size() ;\\n        vector<int> front(n, -1) , curr(n, -1) ;\\n       \\n        for(int j = 0; j < n; j++ ){\\n            front[j] = triangle[n-1][j] ; \\n        }\\n        \\n        for(int i = n-2; i >= 0; i--){\\n            for(int j = i; j >= 0; j-- ){\\n                curr[j] = triangle[i][j] + min(front[j] , front[j+1]) ;\\n            }\\n            front = curr ;\\n        }\\n        \\n        return front[0] ;\\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) { \\n        int n = triangle.size() ;\\n     \\n        return helper(triangle, 0, 0) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334906,
                "title": "c-solution-faster-than-93-used-less-space-than-96-very-easy-solution",
                "content": "class Solution\\n{\\npublic:\\n\\n    int minimumTotal(vector<vector<int>> &triangle)\\n    {\\n        for (int i = triangle.size() - 2; i >= 0; i--)\\n        {\\n            for (int j = 0; j < triangle[i].size(); j++)\\n            {\\n                triangle[i][j] = triangle[i][j] + min(triangle[i+1][j],triangle[i+1][j+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    int minimumTotal(vector<vector<int>> &triangle)\\n    {\\n        for (int i = triangle.size() - 2; i >= 0; i--)\\n        {\\n            for (int j = 0; j < triangle[i].size(); j++)\\n            {\\n                triangle[i][j] = triangle[i][j] + min(triangle[i+1][j],triangle[i+1][j+1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1154785,
                "title": "c-dp",
                "content": "Shortest Solution using dp with no explaination.\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int k=0;k<triangle[i].size();k++){\\n                triangle[i][k]+=min(triangle[i+1][k],triangle[i+1][k+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n};\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Triangle.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int k=0;k<triangle[i].size();k++){\\n                triangle[i][k]+=min(triangle[i+1][k],triangle[i+1][k+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926253,
                "title": "c-4-solutions-w-explanations-recursion-memoization-tabulation-space-optimized",
                "content": "## \\u274C Solution I: Recursion [TLE]\\nTry all valid paths and calculate the sum. Finally, return the minimum sum.\\n\\nAt each step, we have two choices:\\n1. Move to lower-left element (i + 1 and j)\\n2. Move to lower-right element (i + 1 and j + 1)\\n\\n### Code\\n```\\nclass Solution {\\n    int solve(int row, int col, vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        if (row >= n) {\\n            return 0;\\n        }\\n        int m = triangle[row].size();\\n        if (col >= m) {\\n            return 0;\\n        }\\n        return triangle[row][col] + min(solve(row+1, col, triangle), solve(row+1, col+1, triangle));\\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return solve(0, 0, triangle);\\n    }\\n};\\n```\\n- Time complexity: `O(2\\u207F)`\\n- Space complexity: `O(n)`\\n\\n---\\n\\n## \\u2705 Solution II: Top-Down DP or Memoization [Accepted]\\nWe are doing a lot of repetitive work in the above recursive solution. We can create a `2D` matrix `DP` and store the result of each recursion call in it.\\n\\n### Code\\n```\\nclass Solution {\\n    int solve(int row, int col, vector<vector<int>>& triangle, vector<vector<int>>& dp) {\\n        int n = triangle.size();\\n        if (row >= n) {\\n            return 0;\\n        }\\n        int m = triangle[row].size();\\n        if (col >= m) {\\n            return 0;\\n        }\\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n        return dp[row][col] = triangle[row][col] + min(solve(row+1, col, triangle, dp), solve(row+1, col+1, triangle, dp));\\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n);\\n        for (int i=0; i<n; i++) {\\n            int m = triangle[i].size();\\n            for (int j=0; j<m; j++) {\\n                dp[i].push_back(-1);\\n            }\\n        }\\n        return solve(0, 0, triangle, dp);\\n    }\\n};\\n```\\n- Time complexity: `O(n\\xB2)`\\n- Space complexity: `O(n\\xB2)`\\n\\n---\\n\\n## \\u2705 Solution III(a): Bottm Up DP or Tabulation [Accepted]\\nWe can do a bottom-up traversal instead of traversing from top to bottom.\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n);\\n        for (int i=0; i<n; i++) {\\n            int m = triangle[i].size();\\n            for (int j=0; j<m; j++) {\\n                if (i == n-1) {\\n                    dp[i].push_back(triangle[i][j]);\\n                } else {\\n                    dp[i].push_back(-1);\\n                }\\n            }\\n        }\\n        for (int i=n-2; i>=0; i--) {\\n            int m = triangle[i].size();\\n            for (int j=0; j<m; j++) {\\n                dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1]);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n- Time complexity: `O(n\\xB2)`\\n- Space complexity: `O(n\\xB2)`\\n\\n---\\n\\n## \\u2705 Solution III(b): Space Optimized DP [Accepted]\\nWe only need the information about the next row. So instead of creating a `2D` matrix, `1D` matrix will do.\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<int> currRow(n, 0);\\n        vector<int> nextRow(triangle[n-1]);\\n        for (int i=n-2; i>=0; i--) {\\n            int m = triangle[i].size();\\n            for (int j=0; j<m; j++) {\\n                currRow[j] = triangle[i][j] + min(nextRow[j], nextRow[j+1]);\\n            }\\n            swap(currRow, nextRow);\\n        }\\n        swap(currRow, nextRow);\\n        return currRow[0];\\n    }\\n};\\n```\\n- Time complexity: `O(n\\xB2)`\\n- Space complexity: `O(n)`\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int row, int col, vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        if (row >= n) {\\n            return 0;\\n        }\\n        int m = triangle[row].size();\\n        if (col >= m) {\\n            return 0;\\n        }\\n        return triangle[row][col] + min(solve(row+1, col, triangle), solve(row+1, col+1, triangle));\\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return solve(0, 0, triangle);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int solve(int row, int col, vector<vector<int>>& triangle, vector<vector<int>>& dp) {\\n        int n = triangle.size();\\n        if (row >= n) {\\n            return 0;\\n        }\\n        int m = triangle[row].size();\\n        if (col >= m) {\\n            return 0;\\n        }\\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n        return dp[row][col] = triangle[row][col] + min(solve(row+1, col, triangle, dp), solve(row+1, col+1, triangle, dp));\\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n);\\n        for (int i=0; i<n; i++) {\\n            int m = triangle[i].size();\\n            for (int j=0; j<m; j++) {\\n                dp[i].push_back(-1);\\n            }\\n        }\\n        return solve(0, 0, triangle, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n);\\n        for (int i=0; i<n; i++) {\\n            int m = triangle[i].size();\\n            for (int j=0; j<m; j++) {\\n                if (i == n-1) {\\n                    dp[i].push_back(triangle[i][j]);\\n                } else {\\n                    dp[i].push_back(-1);\\n                }\\n            }\\n        }\\n        for (int i=n-2; i>=0; i--) {\\n            int m = triangle[i].size();\\n            for (int j=0; j<m; j++) {\\n                dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1]);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<int> currRow(n, 0);\\n        vector<int> nextRow(triangle[n-1]);\\n        for (int i=n-2; i>=0; i--) {\\n            int m = triangle[i].size();\\n            for (int j=0; j<m; j++) {\\n                currRow[j] = triangle[i][j] + min(nextRow[j], nextRow[j+1]);\\n            }\\n            swap(currRow, nextRow);\\n        }\\n        swap(currRow, nextRow);\\n        return currRow[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692463,
                "title": "c-solution-dp-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int m, int n, vector<vector<int>> &triangle, int &target, vector<vector<int>> &dp){\\n    if(m == target){\\n        return triangle[m][n];\\n    }\\n\\n    if(dp[m][n] != -1){\\n        return dp[m][n];\\n    }\\n\\n    int down = triangle[m][n] + solve(m+1, n, triangle, target, dp);\\n    int diagonal = triangle[m][n] + solve(m+1, n+1, triangle, target, dp);\\n\\n    return dp[m][n]=min(down, diagonal);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int target = triangle.size()-1;\\n        vector<vector<int>> dp = triangle;\\n        for(auto &i : dp){\\n            for(auto &j : i){\\n                j = -1;\\n            }\\n        }\\n        return solve(0, 0, triangle, target, dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int m, int n, vector<vector<int>> &triangle, int &target, vector<vector<int>> &dp){\\n    if(m == target){\\n        return triangle[m][n];\\n    }\\n\\n    if(dp[m][n] != -1){\\n        return dp[m][n];\\n    }\\n\\n    int down = triangle[m][n] + solve(m+1, n, triangle, target, dp);\\n    int diagonal = triangle[m][n] + solve(m+1, n+1, triangle, target, dp);\\n\\n    return dp[m][n]=min(down, diagonal);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int target = triangle.size()-1;\\n        vector<vector<int>> dp = triangle;\\n        for(auto &i : dp){\\n            for(auto &j : i){\\n                j = -1;\\n            }\\n        }\\n        return solve(0, 0, triangle, target, dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247266,
                "title": "python-solution-recursion-memoisation-tabulation-space-optimization",
                "content": "\\n# Code\\n```\\n#RECURSION\\nclass Solution1(object):\\n    def minimumTotal(self, triangle):\\n        l = len(triangle)\\n        def solve(row,idx):\\n            if row == l-1:\\n                return triangle[row][idx]\\n            return triangle[row][idx]+min(solve(row+1,idx),solve(row+1,idx+1))\\n        ans = solve(0,0)\\n        return ans\\n\\n#MEMOIZATION\\nclass Solution2(object):\\n    def minimumTotal(self, triangle):\\n        l = len(triangle)\\n        memo = [[-1 for i in range(len(triangle[j]))] for j in range(len(triangle))]\\n        #print(memo) \\n        def solve(row,idx):\\n            if row == l-1:\\n                return triangle[row][idx]\\n            if memo[row][idx] != -1:\\n                return memo[row][idx]\\n            memo[row][idx] = triangle[row][idx]+min(solve(row+1,idx),solve(row+1,idx+1))\\n            return memo[row][idx]\\n        ans = solve(0,0)\\n        return ans\\n\\n#TABULATION (Top Down)\\nclass Solution3(object):\\n    def minimumTotal(self, triangle):\\n        l = len(triangle)\\n        memo = [[-1 for i in range(len(triangle[j]))] for j in range(len(triangle))]\\n        for i in range(len(triangle)):\\n            for j in range(len(triangle[i])):\\n                if i == 0:\\n                    memo[i][j] = triangle[i][j]\\n                else:\\n                    if j<i and j-1>=0:\\n                        memo[i][j] = triangle[i][j]+min(memo[i-1][j],memo[i-1][j-1])\\n                    elif j<i:\\n                        memo[i][j] = triangle[i][j] + memo[i-1][j]\\n                    elif j-1>=0:\\n                        memo[i][j] = triangle[i][j] + memo[i-1][j-1]\\n\\n      \\n        return min(memo[-1])\\n\\n#SPACE OPTIMIZATION\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        l = len(triangle)\\n        for i in range(l-2,-1,-1):\\n            for j in range(i+1):\\n                triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1])\\n        return triangle[0][0] \\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n#RECURSION\\nclass Solution1(object):\\n    def minimumTotal(self, triangle):\\n        l = len(triangle)\\n        def solve(row,idx):\\n            if row == l-1:\\n                return triangle[row][idx]\\n            return triangle[row][idx]+min(solve(row+1,idx),solve(row+1,idx+1))\\n        ans = solve(0,0)\\n        return ans\\n\\n#MEMOIZATION\\nclass Solution2(object):\\n    def minimumTotal(self, triangle):\\n        l = len(triangle)\\n        memo = [[-1 for i in range(len(triangle[j]))] for j in range(len(triangle))]\\n        #print(memo) \\n        def solve(row,idx):\\n            if row == l-1:\\n                return triangle[row][idx]\\n            if memo[row][idx] != -1:\\n                return memo[row][idx]\\n            memo[row][idx] = triangle[row][idx]+min(solve(row+1,idx),solve(row+1,idx+1))\\n            return memo[row][idx]\\n        ans = solve(0,0)\\n        return ans\\n\\n#TABULATION (Top Down)\\nclass Solution3(object):\\n    def minimumTotal(self, triangle):\\n        l = len(triangle)\\n        memo = [[-1 for i in range(len(triangle[j]))] for j in range(len(triangle))]\\n        for i in range(len(triangle)):\\n            for j in range(len(triangle[i])):\\n                if i == 0:\\n                    memo[i][j] = triangle[i][j]\\n                else:\\n                    if j<i and j-1>=0:\\n                        memo[i][j] = triangle[i][j]+min(memo[i-1][j],memo[i-1][j-1])\\n                    elif j<i:\\n                        memo[i][j] = triangle[i][j] + memo[i-1][j]\\n                    elif j-1>=0:\\n                        memo[i][j] = triangle[i][j] + memo[i-1][j-1]\\n\\n      \\n        return min(memo[-1])\\n\\n#SPACE OPTIMIZATION\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        l = len(triangle)\\n        for i in range(l-2,-1,-1):\\n            for j in range(i+1):\\n                triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1])\\n        return triangle[0][0] \\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195775,
                "title": "with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis problem can be solved using dynamic programming. We can start at the second last row and keep adding the minimum of the two adjacent numbers from the next row. We repeat this process until we reach the top of the triangle. Finally, we return the value at the top of the triangle, which is the minimum path sum.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2), where n is the number of rows in the triangle.\\n\\n- Space complexity:\\nO(1), as we are modifying the input triangle in-place.\\n\\n# Code\\n```\\nclass Solution:\\n  def minimumTotal(self, triangle: List[List[int]]) -> int:\\n    n = len(triangle)\\n    \\n    # Start at the second last row of the triangle\\n    for i in range(n-2, -1, -1):\\n        # Iterate over each number in the current row\\n        for j in range(len(triangle[i])):\\n            # Add the minimum of the two adjacent numbers from the next row\\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\\n    \\n    # Return the value at the top of the triangle\\n    return triangle[0][0]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def minimumTotal(self, triangle: List[List[int]]) -> int:\\n    n = len(triangle)\\n    \\n    # Start at the second last row of the triangle\\n    for i in range(n-2, -1, -1):\\n        # Iterate over each number in the current row\\n        for j in range(len(triangle[i])):\\n            # Add the minimum of the two adjacent numbers from the next row\\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\\n    \\n    # Return the value at the top of the triangle\\n    return triangle[0][0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957900,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int m=triangle.size();\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                triangle[i][j]+=min(triangle[i+1][j], triangle[i+1][j+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int m=triangle.size();\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                triangle[i][j]+=min(triangle[i+1][j], triangle[i+1][j+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148897,
                "title": "c-recursive-dynamic-programming-approach",
                "content": "1. We will have the basic recursive code\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(int i, int j, int n, vector<vector<int>> &triangle){\\n        if(i==n-1)\\n            return triangle[i][j];\\n        int left = triangle[i][j]+findMin(i+1, j, n, triangle);\\n        int right = triangle[i][j]+findMin(i+1, j+1, n, triangle);\\n        return min(left, right);   \\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return findMin(0, 0, triangle.size(), triangle);\\n    }\\n};\\n```\\n\\n2. Memoized DP solution for the same\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(int i, int j, int n, vector<vector<int>> &triangle, vector<vector<int>> &mem){\\n        if(i==n-1)\\n            return triangle[i][j];\\n        if(mem[i][j]!=-1)\\n            return mem[i][j];\\n        int left = triangle[i][j]+findMin(i+1, j, n, triangle, mem);\\n        int right = triangle[i][j]+findMin(i+1, j+1, n, triangle, mem);\\n        return mem[i][j]=min(left, right);    \\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>> mem(triangle.size(), vector<int>(triangle.size(), -1));\\n        return findMin(0, 0, triangle.size(), triangle, mem);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(int i, int j, int n, vector<vector<int>> &triangle){\\n        if(i==n-1)\\n            return triangle[i][j];\\n        int left = triangle[i][j]+findMin(i+1, j, n, triangle);\\n        int right = triangle[i][j]+findMin(i+1, j+1, n, triangle);\\n        return min(left, right);   \\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return findMin(0, 0, triangle.size(), triangle);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(int i, int j, int n, vector<vector<int>> &triangle, vector<vector<int>> &mem){\\n        if(i==n-1)\\n            return triangle[i][j];\\n        if(mem[i][j]!=-1)\\n            return mem[i][j];\\n        int left = triangle[i][j]+findMin(i+1, j, n, triangle, mem);\\n        int right = triangle[i][j]+findMin(i+1, j+1, n, triangle, mem);\\n        return mem[i][j]=min(left, right);    \\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>> mem(triangle.size(), vector<int>(triangle.size(), -1));\\n        return findMin(0, 0, triangle.size(), triangle, mem);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145105,
                "title": "c-0ms-o-n-2-8-5-mb-o-1-100-98-91-dp-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& t) {\\n        for(int i=t.size()-1;i>0;--i)\\n            for(int j=0;j<i;++j)\\n                t[i-1][j]+=min(t[i][j],t[i][j+1]);\\n        return t[0][0];\\n    }\\n};\\n```\\n1.the minimum cost from top to botton = the minimum cost from botton to top\\n2.there is only two ways to arrive node (i,j) -> from (i-1)(j) or (i-1)(j+1)\\nEX:\\n5\\n2 4\\n1 5 3\\n--- --- \\n5\\n3 7\\n--- ---\\n8 #",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& t) {\\n        for(int i=t.size()-1;i>0;--i)\\n            for(int j=0;j<i;++j)\\n                t[i-1][j]+=min(t[i][j],t[i][j+1]);\\n        return t[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586171,
                "title": "best-solution-in-c-with-timeo-n-m-spaceo-1-faster-than-100-users",
                "content": "Here I am traversing through the array and I am adding the value of previous row according to pascals triangle. And when I am in last row I will maintain the least present element and will return that.**Comment down if you aren\\'t able to understand I will be glad to help you to out.**\\n\\nPlease Upvote if you like my solution so that other can also see.**Happy Coding**\\n\\n\\n**Time->O(n*m) Space O(1)**\\n\\n\\n\\n\\t int minimumTotal(vector<vector<int>>& tri) {\\n        int n = tri.size();\\n        int min=INT_MAX;\\n        if(n==1)\\n            return tri[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int m = tri[i].size();\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j==0)\\n                {\\n                    tri[i][j]+=tri[i-1][j];\\n                }\\n                else if(j==m-1)\\n                {\\n                    tri[i][j]+=tri[i-1][j-1];\\n                }\\n                else\\n                {\\n                    int a = tri[i-1][j];\\n                    int b = tri[i-1][j-1];\\n                    int c = a>b?b:a;\\n                    tri[i][j]=tri[i][j] + c;\\n                }\\n                if(i==n-1)\\n                {\\n                    if(min>tri[i][j])\\n                        min=tri[i][j];\\n                }\\n            }\\n        }\\n        return min;\\n    }",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "Here I am traversing through the array and I am adding the value of previous row according to pascals triangle. And when I am in last row I will maintain the least present element and will return that.**Comment down if you aren\\'t able to understand I will be glad to help you to out.**\\n\\nPlease Upvote if you like my solution so that other can also see.**Happy Coding**\\n\\n\\n**Time->O(n*m) Space O(1)**\\n\\n\\n\\n\\t int minimumTotal(vector<vector<int>>& tri) {\\n        int n = tri.size();\\n        int min=INT_MAX;\\n        if(n==1)\\n            return tri[0][0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int m = tri[i].size();\\n            for(int j=0;j<m;j++)\\n            {\\n                if(j==0)\\n                {\\n                    tri[i][j]+=tri[i-1][j];\\n                }\\n                else if(j==m-1)\\n                {\\n                    tri[i][j]+=tri[i-1][j-1];\\n                }\\n                else\\n                {\\n                    int a = tri[i-1][j];\\n                    int b = tri[i-1][j-1];\\n                    int c = a>b?b:a;\\n                    tri[i][j]=tri[i][j] + c;\\n                }\\n                if(i==n-1)\\n                {\\n                    if(min>tri[i][j])\\n                        min=tri[i][j];\\n                }\\n            }\\n        }\\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1389954,
                "title": "go-bottom-up-with-comments-constant-memory-beats-100-compute-and-memory",
                "content": "The idea is to go bottom-up from the bottom of the triangle.  We do this by looking starting at the 2nd to last row of the triangle and for each cell, finding the min step of the next row. Then we store that min step + cell value at the current row location.  Once we\\'re done with the row, we move up, so by the time we\\'re at the top of the triangle, we have the minimal sum stored in the [0][0] location.\\n\\n```\\nfunc minimumTotal(triangle [][]int) int {\\n    // We can take a Greedy approach starting at the bottom and storing it on the next row up\\n    \\n    // Note: r starts a len-2 because the last row is len-1 and we\\'ll be looking down one row!\\n    for r := len(triangle)-2; r>=0; r-- {\\n        for c := range triangle[r] {\\n            // figure out what\\'s the min sum for this node by looking at the possible 2 spots in the next row\\n            // ie: get the greedy min next step on the next row and add it to the current [r][c] in the triangle\\n            triangle[r][c] += min(triangle[r+1][c], triangle[r+1][c+1])\\n        }\\n    }\\n    // at this point, the min sum should be at the top \\n    return triangle[0][0]\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumTotal(triangle [][]int) int {\\n    // We can take a Greedy approach starting at the bottom and storing it on the next row up\\n    \\n    // Note: r starts a len-2 because the last row is len-1 and we\\'ll be looking down one row!\\n    for r := len(triangle)-2; r>=0; r-- {\\n        for c := range triangle[r] {\\n            // figure out what\\'s the min sum for this node by looking at the possible 2 spots in the next row\\n            // ie: get the greedy min next step on the next row and add it to the current [r][c] in the triangle\\n            triangle[r][c] += min(triangle[r+1][c], triangle[r+1][c+1])\\n        }\\n    }\\n    // at this point, the min sum should be at the top \\n    return triangle[0][0]\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1297804,
                "title": "java-0ms-solution-very-easy",
                "content": "```\\nclass Solution {\\n    int[][] dp;\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        dp = new int[triangle.size()][triangle.size()];\\n        return helper(0,0,triangle);\\n    }\\n    \\n    int helper(int r,int c,List<List<Integer>> triangle)\\n    {\\n        if(r == triangle.size())\\n            return 0;\\n        \\n        if(dp[r][c] != 0)\\n            return dp[r][c];\\n        \\n        return dp[r][c] = triangle.get(r).get(c) + Math.min(helper(r+1,c,triangle),helper(r+1,c+1,triangle));\\n        \\n    }\\n    \\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        dp = new int[triangle.size()][triangle.size()];\\n        return helper(0,0,triangle);\\n    }\\n    \\n    int helper(int r,int c,List<List<Integer>> triangle)\\n    {\\n        if(r == triangle.size())\\n            return 0;\\n        \\n        if(dp[r][c] != 0)\\n            return dp[r][c];\\n        \\n        return dp[r][c] = triangle.get(r).get(c) + Math.min(helper(r+1,c,triangle),helper(r+1,c+1,triangle));\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123995,
                "title": "c-top-down-bottom-up-with-space-optimization-in-association-with-minas528",
                "content": "**Top-Down Recursive Solution O(N*M)/2 Time & O(N*M) Space**\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int M = triangle.size();\\n        vector<vector<int>> memo(M, vector<int>(M, -1));\\n        if (M == 1) {\\n            return triangle[0][0];\\n        }\\n        return dpHelper(0, 0, triangle, memo);\\n    }\\n    \\n    int dpHelper(int r, int c, vector<vector<int>> &T, vector<vector<int>> &memo) {\\n        if (memo[r][c] != -1) {\\n            return memo[r][c];\\n        }\\n        // Base case\\n        if (r == T.size() - 2) {\\n            memo[r][c] = T[r][c] + min(T[r + 1][c], T[r + 1][c + 1]);\\n            return memo[r][c];\\n        }\\n        memo[r][c] = T[r][c] + min(dpHelper(r + 1, c, T, memo), dpHelper(r + 1, c + 1, T, memo));\\n        return memo[r][c];\\n    }\\n};\\n```\\n\\n**Bottom-Up Solution O(N*M)/2 Time & O(N) Space**\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int M = triangle.size();\\n        if (M == 1) {\\n            return triangle[0][0];\\n        }\\n        vector<int> row = triangle.back();\\n        for (int i = triangle.size() - 2; i >= 0; i--) {\\n            for (int j = 0; j < triangle[i].size(); j++) {\\n                row[j] = triangle[i][j] + min(row[j], row[j + 1]);\\n            }   \\n        }\\n        return row[0];\\n    }\\n};\\n```\\n\\n**Bottom-Up Solution O(N*M)/2 Time & O(1) Space**\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        for (int i = triangle.size() - 2; i >= 0; i--) {\\n            for (int j = 0; j < triangle[i].size(); j++) {\\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\\n            }   \\n        }\\n        return triangle[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int M = triangle.size();\\n        vector<vector<int>> memo(M, vector<int>(M, -1));\\n        if (M == 1) {\\n            return triangle[0][0];\\n        }\\n        return dpHelper(0, 0, triangle, memo);\\n    }\\n    \\n    int dpHelper(int r, int c, vector<vector<int>> &T, vector<vector<int>> &memo) {\\n        if (memo[r][c] != -1) {\\n            return memo[r][c];\\n        }\\n        // Base case\\n        if (r == T.size() - 2) {\\n            memo[r][c] = T[r][c] + min(T[r + 1][c], T[r + 1][c + 1]);\\n            return memo[r][c];\\n        }\\n        memo[r][c] = T[r][c] + min(dpHelper(r + 1, c, T, memo), dpHelper(r + 1, c + 1, T, memo));\\n        return memo[r][c];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int M = triangle.size();\\n        if (M == 1) {\\n            return triangle[0][0];\\n        }\\n        vector<int> row = triangle.back();\\n        for (int i = triangle.size() - 2; i >= 0; i--) {\\n            for (int j = 0; j < triangle[i].size(); j++) {\\n                row[j] = triangle[i][j] + min(row[j], row[j + 1]);\\n            }   \\n        }\\n        return row[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        for (int i = triangle.size() - 2; i >= 0; i--) {\\n            for (int j = 0; j < triangle[i].size(); j++) {\\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1]);\\n            }   \\n        }\\n        return triangle[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759473,
                "title": "c-bfs-like-approach-with-dp-explained-100-time-95-space-constant-memory",
                "content": "So, the idea is to move down our triangle like we would navigate in a graph with a BFS approach, layer by layer - but instead of preparing each layer as a series of new branches and leafs, we just cumulate the minimum possible path.\\n\\nSo, given the example:\\n\\n```\\n[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n```\\n\\nWe proceed with the first step and recompute the second row with with the (minimum) overall cost of getting there:\\n\\n```\\n[\\n     [2],\\n    [5,6], // 3 + 2, 4 + 2\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n```\\n\\nThen comes the third layer and notice that things start to get interesting, since the central value (`5`) has 2 possible ancestors, but we only keep the smaller one - the `5` in the second row:\\n\\n```\\n[\\n     [2],\\n    [5,6],\\n   [11,10,13], // 6 + 5, 5 + 5, 7 + 6\\n  [4,1,8,3]\\n]\\n```\\n\\nFinally, last round:\\n\\n```\\n[\\n     [2],\\n    [5,6],\\n   [11,10,13],\\n  [15,11,18,16] // 4 + 11, 1 + 10, 8 + 10, 3 + 13\\n]\\n```\\n\\nLast step, we get the minimum value from the last row: `11`.\\n\\nThe code below describes this approach (see the comments for the details), moving from each row starting from the second up to the end and noticing that the first and last elements of each row only have an ancestor (the matching extreme of the previous row), while all the others instead pick the minimum of their 2 possible parents:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int len = triangle.size(), rowLen;\\n        // parsing all the rows after the first\\n        for (int i = 1; i < len; i++) {\\n            rowLen = triangle[i].size();\\n            // looping through each row elements, incrementing it with\\n            // the minimum direct ancestor\\n            for (int j = 0; j < rowLen; j++) {\\n                // case for the first element of a row\\n                if (!j) triangle[i][j] += triangle[i - 1][0];\\n                // case for the last element of a row\\n                else if (j == rowLen - 1) triangle[i][j] += triangle[i - 1][j - 1];\\n                // all the others\\n                else triangle[i][j] += min(triangle[i - 1][j - 1], triangle[i - 1][j]);\\n            }\\n        }\\n        // finally, we return the minimum cumulated value in the very last row\\n        return accumulate(begin(triangle[len - 1]), end(triangle[len - 1]), INT_MAX, [](int a, int b){return min(a, b);});\\n    }\\n};\\n```\\n\\nAnd after about one year, I came up with an even more performing solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        // computing the min path in place\\n        for (int i = 1, lmt = triangle.size(); i < lmt; i++) {\\n            auto prevRow = triangle[i - 1], &currRow = triangle[i];\\n            // updating the first item\\n            currRow.front() += prevRow.front();\\n            // updating mid elements\\n            for (int j = 1, lmtRow = prevRow.size(); j < lmtRow; j++) currRow[j] += min(prevRow[j - 1], prevRow[j]);\\n            // updating the last item\\n            currRow.back() += prevRow.back();\\n        }\\n        return *min_element(begin(triangle.back()), end(triangle.back()));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n```\n```\\n[\\n     [2],\\n    [5,6], // 3 + 2, 4 + 2\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n```\n```\\n[\\n     [2],\\n    [5,6],\\n   [11,10,13], // 6 + 5, 5 + 5, 7 + 6\\n  [4,1,8,3]\\n]\\n```\n```\\n[\\n     [2],\\n    [5,6],\\n   [11,10,13],\\n  [15,11,18,16] // 4 + 11, 1 + 10, 8 + 10, 3 + 13\\n]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int len = triangle.size(), rowLen;\\n        // parsing all the rows after the first\\n        for (int i = 1; i < len; i++) {\\n            rowLen = triangle[i].size();\\n            // looping through each row elements, incrementing it with\\n            // the minimum direct ancestor\\n            for (int j = 0; j < rowLen; j++) {\\n                // case for the first element of a row\\n                if (!j) triangle[i][j] += triangle[i - 1][0];\\n                // case for the last element of a row\\n                else if (j == rowLen - 1) triangle[i][j] += triangle[i - 1][j - 1];\\n                // all the others\\n                else triangle[i][j] += min(triangle[i - 1][j - 1], triangle[i - 1][j]);\\n            }\\n        }\\n        // finally, we return the minimum cumulated value in the very last row\\n        return accumulate(begin(triangle[len - 1]), end(triangle[len - 1]), INT_MAX, [](int a, int b){return min(a, b);});\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        // computing the min path in place\\n        for (int i = 1, lmt = triangle.size(); i < lmt; i++) {\\n            auto prevRow = triangle[i - 1], &currRow = triangle[i];\\n            // updating the first item\\n            currRow.front() += prevRow.front();\\n            // updating mid elements\\n            for (int j = 1, lmtRow = prevRow.size(); j < lmtRow; j++) currRow[j] += min(prevRow[j - 1], prevRow[j]);\\n            // updating the last item\\n            currRow.back() += prevRow.back();\\n        }\\n        return *min_element(begin(triangle.back()), end(triangle.back()));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671594,
                "title": "java-three-solutions-dynamic-programming-top-down-bottom-up-and-memoization",
                "content": "<hr>\\n\\n\\uD83D\\uDC46\\uD83D\\uDC46 ***Upvote if you like my solutions!***\\n<hr>\\n\\n**1. Using 1D array**\\n\\n**Runtime:** 2 ms, faster than **75.18%** of Java online submissions for Triangle.\\n**Memory Usage:** 39.7 MB, less than 47.41% of Java online submissions for Triangle.\\n\\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> A) {\\n        // For storing the result \\n        // in a 1-D array, and  \\n        // simultaneously updating  \\n        // the result. \\n        int []memo = new int[A.size()]; \\n        int n = A.size() - 1; \\n      \\n        // For the bottom row \\n        for (int i = 0; i < A.get(n).size(); i++)  \\n            memo[i] = A.get(n).get(i); \\n      \\n        // Calculation of the  \\n        // remaining rows, in \\n        // bottom up manner. \\n        for (int i = A.size() - 2;i >= 0; i--)  \\n            for (int j = 0;j<A.get(i).size(); j++)  \\n                memo[j] = A.get(i).get(j) + (int)Math.min(memo[j],memo[j + 1]); \\n    \\n        // return the  \\n        // top element \\n        return memo[0]; \\n    }\\n}\\n```\\n<hr>\\n\\n**2. Bottom-Up Apporach - Using 2D Array**\\n\\n**Runtime:** 2 ms, faster than **75.18%** of Java online submissions for Triangle.\\n**Memory Usage:** 39.7 MB, less than 55.41% of Java online submissions for Triangle.\\n\\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        int[][] dp = new int[triangle.size()][triangle.size()];\\n        List<Integer> lastRow = triangle.get(triangle.size() - 1);\\n        for (int i = 0; i < lastRow.size(); i++)\\n            dp[triangle.size() - 1][i] = lastRow.get(i);\\n\\n        for (int i = triangle.size() - 2; i > -1; i--) {\\n            List<Integer> row = triangle.get(i);\\n            for (int j = 0; j < row.size(); j++) {\\n                int maxSumLeft = dp[i + 1][j];\\n                int maxSumRight = dp[i + 1][j + 1];\\n                int currentValue = row.get(j);\\n                int sumPath = currentValue + Math.min(maxSumLeft, maxSumRight);\\n                dp[i][j] = sumPath;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\\n<hr>\\n\\n**3. Top-Down Approach**\\n\\n**Runtime:** 3 ms, faster than **48.18%** of Java online submissions for Triangle.\\n**Memory Usage:** 39.3 MB, less than 88.18% of Java online submissions for Triangle.\\n\\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        int len = triangle.size();\\n        \\n        int dp[][] = new int[len][len];\\n        dp[0][0] = triangle.get(0).get(0);\\n        \\n        for(int i=1;i<len;i++){\\n            List<Integer> temp = triangle.get(i);\\n            for(int j=0;j<=i;j++){\\n                if(i==j){\\n                    dp[i][j]=temp.get(j)+dp[i-1][j-1];\\n                }\\n                else if(j!=0 && temp.get(j)+dp[i-1][j-1] < temp.get(j)+dp[i-1][j]){\\n                    dp[i][j] = temp.get(j)+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=temp.get(j)+dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int min = dp[len-1][0];\\n        for(int i=1;i<len;i++){\\n            if(dp[len-1][i]<min){\\n                min=dp[len-1][i];\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> A) {\\n        // For storing the result \\n        // in a 1-D array, and  \\n        // simultaneously updating  \\n        // the result. \\n        int []memo = new int[A.size()]; \\n        int n = A.size() - 1; \\n      \\n        // For the bottom row \\n        for (int i = 0; i < A.get(n).size(); i++)  \\n            memo[i] = A.get(n).get(i); \\n      \\n        // Calculation of the  \\n        // remaining rows, in \\n        // bottom up manner. \\n        for (int i = A.size() - 2;i >= 0; i--)  \\n            for (int j = 0;j<A.get(i).size(); j++)  \\n                memo[j] = A.get(i).get(j) + (int)Math.min(memo[j],memo[j + 1]); \\n    \\n        // return the  \\n        // top element \\n        return memo[0]; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        int[][] dp = new int[triangle.size()][triangle.size()];\\n        List<Integer> lastRow = triangle.get(triangle.size() - 1);\\n        for (int i = 0; i < lastRow.size(); i++)\\n            dp[triangle.size() - 1][i] = lastRow.get(i);\\n\\n        for (int i = triangle.size() - 2; i > -1; i--) {\\n            List<Integer> row = triangle.get(i);\\n            for (int j = 0; j < row.size(); j++) {\\n                int maxSumLeft = dp[i + 1][j];\\n                int maxSumRight = dp[i + 1][j + 1];\\n                int currentValue = row.get(j);\\n                int sumPath = currentValue + Math.min(maxSumLeft, maxSumRight);\\n                dp[i][j] = sumPath;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        int len = triangle.size();\\n        \\n        int dp[][] = new int[len][len];\\n        dp[0][0] = triangle.get(0).get(0);\\n        \\n        for(int i=1;i<len;i++){\\n            List<Integer> temp = triangle.get(i);\\n            for(int j=0;j<=i;j++){\\n                if(i==j){\\n                    dp[i][j]=temp.get(j)+dp[i-1][j-1];\\n                }\\n                else if(j!=0 && temp.get(j)+dp[i-1][j-1] < temp.get(j)+dp[i-1][j]){\\n                    dp[i][j] = temp.get(j)+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j]=temp.get(j)+dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        int min = dp[len-1][0];\\n        for(int i=1;i<len;i++){\\n            if(dp[len-1][i]<min){\\n                min=dp[len-1][i];\\n            }\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662206,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int MinimumTotal(IList<IList<int>> triangle) {\\n        if (triangle == null || triangle.Count == 0)\\n            return 0;\\n        \\n        for (int i = triangle.Count - 1; i > 0; i--)\\n            for (int j = 0; j < triangle[i].Count - 1; j++)\\n                triangle[i - 1][j] += Math.Min(triangle[i][j], triangle[i][j + 1]);\\n        \\n        return triangle[0][0];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MinimumTotal(IList<IList<int>> triangle) {\\n        if (triangle == null || triangle.Count == 0)\\n            return 0;\\n        \\n        for (int i = triangle.Count - 1; i > 0; i--)\\n            for (int j = 0; j < triangle[i].Count - 1; j++)\\n                triangle[i - 1][j] += Math.Min(triangle[i][j], triangle[i][j + 1]);\\n        \\n        return triangle[0][0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 267079,
                "title": "4-lines-python",
                "content": "For each row starting from one we can take the mimium of  A[i-1][j] or A[i-1][j-1] \\n\\n ```   \\n def minimumTotal(self, A):\\n        for i in range(1,  len(A)):\\n            for j in range(len(A[i])):\\n                A[i][j] += min([A[i-1][x] for x in (j-1,j) if 0<= x < len(A[i-1])])\\n        return min(A[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```   \\n def minimumTotal(self, A):\\n        for i in range(1,  len(A)):\\n            for j in range(len(A[i])):\\n                A[i][j] += min([A[i-1][x] for x in (j-1,j) if 0<= x < len(A[i-1])])\\n        return min(A[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 38726,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The **ART** of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\nEach optimal choice for the parent node\\'s accumulated minimum total is the minimum of its left/right child node\\'s optimal choice.\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n---\\n\\n**Kotlin**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n\\n```\\nclass Solution {\\n    fun minimumTotal(A: List<List<Int>>): Int {\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == A.size)\\n                return 0\\n            var L = go(i + 1, j)\\n            var R = go(i + 1, j + 1)\\n            return A[i][j] + Math.min(L, R)\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n\\n```\\nclass Solution {\\n    fun minimumTotal(A: List<List<Int>>): Int {\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == A.size)\\n                return 0\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var L = go(i + 1, j)\\n                var R = go(i + 1, j + 1)\\n                m[k] = A[i][j] + Math.min(L, R)\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n```\\nclass Solution {\\n    fun minimumTotal(A: List<List<Int>>): Int {\\n        var dp = A.map{ it.toMutableList() }\\n        for (i in A.size - 2 downTo 0) {\\n            for (j in 0 until A[i].size) {\\n                var L = dp[i + 1][j]\\n                var R = dp[i + 1][j + 1]\\n                dp[i][j] += Math.min(L, R)\\n            }\\n        }\\n        return dp[0][0]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n\\n```\\nlet minimumTotal = A => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == A.length)\\n            return 0;\\n        let L = go(i + 1, j),\\n            R = go(i + 1, j + 1);\\n        return A[i][j] += Math.min(L, R);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n\\n```\\nlet minimumTotal = (A, m = new Map()) => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == A.length)\\n            return 0;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let L = go(i + 1, j),\\n                R = go(i + 1, j + 1);\\n            m.set(k, A[i][j] += Math.min(L, R));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n```\\nlet minimumTotal = A => {\\n    for (let i = A.length - 2; 0 <= i; --i) {\\n        for (let j = 0; j < A[i].length; ++j) {\\n            let L = A[i + 1][j],\\n                R = A[i + 1][j + 1];\\n            A[i][j] += Math.min(L, R);\\n        }\\n    }\\n    return A[0][0];\\n};\\n```\\n\\n---\\n\\n**Python3**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n\\n```\\nclass Solution:\\n    def minimumTotal(self, A: List[List[int]]) -> int:\\n        def go(i = 0, j = 0):\\n            if i == len(A):\\n                return 0\\n            L = go(i + 1, j)\\n            R = go(i + 1, j + 1)\\n            A[i][j] += min(L, R)\\n            return A[i][j]\\n        return go()\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n\\n```\\nclass Solution:\\n    def minimumTotal(self, A: List[List[int]]) -> int:\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == len(A):\\n                return 0\\n            L = go(i + 1, j)\\n            R = go(i + 1, j + 1)\\n            A[i][j] += min(L, R)\\n            return A[i][j]\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n```\\nclass Solution:\\n    def minimumTotal(self, A: List[List[int]]) -> int:\\n        for i in range(len(A) - 2, -1, -1):\\n            for j in range(len(A[i])):\\n                L = A[i + 1][j]\\n                R = A[i + 1][j + 1]\\n                A[i][j] += min(L, R)\\n        return A[0][0]\\n```\\n\\n**Rust**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_total(mut A: VVI) -> i32 {\\n        fn go(mut A: &VVI, i: usize, j: usize) -> i32 {\\n            if i == A.len() {\\n                return 0;\\n            }\\n            let L = go(A, i + 1, j);\\n            let R = go(A, i + 1, j + 1);\\n            return A[i][j] + min(L, R);\\n        }\\n        return go(&mut A, 0, 0);\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn minimum_total(mut A: VVI) -> i32 {\\n        let mut m = HashMap::<String, i32>::new();\\n        fn go(A: &mut VVI, m: &mut HashMap<String, i32>, i: usize, j: usize) -> i32 {\\n            if i == A.len() {\\n                return 0;\\n            }\\n            let k = format!(\"{},{}\", i, j);\\n            if !m.contains_key(&k) {\\n                let L = go(A, m, i + 1, j);\\n                let R = go(A, m, i + 1, j + 1);\\n                m.insert(k.clone(), A[i][j] + min(L, R));\\n            }\\n            return *m.get(&k).unwrap();\\n        }\\n        return go(&mut A, &mut m, 0, 0);\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_total(mut A: VVI) -> i32 {\\n        for i in (0..A.len() - 1).rev() {\\n            for j in 0..A[i].len() {\\n                let L = A[i + 1][j];\\n                let R = A[i + 1][j + 1];\\n                A[i][j] += min(L, R);\\n            }\\n        }\\n        return A[0][0];\\n    }\\n}\\n```\\n\\n---\\n\\n**C++**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int minimumTotal(VVI& A) {\\n        fun go = [&](auto i, auto j) {\\n            if (i == A.size())\\n                return 0;\\n            auto L = go(i + 1, j),\\n                 R = go(i + 1, j + 1);\\n            return A[i][j] += min(L, R);\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minimumTotal(VVI& A, Map m = {}) {\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (i == A.size())\\n                return 0;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto L = go(i + 1, j),\\n                     R = go(i + 1, j + 1);\\n                m[k] = A[i][j] += min(L, R);\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumTotal(VVI& A) {\\n        int N = A.size();\\n        for (auto i{ N - 2 }; 0 <= i; --i) {\\n            for (auto j{ 0 }; j < A[i].size(); ++j) {\\n                auto L = A[i + 1][j],\\n                     R = A[i + 1][j + 1];\\n                A[i][j] += min(L, R);\\n            }\\n        }\\n        return A[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumTotal(A: List<List<Int>>): Int {\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == A.size)\\n                return 0\\n            var L = go(i + 1, j)\\n            var R = go(i + 1, j + 1)\\n            return A[i][j] + Math.min(L, R)\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumTotal(A: List<List<Int>>): Int {\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == A.size)\\n                return 0\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var L = go(i + 1, j)\\n                var R = go(i + 1, j + 1)\\n                m[k] = A[i][j] + Math.min(L, R)\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumTotal(A: List<List<Int>>): Int {\\n        var dp = A.map{ it.toMutableList() }\\n        for (i in A.size - 2 downTo 0) {\\n            for (j in 0 until A[i].size) {\\n                var L = dp[i + 1][j]\\n                var R = dp[i + 1][j + 1]\\n                dp[i][j] += Math.min(L, R)\\n            }\\n        }\\n        return dp[0][0]\\n    }\\n}\\n```\n```\\nlet minimumTotal = A => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == A.length)\\n            return 0;\\n        let L = go(i + 1, j),\\n            R = go(i + 1, j + 1);\\n        return A[i][j] += Math.min(L, R);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minimumTotal = (A, m = new Map()) => {\\n    let go = (i = 0, j = 0) => {\\n        if (i == A.length)\\n            return 0;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let L = go(i + 1, j),\\n                R = go(i + 1, j + 1);\\n            m.set(k, A[i][j] += Math.min(L, R));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minimumTotal = A => {\\n    for (let i = A.length - 2; 0 <= i; --i) {\\n        for (let j = 0; j < A[i].length; ++j) {\\n            let L = A[i + 1][j],\\n                R = A[i + 1][j + 1];\\n            A[i][j] += Math.min(L, R);\\n        }\\n    }\\n    return A[0][0];\\n};\\n```\n```\\nclass Solution:\\n    def minimumTotal(self, A: List[List[int]]) -> int:\\n        def go(i = 0, j = 0):\\n            if i == len(A):\\n                return 0\\n            L = go(i + 1, j)\\n            R = go(i + 1, j + 1)\\n            A[i][j] += min(L, R)\\n            return A[i][j]\\n        return go()\\n```\n```\\nclass Solution:\\n    def minimumTotal(self, A: List[List[int]]) -> int:\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == len(A):\\n                return 0\\n            L = go(i + 1, j)\\n            R = go(i + 1, j + 1)\\n            A[i][j] += min(L, R)\\n            return A[i][j]\\n        return go()\\n```\n```\\nclass Solution:\\n    def minimumTotal(self, A: List[List[int]]) -> int:\\n        for i in range(len(A) - 2, -1, -1):\\n            for j in range(len(A[i])):\\n                L = A[i + 1][j]\\n                R = A[i + 1][j + 1]\\n                A[i][j] += min(L, R)\\n        return A[0][0]\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_total(mut A: VVI) -> i32 {\\n        fn go(mut A: &VVI, i: usize, j: usize) -> i32 {\\n            if i == A.len() {\\n                return 0;\\n            }\\n            let L = go(A, i + 1, j);\\n            let R = go(A, i + 1, j + 1);\\n            return A[i][j] + min(L, R);\\n        }\\n        return go(&mut A, 0, 0);\\n    }\\n}\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn minimum_total(mut A: VVI) -> i32 {\\n        let mut m = HashMap::<String, i32>::new();\\n        fn go(A: &mut VVI, m: &mut HashMap<String, i32>, i: usize, j: usize) -> i32 {\\n            if i == A.len() {\\n                return 0;\\n            }\\n            let k = format!(\"{},{}\", i, j);\\n            if !m.contains_key(&k) {\\n                let L = go(A, m, i + 1, j);\\n                let R = go(A, m, i + 1, j + 1);\\n                m.insert(k.clone(), A[i][j] + min(L, R));\\n            }\\n            return *m.get(&k).unwrap();\\n        }\\n        return go(&mut A, &mut m, 0, 0);\\n    }\\n}\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_total(mut A: VVI) -> i32 {\\n        for i in (0..A.len() - 1).rev() {\\n            for j in 0..A[i].len() {\\n                let L = A[i + 1][j];\\n                let R = A[i + 1][j + 1];\\n                A[i][j] += min(L, R);\\n            }\\n        }\\n        return A[0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int minimumTotal(VVI& A) {\\n        fun go = [&](auto i, auto j) {\\n            if (i == A.size())\\n                return 0;\\n            auto L = go(i + 1, j),\\n                 R = go(i + 1, j + 1);\\n            return A[i][j] += min(L, R);\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minimumTotal(VVI& A, Map m = {}) {\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (i == A.size())\\n                return 0;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto L = go(i + 1, j),\\n                     R = go(i + 1, j + 1);\\n                m[k] = A[i][j] += min(L, R);\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumTotal(VVI& A) {\\n        int N = A.size();\\n        for (auto i{ N - 2 }; 0 <= i; --i) {\\n            for (auto j{ 0 }; j < A[i].size(); ++j) {\\n                auto L = A[i + 1][j],\\n                     R = A[i + 1][j + 1];\\n                A[i][j] += min(L, R);\\n            }\\n        }\\n        return A[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38893,
                "title": "3-ms-java-dp-solution-o-n-space-with-inline-comments",
                "content": "    public int minimumTotal(List<List<Integer>> triangle) {\\n        int[] sum = new int[triangle.size()];\\n        sum[0] = triangle.get(0).get(0);\\n        int min = Integer.MAX_VALUE;\\n        \\n        for (int i = 1; i < triangle.size(); i++)\\n        {\\n            List<Integer> row = triangle.get(i);\\n            \\n            // iterate backwards so we don't write over our cache in the sum\\n            // array.  If we start from the last we will never overwrite values\\n            // that we will need later.\\n            for (int j = i; j >= 0; j--)\\n            {\\n                int val = row.get(j);\\n                \\n                // if we are on the first column then the only adjacent\\n                // number is already stored in sum[j] from the previous row\\n                if (j == 0)\\n                {\\n                    sum[j] += val;\\n                }\\n                \\n                // if we are on the last column then we are adding a new\\n                // value to the sum array since it increases by one each row.\\n                // Add the sum from the previous row which is located at sum[j-1]\\n                else if (j == i)\\n                {\\n                    sum[j] = val + sum[j - 1];\\n                }\\n                \\n                // we are in between and we need to take the min sum from the\\n                // adjacent cells in the previous row.\\n                else\\n                {\\n                    sum[j] = Math.min(sum[j], sum[j-1]) + val;\\n                }\\n            }\\n        }\\n        \\n        for (int num: sum)\\n        {\\n            min = Math.min(num, min);\\n        }\\n        return min;\\n    }",
                "solutionTags": [],
                "code": "    public int minimumTotal(List<List<Integer>> triangle) {\\n        int[] sum = new int[triangle.size()];\\n        sum[0] = triangle.get(0).get(0);\\n        int min = Integer.MAX_VALUE;\\n        \\n        for (int i = 1; i < triangle.size(); i++)\\n        {\\n            List<Integer> row = triangle.get(i);\\n            \\n            // iterate backwards so we don't write over our cache in the sum\\n            // array.  If we start from the last we will never overwrite values\\n            // that we will need later.\\n            for (int j = i; j >= 0; j--)\\n            {\\n                int val = row.get(j);\\n                \\n                // if we are on the first column then the only adjacent\\n                // number is already stored in sum[j] from the previous row\\n                if (j == 0)\\n                {\\n                    sum[j] += val;\\n                }\\n                \\n                // if we are on the last column then we are adding a new\\n                // value to the sum array since it increases by one each row.\\n                // Add the sum from the previous row which is located at sum[j-1]\\n                else if (j == i)\\n                {\\n                    sum[j] = val + sum[j - 1];\\n                }\\n                \\n                // we are in between and we need to take the min sum from the\\n                // adjacent cells in the previous row.\\n                else\\n                {\\n                    sum[j] = Math.min(sum[j], sum[j-1]) + val;\\n                }\\n            }\\n        }\\n        \\n        for (int num: sum)\\n        {\\n            min = Math.min(num, min);\\n        }\\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38787,
                "title": "reason-why-the-best-algorithm-has-to-be-u0398-n-2",
                "content": "Suppose the best algorithm has time complexity of `T(n)` when there are `n` layers. Then let's think about what `T(n+1)` would be for such a best algorithm. For us to find the minimum sum of `n+1` layers, `we have to check every possible item on the last layer`. Since there are `n+1` elements on the last layer, we have\\n\\n    T(n+1) = T(n) + (n+1)  with T(1)=1\\n    ==> T(n) = 1 + 2 + ... + (n+1) = \\u0398(n^2)\\n\\nWhy do we have to check all items on layer `n+1`? Think of the following example:\\n\\nSuppose we have 5 layers now and the sum of all minimum sum path to the elements on layer 5 are as follows:\\n\\n    1    3    6    9    90\\n\\nWhich of the above 5 elements could be in the minimum sum path if there is one more layer? The answer is any one. For example if layer 6 has the following numbers:\\n\\n    100 100 100 100 100 1\\n\\nIn this case, the minimum sum path is 90+1.\\n\\n========================================\\n\\nSomething kind of irrelevant:\\n\\nOne other detail that might be interesting to some of you is how many possible paths there are. The answer is C(n) = O(2<sup>n-1</sup>). This can be shown by induction:\\n\\n    n=1 ==> C(1) = 1\\n\\nAssume for `n=k`, C(k) = 2<sup>k-1</sup>, then for `n=k+1`, there are `k` elements on the last but one layer, for every element on that layer, it has two possible paths to the `k+1` layer. Therefore\\n\\n    C(k+1) = C(k)*2 = 2^((k-1)+1)\\n\\nThus, C(n) = 2<sup>n-1</sup>.",
                "solutionTags": [],
                "code": "Suppose the best algorithm has time complexity of `T(n)` when there are `n` layers. Then let's think about what `T(n+1)` would be for such a best algorithm. For us to find the minimum sum of `n+1` layers, `we have to check every possible item on the last layer`. Since there are `n+1` elements on the last layer, we have\\n\\n    T(n+1) = T(n) + (n+1)  with T(1)=1\\n    ==> T(n) = 1 + 2 + ... + (n+1) = \\u0398(n^2)\\n\\nWhy do we have to check all items on layer `n+1`? Think of the following example:\\n\\nSuppose we have 5 layers now and the sum of all minimum sum path to the elements on layer 5 are as follows:\\n\\n    1    3    6    9    90\\n\\nWhich of the above 5 elements could be in the minimum sum path if there is one more layer? The answer is any one. For example if layer 6 has the following numbers:\\n\\n    100 100 100 100 100 1\\n\\nIn this case, the minimum sum path is 90+1.\\n\\n========================================\\n\\nSomething kind of irrelevant:\\n\\nOne other detail that might be interesting to some of you is how many possible paths there are. The answer is C(n) = O(2<sup>n-1</sup>). This can be shown by induction:\\n\\n    n=1 ==> C(1) = 1\\n\\nAssume for `n=k`, C(k) = 2<sup>k-1</sup>, then for `n=k+1`, there are `k` elements on the last but one layer, for every element on that layer, it has two possible paths to the `k+1` layer. Therefore\\n\\n    C(k+1) = C(k)*2 = 2^((k-1)+1)\\n\\nThus, C(n) = 2<sup>n-1</sup>.",
                "codeTag": "Unknown"
            },
            {
                "id": 3894533,
                "title": "beats-96-easiest-approach-extra-o-1-space",
                "content": "# Intuition\\nThe algorithm efficiently computes the minimum path cost from the triangle\\'s bottom to top, updating each cell to represent the least costly path by considering the two possible paths from the previous row.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n**Step 1:** We start by preparing a place to store the answer, which we\\'ll call `ans`, and set it to a really large value. This will be used to keep track of the minimum path sum.\\n\\n**Step 2:** We count how many rows the triangle has and save this count as `n`.\\n\\n**Step 3:** If the triangle has only one row, we\\'re done! We return the single number in that row as the minimum path sum.\\n\\n**Step 4:** Now the interesting part begins! We go through each row, starting from the second row (row number 1). We\\'re going to update the values in each row to represent the minimum path sum that ends at that position.\\n\\n**Step 5:** For each new row, we take the first number and add to it the number right above it from the previous row. This step ensures we keep track of the running total as we move down the triangle.\\n\\n**Step 6:** Moving inside the row, we consider each number (excluding the first and last) and update it. We add to it the smaller of the two numbers directly above it from the previous row. This way, we\\'re building up the path with the minimum sum.\\n\\n**Step 7:** Similarly, for the last number in the row, we add to it the number diagonally above it from the previous row. Again, this helps us account for the minimum sum path.\\n\\n**Step 8:** Once we\\'ve gone through all the rows and updated the values, we now have the minimum path sum stored in the last row.\\n\\n**Step 9:** To find the overall minimum path sum, we loop through the numbers in the last row and compare each of them to our `ans` variable. If we find a smaller number, we update `ans` with that value.\\n\\n**Step 10:** Finally, we return the `ans` value, which now holds the minimum path sum from the top of the triangle to the bottom.\\n\\nIn simple terms, this code dynamically calculates the minimum path sum by progressively adding up the numbers while considering the most efficient path. It\\'s like finding the shortest way through a maze, where each number represents a step\\'s cost, and we\\'re trying to spend the least amount of energy to reach the end.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int ans = 100000;\\n        int n = triangle.size();\\n        if(n == 1){\\n            return triangle[0][0];\\n        }\\n        for(int i = 1 ; i < n ; i++ ){\\n            triangle[i][0] += triangle[i-1][0] ;\\n            for(int j = 1 ; j < i ; j++){\\n                triangle[i][j] += min(triangle[i-1][j] , triangle[i-1][j-1]) ;\\n            }\\n            triangle[i][i] += triangle[i-1][i-1] ;\\n        }\\n        for(int j = 0 ; j < n ; j++){\\n            ans = min(ans , triangle[n-1][j]);\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int ans = 100000;\\n        int n = triangle.size();\\n        if(n == 1){\\n            return triangle[0][0];\\n        }\\n        for(int i = 1 ; i < n ; i++ ){\\n            triangle[i][0] += triangle[i-1][0] ;\\n            for(int j = 1 ; j < i ; j++){\\n                triangle[i][j] += min(triangle[i-1][j] , triangle[i-1][j-1]) ;\\n            }\\n            triangle[i][i] += triangle[i-1][i-1] ;\\n        }\\n        for(int j = 0 ; j < n ; j++){\\n            ans = min(ans , triangle[n-1][j]);\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770607,
                "title": "memoization-java-99",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    long[][] dp;\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        dp=new long[triangle.size()][triangle.get(triangle.size()-1).size()];\\n        for (long[] row : dp)\\n            Arrays.fill(row,Long.MIN_VALUE);\\n        return dfs(0,0,triangle);\\n    }\\n    public int dfs(int level,int index,List<List<Integer>> triangle){\\n        if(level>triangle.size()-1) return 0;\\n        if(dp[level][index]!=Long.MIN_VALUE) return (int)dp[level][index];\\n        int path = triangle.get(level).get(index); // get the current value\\n        if (level < triangle.size() - 1) \\n            path += Math.min(dfs(level + 1, index, triangle), dfs(level + 1, index + 1, triangle));\\n        dp[level][index]=(long)path;\\n        return path;\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long[][] dp;\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        dp=new long[triangle.size()][triangle.get(triangle.size()-1).size()];\\n        for (long[] row : dp)\\n            Arrays.fill(row,Long.MIN_VALUE);\\n        return dfs(0,0,triangle);\\n    }\\n    public int dfs(int level,int index,List<List<Integer>> triangle){\\n        if(level>triangle.size()-1) return 0;\\n        if(dp[level][index]!=Long.MIN_VALUE) return (int)dp[level][index];\\n        int path = triangle.get(level).get(index); // get the current value\\n        if (level < triangle.size() - 1) \\n            path += Math.min(dfs(level + 1, index, triangle), dfs(level + 1, index + 1, triangle));\\n        dp[level][index]=(long)path;\\n        return path;\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642838,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle)\\n     {\\n        int n=triangle.size();\\n        vector<int> prev(n,0),curr(n,0);\\n        for(int i=0;i<n;i++) prev[i]=triangle[n-1][i];\\n        for(int i=n-2;i>=0;i--) \\n        {\\n            for(int j=i;j>=0;j--)\\n             {\\n                curr[j]=triangle[i][j]+min(prev[j],prev[j+1]);\\n            }\\n            prev=curr;\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle)\\n     {\\n        int n=triangle.size();\\n        vector<int> prev(n,0),curr(n,0);\\n        for(int i=0;i<n;i++) prev[i]=triangle[n-1][i];\\n        for(int i=n-2;i>=0;i--) \\n        {\\n            for(int j=i;j>=0;j--)\\n             {\\n                curr[j]=triangle[i][j]+min(prev[j],prev[j+1]);\\n            }\\n            prev=curr;\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634442,
                "title": "4-appproches-solution-cpp-o-n-space-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nRECURSION  SOLUTION  TLE \\nclass Solution {\\npublic:\\n    int solve(int i ,int j,vector<vector<int>>& triangle ){\\n        if( i >= triangle.size() || j >= triangle[i].size() ) return 0;\\n        if( i == triangle.size()-1 ) return triangle[i][j];\\n\\n        int sum = INT_MAX;\\n      \\n        return triangle[i][j] + min(solve(i+1,j,triangle),solve(i+1,j+1,triangle)); \\n         \\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return solve(0,0,triangle);\\n    }\\n};\\n```\\n```\\nUSING MEMOAIZATION\\n\\nclass Solution {\\npublic:\\n    int solve(int i ,int j,vector<vector<int>>& triangle ,vector<vector<int>>&dp){\\n        if( i >= triangle.size() || j >= triangle[i].size() ) return 0;\\n        if( i == triangle.size()-1 ) return triangle[i][j];\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = triangle[i][j] + min(solve(i+1,j,triangle,dp),solve(i+1,j+1,triangle,dp)); \\n    }\\n```\\n```\\n TABULATION SOLUTION O(M*N) SPACE\\n int Solve_Tab(vector<vector<int>>& triangle){\\n        int n = 200;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0)); \\n        int row = triangle.size();\\n\\n        for(int i = 0 ; i<triangle[row-1].size();i++){\\n            dp[row-1][i] = triangle[row-1][i];   \\n        }\\n\\n        for(int i = row-2 ; i>=0;i--){\\n            for(int j = triangle[i].size()-1 ; j >= 0;j--)\\n              dp[i][j] = triangle[i][j] + min(dp[i+1][j],dp[i+1][j+1]);\\n    }\\n       return  dp[0][0];\\n\\n    }\\n```\\nO(N) SPACE \\n\\n    int Solve_Tab(vector<vector<int>>& triangle){\\n        int n = 200;\\n        vector<int>prev(n+1,0);\\n        vector<int>curr(n+1,0);\\n\\n        int row = triangle.size();\\n        for(int i = 0 ; i<triangle[row-1].size();i++)\\n            prev[i] = triangle[row-1][i];\\n\\n        for(int i = row-2 ; i>=0;i--){\\n            for(int j = triangle[i].size()-1 ; j >= 0;j--)\\n              curr[j] = triangle[i][j] + min(prev[j],prev[j+1]);    \\n            prev = curr;\\n        }\\n       return prev[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nRECURSION  SOLUTION  TLE \\nclass Solution {\\npublic:\\n    int solve(int i ,int j,vector<vector<int>>& triangle ){\\n        if( i >= triangle.size() || j >= triangle[i].size() ) return 0;\\n        if( i == triangle.size()-1 ) return triangle[i][j];\\n\\n        int sum = INT_MAX;\\n      \\n        return triangle[i][j] + min(solve(i+1,j,triangle),solve(i+1,j+1,triangle)); \\n         \\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return solve(0,0,triangle);\\n    }\\n};\\n```\n```\\nUSING MEMOAIZATION\\n\\nclass Solution {\\npublic:\\n    int solve(int i ,int j,vector<vector<int>>& triangle ,vector<vector<int>>&dp){\\n        if( i >= triangle.size() || j >= triangle[i].size() ) return 0;\\n        if( i == triangle.size()-1 ) return triangle[i][j];\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        return dp[i][j] = triangle[i][j] + min(solve(i+1,j,triangle,dp),solve(i+1,j+1,triangle,dp)); \\n    }\\n```\n```\\n TABULATION SOLUTION O(M*N) SPACE\\n int Solve_Tab(vector<vector<int>>& triangle){\\n        int n = 200;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0)); \\n        int row = triangle.size();\\n\\n        for(int i = 0 ; i<triangle[row-1].size();i++){\\n            dp[row-1][i] = triangle[row-1][i];   \\n        }\\n\\n        for(int i = row-2 ; i>=0;i--){\\n            for(int j = triangle[i].size()-1 ; j >= 0;j--)\\n              dp[i][j] = triangle[i][j] + min(dp[i+1][j],dp[i+1][j+1]);\\n    }\\n       return  dp[0][0];\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336329,
                "title": "best-o-n-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^S)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& triangle, int n) {\\n        if (i == n-1)\\n            return triangle[i][j];\\n        int down = triangle[i][j] + solve(i+1, j, triangle, n);\\n        int diagonal = triangle[i][j] + solve(i+1, j+1, triangle, n);\\n        return min (down, diagonal);     \\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        return solve(0, 0, triangle, n);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$\\n\\n- Space complexity:\\n$$O(n * n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& triangle, vector<vector<int>>& dp, int n) {\\n        if (i == n-1)\\n            return triangle[i][j];\\n        if (dp[i][j] != -1)\\n            return dp[i][j];    \\n        int down = triangle[i][j] + solve(i+1, j, triangle, dp, n);\\n        int diagonal = triangle[i][j] + solve(i+1, j+1, triangle, dp, n);\\n        return dp[i][j] = min (down, diagonal);     \\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return solve(0, 0, triangle, dp, n);\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$\\n\\n- Space complexity:\\n$$O(n * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++)\\n            dp[n-1][i] = triangle[n-1][i];\\n        for (int i = n-2; i >= 0; i--) {\\n            for (int j = i; j >= 0; j--) {\\n                int down = triangle[i][j] + dp[i+1][j];\\n                int diagonal = triangle[i][j] + dp[i+1][j+1];\\n                dp[i][j] = min (down, diagonal);    \\n            }\\n        }   \\n        return dp[0][0];  \\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector <int> front(n);\\n        for (int i = 0; i < n; i++)\\n            front[i] = triangle[n-1][i];\\n        for (int i = n-2; i >= 0; i--) {\\n            vector <int> cur(n);\\n            for (int j = i; j >= 0; j--) {\\n                int down = triangle[i][j] + front[j];\\n                int diagonal = triangle[i][j] + front[j+1];\\n                cur[j] = min (down, diagonal);    \\n            }\\n            front = cur;\\n        }   \\n        return front[0];  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& triangle, int n) {\\n        if (i == n-1)\\n            return triangle[i][j];\\n        int down = triangle[i][j] + solve(i+1, j, triangle, n);\\n        int diagonal = triangle[i][j] + solve(i+1, j+1, triangle, n);\\n        return min (down, diagonal);     \\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        return solve(0, 0, triangle, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& triangle, vector<vector<int>>& dp, int n) {\\n        if (i == n-1)\\n            return triangle[i][j];\\n        if (dp[i][j] != -1)\\n            return dp[i][j];    \\n        int down = triangle[i][j] + solve(i+1, j, triangle, dp, n);\\n        int diagonal = triangle[i][j] + solve(i+1, j+1, triangle, dp, n);\\n        return dp[i][j] = min (down, diagonal);     \\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return solve(0, 0, triangle, dp, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; i++)\\n            dp[n-1][i] = triangle[n-1][i];\\n        for (int i = n-2; i >= 0; i--) {\\n            for (int j = i; j >= 0; j--) {\\n                int down = triangle[i][j] + dp[i+1][j];\\n                int diagonal = triangle[i][j] + dp[i+1][j+1];\\n                dp[i][j] = min (down, diagonal);    \\n            }\\n        }   \\n        return dp[0][0];  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector <int> front(n);\\n        for (int i = 0; i < n; i++)\\n            front[i] = triangle[n-1][i];\\n        for (int i = n-2; i >= 0; i--) {\\n            vector <int> cur(n);\\n            for (int j = i; j >= 0; j--) {\\n                int down = triangle[i][j] + front[j];\\n                int diagonal = triangle[i][j] + front[j+1];\\n                cur[j] = min (down, diagonal);    \\n            }\\n            front = cur;\\n        }   \\n        return front[0];  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197163,
                "title": "effective-form-of-dp-concept-constant-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nMain principle of DP is memorisation, so we memorize solutions for sub-tasks to generate solution. In this particular problem each node could be reached from only two nodes, so we can go layer by layer from top to bottom, processing every layer in place, as we don\\'t need to know original value of node if we already found cost of optimal way.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPreprocess first two layers, as there is only one way to reach them. Then do following for each layer: \\n- Increase values for 0th and (elems-1)th elements, because there is only one way to reach them\\n- For every other element decide which of two upper elements(that now contain values of optimal paths) is optimal, and increase their value by it.\\nAt the end we iterate through last layer, as every element stores cost of optimal path to reach it.\\n# Complexity\\n- Time complexity: O(n), where n is total count of elements, as every element is processed only once.\\n- Space complexity: O(1) - we use only constant extra space.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int ans = INT_MAX;\\n        int levelTotal = triangle.size();\\n        if (levelTotal == 1)\\n        {\\n            return triangle[0][0];\\n        }\\n        else if (levelTotal == 2)\\n        {\\n            return min(triangle[1][0], triangle[1][1]) + triangle[0][0];\\n        }\\n        triangle[1][0] += triangle[0][0];\\n        triangle[1][1] += triangle[0][0];\\n        int elems = 3;\\n        for (int i = 2; i<levelTotal; i++)\\n        {\\n            triangle[i][0]+=triangle[i-1][0];\\n            triangle[i][elems-1]+=triangle[i-1][elems-2];\\n            for (int j = 1; j<elems-1; j++)\\n            {\\n                triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]);\\n            }\\n            elems++;\\n        }\\n        for (int i = 0; i < elems-1; i++)\\n        {\\n            if (triangle[levelTotal-1][i] < ans)\\n            {\\n                ans = triangle[levelTotal-1][i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n If this solution was useful, please upvote :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int ans = INT_MAX;\\n        int levelTotal = triangle.size();\\n        if (levelTotal == 1)\\n        {\\n            return triangle[0][0];\\n        }\\n        else if (levelTotal == 2)\\n        {\\n            return min(triangle[1][0], triangle[1][1]) + triangle[0][0];\\n        }\\n        triangle[1][0] += triangle[0][0];\\n        triangle[1][1] += triangle[0][0];\\n        int elems = 3;\\n        for (int i = 2; i<levelTotal; i++)\\n        {\\n            triangle[i][0]+=triangle[i-1][0];\\n            triangle[i][elems-1]+=triangle[i-1][elems-2];\\n            for (int j = 1; j<elems-1; j++)\\n            {\\n                triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]);\\n            }\\n            elems++;\\n        }\\n        for (int i = 0; i < elems-1; i++)\\n        {\\n            if (triangle[levelTotal-1][i] < ans)\\n            {\\n                ans = triangle[levelTotal-1][i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059050,
                "title": "beats-100-most-efficient-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint minimumTotal(vector<vector<int>>& v) {\\n        int n = v.size();\\n         vector<int>prev(n,0) , curr(n,0);\\n        for(int j=0;j<n;j++){\\n            prev[j] = v[n-1][j];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i;j>=0;j--){\\n                \\n                int pick    = v[i][j] + prev[j];\\n                int notpick = v[i][j] + prev[j+1];\\n                 curr[j] = min(pick , notpick);\\n                }\\n                prev = curr;\\n            }\\n        return prev[0];\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint minimumTotal(vector<vector<int>>& v) {\\n        int n = v.size();\\n         vector<int>prev(n,0) , curr(n,0);\\n        for(int j=0;j<n;j++){\\n            prev[j] = v[n-1][j];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i;j>=0;j--){\\n                \\n                int pick    = v[i][j] + prev[j];\\n                int notpick = v[i][j] + prev[j+1];\\n                 curr[j] = min(pick , notpick);\\n                }\\n                prev = curr;\\n            }\\n        return prev[0];\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958232,
                "title": "java-solution-memoization-similar-to-minimum-path-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsame as min path sum on grid but with fixed starting point and variable ending point\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsince it has a fixed starting point we will start from there and the base case would be to reach the last row hence ind==n then we will return it\\'s value\\n\\nas mentioned in the question ,we can go i and i+1 hence the cases written in recursive call and make sure to add the value at that particular index to get the sum in the last we will take the minimum of i and (i+1) cases\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(triangle\\'s height * width of triangle\\'s largest slice) due to these many number of states in dp\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(triangle\\'s height * width of triangle\\'s largest slice)+O(n) (auxiliary stack space)\\n# Code\\n```\\nclass Solution {\\n    \\n\\n    public int solve(List<List<Integer>> triangle,int i,int j,int[][] dp){\\n        if(i==triangle.size()-1) return triangle.get(i).get(j);\\nif(i>=triangle.size()-1 || j>=triangle.get(triangle.size()-1).size()) return (int)Math.pow(10,9);\\nif(dp[i][j]!=-1) return dp[i][j];\\nint down=triangle.get(i).get(j)+solve(triangle,i+1,j,dp);\\nint diag=triangle.get(i).get(j)+solve(triangle,i+1,j+1,dp);\\nreturn dp[i][j]=Math.min(down,diag);\\n    }\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        int[][] dp=new int[triangle.size()][triangle.get(triangle.size()-1).size()];\\n        for(int[]row:dp) Arrays.fill(row,-1);\\n       return solve(triangle,0,0,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\n    public int solve(List<List<Integer>> triangle,int i,int j,int[][] dp){\\n        if(i==triangle.size()-1) return triangle.get(i).get(j);\\nif(i>=triangle.size()-1 || j>=triangle.get(triangle.size()-1).size()) return (int)Math.pow(10,9);\\nif(dp[i][j]!=-1) return dp[i][j];\\nint down=triangle.get(i).get(j)+solve(triangle,i+1,j,dp);\\nint diag=triangle.get(i).get(j)+solve(triangle,i+1,j+1,dp);\\nreturn dp[i][j]=Math.min(down,diag);\\n    }\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        int[][] dp=new int[triangle.size()][triangle.get(triangle.size()-1).size()];\\n        for(int[]row:dp) Arrays.fill(row,-1);\\n       return solve(triangle,0,0,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554765,
                "title": "c-easy-solution-recursion-memoization",
                "content": "**Recursion** 42/44 test case passed \\u274C\\n```\\nclass Solution {\\npublic:\\n    int help(vector<vector<int>>& triangle,int i,int j){\\n        if(i==triangle.size()){\\n            return 0;\\n        }\\n        if(j>=triangle[i].size()){\\n            return 0;\\n        }\\n        int straight=help(triangle,i+1,j)+triangle[i][j];\\n        int adjacent=help(triangle,i+1,j+1)+triangle[i][j];\\n        return min(straight,adjacent);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return help(triangle,0,0);\\n    }\\n};\\n```\\n **Memoization**\\n ```\\n class Solution {\\npublic:\\n    int help(vector<vector<int>>& triangle,int i,int j,vector<vector<int>> &dp){\\n        if(i==triangle.size()){\\n            return 0;\\n        }\\n        if(j>=triangle[i].size()){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int straight=help(triangle,i+1,j,dp)+triangle[i][j];\\n        int adjacent=help(triangle,i+1,j+1,dp)+triangle[i][j];\\n        return dp[i][j]=min(straight,adjacent);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        vector<vector<int>> dp(n+1,vector<int> (triangle[n-1].size()+1,-1));\\n        return help(triangle,0,0,dp);\\n    }\\n};\\n ```\\n  Please upvote if you like the solution\\n  Happy Coding !!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(vector<vector<int>>& triangle,int i,int j){\\n        if(i==triangle.size()){\\n            return 0;\\n        }\\n        if(j>=triangle[i].size()){\\n            return 0;\\n        }\\n        int straight=help(triangle,i+1,j)+triangle[i][j];\\n        int adjacent=help(triangle,i+1,j+1)+triangle[i][j];\\n        return min(straight,adjacent);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return help(triangle,0,0);\\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    int help(vector<vector<int>>& triangle,int i,int j,vector<vector<int>> &dp){\\n        if(i==triangle.size()){\\n            return 0;\\n        }\\n        if(j>=triangle[i].size()){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int straight=help(triangle,i+1,j,dp)+triangle[i][j];\\n        int adjacent=help(triangle,i+1,j+1,dp)+triangle[i][j];\\n        return dp[i][j]=min(straight,adjacent);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        vector<vector<int>> dp(n+1,vector<int> (triangle[n-1].size()+1,-1));\\n        return help(triangle,0,0,dp);\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2205054,
                "title": "c-simple-solution-recursion-memoization-tabulation",
                "content": "// recursion   Time Complexity: O(2\\u207F)  ||  Space Complexity: O(n)\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i, int j, vector<vector<int>>& triangle ){\\n         if( i == triangle.size()-1)   // base case\\n             return triangle[triangle.size()-1][j];\\n        int d = triangle[i][j] + f(i+1, j , triangle);     // for down \\n        int dg = triangle[i][j] + f(i+1, j+1 , triangle);  // for diagnol\\n        return min(d,dg);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n       return  f(0,0,triangle);\\n    }\\n};\\n\\n\\n// memositaion    Time Complexity: O(n*n)  ||  Space Complexity: O(n*n)\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i, int j, vector<vector<int>>& triangle , vector<vector<int>>&dp){\\n         \\n         if( i == triangle.size()-1)   // base case\\n             return triangle[triangle.size()-1][j];\\n        \\n        if(dp[i][j] != -1)      //*\\n            return dp[i][j];\\n        int d = triangle[i][j] + f(i+1, j , triangle , dp);     // for down \\n        int dg = triangle[i][j] + f(i+1, j+1 , triangle , dp);  // for diagnol\\n\\n        return dp[i][j] =  min(d,dg);   //*\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n       vector<vector<int>>dp(triangle.size() ,vector<int>(triangle.size(),-1));  // *\\n        \\n       return  f(0,0,triangle,dp);\\n    }\\n};\\n\\n\\n// tabulation   Time Complexity: O(n*n)  ||  Space Complexity: O(n*n)\\n\\nclass Solution {\\n   public:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        \\n        for (int j = 0; j < n; j++)   //*\\n            dp[n - 1][j] = triangle[n - 1][j];\\n        \\n        for (int i = n - 2; i >= 0; i--) {   //*\\n            for (int j = 0; j < i + 1; j++) {\\n                \\n                int d = triangle[i][j] + dp[i + 1][j];\\n                int dg = triangle[i][j] + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = min(d,dg);\\n            }\\n        }\\n        return dp[0][0];   //*\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int f(int i, int j, vector<vector<int>>& triangle ){\\n         if( i == triangle.size()-1)   // base case\\n             return triangle[triangle.size()-1][j];\\n        int d = triangle[i][j] + f(i+1, j , triangle);     // for down \\n        int dg = triangle[i][j] + f(i+1, j+1 , triangle);  // for diagnol\\n        return min(d,dg);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2146102,
                "title": "cpp-solution-0-ms-100-faster-91-better-space-efficiency-bottom-up-approach",
                "content": "__Thanks for checking out my solution\\nDo upvote, if it helped :)__\\n\\n__Whenever I see a pyramid shape (in DSA questions ofc), my first thought is to build a solution bottom-up, and return the top-most element, \\n[ If the question allows this. ]\\nSame applies to this question!__\\n\\n_For this very question we will store the immidiate minimum paths and continue to do so, till we reach the top-most element,\\ni.e. we will modify the given vector.\\nWe will start with the second last row of the vector (if  available), and for every element in this row, \\nWe will add the minimum of the two possible elements it can travel to `if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.`\\nWhen we continue to do this for all the elements we will ultimately reach the top most element, with the minimum path sum possible._\\n\\n\\n`Lets understand this with an example.`\\n   2\\n  3 4\\n 6 5 7\\n4 1 8 3\\n\\n__For the first iteration, that is the (n-i)th row from the top (where n = total number of rows, i starting from 1), \\nBottom-Up for a reason :)\\nAnother loop to modify the elements of this row\\n6 + min(4,1) ---> 6 + 1 = 7\\n5 + min(1,8) ---> 5 + 1 = 6\\n7 + min(8,3) ---> 7 + 3 = 10__\\n\\n`This Gives us the following pyramid`\\n2\\n3 4\\n7 6 10\\n4 1 8 3\\n`We need not worry about the variations done to the previous layer, as we only use a layer to build the one above it.\\nAnd ultimately we will build the top-most layer, which stores the answer.`\\n\\n__For the second iteration, (n-2)th from the top\\n3 + min(7,6) ----> 3 + 6 = 9\\n4 + min(6,10) ---> 4 + 6 = 10__\\n\\n`This Gives us the following pyramid`\\n2\\n9 10\\n7 6 10\\n4 1 8 3\\n\\n__For the Third iteration, (n-3)th from the top, As per our example it is the first row\\n2 + min(9,10) ----> 2 + 9 = 11__\\n\\n`This Gives us the following pyramid`\\n11\\n9 10\\n7 6 10\\n4 1 8 3\\n\\n__Our top-most element, stores the minimum path sum, i.e. 11\\nIn this way, we build the solution from the second last row, all the way to the top.\\nThe Following underlined path gives the better story__\\n\\n<ins>2</ins>\\n<ins>3</ins> 4\\n6 <ins>5</ins> 7\\n4 <ins>1</ins> 8 3\\n\\n__Below is the cpp implementaion for the approach mentioned above__\\n\\n```\\nclass Solution {  // Runtime: 0 ms, faster than 100.00% of C++ online submissions for Triangle.\\n                  // Memory Usage: 8.5 MB, less than 91.19% of C++ online submissions for Triangle.\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) \\n    {\\n        int len = triangle.size();\\n        for(int i = len - 2; i >= 0; i--)                          //Building the solution Bottom-Up\\n        {\\n            for(int j = 0; j < triangle[i].size(); j++)         //Traversing the current row\\n            {\\n                triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]); //Add the minimum of the two available options\\n            }\\n        }\\n        return triangle[0][0];                          //As the result will be stored in the top-most element, return the top-most element\\n    }\\n};\\n```\\n__Time Complexity : O((N-1)*(N/2)) ~ O(N^2)\\nSpace Complexity: O(1), Since we are only manipulating the given vector__",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {  // Runtime: 0 ms, faster than 100.00% of C++ online submissions for Triangle.\\n                  // Memory Usage: 8.5 MB, less than 91.19% of C++ online submissions for Triangle.\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) \\n    {\\n        int len = triangle.size();\\n        for(int i = len - 2; i >= 0; i--)                          //Building the solution Bottom-Up\\n        {\\n            for(int j = 0; j < triangle[i].size(); j++)         //Traversing the current row\\n            {\\n                triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]); //Add the minimum of the two available options\\n            }\\n        }\\n        return triangle[0][0];                          //As the result will be stored in the top-most element, return the top-most element\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146024,
                "title": "c-dp-reccursion-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> dp;\\n\\n\\tint helper(int i, int j, vector<vector<int>> &triangle) {\\n\\t\\tif (i == triangle.size() - 1) return triangle[i][j];\\n\\t\\tif (dp[i][j] != -1) return dp[i][j];\\n\\t\\tint bottom = triangle[i][j] + helper(i + 1, j, triangle);\\n\\t\\tint bottom_right = triangle[i][j] + helper(i + 1, j + 1, triangle);\\n\\t\\treturn dp[i][j] = min(bottom_right, bottom);\\n\\t}\\npublic:\\n\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\tint n = triangle.size();\\n\\t\\tdp.resize(n, vector<int>(n, -1));\\n\\t\\treturn helper(0, 0, triangle);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> dp;\\n\\n\\tint helper(int i, int j, vector<vector<int>> &triangle) {\\n\\t\\tif (i == triangle.size() - 1) return triangle[i][j];\\n\\t\\tif (dp[i][j] != -1) return dp[i][j];\\n\\t\\tint bottom = triangle[i][j] + helper(i + 1, j, triangle);\\n\\t\\tint bottom_right = triangle[i][j] + helper(i + 1, j + 1, triangle);\\n\\t\\treturn dp[i][j] = min(bottom_right, bottom);\\n\\t}\\npublic:\\n\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\tint n = triangle.size();\\n\\t\\tdp.resize(n, vector<int>(n, -1));\\n\\t\\treturn helper(0, 0, triangle);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145581,
                "title": "c-dp-3-solutions",
                "content": "#1 - top down\\n```\\npublic class Solution\\n{\\n    public int MinimumTotal(IList<IList<int>> triangle)\\n    {\\n        int n = triangle.Count;\\n        int?[,] dp = new int?[n, n];\\n        return GetShortestPath(0, 0);\\n\\n        int GetShortestPath(int row, int column)\\n        {\\n            if (row == n) return 0;\\n            if (column == row + 1) return int.MaxValue;\\n\\n            return dp[row, column] ??= triangle[row][column] + Math.Min(GetShortestPath(row + 1, column), GetShortestPath(row + 1, column + 1));\\n        }\\n    }\\n}\\n```\\n\\n#2 - bottom up with extra O(N) memory \\n```\\npublic class Solution\\n{\\n    public int MinimumTotal(IList<IList<int>> triangle)\\n    {\\n        int n = triangle.Count;\\n        int[] previous = new int[n];\\n        int[] current = triangle[n - 1].ToArray();\\n\\n        for (int row = n - 2; row >= 0; row--)\\n        {\\n            (previous, current) = (current, previous);\\n            for (int column = 0; column <= row; column++)\\n            {\\n                current[column] = triangle[row][column] + Math.Min(previous[column], previous[column + 1]);\\n            }\\n        }\\n\\n        return current[0];\\n    }\\n}\\n```\\n\\n#3 - bottom up with no extra memory\\n```\\npublic class Solution\\n{\\n    public int MinimumTotal(IList<IList<int>> triangle)\\n    {\\n        for (int row = triangle.Count - 2; row >= 0; row--)\\n        {\\n            for (int column = 0; column <= row; column++)\\n            {\\n                triangle[row][column] += Math.Min(triangle[row + 1][column], triangle[row + 1][column + 1]);\\n            }\\n        }\\n\\n        return triangle[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumTotal(IList<IList<int>> triangle)\\n    {\\n        int n = triangle.Count;\\n        int?[,] dp = new int?[n, n];\\n        return GetShortestPath(0, 0);\\n\\n        int GetShortestPath(int row, int column)\\n        {\\n            if (row == n) return 0;\\n            if (column == row + 1) return int.MaxValue;\\n\\n            return dp[row, column] ??= triangle[row][column] + Math.Min(GetShortestPath(row + 1, column), GetShortestPath(row + 1, column + 1));\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int MinimumTotal(IList<IList<int>> triangle)\\n    {\\n        int n = triangle.Count;\\n        int[] previous = new int[n];\\n        int[] current = triangle[n - 1].ToArray();\\n\\n        for (int row = n - 2; row >= 0; row--)\\n        {\\n            (previous, current) = (current, previous);\\n            for (int column = 0; column <= row; column++)\\n            {\\n                current[column] = triangle[row][column] + Math.Min(previous[column], previous[column + 1]);\\n            }\\n        }\\n\\n        return current[0];\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int MinimumTotal(IList<IList<int>> triangle)\\n    {\\n        for (int row = triangle.Count - 2; row >= 0; row--)\\n        {\\n            for (int column = 0; column <= row; column++)\\n            {\\n                triangle[row][column] += Math.Min(triangle[row + 1][column], triangle[row + 1][column + 1]);\\n            }\\n        }\\n\\n        return triangle[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001682,
                "title": "rust-concise-functional-style",
                "content": "I like this \"rusty\" solution where I avoid manual indexing and special treatment of edge cases.\\n\\n```\\nimpl Solution {\\n    pub fn minimum_total(triangle: Vec<Vec<i32>>) -> i32 {\\n        triangle\\n            .into_iter()\\n            .rev()\\n            .reduce(|prev, mut curr| {\\n                curr.iter_mut()\\n                    .zip(prev.windows(2).map(|w| w[0].min(w[1])))\\n                    .for_each(|(p, c)| *p += c);\\n                curr\\n            })\\n            .unwrap()[0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_total(triangle: Vec<Vec<i32>>) -> i32 {\\n        triangle\\n            .into_iter()\\n            .rev()\\n            .reduce(|prev, mut curr| {\\n                curr.iter_mut()\\n                    .zip(prev.windows(2).map(|w| w[0].min(w[1])))\\n                    .for_each(|(p, c)| *p += c);\\n                curr\\n            })\\n            .unwrap()[0]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737675,
                "title": "c-solution-with-just-4-lines-of-code",
                "content": "```\\n int minimumTotal(vector<vector<int>>& t) {\\n        for(int i = t.size()-1; i > 0; i--)\\n        for(int j =0; j < t[i].size() -1; j++)\\n        t[i-1][j] = t[i-1][j] + min(t[i][j], t[i][j+1]);\\n        return t[0][0];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int minimumTotal(vector<vector<int>>& t) {\\n        for(int i = t.size()-1; i > 0; i--)\\n        for(int j =0; j < t[i].size() -1; j++)\\n        t[i-1][j] = t[i-1][j] + min(t[i][j], t[i][j+1]);\\n        return t[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653606,
                "title": "c-recursive-to-memoization-conversion-with-comments",
                "content": "```\\n/*the recursive solution is pretty simple where we make 2 calls to the bottom one \\nand bottom right one and return the min out of it */\\n\\n  Recursive\\n\\nint solve(vector<vector<int>>&triangle,int n,int k,int i)\\n    {\\n        if(n==0)return 0;\\n        int l=solve(triangle,n-1,k+1,i)+triangle[k][i];\\n        int h=solve(triangle,n-1,k+1,i+1)+triangle[k][i];\\n        return min(l,h);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n       int n=triangle.size();\\n       int ans=solve(triangle,n,0,0);\\n       return ans;\\n    }\\n\\t //the complexity being approximately 2^n it fails 2 test cases\\n\\t \\n\\t  Memoization\\n\\t  \\n/*we only need to keep in mind the changing parameters and construct a dp accordingly,\\nnow it is a simple problem in which at every step u need  to make two choices if u are gonna take the bottom one or the bottom right one \\nand save the minimum out of them in our dp at each step and return */\\n\\n int solve(vector<vector<int>>&triangle,int n,int k,int i,vector<vector<int>>&dp)\\n    {\\n        if(n==0)return 0;\\n        if(dp[k][i]!=-1)return dp[k][i];\\n        int l=solve(triangle,n-1,k+1,i,dp)+triangle[k][i];  \\n        int h=solve(triangle,n-1,k+1,i+1,dp)+triangle[k][i];\\n        return dp[k][i]= min(l,h);\\n    } \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n       int n=triangle.size();\\n       vector<vector<int>>dp(n,vector<int>(n,-1));\\n       int ans=solve(triangle,n,0,0,dp);\\n       return ans;\\n    }\\n};\\n//pls upvote if u understood the solution :)",
                "solutionTags": [],
                "code": "```\\n/*the recursive solution is pretty simple where we make 2 calls to the bottom one \\nand bottom right one and return the min out of it */\\n\\n  Recursive\\n\\nint solve(vector<vector<int>>&triangle,int n,int k,int i)\\n    {\\n        if(n==0)return 0;\\n        int l=solve(triangle,n-1,k+1,i)+triangle[k][i];\\n        int h=solve(triangle,n-1,k+1,i+1)+triangle[k][i];\\n        return min(l,h);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n       int n=triangle.size();\\n       int ans=solve(triangle,n,0,0);\\n       return ans;\\n    }\\n\\t //the complexity being approximately 2^n it fails 2 test cases\\n\\t \\n\\t  Memoization\\n\\t  \\n/*we only need to keep in mind the changing parameters and construct a dp accordingly,\\nnow it is a simple problem in which at every step u need  to make two choices if u are gonna take the bottom one or the bottom right one \\nand save the minimum out of them in our dp at each step and return */\\n\\n int solve(vector<vector<int>>&triangle,int n,int k,int i,vector<vector<int>>&dp)\\n    {\\n        if(n==0)return 0;\\n        if(dp[k][i]!=-1)return dp[k][i];\\n        int l=solve(triangle,n-1,k+1,i,dp)+triangle[k][i];  \\n        int h=solve(triangle,n-1,k+1,i+1,dp)+triangle[k][i];\\n        return dp[k][i]= min(l,h);\\n    } \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n       int n=triangle.size();\\n       vector<vector<int>>dp(n,vector<int>(n,-1));\\n       int ans=solve(triangle,n,0,0,dp);\\n       return ans;\\n    }\\n};\\n//pls upvote if u understood the solution :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1601619,
                "title": "1-ms-2d-array-dp-small-code-easy-to-understand-with-comments-java",
                "content": "```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle){\\n        if(triangle.size() == 1)\\n            return triangle.get(0).get(0);     //base case \\n        int[][] dp = new int[triangle.size()][triangle.size()];  // new 2d array \\n        int result = Integer.MAX_VALUE; \\n        for(int i=0;i<triangle.size();i++)\\n            for(int j=0;j<=i;j++)\\n                dp[i][j] = triangle.get(i).get(j);  // creating the triangle in the 2d array like stairs\\n        \\n        for(int i=1;i< dp.length;i++){ //staring off with 1th row because 0th row is already the minimum sum\\n            for(int j=0;j<=i;j++){\\n                if(j==0){ //j==0 means its the left boundary of the triangle and only to reach is from the upper boundary\\n                    dp[i][j] += dp[i-1][j];\\n                }else if(j==i){ //j==i means its the right boundary of the triangle and only to reach is from the upper boundary\\n                    dp[i][j] += dp[i-1][j-1];\\n                }else{ // now its not the boundary, so there are two possible ways to reach, we have to use the minimum one\\n                    dp[i][j] += Math.min(dp[i-1][j-1],dp[i-1][j]);\\n                }\\n                if(i==dp.length-1) // if we are at the last row or bottom we keep on updating the result\\n                    result = Math.min(result,dp[i][j]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle){\\n        if(triangle.size() == 1)\\n            return triangle.get(0).get(0);     //base case \\n        int[][] dp = new int[triangle.size()][triangle.size()];  // new 2d array \\n        int result = Integer.MAX_VALUE; \\n        for(int i=0;i<triangle.size();i++)\\n            for(int j=0;j<=i;j++)\\n                dp[i][j] = triangle.get(i).get(j);  // creating the triangle in the 2d array like stairs\\n        \\n        for(int i=1;i< dp.length;i++){ //staring off with 1th row because 0th row is already the minimum sum\\n            for(int j=0;j<=i;j++){\\n                if(j==0){ //j==0 means its the left boundary of the triangle and only to reach is from the upper boundary\\n                    dp[i][j] += dp[i-1][j];\\n                }else if(j==i){ //j==i means its the right boundary of the triangle and only to reach is from the upper boundary\\n                    dp[i][j] += dp[i-1][j-1];\\n                }else{ // now its not the boundary, so there are two possible ways to reach, we have to use the minimum one\\n                    dp[i][j] += Math.min(dp[i-1][j-1],dp[i-1][j]);\\n                }\\n                if(i==dp.length-1) // if we are at the last row or bottom we keep on updating the result\\n                    result = Math.min(result,dp[i][j]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463331,
                "title": "java-clean-and-simple-solution-bottom-up-dp-o-mn-time-o-n-space",
                "content": "The `min[]` array stores the running minimum sum while iterating the list from bottom to top.\\n\\n```\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n        int m = triangle.size(), n = triangle.get(m-1).size();\\n        int[] min = new int[n+1];\\n        for (int i=m-1; i >=0; i--) {\\n            for (int j=0; j <= i; j++) {\\n                min[j] = Math.min(min[j], min[j+1]) + triangle.get(i).get(j);\\n            }\\n        }\\n        return min[0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int minimumTotal(List<List<Integer>> triangle) {\\n        int m = triangle.size(), n = triangle.get(m-1).size();\\n        int[] min = new int[n+1];\\n        for (int i=m-1; i >=0; i--) {\\n            for (int j=0; j <= i; j++) {\\n                min[j] = Math.min(min[j], min[j+1]) + triangle.get(i).get(j);\\n            }\\n        }\\n        return min[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1459357,
                "title": "python-bottom-up-dp-clean-concise",
                "content": "```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        n = len(triangle)\\n        for r in range(1, n):\\n            for c in range(r+1):\\n                if c == 0:\\n                    triangle[r][c] += triangle[r-1][c]\\n                elif c == r:\\n                    triangle[r][c] += triangle[r-1][c-1]\\n                else:\\n                    triangle[r][c] += min(triangle[r-1][c-1], triangle[r-1][c])\\n        \\n        ans = math.inf\\n        for c in range(n):\\n            ans = min(ans, triangle[n-1][c])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N^2)`, where `N <= 200` is length of triangle.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        n = len(triangle)\\n        for r in range(1, n):\\n            for c in range(r+1):\\n                if c == 0:\\n                    triangle[r][c] += triangle[r-1][c]\\n                elif c == r:\\n                    triangle[r][c] += triangle[r-1][c-1]\\n                else:\\n                    triangle[r][c] += min(triangle[r-1][c-1], triangle[r-1][c])\\n        \\n        ans = math.inf\\n        for c in range(n):\\n            ans = min(ans, triangle[n-1][c])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169756,
                "title": "java-clean-dp",
                "content": "```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        List<Integer> dp = new ArrayList<Integer>(triangle.get(triangle.size()-1));\\n        for(int i=triangle.size()-2; i>=0; i--){\\n            for(int j=0; j<=i; j++){\\n                dp.set(j, Math.min(dp.get(j), dp.get(j+1)) + triangle.get(i).get(j));\\n            }\\n        }\\n        return dp.get(0);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        List<Integer> dp = new ArrayList<Integer>(triangle.get(triangle.size()-1));\\n        for(int i=triangle.size()-2; i>=0; i--){\\n            for(int j=0; j<=i; j++){\\n                dp.set(j, Math.min(dp.get(j), dp.get(j+1)) + triangle.get(i).get(j));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 827636,
                "title": "python-dp-solution-beats-87-of-solutions-annotated",
                "content": "I\\'ve added my solution to the **Triangle** problem, initially I had a hard time understanding how to do it at first but once I proved that it could be done by ***Dynamic Programming***  and with the help of some visuals (**If you don\\'t have a whiteboard or sketchpad I highly recommend getting one**) this problem actually wasn\\'t too bad!\\n\\nSo with **Dynamic programming** we rely on previously calculated values to derive the current solution to a **subproblem**. So what subproblems are we trying to solve?? Well, we want to get the sum from the smallest adjacent path so when we reach the end of said path we\\'ll have a list of calculated path sums from which we can choose the smallest value. \\n\\nJust FYI, an adjacent path means that we can only look at values that are at least one index away from the previous.\\n\\nExample:\\n\\n**Matrix**\\n[\\n[2],\\n[3,**4**],\\n[6,5,7],\\n[4,1,8,3]\\n]\\n\\nIf we\\'re at **matrix[1][1]** then we can only move to **matrix[2][1]** or **matrix[2][2]**, or in this case from **4 -> 5** or **4 -> 7**.\\n\\nBack to subproblems! In order to begin using previous values to solve current subproblems, we need to have initial data for us to use. This is where we calculate the previous sums straight down and diagonally from the starting index, this gives us a **\"border\"** from which we can start calculating the internal values. If you\\'re still a bit confused here is an example.\\n\\n[\\n[**2**],\\n[**5**,**6**],\\n[**11**,5,**13**],\\n[**15**,1,8,**16**]\\n]\\n\\nUsing the previous matrix we calculated all the path sums vertically and diagonally. Now if we started at **matrix[2][1]** we can refer to **matrix[1][1]** or **matrix[1][0]** for previous values. Using this logic we can find out the path sums for every possible path in the triangle.\\n\\nThis essentially reduces our problem to `dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]`\\n\\nAfter everything is said and done, the final row of our matrix should look like this **[15,11,18,16]**, it then becomes a matter of retrieving the smallest value from that row.\\n\\nI\\'ve annotated my code with this thought process, hopefully it all makes sense.\\n\\n```\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        \"\"\"\\n        :type triangle: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# Edge cases for small input\\n        if not triangle: \\n            return 0\\n        if len(triangle) < 2:\\n            return triangle[0][0]\\n        if len(triangle) < 3:\\n            return triangle[0][0] + min(triangle[1])\\n        \\n        n, m = len(triangle), len(triangle[-1])\\n        \\n\\t\\t# Construct auxillary DP matrix and setting initial value with first in triangle input\\n        dp = [[0] * (m) for i in range(n)]\\n        dp[0][0] = triangle[0][0]\\n        \\n\\t\\t# Calculate sums from start to bottom (vertically)\\n        for i in range(1, n):\\n            dp[i][0] = triangle[i][0] + dp[i-1][0]\\n            \\n\\t\\t# Calculate sums from start to last value in last list (diagonally)\\n        for j in range(1, m):\\n            dp[j][j] = triangle[j][j] + dp[j-1][j-1]\\n            \\n\\t\\t# Now that we\\'ve calculated our initial border values we can now use previous info to build up our answer\\n        for i in range(2, n):\\n            for j in range(1, len(triangle[i])-1):\\n                dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\\n        \\n\\t\\t# Bottom row will hold the path sums for all possible rows above, just find min of last row\\n        return min(dp[m-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        \"\"\"\\n        :type triangle: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# Edge cases for small input\\n        if not triangle: \\n            return 0\\n        if len(triangle) < 2:\\n            return triangle[0][0]\\n        if len(triangle) < 3:\\n            return triangle[0][0] + min(triangle[1])\\n        \\n        n, m = len(triangle), len(triangle[-1])\\n        \\n\\t\\t# Construct auxillary DP matrix and setting initial value with first in triangle input\\n        dp = [[0] * (m) for i in range(n)]\\n        dp[0][0] = triangle[0][0]\\n        \\n\\t\\t# Calculate sums from start to bottom (vertically)\\n        for i in range(1, n):\\n            dp[i][0] = triangle[i][0] + dp[i-1][0]\\n            \\n\\t\\t# Calculate sums from start to last value in last list (diagonally)\\n        for j in range(1, m):\\n            dp[j][j] = triangle[j][j] + dp[j-1][j-1]\\n            \\n\\t\\t# Now that we\\'ve calculated our initial border values we can now use previous info to build up our answer\\n        for i in range(2, n):\\n            for j in range(1, len(triangle[i])-1):\\n                dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\\n        \\n\\t\\t# Bottom row will hold the path sums for all possible rows above, just find min of last row\\n        return min(dp[m-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384086,
                "title": "concise-rust-0ms-o-1-extra-space",
                "content": "```rust\\nimpl Solution {\\n    pub fn minimum_total(mut triangle: Vec<Vec<i32>>) -> i32 {\\n        let rows = triangle.len();\\n        (0..rows-1).rev().for_each(|r| (0..r+1).for_each(|c| \\n               triangle[r][c] += std::cmp::min(triangle[r+1][c], triangle[r+1][c+1])));\\n        triangle[0][0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn minimum_total(mut triangle: Vec<Vec<i32>>) -> i32 {\\n        let rows = triangle.len();\\n        (0..rows-1).rev().for_each(|r| (0..r+1).for_each(|c| \\n               triangle[r][c] += std::cmp::min(triangle[r+1][c], triangle[r+1][c+1])));\\n        triangle[0][0]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359374,
                "title": "java-dfs-with-memoization-and-helpful-comments",
                "content": "Doing normal dfs will ensure that you hit the time limit. If you go through a simple example you will see that certain path will be reprocessed. It is best to save the best sum for each node and abort if you encounter the same path.\\nThis solution does not attempt to lower space to n, it is however very easy to follow and runs quickly.\\n\\nThe idea is simple:\\n\\n1. Use DFS to get to the bottom of the triangle.\\n2. At each node, save the best sum.\\n3. The best sum is calculated as: currentNode + min(leftChild, rightChild)\\n4. The base case should return 0 as the sum, if you are at the last level, the left and right child will return 0. As such the best sum will simply be the currentNode.\\n```\\nclass Solution {        \\n    \\n    int memoized[][];\\n    \\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        memoized = new int[triangle.size()][triangle.size()];\\n        \\n        // FILL ALL ELEMENTS WITH DEFAULT TO CHECK IF IT HAS BEEN POPULATED\\n        for (int[] row : memoized) {\\n            Arrays.fill(row, Integer.MIN_VALUE);\\n        }\\n        \\n        return minimumTotal(triangle, 0, 0);\\n    }\\n    \\n    public int minimumTotal(List<List<Integer>> triangle, int level, int col) {\\n        // BASE CASE - NO MORE ROWS TO PROCESS, RETURN 0 SIZE THE BEST SUM AFTER THE LAST ROW IS 0\\n        if (level == triangle.size()) {\\n            return 0;\\n        }\\n        \\n        // IF WE PROCESSED THIS COMBO BEFORE, RETURN THE BEST RECORDED SUM\\n        if (memoized[level][col] != Integer.MIN_VALUE) {\\n            return memoized[level][col];\\n        }\\n        \\n        final List<Integer> nums = triangle.get(level);\\n        int num = nums.get(col);\\n        \\n        // WE CAN GO LEFT OR RIGHT, NODES HAVE TO BE ADJACENT\\n        int leftSum = minimumTotal(triangle, level + 1, col);\\n        int rightSum = minimumTotal(triangle, level + 1, col + 1);\\n        \\n        // TAKE THE BEST OF THE LEFT OR RIGHT AND ADD THE CURRENT NODE\\n        int currentBestSum = num + Math.min(leftSum, rightSum);\\n        \\n        // SAVE THIS RESULT IN CASE WE WANT TO PROCESS THIS TREE AGAIN\\n        memoized[level][col] = currentBestSum;\\n         \\n        return currentBestSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {        \\n    \\n    int memoized[][];\\n    \\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        memoized = new int[triangle.size()][triangle.size()];\\n        \\n        // FILL ALL ELEMENTS WITH DEFAULT TO CHECK IF IT HAS BEEN POPULATED\\n        for (int[] row : memoized) {\\n            Arrays.fill(row, Integer.MIN_VALUE);\\n        }\\n        \\n        return minimumTotal(triangle, 0, 0);\\n    }\\n    \\n    public int minimumTotal(List<List<Integer>> triangle, int level, int col) {\\n        // BASE CASE - NO MORE ROWS TO PROCESS, RETURN 0 SIZE THE BEST SUM AFTER THE LAST ROW IS 0\\n        if (level == triangle.size()) {\\n            return 0;\\n        }\\n        \\n        // IF WE PROCESSED THIS COMBO BEFORE, RETURN THE BEST RECORDED SUM\\n        if (memoized[level][col] != Integer.MIN_VALUE) {\\n            return memoized[level][col];\\n        }\\n        \\n        final List<Integer> nums = triangle.get(level);\\n        int num = nums.get(col);\\n        \\n        // WE CAN GO LEFT OR RIGHT, NODES HAVE TO BE ADJACENT\\n        int leftSum = minimumTotal(triangle, level + 1, col);\\n        int rightSum = minimumTotal(triangle, level + 1, col + 1);\\n        \\n        // TAKE THE BEST OF THE LEFT OR RIGHT AND ADD THE CURRENT NODE\\n        int currentBestSum = num + Math.min(leftSum, rightSum);\\n        \\n        // SAVE THIS RESULT IN CASE WE WANT TO PROCESS THIS TREE AGAIN\\n        memoized[level][col] = currentBestSum;\\n         \\n        return currentBestSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320849,
                "title": "c-80-beat-search-grid-solution-o-n-problem-size",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        if (triangle.size() <= 0) { return 0; }\\n        \\n        vector<vector<int>> aSearch;\\n        \\n        vector<int> aRow0;\\n        aRow0.push_back(triangle[0][0]);\\n        aSearch.push_back(aRow0);\\n        \\n        for (int aDepth=1;aDepth<triangle.size();aDepth++) {\\n            int aDepth1 = aDepth - 1;\\n            vector<int> aRow;    \\n            for (int i=0;i<triangle[aDepth].size();i++) {\\n                if (i == 0) {\\n                    aRow.push_back(triangle[aDepth][0] + aSearch[aDepth1][0]);\\n                } else if (i == (triangle[aDepth].size() - 1)) {\\n                    aRow.push_back(triangle[aDepth].back() + aSearch[aDepth1].back());\\n                } else {\\n                    aRow.push_back(triangle[aDepth][i] + min( aSearch[aDepth1][i - 1], aSearch[aDepth1][i] ));\\n                }\\n            }\\n            aSearch.push_back(aRow);\\n        }\\n        \\n        //Now we pick the minimum element from our search grid...\\n        int aResult = aSearch[triangle.size()-1][0];\\n        for (int i=1;i<aSearch[triangle.size()-1].size();i++) {\\n            aResult = min(aResult, aSearch[triangle.size()-1][i]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nThis is essentially a dynamic programming solution. We store the minimum routes in a search triangle. Then we choose the lowest node from the bottom row. There may be a way to do this with much less extra space require...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        if (triangle.size() <= 0) { return 0; }\\n        \\n        vector<vector<int>> aSearch;\\n        \\n        vector<int> aRow0;\\n        aRow0.push_back(triangle[0][0]);\\n        aSearch.push_back(aRow0);\\n        \\n        for (int aDepth=1;aDepth<triangle.size();aDepth++) {\\n            int aDepth1 = aDepth - 1;\\n            vector<int> aRow;    \\n            for (int i=0;i<triangle[aDepth].size();i++) {\\n                if (i == 0) {\\n                    aRow.push_back(triangle[aDepth][0] + aSearch[aDepth1][0]);\\n                } else if (i == (triangle[aDepth].size() - 1)) {\\n                    aRow.push_back(triangle[aDepth].back() + aSearch[aDepth1].back());\\n                } else {\\n                    aRow.push_back(triangle[aDepth][i] + min( aSearch[aDepth1][i - 1], aSearch[aDepth1][i] ));\\n                }\\n            }\\n            aSearch.push_back(aRow);\\n        }\\n        \\n        //Now we pick the minimum element from our search grid...\\n        int aResult = aSearch[triangle.size()-1][0];\\n        for (int i=1;i<aSearch[triangle.size()-1].size();i++) {\\n            aResult = min(aResult, aSearch[triangle.size()-1][i]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189338,
                "title": "javascript-simple-5-line-dp-logic-beats-100",
                "content": "```\n/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n    // bottom-up\n    let n = triangle.length;\n    let dp = triangle[n-1];\n    for(let i=n-2; i>-1; i--){\n        for(let j=0; j<triangle[i].length; j++){\n            dp[j] = Math.min(dp[j], dp[j+1]) + triangle[i][j];\n        }\n    }\n    return dp[0];\n};\n```\n\nBottom-up approach:\n\nsteps:\n1. Define array ```dp[]``` = last(bottom) level of triangle\n2. start from the last but one level to the top level (```i=triangle.length-2```)\n3. for each level ```i```: \n\t- for each element ```j``` in that level:\n\t\t- find the minimum of the adjacent numbers on the row below (```dp[j], dp[j+1]```)\n\t\t- sum it (minimum val) with the current element at ```j``` in ```triangle[i]```\n\t\t- replace the value at ```j``` position in ```dp[]``` i.e. ```dp[j]```\n\nby doing this iteratively till top we are actually elemenating/ ignoring 1 last element in ```dp[]``` in consideration everytime we go to one level up\n\nin the last iteration we will only have 1 element to consider, which will be on the first position\n\nand we return ```dp[0]```",
                "solutionTags": [],
                "code": "```\n/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n    // bottom-up\n    let n = triangle.length;\n    let dp = triangle[n-1];\n    for(let i=n-2; i>-1; i--){\n        for(let j=0; j<triangle[i].length; j++){\n            dp[j] = Math.min(dp[j], dp[j+1]) + triangle[i][j];\n        }\n    }\n    return dp[0];\n};\n```\n```dp[]```\n```i=triangle.length-2```\n```i```\n```j```\n```dp[j], dp[j+1]```\n```j```\n```triangle[i]```\n```j```\n```dp[]```\n```dp[j]```\n```dp[]```\n```dp[0]```",
                "codeTag": "Unknown"
            },
            {
                "id": 38895,
                "title": "my-o-n-cpp-code-using-dp",
                "content": "    class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int>>& triangle) \\n        {\\n            // s[r][c] = min(s[r+1][c], s[r+1][c+1])\\n            // s[r][c] = triangle[r][c] if r is the last row\\n            \\n            vector<int> minTotalVec(triangle.back());\\n            for(int i = triangle.size()-2; i >=0; i--)\\n                for(int j = 0; j <= i; j++)\\n                {\\n                    int sum1 = minTotalVec[j] + triangle[i][j];\\n                    int sum2 = minTotalVec[j+1] + triangle[i][j];\\n                    \\n                    minTotalVec[j] = std::min(sum1, sum2);\\n                }\\n                \\n            return minTotalVec[0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int>>& triangle) \\n        {\\n            // s[r][c] = min(s[r+1][c], s[r+1][c+1])\\n            // s[r][c] = triangle[r][c] if r is the last row\\n            \\n            vector<int> minTotalVec(triangle.back());\\n            for(int i = triangle.size()-2; i >=0; i--)\\n                for(int j = 0; j <= i; j++)\\n                {\\n                    int sum1 = minTotalVec[j] + triangle[i][j];\\n                    int sum2 = minTotalVec[j+1] + triangle[i][j];\\n                    \\n                    minTotalVec[j] = std::min(sum1, sum2);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 38958,
                "title": "c-simple-solution",
                "content": "  \\n\\n      int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<int> min;\\n        int n = triangle.size();\\n        for (int i = n-2; i >= 0; --i) {\\n            for (int j = 0; j < triangle[i].size(); ++j) {\\n                triangle[i][j]+=triangle[i+1][j]<triangle[i+1][j+1]?triangle[i+1][j]:triangle[i+1][j+1];\\n            }\\n        }\\n        return triangle[0][0];\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "  \\n\\n      int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<int> min;\\n        int n = triangle.size();\\n        for (int i = n-2; i >= 0; --i) {\\n            for (int j = 0; j < triangle[i].size(); ++j) {\\n                triangle[i][j]+=triangle[i+1][j]<triangle[i+1][j+1]?triangle[i+1][j]:triangle[i+1][j+1];\\n            }\\n        }\\n        return triangle[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 38970,
                "title": "o-n-2-time-o-n-space-java-dp-solution",
                "content": "This bottom-up solution uses the array mins[] to store the minimum sum\\nof each path until the current number.\\n\\n\\n\\n    public class Solution {\\n        public int minimumTotal(List<List<Integer>> triangle) {\\n            if(triangle==null||triangle.isEmpty()) return 0;\\n            final int height=triangle.size();\\n            int[] mins = new int[height];\\n            for(int i=0;i<height;i++){\\n                mins[i]=triangle.get(height-1).get(i);\\n            }\\n            \\n            for(int i=height-1;i>0;i--){\\n                for(int j=0;j<i;j++){\\n                    mins[j]=Math.min(mins[j+1],mins[j])+triangle.get(i-1).get(j);\\n                }\\n            }\\n            return mins[0];\\n        }\\n     \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int minimumTotal(List<List<Integer>> triangle) {\\n            if(triangle==null||triangle.isEmpty()) return 0;\\n            final int height=triangle.size();\\n            int[] mins = new int[height];\\n            for(int i=0;i<height;i++){\\n                mins[i]=triangle.get(height-1).get(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38992,
                "title": "iterative-13ms-solution-c-with-explaination",
                "content": "    class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int> > &a) {\\n            vector<int> min;\\n            int n = a.size();\\n            \\n            // push the last row to min vector\\n            for (int i = 0; i <= n; ++i) {\\n                min.push_back(a[n-1][i]);\\n            }\\n            \\n            vector<int>& row_below = min;\\n            \\n            // Logic : at each element of the row , check against\\n            // two elements, and take minimum.\\n            // its a DP, as you add to the already minimum sum\\n            // at each stage\\n            for (int i = n-2; i >= 0; --i) {\\n                vector<int> cur_row;\\n                for (int j = 0; j < a[i].size(); ++j) {\\n                    if (row_below[j] < row_below[j+1]) {\\n                        cur_row.push_back(row_below[j]+a[i][j]);\\n                    } else {\\n                        cur_row.push_back(row_below[j+1]+a[i][j]);\\n                    }\\n                }\\n                row_below.resize(0);\\n                row_below = cur_row;\\n            }\\n            return row_below[0];\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int minimumTotal(vector<vector<int> > &a) {\\n            vector<int> min;\\n            int n = a.size();\\n            \\n            // push the last row to min vector\\n            for (int i = 0; i <= n; ++i) {\\n                min.push_back(a[n-1][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3815111,
                "title": "easy-c-solution",
                "content": "# PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION\\n# Approach\\nIt starts by initializing an integer variable n with the size of the triangle vector, which gives the number of rows in the triangle.\\n\\nIt creates a 1D vector dp of size n and initializes all its elements to zero. This vector will be used to store the minimum path sums from the bottom row to each element in the row above.\\n\\nIt then iterates over the last row of the triangle (the bottom row) and assigns the elements of that row to the corresponding elements in the dp vector. This step essentially initializes the dp vector with the values of the bottom row of the triangle.\\n\\nThe code then proceeds to update the dp vector row by row, starting from the second-to-last row (index n-2) and moving upwards. For each element in the current row, it calculates the minimum path sum by taking the minimum between the current element and the element directly below it in the dp vector, and then adds the value of the corresponding element in the triangle. This step effectively computes the minimum path sum from the current element to the bottom of the triangle.\\n\\nAfter the second loop finishes, the dp vector will hold the minimum path sums from the top to each element of the bottom row.\\n\\nFinally, the function returns the value stored in dp[0], which represents the minimum path sum from the top to the bottom of the triangle.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<int>dp(n,0);\\n        for(int i = 0;i<n;i++)\\n        {\\n            // why n-1 .because we are going from bottom to up  \\n            dp[i]=triangle[n-1][i];\\n        }\\n        for(int i= n-2;i>=0;i--)\\n        {\\n            for(int j = 0;j<triangle[i].size();j++)\\n            {\\n                dp[j]=min(dp[j],dp[j+1])+ triangle[i][j];\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<int>dp(n,0);\\n        for(int i = 0;i<n;i++)\\n        {\\n            // why n-1 .because we are going from bottom to up  \\n            dp[i]=triangle[n-1][i];\\n        }\\n        for(int i= n-2;i>=0;i--)\\n        {\\n            for(int j = 0;j<triangle[i].size();j++)\\n            {\\n                dp[j]=min(dp[j],dp[j+1])+ triangle[i][j];\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773796,
                "title": "best-optimal-solutions-with-memoization-tabulation-space-optimization",
                "content": "# Request\\nIf you found it helpful, kindly consider giving it an upvote.\\n# Important\\nHere base case formulation & how the base case of memoization is getting converted for tabulation is the most important thing.\\n\\n# Recursion+Memoization\\n```\\nclass Solution\\n{\\nprivate:\\n    int solve(int i,int j,vector<vector<int>>& triangle,vector<vector<int>>& DP,int n)\\n    {\\n        if(i == n-1)\\n        {\\n            return triangle[i][j];\\n        }\\n    //    yaha i>n or i<0 wale base case ki bhi jrurt nahi hai bcoz we will never go out of bound\\n        int opt1 = solve(i+1,j,triangle,DP,n)+triangle[i][j];\\n        int opt2 = solve(i+1,j+1,triangle,DP,n)+triangle[i][j];\\n        return DP[i][j] = min(opt1,opt2);\\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle)\\n    {\\n        int n = triangle.size();\\n        vector<vector<int>> DP;\\n        for(int i=1;i<=n;i++)\\n        {\\n           vector<int> temp(i,-1);\\n           DP.push_back(temp);\\n        }\\n        return solve(0,0,triangle,DP,n);\\n    }\\n};\\n```\\n# Tabulation\\n```\\nclass Solution\\n{\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle)\\n    {\\n        int n = triangle.size();\\n        vector<vector<int>> DP;\\n        for(int i=1;i<=n;i++)\\n        {\\n           vector<int> temp(i,-1);\\n           DP.push_back(temp);\\n        }\\n\\n        // when you will observe the base case of recursion + memoisation you will see that the base case is diff from other grid problems here in base case for each i = n-1 we are returning triangle[n-1][j] where j will be 0 to n-1 so out base case for tabulation will be a for loop \\n        \\n        // base case\\n        for(int j=0;j<n;j++)\\n        {\\n            DP[n-1][j] = triangle[n-1][j];\\n        }\\n\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                int op1 = DP[i+1][j]+triangle[i][j];\\n                int op2 = DP[i+1][j+1] + triangle[i][j];\\n                DP[i][j] = min(op1,op2);\\n            }\\n        }\\n        return DP[0][0];\\n    }\\n};\\n```\\n# Optimized Space\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle)\\n    {\\n        // every time we need is previous row in bottom up of triangle i.e. if we are on rwo 4 then we need row 5\\n        int n = triangle.size();\\n        vector<int> prev(n,-1);\\n        //base case\\n        for(int j=0;j<n;j++)\\n        {\\n            prev[j] = triangle[n-1][j];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            //temp storing curr row\\n            vector<int> temp(n,-1);\\n            for(int j=i;j>=0;j--)\\n            {\\n                int op1 = prev[j]+triangle[i][j];\\n                int op2 = prev[j+1] + triangle[i][j];\\n                temp[j] = min(op1,op2);\\n            }\\n            prev = temp;\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    int solve(int i,int j,vector<vector<int>>& triangle,vector<vector<int>>& DP,int n)\\n    {\\n        if(i == n-1)\\n        {\\n            return triangle[i][j];\\n        }\\n    //    yaha i>n or i<0 wale base case ki bhi jrurt nahi hai bcoz we will never go out of bound\\n        int opt1 = solve(i+1,j,triangle,DP,n)+triangle[i][j];\\n        int opt2 = solve(i+1,j+1,triangle,DP,n)+triangle[i][j];\\n        return DP[i][j] = min(opt1,opt2);\\n    }\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle)\\n    {\\n        int n = triangle.size();\\n        vector<vector<int>> DP;\\n        for(int i=1;i<=n;i++)\\n        {\\n           vector<int> temp(i,-1);\\n           DP.push_back(temp);\\n        }\\n        return solve(0,0,triangle,DP,n);\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle)\\n    {\\n        int n = triangle.size();\\n        vector<vector<int>> DP;\\n        for(int i=1;i<=n;i++)\\n        {\\n           vector<int> temp(i,-1);\\n           DP.push_back(temp);\\n        }\\n\\n        // when you will observe the base case of recursion + memoisation you will see that the base case is diff from other grid problems here in base case for each i = n-1 we are returning triangle[n-1][j] where j will be 0 to n-1 so out base case for tabulation will be a for loop \\n        \\n        // base case\\n        for(int j=0;j<n;j++)\\n        {\\n            DP[n-1][j] = triangle[n-1][j];\\n        }\\n\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                int op1 = DP[i+1][j]+triangle[i][j];\\n                int op2 = DP[i+1][j+1] + triangle[i][j];\\n                DP[i][j] = min(op1,op2);\\n            }\\n        }\\n        return DP[0][0];\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle)\\n    {\\n        // every time we need is previous row in bottom up of triangle i.e. if we are on rwo 4 then we need row 5\\n        int n = triangle.size();\\n        vector<int> prev(n,-1);\\n        //base case\\n        for(int j=0;j<n;j++)\\n        {\\n            prev[j] = triangle[n-1][j];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            //temp storing curr row\\n            vector<int> temp(n,-1);\\n            for(int j=i;j>=0;j--)\\n            {\\n                int op1 = prev[j]+triangle[i][j];\\n                int op2 = prev[j+1] + triangle[i][j];\\n                temp[j] = min(op1,op2);\\n            }\\n            prev = temp;\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704103,
                "title": "simple-c-recursive-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int j,vector<vector<int>>& triangle,vector<vector<int>> &dp){\\n    int n=triangle.size();\\n     if(i==n-1){\\n        return triangle[i][j];\\n\\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n  \\n    int d=INT_MAX;\\n    int r=INT_MAX;\\n\\n        d=solve(i+1,j,triangle,dp);\\n        r=solve(i+1,j+1,triangle,dp);\\n    \\n   \\n    return dp[i][j]=triangle[i][j]+min({d,r});\\n\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n         int n=triangle.size();\\n    \\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(0,0,triangle,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int j,vector<vector<int>>& triangle,vector<vector<int>> &dp){\\n    int n=triangle.size();\\n     if(i==n-1){\\n        return triangle[i][j];\\n\\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n  \\n    int d=INT_MAX;\\n    int r=INT_MAX;\\n\\n        d=solve(i+1,j,triangle,dp);\\n        r=solve(i+1,j+1,triangle,dp);\\n    \\n   \\n    return dp[i][j]=triangle[i][j]+min({d,r});\\n\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n         int n=triangle.size();\\n    \\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return solve(0,0,triangle,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492469,
                "title": "c-o-n-2-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& t) {\\n        for(int i = t.size()-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j < t[i].size() ; j++)\\n            {\\n                t[i][j] += min(t[i+1][j],t[i+1][j+1]);\\n            }\\n        }\\n        return t[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& t) {\\n        for(int i = t.size()-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j < t[i].size() ; j++)\\n            {\\n                t[i][j] += min(t[i+1][j],t[i+1][j+1]);\\n            }\\n        }\\n        return t[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416768,
                "title": "java-dynamic-programming-triangle",
                "content": "\\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        List<int[]> ways = new ArrayList<>();\\n        int capacity = 3;\\n        int[] tmp;\\n        ways.add(new int[]{Integer.MAX_VALUE, triangle.get(0).get(0),Integer.MAX_VALUE});\\n        for (int i = 1; i < triangle.size(); i++)\\n        {\\n            capacity++;\\n            tmp = new int[capacity];\\n            tmp[0] = Integer.MAX_VALUE;\\n            tmp[capacity - 1] = Integer.MAX_VALUE;\\n            for (int j = 1; j < capacity - 1; j++)\\n                tmp[j] = (Math.min(ways.get(i - 1)[j - 1], ways.get(i - 1)[j]) + triangle.get(i).get(j - 1));\\n            ways.add(tmp);\\n        }\\n        int min = ways.get(ways.size() - 1)[1];\\n        for (Integer num :ways.get(ways.size() - 1))\\n            min = Math.min(min, num);\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        List<int[]> ways = new ArrayList<>();\\n        int capacity = 3;\\n        int[] tmp;\\n        ways.add(new int[]{Integer.MAX_VALUE, triangle.get(0).get(0),Integer.MAX_VALUE});\\n        for (int i = 1; i < triangle.size(); i++)\\n        {\\n            capacity++;\\n            tmp = new int[capacity];\\n            tmp[0] = Integer.MAX_VALUE;\\n            tmp[capacity - 1] = Integer.MAX_VALUE;\\n            for (int j = 1; j < capacity - 1; j++)\\n                tmp[j] = (Math.min(ways.get(i - 1)[j - 1], ways.get(i - 1)[j]) + triangle.get(i).get(j - 1));\\n            ways.add(tmp);\\n        }\\n        int min = ways.get(ways.size() - 1)[1];\\n        for (Integer num :ways.get(ways.size() - 1))\\n            min = Math.min(min, num);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280855,
                "title": "space-optimized-follow-up-c",
                "content": "# Complexity\\n- Time complexity:\\n  O(n^2)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int minimumTotal_tabulation_spaceOptimized(vector<vector<int>>&triangle){\\n      //space complextiy O(n) and Auxiliary space is O(1)\\n       int n=triangle.size();\\n       vector<int>dp(n,1e9);\\n       dp[0]=triangle[0][0];\\n       int prev;\\n       for(int i=1;i<n;i++){\\n           prev=dp[0];\\n           dp[0]=prev+triangle[i][0];\\n           for(int j=1;j<=i;j++){\\n               int curr=dp[j];\\n               dp[j]=triangle[i][j]+min(dp[j],prev);\\n               prev=curr;\\n           }\\n       }\\n       int ans=1e9;\\n       for(int i=0;i<n;i++)ans=min(ans,dp[i]);\\n       return ans;\\n   }\\n \\n\\n    int minimumTotal_tabulation(vector<vector<int>>&triangle){\\n        //space complexity is O(n) and Auxiliary space is also O(n)\\n       int n=triangle.size();\\n       vector<int>dp(n,1e9);\\n       dp[0]=triangle[0][0];\\n       for(int i=1;i<n;i++){\\n           vector<int>prev=dp;//Auxiliary space taken by prev vector\\n           dp[0]=prev[0]+triangle[i][0];\\n           for(int j=1;j<=i;j++){\\n               dp[j]=triangle[i][j]+min(prev[j],prev[j-1]);\\n           }\\n       }\\n       int ans=1e9;\\n       for(int i=0;i<n;i++)ans=min(ans,dp[i]);\\n       return ans;\\n   }\\n\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return minimumTotal_tabulation_spaceOptimized(triangle);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minimumTotal_tabulation_spaceOptimized(vector<vector<int>>&triangle){\\n      //space complextiy O(n) and Auxiliary space is O(1)\\n       int n=triangle.size();\\n       vector<int>dp(n,1e9);\\n       dp[0]=triangle[0][0];\\n       int prev;\\n       for(int i=1;i<n;i++){\\n           prev=dp[0];\\n           dp[0]=prev+triangle[i][0];\\n           for(int j=1;j<=i;j++){\\n               int curr=dp[j];\\n               dp[j]=triangle[i][j]+min(dp[j],prev);\\n               prev=curr;\\n           }\\n       }\\n       int ans=1e9;\\n       for(int i=0;i<n;i++)ans=min(ans,dp[i]);\\n       return ans;\\n   }\\n \\n\\n    int minimumTotal_tabulation(vector<vector<int>>&triangle){\\n        //space complexity is O(n) and Auxiliary space is also O(n)\\n       int n=triangle.size();\\n       vector<int>dp(n,1e9);\\n       dp[0]=triangle[0][0];\\n       for(int i=1;i<n;i++){\\n           vector<int>prev=dp;//Auxiliary space taken by prev vector\\n           dp[0]=prev[0]+triangle[i][0];\\n           for(int j=1;j<=i;j++){\\n               dp[j]=triangle[i][j]+min(prev[j],prev[j-1]);\\n           }\\n       }\\n       int ans=1e9;\\n       for(int i=0;i<n;i++)ans=min(ans,dp[i]);\\n       return ans;\\n   }\\n\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        return minimumTotal_tabulation_spaceOptimized(triangle);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233634,
                "title": "tabulation-with-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntriangle[i][j] represents minimum path sum to bottom from {i,j}\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n\\n        int n  = triangle.size()  ;\\n        int m = triangle[n-1].size()  ;\\n        int k = 2 ;\\n        for(int i = n - 2 ; i>= 0 ; i--,k++)\\n        {\\n            for(int j = m - k ; j >= 0 ; j--)\\n            {  \\n                 \\n                triangle[i][j] =  triangle[i][j] + min(triangle[i+1][j],triangle[i+1][j+1]) ;\\n\\n            }\\n            cout << endl;\\n        }\\n       \\n        return triangle[0][0] ;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n\\n        int n  = triangle.size()  ;\\n        int m = triangle[n-1].size()  ;\\n        int k = 2 ;\\n        for(int i = n - 2 ; i>= 0 ; i--,k++)\\n        {\\n            for(int j = m - k ; j >= 0 ; j--)\\n            {  \\n                 \\n                triangle[i][j] =  triangle[i][j] + min(triangle[i+1][j],triangle[i+1][j+1]) ;\\n\\n            }\\n            cout << endl;\\n        }\\n       \\n        return triangle[0][0] ;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3075936,
                "title": "java-simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        int sum=0;\\n\\n        for(int i=triangle.size()-2;i>=0;i--){\\n            for(int j=0;j<triangle.get(i).size();j++){\\n                int first=triangle.get(i+1).get(j);\\n                int second=triangle.get(i+1).get(j+1);\\n                int min=Math.min(first,second);\\n                sum=min+triangle.get(i).get(j);\\n                triangle.get(i).set(j,sum);\\n            }\\n        }\\n        return triangle.get(0).get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> triangle) {\\n        int sum=0;\\n\\n        for(int i=triangle.size()-2;i>=0;i--){\\n            for(int j=0;j<triangle.get(i).size();j++){\\n                int first=triangle.get(i+1).get(j);\\n                int second=triangle.get(i+1).get(j+1);\\n                int min=Math.min(first,second);\\n                sum=min+triangle.get(i).get(j);\\n                triangle.get(i).set(j,sum);\\n            }\\n        }\\n        return triangle.get(0).get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072479,
                "title": "triangle-dp-solution-leetcode",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint minpath(int i,int j,vector<vector<int>>&t,vector<vector<int>>&dp){\\n    if(i==t.size()-1) return t[i][j];\\nif(dp[i][j]!=-1) return dp[i][j];\\n    int p1=t[i][j]+minpath(i+1,j,t,dp);\\n    int p2=t[i][j]+minpath(i+1,j+1,t,dp);\\n\\n    return dp[i][j]=min(p1,p2);\\n}\\n    int minimumTotal(vector<vector<int>>&t) {\\n        int i=0,j=0;\\n        int n=t.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return minpath(i,j,t,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint minpath(int i,int j,vector<vector<int>>&t,vector<vector<int>>&dp){\\n    if(i==t.size()-1) return t[i][j];\\nif(dp[i][j]!=-1) return dp[i][j];\\n    int p1=t[i][j]+minpath(i+1,j,t,dp);\\n    int p2=t[i][j]+minpath(i+1,j+1,t,dp);\\n\\n    return dp[i][j]=min(p1,p2);\\n}\\n    int minimumTotal(vector<vector<int>>&t) {\\n        int i=0,j=0;\\n        int n=t.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return minpath(i,j,t,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034500,
                "title": "3-approaches-recursion-dp-memoization-dp-tabulation",
                "content": "**Please, Upvote if you learned something form here!**\\n\\n# Approach1 - Recursion (gives TLE)\\n- Time complexity: O(Exponential)\\n- Space complexity: O(m + n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int r, int c , int n , vector<vector<int>> &tri){\\n        if(r == n-1) return tri[r][c];\\n\\n        int vertical = tri[r][c] + solve(r+1 ,  c , n , tri);\\n        int diagonal = tri[r][c] + solve(r+1 , c+1 , n , tri);\\n        \\n        return min(vertical , diagonal);\\n\\n    }\\n\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        int res = solve(0 , 0 , n , triangle);\\n        return res;\\n    }\\n};\\n```\\n# Approach 2 - DP Memoization\\n- Time complexity: O(m*n)\\n- Space complexity: O(m + n) + O(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int r, int c , int n , vector<vector<int>> &tri , vector<vector<int>> &memo){\\n        if(r == n-1) return memo[r][c] = tri[r][c];\\n        if(memo[r][c] != -1) return memo[r][c];\\n\\n        int vertical = tri[r][c] + solve(r+1 ,  c , n , tri , memo);\\n        int diagonal = tri[r][c] + solve(r+1 , c+1 , n , tri , memo);\\n        \\n        return memo[r][c] = min(vertical , diagonal);\\n\\n    }\\n\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> memo(n , vector<int> (n , -1));\\n\\n        int res = solve(0 , 0 , n , triangle , memo);\\n        return memo[0][0];\\n    }\\n};\\n```\\n# Approach 3 - DP Tabulation\\n- Time complexity: O(m*n)\\n- Space complexity: O(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n , vector<int> (n , 0));\\n\\n        // Initialization\\n        for(int i=0 ; i<triangle[n-1].size() ; i++){\\n            dp[n-1][i] = triangle[n-1][i];\\n        }\\n\\n        for(int i=n-2 ; i>=0 ; i--){\\n            for(int j=0 ; j<triangle[i].size() ; j++){\\n                dp[i][j] = triangle[i][j] + min(dp[i+1][j] , dp[i+1][j+1]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(int r, int c , int n , vector<vector<int>> &tri){\\n        if(r == n-1) return tri[r][c];\\n\\n        int vertical = tri[r][c] + solve(r+1 ,  c , n , tri);\\n        int diagonal = tri[r][c] + solve(r+1 , c+1 , n , tri);\\n        \\n        return min(vertical , diagonal);\\n\\n    }\\n\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        int res = solve(0 , 0 , n , triangle);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int r, int c , int n , vector<vector<int>> &tri , vector<vector<int>> &memo){\\n        if(r == n-1) return memo[r][c] = tri[r][c];\\n        if(memo[r][c] != -1) return memo[r][c];\\n\\n        int vertical = tri[r][c] + solve(r+1 ,  c , n , tri , memo);\\n        int diagonal = tri[r][c] + solve(r+1 , c+1 , n , tri , memo);\\n        \\n        return memo[r][c] = min(vertical , diagonal);\\n\\n    }\\n\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> memo(n , vector<int> (n , -1));\\n\\n        int res = solve(0 , 0 , n , triangle , memo);\\n        return memo[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        vector<vector<int>> dp(n , vector<int> (n , 0));\\n\\n        // Initialization\\n        for(int i=0 ; i<triangle[n-1].size() ; i++){\\n            dp[n-1][i] = triangle[n-1][i];\\n        }\\n\\n        for(int i=n-2 ; i>=0 ; i--){\\n            for(int j=0 ; j<triangle[i].size() ; j++){\\n                dp[i][j] = triangle[i][j] + min(dp[i+1][j] , dp[i+1][j+1]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028903,
                "title": "c-dp-most-optimized-time-space",
                "content": "\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---\\n\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$   --- Beauty of this solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        int minSum = INT_MAX;\\n\\n        vector<int> prev(n, 0), curr(n, 0);\\n        for(int i = 0; i<n; i++){\\n            int m = triangle[i].size();\\n            for(int j = 0; j<m; j++){\\n                curr[j] = triangle[i][j];\\n                if(j == 0)\\n                    curr[j] += prev[j];\\n                else if(j == m-1)\\n                    curr[j] += prev[j-1];\\n                else\\n                    curr[j] += min(prev[j], prev[j-1]);\\n\\n                if(i == n-1)\\n                    minSum = min(minSum, curr[j]);\\n            }\\n            prev = curr;\\n        }\\n        \\n        return minSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        int minSum = INT_MAX;\\n\\n        vector<int> prev(n, 0), curr(n, 0);\\n        for(int i = 0; i<n; i++){\\n            int m = triangle[i].size();\\n            for(int j = 0; j<m; j++){\\n                curr[j] = triangle[i][j];\\n                if(j == 0)\\n                    curr[j] += prev[j];\\n                else if(j == m-1)\\n                    curr[j] += prev[j-1];\\n                else\\n                    curr[j] += min(prev[j], prev[j-1]);\\n\\n                if(i == n-1)\\n                    minSum = min(minSum, curr[j]);\\n            }\\n            prev = curr;\\n        }\\n        \\n        return minSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812359,
                "title": "golang-dp",
                "content": "# Approach\\nGoigng from bottom to the top we will choose the most optimal way to get from the previous layer to the current. We can get to the current cell from two cells on the previous layer - calculate both those ways and choose the minimum. \\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\nWhere ***N*** is the number of all cells in the triangle.\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunc minimumTotal(triangle [][]int) int {\\n    for i := len(triangle) - 2; i >= 0; i-- {\\n        for j := 0; j < len(triangle[i]); j++ {\\n           triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j + 1])\\n        }\\n    }\\n\\n    return triangle[0][0]\\n}\\n\\nfunc min(a,b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumTotal(triangle [][]int) int {\\n    for i := len(triangle) - 2; i >= 0; i-- {\\n        for j := 0; j < len(triangle[i]); j++ {\\n           triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j + 1])\\n        }\\n    }\\n\\n    return triangle[0][0]\\n}\\n\\nfunc min(a,b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2788755,
                "title": "java-2-solutions-dp-top-down-bottom-up",
                "content": "### **Please Upvote** :D\\nThis problem can be solved using Dynamic Programming.\\n##### 1. Top-Down approach:\\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> t) {\\n        for (int i = 1; i < t.size(); i++) {\\n            for (int j = 0; j < t.get(i).size(); j++) {\\n                int sum = 0;\\n\\n                if (j == 0) {\\n                    sum = t.get(i).get(j) + t.get(i - 1).get(j);\\n                }\\n                else if (j == t.get(i).size() - 1) {\\n                    sum = t.get(i).get(j) + t.get(i - 1).get(t.get(i - 1).size() - 1);\\n                }\\n                else {\\n                    int min = Math.min(t.get(i - 1).get(j), t.get(i - 1).get(j - 1));\\n                    sum = min + t.get(i).get(j);\\n                }\\n\\n                t.get(i).set(j, sum);\\n            }\\n        }\\n\\n        return Collections.min(t.get(t.size() - 1));\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n\\n##### 2. Bottom-Up approach:\\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> t) {\\n        for (int i = t.size() - 2; i >= 0; i--) {\\n            for (int j = 0; j < t.get(i).size(); j++) {\\n                int min = Math.min(t.get(i + 1).get(j), t.get(i + 1).get(j + 1));\\n                int sum = min + t.get(i).get(j);\\n                t.get(i).set(j, sum);\\n            }\\n        }\\n\\n        return t.get(0).get(0);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> t) {\\n        for (int i = 1; i < t.size(); i++) {\\n            for (int j = 0; j < t.get(i).size(); j++) {\\n                int sum = 0;\\n\\n                if (j == 0) {\\n                    sum = t.get(i).get(j) + t.get(i - 1).get(j);\\n                }\\n                else if (j == t.get(i).size() - 1) {\\n                    sum = t.get(i).get(j) + t.get(i - 1).get(t.get(i - 1).size() - 1);\\n                }\\n                else {\\n                    int min = Math.min(t.get(i - 1).get(j), t.get(i - 1).get(j - 1));\\n                    sum = min + t.get(i).get(j);\\n                }\\n\\n                t.get(i).set(j, sum);\\n            }\\n        }\\n\\n        return Collections.min(t.get(t.size() - 1));\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> t) {\\n        for (int i = t.size() - 2; i >= 0; i--) {\\n            for (int j = 0; j < t.get(i).size(); j++) {\\n                int min = Math.min(t.get(i + 1).get(j), t.get(i + 1).get(j + 1));\\n                int sum = min + t.get(i).get(j);\\n                t.get(i).set(j, sum);\\n            }\\n        }\\n\\n        return t.get(0).get(0);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658546,
                "title": "evolve-from-recursion-memoisation-tabulation-space-optimisation-step-by-step-explantion",
                "content": "***Why Greedy fails*** : Greedy approach did not work becuase here the values are not unifrom.\\n ![image](https://assets.leetcode.com/users/images/982921b3-93fa-41d8-bcd9-d2e2b5e97ff0_1664863863.9519043.jpeg)\\n\\n **Recursive Approach :** Time limit exceeded\\n``` \\n     // Recursive approach\\n     int fun(int i,int j,vector<vector<int>>& triangle){\\n        // base case \\n        if(i == triangle.size()-1){\\n            return triangle[triangle.size()-1][j];\\n        }\\n        \\n        int down = triangle[i][j] + fun(i+1,j,triangle);\\n        int diag = triangle[i][j] + fun(i+1,j+1,triangle);\\n        \\n        return min(down,diag);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        return fun(0,0,triangle);\\n    }\\n```\\n\\n**Memoisation** :\\n```\\n// Recursive + memoisation approach\\nint fun(int i, int j, vector<vector<int>> &triangle, vector<vector<int>> &dp)\\n{\\n    // base case\\n    if (i == triangle.size() - 1)\\n    {\\n        return dp[i][j] = triangle[triangle.size() - 1][j];\\n    }\\n\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n\\n    int down = triangle[i][j] + fun(i + 1, j, triangle, dp);\\n    int diag = triangle[i][j] + fun(i + 1, j + 1, triangle, dp);\\n\\n    return dp[i][j] = min(down, diag);\\n}\\n\\nint minimumTotal(vector<vector<int>> &triangle)\\n{\\n\\n    int n = triangle.size();\\n    vector<vector<int>> dp(n, vector<int>(n, -1));\\n    return fun(0, 0, triangle, dp);\\n}\\n```\\n\\n**Tabulation :** Since our recursive call went from the 0 to n-1 hence tabulation process will be form opposite dir i.e. n-1 to n.\\n```\\nint minimumTotal(vector<vector<int>> &triangle)\\n{\\n    int n = triangle.size();\\n    vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n    // Base cases : Last row\\n    for (int i = 0; i < n; i++)\\n    {\\n        dp[n - 1][i] = triangle[n - 1][i];\\n    }\\n    // Since we have already filled the last row hence loop will run from n-2\\n    for (int i = n - 2; i >= 0; i--)\\n    {\\n        for (int j = i; j >= 0; j--)\\n        {\\n            // Just copy paste the recursion logic stuff\\n            int down = triangle[i][j] + dp[i + 1][j];\\n            int diagonal = triangle[i][j] + dp[i + 1][j + 1];\\n\\n            dp[i][j] = min(down, diagonal);\\n        }\\n    }\\n\\n    return dp[0][0];\\n}\\n```\\n**Space Optimisation** : If do a dry run of tabulation process then we will observe that, we only need the next row, in order to calculate dp[i][j]. Therefore we can space optimize it.\\nInitially we can take a dummy row (say next/front). We initialize this row to the triangle matrix last row( as done in tabulation). Now the current row(say cur) only needs the next row\\u2019s value in order to calculate dp[i][j].\\n![image](https://assets.leetcode.com/users/images/0c6fa0d5-896e-4688-b34d-8428c9f519ce_1664863880.4766264.jpeg)\\n\\n**SC: O(N) & TC: O(N*N)**\\n```\\nint minimumTotal(vector<vector<int>> &triangle)\\n{\\n    int n = triangle.size();\\n    vector<int> next(n, 0), cur(n, 0);\\n    for (int j = 0; j < n; j++)\\n    {\\n        next[j] = triangle[n - 1][j];\\n    }\\n    for (int i = n - 2; i >= 0; i--)\\n    {\\n        for (int j = i; j >= 0; j--)\\n        {\\n            int down = triangle[i][j] + next[j];\\n            int diagonal = triangle[i][j] + next[j + 1];\\n\\n            cur[j] = min(down, diagonal);\\n        }\\n        next = cur;\\n    }\\n    return next[0];\\n}\\n```\\nUpvote it, if you found my explnation useful .\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` \\n     // Recursive approach\\n     int fun(int i,int j,vector<vector<int>>& triangle){\\n        // base case \\n        if(i == triangle.size()-1){\\n            return triangle[triangle.size()-1][j];\\n        }\\n        \\n        int down = triangle[i][j] + fun(i+1,j,triangle);\\n        int diag = triangle[i][j] + fun(i+1,j+1,triangle);\\n        \\n        return min(down,diag);\\n    }\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        return fun(0,0,triangle);\\n    }\\n```\n```\\n// Recursive + memoisation approach\\nint fun(int i, int j, vector<vector<int>> &triangle, vector<vector<int>> &dp)\\n{\\n    // base case\\n    if (i == triangle.size() - 1)\\n    {\\n        return dp[i][j] = triangle[triangle.size() - 1][j];\\n    }\\n\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n\\n    int down = triangle[i][j] + fun(i + 1, j, triangle, dp);\\n    int diag = triangle[i][j] + fun(i + 1, j + 1, triangle, dp);\\n\\n    return dp[i][j] = min(down, diag);\\n}\\n\\nint minimumTotal(vector<vector<int>> &triangle)\\n{\\n\\n    int n = triangle.size();\\n    vector<vector<int>> dp(n, vector<int>(n, -1));\\n    return fun(0, 0, triangle, dp);\\n}\\n```\n```\\nint minimumTotal(vector<vector<int>> &triangle)\\n{\\n    int n = triangle.size();\\n    vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n    // Base cases : Last row\\n    for (int i = 0; i < n; i++)\\n    {\\n        dp[n - 1][i] = triangle[n - 1][i];\\n    }\\n    // Since we have already filled the last row hence loop will run from n-2\\n    for (int i = n - 2; i >= 0; i--)\\n    {\\n        for (int j = i; j >= 0; j--)\\n        {\\n            // Just copy paste the recursion logic stuff\\n            int down = triangle[i][j] + dp[i + 1][j];\\n            int diagonal = triangle[i][j] + dp[i + 1][j + 1];\\n\\n            dp[i][j] = min(down, diagonal);\\n        }\\n    }\\n\\n    return dp[0][0];\\n}\\n```\n```\\nint minimumTotal(vector<vector<int>> &triangle)\\n{\\n    int n = triangle.size();\\n    vector<int> next(n, 0), cur(n, 0);\\n    for (int j = 0; j < n; j++)\\n    {\\n        next[j] = triangle[n - 1][j];\\n    }\\n    for (int i = n - 2; i >= 0; i--)\\n    {\\n        for (int j = i; j >= 0; j--)\\n        {\\n            int down = triangle[i][j] + next[j];\\n            int diagonal = triangle[i][j] + next[j + 1];\\n\\n            cur[j] = min(down, diagonal);\\n        }\\n        next = cur;\\n    }\\n    return next[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2467606,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumTotal(List<List<Integer>> t) {\\n        int k=t.size();\\n        int dp[] = new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            dp[i] = t.get(k-1).get(i);\\n        }\\n        for(int i=k-2;i>=0;i--)\\n        {\\n            int a[] = new int[k];\\n            for(int j=i;j>=0;j--)\\n            {\\n                a[j]=t.get(i).get(j)+Math.min(dp[j],dp[j+1]);\\n            }\\n            dp=a;\\n        }\\n        return dp[0];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int minimumTotal(List<List<Integer>> t) {\\n        int k=t.size();\\n        int dp[] = new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            dp[i] = t.get(k-1).get(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2463974,
                "title": "easy-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(), vector<int>(triangle.size(),0));\\n        int n = triangle.size();\\n        for(int j = 0; j < n; ++j) dp[n-1][j] = triangle[n-1][j];\\n        for(int i = n-2; i >=0; --i)\\n        {\\n            for(int j = i; j>=0; --j)\\n            {\\n                int way1 = triangle[i][j] + dp[i+1][j];\\n                int way2 = triangle[i][j] + dp[i+1][j+1];\\n                dp[i][j] = min(way1, way2);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(), vector<int>(triangle.size(),0));\\n        int n = triangle.size();\\n        for(int j = 0; j < n; ++j) dp[n-1][j] = triangle[n-1][j];\\n        for(int i = n-2; i >=0; --i)\\n        {\\n            for(int j = i; j>=0; --j)\\n            {\\n                int way1 = triangle[i][j] + dp[i+1][j];\\n                int way2 = triangle[i][j] + dp[i+1][j+1];\\n                dp[i][j] = min(way1, way2);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317587,
                "title": "simple-python-4-lines-detailed-explanation-o-1-space-dp",
                "content": "upvote if you think it was worth a read :)\\n\\nThe  approach we take is to divide the problem into smaller triangles\\n\\nLet\\'s consider a triangle with 2 rows \\n```\\n   1          The answer would be 1 + min (3, 5) = 4\\n3     5       \\n```\\nLet\\'s consider a triangle with 3 rows \\n```\\n\\t   1          \\n\\t3     5 \\n7     -1      0\\n\\nThe last two rows can be divided into these 2 triangles\\n\\t3               5\\n7      -1       -1     0\\n\\nwe solve for the first triangle and get the mimumum path to be \\n3 + min(7,-1) = 2\\nwe solve for the second triangle and get the mimumum path to be \\n5 + min(-1,0) = 4 \\n\\nthus we can reduce the last two rows into one row containing the answers to the sub triangles \\n2nd row :  2   4 \\n\\nnow we can ignore the 3 rd row since we have gotten the optimal answer we wanted from it\\n\\nNow we only have a triangle with 2 rows \\n\\t1                      solution = 1 + min(2,4) = 3\\n2       4 \\n\\nthus we get the final answer to be 3\\n```\\nwe can generalize this solution for N rows: \\nwe just keep reducing the last 2 rows into a single row till we are left with one row \\n\\nthus our result is always stored in triangle[0][0] (the 1st row), which we return\\n\\nwe can implement this iteratively, we start with the second last row and update the values as value = value + min( valueBelow, valueBelowToTheRight )\\nthus traingle[r][c] = triangle[r][c] += min(triangle[r+1][c], triangle[r+1][c+1])\\n\\nout total row iterations will be N-1 rows (all except the last) and we have to iterate on all elements in that row thus all columns\\n\\n```\\n        for r in reversed(range(len(triangle)-1)):\\n            for c in range(r+1):\\n                triangle[r][c] += min(triangle[r+1][c], triangle[r+1][c+1])\\n        \\n        return triangle[0][0]\\n```\\n\\nSpace complexity : \\nsince we have updated all the values within the traingle itself we get a constant space solution  = O(1) \\n\\nTime complexity : \\nsince we go through all elements minus the last row once \\ntime complexity will be O(total elements - last row elements)\\nO ( N * (N+1) / 2  -  N)\\nwhich is the same as O(N^2)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n   1          The answer would be 1 + min (3, 5) = 4\\n3     5       \\n```\n```\\n\\t   1          \\n\\t3     5 \\n7     -1      0\\n\\nThe last two rows can be divided into these 2 triangles\\n\\t3               5\\n7      -1       -1     0\\n\\nwe solve for the first triangle and get the mimumum path to be \\n3 + min(7,-1) = 2\\nwe solve for the second triangle and get the mimumum path to be \\n5 + min(-1,0) = 4 \\n\\nthus we can reduce the last two rows into one row containing the answers to the sub triangles \\n2nd row :  2   4 \\n\\nnow we can ignore the 3 rd row since we have gotten the optimal answer we wanted from it\\n\\nNow we only have a triangle with 2 rows \\n\\t1                      solution = 1 + min(2,4) = 3\\n2       4 \\n\\nthus we get the final answer to be 3\\n```\n```\\n        for r in reversed(range(len(triangle)-1)):\\n            for c in range(r+1):\\n                triangle[r][c] += min(triangle[r+1][c], triangle[r+1][c+1])\\n        \\n        return triangle[0][0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2147385,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(len(triangle)-1,0,-1):\\n            x=triangle[i]\\n            for j in range(len(x)-1):\\n                triangle[i-1][j]+=min(triangle[i][j],triangle[i][j+1])\\n        return triangle[0][0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(len(triangle)-1,0,-1):\\n            x=triangle[i]\\n            for j in range(len(x)-1):\\n                triangle[i-1][j]+=min(triangle[i][j],triangle[i][j+1])\\n        return triangle[0][0]",
                "codeTag": "Java"
            },
            {
                "id": 2147004,
                "title": "c-dp-memoization-tabulation",
                "content": "Memoization\\n```\\nvector<vector<int>> dp(200,vector<int>(200,-1));\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    int solve(vector<vector<int>> &v,int i,int j)\\n    {\\n        if(i==v.size()) return 0;\\n        \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        int ans=solve(v,i+1,j);\\n\\n        if(j<i+1) ans=min(ans,solve(v,i+1,j+1));\\n        \\n        return dp[i][j]=ans+v[i][j];\\n\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        \\n        for(int z=0;z<200;z++)\\n        {\\n            for(int y=0;y<200;y++)\\n            {\\n                dp[z][y]=-1;\\n            }\\n        }\\n        \\n        return solve(triangle,0,0);\\n        \\n    }\\n};\\n```\\n\\nTabulation\\n```\\n\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\tint n = triangle.size();\\n\\t\\tvector<vector<int>>dp(n, vector<int>(n, -1));\\n\\t\\tfor(int i = 0; i < n; i++) \\n\\t\\t\\tdp[n-1][i] = triangle[n-1][i];\\n        \\n        \\n\\t\\tfor(int i = n-2; i >= 0; i--) {\\n\\t\\t\\tfor(int j = 0; j <=i ; j++) {\\n\\t\\t\\t\\tint temp1 = triangle[i][j] + dp[i+1][j];\\n\\t\\t\\t\\tint temp2 = triangle[i][j] + dp[i+1][j+1];\\n\\t\\t\\t\\tdp[i][j] = min(temp1, temp2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        return dp[0][0];\\n\\t}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<vector<int>> dp(200,vector<int>(200,-1));\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    int solve(vector<vector<int>> &v,int i,int j)\\n    {\\n        if(i==v.size()) return 0;\\n        \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        int ans=solve(v,i+1,j);\\n\\n        if(j<i+1) ans=min(ans,solve(v,i+1,j+1));\\n        \\n        return dp[i][j]=ans+v[i][j];\\n\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        \\n        for(int z=0;z<200;z++)\\n        {\\n            for(int y=0;y<200;y++)\\n            {\\n                dp[z][y]=-1;\\n            }\\n        }\\n        \\n        return solve(triangle,0,0);\\n        \\n    }\\n};\\n```\n```\\n\\tint minimumTotal(vector<vector<int>>& triangle) {\\n\\t\\tint n = triangle.size();\\n\\t\\tvector<vector<int>>dp(n, vector<int>(n, -1));\\n\\t\\tfor(int i = 0; i < n; i++) \\n\\t\\t\\tdp[n-1][i] = triangle[n-1][i];\\n        \\n        \\n\\t\\tfor(int i = n-2; i >= 0; i--) {\\n\\t\\t\\tfor(int j = 0; j <=i ; j++) {\\n\\t\\t\\t\\tint temp1 = triangle[i][j] + dp[i+1][j];\\n\\t\\t\\t\\tint temp2 = triangle[i][j] + dp[i+1][j+1];\\n\\t\\t\\t\\tdp[i][j] = min(temp1, temp2);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n        return dp[0][0];\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145441,
                "title": "c-explained-solution-best-time-complexity-recursion-memoization",
                "content": "**Please upvote the solution if helpful** \\n```\\nclass Solution {\\npublic:\\n    //[ Recursion Solution with memoization ] --> bottom to top approach\\n    // Why DP ?  --> First try to understand at each cell --> there are 2 methods to reach bottom --> go down or go down&right \\n    // try to observe that there are overlapping subproblems \\n    // Now if we are at (i,j) --> then we need to calculate smallest possible path from (i+1,j) and (i+1,j+1) \\n    // and for a cell (i,j+1) --> we need to calculate smallest possible path from (i+1,j+1) and (i+1,j+2) as subproblems \\n    // Observe that we need to calculate (i+1,j+1) more than once --> need to memoize(store) the values once computed \\n    \\n    //so , we take an external 2D matrix of size n*m where n--> number of rows in triangle given and m--> maximum number of col in triangle given \\n    // dp[i][j] --> represents the smallest possible path from (i,j) to the bottom of the triangle \\n    // optimal answer --> dp[0][0]\\n    \\n    int help(int row,int col,vector<vector<int>> &a,vector<vector<int>>&dp){\\n        if(row==a.size()) return 0; // base case : we need to stop once we exceed the base of the triangle given \\n        if(dp[row][col]!=-1){       // if value is already calculated --> we use the precomputed value --> O(1) operation\\n            return dp[row][col];    \\n        }\\n        return dp[row][col]=a[row][col]+min(help(row+1,col,a,dp),help(row+1,col+1,a,dp));   // else we store and return the value computed via recursion \\n        // \\n    }\\n\\n    int minimumTotal(vector<vector<int>>& a) {\\n        vector<vector<int>> dp(a.size(),vector<int>(a[a.size()-1].size(),-1));  // creating 2d array which will store all the calculated values for future\\n         // we are for sure of using the first cell in triangle and hence we take minimum of the 2 possible paths --> col=0 or col=1 \\n        return min(a[0][0]+help(1,0,a,dp),a[0][0]+help(1,1,a,dp));     \\n    }\\n    \\n    // Time Complexity : O(n*m) where n,m represents the dimensions of the triangles height and width \\n    // Reason of Time Complexity : We reach each cell of triangle once --> total cells n*m/2 --> Time Complexity = O(n*m/2) ==O(n*m)\\n    // Space Complexity: O(n*m) because of 2D matrix\\n};\\n```\\n**Please upvote the solution if helpful**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //[ Recursion Solution with memoization ] --> bottom to top approach\\n    // Why DP ?  --> First try to understand at each cell --> there are 2 methods to reach bottom --> go down or go down&right \\n    // try to observe that there are overlapping subproblems \\n    // Now if we are at (i,j) --> then we need to calculate smallest possible path from (i+1,j) and (i+1,j+1) \\n    // and for a cell (i,j+1) --> we need to calculate smallest possible path from (i+1,j+1) and (i+1,j+2) as subproblems \\n    // Observe that we need to calculate (i+1,j+1) more than once --> need to memoize(store) the values once computed \\n    \\n    //so , we take an external 2D matrix of size n*m where n--> number of rows in triangle given and m--> maximum number of col in triangle given \\n    // dp[i][j] --> represents the smallest possible path from (i,j) to the bottom of the triangle \\n    // optimal answer --> dp[0][0]\\n    \\n    int help(int row,int col,vector<vector<int>> &a,vector<vector<int>>&dp){\\n        if(row==a.size()) return 0; // base case : we need to stop once we exceed the base of the triangle given \\n        if(dp[row][col]!=-1){       // if value is already calculated --> we use the precomputed value --> O(1) operation\\n            return dp[row][col];    \\n        }\\n        return dp[row][col]=a[row][col]+min(help(row+1,col,a,dp),help(row+1,col+1,a,dp));   // else we store and return the value computed via recursion \\n        // \\n    }\\n\\n    int minimumTotal(vector<vector<int>>& a) {\\n        vector<vector<int>> dp(a.size(),vector<int>(a[a.size()-1].size(),-1));  // creating 2d array which will store all the calculated values for future\\n         // we are for sure of using the first cell in triangle and hence we take minimum of the 2 possible paths --> col=0 or col=1 \\n        return min(a[0][0]+help(1,0,a,dp),a[0][0]+help(1,1,a,dp));     \\n    }\\n    \\n    // Time Complexity : O(n*m) where n,m represents the dimensions of the triangles height and width \\n    // Reason of Time Complexity : We reach each cell of triangle once --> total cells n*m/2 --> Time Complexity = O(n*m/2) ==O(n*m)\\n    // Space Complexity: O(n*m) because of 2D matrix\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145337,
                "title": "recursive-memoize-solution-for-triangle",
                "content": "\\n``` class Solution {\\nprivate:\\n    int dp[201][201];\\npublic:\\n    int getMin(int i, int j, vector<vector<int>>& triangle) {\\n        int rows = triangle.size(), cols = triangle[i].size();\\n        \\n        if(i == rows-1){\\n            return triangle[i][j];\\n        }\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int ls = triangle[i][j] + getMin(i+1, j, triangle);\\n        int rs = triangle[i][j] + getMin(i+1, j+1, triangle);\\n        \\n        dp[i][j] = min(ls, rs);\\n        return dp[i][j];\\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        memset(dp, -1, sizeof(dp));\\n        int i=0, j=0;\\n        int res = getMin(i, j, triangle);\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    int dp[201][201];\\npublic:\\n    int getMin(int i, int j, vector<vector<int>>& triangle) {\\n        int rows = triangle.size(), cols = triangle[i].size();\\n        \\n        if(i == rows-1){\\n            return triangle[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2145268,
                "title": "best-time-o-n-2-best-auxiliary-space-o-1-brute-to-optimal-5-approaches",
                "content": "##### Recursion + Memoization\\n Time: O(n^2) | Auxiliary Space: O(n^2)\\n```\\n    int helper(int i, int j, vector<vector<int>>& triangle, vector<vector<int>>& dp)\\n    {\\n        if(i == triangle.size()-1)\\n        {\\n            return triangle[i][j];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down = triangle[i][j] + helper(i+1,j,triangle,dp);\\n        int dia = triangle[i][j] + helper(i+1,j+1,triangle,dp);\\n        return dp[i][j]=min(down,dia);\\n        \\n    }\\n\\t\\n\\tint minimumTotal(vector<vector<int>>& triangle)\\n\\t{\\n\\t\\tint n = triangle.size();\\n\\t\\tvector<vector<int>> dp(n, vector<int> (n,-1));\\n\\t\\treturn helper(0,0,triangle,dp);\\n\\t}\\n```\\n\\n##### Tabulation\\nTime: O(n^2) | Auxiliary Space: O(n^2)\\n```\\n\\tvector<vector < int>> dp(n, vector<int> (n,0));\\n\\tfor(int i=n-1;i>=0;i--)\\n\\t{\\n\\t\\tfor(int j=i;j>=0;j--)\\n\\t\\t{\\n\\t\\t\\tif(i==n-1) dp[i][j]=triangle[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint dia = triangle[i][j] + dp[i+1][j+1];\\n\\t\\t\\t\\tint down = triangle[i][j] + dp[i+1][j];\\n\\t\\t\\t\\tdp[i][j]=min(down,dia);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][0];\\n```\\n\\n##### Space optimised Tabulation (Two arrays)\\nTime: O(n^2) | Auxiliary Space: O(n)\\n```\\n\\tvector<int> dp(n,0), temp(n,0);\\n\\tfor(int i=n-1;i>=0;i--)\\n\\t{\\n\\t\\tfor(int j=i;j>=0;j--)\\n\\t\\t{\\n\\t\\t\\tif(i==n-1) temp[j]=triangle[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint down = triangle[i][j] + dp[j];\\n\\t\\t\\t\\tint dia = triangle[i][j] + dp[j+1];\\n\\t\\t\\t\\ttemp[j]=min(down,dia);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp=temp;\\n\\t}\\n\\treturn dp[0];\\n```\\n\\n##### Space optimised Tabulation (Single array)\\nTime: O(n^2) | Auxiliary Space: O(n)\\n```\\n\\tvector<int> dp(n, 0);\\n\\tfor (int j = n - 1; j >= 0; j--)\\t// filling up base cases\\n\\t{\\n\\t\\tdp[j] = triangle[n - 1][j];\\n\\t}\\n\\tint prev = dp[n - 1];\\t// prev variable maintains the value of dp[i+1][j+1] when we are evaluationg dp[i][j]\\n\\n\\tfor (int i = n - 2; i >= 0; i--)\\n\\t{\\n\\t\\tfor (int j = i; j >= 0; j--)\\n\\t\\t{\\n\\t\\t\\tint temp = dp[j];\\n\\t\\t\\tint down = triangle[i][j] + dp[j];\\n\\t\\t\\tint dia = triangle[i][j] + prev;\\n\\t\\t\\tdp[j] = min(down, dia);\\n\\t\\t\\tprev = temp;\\n\\t\\t}\\n\\t\\tprev = dp[i];\\n\\t}\\n\\treturn dp[0];\\n```\\n\\n##### Reusing the triangle forTabulation (Modifying input)\\nTime: O(n^2) | Auxiliary Space: O(1)\\n```\\n\\tfor(int i=n-1;i>=0;i--)\\n\\t{\\n\\t\\tfor(int j=i;j>=0;j--)\\n\\t\\t{\\n\\t\\t\\tif(i==n-1) triangle[i][j]=triangle[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint dia = triangle[i][j] + triangle[i+1][j+1];\\n\\t\\t\\t\\tint down = triangle[i][j] + triangle[i+1][j];\\n\\t\\t\\t\\ttriangle[i][j]=min(down,dia);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn triangle[0][0];\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    int helper(int i, int j, vector<vector<int>>& triangle, vector<vector<int>>& dp)\\n    {\\n        if(i == triangle.size()-1)\\n        {\\n            return triangle[i][j];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int down = triangle[i][j] + helper(i+1,j,triangle,dp);\\n        int dia = triangle[i][j] + helper(i+1,j+1,triangle,dp);\\n        return dp[i][j]=min(down,dia);\\n        \\n    }\\n\\t\\n\\tint minimumTotal(vector<vector<int>>& triangle)\\n\\t{\\n\\t\\tint n = triangle.size();\\n\\t\\tvector<vector<int>> dp(n, vector<int> (n,-1));\\n\\t\\treturn helper(0,0,triangle,dp);\\n\\t}\\n```\n```\\n\\tvector<vector < int>> dp(n, vector<int> (n,0));\\n\\tfor(int i=n-1;i>=0;i--)\\n\\t{\\n\\t\\tfor(int j=i;j>=0;j--)\\n\\t\\t{\\n\\t\\t\\tif(i==n-1) dp[i][j]=triangle[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint dia = triangle[i][j] + dp[i+1][j+1];\\n\\t\\t\\t\\tint down = triangle[i][j] + dp[i+1][j];\\n\\t\\t\\t\\tdp[i][j]=min(down,dia);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][0];\\n```\n```\\n\\tvector<int> dp(n,0), temp(n,0);\\n\\tfor(int i=n-1;i>=0;i--)\\n\\t{\\n\\t\\tfor(int j=i;j>=0;j--)\\n\\t\\t{\\n\\t\\t\\tif(i==n-1) temp[j]=triangle[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint down = triangle[i][j] + dp[j];\\n\\t\\t\\t\\tint dia = triangle[i][j] + dp[j+1];\\n\\t\\t\\t\\ttemp[j]=min(down,dia);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdp=temp;\\n\\t}\\n\\treturn dp[0];\\n```\n```\\n\\tvector<int> dp(n, 0);\\n\\tfor (int j = n - 1; j >= 0; j--)\\t// filling up base cases\\n\\t{\\n\\t\\tdp[j] = triangle[n - 1][j];\\n\\t}\\n\\tint prev = dp[n - 1];\\t// prev variable maintains the value of dp[i+1][j+1] when we are evaluationg dp[i][j]\\n\\n\\tfor (int i = n - 2; i >= 0; i--)\\n\\t{\\n\\t\\tfor (int j = i; j >= 0; j--)\\n\\t\\t{\\n\\t\\t\\tint temp = dp[j];\\n\\t\\t\\tint down = triangle[i][j] + dp[j];\\n\\t\\t\\tint dia = triangle[i][j] + prev;\\n\\t\\t\\tdp[j] = min(down, dia);\\n\\t\\t\\tprev = temp;\\n\\t\\t}\\n\\t\\tprev = dp[i];\\n\\t}\\n\\treturn dp[0];\\n```\n```\\n\\tfor(int i=n-1;i>=0;i--)\\n\\t{\\n\\t\\tfor(int j=i;j>=0;j--)\\n\\t\\t{\\n\\t\\t\\tif(i==n-1) triangle[i][j]=triangle[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tint dia = triangle[i][j] + triangle[i+1][j+1];\\n\\t\\t\\t\\tint down = triangle[i][j] + triangle[i+1][j];\\n\\t\\t\\t\\ttriangle[i][j]=min(down,dia);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn triangle[0][0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2144992,
                "title": "c-dp",
                "content": "Iterate thru every row and every number.\\nAdd the min of [row-1][i]  [row-1][i-1]\\nthe minimum number in your last row is the final answer\\n\\n**SOLVED LIVE ON STREAM.  LINK IN PROFILE.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int ans = INT_MAX;\\n        int ROWS = triangle.size();\\n        for(int r = 1; r < ROWS; r++) {\\n            int n = triangle[r].size();\\n            for(int i = 0; i < n; i++) {\\n                if(i == 0) {\\n                    triangle[r][i] += triangle[r-1][i];\\n                } else if (i == n - 1) {\\n                    triangle[r][i] += triangle[r-1][i-1];\\n                } else {\\n                    int mn = min(triangle[r-1][i], triangle[r-1][i-1]);\\n                    triangle[r][i] += mn;\\n                }\\n            }\\n        }\\n        \\n        for(int x : triangle[ROWS-1]) {\\n            ans = min(ans, x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int ans = INT_MAX;\\n        int ROWS = triangle.size();\\n        for(int r = 1; r < ROWS; r++) {\\n            int n = triangle[r].size();\\n            for(int i = 0; i < n; i++) {\\n                if(i == 0) {\\n                    triangle[r][i] += triangle[r-1][i];\\n                } else if (i == n - 1) {\\n                    triangle[r][i] += triangle[r-1][i-1];\\n                } else {\\n                    int mn = min(triangle[r-1][i], triangle[r-1][i-1]);\\n                    triangle[r][i] += mn;\\n                }\\n            }\\n        }\\n        \\n        for(int x : triangle[ROWS-1]) {\\n            ans = min(ans, x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042819,
                "title": "simple-dynamic-python-solution-explained",
                "content": "This solution essentially works by iterating through the triangle starting at the second last row and setting each element in that row to the minimum neighbor in the next row plus itself and then looping to the rows above. This makes each element in the triangle equal to the shortest path below and sets the peak of the triangle to the overall shortest path.\\n```\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        for i in range(len(triangle)-2,-1,-1):\\n            for j in range(len(triangle[i])):\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\\n                \\n        return triangle[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        for i in range(len(triangle)-2,-1,-1):\\n            for j in range(len(triangle[i])):\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\\n                \\n        return triangle[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008347,
                "title": "recursion-dp",
                "content": "### Recursion\\n```\\nint solve(vector<vector<int>> &v, int i, int j){\\n  if(i>v.size()-1 ) return 0;\\n  int left= v[i][j]  + solve(v, i+1,j);\\n  int right =v[i][j]  + solve(v, i+1,j+1);\\n  return  min(left, right);\\n}\\nint minimumTotal(vector<vector<int>>& v) {\\n  return solve(v,0,0);\\n}\\n```\\n\\n### Dynamic Programming\\n```\\nint minimumTotal(vector<vector<int>>& v) {\\n  int n= v.size();\\n  vector<int> dp(n,0);\\n  for(int i=0;i<n;i++)\\n    dp[i] = v[n-1][i];\\n  for(int i=n-2;i>=0;i--){\\n      for(int j=0;j<=i;j++)\\n        dp[j] = min(dp[j], dp[j+1]) + v[i][j];\\n  }\\n  return dp[0];\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint solve(vector<vector<int>> &v, int i, int j){\\n  if(i>v.size()-1 ) return 0;\\n  int left= v[i][j]  + solve(v, i+1,j);\\n  int right =v[i][j]  + solve(v, i+1,j+1);\\n  return  min(left, right);\\n}\\nint minimumTotal(vector<vector<int>>& v) {\\n  return solve(v,0,0);\\n}\\n```\n```\\nint minimumTotal(vector<vector<int>>& v) {\\n  int n= v.size();\\n  vector<int> dp(n,0);\\n  for(int i=0;i<n;i++)\\n    dp[i] = v[n-1][i];\\n  for(int i=n-2;i>=0;i--){\\n      for(int j=0;j<=i;j++)\\n        dp[j] = min(dp[j], dp[j+1]) + v[i][j];\\n  }\\n  return dp[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1959613,
                "title": "bottom-up-dp-solution-c-explained",
                "content": "While going down you decide which path to take on the basis of what was the min cost in the upper paths.\\nWe do reverse of this, we go down->up\\n\\nwhile doing this:\\n1. check which path costs min, coming up from cell just below it traingle[i+1][j] or coming from cell diagonally below current cell triangle[i+1][j+1] find optimal path and store that ans for current cell.\\n2. While going up keep storing min path for each cell and the topmost cell will eventually have the ans .\\n```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        int n=triangle.size();\\n        \\n        \\n        for(int i=n-2;i>=0;i--){\\n            int m=triangle[i].size();//number of cols in each row of triangle matrix\\n            for(int j=m-1;j>=0;j--){\\n                triangle[i][j]+=min(triangle[i+1][j],triangle[i+1][j+1]);\\n                //min cost from cell just below it or diagonally below it \\n            }\\n        }\\n        \\n        return triangle[0][0]; //ans \\n    }\\n};\\n```\\n\\nPlease upvote if you found it helpful :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        int n=triangle.size();\\n        \\n        \\n        for(int i=n-2;i>=0;i--){\\n            int m=triangle[i].size();//number of cols in each row of triangle matrix\\n            for(int j=m-1;j>=0;j--){\\n                triangle[i][j]+=min(triangle[i+1][j],triangle[i+1][j+1]);\\n                //min cost from cell just below it or diagonally below it \\n            }\\n        }\\n        \\n        return triangle[0][0]; //ans \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886895,
                "title": "c-dp-simple-easy-to-understand-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    // normal min value finding function\\n    long long int min(long long int a, long long int b) {\\n        return a > b? b : a; \\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        // initializing dp\\n        vector<vector<long long int>> dp(triangle.size(), vector<long long int>(triangle.size(), 0));\\n        \\n        // dp[i][j]: min sum till ith row \\n        int len = 2;\\n        dp[0][0] = triangle[0][0];\\n        \\n        for(int i=1;i<triangle.size();i++) {\\n            for(int j=0;j<len;j++) {\\n                if(j == 0) {\\n                    // when we are at the start of the array we can only take the value above the current element\\n                    dp[i][j] = dp[i-1][j] + triangle[i][j];\\n                } else if(j == len-1) {\\n                    // when we are at then end of the array we can only take the value at the diagonally left element in the previous row\\n                    dp[i][j] = dp[i-1][j-1] + triangle[i][j];\\n                } else {\\n                    // when we are at the middle of the array we will consider min among diagonally left and above element in previous row\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j];\\n                }\\n            }\\n            len++;\\n        }\\n        \\n        long long int minv = INT_MAX;\\n        for(int i=0;i<triangle.size();i++) {\\n            // now we will find the min in the last array which will be our ans as our motive in this question was to reach last array with min cost.\\n            minv = min(dp[triangle.size()-1][i], minv);\\n        }\\n        \\n        return minv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // normal min value finding function\\n    long long int min(long long int a, long long int b) {\\n        return a > b? b : a; \\n    }\\n    \\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        // initializing dp\\n        vector<vector<long long int>> dp(triangle.size(), vector<long long int>(triangle.size(), 0));\\n        \\n        // dp[i][j]: min sum till ith row \\n        int len = 2;\\n        dp[0][0] = triangle[0][0];\\n        \\n        for(int i=1;i<triangle.size();i++) {\\n            for(int j=0;j<len;j++) {\\n                if(j == 0) {\\n                    // when we are at the start of the array we can only take the value above the current element\\n                    dp[i][j] = dp[i-1][j] + triangle[i][j];\\n                } else if(j == len-1) {\\n                    // when we are at then end of the array we can only take the value at the diagonally left element in the previous row\\n                    dp[i][j] = dp[i-1][j-1] + triangle[i][j];\\n                } else {\\n                    // when we are at the middle of the array we will consider min among diagonally left and above element in previous row\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j];\\n                }\\n            }\\n            len++;\\n        }\\n        \\n        long long int minv = INT_MAX;\\n        for(int i=0;i<triangle.size();i++) {\\n            // now we will find the min in the last array which will be our ans as our motive in this question was to reach last array with min cost.\\n            minv = min(dp[triangle.size()-1][i], minv);\\n        }\\n        \\n        return minv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791066,
                "title": "python-3-100ms-bottom-up-dp-solution",
                "content": "```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        if not triangle:\\n            return \\n        res = triangle[-1]\\n        for i in range(len(triangle)-2, -1, -1):\\n            for j in range(len(triangle[i])):\\n                res[j] = min(res[j], res[j+1]) + triangle[i][j]\\n        return res[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        if not triangle:\\n            return \\n        res = triangle[-1]\\n        for i in range(len(triangle)-2, -1, -1):\\n            for j in range(len(triangle[i])):\\n                res[j] = min(res[j], res[j+1]) + triangle[i][j]\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725925,
                "title": "c-o-1-space-solution-dp",
                "content": "```\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        int ans = INT_MAX;\\n        \\n        for(int i=1; i<n; i++){\\n            triangle[i][0]+=triangle[i-1][0];\\n            for(int j=1; j<triangle[i].size()-1; j++)\\n                triangle[i][j]+=min(triangle[i-1][j], triangle[i-1][j-1]);\\n            triangle[i][triangle[i].size()-1]+=triangle[i-1][triangle[i].size()-2];\\n        }\\n        \\n        for(int j=0; j<n; j++)\\n            ans=min(ans, triangle[n-1][j]);\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int n = triangle.size();\\n        int ans = INT_MAX;\\n        \\n        for(int i=1; i<n; i++){\\n            triangle[i][0]+=triangle[i-1][0];\\n            for(int j=1; j<triangle[i].size()-1; j++)\\n                triangle[i][j]+=min(triangle[i-1][j], triangle[i-1][j-1]);\\n            triangle[i][triangle[i].size()-1]+=triangle[i-1][triangle[i].size()-2];\\n        }\\n        \\n        for(int j=0; j<n; j++)\\n            ans=min(ans, triangle[n-1][j]);\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1714476,
                "title": "javascript-typescript-simple-dp-solution-time-90-faster-memory-43-less",
                "content": "From bottom to top, find the minimum path sum of every node, and replace the original node value with it. \\nTime complexity O(n), space complexity O(1).\\n```\\nfunction minimumTotal(triangle: number[][]): number {\\n    if (triangle.length === 1) return triangle[0][0];\\n    \\n    let height = triangle.length - 2;\\n    \\n    for (let level: number = height; level >= 0; level--) {\\n        for (let col: number = 0; col < triangle[level].length; col++) {\\n            triangle[level][col] += Math.min(triangle[level + 1][col], triangle[level + 1][col + 1]);\\n        }\\n    }\\n    \\n    return triangle[0][0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction minimumTotal(triangle: number[][]): number {\\n    if (triangle.length === 1) return triangle[0][0];\\n    \\n    let height = triangle.length - 2;\\n    \\n    for (let level: number = height; level >= 0; level--) {\\n        for (let col: number = 0; col < triangle[level].length; col++) {\\n            triangle[level][col] += Math.min(triangle[level + 1][col], triangle[level + 1][col + 1]);\\n        }\\n    }\\n    \\n    return triangle[0][0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1615170,
                "title": "python-bottom-up-faster-than-98",
                "content": "```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(len(triangle)-2, -1, -1):\\n            for j in range(len(triangle[i])):\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\\n        \\n        return triangle[0][0]\\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        for i in range(len(triangle)-2, -1, -1):\\n            for j in range(len(triangle[i])):\\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\\n        \\n        return triangle[0][0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498175,
                "title": "in-place-c-solution-no-extra-space",
                "content": "In place solution\\n```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<triangle[i].size();j++)\\n            {\\n                triangle[i][j]+=min(triangle[i+1][j],triangle[i+1][j+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumTotal(vector<vector<int>>& triangle) {\\n        int n=triangle.size();\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<triangle[i].size();j++)\\n            {\\n                triangle[i][j]+=min(triangle[i+1][j],triangle[i+1][j+1]);\\n            }\\n        }\\n        return triangle[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170025,
                "title": "rust-short-o-1-space",
                "content": "```rust\\nimpl Solution {\\n    pub fn minimum_total(mut triangle: Vec<Vec<i32>>) -> i32 {\\n        for y in (0..triangle.len() - 1).rev() {\\n            for x in (0..triangle[y].len()) {\\n                triangle[y][x] += triangle[y + 1][x].min(triangle[y + 1][x + 1]);\\n            }\\n        }\\n        triangle[0][0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn minimum_total(mut triangle: Vec<Vec<i32>>) -> i32 {\\n        for y in (0..triangle.len() - 1).rev() {\\n            for x in (0..triangle[y].len()) {\\n                triangle[y][x] += triangle[y + 1][x].min(triangle[y + 1][x + 1]);\\n            }\\n        }\\n        triangle[0][0]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112752,
                "title": "python-simple-dp",
                "content": "```\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        n=len(triangle)\\n        if n==1:\\n            return triangle[0][0]\\n        for i in range(1,n):\\n            for j in range(0,i+1):\\n                if j==0:\\n                    triangle[i][0]+=triangle[i-1][0]\\n                elif j==i:\\n                    triangle[i][j]+=triangle[i-1][-1]\\n                else:\\n                    triangle[i][j]+=min(triangle[i-1][j-1],triangle[i-1][j])\\n        return min(triangle[-1])\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\\n        n=len(triangle)\\n        if n==1:\\n            return triangle[0][0]\\n        for i in range(1,n):\\n            for j in range(0,i+1):\\n                if j==0:\\n                    triangle[i][0]+=triangle[i-1][0]\\n                elif j==i:\\n                    triangle[i][j]+=triangle[i-1][-1]\\n                else:\\n                    triangle[i][j]+=min(triangle[i-1][j-1],triangle[i-1][j])\\n        return min(triangle[-1])\\n            \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1091513,
                "title": "c-simple-and-short-dp-faster-and-no-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& tri) {\\n        int h=tri.size();\\n        for(int i=h-2;i>=0;--i)\\n            for(int j=0;j<tri[i].size();++j)\\n            {\\n                tri[i][j]+=min(tri[i+1][j],tri[i+1][j+1]);\\n            }\\n        return tri[0][0];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& tri) {\\n        int h=tri.size();\\n        for(int i=h-2;i>=0;--i)\\n            for(int j=0;j<tri[i].size();++j)\\n            {\\n                tri[i][j]+=min(tri[i+1][j],tri[i+1][j+1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1018422,
                "title": "easy-c-iterative-dp-solution",
                "content": "class Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        int n=triangle.size();\\n        int m=triangle[n-1].size();\\n        \\n       \\n        \\n        int dp[n+1][m+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=(int)1e5;\\n            }\\n        }\\n        \\n       \\n            dp[0][1]=0;\\n            dp[0][0]=0;\\n        \\n        \\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=i;j++)\\n            {\\n                dp[i][j]=min(dp[i-1][j],dp[i-1][j-1])+triangle[i-1][j-1];\\n            }\\n        }\\n        \\n      \\n        \\n        int ans=1e5;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            ans=min(ans,dp[n][i]);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        \\n        int n=triangle.size();\\n        int m=triangle[n-1].size();\\n        \\n       \\n        \\n        int dp[n+1][m+1];\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                dp[i][j]=(int)1e5;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 977025,
                "title": "python-4-liner-easy-100-memory-100-faster",
                "content": "\\n```\\n    def minimumTotal(self, a: List[List[int]]) -> int:\\n        for i in range(len(a)-1,0,-1):\\n            for j in range(len(a[i])-1):\\n                a[i-1][j] += min(a[i][j],a[i][j+1])\\n        return a[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumTotal(self, a: List[List[int]]) -> int:\\n        for i in range(len(a)-1,0,-1):\\n            for j in range(len(a[i])-1):\\n                a[i-1][j] += min(a[i][j],a[i][j+1])\\n        return a[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 942401,
                "title": "scala-10-lines-dp-solution-with-step-by-step-explanation",
                "content": "**Thought**\\n* Dynamic Programming\\n\\t* We calculate minimum path summation of the input triangle in  bottom up manner\\n\\t*  state definition\\n\\t\\t* one dimension dp[j]\\n        * dp[j]  represents minimum path summation at position triangle[i][j] during bottom up\\n        * ex:\\n\\t\\t\\t* input triangle:\\n      [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n\\t\\t\\t* dp[j] at i-th layer\\n\\t\\t\\t\\t* iter 4:     11\\n\\t\\t\\t\\t* iter 3:   9, 10\\n\\t\\t\\t\\t* iter 2:  7, 6, 10\\n\\t\\t\\t\\t* iter 1:  4, 1, 8, 3\\n\\n\\t* state transition\\n\\t\\t* dp[j] at triangle i-th layer:\\n\\t\\t\\t* dp[j] = triangle[i][j]  +  min( previous dp[j], previous dp[j - 1])\\n\\t\\t\\t* ex:\\n\\t\\t\\t\\t* input triangle:\\n\\t\\t\\t\\t\\t1:     [2],\\n\\t\\t\\t\\t\\t2:    [3,4],\\n\\t\\t\\t\\t\\t3:   [6,5,7],\\n\\t\\t\\t\\t\\t4:  [4,1,8,3]\\n\\n                * bottom up step by step  :\\n                    * iter 1: dp:   [4, 1, 8, 3]\\n                    * iter 2:\\n                        * current array\\n                            * 3-th array in triangle: [6, 5, 7]\\n                        * previous dp  [4, 1, 8, 3]\\n                        * update dp:\\n                            * [6 + min(4, 1),  5 + min(1, 8),  7 + min(8, 3) ] = [7, 6, 10]\\n                    * iter 3:\\n                        * current array\\n                            * second array in triangle: [3, 4]\\n                        * previous dp [7, 6, 10]\\n                        * update dp: \\n                            * [3 + min(7, 6), 4 + min(6, 10)] = [9, 10]\\n                    * iter 4:\\n                        * current array\\n                            * first array in triangle [2]\\n                        * previous dp [9, 10]\\n                        * update dp:\\n                            * [2 + min(9, 10) ] = [11]\\n\\n\\t\\t\\t\\t\\t* **finally, we got the minimum path sum: 11**\\n \\n\\n**Code**\\n\\t\\t\\n```\\nobject Solution {\\n    def minimumTotal(triangle: List[List[Int]]): Int = {\\n        val depth = triangle.size\\n        val dp = triangle.last.toArray\\n        for(i <- (depth - 2) to 0 by -1; j <- triangle(i).indices)\\n            dp(j) = triangle(i)(j) + (dp(j) min dp(j + 1)) \\n        dp(0)\\n    }\\n}\\n```\\n* time complexity: O(N)\\n\\t* N is the height of triangle\\n\\t*  all element are visited once\\n* space complexity: O(N)\\n\\t*  N is the height of triangle\\n\\t*  We only create dp array which dimesnion is equals to the last row in triangle",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```\\nobject Solution {\\n    def minimumTotal(triangle: List[List[Int]]): Int = {\\n        val depth = triangle.size\\n        val dp = triangle.last.toArray\\n        for(i <- (depth - 2) to 0 by -1; j <- triangle(i).indices)\\n            dp(j) = triangle(i)(j) + (dp(j) min dp(j + 1)) \\n        dp(0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 901787,
                "title": "no-extra-space-no-recursion-no-memo-only-compute",
                "content": "```\\n#T is the Triangle data structure.\\n#Parse from 2nd row.\\n#Handle first and last column distinctly.\\n#Handle rest of the columns from 1 to r-1\\n#Keep updating T as you progress downwards.\\n#Pythonic enough?\\n#Thanks\\n\\ndef minimumTotal(self, T: List[List[int]]) -> int:           \\n        for r in range(1,len(T)):            \\n            T[r][0]+=T[r-1][0]\\n            T[r][r]+=T[r-1][r-1]\\n            for c in range(1,r):\\n                T[r][c]+=min(T[r-1][c],T[r-1][c-1])\\n        return min(T[-1]) \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n#T is the Triangle data structure.\\n#Parse from 2nd row.\\n#Handle first and last column distinctly.\\n#Handle rest of the columns from 1 to r-1\\n#Keep updating T as you progress downwards.\\n#Pythonic enough?\\n#Thanks\\n\\ndef minimumTotal(self, T: List[List[int]]) -> int:           \\n        for r in range(1,len(T)):            \\n            T[r][0]+=T[r-1][0]\\n            T[r][r]+=T[r-1][r-1]\\n            for c in range(1,r):\\n                T[r][c]+=min(T[r-1][c],T[r-1][c-1])\\n        return min(T[-1]) \\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1567400,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1564875,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1570437,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1566746,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1569970,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1567865,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1567142,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1800744,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1570934,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1567864,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1567400,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1564875,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1570437,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1566746,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1569970,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1567865,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1567142,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1800744,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1570934,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1567864,
                "content": [
                    {
                        "username": "shAdow2654",
                        "content": "\\nInput: [[-1],[2,3],[1,-1,-3]]\\nOutput: -2\\nExpected: -1\\n**The correct ans acc to me is -1 + 2 -3 = -2\\nBut Expected answer is -1.**\\n*How this is possible???*"
                    },
                    {
                        "username": "BorisBLG",
                        "content": "[@2200032722](/2200032722) Is it not?? I dun get this too"
                    },
                    {
                        "username": "fahad_sait",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)  but in the worst case, the time complexity will be very high...\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[@Siddhant_agrawal](/Siddhant_agrawal)               but -2 is minimum value than -1 ?\\n                                                                                 "
                    },
                    {
                        "username": "hosua",
                        "content": "[@ironmonger1](/ironmonger1) It never jumped. The path it takes is -1 -> 3 -> -3. The path you were thinking of takes 2 in the second row, but it ends up being a lower sum if you take 3 in the second row instead."
                    },
                    {
                        "username": "Siddhant_agrawal",
                        "content": "The basic condition is i or i+1 for next row. for first row we can select -1. for second row we can select either 2 or 3. Lets suppose we choose 2. then we can select 1 or -1. so the sum for -1,2,1 is 2 and for -1,2,-1 is 0. Now suppose we have selected 3 in previous step then we have options -1 and -3. now the sum for -1, 3,-1 will be 1 and for -1,3,-3 will be -1. hence out of all some -1 is minimum sum. hence -1 is answer"
                    },
                    {
                        "username": "user0467H",
                        "content": "[@ironmonger1](/ironmonger1) you are right"
                    },
                    {
                        "username": "n4nevinn",
                        "content": "[@ironmonger1](/ironmonger1) Then it should go to -1 and final answer should be 0. But the expected answer here is -1"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I am a bit late but how can you jump from 2(column 0) to -3(column 2) as it clearly says you can only go i or i+1 so you can only go 0 and 1 for index 0"
                    },
                    {
                        "username": "bladderoverflow",
                        "content": "if we choose index=2 in second row, the range to choose in 3rd row is {2, 3} or {1,2,3} ?\\n\\nmathematically {1,2,3} make sense, \\n\\nbut in a (left right balanced) triangle showing in the question, seems only {2,3} is visually adjacent."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Recursion | Memoization | Tabulation | Space Optimization\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "You should take {1,2,3} .."
                    },
                    {
                        "username": "flag_smasher",
                        "content": "Lets understand with an example.\\nSuppose, the triangle looks like this.\\n\\n2\\n2 3\\n5 6 7\\n2 4 3 1\\n\\nWe can only move to the adjascent nodes in the next line. From 3 we can go to 6/7 not 5.\\nSo the approach is to re-calculate the triangle.\\nNow how?\\nJust see the first element 2. There is nothing before 2 so we will calculate from the 2nd line.\\nfor next 2 there is the 2 of first line is only adjascent. so 2+2=4. So make triangle[1][0]=4.\\nAnd for 3 it becomes 5.\\nSo,the triangle is now like\\n2\\n4 5\\n5 6 7\\n2 4 3 1\\n\\nSame way for triangle[3][1] 6 has two adjascent elements. So we will take the smaller sum.\\n6+4<6+5.\\n\\nUltimately the triangle becomes\\n2\\n4 5\\n9 10 12\\n11 13 13 13\\nnotice last elements of a line has only one adjascent elements.\\nSo, answer is the samllest element of last line.\\n\\nTry it first. If you still don\\'t get it. See the code.\\nhttps://github.com/Shuvro-d/Leetcode-solutions\\n\\nThere is nothing wrong in watching solutions......Happy Coding....."
                    },
                    {
                        "username": "basten2002",
                        "content": "most intuitive approach !!"
                    },
                    {
                        "username": "GodOfm4a1",
                        "content": "Thanks for the invaulable insight. I was able to code because of it without looking at others solution.\\n\\nhttps://leetcode.com/problems/triangle/solutions/3647468/c-space-optimized-solution-with-explaination-dynamic-programming/"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "Brilliant explanation!! I don\\'t get why there are almost no solutions that use this idea, as it requires only constant extra space."
                    },
                    {
                        "username": "rick21",
                        "content": "I think we can come out -2 by selecting \\nLevel 0: 0 (-1)\\nLevel 1: 1 (2)\\nLevel 2: 0 (-3)\\nmin = -1 + 2 + (-3) = -2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Important statement to read\n\"For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row\"\n\nIf we can move to any index of next row then it can be greedy solution. Just pick smaller value from each row.\nbut it is dynamic programming solution. we need to just look for j or j+1 of next row (i+1)"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "pritijha24",
                        "content": "Test Case:-        [[-1],[2,3],[1,-1,-3]]\\n\\nAnswer Expected :- -1\\n\\nBut Answer Should be -1+2+(-3)=-2     \\n\\nAm I wrong somewhere?"
                    },
                    {
                        "username": "killyosaur",
                        "content": "Yes, you cannot step \"backwards\". if you are at 0 and go to 1, the only legal moves for the next row is either 1 or 2. 0 is no longer allowed."
                    },
                    {
                        "username": "vy7Sun",
                        "content": "          -1\\n      2       3\\n    1     -1     -3\\n\\nWhy I feel the shortest path would be -1, 2, -1 = 0, but the expected answer is -1 according to the submission ?"
                    },
                    {
                        "username": "Saiteja_521",
                        "content": "The Shortest path is  -1, 3, -3 = -1"
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "[@rahulroshanganesh2002](/rahulroshanganesh2002) however why does testcase 19 [[2],[3,4],[6,5,9],[4,4,8,0]] expect \"14\" while if we count from bottom, then it will results 15?"
                    },
                    {
                        "username": "rahulroshanganesh2002",
                        "content": "[@vy7Sun](/vy7Sun)they are parsing from bottom up not top to bottom.\\n"
                    },
                    {
                        "username": "Sarankumar_R",
                        "content": "[@Ramachari](/Ramachari) yes"
                    },
                    {
                        "username": "Ramachari",
                        "content": "we have to consider the whole path from top to bottom rather than just the small element in the next row"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "[@chriske0629](/chriske0629) Ok i understood what to do now i have to figure out how to do"
                    },
                    {
                        "username": "hfirn",
                        "content": "[@chriske0629](/chriske0629) So it needs to compare the final results, and find the shortest path from top to bottom."
                    },
                    {
                        "username": "chriske0629",
                        "content": "Beacause if you go for the rightest path, It would be -1, 3, -3. The result of this path(-1) would be smaller than 0"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up: In-place)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up: Auxiliary Space)\n\n  \n**Approach 3:** Dynamic Programming (Bottom-up: Flip Triangle Upside Down)\n\n  \n**Approach 4:** Memoization (Top-Down)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "f20200445",
                        "content": "Why is this giving TLE only for last testcase? I could do the tabulation solution but memoization is giving me TLE."
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "my memoization solution passed all the cases! you might be doing some mistake i guess"
                    },
                    {
                        "username": "steven_tian",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\n-1+2+-3=-2,\\n\\n I don\\'t know why answer is -1\\n \\n Could anyone tell me the reason ?\\n \\n Thanks in advance.\\n \\n \\n"
                    },
                    {
                        "username": "Tanmayee3012",
                        "content": "but we can\\'t select -3 if we choose 2 from second level as it is out of reach of index having element 2 .."
                    },
                    {
                        "username": "killyosaur",
                        "content": "because of how you have to step:\\nyou can either go to the the j-th or j-th + 1, never j-th - 1. So that means 0->0->0, 0->1->1, or 0->1->2. 0->1->2 is the shortest path."
                    },
                    {
                        "username": "Sining",
                        "content": "I guess  I had trouble to understand what adjacent node means. But for the {{-1},{2,3},{1,-1,-3}}, the answer showed -1. It does not make sense."
                    },
                    {
                        "username": "crpeck",
                        "content": "It looks like the minimum path should be `-1 => 3 => -3`, and `-1 + 3 + -3 = -1`. What result are you expecting?"
                    }
                ]
            },
            {
                "id": 1730569,
                "content": [
                    {
                        "username": "Adish19",
                        "content": "I think the question is not explained in detail\\nFor Test Case\\n[[-1],[2,3],[1,-1,-3]]\\n\\nSum should be -1 + min(2,3) + min(1,-1) = 0\\nBut Expected answer is -1\\n\\nI have tried top to bottom approach using recursion \\nBut I have seen solutions working on Bottom Up approach\\n\\nComment if I am wrong"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Guys don\\'t get confused by seeing pyramid triangular pattern its actually like this:\\n2\\n34\\n657\\n4183\\nfor input:[[2],[3,4],[6,5,7],[4,1,8,3]]\\nwe can more either i or (i+1) of next row if we start from (0,0)"
                    },
                    {
                        "username": "lalithnaren08e",
                        "content": "If we are on any particular row and the column is x\\nby adjacent column in next it means we can move to any of {x-1 , x , x+1 } columns in the next row . \\n but the solution gets accepted if we move from column x to either  x+1 or x in the next row"
                    },
                    {
                        "username": "navjot50",
                        "content": "[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n\\nFor example we are at 3, can we just move to 6 and 5 or we can move to 7 as well. Similarly, for 5 can we just move to 1 and 8 or can we move to 4 and 3 as well. Adjacent is one node on left and one on right or is it the entire below row?"
                    },
                    {
                        "username": "sj82516",
                        "content": "I got an error:\\nInput:\\n[[-1],[2,3],[1,-1,-3]]\\nOutput:\\n-2\\nExpected:\\n-1\\n\\nwhy answer is -1?"
                    },
                    {
                        "username": "winnie2",
                        "content": "Input:\\t[[-1],[2,3],[1,-1,-3]] \\nOutput:\\t-2 \\nExpected:\\t-1. \\n\\nIsn't -2 correct here?"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Greedy will not work"
                    },
                    {
                        "username": "user7079E",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\nFor the above test case the minumum sum should be -1\\n-1+2-3=-2 which is less than -1.\\n\\nCan you please help me understand how it is -1"
                    },
                    {
                        "username": "dylanoo",
                        "content": "I am thinking if there is a way using DP to output the minimum path? It is doable with DFS, any suggestions on how to do it with DP?"
                    },
                    {
                        "username": "suhit",
                        "content": "Why is the expected output for [[-1],[3,2],[-3,1,-1]] is -1? \\n\\t\\t-1\\n\\t\\t3      2\\n\\t-3   1   -1 \\nShouldn\\'t it be -2 as minimum sum array would then be  -1 + 2 + (-3) = -2?  \\n"
                    }
                ]
            },
            {
                "id": 1918065,
                "content": [
                    {
                        "username": "Adish19",
                        "content": "I think the question is not explained in detail\\nFor Test Case\\n[[-1],[2,3],[1,-1,-3]]\\n\\nSum should be -1 + min(2,3) + min(1,-1) = 0\\nBut Expected answer is -1\\n\\nI have tried top to bottom approach using recursion \\nBut I have seen solutions working on Bottom Up approach\\n\\nComment if I am wrong"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Guys don\\'t get confused by seeing pyramid triangular pattern its actually like this:\\n2\\n34\\n657\\n4183\\nfor input:[[2],[3,4],[6,5,7],[4,1,8,3]]\\nwe can more either i or (i+1) of next row if we start from (0,0)"
                    },
                    {
                        "username": "lalithnaren08e",
                        "content": "If we are on any particular row and the column is x\\nby adjacent column in next it means we can move to any of {x-1 , x , x+1 } columns in the next row . \\n but the solution gets accepted if we move from column x to either  x+1 or x in the next row"
                    },
                    {
                        "username": "navjot50",
                        "content": "[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n\\nFor example we are at 3, can we just move to 6 and 5 or we can move to 7 as well. Similarly, for 5 can we just move to 1 and 8 or can we move to 4 and 3 as well. Adjacent is one node on left and one on right or is it the entire below row?"
                    },
                    {
                        "username": "sj82516",
                        "content": "I got an error:\\nInput:\\n[[-1],[2,3],[1,-1,-3]]\\nOutput:\\n-2\\nExpected:\\n-1\\n\\nwhy answer is -1?"
                    },
                    {
                        "username": "winnie2",
                        "content": "Input:\\t[[-1],[2,3],[1,-1,-3]] \\nOutput:\\t-2 \\nExpected:\\t-1. \\n\\nIsn't -2 correct here?"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Greedy will not work"
                    },
                    {
                        "username": "user7079E",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\nFor the above test case the minumum sum should be -1\\n-1+2-3=-2 which is less than -1.\\n\\nCan you please help me understand how it is -1"
                    },
                    {
                        "username": "dylanoo",
                        "content": "I am thinking if there is a way using DP to output the minimum path? It is doable with DFS, any suggestions on how to do it with DP?"
                    },
                    {
                        "username": "suhit",
                        "content": "Why is the expected output for [[-1],[3,2],[-3,1,-1]] is -1? \\n\\t\\t-1\\n\\t\\t3      2\\n\\t-3   1   -1 \\nShouldn\\'t it be -2 as minimum sum array would then be  -1 + 2 + (-3) = -2?  \\n"
                    }
                ]
            },
            {
                "id": 1570190,
                "content": [
                    {
                        "username": "Adish19",
                        "content": "I think the question is not explained in detail\\nFor Test Case\\n[[-1],[2,3],[1,-1,-3]]\\n\\nSum should be -1 + min(2,3) + min(1,-1) = 0\\nBut Expected answer is -1\\n\\nI have tried top to bottom approach using recursion \\nBut I have seen solutions working on Bottom Up approach\\n\\nComment if I am wrong"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Guys don\\'t get confused by seeing pyramid triangular pattern its actually like this:\\n2\\n34\\n657\\n4183\\nfor input:[[2],[3,4],[6,5,7],[4,1,8,3]]\\nwe can more either i or (i+1) of next row if we start from (0,0)"
                    },
                    {
                        "username": "lalithnaren08e",
                        "content": "If we are on any particular row and the column is x\\nby adjacent column in next it means we can move to any of {x-1 , x , x+1 } columns in the next row . \\n but the solution gets accepted if we move from column x to either  x+1 or x in the next row"
                    },
                    {
                        "username": "navjot50",
                        "content": "[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n\\nFor example we are at 3, can we just move to 6 and 5 or we can move to 7 as well. Similarly, for 5 can we just move to 1 and 8 or can we move to 4 and 3 as well. Adjacent is one node on left and one on right or is it the entire below row?"
                    },
                    {
                        "username": "sj82516",
                        "content": "I got an error:\\nInput:\\n[[-1],[2,3],[1,-1,-3]]\\nOutput:\\n-2\\nExpected:\\n-1\\n\\nwhy answer is -1?"
                    },
                    {
                        "username": "winnie2",
                        "content": "Input:\\t[[-1],[2,3],[1,-1,-3]] \\nOutput:\\t-2 \\nExpected:\\t-1. \\n\\nIsn't -2 correct here?"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Greedy will not work"
                    },
                    {
                        "username": "user7079E",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\nFor the above test case the minumum sum should be -1\\n-1+2-3=-2 which is less than -1.\\n\\nCan you please help me understand how it is -1"
                    },
                    {
                        "username": "dylanoo",
                        "content": "I am thinking if there is a way using DP to output the minimum path? It is doable with DFS, any suggestions on how to do it with DP?"
                    },
                    {
                        "username": "suhit",
                        "content": "Why is the expected output for [[-1],[3,2],[-3,1,-1]] is -1? \\n\\t\\t-1\\n\\t\\t3      2\\n\\t-3   1   -1 \\nShouldn\\'t it be -2 as minimum sum array would then be  -1 + 2 + (-3) = -2?  \\n"
                    }
                ]
            },
            {
                "id": 1569311,
                "content": [
                    {
                        "username": "Adish19",
                        "content": "I think the question is not explained in detail\\nFor Test Case\\n[[-1],[2,3],[1,-1,-3]]\\n\\nSum should be -1 + min(2,3) + min(1,-1) = 0\\nBut Expected answer is -1\\n\\nI have tried top to bottom approach using recursion \\nBut I have seen solutions working on Bottom Up approach\\n\\nComment if I am wrong"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Guys don\\'t get confused by seeing pyramid triangular pattern its actually like this:\\n2\\n34\\n657\\n4183\\nfor input:[[2],[3,4],[6,5,7],[4,1,8,3]]\\nwe can more either i or (i+1) of next row if we start from (0,0)"
                    },
                    {
                        "username": "lalithnaren08e",
                        "content": "If we are on any particular row and the column is x\\nby adjacent column in next it means we can move to any of {x-1 , x , x+1 } columns in the next row . \\n but the solution gets accepted if we move from column x to either  x+1 or x in the next row"
                    },
                    {
                        "username": "navjot50",
                        "content": "[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n\\nFor example we are at 3, can we just move to 6 and 5 or we can move to 7 as well. Similarly, for 5 can we just move to 1 and 8 or can we move to 4 and 3 as well. Adjacent is one node on left and one on right or is it the entire below row?"
                    },
                    {
                        "username": "sj82516",
                        "content": "I got an error:\\nInput:\\n[[-1],[2,3],[1,-1,-3]]\\nOutput:\\n-2\\nExpected:\\n-1\\n\\nwhy answer is -1?"
                    },
                    {
                        "username": "winnie2",
                        "content": "Input:\\t[[-1],[2,3],[1,-1,-3]] \\nOutput:\\t-2 \\nExpected:\\t-1. \\n\\nIsn't -2 correct here?"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Greedy will not work"
                    },
                    {
                        "username": "user7079E",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\nFor the above test case the minumum sum should be -1\\n-1+2-3=-2 which is less than -1.\\n\\nCan you please help me understand how it is -1"
                    },
                    {
                        "username": "dylanoo",
                        "content": "I am thinking if there is a way using DP to output the minimum path? It is doable with DFS, any suggestions on how to do it with DP?"
                    },
                    {
                        "username": "suhit",
                        "content": "Why is the expected output for [[-1],[3,2],[-3,1,-1]] is -1? \\n\\t\\t-1\\n\\t\\t3      2\\n\\t-3   1   -1 \\nShouldn\\'t it be -2 as minimum sum array would then be  -1 + 2 + (-3) = -2?  \\n"
                    }
                ]
            },
            {
                "id": 1571246,
                "content": [
                    {
                        "username": "Adish19",
                        "content": "I think the question is not explained in detail\\nFor Test Case\\n[[-1],[2,3],[1,-1,-3]]\\n\\nSum should be -1 + min(2,3) + min(1,-1) = 0\\nBut Expected answer is -1\\n\\nI have tried top to bottom approach using recursion \\nBut I have seen solutions working on Bottom Up approach\\n\\nComment if I am wrong"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Guys don\\'t get confused by seeing pyramid triangular pattern its actually like this:\\n2\\n34\\n657\\n4183\\nfor input:[[2],[3,4],[6,5,7],[4,1,8,3]]\\nwe can more either i or (i+1) of next row if we start from (0,0)"
                    },
                    {
                        "username": "lalithnaren08e",
                        "content": "If we are on any particular row and the column is x\\nby adjacent column in next it means we can move to any of {x-1 , x , x+1 } columns in the next row . \\n but the solution gets accepted if we move from column x to either  x+1 or x in the next row"
                    },
                    {
                        "username": "navjot50",
                        "content": "[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n\\nFor example we are at 3, can we just move to 6 and 5 or we can move to 7 as well. Similarly, for 5 can we just move to 1 and 8 or can we move to 4 and 3 as well. Adjacent is one node on left and one on right or is it the entire below row?"
                    },
                    {
                        "username": "sj82516",
                        "content": "I got an error:\\nInput:\\n[[-1],[2,3],[1,-1,-3]]\\nOutput:\\n-2\\nExpected:\\n-1\\n\\nwhy answer is -1?"
                    },
                    {
                        "username": "winnie2",
                        "content": "Input:\\t[[-1],[2,3],[1,-1,-3]] \\nOutput:\\t-2 \\nExpected:\\t-1. \\n\\nIsn't -2 correct here?"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Greedy will not work"
                    },
                    {
                        "username": "user7079E",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\nFor the above test case the minumum sum should be -1\\n-1+2-3=-2 which is less than -1.\\n\\nCan you please help me understand how it is -1"
                    },
                    {
                        "username": "dylanoo",
                        "content": "I am thinking if there is a way using DP to output the minimum path? It is doable with DFS, any suggestions on how to do it with DP?"
                    },
                    {
                        "username": "suhit",
                        "content": "Why is the expected output for [[-1],[3,2],[-3,1,-1]] is -1? \\n\\t\\t-1\\n\\t\\t3      2\\n\\t-3   1   -1 \\nShouldn\\'t it be -2 as minimum sum array would then be  -1 + 2 + (-3) = -2?  \\n"
                    }
                ]
            },
            {
                "id": 1571249,
                "content": [
                    {
                        "username": "Adish19",
                        "content": "I think the question is not explained in detail\\nFor Test Case\\n[[-1],[2,3],[1,-1,-3]]\\n\\nSum should be -1 + min(2,3) + min(1,-1) = 0\\nBut Expected answer is -1\\n\\nI have tried top to bottom approach using recursion \\nBut I have seen solutions working on Bottom Up approach\\n\\nComment if I am wrong"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Guys don\\'t get confused by seeing pyramid triangular pattern its actually like this:\\n2\\n34\\n657\\n4183\\nfor input:[[2],[3,4],[6,5,7],[4,1,8,3]]\\nwe can more either i or (i+1) of next row if we start from (0,0)"
                    },
                    {
                        "username": "lalithnaren08e",
                        "content": "If we are on any particular row and the column is x\\nby adjacent column in next it means we can move to any of {x-1 , x , x+1 } columns in the next row . \\n but the solution gets accepted if we move from column x to either  x+1 or x in the next row"
                    },
                    {
                        "username": "navjot50",
                        "content": "[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n\\nFor example we are at 3, can we just move to 6 and 5 or we can move to 7 as well. Similarly, for 5 can we just move to 1 and 8 or can we move to 4 and 3 as well. Adjacent is one node on left and one on right or is it the entire below row?"
                    },
                    {
                        "username": "sj82516",
                        "content": "I got an error:\\nInput:\\n[[-1],[2,3],[1,-1,-3]]\\nOutput:\\n-2\\nExpected:\\n-1\\n\\nwhy answer is -1?"
                    },
                    {
                        "username": "winnie2",
                        "content": "Input:\\t[[-1],[2,3],[1,-1,-3]] \\nOutput:\\t-2 \\nExpected:\\t-1. \\n\\nIsn't -2 correct here?"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Greedy will not work"
                    },
                    {
                        "username": "user7079E",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\nFor the above test case the minumum sum should be -1\\n-1+2-3=-2 which is less than -1.\\n\\nCan you please help me understand how it is -1"
                    },
                    {
                        "username": "dylanoo",
                        "content": "I am thinking if there is a way using DP to output the minimum path? It is doable with DFS, any suggestions on how to do it with DP?"
                    },
                    {
                        "username": "suhit",
                        "content": "Why is the expected output for [[-1],[3,2],[-3,1,-1]] is -1? \\n\\t\\t-1\\n\\t\\t3      2\\n\\t-3   1   -1 \\nShouldn\\'t it be -2 as minimum sum array would then be  -1 + 2 + (-3) = -2?  \\n"
                    }
                ]
            },
            {
                "id": 1980258,
                "content": [
                    {
                        "username": "Adish19",
                        "content": "I think the question is not explained in detail\\nFor Test Case\\n[[-1],[2,3],[1,-1,-3]]\\n\\nSum should be -1 + min(2,3) + min(1,-1) = 0\\nBut Expected answer is -1\\n\\nI have tried top to bottom approach using recursion \\nBut I have seen solutions working on Bottom Up approach\\n\\nComment if I am wrong"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Guys don\\'t get confused by seeing pyramid triangular pattern its actually like this:\\n2\\n34\\n657\\n4183\\nfor input:[[2],[3,4],[6,5,7],[4,1,8,3]]\\nwe can more either i or (i+1) of next row if we start from (0,0)"
                    },
                    {
                        "username": "lalithnaren08e",
                        "content": "If we are on any particular row and the column is x\\nby adjacent column in next it means we can move to any of {x-1 , x , x+1 } columns in the next row . \\n but the solution gets accepted if we move from column x to either  x+1 or x in the next row"
                    },
                    {
                        "username": "navjot50",
                        "content": "[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n\\nFor example we are at 3, can we just move to 6 and 5 or we can move to 7 as well. Similarly, for 5 can we just move to 1 and 8 or can we move to 4 and 3 as well. Adjacent is one node on left and one on right or is it the entire below row?"
                    },
                    {
                        "username": "sj82516",
                        "content": "I got an error:\\nInput:\\n[[-1],[2,3],[1,-1,-3]]\\nOutput:\\n-2\\nExpected:\\n-1\\n\\nwhy answer is -1?"
                    },
                    {
                        "username": "winnie2",
                        "content": "Input:\\t[[-1],[2,3],[1,-1,-3]] \\nOutput:\\t-2 \\nExpected:\\t-1. \\n\\nIsn't -2 correct here?"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Greedy will not work"
                    },
                    {
                        "username": "user7079E",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\nFor the above test case the minumum sum should be -1\\n-1+2-3=-2 which is less than -1.\\n\\nCan you please help me understand how it is -1"
                    },
                    {
                        "username": "dylanoo",
                        "content": "I am thinking if there is a way using DP to output the minimum path? It is doable with DFS, any suggestions on how to do it with DP?"
                    },
                    {
                        "username": "suhit",
                        "content": "Why is the expected output for [[-1],[3,2],[-3,1,-1]] is -1? \\n\\t\\t-1\\n\\t\\t3      2\\n\\t-3   1   -1 \\nShouldn\\'t it be -2 as minimum sum array would then be  -1 + 2 + (-3) = -2?  \\n"
                    }
                ]
            },
            {
                "id": 1574453,
                "content": [
                    {
                        "username": "Adish19",
                        "content": "I think the question is not explained in detail\\nFor Test Case\\n[[-1],[2,3],[1,-1,-3]]\\n\\nSum should be -1 + min(2,3) + min(1,-1) = 0\\nBut Expected answer is -1\\n\\nI have tried top to bottom approach using recursion \\nBut I have seen solutions working on Bottom Up approach\\n\\nComment if I am wrong"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Guys don\\'t get confused by seeing pyramid triangular pattern its actually like this:\\n2\\n34\\n657\\n4183\\nfor input:[[2],[3,4],[6,5,7],[4,1,8,3]]\\nwe can more either i or (i+1) of next row if we start from (0,0)"
                    },
                    {
                        "username": "lalithnaren08e",
                        "content": "If we are on any particular row and the column is x\\nby adjacent column in next it means we can move to any of {x-1 , x , x+1 } columns in the next row . \\n but the solution gets accepted if we move from column x to either  x+1 or x in the next row"
                    },
                    {
                        "username": "navjot50",
                        "content": "[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n\\nFor example we are at 3, can we just move to 6 and 5 or we can move to 7 as well. Similarly, for 5 can we just move to 1 and 8 or can we move to 4 and 3 as well. Adjacent is one node on left and one on right or is it the entire below row?"
                    },
                    {
                        "username": "sj82516",
                        "content": "I got an error:\\nInput:\\n[[-1],[2,3],[1,-1,-3]]\\nOutput:\\n-2\\nExpected:\\n-1\\n\\nwhy answer is -1?"
                    },
                    {
                        "username": "winnie2",
                        "content": "Input:\\t[[-1],[2,3],[1,-1,-3]] \\nOutput:\\t-2 \\nExpected:\\t-1. \\n\\nIsn't -2 correct here?"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Greedy will not work"
                    },
                    {
                        "username": "user7079E",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\nFor the above test case the minumum sum should be -1\\n-1+2-3=-2 which is less than -1.\\n\\nCan you please help me understand how it is -1"
                    },
                    {
                        "username": "dylanoo",
                        "content": "I am thinking if there is a way using DP to output the minimum path? It is doable with DFS, any suggestions on how to do it with DP?"
                    },
                    {
                        "username": "suhit",
                        "content": "Why is the expected output for [[-1],[3,2],[-3,1,-1]] is -1? \\n\\t\\t-1\\n\\t\\t3      2\\n\\t-3   1   -1 \\nShouldn\\'t it be -2 as minimum sum array would then be  -1 + 2 + (-3) = -2?  \\n"
                    }
                ]
            },
            {
                "id": 1572451,
                "content": [
                    {
                        "username": "Adish19",
                        "content": "I think the question is not explained in detail\\nFor Test Case\\n[[-1],[2,3],[1,-1,-3]]\\n\\nSum should be -1 + min(2,3) + min(1,-1) = 0\\nBut Expected answer is -1\\n\\nI have tried top to bottom approach using recursion \\nBut I have seen solutions working on Bottom Up approach\\n\\nComment if I am wrong"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Guys don\\'t get confused by seeing pyramid triangular pattern its actually like this:\\n2\\n34\\n657\\n4183\\nfor input:[[2],[3,4],[6,5,7],[4,1,8,3]]\\nwe can more either i or (i+1) of next row if we start from (0,0)"
                    },
                    {
                        "username": "lalithnaren08e",
                        "content": "If we are on any particular row and the column is x\\nby adjacent column in next it means we can move to any of {x-1 , x , x+1 } columns in the next row . \\n but the solution gets accepted if we move from column x to either  x+1 or x in the next row"
                    },
                    {
                        "username": "navjot50",
                        "content": "[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n\\nFor example we are at 3, can we just move to 6 and 5 or we can move to 7 as well. Similarly, for 5 can we just move to 1 and 8 or can we move to 4 and 3 as well. Adjacent is one node on left and one on right or is it the entire below row?"
                    },
                    {
                        "username": "sj82516",
                        "content": "I got an error:\\nInput:\\n[[-1],[2,3],[1,-1,-3]]\\nOutput:\\n-2\\nExpected:\\n-1\\n\\nwhy answer is -1?"
                    },
                    {
                        "username": "winnie2",
                        "content": "Input:\\t[[-1],[2,3],[1,-1,-3]] \\nOutput:\\t-2 \\nExpected:\\t-1. \\n\\nIsn't -2 correct here?"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Greedy will not work"
                    },
                    {
                        "username": "user7079E",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\nFor the above test case the minumum sum should be -1\\n-1+2-3=-2 which is less than -1.\\n\\nCan you please help me understand how it is -1"
                    },
                    {
                        "username": "dylanoo",
                        "content": "I am thinking if there is a way using DP to output the minimum path? It is doable with DFS, any suggestions on how to do it with DP?"
                    },
                    {
                        "username": "suhit",
                        "content": "Why is the expected output for [[-1],[3,2],[-3,1,-1]] is -1? \\n\\t\\t-1\\n\\t\\t3      2\\n\\t-3   1   -1 \\nShouldn\\'t it be -2 as minimum sum array would then be  -1 + 2 + (-3) = -2?  \\n"
                    }
                ]
            },
            {
                "id": 1572148,
                "content": [
                    {
                        "username": "Adish19",
                        "content": "I think the question is not explained in detail\\nFor Test Case\\n[[-1],[2,3],[1,-1,-3]]\\n\\nSum should be -1 + min(2,3) + min(1,-1) = 0\\nBut Expected answer is -1\\n\\nI have tried top to bottom approach using recursion \\nBut I have seen solutions working on Bottom Up approach\\n\\nComment if I am wrong"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Guys don\\'t get confused by seeing pyramid triangular pattern its actually like this:\\n2\\n34\\n657\\n4183\\nfor input:[[2],[3,4],[6,5,7],[4,1,8,3]]\\nwe can more either i or (i+1) of next row if we start from (0,0)"
                    },
                    {
                        "username": "lalithnaren08e",
                        "content": "If we are on any particular row and the column is x\\nby adjacent column in next it means we can move to any of {x-1 , x , x+1 } columns in the next row . \\n but the solution gets accepted if we move from column x to either  x+1 or x in the next row"
                    },
                    {
                        "username": "navjot50",
                        "content": "[\\n     [2],\\n    [3,4],\\n   [6,5,7],\\n  [4,1,8,3]\\n]\\n\\nFor example we are at 3, can we just move to 6 and 5 or we can move to 7 as well. Similarly, for 5 can we just move to 1 and 8 or can we move to 4 and 3 as well. Adjacent is one node on left and one on right or is it the entire below row?"
                    },
                    {
                        "username": "sj82516",
                        "content": "I got an error:\\nInput:\\n[[-1],[2,3],[1,-1,-3]]\\nOutput:\\n-2\\nExpected:\\n-1\\n\\nwhy answer is -1?"
                    },
                    {
                        "username": "winnie2",
                        "content": "Input:\\t[[-1],[2,3],[1,-1,-3]] \\nOutput:\\t-2 \\nExpected:\\t-1. \\n\\nIsn't -2 correct here?"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "Greedy will not work"
                    },
                    {
                        "username": "user7079E",
                        "content": "[[-1],[2,3],[1,-1,-3]]\\n\\nFor the above test case the minumum sum should be -1\\n-1+2-3=-2 which is less than -1.\\n\\nCan you please help me understand how it is -1"
                    },
                    {
                        "username": "dylanoo",
                        "content": "I am thinking if there is a way using DP to output the minimum path? It is doable with DFS, any suggestions on how to do it with DP?"
                    },
                    {
                        "username": "suhit",
                        "content": "Why is the expected output for [[-1],[3,2],[-3,1,-1]] is -1? \\n\\t\\t-1\\n\\t\\t3      2\\n\\t-3   1   -1 \\nShouldn\\'t it be -2 as minimum sum array would then be  -1 + 2 + (-3) = -2?  \\n"
                    }
                ]
            },
            {
                "id": 1571245,
                "content": [
                    {
                        "username": "maanick90",
                        "content": "I've been confused when the submission result showed this. -2 is minimum compared to -1 and then I wondered why it showed like this?\\n\\n![0_1481158041590_upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20](/uploads/files/1481158047726-upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20.png)"
                    },
                    {
                        "username": "ngcl",
                        "content": "I got stuck in the definition of the \"adjacent numbers on the row below\".\\n\\nIn this problem, the \"adjacent number on the row below\" does not contain the \"left one\".\\n\\nFor instance, the adjacent number of \"3\" on the row below is {5, 6}, rather than {4, 5, 6}.\\n\\n\\n    [1],\\n    [2, 3],\\n    [4 ,5, 6]"
                    },
                    {
                        "username": "nitin5",
                        "content": "just to clear adjacent here means same index or index +1 and not index -1."
                    },
                    {
                        "username": "cobblau",
                        "content": "Could someone give a precise explanation?   \\n(Please answer with fluent English. Chinglish is rejected!)"
                    },
                    {
                        "username": "markfortma",
                        "content": "The expected result of -1 for [[-1],[2,3],[1,-1,-3]] is only possible to traverse the triangle contrary to the instructions, as in from the end.\\n\\nAccording to the instructions, it\\'s supposed to be 0 to nth row, which means it should be \"-1 + 2 + -1\" since the instructions say, \"such that the next row is either index i or index i + 1.\"\\n\\nIf we perform the evaluation from nth to 0, where we choose the smallest value in the nth array; the path (only) then becomes \"-3 + 3 + -1\"\\n\\nEither update the instructions or update the test cases because this is wrong."
                    },
                    {
                        "username": "androidcarson",
                        "content": "if only the problem had more examples and a longer accurate description, most of the devs attempting to solve it wouldn\\'t have to read the discussion to figure out what it actually wants us to solve"
                    },
                    {
                        "username": "Vinay_000000",
                        "content": "Read the question carefully : \nwe can only move down or down_right"
                    },
                    {
                        "username": "LAKKAPPA_BASIDONI",
                        "content": "This question not implimented  correctly.\\ndon\\'t try this problem \\nsolve other problem\\nsave your time\\ntriangle =  [[-1],[2,3],[1,-1,-3]]\\nOutput =-2 //this is correct output\\nExpected =-1\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I tried this recursion but was getting TLE so did some research and found a technique called memoization which sped it up dramatically (beats 95%).\n\nBasically, you just create a table and store the result of each recursive calculation there so then if you recurse that \"node\" again, you just use the previously calculated result.\n\nExample:\n\n    if (memo[y][x] != - 1)\n        return memo[y][x];\n\n// resursive function\n\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "looks similar to minimum path sum\\n"
                    }
                ]
            },
            {
                "id": 1571247,
                "content": [
                    {
                        "username": "maanick90",
                        "content": "I've been confused when the submission result showed this. -2 is minimum compared to -1 and then I wondered why it showed like this?\\n\\n![0_1481158041590_upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20](/uploads/files/1481158047726-upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20.png)"
                    },
                    {
                        "username": "ngcl",
                        "content": "I got stuck in the definition of the \"adjacent numbers on the row below\".\\n\\nIn this problem, the \"adjacent number on the row below\" does not contain the \"left one\".\\n\\nFor instance, the adjacent number of \"3\" on the row below is {5, 6}, rather than {4, 5, 6}.\\n\\n\\n    [1],\\n    [2, 3],\\n    [4 ,5, 6]"
                    },
                    {
                        "username": "nitin5",
                        "content": "just to clear adjacent here means same index or index +1 and not index -1."
                    },
                    {
                        "username": "cobblau",
                        "content": "Could someone give a precise explanation?   \\n(Please answer with fluent English. Chinglish is rejected!)"
                    },
                    {
                        "username": "markfortma",
                        "content": "The expected result of -1 for [[-1],[2,3],[1,-1,-3]] is only possible to traverse the triangle contrary to the instructions, as in from the end.\\n\\nAccording to the instructions, it\\'s supposed to be 0 to nth row, which means it should be \"-1 + 2 + -1\" since the instructions say, \"such that the next row is either index i or index i + 1.\"\\n\\nIf we perform the evaluation from nth to 0, where we choose the smallest value in the nth array; the path (only) then becomes \"-3 + 3 + -1\"\\n\\nEither update the instructions or update the test cases because this is wrong."
                    },
                    {
                        "username": "androidcarson",
                        "content": "if only the problem had more examples and a longer accurate description, most of the devs attempting to solve it wouldn\\'t have to read the discussion to figure out what it actually wants us to solve"
                    },
                    {
                        "username": "Vinay_000000",
                        "content": "Read the question carefully : \nwe can only move down or down_right"
                    },
                    {
                        "username": "LAKKAPPA_BASIDONI",
                        "content": "This question not implimented  correctly.\\ndon\\'t try this problem \\nsolve other problem\\nsave your time\\ntriangle =  [[-1],[2,3],[1,-1,-3]]\\nOutput =-2 //this is correct output\\nExpected =-1\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I tried this recursion but was getting TLE so did some research and found a technique called memoization which sped it up dramatically (beats 95%).\n\nBasically, you just create a table and store the result of each recursive calculation there so then if you recurse that \"node\" again, you just use the previously calculated result.\n\nExample:\n\n    if (memo[y][x] != - 1)\n        return memo[y][x];\n\n// resursive function\n\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "looks similar to minimum path sum\\n"
                    }
                ]
            },
            {
                "id": 1568937,
                "content": [
                    {
                        "username": "maanick90",
                        "content": "I've been confused when the submission result showed this. -2 is minimum compared to -1 and then I wondered why it showed like this?\\n\\n![0_1481158041590_upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20](/uploads/files/1481158047726-upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20.png)"
                    },
                    {
                        "username": "ngcl",
                        "content": "I got stuck in the definition of the \"adjacent numbers on the row below\".\\n\\nIn this problem, the \"adjacent number on the row below\" does not contain the \"left one\".\\n\\nFor instance, the adjacent number of \"3\" on the row below is {5, 6}, rather than {4, 5, 6}.\\n\\n\\n    [1],\\n    [2, 3],\\n    [4 ,5, 6]"
                    },
                    {
                        "username": "nitin5",
                        "content": "just to clear adjacent here means same index or index +1 and not index -1."
                    },
                    {
                        "username": "cobblau",
                        "content": "Could someone give a precise explanation?   \\n(Please answer with fluent English. Chinglish is rejected!)"
                    },
                    {
                        "username": "markfortma",
                        "content": "The expected result of -1 for [[-1],[2,3],[1,-1,-3]] is only possible to traverse the triangle contrary to the instructions, as in from the end.\\n\\nAccording to the instructions, it\\'s supposed to be 0 to nth row, which means it should be \"-1 + 2 + -1\" since the instructions say, \"such that the next row is either index i or index i + 1.\"\\n\\nIf we perform the evaluation from nth to 0, where we choose the smallest value in the nth array; the path (only) then becomes \"-3 + 3 + -1\"\\n\\nEither update the instructions or update the test cases because this is wrong."
                    },
                    {
                        "username": "androidcarson",
                        "content": "if only the problem had more examples and a longer accurate description, most of the devs attempting to solve it wouldn\\'t have to read the discussion to figure out what it actually wants us to solve"
                    },
                    {
                        "username": "Vinay_000000",
                        "content": "Read the question carefully : \nwe can only move down or down_right"
                    },
                    {
                        "username": "LAKKAPPA_BASIDONI",
                        "content": "This question not implimented  correctly.\\ndon\\'t try this problem \\nsolve other problem\\nsave your time\\ntriangle =  [[-1],[2,3],[1,-1,-3]]\\nOutput =-2 //this is correct output\\nExpected =-1\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I tried this recursion but was getting TLE so did some research and found a technique called memoization which sped it up dramatically (beats 95%).\n\nBasically, you just create a table and store the result of each recursive calculation there so then if you recurse that \"node\" again, you just use the previously calculated result.\n\nExample:\n\n    if (memo[y][x] != - 1)\n        return memo[y][x];\n\n// resursive function\n\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "looks similar to minimum path sum\\n"
                    }
                ]
            },
            {
                "id": 1567197,
                "content": [
                    {
                        "username": "maanick90",
                        "content": "I've been confused when the submission result showed this. -2 is minimum compared to -1 and then I wondered why it showed like this?\\n\\n![0_1481158041590_upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20](/uploads/files/1481158047726-upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20.png)"
                    },
                    {
                        "username": "ngcl",
                        "content": "I got stuck in the definition of the \"adjacent numbers on the row below\".\\n\\nIn this problem, the \"adjacent number on the row below\" does not contain the \"left one\".\\n\\nFor instance, the adjacent number of \"3\" on the row below is {5, 6}, rather than {4, 5, 6}.\\n\\n\\n    [1],\\n    [2, 3],\\n    [4 ,5, 6]"
                    },
                    {
                        "username": "nitin5",
                        "content": "just to clear adjacent here means same index or index +1 and not index -1."
                    },
                    {
                        "username": "cobblau",
                        "content": "Could someone give a precise explanation?   \\n(Please answer with fluent English. Chinglish is rejected!)"
                    },
                    {
                        "username": "markfortma",
                        "content": "The expected result of -1 for [[-1],[2,3],[1,-1,-3]] is only possible to traverse the triangle contrary to the instructions, as in from the end.\\n\\nAccording to the instructions, it\\'s supposed to be 0 to nth row, which means it should be \"-1 + 2 + -1\" since the instructions say, \"such that the next row is either index i or index i + 1.\"\\n\\nIf we perform the evaluation from nth to 0, where we choose the smallest value in the nth array; the path (only) then becomes \"-3 + 3 + -1\"\\n\\nEither update the instructions or update the test cases because this is wrong."
                    },
                    {
                        "username": "androidcarson",
                        "content": "if only the problem had more examples and a longer accurate description, most of the devs attempting to solve it wouldn\\'t have to read the discussion to figure out what it actually wants us to solve"
                    },
                    {
                        "username": "Vinay_000000",
                        "content": "Read the question carefully : \nwe can only move down or down_right"
                    },
                    {
                        "username": "LAKKAPPA_BASIDONI",
                        "content": "This question not implimented  correctly.\\ndon\\'t try this problem \\nsolve other problem\\nsave your time\\ntriangle =  [[-1],[2,3],[1,-1,-3]]\\nOutput =-2 //this is correct output\\nExpected =-1\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I tried this recursion but was getting TLE so did some research and found a technique called memoization which sped it up dramatically (beats 95%).\n\nBasically, you just create a table and store the result of each recursive calculation there so then if you recurse that \"node\" again, you just use the previously calculated result.\n\nExample:\n\n    if (memo[y][x] != - 1)\n        return memo[y][x];\n\n// resursive function\n\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "looks similar to minimum path sum\\n"
                    }
                ]
            },
            {
                "id": 2067722,
                "content": [
                    {
                        "username": "maanick90",
                        "content": "I've been confused when the submission result showed this. -2 is minimum compared to -1 and then I wondered why it showed like this?\\n\\n![0_1481158041590_upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20](/uploads/files/1481158047726-upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20.png)"
                    },
                    {
                        "username": "ngcl",
                        "content": "I got stuck in the definition of the \"adjacent numbers on the row below\".\\n\\nIn this problem, the \"adjacent number on the row below\" does not contain the \"left one\".\\n\\nFor instance, the adjacent number of \"3\" on the row below is {5, 6}, rather than {4, 5, 6}.\\n\\n\\n    [1],\\n    [2, 3],\\n    [4 ,5, 6]"
                    },
                    {
                        "username": "nitin5",
                        "content": "just to clear adjacent here means same index or index +1 and not index -1."
                    },
                    {
                        "username": "cobblau",
                        "content": "Could someone give a precise explanation?   \\n(Please answer with fluent English. Chinglish is rejected!)"
                    },
                    {
                        "username": "markfortma",
                        "content": "The expected result of -1 for [[-1],[2,3],[1,-1,-3]] is only possible to traverse the triangle contrary to the instructions, as in from the end.\\n\\nAccording to the instructions, it\\'s supposed to be 0 to nth row, which means it should be \"-1 + 2 + -1\" since the instructions say, \"such that the next row is either index i or index i + 1.\"\\n\\nIf we perform the evaluation from nth to 0, where we choose the smallest value in the nth array; the path (only) then becomes \"-3 + 3 + -1\"\\n\\nEither update the instructions or update the test cases because this is wrong."
                    },
                    {
                        "username": "androidcarson",
                        "content": "if only the problem had more examples and a longer accurate description, most of the devs attempting to solve it wouldn\\'t have to read the discussion to figure out what it actually wants us to solve"
                    },
                    {
                        "username": "Vinay_000000",
                        "content": "Read the question carefully : \nwe can only move down or down_right"
                    },
                    {
                        "username": "LAKKAPPA_BASIDONI",
                        "content": "This question not implimented  correctly.\\ndon\\'t try this problem \\nsolve other problem\\nsave your time\\ntriangle =  [[-1],[2,3],[1,-1,-3]]\\nOutput =-2 //this is correct output\\nExpected =-1\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I tried this recursion but was getting TLE so did some research and found a technique called memoization which sped it up dramatically (beats 95%).\n\nBasically, you just create a table and store the result of each recursive calculation there so then if you recurse that \"node\" again, you just use the previously calculated result.\n\nExample:\n\n    if (memo[y][x] != - 1)\n        return memo[y][x];\n\n// resursive function\n\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "looks similar to minimum path sum\\n"
                    }
                ]
            },
            {
                "id": 2037637,
                "content": [
                    {
                        "username": "maanick90",
                        "content": "I've been confused when the submission result showed this. -2 is minimum compared to -1 and then I wondered why it showed like this?\\n\\n![0_1481158041590_upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20](/uploads/files/1481158047726-upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20.png)"
                    },
                    {
                        "username": "ngcl",
                        "content": "I got stuck in the definition of the \"adjacent numbers on the row below\".\\n\\nIn this problem, the \"adjacent number on the row below\" does not contain the \"left one\".\\n\\nFor instance, the adjacent number of \"3\" on the row below is {5, 6}, rather than {4, 5, 6}.\\n\\n\\n    [1],\\n    [2, 3],\\n    [4 ,5, 6]"
                    },
                    {
                        "username": "nitin5",
                        "content": "just to clear adjacent here means same index or index +1 and not index -1."
                    },
                    {
                        "username": "cobblau",
                        "content": "Could someone give a precise explanation?   \\n(Please answer with fluent English. Chinglish is rejected!)"
                    },
                    {
                        "username": "markfortma",
                        "content": "The expected result of -1 for [[-1],[2,3],[1,-1,-3]] is only possible to traverse the triangle contrary to the instructions, as in from the end.\\n\\nAccording to the instructions, it\\'s supposed to be 0 to nth row, which means it should be \"-1 + 2 + -1\" since the instructions say, \"such that the next row is either index i or index i + 1.\"\\n\\nIf we perform the evaluation from nth to 0, where we choose the smallest value in the nth array; the path (only) then becomes \"-3 + 3 + -1\"\\n\\nEither update the instructions or update the test cases because this is wrong."
                    },
                    {
                        "username": "androidcarson",
                        "content": "if only the problem had more examples and a longer accurate description, most of the devs attempting to solve it wouldn\\'t have to read the discussion to figure out what it actually wants us to solve"
                    },
                    {
                        "username": "Vinay_000000",
                        "content": "Read the question carefully : \nwe can only move down or down_right"
                    },
                    {
                        "username": "LAKKAPPA_BASIDONI",
                        "content": "This question not implimented  correctly.\\ndon\\'t try this problem \\nsolve other problem\\nsave your time\\ntriangle =  [[-1],[2,3],[1,-1,-3]]\\nOutput =-2 //this is correct output\\nExpected =-1\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I tried this recursion but was getting TLE so did some research and found a technique called memoization which sped it up dramatically (beats 95%).\n\nBasically, you just create a table and store the result of each recursive calculation there so then if you recurse that \"node\" again, you just use the previously calculated result.\n\nExample:\n\n    if (memo[y][x] != - 1)\n        return memo[y][x];\n\n// resursive function\n\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "looks similar to minimum path sum\\n"
                    }
                ]
            },
            {
                "id": 2035737,
                "content": [
                    {
                        "username": "maanick90",
                        "content": "I've been confused when the submission result showed this. -2 is minimum compared to -1 and then I wondered why it showed like this?\\n\\n![0_1481158041590_upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20](/uploads/files/1481158047726-upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20.png)"
                    },
                    {
                        "username": "ngcl",
                        "content": "I got stuck in the definition of the \"adjacent numbers on the row below\".\\n\\nIn this problem, the \"adjacent number on the row below\" does not contain the \"left one\".\\n\\nFor instance, the adjacent number of \"3\" on the row below is {5, 6}, rather than {4, 5, 6}.\\n\\n\\n    [1],\\n    [2, 3],\\n    [4 ,5, 6]"
                    },
                    {
                        "username": "nitin5",
                        "content": "just to clear adjacent here means same index or index +1 and not index -1."
                    },
                    {
                        "username": "cobblau",
                        "content": "Could someone give a precise explanation?   \\n(Please answer with fluent English. Chinglish is rejected!)"
                    },
                    {
                        "username": "markfortma",
                        "content": "The expected result of -1 for [[-1],[2,3],[1,-1,-3]] is only possible to traverse the triangle contrary to the instructions, as in from the end.\\n\\nAccording to the instructions, it\\'s supposed to be 0 to nth row, which means it should be \"-1 + 2 + -1\" since the instructions say, \"such that the next row is either index i or index i + 1.\"\\n\\nIf we perform the evaluation from nth to 0, where we choose the smallest value in the nth array; the path (only) then becomes \"-3 + 3 + -1\"\\n\\nEither update the instructions or update the test cases because this is wrong."
                    },
                    {
                        "username": "androidcarson",
                        "content": "if only the problem had more examples and a longer accurate description, most of the devs attempting to solve it wouldn\\'t have to read the discussion to figure out what it actually wants us to solve"
                    },
                    {
                        "username": "Vinay_000000",
                        "content": "Read the question carefully : \nwe can only move down or down_right"
                    },
                    {
                        "username": "LAKKAPPA_BASIDONI",
                        "content": "This question not implimented  correctly.\\ndon\\'t try this problem \\nsolve other problem\\nsave your time\\ntriangle =  [[-1],[2,3],[1,-1,-3]]\\nOutput =-2 //this is correct output\\nExpected =-1\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I tried this recursion but was getting TLE so did some research and found a technique called memoization which sped it up dramatically (beats 95%).\n\nBasically, you just create a table and store the result of each recursive calculation there so then if you recurse that \"node\" again, you just use the previously calculated result.\n\nExample:\n\n    if (memo[y][x] != - 1)\n        return memo[y][x];\n\n// resursive function\n\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "looks similar to minimum path sum\\n"
                    }
                ]
            },
            {
                "id": 2018259,
                "content": [
                    {
                        "username": "maanick90",
                        "content": "I've been confused when the submission result showed this. -2 is minimum compared to -1 and then I wondered why it showed like this?\\n\\n![0_1481158041590_upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20](/uploads/files/1481158047726-upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20.png)"
                    },
                    {
                        "username": "ngcl",
                        "content": "I got stuck in the definition of the \"adjacent numbers on the row below\".\\n\\nIn this problem, the \"adjacent number on the row below\" does not contain the \"left one\".\\n\\nFor instance, the adjacent number of \"3\" on the row below is {5, 6}, rather than {4, 5, 6}.\\n\\n\\n    [1],\\n    [2, 3],\\n    [4 ,5, 6]"
                    },
                    {
                        "username": "nitin5",
                        "content": "just to clear adjacent here means same index or index +1 and not index -1."
                    },
                    {
                        "username": "cobblau",
                        "content": "Could someone give a precise explanation?   \\n(Please answer with fluent English. Chinglish is rejected!)"
                    },
                    {
                        "username": "markfortma",
                        "content": "The expected result of -1 for [[-1],[2,3],[1,-1,-3]] is only possible to traverse the triangle contrary to the instructions, as in from the end.\\n\\nAccording to the instructions, it\\'s supposed to be 0 to nth row, which means it should be \"-1 + 2 + -1\" since the instructions say, \"such that the next row is either index i or index i + 1.\"\\n\\nIf we perform the evaluation from nth to 0, where we choose the smallest value in the nth array; the path (only) then becomes \"-3 + 3 + -1\"\\n\\nEither update the instructions or update the test cases because this is wrong."
                    },
                    {
                        "username": "androidcarson",
                        "content": "if only the problem had more examples and a longer accurate description, most of the devs attempting to solve it wouldn\\'t have to read the discussion to figure out what it actually wants us to solve"
                    },
                    {
                        "username": "Vinay_000000",
                        "content": "Read the question carefully : \nwe can only move down or down_right"
                    },
                    {
                        "username": "LAKKAPPA_BASIDONI",
                        "content": "This question not implimented  correctly.\\ndon\\'t try this problem \\nsolve other problem\\nsave your time\\ntriangle =  [[-1],[2,3],[1,-1,-3]]\\nOutput =-2 //this is correct output\\nExpected =-1\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I tried this recursion but was getting TLE so did some research and found a technique called memoization which sped it up dramatically (beats 95%).\n\nBasically, you just create a table and store the result of each recursive calculation there so then if you recurse that \"node\" again, you just use the previously calculated result.\n\nExample:\n\n    if (memo[y][x] != - 1)\n        return memo[y][x];\n\n// resursive function\n\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "looks similar to minimum path sum\\n"
                    }
                ]
            },
            {
                "id": 2006826,
                "content": [
                    {
                        "username": "maanick90",
                        "content": "I've been confused when the submission result showed this. -2 is minimum compared to -1 and then I wondered why it showed like this?\\n\\n![0_1481158041590_upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20](/uploads/files/1481158047726-upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20.png)"
                    },
                    {
                        "username": "ngcl",
                        "content": "I got stuck in the definition of the \"adjacent numbers on the row below\".\\n\\nIn this problem, the \"adjacent number on the row below\" does not contain the \"left one\".\\n\\nFor instance, the adjacent number of \"3\" on the row below is {5, 6}, rather than {4, 5, 6}.\\n\\n\\n    [1],\\n    [2, 3],\\n    [4 ,5, 6]"
                    },
                    {
                        "username": "nitin5",
                        "content": "just to clear adjacent here means same index or index +1 and not index -1."
                    },
                    {
                        "username": "cobblau",
                        "content": "Could someone give a precise explanation?   \\n(Please answer with fluent English. Chinglish is rejected!)"
                    },
                    {
                        "username": "markfortma",
                        "content": "The expected result of -1 for [[-1],[2,3],[1,-1,-3]] is only possible to traverse the triangle contrary to the instructions, as in from the end.\\n\\nAccording to the instructions, it\\'s supposed to be 0 to nth row, which means it should be \"-1 + 2 + -1\" since the instructions say, \"such that the next row is either index i or index i + 1.\"\\n\\nIf we perform the evaluation from nth to 0, where we choose the smallest value in the nth array; the path (only) then becomes \"-3 + 3 + -1\"\\n\\nEither update the instructions or update the test cases because this is wrong."
                    },
                    {
                        "username": "androidcarson",
                        "content": "if only the problem had more examples and a longer accurate description, most of the devs attempting to solve it wouldn\\'t have to read the discussion to figure out what it actually wants us to solve"
                    },
                    {
                        "username": "Vinay_000000",
                        "content": "Read the question carefully : \nwe can only move down or down_right"
                    },
                    {
                        "username": "LAKKAPPA_BASIDONI",
                        "content": "This question not implimented  correctly.\\ndon\\'t try this problem \\nsolve other problem\\nsave your time\\ntriangle =  [[-1],[2,3],[1,-1,-3]]\\nOutput =-2 //this is correct output\\nExpected =-1\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I tried this recursion but was getting TLE so did some research and found a technique called memoization which sped it up dramatically (beats 95%).\n\nBasically, you just create a table and store the result of each recursive calculation there so then if you recurse that \"node\" again, you just use the previously calculated result.\n\nExample:\n\n    if (memo[y][x] != - 1)\n        return memo[y][x];\n\n// resursive function\n\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "looks similar to minimum path sum\\n"
                    }
                ]
            },
            {
                "id": 1899560,
                "content": [
                    {
                        "username": "maanick90",
                        "content": "I've been confused when the submission result showed this. -2 is minimum compared to -1 and then I wondered why it showed like this?\\n\\n![0_1481158041590_upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20](/uploads/files/1481158047726-upload-a8373ebe-6616-46bd-97f6-6d8e44bc4a20.png)"
                    },
                    {
                        "username": "ngcl",
                        "content": "I got stuck in the definition of the \"adjacent numbers on the row below\".\\n\\nIn this problem, the \"adjacent number on the row below\" does not contain the \"left one\".\\n\\nFor instance, the adjacent number of \"3\" on the row below is {5, 6}, rather than {4, 5, 6}.\\n\\n\\n    [1],\\n    [2, 3],\\n    [4 ,5, 6]"
                    },
                    {
                        "username": "nitin5",
                        "content": "just to clear adjacent here means same index or index +1 and not index -1."
                    },
                    {
                        "username": "cobblau",
                        "content": "Could someone give a precise explanation?   \\n(Please answer with fluent English. Chinglish is rejected!)"
                    },
                    {
                        "username": "markfortma",
                        "content": "The expected result of -1 for [[-1],[2,3],[1,-1,-3]] is only possible to traverse the triangle contrary to the instructions, as in from the end.\\n\\nAccording to the instructions, it\\'s supposed to be 0 to nth row, which means it should be \"-1 + 2 + -1\" since the instructions say, \"such that the next row is either index i or index i + 1.\"\\n\\nIf we perform the evaluation from nth to 0, where we choose the smallest value in the nth array; the path (only) then becomes \"-3 + 3 + -1\"\\n\\nEither update the instructions or update the test cases because this is wrong."
                    },
                    {
                        "username": "androidcarson",
                        "content": "if only the problem had more examples and a longer accurate description, most of the devs attempting to solve it wouldn\\'t have to read the discussion to figure out what it actually wants us to solve"
                    },
                    {
                        "username": "Vinay_000000",
                        "content": "Read the question carefully : \nwe can only move down or down_right"
                    },
                    {
                        "username": "LAKKAPPA_BASIDONI",
                        "content": "This question not implimented  correctly.\\ndon\\'t try this problem \\nsolve other problem\\nsave your time\\ntriangle =  [[-1],[2,3],[1,-1,-3]]\\nOutput =-2 //this is correct output\\nExpected =-1\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I tried this recursion but was getting TLE so did some research and found a technique called memoization which sped it up dramatically (beats 95%).\n\nBasically, you just create a table and store the result of each recursive calculation there so then if you recurse that \"node\" again, you just use the previously calculated result.\n\nExample:\n\n    if (memo[y][x] != - 1)\n        return memo[y][x];\n\n// resursive function\n\n    memo[y][x] = tri[y][x] + (left < right ? left : right);\n    return memo[y][x];\n"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "looks similar to minimum path sum\\n"
                    }
                ]
            },
            {
                "id": 1899022,
                "content": [
                    {
                        "username": "20BCS225",
                        "content": "is this problem can be solved by recursion??\\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "yes but time complexity will be higher so we can use dp here"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]] answer is -1 why not -2 ???????????\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]]  answer is -1 why not -2 ???????????"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just because -2 is not possible you can only move either on same index or on i+1 index"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[[-1],[-2,-3]]\\n   -1\\n-2 -3 \\n\\nThe shortest path is -1 + -2 so it\\'s -3.\\nWhy submission says it should be -4? xd\\nSomeone was drunk desgining those test cases?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "It\\'s clearly -4 as the shortest path is -1 + - 3 = - 4"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Just go through the lines, find the minimum value in them and check the indexes as I understand it is too naive :)\\n\\n        int sum = 0, nowIndex = 0, min = Int32.MaxValue;\\n\\n        for (int i = 0; i < triangle.Count; i++)\\n        {\\n            for (int j = nowIndex; j < triangle[i].Count; j++)\\n            {\\n                if (triangle[i][j] < min)\\n                {\\n                    nowIndex = j;\\n                    min = triangle[i][j];\\n                }\\n            }\\n            sum += min;\\n            min = Int32.MaxValue;\\n        }\\n\\n        return sum;\\n\\nas I guess, Dijkstra\\'s algorithm of the shortest path in the graph is needed here? if we somehow represent the list as a graph\\n"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "any hint how can I solve the follow up problem for this problem where space have to be O(n)."
                    },
                    {
                        "username": "praball",
                        "content": "Memoization approach giving TLE :// \\nidea anyone?"
                    },
                    {
                        "username": "vishal_niet",
                        "content": " `\n\n    public int myFunction(List<List<Integer>> triangle,int i,int j) {\n\t\tif (i==triangle.size()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint currentNode=triangle.get(i).get(j);\n\t\tint leftNode=myFunction(triangle,i+1,j)+currentNode;\n\t\tint rightNode = myFunction(triangle,i+1,j+1)+currentNode;\n\t\t\n\t\tint result=Math.min(leftNode, rightNode);\n\t\treturn result;\n\t}\n\t\n\n`\n\nCan anyone tell me that why my binary _search approach is giving TLE."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "Input\\ntriangle = [[2],[3,4],[6,5,9],[4,4,8,0]]\\n\\nOutput\\n15\\nExpected\\n14\\n\\ni make the order from bottom of triangle....while i\\'ve made it start from upper previously and it\\'s wrong too....so which one is correct?"
                    },
                    {
                        "username": "mritunjai88",
                        "content": "If we find the smallest element in each list and add it to the sum it would also calculate the smallest path sum. Is my understanding correct?"
                    }
                ]
            },
            {
                "id": 1896850,
                "content": [
                    {
                        "username": "20BCS225",
                        "content": "is this problem can be solved by recursion??\\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "yes but time complexity will be higher so we can use dp here"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]] answer is -1 why not -2 ???????????\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]]  answer is -1 why not -2 ???????????"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just because -2 is not possible you can only move either on same index or on i+1 index"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[[-1],[-2,-3]]\\n   -1\\n-2 -3 \\n\\nThe shortest path is -1 + -2 so it\\'s -3.\\nWhy submission says it should be -4? xd\\nSomeone was drunk desgining those test cases?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "It\\'s clearly -4 as the shortest path is -1 + - 3 = - 4"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Just go through the lines, find the minimum value in them and check the indexes as I understand it is too naive :)\\n\\n        int sum = 0, nowIndex = 0, min = Int32.MaxValue;\\n\\n        for (int i = 0; i < triangle.Count; i++)\\n        {\\n            for (int j = nowIndex; j < triangle[i].Count; j++)\\n            {\\n                if (triangle[i][j] < min)\\n                {\\n                    nowIndex = j;\\n                    min = triangle[i][j];\\n                }\\n            }\\n            sum += min;\\n            min = Int32.MaxValue;\\n        }\\n\\n        return sum;\\n\\nas I guess, Dijkstra\\'s algorithm of the shortest path in the graph is needed here? if we somehow represent the list as a graph\\n"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "any hint how can I solve the follow up problem for this problem where space have to be O(n)."
                    },
                    {
                        "username": "praball",
                        "content": "Memoization approach giving TLE :// \\nidea anyone?"
                    },
                    {
                        "username": "vishal_niet",
                        "content": " `\n\n    public int myFunction(List<List<Integer>> triangle,int i,int j) {\n\t\tif (i==triangle.size()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint currentNode=triangle.get(i).get(j);\n\t\tint leftNode=myFunction(triangle,i+1,j)+currentNode;\n\t\tint rightNode = myFunction(triangle,i+1,j+1)+currentNode;\n\t\t\n\t\tint result=Math.min(leftNode, rightNode);\n\t\treturn result;\n\t}\n\t\n\n`\n\nCan anyone tell me that why my binary _search approach is giving TLE."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "Input\\ntriangle = [[2],[3,4],[6,5,9],[4,4,8,0]]\\n\\nOutput\\n15\\nExpected\\n14\\n\\ni make the order from bottom of triangle....while i\\'ve made it start from upper previously and it\\'s wrong too....so which one is correct?"
                    },
                    {
                        "username": "mritunjai88",
                        "content": "If we find the smallest element in each list and add it to the sum it would also calculate the smallest path sum. Is my understanding correct?"
                    }
                ]
            },
            {
                "id": 1896849,
                "content": [
                    {
                        "username": "20BCS225",
                        "content": "is this problem can be solved by recursion??\\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "yes but time complexity will be higher so we can use dp here"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]] answer is -1 why not -2 ???????????\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]]  answer is -1 why not -2 ???????????"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just because -2 is not possible you can only move either on same index or on i+1 index"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[[-1],[-2,-3]]\\n   -1\\n-2 -3 \\n\\nThe shortest path is -1 + -2 so it\\'s -3.\\nWhy submission says it should be -4? xd\\nSomeone was drunk desgining those test cases?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "It\\'s clearly -4 as the shortest path is -1 + - 3 = - 4"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Just go through the lines, find the minimum value in them and check the indexes as I understand it is too naive :)\\n\\n        int sum = 0, nowIndex = 0, min = Int32.MaxValue;\\n\\n        for (int i = 0; i < triangle.Count; i++)\\n        {\\n            for (int j = nowIndex; j < triangle[i].Count; j++)\\n            {\\n                if (triangle[i][j] < min)\\n                {\\n                    nowIndex = j;\\n                    min = triangle[i][j];\\n                }\\n            }\\n            sum += min;\\n            min = Int32.MaxValue;\\n        }\\n\\n        return sum;\\n\\nas I guess, Dijkstra\\'s algorithm of the shortest path in the graph is needed here? if we somehow represent the list as a graph\\n"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "any hint how can I solve the follow up problem for this problem where space have to be O(n)."
                    },
                    {
                        "username": "praball",
                        "content": "Memoization approach giving TLE :// \\nidea anyone?"
                    },
                    {
                        "username": "vishal_niet",
                        "content": " `\n\n    public int myFunction(List<List<Integer>> triangle,int i,int j) {\n\t\tif (i==triangle.size()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint currentNode=triangle.get(i).get(j);\n\t\tint leftNode=myFunction(triangle,i+1,j)+currentNode;\n\t\tint rightNode = myFunction(triangle,i+1,j+1)+currentNode;\n\t\t\n\t\tint result=Math.min(leftNode, rightNode);\n\t\treturn result;\n\t}\n\t\n\n`\n\nCan anyone tell me that why my binary _search approach is giving TLE."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "Input\\ntriangle = [[2],[3,4],[6,5,9],[4,4,8,0]]\\n\\nOutput\\n15\\nExpected\\n14\\n\\ni make the order from bottom of triangle....while i\\'ve made it start from upper previously and it\\'s wrong too....so which one is correct?"
                    },
                    {
                        "username": "mritunjai88",
                        "content": "If we find the smallest element in each list and add it to the sum it would also calculate the smallest path sum. Is my understanding correct?"
                    }
                ]
            },
            {
                "id": 1891074,
                "content": [
                    {
                        "username": "20BCS225",
                        "content": "is this problem can be solved by recursion??\\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "yes but time complexity will be higher so we can use dp here"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]] answer is -1 why not -2 ???????????\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]]  answer is -1 why not -2 ???????????"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just because -2 is not possible you can only move either on same index or on i+1 index"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[[-1],[-2,-3]]\\n   -1\\n-2 -3 \\n\\nThe shortest path is -1 + -2 so it\\'s -3.\\nWhy submission says it should be -4? xd\\nSomeone was drunk desgining those test cases?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "It\\'s clearly -4 as the shortest path is -1 + - 3 = - 4"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Just go through the lines, find the minimum value in them and check the indexes as I understand it is too naive :)\\n\\n        int sum = 0, nowIndex = 0, min = Int32.MaxValue;\\n\\n        for (int i = 0; i < triangle.Count; i++)\\n        {\\n            for (int j = nowIndex; j < triangle[i].Count; j++)\\n            {\\n                if (triangle[i][j] < min)\\n                {\\n                    nowIndex = j;\\n                    min = triangle[i][j];\\n                }\\n            }\\n            sum += min;\\n            min = Int32.MaxValue;\\n        }\\n\\n        return sum;\\n\\nas I guess, Dijkstra\\'s algorithm of the shortest path in the graph is needed here? if we somehow represent the list as a graph\\n"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "any hint how can I solve the follow up problem for this problem where space have to be O(n)."
                    },
                    {
                        "username": "praball",
                        "content": "Memoization approach giving TLE :// \\nidea anyone?"
                    },
                    {
                        "username": "vishal_niet",
                        "content": " `\n\n    public int myFunction(List<List<Integer>> triangle,int i,int j) {\n\t\tif (i==triangle.size()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint currentNode=triangle.get(i).get(j);\n\t\tint leftNode=myFunction(triangle,i+1,j)+currentNode;\n\t\tint rightNode = myFunction(triangle,i+1,j+1)+currentNode;\n\t\t\n\t\tint result=Math.min(leftNode, rightNode);\n\t\treturn result;\n\t}\n\t\n\n`\n\nCan anyone tell me that why my binary _search approach is giving TLE."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "Input\\ntriangle = [[2],[3,4],[6,5,9],[4,4,8,0]]\\n\\nOutput\\n15\\nExpected\\n14\\n\\ni make the order from bottom of triangle....while i\\'ve made it start from upper previously and it\\'s wrong too....so which one is correct?"
                    },
                    {
                        "username": "mritunjai88",
                        "content": "If we find the smallest element in each list and add it to the sum it would also calculate the smallest path sum. Is my understanding correct?"
                    }
                ]
            },
            {
                "id": 1890524,
                "content": [
                    {
                        "username": "20BCS225",
                        "content": "is this problem can be solved by recursion??\\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "yes but time complexity will be higher so we can use dp here"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]] answer is -1 why not -2 ???????????\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]]  answer is -1 why not -2 ???????????"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just because -2 is not possible you can only move either on same index or on i+1 index"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[[-1],[-2,-3]]\\n   -1\\n-2 -3 \\n\\nThe shortest path is -1 + -2 so it\\'s -3.\\nWhy submission says it should be -4? xd\\nSomeone was drunk desgining those test cases?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "It\\'s clearly -4 as the shortest path is -1 + - 3 = - 4"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Just go through the lines, find the minimum value in them and check the indexes as I understand it is too naive :)\\n\\n        int sum = 0, nowIndex = 0, min = Int32.MaxValue;\\n\\n        for (int i = 0; i < triangle.Count; i++)\\n        {\\n            for (int j = nowIndex; j < triangle[i].Count; j++)\\n            {\\n                if (triangle[i][j] < min)\\n                {\\n                    nowIndex = j;\\n                    min = triangle[i][j];\\n                }\\n            }\\n            sum += min;\\n            min = Int32.MaxValue;\\n        }\\n\\n        return sum;\\n\\nas I guess, Dijkstra\\'s algorithm of the shortest path in the graph is needed here? if we somehow represent the list as a graph\\n"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "any hint how can I solve the follow up problem for this problem where space have to be O(n)."
                    },
                    {
                        "username": "praball",
                        "content": "Memoization approach giving TLE :// \\nidea anyone?"
                    },
                    {
                        "username": "vishal_niet",
                        "content": " `\n\n    public int myFunction(List<List<Integer>> triangle,int i,int j) {\n\t\tif (i==triangle.size()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint currentNode=triangle.get(i).get(j);\n\t\tint leftNode=myFunction(triangle,i+1,j)+currentNode;\n\t\tint rightNode = myFunction(triangle,i+1,j+1)+currentNode;\n\t\t\n\t\tint result=Math.min(leftNode, rightNode);\n\t\treturn result;\n\t}\n\t\n\n`\n\nCan anyone tell me that why my binary _search approach is giving TLE."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "Input\\ntriangle = [[2],[3,4],[6,5,9],[4,4,8,0]]\\n\\nOutput\\n15\\nExpected\\n14\\n\\ni make the order from bottom of triangle....while i\\'ve made it start from upper previously and it\\'s wrong too....so which one is correct?"
                    },
                    {
                        "username": "mritunjai88",
                        "content": "If we find the smallest element in each list and add it to the sum it would also calculate the smallest path sum. Is my understanding correct?"
                    }
                ]
            },
            {
                "id": 1852819,
                "content": [
                    {
                        "username": "20BCS225",
                        "content": "is this problem can be solved by recursion??\\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "yes but time complexity will be higher so we can use dp here"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]] answer is -1 why not -2 ???????????\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]]  answer is -1 why not -2 ???????????"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just because -2 is not possible you can only move either on same index or on i+1 index"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[[-1],[-2,-3]]\\n   -1\\n-2 -3 \\n\\nThe shortest path is -1 + -2 so it\\'s -3.\\nWhy submission says it should be -4? xd\\nSomeone was drunk desgining those test cases?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "It\\'s clearly -4 as the shortest path is -1 + - 3 = - 4"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Just go through the lines, find the minimum value in them and check the indexes as I understand it is too naive :)\\n\\n        int sum = 0, nowIndex = 0, min = Int32.MaxValue;\\n\\n        for (int i = 0; i < triangle.Count; i++)\\n        {\\n            for (int j = nowIndex; j < triangle[i].Count; j++)\\n            {\\n                if (triangle[i][j] < min)\\n                {\\n                    nowIndex = j;\\n                    min = triangle[i][j];\\n                }\\n            }\\n            sum += min;\\n            min = Int32.MaxValue;\\n        }\\n\\n        return sum;\\n\\nas I guess, Dijkstra\\'s algorithm of the shortest path in the graph is needed here? if we somehow represent the list as a graph\\n"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "any hint how can I solve the follow up problem for this problem where space have to be O(n)."
                    },
                    {
                        "username": "praball",
                        "content": "Memoization approach giving TLE :// \\nidea anyone?"
                    },
                    {
                        "username": "vishal_niet",
                        "content": " `\n\n    public int myFunction(List<List<Integer>> triangle,int i,int j) {\n\t\tif (i==triangle.size()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint currentNode=triangle.get(i).get(j);\n\t\tint leftNode=myFunction(triangle,i+1,j)+currentNode;\n\t\tint rightNode = myFunction(triangle,i+1,j+1)+currentNode;\n\t\t\n\t\tint result=Math.min(leftNode, rightNode);\n\t\treturn result;\n\t}\n\t\n\n`\n\nCan anyone tell me that why my binary _search approach is giving TLE."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "Input\\ntriangle = [[2],[3,4],[6,5,9],[4,4,8,0]]\\n\\nOutput\\n15\\nExpected\\n14\\n\\ni make the order from bottom of triangle....while i\\'ve made it start from upper previously and it\\'s wrong too....so which one is correct?"
                    },
                    {
                        "username": "mritunjai88",
                        "content": "If we find the smallest element in each list and add it to the sum it would also calculate the smallest path sum. Is my understanding correct?"
                    }
                ]
            },
            {
                "id": 1850657,
                "content": [
                    {
                        "username": "20BCS225",
                        "content": "is this problem can be solved by recursion??\\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "yes but time complexity will be higher so we can use dp here"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]] answer is -1 why not -2 ???????????\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]]  answer is -1 why not -2 ???????????"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just because -2 is not possible you can only move either on same index or on i+1 index"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[[-1],[-2,-3]]\\n   -1\\n-2 -3 \\n\\nThe shortest path is -1 + -2 so it\\'s -3.\\nWhy submission says it should be -4? xd\\nSomeone was drunk desgining those test cases?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "It\\'s clearly -4 as the shortest path is -1 + - 3 = - 4"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Just go through the lines, find the minimum value in them and check the indexes as I understand it is too naive :)\\n\\n        int sum = 0, nowIndex = 0, min = Int32.MaxValue;\\n\\n        for (int i = 0; i < triangle.Count; i++)\\n        {\\n            for (int j = nowIndex; j < triangle[i].Count; j++)\\n            {\\n                if (triangle[i][j] < min)\\n                {\\n                    nowIndex = j;\\n                    min = triangle[i][j];\\n                }\\n            }\\n            sum += min;\\n            min = Int32.MaxValue;\\n        }\\n\\n        return sum;\\n\\nas I guess, Dijkstra\\'s algorithm of the shortest path in the graph is needed here? if we somehow represent the list as a graph\\n"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "any hint how can I solve the follow up problem for this problem where space have to be O(n)."
                    },
                    {
                        "username": "praball",
                        "content": "Memoization approach giving TLE :// \\nidea anyone?"
                    },
                    {
                        "username": "vishal_niet",
                        "content": " `\n\n    public int myFunction(List<List<Integer>> triangle,int i,int j) {\n\t\tif (i==triangle.size()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint currentNode=triangle.get(i).get(j);\n\t\tint leftNode=myFunction(triangle,i+1,j)+currentNode;\n\t\tint rightNode = myFunction(triangle,i+1,j+1)+currentNode;\n\t\t\n\t\tint result=Math.min(leftNode, rightNode);\n\t\treturn result;\n\t}\n\t\n\n`\n\nCan anyone tell me that why my binary _search approach is giving TLE."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "Input\\ntriangle = [[2],[3,4],[6,5,9],[4,4,8,0]]\\n\\nOutput\\n15\\nExpected\\n14\\n\\ni make the order from bottom of triangle....while i\\'ve made it start from upper previously and it\\'s wrong too....so which one is correct?"
                    },
                    {
                        "username": "mritunjai88",
                        "content": "If we find the smallest element in each list and add it to the sum it would also calculate the smallest path sum. Is my understanding correct?"
                    }
                ]
            },
            {
                "id": 1827815,
                "content": [
                    {
                        "username": "20BCS225",
                        "content": "is this problem can be solved by recursion??\\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "yes but time complexity will be higher so we can use dp here"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]] answer is -1 why not -2 ???????????\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]]  answer is -1 why not -2 ???????????"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just because -2 is not possible you can only move either on same index or on i+1 index"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[[-1],[-2,-3]]\\n   -1\\n-2 -3 \\n\\nThe shortest path is -1 + -2 so it\\'s -3.\\nWhy submission says it should be -4? xd\\nSomeone was drunk desgining those test cases?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "It\\'s clearly -4 as the shortest path is -1 + - 3 = - 4"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Just go through the lines, find the minimum value in them and check the indexes as I understand it is too naive :)\\n\\n        int sum = 0, nowIndex = 0, min = Int32.MaxValue;\\n\\n        for (int i = 0; i < triangle.Count; i++)\\n        {\\n            for (int j = nowIndex; j < triangle[i].Count; j++)\\n            {\\n                if (triangle[i][j] < min)\\n                {\\n                    nowIndex = j;\\n                    min = triangle[i][j];\\n                }\\n            }\\n            sum += min;\\n            min = Int32.MaxValue;\\n        }\\n\\n        return sum;\\n\\nas I guess, Dijkstra\\'s algorithm of the shortest path in the graph is needed here? if we somehow represent the list as a graph\\n"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "any hint how can I solve the follow up problem for this problem where space have to be O(n)."
                    },
                    {
                        "username": "praball",
                        "content": "Memoization approach giving TLE :// \\nidea anyone?"
                    },
                    {
                        "username": "vishal_niet",
                        "content": " `\n\n    public int myFunction(List<List<Integer>> triangle,int i,int j) {\n\t\tif (i==triangle.size()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint currentNode=triangle.get(i).get(j);\n\t\tint leftNode=myFunction(triangle,i+1,j)+currentNode;\n\t\tint rightNode = myFunction(triangle,i+1,j+1)+currentNode;\n\t\t\n\t\tint result=Math.min(leftNode, rightNode);\n\t\treturn result;\n\t}\n\t\n\n`\n\nCan anyone tell me that why my binary _search approach is giving TLE."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "Input\\ntriangle = [[2],[3,4],[6,5,9],[4,4,8,0]]\\n\\nOutput\\n15\\nExpected\\n14\\n\\ni make the order from bottom of triangle....while i\\'ve made it start from upper previously and it\\'s wrong too....so which one is correct?"
                    },
                    {
                        "username": "mritunjai88",
                        "content": "If we find the smallest element in each list and add it to the sum it would also calculate the smallest path sum. Is my understanding correct?"
                    }
                ]
            },
            {
                "id": 1818264,
                "content": [
                    {
                        "username": "20BCS225",
                        "content": "is this problem can be solved by recursion??\\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "yes but time complexity will be higher so we can use dp here"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]] answer is -1 why not -2 ???????????\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]]  answer is -1 why not -2 ???????????"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just because -2 is not possible you can only move either on same index or on i+1 index"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[[-1],[-2,-3]]\\n   -1\\n-2 -3 \\n\\nThe shortest path is -1 + -2 so it\\'s -3.\\nWhy submission says it should be -4? xd\\nSomeone was drunk desgining those test cases?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "It\\'s clearly -4 as the shortest path is -1 + - 3 = - 4"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Just go through the lines, find the minimum value in them and check the indexes as I understand it is too naive :)\\n\\n        int sum = 0, nowIndex = 0, min = Int32.MaxValue;\\n\\n        for (int i = 0; i < triangle.Count; i++)\\n        {\\n            for (int j = nowIndex; j < triangle[i].Count; j++)\\n            {\\n                if (triangle[i][j] < min)\\n                {\\n                    nowIndex = j;\\n                    min = triangle[i][j];\\n                }\\n            }\\n            sum += min;\\n            min = Int32.MaxValue;\\n        }\\n\\n        return sum;\\n\\nas I guess, Dijkstra\\'s algorithm of the shortest path in the graph is needed here? if we somehow represent the list as a graph\\n"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "any hint how can I solve the follow up problem for this problem where space have to be O(n)."
                    },
                    {
                        "username": "praball",
                        "content": "Memoization approach giving TLE :// \\nidea anyone?"
                    },
                    {
                        "username": "vishal_niet",
                        "content": " `\n\n    public int myFunction(List<List<Integer>> triangle,int i,int j) {\n\t\tif (i==triangle.size()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint currentNode=triangle.get(i).get(j);\n\t\tint leftNode=myFunction(triangle,i+1,j)+currentNode;\n\t\tint rightNode = myFunction(triangle,i+1,j+1)+currentNode;\n\t\t\n\t\tint result=Math.min(leftNode, rightNode);\n\t\treturn result;\n\t}\n\t\n\n`\n\nCan anyone tell me that why my binary _search approach is giving TLE."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "Input\\ntriangle = [[2],[3,4],[6,5,9],[4,4,8,0]]\\n\\nOutput\\n15\\nExpected\\n14\\n\\ni make the order from bottom of triangle....while i\\'ve made it start from upper previously and it\\'s wrong too....so which one is correct?"
                    },
                    {
                        "username": "mritunjai88",
                        "content": "If we find the smallest element in each list and add it to the sum it would also calculate the smallest path sum. Is my understanding correct?"
                    }
                ]
            },
            {
                "id": 1803925,
                "content": [
                    {
                        "username": "20BCS225",
                        "content": "is this problem can be solved by recursion??\\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "yes but time complexity will be higher so we can use dp here"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]] answer is -1 why not -2 ???????????\\n"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "can anyone explain why [[-1],[2,3],[1,-1,-3]]  answer is -1 why not -2 ???????????"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just because -2 is not possible you can only move either on same index or on i+1 index"
                    },
                    {
                        "username": "Kuba111",
                        "content": "[[-1],[-2,-3]]\\n   -1\\n-2 -3 \\n\\nThe shortest path is -1 + -2 so it\\'s -3.\\nWhy submission says it should be -4? xd\\nSomeone was drunk desgining those test cases?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "It\\'s clearly -4 as the shortest path is -1 + - 3 = - 4"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "Just go through the lines, find the minimum value in them and check the indexes as I understand it is too naive :)\\n\\n        int sum = 0, nowIndex = 0, min = Int32.MaxValue;\\n\\n        for (int i = 0; i < triangle.Count; i++)\\n        {\\n            for (int j = nowIndex; j < triangle[i].Count; j++)\\n            {\\n                if (triangle[i][j] < min)\\n                {\\n                    nowIndex = j;\\n                    min = triangle[i][j];\\n                }\\n            }\\n            sum += min;\\n            min = Int32.MaxValue;\\n        }\\n\\n        return sum;\\n\\nas I guess, Dijkstra\\'s algorithm of the shortest path in the graph is needed here? if we somehow represent the list as a graph\\n"
                    },
                    {
                        "username": "mannsahb3501",
                        "content": "any hint how can I solve the follow up problem for this problem where space have to be O(n)."
                    },
                    {
                        "username": "praball",
                        "content": "Memoization approach giving TLE :// \\nidea anyone?"
                    },
                    {
                        "username": "vishal_niet",
                        "content": " `\n\n    public int myFunction(List<List<Integer>> triangle,int i,int j) {\n\t\tif (i==triangle.size()) {\n\t\t\treturn 0;\n\t\t}\n\t\tint currentNode=triangle.get(i).get(j);\n\t\tint leftNode=myFunction(triangle,i+1,j)+currentNode;\n\t\tint rightNode = myFunction(triangle,i+1,j+1)+currentNode;\n\t\t\n\t\tint result=Math.min(leftNode, rightNode);\n\t\treturn result;\n\t}\n\t\n\n`\n\nCan anyone tell me that why my binary _search approach is giving TLE."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "Input\\ntriangle = [[2],[3,4],[6,5,9],[4,4,8,0]]\\n\\nOutput\\n15\\nExpected\\n14\\n\\ni make the order from bottom of triangle....while i\\'ve made it start from upper previously and it\\'s wrong too....so which one is correct?"
                    },
                    {
                        "username": "mritunjai88",
                        "content": "If we find the smallest element in each list and add it to the sum it would also calculate the smallest path sum. Is my understanding correct?"
                    }
                ]
            },
            {
                "id": 1800482,
                "content": [
                    {
                        "username": "Joshualum",
                        "content": "I encountered another problem exactly as the same rule of this question, but this time we can choose 2 paths from the triangle. The common nodes of the 2 routes will only be counted once. I have really no idea on this!\\n\\nMy first intention was to set the 1st walked path nodes to 0 and do the second time, but I soon found a counter example. After that I tried to make a 3D array but again end up recounting nodes in the two paths... Can anyone solve this?"
                    },
                    {
                        "username": "vishalk754",
                        "content": " [@LeetCode](/LeetCode) i was solving this question got error for test case :\\ntriangle = [[-1],[2,3],[1,-1,-3]]\\nexpected = -1 \\nhow its possible any one please correct me if i am wrong \\n(-1)+(2)+(-3) = -2 its my ouput "
                    },
                    {
                        "username": "user2609J",
                        "content": "Hey every one,\\nI didn\\'t understand why the is -1 with this input [[-1],[2,3],[1,-1,-3]], can any one help me ?\\nThank\\'s"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Recursion | Memoization | Tabulation | Space Optimization\\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "rajivgurav712",
                        "content": "120. Triangle problem\\n\\nI wrote this code-\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        c=0\\n        for i in triangle:\\n            min=10\\n            for j in i:\\n                if j<min:\\n                    min=j\\n            c+=min\\n        return c\\n \\nand at 13th testcase the expected answer is -1 and i got -2 as per my code How? plz help me"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "I thought it is as easy as when we used to print * in a triangle but i was wrong."
                    },
                    {
                        "username": "vyomverma",
                        "content": "testcase:\\n[[-1],[2,3],[1,-1,-3]]\\n\\n\\nits output should be -2 \\nbut expected value is given as -1. \\n\\n\\nmy  cpp code:\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int min=0;\\n        for(int i=0 ; i< triangle.size() ;i++){\\n            int temp=triangle[i][0];\\n            for(int j=0 ; j<triangle[i].size() ; j++ ){\\n                if(triangle[i][j]<temp){\\n                    temp = triangle[i][j];\\n                }\\n               \\n            }\\n             min = min+temp;\\n        }\\n        return min;\\n    }\\n};"
                    },
                    {
                        "username": "dedmouze",
                        "content": "For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n![Answer](https://ltdfoto.ru/images/2023/01/23/Answer.png)\n\nYou cant go like red arrow. Only blue and green available."
                    },
                    {
                        "username": "csseifms",
                        "content": "Test case:\\n   [[2],\\n   [3,4],\\n  [6,5,9],\\n [4,4,8,0]]\\n\\nBreaking down for values after calculating step by step:\\n      [2]\\n    [5, 6]\\n  [11, 10, 11, 15]\\n[15, 15, 14, 18, 19, 11, 15]\\n\\nwhy the output should be 14 not 11?!"
                    },
                    {
                        "username": "nightbird007",
                        "content": "class Solution {\\npublic:\\nint dfs(vector<vector<int>>dp,vector<vector<int>>mat,int n,int i=0,int j=0)\\n{\\n    if(i==n)return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l=mat[i][j]+dfs(dp,mat,n,i+1,j);\\n    int r=mat[i][j]+dfs(dp,mat,n,i+1,j+1);\\n    return dp[i][j]=min(l,r);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(),vector<int>(triangle.size(),-1));\\n        return dfs(dp,triangle,triangle.size());\\n    }\\n};\\n\\nwhat is wrong with my solution ???"
                    },
                    {
                        "username": "nightbird007",
                        "content": "[@csseifms](/csseifms) i did i got a time limit exceed in case 42"
                    },
                    {
                        "username": "csseifms",
                        "content": "maybe because you do not consider \"index\" jump; \"you may move to either index i or index i + 1 on the next row.\"\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1790408,
                "content": [
                    {
                        "username": "Joshualum",
                        "content": "I encountered another problem exactly as the same rule of this question, but this time we can choose 2 paths from the triangle. The common nodes of the 2 routes will only be counted once. I have really no idea on this!\\n\\nMy first intention was to set the 1st walked path nodes to 0 and do the second time, but I soon found a counter example. After that I tried to make a 3D array but again end up recounting nodes in the two paths... Can anyone solve this?"
                    },
                    {
                        "username": "vishalk754",
                        "content": " [@LeetCode](/LeetCode) i was solving this question got error for test case :\\ntriangle = [[-1],[2,3],[1,-1,-3]]\\nexpected = -1 \\nhow its possible any one please correct me if i am wrong \\n(-1)+(2)+(-3) = -2 its my ouput "
                    },
                    {
                        "username": "user2609J",
                        "content": "Hey every one,\\nI didn\\'t understand why the is -1 with this input [[-1],[2,3],[1,-1,-3]], can any one help me ?\\nThank\\'s"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Recursion | Memoization | Tabulation | Space Optimization\\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "rajivgurav712",
                        "content": "120. Triangle problem\\n\\nI wrote this code-\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        c=0\\n        for i in triangle:\\n            min=10\\n            for j in i:\\n                if j<min:\\n                    min=j\\n            c+=min\\n        return c\\n \\nand at 13th testcase the expected answer is -1 and i got -2 as per my code How? plz help me"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "I thought it is as easy as when we used to print * in a triangle but i was wrong."
                    },
                    {
                        "username": "vyomverma",
                        "content": "testcase:\\n[[-1],[2,3],[1,-1,-3]]\\n\\n\\nits output should be -2 \\nbut expected value is given as -1. \\n\\n\\nmy  cpp code:\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int min=0;\\n        for(int i=0 ; i< triangle.size() ;i++){\\n            int temp=triangle[i][0];\\n            for(int j=0 ; j<triangle[i].size() ; j++ ){\\n                if(triangle[i][j]<temp){\\n                    temp = triangle[i][j];\\n                }\\n               \\n            }\\n             min = min+temp;\\n        }\\n        return min;\\n    }\\n};"
                    },
                    {
                        "username": "dedmouze",
                        "content": "For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n![Answer](https://ltdfoto.ru/images/2023/01/23/Answer.png)\n\nYou cant go like red arrow. Only blue and green available."
                    },
                    {
                        "username": "csseifms",
                        "content": "Test case:\\n   [[2],\\n   [3,4],\\n  [6,5,9],\\n [4,4,8,0]]\\n\\nBreaking down for values after calculating step by step:\\n      [2]\\n    [5, 6]\\n  [11, 10, 11, 15]\\n[15, 15, 14, 18, 19, 11, 15]\\n\\nwhy the output should be 14 not 11?!"
                    },
                    {
                        "username": "nightbird007",
                        "content": "class Solution {\\npublic:\\nint dfs(vector<vector<int>>dp,vector<vector<int>>mat,int n,int i=0,int j=0)\\n{\\n    if(i==n)return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l=mat[i][j]+dfs(dp,mat,n,i+1,j);\\n    int r=mat[i][j]+dfs(dp,mat,n,i+1,j+1);\\n    return dp[i][j]=min(l,r);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(),vector<int>(triangle.size(),-1));\\n        return dfs(dp,triangle,triangle.size());\\n    }\\n};\\n\\nwhat is wrong with my solution ???"
                    },
                    {
                        "username": "nightbird007",
                        "content": "[@csseifms](/csseifms) i did i got a time limit exceed in case 42"
                    },
                    {
                        "username": "csseifms",
                        "content": "maybe because you do not consider \"index\" jump; \"you may move to either index i or index i + 1 on the next row.\"\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1786475,
                "content": [
                    {
                        "username": "Joshualum",
                        "content": "I encountered another problem exactly as the same rule of this question, but this time we can choose 2 paths from the triangle. The common nodes of the 2 routes will only be counted once. I have really no idea on this!\\n\\nMy first intention was to set the 1st walked path nodes to 0 and do the second time, but I soon found a counter example. After that I tried to make a 3D array but again end up recounting nodes in the two paths... Can anyone solve this?"
                    },
                    {
                        "username": "vishalk754",
                        "content": " [@LeetCode](/LeetCode) i was solving this question got error for test case :\\ntriangle = [[-1],[2,3],[1,-1,-3]]\\nexpected = -1 \\nhow its possible any one please correct me if i am wrong \\n(-1)+(2)+(-3) = -2 its my ouput "
                    },
                    {
                        "username": "user2609J",
                        "content": "Hey every one,\\nI didn\\'t understand why the is -1 with this input [[-1],[2,3],[1,-1,-3]], can any one help me ?\\nThank\\'s"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Recursion | Memoization | Tabulation | Space Optimization\\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "rajivgurav712",
                        "content": "120. Triangle problem\\n\\nI wrote this code-\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        c=0\\n        for i in triangle:\\n            min=10\\n            for j in i:\\n                if j<min:\\n                    min=j\\n            c+=min\\n        return c\\n \\nand at 13th testcase the expected answer is -1 and i got -2 as per my code How? plz help me"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "I thought it is as easy as when we used to print * in a triangle but i was wrong."
                    },
                    {
                        "username": "vyomverma",
                        "content": "testcase:\\n[[-1],[2,3],[1,-1,-3]]\\n\\n\\nits output should be -2 \\nbut expected value is given as -1. \\n\\n\\nmy  cpp code:\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int min=0;\\n        for(int i=0 ; i< triangle.size() ;i++){\\n            int temp=triangle[i][0];\\n            for(int j=0 ; j<triangle[i].size() ; j++ ){\\n                if(triangle[i][j]<temp){\\n                    temp = triangle[i][j];\\n                }\\n               \\n            }\\n             min = min+temp;\\n        }\\n        return min;\\n    }\\n};"
                    },
                    {
                        "username": "dedmouze",
                        "content": "For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n![Answer](https://ltdfoto.ru/images/2023/01/23/Answer.png)\n\nYou cant go like red arrow. Only blue and green available."
                    },
                    {
                        "username": "csseifms",
                        "content": "Test case:\\n   [[2],\\n   [3,4],\\n  [6,5,9],\\n [4,4,8,0]]\\n\\nBreaking down for values after calculating step by step:\\n      [2]\\n    [5, 6]\\n  [11, 10, 11, 15]\\n[15, 15, 14, 18, 19, 11, 15]\\n\\nwhy the output should be 14 not 11?!"
                    },
                    {
                        "username": "nightbird007",
                        "content": "class Solution {\\npublic:\\nint dfs(vector<vector<int>>dp,vector<vector<int>>mat,int n,int i=0,int j=0)\\n{\\n    if(i==n)return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l=mat[i][j]+dfs(dp,mat,n,i+1,j);\\n    int r=mat[i][j]+dfs(dp,mat,n,i+1,j+1);\\n    return dp[i][j]=min(l,r);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(),vector<int>(triangle.size(),-1));\\n        return dfs(dp,triangle,triangle.size());\\n    }\\n};\\n\\nwhat is wrong with my solution ???"
                    },
                    {
                        "username": "nightbird007",
                        "content": "[@csseifms](/csseifms) i did i got a time limit exceed in case 42"
                    },
                    {
                        "username": "csseifms",
                        "content": "maybe because you do not consider \"index\" jump; \"you may move to either index i or index i + 1 on the next row.\"\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1781999,
                "content": [
                    {
                        "username": "Joshualum",
                        "content": "I encountered another problem exactly as the same rule of this question, but this time we can choose 2 paths from the triangle. The common nodes of the 2 routes will only be counted once. I have really no idea on this!\\n\\nMy first intention was to set the 1st walked path nodes to 0 and do the second time, but I soon found a counter example. After that I tried to make a 3D array but again end up recounting nodes in the two paths... Can anyone solve this?"
                    },
                    {
                        "username": "vishalk754",
                        "content": " [@LeetCode](/LeetCode) i was solving this question got error for test case :\\ntriangle = [[-1],[2,3],[1,-1,-3]]\\nexpected = -1 \\nhow its possible any one please correct me if i am wrong \\n(-1)+(2)+(-3) = -2 its my ouput "
                    },
                    {
                        "username": "user2609J",
                        "content": "Hey every one,\\nI didn\\'t understand why the is -1 with this input [[-1],[2,3],[1,-1,-3]], can any one help me ?\\nThank\\'s"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Recursion | Memoization | Tabulation | Space Optimization\\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "rajivgurav712",
                        "content": "120. Triangle problem\\n\\nI wrote this code-\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        c=0\\n        for i in triangle:\\n            min=10\\n            for j in i:\\n                if j<min:\\n                    min=j\\n            c+=min\\n        return c\\n \\nand at 13th testcase the expected answer is -1 and i got -2 as per my code How? plz help me"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "I thought it is as easy as when we used to print * in a triangle but i was wrong."
                    },
                    {
                        "username": "vyomverma",
                        "content": "testcase:\\n[[-1],[2,3],[1,-1,-3]]\\n\\n\\nits output should be -2 \\nbut expected value is given as -1. \\n\\n\\nmy  cpp code:\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int min=0;\\n        for(int i=0 ; i< triangle.size() ;i++){\\n            int temp=triangle[i][0];\\n            for(int j=0 ; j<triangle[i].size() ; j++ ){\\n                if(triangle[i][j]<temp){\\n                    temp = triangle[i][j];\\n                }\\n               \\n            }\\n             min = min+temp;\\n        }\\n        return min;\\n    }\\n};"
                    },
                    {
                        "username": "dedmouze",
                        "content": "For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n![Answer](https://ltdfoto.ru/images/2023/01/23/Answer.png)\n\nYou cant go like red arrow. Only blue and green available."
                    },
                    {
                        "username": "csseifms",
                        "content": "Test case:\\n   [[2],\\n   [3,4],\\n  [6,5,9],\\n [4,4,8,0]]\\n\\nBreaking down for values after calculating step by step:\\n      [2]\\n    [5, 6]\\n  [11, 10, 11, 15]\\n[15, 15, 14, 18, 19, 11, 15]\\n\\nwhy the output should be 14 not 11?!"
                    },
                    {
                        "username": "nightbird007",
                        "content": "class Solution {\\npublic:\\nint dfs(vector<vector<int>>dp,vector<vector<int>>mat,int n,int i=0,int j=0)\\n{\\n    if(i==n)return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l=mat[i][j]+dfs(dp,mat,n,i+1,j);\\n    int r=mat[i][j]+dfs(dp,mat,n,i+1,j+1);\\n    return dp[i][j]=min(l,r);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(),vector<int>(triangle.size(),-1));\\n        return dfs(dp,triangle,triangle.size());\\n    }\\n};\\n\\nwhat is wrong with my solution ???"
                    },
                    {
                        "username": "nightbird007",
                        "content": "[@csseifms](/csseifms) i did i got a time limit exceed in case 42"
                    },
                    {
                        "username": "csseifms",
                        "content": "maybe because you do not consider \"index\" jump; \"you may move to either index i or index i + 1 on the next row.\"\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1776522,
                "content": [
                    {
                        "username": "Joshualum",
                        "content": "I encountered another problem exactly as the same rule of this question, but this time we can choose 2 paths from the triangle. The common nodes of the 2 routes will only be counted once. I have really no idea on this!\\n\\nMy first intention was to set the 1st walked path nodes to 0 and do the second time, but I soon found a counter example. After that I tried to make a 3D array but again end up recounting nodes in the two paths... Can anyone solve this?"
                    },
                    {
                        "username": "vishalk754",
                        "content": " [@LeetCode](/LeetCode) i was solving this question got error for test case :\\ntriangle = [[-1],[2,3],[1,-1,-3]]\\nexpected = -1 \\nhow its possible any one please correct me if i am wrong \\n(-1)+(2)+(-3) = -2 its my ouput "
                    },
                    {
                        "username": "user2609J",
                        "content": "Hey every one,\\nI didn\\'t understand why the is -1 with this input [[-1],[2,3],[1,-1,-3]], can any one help me ?\\nThank\\'s"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Recursion | Memoization | Tabulation | Space Optimization\\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "rajivgurav712",
                        "content": "120. Triangle problem\\n\\nI wrote this code-\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        c=0\\n        for i in triangle:\\n            min=10\\n            for j in i:\\n                if j<min:\\n                    min=j\\n            c+=min\\n        return c\\n \\nand at 13th testcase the expected answer is -1 and i got -2 as per my code How? plz help me"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "I thought it is as easy as when we used to print * in a triangle but i was wrong."
                    },
                    {
                        "username": "vyomverma",
                        "content": "testcase:\\n[[-1],[2,3],[1,-1,-3]]\\n\\n\\nits output should be -2 \\nbut expected value is given as -1. \\n\\n\\nmy  cpp code:\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int min=0;\\n        for(int i=0 ; i< triangle.size() ;i++){\\n            int temp=triangle[i][0];\\n            for(int j=0 ; j<triangle[i].size() ; j++ ){\\n                if(triangle[i][j]<temp){\\n                    temp = triangle[i][j];\\n                }\\n               \\n            }\\n             min = min+temp;\\n        }\\n        return min;\\n    }\\n};"
                    },
                    {
                        "username": "dedmouze",
                        "content": "For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n![Answer](https://ltdfoto.ru/images/2023/01/23/Answer.png)\n\nYou cant go like red arrow. Only blue and green available."
                    },
                    {
                        "username": "csseifms",
                        "content": "Test case:\\n   [[2],\\n   [3,4],\\n  [6,5,9],\\n [4,4,8,0]]\\n\\nBreaking down for values after calculating step by step:\\n      [2]\\n    [5, 6]\\n  [11, 10, 11, 15]\\n[15, 15, 14, 18, 19, 11, 15]\\n\\nwhy the output should be 14 not 11?!"
                    },
                    {
                        "username": "nightbird007",
                        "content": "class Solution {\\npublic:\\nint dfs(vector<vector<int>>dp,vector<vector<int>>mat,int n,int i=0,int j=0)\\n{\\n    if(i==n)return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l=mat[i][j]+dfs(dp,mat,n,i+1,j);\\n    int r=mat[i][j]+dfs(dp,mat,n,i+1,j+1);\\n    return dp[i][j]=min(l,r);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(),vector<int>(triangle.size(),-1));\\n        return dfs(dp,triangle,triangle.size());\\n    }\\n};\\n\\nwhat is wrong with my solution ???"
                    },
                    {
                        "username": "nightbird007",
                        "content": "[@csseifms](/csseifms) i did i got a time limit exceed in case 42"
                    },
                    {
                        "username": "csseifms",
                        "content": "maybe because you do not consider \"index\" jump; \"you may move to either index i or index i + 1 on the next row.\"\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1769305,
                "content": [
                    {
                        "username": "Joshualum",
                        "content": "I encountered another problem exactly as the same rule of this question, but this time we can choose 2 paths from the triangle. The common nodes of the 2 routes will only be counted once. I have really no idea on this!\\n\\nMy first intention was to set the 1st walked path nodes to 0 and do the second time, but I soon found a counter example. After that I tried to make a 3D array but again end up recounting nodes in the two paths... Can anyone solve this?"
                    },
                    {
                        "username": "vishalk754",
                        "content": " [@LeetCode](/LeetCode) i was solving this question got error for test case :\\ntriangle = [[-1],[2,3],[1,-1,-3]]\\nexpected = -1 \\nhow its possible any one please correct me if i am wrong \\n(-1)+(2)+(-3) = -2 its my ouput "
                    },
                    {
                        "username": "user2609J",
                        "content": "Hey every one,\\nI didn\\'t understand why the is -1 with this input [[-1],[2,3],[1,-1,-3]], can any one help me ?\\nThank\\'s"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Recursion | Memoization | Tabulation | Space Optimization\\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "rajivgurav712",
                        "content": "120. Triangle problem\\n\\nI wrote this code-\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        c=0\\n        for i in triangle:\\n            min=10\\n            for j in i:\\n                if j<min:\\n                    min=j\\n            c+=min\\n        return c\\n \\nand at 13th testcase the expected answer is -1 and i got -2 as per my code How? plz help me"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "I thought it is as easy as when we used to print * in a triangle but i was wrong."
                    },
                    {
                        "username": "vyomverma",
                        "content": "testcase:\\n[[-1],[2,3],[1,-1,-3]]\\n\\n\\nits output should be -2 \\nbut expected value is given as -1. \\n\\n\\nmy  cpp code:\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int min=0;\\n        for(int i=0 ; i< triangle.size() ;i++){\\n            int temp=triangle[i][0];\\n            for(int j=0 ; j<triangle[i].size() ; j++ ){\\n                if(triangle[i][j]<temp){\\n                    temp = triangle[i][j];\\n                }\\n               \\n            }\\n             min = min+temp;\\n        }\\n        return min;\\n    }\\n};"
                    },
                    {
                        "username": "dedmouze",
                        "content": "For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n![Answer](https://ltdfoto.ru/images/2023/01/23/Answer.png)\n\nYou cant go like red arrow. Only blue and green available."
                    },
                    {
                        "username": "csseifms",
                        "content": "Test case:\\n   [[2],\\n   [3,4],\\n  [6,5,9],\\n [4,4,8,0]]\\n\\nBreaking down for values after calculating step by step:\\n      [2]\\n    [5, 6]\\n  [11, 10, 11, 15]\\n[15, 15, 14, 18, 19, 11, 15]\\n\\nwhy the output should be 14 not 11?!"
                    },
                    {
                        "username": "nightbird007",
                        "content": "class Solution {\\npublic:\\nint dfs(vector<vector<int>>dp,vector<vector<int>>mat,int n,int i=0,int j=0)\\n{\\n    if(i==n)return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l=mat[i][j]+dfs(dp,mat,n,i+1,j);\\n    int r=mat[i][j]+dfs(dp,mat,n,i+1,j+1);\\n    return dp[i][j]=min(l,r);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(),vector<int>(triangle.size(),-1));\\n        return dfs(dp,triangle,triangle.size());\\n    }\\n};\\n\\nwhat is wrong with my solution ???"
                    },
                    {
                        "username": "nightbird007",
                        "content": "[@csseifms](/csseifms) i did i got a time limit exceed in case 42"
                    },
                    {
                        "username": "csseifms",
                        "content": "maybe because you do not consider \"index\" jump; \"you may move to either index i or index i + 1 on the next row.\"\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1766950,
                "content": [
                    {
                        "username": "Joshualum",
                        "content": "I encountered another problem exactly as the same rule of this question, but this time we can choose 2 paths from the triangle. The common nodes of the 2 routes will only be counted once. I have really no idea on this!\\n\\nMy first intention was to set the 1st walked path nodes to 0 and do the second time, but I soon found a counter example. After that I tried to make a 3D array but again end up recounting nodes in the two paths... Can anyone solve this?"
                    },
                    {
                        "username": "vishalk754",
                        "content": " [@LeetCode](/LeetCode) i was solving this question got error for test case :\\ntriangle = [[-1],[2,3],[1,-1,-3]]\\nexpected = -1 \\nhow its possible any one please correct me if i am wrong \\n(-1)+(2)+(-3) = -2 its my ouput "
                    },
                    {
                        "username": "user2609J",
                        "content": "Hey every one,\\nI didn\\'t understand why the is -1 with this input [[-1],[2,3],[1,-1,-3]], can any one help me ?\\nThank\\'s"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Recursion | Memoization | Tabulation | Space Optimization\\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "rajivgurav712",
                        "content": "120. Triangle problem\\n\\nI wrote this code-\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        c=0\\n        for i in triangle:\\n            min=10\\n            for j in i:\\n                if j<min:\\n                    min=j\\n            c+=min\\n        return c\\n \\nand at 13th testcase the expected answer is -1 and i got -2 as per my code How? plz help me"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "I thought it is as easy as when we used to print * in a triangle but i was wrong."
                    },
                    {
                        "username": "vyomverma",
                        "content": "testcase:\\n[[-1],[2,3],[1,-1,-3]]\\n\\n\\nits output should be -2 \\nbut expected value is given as -1. \\n\\n\\nmy  cpp code:\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int min=0;\\n        for(int i=0 ; i< triangle.size() ;i++){\\n            int temp=triangle[i][0];\\n            for(int j=0 ; j<triangle[i].size() ; j++ ){\\n                if(triangle[i][j]<temp){\\n                    temp = triangle[i][j];\\n                }\\n               \\n            }\\n             min = min+temp;\\n        }\\n        return min;\\n    }\\n};"
                    },
                    {
                        "username": "dedmouze",
                        "content": "For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n![Answer](https://ltdfoto.ru/images/2023/01/23/Answer.png)\n\nYou cant go like red arrow. Only blue and green available."
                    },
                    {
                        "username": "csseifms",
                        "content": "Test case:\\n   [[2],\\n   [3,4],\\n  [6,5,9],\\n [4,4,8,0]]\\n\\nBreaking down for values after calculating step by step:\\n      [2]\\n    [5, 6]\\n  [11, 10, 11, 15]\\n[15, 15, 14, 18, 19, 11, 15]\\n\\nwhy the output should be 14 not 11?!"
                    },
                    {
                        "username": "nightbird007",
                        "content": "class Solution {\\npublic:\\nint dfs(vector<vector<int>>dp,vector<vector<int>>mat,int n,int i=0,int j=0)\\n{\\n    if(i==n)return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l=mat[i][j]+dfs(dp,mat,n,i+1,j);\\n    int r=mat[i][j]+dfs(dp,mat,n,i+1,j+1);\\n    return dp[i][j]=min(l,r);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(),vector<int>(triangle.size(),-1));\\n        return dfs(dp,triangle,triangle.size());\\n    }\\n};\\n\\nwhat is wrong with my solution ???"
                    },
                    {
                        "username": "nightbird007",
                        "content": "[@csseifms](/csseifms) i did i got a time limit exceed in case 42"
                    },
                    {
                        "username": "csseifms",
                        "content": "maybe because you do not consider \"index\" jump; \"you may move to either index i or index i + 1 on the next row.\"\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1764917,
                "content": [
                    {
                        "username": "Joshualum",
                        "content": "I encountered another problem exactly as the same rule of this question, but this time we can choose 2 paths from the triangle. The common nodes of the 2 routes will only be counted once. I have really no idea on this!\\n\\nMy first intention was to set the 1st walked path nodes to 0 and do the second time, but I soon found a counter example. After that I tried to make a 3D array but again end up recounting nodes in the two paths... Can anyone solve this?"
                    },
                    {
                        "username": "vishalk754",
                        "content": " [@LeetCode](/LeetCode) i was solving this question got error for test case :\\ntriangle = [[-1],[2,3],[1,-1,-3]]\\nexpected = -1 \\nhow its possible any one please correct me if i am wrong \\n(-1)+(2)+(-3) = -2 its my ouput "
                    },
                    {
                        "username": "user2609J",
                        "content": "Hey every one,\\nI didn\\'t understand why the is -1 with this input [[-1],[2,3],[1,-1,-3]], can any one help me ?\\nThank\\'s"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Recursion | Memoization | Tabulation | Space Optimization\\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "rajivgurav712",
                        "content": "120. Triangle problem\\n\\nI wrote this code-\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        c=0\\n        for i in triangle:\\n            min=10\\n            for j in i:\\n                if j<min:\\n                    min=j\\n            c+=min\\n        return c\\n \\nand at 13th testcase the expected answer is -1 and i got -2 as per my code How? plz help me"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "I thought it is as easy as when we used to print * in a triangle but i was wrong."
                    },
                    {
                        "username": "vyomverma",
                        "content": "testcase:\\n[[-1],[2,3],[1,-1,-3]]\\n\\n\\nits output should be -2 \\nbut expected value is given as -1. \\n\\n\\nmy  cpp code:\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int min=0;\\n        for(int i=0 ; i< triangle.size() ;i++){\\n            int temp=triangle[i][0];\\n            for(int j=0 ; j<triangle[i].size() ; j++ ){\\n                if(triangle[i][j]<temp){\\n                    temp = triangle[i][j];\\n                }\\n               \\n            }\\n             min = min+temp;\\n        }\\n        return min;\\n    }\\n};"
                    },
                    {
                        "username": "dedmouze",
                        "content": "For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n![Answer](https://ltdfoto.ru/images/2023/01/23/Answer.png)\n\nYou cant go like red arrow. Only blue and green available."
                    },
                    {
                        "username": "csseifms",
                        "content": "Test case:\\n   [[2],\\n   [3,4],\\n  [6,5,9],\\n [4,4,8,0]]\\n\\nBreaking down for values after calculating step by step:\\n      [2]\\n    [5, 6]\\n  [11, 10, 11, 15]\\n[15, 15, 14, 18, 19, 11, 15]\\n\\nwhy the output should be 14 not 11?!"
                    },
                    {
                        "username": "nightbird007",
                        "content": "class Solution {\\npublic:\\nint dfs(vector<vector<int>>dp,vector<vector<int>>mat,int n,int i=0,int j=0)\\n{\\n    if(i==n)return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l=mat[i][j]+dfs(dp,mat,n,i+1,j);\\n    int r=mat[i][j]+dfs(dp,mat,n,i+1,j+1);\\n    return dp[i][j]=min(l,r);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(),vector<int>(triangle.size(),-1));\\n        return dfs(dp,triangle,triangle.size());\\n    }\\n};\\n\\nwhat is wrong with my solution ???"
                    },
                    {
                        "username": "nightbird007",
                        "content": "[@csseifms](/csseifms) i did i got a time limit exceed in case 42"
                    },
                    {
                        "username": "csseifms",
                        "content": "maybe because you do not consider \"index\" jump; \"you may move to either index i or index i + 1 on the next row.\"\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1764510,
                "content": [
                    {
                        "username": "Joshualum",
                        "content": "I encountered another problem exactly as the same rule of this question, but this time we can choose 2 paths from the triangle. The common nodes of the 2 routes will only be counted once. I have really no idea on this!\\n\\nMy first intention was to set the 1st walked path nodes to 0 and do the second time, but I soon found a counter example. After that I tried to make a 3D array but again end up recounting nodes in the two paths... Can anyone solve this?"
                    },
                    {
                        "username": "vishalk754",
                        "content": " [@LeetCode](/LeetCode) i was solving this question got error for test case :\\ntriangle = [[-1],[2,3],[1,-1,-3]]\\nexpected = -1 \\nhow its possible any one please correct me if i am wrong \\n(-1)+(2)+(-3) = -2 its my ouput "
                    },
                    {
                        "username": "user2609J",
                        "content": "Hey every one,\\nI didn\\'t understand why the is -1 with this input [[-1],[2,3],[1,-1,-3]], can any one help me ?\\nThank\\'s"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Recursion | Memoization | Tabulation | Space Optimization\\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "rajivgurav712",
                        "content": "120. Triangle problem\\n\\nI wrote this code-\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        c=0\\n        for i in triangle:\\n            min=10\\n            for j in i:\\n                if j<min:\\n                    min=j\\n            c+=min\\n        return c\\n \\nand at 13th testcase the expected answer is -1 and i got -2 as per my code How? plz help me"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "I thought it is as easy as when we used to print * in a triangle but i was wrong."
                    },
                    {
                        "username": "vyomverma",
                        "content": "testcase:\\n[[-1],[2,3],[1,-1,-3]]\\n\\n\\nits output should be -2 \\nbut expected value is given as -1. \\n\\n\\nmy  cpp code:\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int min=0;\\n        for(int i=0 ; i< triangle.size() ;i++){\\n            int temp=triangle[i][0];\\n            for(int j=0 ; j<triangle[i].size() ; j++ ){\\n                if(triangle[i][j]<temp){\\n                    temp = triangle[i][j];\\n                }\\n               \\n            }\\n             min = min+temp;\\n        }\\n        return min;\\n    }\\n};"
                    },
                    {
                        "username": "dedmouze",
                        "content": "For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n![Answer](https://ltdfoto.ru/images/2023/01/23/Answer.png)\n\nYou cant go like red arrow. Only blue and green available."
                    },
                    {
                        "username": "csseifms",
                        "content": "Test case:\\n   [[2],\\n   [3,4],\\n  [6,5,9],\\n [4,4,8,0]]\\n\\nBreaking down for values after calculating step by step:\\n      [2]\\n    [5, 6]\\n  [11, 10, 11, 15]\\n[15, 15, 14, 18, 19, 11, 15]\\n\\nwhy the output should be 14 not 11?!"
                    },
                    {
                        "username": "nightbird007",
                        "content": "class Solution {\\npublic:\\nint dfs(vector<vector<int>>dp,vector<vector<int>>mat,int n,int i=0,int j=0)\\n{\\n    if(i==n)return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l=mat[i][j]+dfs(dp,mat,n,i+1,j);\\n    int r=mat[i][j]+dfs(dp,mat,n,i+1,j+1);\\n    return dp[i][j]=min(l,r);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(),vector<int>(triangle.size(),-1));\\n        return dfs(dp,triangle,triangle.size());\\n    }\\n};\\n\\nwhat is wrong with my solution ???"
                    },
                    {
                        "username": "nightbird007",
                        "content": "[@csseifms](/csseifms) i did i got a time limit exceed in case 42"
                    },
                    {
                        "username": "csseifms",
                        "content": "maybe because you do not consider \"index\" jump; \"you may move to either index i or index i + 1 on the next row.\"\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1754169,
                "content": [
                    {
                        "username": "Joshualum",
                        "content": "I encountered another problem exactly as the same rule of this question, but this time we can choose 2 paths from the triangle. The common nodes of the 2 routes will only be counted once. I have really no idea on this!\\n\\nMy first intention was to set the 1st walked path nodes to 0 and do the second time, but I soon found a counter example. After that I tried to make a 3D array but again end up recounting nodes in the two paths... Can anyone solve this?"
                    },
                    {
                        "username": "vishalk754",
                        "content": " [@LeetCode](/LeetCode) i was solving this question got error for test case :\\ntriangle = [[-1],[2,3],[1,-1,-3]]\\nexpected = -1 \\nhow its possible any one please correct me if i am wrong \\n(-1)+(2)+(-3) = -2 its my ouput "
                    },
                    {
                        "username": "user2609J",
                        "content": "Hey every one,\\nI didn\\'t understand why the is -1 with this input [[-1],[2,3],[1,-1,-3]], can any one help me ?\\nThank\\'s"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Recursion | Memoization | Tabulation | Space Optimization\\nhttps://leetcode.com/problems/triangle/solutions/3122570/recursion-memoization-tabulation-space-optimization/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "rajivgurav712",
                        "content": "120. Triangle problem\\n\\nI wrote this code-\\nclass Solution(object):\\n    def minimumTotal(self, triangle):\\n        c=0\\n        for i in triangle:\\n            min=10\\n            for j in i:\\n                if j<min:\\n                    min=j\\n            c+=min\\n        return c\\n \\nand at 13th testcase the expected answer is -1 and i got -2 as per my code How? plz help me"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "I thought it is as easy as when we used to print * in a triangle but i was wrong."
                    },
                    {
                        "username": "vyomverma",
                        "content": "testcase:\\n[[-1],[2,3],[1,-1,-3]]\\n\\n\\nits output should be -2 \\nbut expected value is given as -1. \\n\\n\\nmy  cpp code:\\nclass Solution {\\npublic:\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        int min=0;\\n        for(int i=0 ; i< triangle.size() ;i++){\\n            int temp=triangle[i][0];\\n            for(int j=0 ; j<triangle[i].size() ; j++ ){\\n                if(triangle[i][j]<temp){\\n                    temp = triangle[i][j];\\n                }\\n               \\n            }\\n             min = min+temp;\\n        }\\n        return min;\\n    }\\n};"
                    },
                    {
                        "username": "dedmouze",
                        "content": "For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n![Answer](https://ltdfoto.ru/images/2023/01/23/Answer.png)\n\nYou cant go like red arrow. Only blue and green available."
                    },
                    {
                        "username": "csseifms",
                        "content": "Test case:\\n   [[2],\\n   [3,4],\\n  [6,5,9],\\n [4,4,8,0]]\\n\\nBreaking down for values after calculating step by step:\\n      [2]\\n    [5, 6]\\n  [11, 10, 11, 15]\\n[15, 15, 14, 18, 19, 11, 15]\\n\\nwhy the output should be 14 not 11?!"
                    },
                    {
                        "username": "nightbird007",
                        "content": "class Solution {\\npublic:\\nint dfs(vector<vector<int>>dp,vector<vector<int>>mat,int n,int i=0,int j=0)\\n{\\n    if(i==n)return 0;\\n    if(dp[i][j]!=-1)return dp[i][j];\\n    int l=mat[i][j]+dfs(dp,mat,n,i+1,j);\\n    int r=mat[i][j]+dfs(dp,mat,n,i+1,j+1);\\n    return dp[i][j]=min(l,r);\\n}\\n    int minimumTotal(vector<vector<int>>& triangle) {\\n        vector<vector<int>>dp(triangle.size(),vector<int>(triangle.size(),-1));\\n        return dfs(dp,triangle,triangle.size());\\n    }\\n};\\n\\nwhat is wrong with my solution ???"
                    },
                    {
                        "username": "nightbird007",
                        "content": "[@csseifms](/csseifms) i did i got a time limit exceed in case 42"
                    },
                    {
                        "username": "csseifms",
                        "content": "maybe because you do not consider \"index\" jump; \"you may move to either index i or index i + 1 on the next row.\"\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum of Square Numbers",
        "question_content": "<p>Given a non-negative integer <code>c</code>, decide whether there&#39;re two integers <code>a</code> and <code>b</code> such that <code>a<sup>2</sup> + b<sup>2</sup> = c</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> c = 5\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 1 * 1 + 2 * 2 = 5\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> c = 3\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= c &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 104930,
                "title": "java-two-pointers-solution",
                "content": "```\\npublic class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long left = 0, right = (long) Math.sqrt(c);\\n        while (left <= right) {\\n            long cur = left * left + right * right;\\n            if (cur < c) {\\n                left++;\\n            } else if (cur > c) {\\n                right--;\\n            } else {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long left = 0, right = (long) Math.sqrt(c);\\n        while (left <= right) {\\n            long cur = left * left + right * right;\\n            if (cur < c) {\\n                left++;\\n            } else if (cur > c) {\\n                right--;\\n            } else {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424957,
                "title": "python-3-solutions-sqrt-hashset-two-pointers-clean-concise-o-sqrt-c",
                "content": "**\\u2714\\uFE0F Solution 1: Sqrt**\\n- Since `a^2 + b^2 = c` => `a = sqrt(c - b^2)` => `a <= sqrt(c)`.\\n- Traverse `a` in range `[0..sqrt(c)]`, check if there exists `bSquare` (where `bSquare = c - a^2`) and `bSquare` is a square number then return True.\\n```python\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        for a in range(int(sqrt(c))+1):\\n            b = sqrt(c - a*a)\\n            if b == int(b):\\n                return True\\n        return False\\n```\\n**Complexity**\\n- Time: `O(sqrt(c) * logC)`, where `c <= 2^31-1`.\\n\\t- The operation `sqrt(x)` takes `O(logX)`, can check this problem **[69. Sqrt(x)](https://leetcode.com/problems/sqrtx/)**.\\n- Space: `O(1)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Using HashSet**\\n- Pre-compute squares number in range `[0...c]` and add to our HashSet, let say `squareSet`.\\n- Iterate `aSquare` in `squareSet`, if there exists `bSquare` (where `bSquare = c - aSquare`) in the `squareSet` then return True.\\n```python\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        squareSet = set()\\n        for x in range(int(math.sqrt(c)) + 1):\\n            squareSet.add(x * x)\\n\\n        for aSquare in squareSet:\\n            bSquare = c - aSquare\\n            if bSquare in squareSet:\\n                return True\\n        return False\\n```\\n**Complexity**\\n- Time: `O(sqrt(c))`, where `c <= 2^31-1`\\n- Space: `O(sqrt(c))`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Two Pointers**\\n- We can use Two Pointers to search a pair of `(left, right)`, so that `left^2 + right^2 = c`.\\n- Start with `left = 0`, `right = int(sqrt(c))`.\\n- while `left <= right`:\\n\\t- Let `cur = left^2 + right^2`.\\n\\t- If `cur == c` then we found a perfect match -> return True\\n\\t- Else if `cur < c`, we need to increase `cur`, so `left += 1`.\\n\\t- Else we need to decrease `cur`, so `right -= 1`.\\n```python\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        left = 0\\n        right = int(sqrt(c))\\n        while left <= right:\\n            cur = left * left + right * right\\n            if cur == c: return True\\n            if cur < c:\\n                left += 1\\n            else:\\n                right -= 1\\n        return False\\n```\\n**Complexity**\\n- Time: `O(sqrt(c))`, where `c <= 2^31-1`\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        for a in range(int(sqrt(c))+1):\\n            b = sqrt(c - a*a)\\n            if b == int(b):\\n                return True\\n        return False\\n```\n```python\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        squareSet = set()\\n        for x in range(int(math.sqrt(c)) + 1):\\n            squareSet.add(x * x)\\n\\n        for aSquare in squareSet:\\n            bSquare = c - aSquare\\n            if bSquare in squareSet:\\n                return True\\n        return False\\n```\n```python\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        left = 0\\n        right = int(sqrt(c))\\n        while left <= right:\\n            cur = left * left + right * right\\n            if cur == c: return True\\n            if cur < c:\\n                left += 1\\n            else:\\n                right -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104932,
                "title": "hashset-java-quick-solution-one-for-loop",
                "content": "```\\npublic class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for (int i = 0; i <= Math.sqrt(c); i++) {\\n            set.add(i * i);\\n            if (set.contains(c - i * i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for (int i = 0; i <= Math.sqrt(c); i++) {\\n            set.add(i * i);\\n            if (set.contains(c - i * i)) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 347164,
                "title": "c-two-pointers-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) \\n    {\\n    \\tif(c<0)\\n    \\t\\treturn false;\\n    \\tlong int left=0,right=sqrt(c);\\n    \\twhile(left<=right)\\n    \\t{\\n    \\t\\tlong int cur=left*left+right*right;\\n    \\t\\tif(cur<c)\\n    \\t\\t\\tleft++;\\n    \\t\\telse if(cur>c)\\n    \\t\\t\\tright--;\\n    \\t\\telse \\n    \\t\\t\\treturn true;\\n    \\t}    \\n    \\treturn false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) \\n    {\\n    \\tif(c<0)\\n    \\t\\treturn false;\\n    \\tlong int left=0,right=sqrt(c);\\n    \\twhile(left<=right)\\n    \\t{\\n    \\t\\tlong int cur=left*left+right*right;\\n    \\t\\tif(cur<c)\\n    \\t\\t\\tleft++;\\n    \\t\\telse if(cur>c)\\n    \\t\\t\\tright--;\\n    \\t\\telse \\n    \\t\\t\\treturn true;\\n    \\t}    \\n    \\treturn false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104973,
                "title": "python-straightforward-with-explanation",
                "content": "```\\ndef judgeSquareSum(self, c):\\n    def is_square(N):\\n        return int(N**.5)**2 == N\\n        \\n    return any(is_square(c - a*a) \\n                for a in xrange(int(c**.5) + 1))\\n```\\n\\nWithout loss of generality, let's consider only ```a, b >= 0```.  This is because if say, ```a < 0```, then we may also find a solution using ```abs(a)```.\\n\\nNow, ```a*a = c - b*b <= c```, because ```b*b >= 0```, and ```0 <= a <= sqrt(c)``` is a necessary condition for a solution.\\n\\nLet's try each ```0 <= a <= sqrt(c)```.  For each choice of ```a```, we must have ```b*b = c - a*a```.  There will be a solution if and only if the right-hand-side is a perfect square.",
                "solutionTags": [],
                "code": "```\\ndef judgeSquareSum(self, c):\\n    def is_square(N):\\n        return int(N**.5)**2 == N\\n        \\n    return any(is_square(c - a*a) \\n                for a in xrange(int(c**.5) + 1))\\n```\n```a, b >= 0```\n```a < 0```\n```abs(a)```\n```a*a = c - b*b <= c```\n```b*b >= 0```\n```0 <= a <= sqrt(c)```\n```0 <= a <= sqrt(c)```\n```a```\n```b*b = c - a*a```",
                "codeTag": "Python3"
            },
            {
                "id": 104935,
                "title": "fermat",
                "content": "As [said earlier](https://discuss.leetcode.com/topic/23808/o-sqrt-n-in-ruby-c-c), a natural number is a sum of two squares if and only if each prime factor that's 3 modulo 4 occurs to an even power in the number's prime factorization.\\n```\\nrequire 'prime'\\n\\ndef judge_square_sum(c)\\n  c == 0 || c.prime_division.all? { |p, e| p % 4 != 3 || e.even? }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nrequire 'prime'\\n\\ndef judge_square_sum(c)\\n  c == 0 || c.prime_division.all? { |p, e| p % 4 != 3 || e.even? }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1424993,
                "title": "sum-of-square-numbers-3-approaches-c-python-java",
                "content": "Obviously this can be done using brute force method. But here I have some other approaches on the same lines\\n\\n\\u2705 ***USING SQRT FUNCTION***\\nSomewhat of a brute force approach where we traverse from `0` to `sqrt(c)` and check for valid conditions\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(long long int a = 0 ; a <= sqrt(c) ; a++)\\n        {\\n            double b = sqrt(c - a * a);\\n            if(b == (int)b)\\n            {\\n                return true ;\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\\n`In JAVA`\\n```\\npublic class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for (long a = 0; a * a <= c; a++) \\n        {\\n            double b = Math.sqrt(c - a * a);\\n            if (b == (int) b)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        for a in range(floor(math.sqrt(c))+1):\\n            b = sqrt(c - a*a)\\n            if b.is_integer():\\n                return True\\n        return False\\n```\\n<hr>\\n\\n\\u2705 ***2 POINTER APPROACH***\\nBetween `0` and `sqrt(c)` we look for values that satisfies the condition\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if(c < 3)\\n            return true ;\\n        long long int a = 0 , b = sqrt(c) ;\\n        while(a <= b)\\n        {\\n            if(a*a + b*b == c)\\n            {\\n                return true ;\\n            }\\n            else if(a*a + b*b < c)\\n            {\\n                a++ ;\\n            }\\n            else\\n            {\\n                b-- ;\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        if c < 3: \\n            return True\\n        a = 0\\n        b = int(math.sqrt(c))\\n        while a <= b:\\n            val = a*a + b*b\\n            if val == c:\\n                return True\\n            elif val < c:\\n                a += 1\\n            else:\\n                b -= 1\\n        return False\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c < 3)\\n        {\\n            return true;\\n        }\\n        int a = 0 , b = (int)Math.sqrt(c);\\n        while(a <= b)\\n        {\\n            if((a*a + b*b)==c)\\n            {\\n                return true;\\n            }\\n            else if((a*a + b*b)<c)\\n            {\\n                a++;\\n            }\\n            else\\n            {\\n                b--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n<hr>\\n\\n\\u2705 ***FERMAT THEOREM***\\nThe [theorem](https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares) states that \"A number `n` is a sum of two squares `if and only` if *all prime factors of n* of the form `4k+3` have *even exponent (power)* in the prime factorization of n.\"\\n* Prime factors of the number \\n\\t* Of the form `(4k + 3)` \\n\\t\\t* Having even power\\n\\t\\t\\t* Only then the number can be represented as sum of squares\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(int i = 2 ; i*i <= c ; i++)\\n        {\\n            int cnt = 0 ;\\n            if(!(c%i))\\n            {\\n                while(c%i == 0) // Count all the prime factors\\n                {\\n                    cnt++ ;\\n                    c /= i ;\\n                }\\n                if(i%4 == 3 && cnt%2 != 0) //If any prime factor of the form (4k+3) occurs an odd number of times.\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n        return c%4 != 3 ; // If the number itself is a prime number and can be expressed in the form of (4k+3) -> return false.\\n    }\\n};\\n```\\n`In Python` \\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(2, int(sqrt(c) + 1)):\\n            cnt = 0 \\n            if c%i == 0:\\n                while(c%i == 0):\\n                    cnt += 1 \\n                    c = int(c/i)\\n                if i%4 == 3 and cnt%2:\\n                    return False\\n        return c%4 != 3\\n```\\n\\n<HR>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(long long int a = 0 ; a <= sqrt(c) ; a++)\\n        {\\n            double b = sqrt(c - a * a);\\n            if(b == (int)b)\\n            {\\n                return true ;\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for (long a = 0; a * a <= c; a++) \\n        {\\n            double b = Math.sqrt(c - a * a);\\n            if (b == (int) b)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        for a in range(floor(math.sqrt(c))+1):\\n            b = sqrt(c - a*a)\\n            if b.is_integer():\\n                return True\\n        return False\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if(c < 3)\\n            return true ;\\n        long long int a = 0 , b = sqrt(c) ;\\n        while(a <= b)\\n        {\\n            if(a*a + b*b == c)\\n            {\\n                return true ;\\n            }\\n            else if(a*a + b*b < c)\\n            {\\n                a++ ;\\n            }\\n            else\\n            {\\n                b-- ;\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        if c < 3: \\n            return True\\n        a = 0\\n        b = int(math.sqrt(c))\\n        while a <= b:\\n            val = a*a + b*b\\n            if val == c:\\n                return True\\n            elif val < c:\\n                a += 1\\n            else:\\n                b -= 1\\n        return False\\n```\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c < 3)\\n        {\\n            return true;\\n        }\\n        int a = 0 , b = (int)Math.sqrt(c);\\n        while(a <= b)\\n        {\\n            if((a*a + b*b)==c)\\n            {\\n                return true;\\n            }\\n            else if((a*a + b*b)<c)\\n            {\\n                a++;\\n            }\\n            else\\n            {\\n                b--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(int i = 2 ; i*i <= c ; i++)\\n        {\\n            int cnt = 0 ;\\n            if(!(c%i))\\n            {\\n                while(c%i == 0) // Count all the prime factors\\n                {\\n                    cnt++ ;\\n                    c /= i ;\\n                }\\n                if(i%4 == 3 && cnt%2 != 0) //If any prime factor of the form (4k+3) occurs an odd number of times.\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n        return c%4 != 3 ; // If the number itself is a prime number and can be expressed in the form of (4k+3) -> return false.\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(2, int(sqrt(c) + 1)):\\n            cnt = 0 \\n            if c%i == 0:\\n                while(c%i == 0):\\n                    cnt += 1 \\n                    c = int(c/i)\\n                if i%4 == 3 and cnt%2:\\n                    return False\\n        return c%4 != 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632331,
                "title": "squares-sum-c-binary-search",
                "content": "Time completixy=O(\\u221Ac*log\\u221Ac)\\n```\\nclass Solution {\\npublic:\\n     bool isPerfectSquare( long int n) {\\n        if(n==1 || n==0)return true;\\n      long int s=0,e=n;\\n        \\n        while(s<=e){\\n            long int m=s+(e-s)/2;\\n            if(m*m==n)return true;\\n           else if(m*m<n)\\n                s=m+1;\\n            else e=m-1;\\n        }\\n        return false;\\n    }\\n    bool judgeSquareSum(int c) {\\n        \\n         if(c==1 || c==0)return true;\\n        \\n        for(long int i=0;i*i<=c;i++){\\n           long int x=i*i;\\n           if (isPerfectSquare(c-x))\\n               return true;\\n             \\n        }\\n                   return false;\\n    }\\n};\\n```\\n\\nupvote if got ;)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isPerfectSquare( long int n) {\\n        if(n==1 || n==0)return true;\\n      long int s=0,e=n;\\n        \\n        while(s<=e){\\n            long int m=s+(e-s)/2;\\n            if(m*m==n)return true;\\n           else if(m*m<n)\\n                s=m+1;\\n            else e=m-1;\\n        }\\n        return false;\\n    }\\n    bool judgeSquareSum(int c) {\\n        \\n         if(c==1 || c==0)return true;\\n        \\n        for(long int i=0;i*i<=c;i++){\\n           long int x=i*i;\\n           if (isPerfectSquare(c-x))\\n               return true;\\n             \\n        }\\n                   return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104934,
                "title": "python-solution-using-set",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        sq = set()\\n        count = int(math.sqrt(c))\\n        # use (count + 1) because first index is 0\\n        for i in range(count + 1):\\n            sq.add(i ** 2)\\n\\n        for n in sq:\\n            if c - n in sq:\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        sq = set()\\n        count = int(math.sqrt(c))\\n        # use (count + 1) because first index is 0\\n        for i in range(count + 1):\\n            sq.add(i ** 2)\\n\\n        for n in sq:\\n            if c - n in sq:\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353607,
                "title": "python-easy-solution-two-pointers",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        cc = int(c ** 0.5)\\n        left = 0\\n        right = cc\\n        while left <= right:\\n            res = left ** 2 + right ** 2\\n            if res == c:\\n                return True\\n            elif res < c:\\n                left += 1\\n            elif res > c:\\n                right -= 1\\n        return False\\n```\\nTime complexity : O(\\\\sqrt(c))\\nSpace complexity: O(1)\\nNote that 0 can be one of the factorization numbers and two integers could be equal.",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        cc = int(c ** 0.5)\\n        left = 0\\n        right = cc\\n        while left <= right:\\n            res = left ** 2 + right ** 2\\n            if res == c:\\n                return True\\n            elif res < c:\\n                left += 1\\n            elif res > c:\\n                right -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424981,
                "title": "python-o-sqrt-c-solution-explained",
                "content": "I am not sure, why this problem is marked as medium: all you need to do is to do bruteforce: just consider all numbers before `sqrt(c)` and check if corresponding `b` is integer. Why we need to check all numbers only before `sqrt(c)`? Because square is always not-negative and if first part is greater than `c`, we can not make sum equal to `c`.\\n\\n#### Complexity\\nTime complexity is `O(sqrt(c))`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def judgeSquareSum(self, c):\\n        for i in range(int(math.sqrt(c))+1):\\n            j = c - i*i\\n            if int(math.sqrt(j))**2 == j: return True\\n        return False\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def judgeSquareSum(self, c):\\n        for i in range(int(math.sqrt(c))+1):\\n            j = c - i*i\\n            if int(math.sqrt(j))**2 == j: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104970,
                "title": "c-very-simple-o-1-space-solution",
                "content": "```\\nbool judgeSquareSum(int c) {\\n        for(int i=0;i<=sqrt(c);i++) {\\n            int t=sqrt(c-i*i);\\n            if(t*t==c-i*i) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool judgeSquareSum(int c) {\\n        for(int i=0;i<=sqrt(c);i++) {\\n            int t=sqrt(c-i*i);\\n            if(t*t==c-i*i) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2622127,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long s = 0;\\n        long e =  (long)Math.sqrt(c);\\n        while(s<=e){\\n            long mid = s*s + e*e;\\n            if(mid==(long)c){\\n                return true;\\n            }else if(mid>(long)c){\\n                e--;\\n            }else{\\n                s++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long s = 0;\\n        long e =  (long)Math.sqrt(c);\\n        while(s<=e){\\n            long mid = s*s + e*e;\\n            if(mid==(long)c){\\n                return true;\\n            }else if(mid>(long)c){\\n                e--;\\n            }else{\\n                s++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932800,
                "title": "python-two-solutions-two-pointers-binary-search",
                "content": "**Please upvote if it helps. Thank you!**\\n```\\ndef judgeSquareSum(self, c: int) -> bool:\\n    for a in range(int(sqrt(c)) + 1):\\n        target = c - a**2\\n        l, r = 0, sqrt(c)\\n        while l <= r:\\n            b = l + (r - l) // 2\\n            if b*b == target:\\n                return True\\n            elif b*b > target:\\n                r = b - 1\\n            else:\\n                l = b + 1\\n    return False\\n```\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        a, b = 0, int(sqrt(c))\\n        while a <= b:\\n            total = a**2 + b**2\\n            if total == c:\\n                return True\\n            elif total < c:\\n                a += 1\\n            else:\\n                b -= 1\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\ndef judgeSquareSum(self, c: int) -> bool:\\n    for a in range(int(sqrt(c)) + 1):\\n        target = c - a**2\\n        l, r = 0, sqrt(c)\\n        while l <= r:\\n            b = l + (r - l) // 2\\n            if b*b == target:\\n                return True\\n            elif b*b > target:\\n                r = b - 1\\n            else:\\n                l = b + 1\\n    return False\\n```\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        a, b = 0, int(sqrt(c))\\n        while a <= b:\\n            total = a**2 + b**2\\n            if total == c:\\n                return True\\n            elif total < c:\\n                a += 1\\n            else:\\n                b -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202507,
                "title": "c-0ms-solution",
                "content": "Basically framed it as an sum of two numbers in array search problem, with array elements in squares (0, 1, 4, 9, ...).\\n\\nRuntime is O(sqrt(c)).\\n\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int top = sqrt(c);\\n        int bot = 0, det = 0;\\n        while(bot <= top) {\\n            det = top*top + bot*bot;\\n            if(det == c) {\\n                return true;\\n            }\\n            else if(det < c) {\\n                bot++;\\n            }\\n            else if(det > c) {\\n                top--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int top = sqrt(c);\\n        int bot = 0, det = 0;\\n        while(bot <= top) {\\n            det = top*top + bot*bot;\\n            if(det == c) {\\n                return true;\\n            }\\n            else if(det < c) {\\n                bot++;\\n            }\\n            else if(det > c) {\\n                top--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104940,
                "title": "java-3-liner",
                "content": "```\\npublic static boolean judgeSquareSum(int c) {\\n  for (int i=0;i<=Math.sqrt(c);i++) \\n    if (Math.floor(Math.sqrt(c-i*i)) == Math.sqrt(c-i*i)) return true;\\n  return false;\\n}  \\n```",
                "solutionTags": [],
                "code": "```\\npublic static boolean judgeSquareSum(int c) {\\n  for (int i=0;i<=Math.sqrt(c);i++) \\n    if (Math.floor(Math.sqrt(c-i*i)) == Math.sqrt(c-i*i)) return true;\\n  return false;\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2697520,
                "title": "easy-solution-in-c-o-c-0-5-beats-100-binary-search-two-pointer",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple two pointer and binary search \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(sqrt(c))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long i=0;\\n        long long j=sqrt(c);\\n        while(i<=j){\\n            long long sum=i*i+j*j;\\n            if(sum==c){\\n                return true;\\n            }\\n            else if(sum>c){\\n                j--;\\n            }\\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long i=0;\\n        long long j=sqrt(c);\\n        while(i<=j){\\n            long long sum=i*i+j*j;\\n            if(sum==c){\\n                return true;\\n            }\\n            else if(sum>c){\\n                j--;\\n            }\\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203194,
                "title": "python3-solution-using-two-pointers",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        low = 0\\n        high = int(sqrt(c))\\n        \\n        if high**2 == c:\\n            return True\\n        \\n        while low<=high:\\n            x = low **2 + high **2\\n            if x == c:\\n                return True\\n            if x > c:\\n                high-=1\\n            else:\\n                low+=1\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        low = 0\\n        high = int(sqrt(c))\\n        \\n        if high**2 == c:\\n            return True\\n        \\n        while low<=high:\\n            x = low **2 + high **2\\n            if x == c:\\n                return True\\n            if x > c:\\n                high-=1\\n            else:\\n                low+=1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021769,
                "title": "two-pointer-algo-java",
                "content": "Use two pointer algo from the range [ 0, squareroot of c].\\n\\n```\\nclass Solution { \\n    public boolean judgeSquareSum(int c) { \\n        long i=0;\\n        long j= (int) (Math.sqrt(c)) ;\\n        \\n        while(i<=j){ \\n            long e=j*j+(i*i); \\n            if(e==c) return true;\\n            if(e>c ) j--;\\n            else i++;\\n        }\\n        return false;\\n    }     \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution { \\n    public boolean judgeSquareSum(int c) { \\n        long i=0;\\n        long j= (int) (Math.sqrt(c)) ;\\n        \\n        while(i<=j){ \\n            long e=j*j+(i*i); \\n            if(e==c) return true;\\n            if(e>c ) j--;\\n            else i++;\\n        }\\n        return false;\\n    }     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818774,
                "title": "c-two-pointer-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int f=0;\\n    for(int i=0, j=sqrt(c);i<=j;)\\n    {\\n        if(pow(i,2)+pow(j,2) == c)\\n            return true;\\n        else if(pow(i,2)+pow(j,2) < c)\\n            i++;\\n        else\\n            j--;\\n    }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int f=0;\\n    for(int i=0, j=sqrt(c);i<=j;)\\n    {\\n        if(pow(i,2)+pow(j,2) == c)\\n            return true;\\n        else if(pow(i,2)+pow(j,2) < c)\\n            i++;\\n        else\\n            j--;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1424995,
                "title": "c-python-java-3-approaches-easy-to-understand",
                "content": "Obviously this can be done using brute force method. But here I have some other approaches on the same lines\\n\\n\\u2705 ***USING SQRT FUNCTION***\\nSomewhat of a brute force approach where we traverse from `0` to `sqrt(c)` and check for valid conditions\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(long long int a = 0 ; a <= sqrt(c) ; a++)\\n        {\\n            double b = sqrt(c - a * a);\\n            if(b == (int)b)\\n            {\\n                return true ;\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\\n`In JAVA`\\n```\\npublic class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for (long a = 0; a * a <= c; a++) \\n        {\\n            double b = Math.sqrt(c - a * a);\\n            if (b == (int) b)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        for a in range(floor(math.sqrt(c))+1):\\n            b = sqrt(c - a*a)\\n            if b.is_integer():\\n                return True\\n        return False\\n```\\n<hr>\\n\\n\\u2705 ***2 POINTER APPROACH***\\nBetween `0` and `sqrt(c)` we look for values that satisfies the condition\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if(c < 3)\\n            return true ;\\n        long long int a = 0 , b = sqrt(c) ;\\n        while(a <= b)\\n        {\\n            if(a*a + b*b == c)\\n            {\\n                return true ;\\n            }\\n            else if(a*a + b*b < c)\\n            {\\n                a++ ;\\n            }\\n            else\\n            {\\n                b-- ;\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        if c < 3: \\n            return True\\n        a = 0\\n        b = int(math.sqrt(c))\\n        while a <= b:\\n            val = a*a + b*b\\n            if val == c:\\n                return True\\n            elif val < c:\\n                a += 1\\n            else:\\n                b -= 1\\n        return False\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c < 3)\\n        {\\n            return true;\\n        }\\n        int a = 0 , b = (int)Math.sqrt(c);\\n        while(a <= b)\\n        {\\n            if((a*a + b*b)==c)\\n            {\\n                return true;\\n            }\\n            else if((a*a + b*b)<c)\\n            {\\n                a++;\\n            }\\n            else\\n            {\\n                b--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n<hr>\\n\\n\\u2705 ***FERMAT THEOREM***\\nThe [theorem](https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares) states that \"A number `n` is a sum of two squares `if and only` if *all prime factors of n* of the form `4k+3` have *even exponent (power)* in the prime factorization of n.\"\\n* Prime factors of the number \\n\\t* Of the form `(4k + 3)` \\n\\t\\t* Having even power\\n\\t\\t\\t* Only then the number can be represented as sum of squares\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(int i = 2 ; i*i <= c ; i++)\\n        {\\n            int cnt = 0 ;\\n            if(!(c%i))\\n            {\\n                while(c%i == 0) // Count all the prime factors\\n                {\\n                    cnt++ ;\\n                    c /= i ;\\n                }\\n                if(i%4 == 3 && cnt%2 != 0) //If any prime factor of the form (4k+3) occurs an odd number of times.\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n        return c%4 != 3 ; // If the number itself is a prime number and can be expressed in the form of (4k+3) -> return false.\\n    }\\n};\\n```\\n`In Python` \\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(2, int(sqrt(c) + 1)):\\n            cnt = 0 \\n            if c%i == 0:\\n                while(c%i == 0):\\n                    cnt += 1 \\n                    c = int(c/i)\\n                if i%4 == 3 and cnt%2:\\n                    return False\\n        return c%4 != 3\\n```\\n\\n<HR>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(long long int a = 0 ; a <= sqrt(c) ; a++)\\n        {\\n            double b = sqrt(c - a * a);\\n            if(b == (int)b)\\n            {\\n                return true ;\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for (long a = 0; a * a <= c; a++) \\n        {\\n            double b = Math.sqrt(c - a * a);\\n            if (b == (int) b)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        for a in range(floor(math.sqrt(c))+1):\\n            b = sqrt(c - a*a)\\n            if b.is_integer():\\n                return True\\n        return False\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if(c < 3)\\n            return true ;\\n        long long int a = 0 , b = sqrt(c) ;\\n        while(a <= b)\\n        {\\n            if(a*a + b*b == c)\\n            {\\n                return true ;\\n            }\\n            else if(a*a + b*b < c)\\n            {\\n                a++ ;\\n            }\\n            else\\n            {\\n                b-- ;\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        if c < 3: \\n            return True\\n        a = 0\\n        b = int(math.sqrt(c))\\n        while a <= b:\\n            val = a*a + b*b\\n            if val == c:\\n                return True\\n            elif val < c:\\n                a += 1\\n            else:\\n                b -= 1\\n        return False\\n```\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c < 3)\\n        {\\n            return true;\\n        }\\n        int a = 0 , b = (int)Math.sqrt(c);\\n        while(a <= b)\\n        {\\n            if((a*a + b*b)==c)\\n            {\\n                return true;\\n            }\\n            else if((a*a + b*b)<c)\\n            {\\n                a++;\\n            }\\n            else\\n            {\\n                b--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(int i = 2 ; i*i <= c ; i++)\\n        {\\n            int cnt = 0 ;\\n            if(!(c%i))\\n            {\\n                while(c%i == 0) // Count all the prime factors\\n                {\\n                    cnt++ ;\\n                    c /= i ;\\n                }\\n                if(i%4 == 3 && cnt%2 != 0) //If any prime factor of the form (4k+3) occurs an odd number of times.\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n        return c%4 != 3 ; // If the number itself is a prime number and can be expressed in the form of (4k+3) -> return false.\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(2, int(sqrt(c) + 1)):\\n            cnt = 0 \\n            if c%i == 0:\\n                while(c%i == 0):\\n                    cnt += 1 \\n                    c = int(c/i)\\n                if i%4 == 3 and cnt%2:\\n                    return False\\n        return c%4 != 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708080,
                "title": "c-brute-force-solution",
                "content": "***Runtime: 4 ms, faster than 71.15% of C++ online submissions for Sum of Square Numbers.\\nMemory Usage: 6.1 MB, less than 51.65% of C++ online submissions for Sum of Square Numbers.***\\n\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for (long a = 0; a * a <= c; a++) {\\n            double b = sqrt(c - a * a);\\n            if (b == int(b))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for (long a = 0; a * a <= c; a++) {\\n            double b = sqrt(c - a * a);\\n            if (b == int(b))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252770,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        s=set()\\n        for i in range(0,floor(math.sqrt(c))+1):\\n            s.add(i*i)\\n            if((c-i*i in s) or (2*i*i==c)):\\n                return True       \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        s=set()\\n        for i in range(0,floor(math.sqrt(c))+1):\\n            s.add(i*i)\\n            if((c-i*i in s) or (2*i*i==c)):\\n                return True       \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344299,
                "title": "100-beats-java-solutions-clean-and-easy-to-understand-code-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJAI SHREE RAM\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search approach\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long i =0 ;\\n        long j = (long)Math.sqrt(c);\\n        while(i<=j){\\n            long mid = i*i+j*j;\\n            if(mid == c){\\n                return true;\\n            }\\n            else if(mid > c){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nplease upvote this for better solution of other questions![download.jfif](https://assets.leetcode.com/users/images/cab69741-c3c9-46e0-9833-1b11eb3b72ab_1679842610.7967398.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long i =0 ;\\n        long j = (long)Math.sqrt(c);\\n        while(i<=j){\\n            long mid = i*i+j*j;\\n            if(mid == c){\\n                return true;\\n            }\\n            else if(mid > c){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734957,
                "title": "c-two-pointers-binary-search-2-approaches",
                "content": "* **Given Equation : sqr(a) + sqr(b) = c. We need to find whether there exists any a and b for a particular c**\\n* **sqr(b) = c-sqr(a)**\\n* **So, we need to do binary search on c-sqr(a) for every value of square of a**\\n* **Time Complexity : O(sqrt(c)Logc)**\\n```\\nclass Solution {\\npublic:\\n    bool binary_search(long long int x)\\n    {\\n        long long int low = 0;\\n        long long int high = x;\\n        while(low<high)\\n        {\\n            long long int mid = (low+high)/2;\\n            if(mid*mid == x)\\n            {\\n                return true;\\n            }\\n            if(mid*mid > x)\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n    bool judgeSquareSum(int c) {\\n        if(c == 1 || c == 2 | c == 0)\\n        {\\n            return true;\\n        }\\n      \\n        for(long long int a = 0;a*a<=c;a++)\\n        {\\n            if(binary_search(c-(int)(a*a)))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n* **Another Simple approach is to use two pointers**\\n* **We know the values of a and b lies between 0 and sqrt(c).**\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int i=0,j=sqrt(c);\\n        while(i<=j)\\n        {\\n            if(i*i+j*j==c)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n            else if(i*i+j*j>c)\\n\\t\\t\\t{\\n                j--;\\n\\t\\t\\t}\\n            else\\n\\t\\t\\t{\\n                i++;\\n\\t\\t\\t}\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool binary_search(long long int x)\\n    {\\n        long long int low = 0;\\n        long long int high = x;\\n        while(low<high)\\n        {\\n            long long int mid = (low+high)/2;\\n            if(mid*mid == x)\\n            {\\n                return true;\\n            }\\n            if(mid*mid > x)\\n            {\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n    bool judgeSquareSum(int c) {\\n        if(c == 1 || c == 2 | c == 0)\\n        {\\n            return true;\\n        }\\n      \\n        for(long long int a = 0;a*a<=c;a++)\\n        {\\n            if(binary_search(c-(int)(a*a)))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int i=0,j=sqrt(c);\\n        while(i<=j)\\n        {\\n            if(i*i+j*j==c)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n            else if(i*i+j*j>c)\\n\\t\\t\\t{\\n                j--;\\n\\t\\t\\t}\\n            else\\n\\t\\t\\t{\\n                i++;\\n\\t\\t\\t}\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487621,
                "title": "python-sol-based-on-sum-of-two-squares-theorem-95-with-explanation",
                "content": "Python sol. based on \"**Sum of two squares theorem**\" \\n\\n---\\n\\nHint:\\nWe can use the result of \"Sum of two squares theorem\" to reduce our computation overhead.\\n\\nHere is the key concept\\n**An integer greater than one** can be written as a **sum of two squares**, **if and only if**,\\nits **prime decomposition** contains **no prime congruent to 3 modulo 4 raised to an odd power****.\\n\\nReference:\\n[1] Sum of two squares theorem\\nhttps://en.wikipedia.org/wiki/Sum_of_two_squares_theorem\\n\\n---\\n\\nExample explanation:\\n\\n---\\n\\n13 ( **Pass** )\\n13 = 2^2 + 3^2 \\n13 = 13 ^ 1  \\n13\\'s factor decomposition is not in the form of (4k+3) ^ q, where q is odd integer.\\n\\n---\\n\\n25 ( **Pass** )\\n25 = 0^2 + 5^2 \\n25 = 5 ^ 2\\n5\\'s factor decomposition is not in the form of (4k+3) ^ q, where q is odd integer.\\n\\n---\\n\\n18 ( **Pass** )\\n18 = 3^2 + 3^2 \\n18 = (2^1) * (3^2)\\nBoth 2\\'s and 3\\'s factor decomposition are not in the form of (4k+3) ^ q, where q is odd integer.\\n\\n---\\n\\n28 ( **Reject** )\\n28 =/= a^2 + b^2\\n28 = (2^2) * (**7**^**1**)\\n2\\'s factor decomposition is okay.\\nBut 7\\'s factor decomposition is rejected, because it is in in the form of (**4k+3**) ^ **q**, where **q** is **odd** integer.\\n\\n---\\n\\n33 ( **Reject** )\\n33 =/= a^2 + b^2\\n33 = (**3**^**1**) * (**11**^**1**)\\nBoth 3\\'s and 7\\'s factor decomposition are rejected, because they are in the form of (**4k+3**) ^ **q**, where **q** is **odd** integer.\\n\\n---\\n\\n```\\nfrom math import sqrt\\n\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        \\n        # general form:\\n        # a^2 + b^2 == c where a <= b\\n        \\n        # c = (p1^q1) * (p2^q2) ... * (pk^qk)\\n        \\n        \\n        factor = 2\\n        \\n        # scan each prime factor\\n        while factor * factor <= c:\\n            \\n            exponent_of_factor = 0\\n            \\n            # check whether \" facotr | c \" or not\\n            if c % factor == 0:\\n                \\n                # get the exponent of current factor\\n                while c % factor == 0:\\n                    \\n                    # accumulate the exponenet of prime factor\\n                    exponent_of_factor += 1\\n                    \\n                    # update c\\n                    c = c // factor\\n                \\n                \\n                # Reject factor decomposition in the form: \" (4k+3)^q | c \", where q is odd integer\\n                if factor % 4 == 3 and exponent_of_factor % 2 != 0:\\n                    return False\\n            \\n            # try next factor\\n            factor += 1\\n        \\n        # Reject number in the form: c = 4k+3 where k is non-negative integer\\n        return c % 4 != 3\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nfrom math import sqrt\\n\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        \\n        # general form:\\n        # a^2 + b^2 == c where a <= b\\n        \\n        # c = (p1^q1) * (p2^q2) ... * (pk^qk)\\n        \\n        \\n        factor = 2\\n        \\n        # scan each prime factor\\n        while factor * factor <= c:\\n            \\n            exponent_of_factor = 0\\n            \\n            # check whether \" facotr | c \" or not\\n            if c % factor == 0:\\n                \\n                # get the exponent of current factor\\n                while c % factor == 0:\\n                    \\n                    # accumulate the exponenet of prime factor\\n                    exponent_of_factor += 1\\n                    \\n                    # update c\\n                    c = c // factor\\n                \\n                \\n                # Reject factor decomposition in the form: \" (4k+3)^q | c \", where q is odd integer\\n                if factor % 4 == 3 and exponent_of_factor % 2 != 0:\\n                    return False\\n            \\n            # try next factor\\n            factor += 1\\n        \\n        # Reject number in the form: c = 4k+3 where k is non-negative integer\\n        return c % 4 != 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104956,
                "title": "javascript-solution-in-5-lines",
                "content": "The idea is determine by sqrt of `c-a*a` is a integer or not\\n```\\nvar judgeSquareSum = function(c) {\\n    for(var i=Math.floor(Math.sqrt(c));i>=0;i--){\\n        if(Number.isInteger(Math.sqrt(c-i*i)))\\n            return true        \\n    }\\n    return false\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar judgeSquareSum = function(c) {\\n    for(var i=Math.floor(Math.sqrt(c));i>=0;i--){\\n        if(Number.isInteger(Math.sqrt(c-i*i)))\\n            return true        \\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341440,
                "title": "binary-search-and-two-pointers-approach-python3",
                "content": "# 1. Two Pointers Approach\\n``` \\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        i,j=0,int(sqrt(c))\\n        while i<=j:\\n            if i*i+j*j==c:\\n                return True\\n            if i*i+j*j>c:\\n                j-=1\\n            else:\\n                i+=1\\n        return False\\n```\\n\\n# 2. Binary search Approach----->O(NLogN)\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        for i in range(int(sqrt(c))+1):\\n            left,right=0,c\\n            while left<=right:\\n                mid=(left+right)//2\\n                if i*i+mid*mid==c:\\n                    return True\\n                if i*i + mid*mid > c:\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n        return False\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        i,j=0,int(sqrt(c))\\n        while i<=j:\\n            if i*i+j*j==c:\\n                return True\\n            if i*i+j*j>c:\\n                j-=1\\n            else:\\n                i+=1\\n        return False\\n```\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        for i in range(int(sqrt(c))+1):\\n            left,right=0,c\\n            while left<=right:\\n                mid=(left+right)//2\\n                if i*i+mid*mid==c:\\n                    return True\\n                if i*i + mid*mid > c:\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108416,
                "title": "two-pointers-vs-binary-search",
                "content": "# Code:\\n1. Two Pointers\\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        low, high = 0, sqrt(c)\\n        high = int(high) + 1\\n        while low <= high:\\n            power = (low ** 2) + (high ** 2) \\n            if power > c:\\n                high -= 1\\n            elif power < c:\\n                low += 1\\n            else: return True\\n        return False\\n```\\n2. Binary Search\\n\\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        low, high = 0, sqrt(c)\\n        high = int(high) + 1\\n        for num in range(high + 1):\\n            l, h = num, high\\n            while h >= l:\\n                mid = (l + h) // 2\\n                power = (num ** 2) + (mid ** 2)\\n                if power > c:\\n                    h = mid - 1\\n                elif power < c:\\n                    l = mid + 1\\n                else: return True\\n        return False\\n```\\n**UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        low, high = 0, sqrt(c)\\n        high = int(high) + 1\\n        while low <= high:\\n            power = (low ** 2) + (high ** 2) \\n            if power > c:\\n                high -= 1\\n            elif power < c:\\n                low += 1\\n            else: return True\\n        return False\\n```\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        low, high = 0, sqrt(c)\\n        high = int(high) + 1\\n        for num in range(high + 1):\\n            l, h = num, high\\n            while h >= l:\\n                mid = (l + h) // 2\\n                power = (num ** 2) + (mid ** 2)\\n                if power > c:\\n                    h = mid - 1\\n                elif power < c:\\n                    l = mid + 1\\n                else: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425356,
                "title": "javascript-intutive-solution",
                "content": "```\\n/**\\n * @param {number} c\\n * @return {boolean}\\n */\\nvar judgeSquareSum = function(c) {\\n    var r = Math.floor(Math.sqrt(c));\\n    var l = 0;\\n     \\n    while(l <= r){\\n        var sum  = l**2 + r**2\\n        if( sum === c){\\n            return true\\n        }else if(sum < c){\\n            l++\\n        }else{\\n            r--\\n        }\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number} c\\n * @return {boolean}\\n */\\nvar judgeSquareSum = function(c) {\\n    var r = Math.floor(Math.sqrt(c));\\n    var l = 0;\\n     \\n    while(l <= r){\\n        var sum  = l**2 + r**2\\n        if( sum === c){\\n            return true\\n        }else if(sum < c){\\n            l++\\n        }else{\\n            r--\\n        }\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807957,
                "title": "python-2-pointer-soln-faster-than-95",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l = 0\\n        r = int(c ** 0.5)\\n        while l <= r:\\n            curr = l*l + r*r\\n            if curr < c:\\n                l += 1\\n            elif curr > c:\\n                r -= 1\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l = 0\\n        r = int(c ** 0.5)\\n        while l <= r:\\n            curr = l*l + r*r\\n            if curr < c:\\n                l += 1\\n            elif curr > c:\\n                r -= 1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104964,
                "title": "16ms-java",
                "content": "```\\npublic boolean judgeSquareSum(int c) {\\n        int i=0;\\n        int j = (int) Math.sqrt(c);\\n        while(i<=j){\\n            if((i*i + j*j) < c) i++;\\n            else if((i*i + j*j) > c) j--;\\n            else return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean judgeSquareSum(int c) {\\n        int i=0;\\n        int j = (int) Math.sqrt(c);\\n        while(i<=j){\\n            if((i*i + j*j) < c) i++;\\n            else if((i*i + j*j) > c) j--;\\n            else return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3701061,
                "title": "basic-approach-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long l=0, r=sqrt(c);\\n        while(l<=r)\\n         {\\n            long long p=l*l+r*r;\\n            if(p<c)\\n               l++;\\n            else if(p>c)\\n                 r--;\\n            else if(p==c)\\n                  return true;\\n         }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long l=0, r=sqrt(c);\\n        while(l<=r)\\n         {\\n            long long p=l*l+r*r;\\n            if(p<c)\\n               l++;\\n            else if(p>c)\\n                 r--;\\n            else if(p==c)\\n                  return true;\\n         }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638668,
                "title": "dry-run-explanation-by-example-7-line-code",
                "content": "\\n\\n\\n# Approach\\n```\\n//**assum c=24**;\\n\\nlong a=0;\\n//a=0; means b^2=c;\\nlong b =(long)Math.sqrt(c);//only integer, sqrt(24)=4;\\n//since b=4 &a=0;<= this value is inital \\nvalues updated in while loop\\n\\n\\n**Dry run**\\n// a<=b(condition)\\n// a=0, 1, 2, 3, 3\\n// b=4, 4, 4, 4, 3\\n// c=16,17,20,25,18\\n//false\\n```\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long a=0;\\n        long b=(long)Math.sqrt(c);\\n\\n        //two pointer appraoch\\n        while(a<=b){\\n            if((a*a + b*b)==c) return true;\\n            else if((a*a + b*b)<c) a++;\\n            else b--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\n//**assum c=24**;\\n\\nlong a=0;\\n//a=0; means b^2=c;\\nlong b =(long)Math.sqrt(c);//only integer, sqrt(24)=4;\\n//since b=4 &a=0;<= this value is inital \\nvalues updated in while loop\\n\\n\\n**Dry run**\\n// a<=b(condition)\\n// a=0, 1, 2, 3, 3\\n// b=4, 4, 4, 4, 3\\n// c=16,17,20,25,18\\n//false\\n```\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long a=0;\\n        long b=(long)Math.sqrt(c);\\n\\n        //two pointer appraoch\\n        while(a<=b){\\n            if((a*a + b*b)==c) return true;\\n            else if((a*a + b*b)<c) a++;\\n            else b--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979513,
                "title": "binary-search-c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        //a^2 + b^2 = c \\n        //see using binary search till sqrt(c) as the very next no. square > c \\n        //ex. 9 -> sqrt(9) -> 3 and 4*4>9 \\n\\n       //we,try to fix one number using i and find the other i.e i^2+b^2 = c --> b^2 = c-i^2 \\n         for(long long int i=0;i*i<=c;i++){\\n          long long int start=0,end=c-i*i;\\n          long long int target = c-i*i;\\n\\n          while(start<=end){\\n              long long int mid = start+(end-start)/2;\\n              long long int search = mid*mid;\\n\\n              if(search>target) end=mid-1;\\n              else if(search<target) start=mid+1;\\n              else if(search==target) return true;\\n          }\\n         }\\n         return false;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        //a^2 + b^2 = c \\n        //see using binary search till sqrt(c) as the very next no. square > c \\n        //ex. 9 -> sqrt(9) -> 3 and 4*4>9 \\n\\n       //we,try to fix one number using i and find the other i.e i^2+b^2 = c --> b^2 = c-i^2 \\n         for(long long int i=0;i*i<=c;i++){\\n          long long int start=0,end=c-i*i;\\n          long long int target = c-i*i;\\n\\n          while(start<=end){\\n              long long int mid = start+(end-start)/2;\\n              long long int search = mid*mid;\\n\\n              if(search>target) end=mid-1;\\n              else if(search<target) start=mid+1;\\n              else if(search==target) return true;\\n          }\\n         }\\n         return false;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912452,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(long long a = 0; a*a <= c; a++) {\\n            double b = sqrt(c - a * a);\\n            if(b == (int)b) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(long long a = 0; a*a <= c; a++) {\\n            double b = sqrt(c - a * a);\\n            if(b == (int)b) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767098,
                "title": "python3-easy-solution-one-pointer-faster-thar-91",
                "content": "\\n\\n\\n```\\n    for a in range(int(sqrt(c))+1):\\n                b=sqrt(c-a*a)\\n                if b==int(b): return True\\n```\\n![image](https://assets.leetcode.com/users/images/a84dd7af-6137-4248-bd46-c5e89e4e99d2_1667313113.9619918.png)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    for a in range(int(sqrt(c))+1):\\n                b=sqrt(c-a*a)\\n                if b==int(b): return True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2470416,
                "title": "easy-solution-using-binary-search-c-faster-than-100-of-online-submission",
                "content": "**TIME COMPLEXITY:-O(Log(C)) \\n  **SPACE COMPLEXITY:-O(1)\\n  \\n  class Solution \\n{  \\n    int findsqrt(int x) \\n    {\\n        if(x==1 || x==0) \\n        return x;\\n        long long low=1,high=(x>>1),mid,ans;\\n        while(low<=high) \\n        {\\n            mid=(low+high)>>1; \\n            long long int k=(1LL*(mid * mid));\\n            if(k>x) \\n            high=mid-1;\\n            else \\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n        } \\n        return ans;     \\n    }\\npublic: \\n    bool judgeSquareSum(int c) \\n    {\\n        int start=0,end=findsqrt(c);\\n        while(start<=end) \\n        {\\n            if(start * start * 1LL+end * end * 1LL==c * 1LL) \\n            return true;\\n            else if(start * start * 1LL+end * end * 1LL<c * 1LL) \\n            start++;\\n            else \\n            end--;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution \\n{  \\n    int findsqrt(int x) \\n    {\\n        if(x==1 || x==0) \\n        return x;\\n        long long low=1,high=(x>>1),mid,ans;\\n        while(low<=high) \\n        {\\n            mid=(low+high)>>1; \\n            long long int k=(1LL*(mid * mid));\\n            if(k>x) \\n            high=mid-1;\\n            else \\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2440471,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q633. Sum of Square Numbers***\\nGiven a non-negative integer c, decide whether there\\'re two integers `a` and `b` such that `a2 + b2 = c.`\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l,h=0,int(sqrt(c))\\n        while(l<=h):\\n            if l*l+h*h==c:\\n                return True\\n            elif l*l+h*h<c:\\n                l+=1\\n            else:\\n                h-=1\\n        return False\\n```\\n**Runtime:**  237 ms\\t\\n**Memory Usage:**  15.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n         long j= (int) (Math.sqrt(c)) ;\\n        int i=0;\\n        while(i<=j)\\n        {\\n            if(i*i+j*j==c)\\n                return true;\\n            else if(i*i+j*j<c)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**Runtime:**  6 ms\\t\\n**Memory Usage:**  48.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int i=0,j=sqrt(c);\\n        while(i<=j)\\n        {\\n            if(i*i+j*j==c)\\n\\t\\t\\t\\treturn true;\\n            else if(i*i+j*j>c)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Runtime:**  3 ms\\t\\n**Memory Usage:**  5.4 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l,h=0,int(sqrt(c))\\n        while(l<=h):\\n            if l*l+h*h==c:\\n                return True\\n            elif l*l+h*h<c:\\n                l+=1\\n            else:\\n                h-=1\\n        return False\\n```\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n         long j= (int) (Math.sqrt(c)) ;\\n        int i=0;\\n        while(i<=j)\\n        {\\n            if(i*i+j*j==c)\\n                return true;\\n            else if(i*i+j*j<c)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int i=0,j=sqrt(c);\\n        while(i<=j)\\n        {\\n            if(i*i+j*j==c)\\n\\t\\t\\t\\treturn true;\\n            else if(i*i+j*j>c)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310004,
                "title": "c-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long num1=sqrt(c);\\n        long res=0;\\n        long num2=0;\\n        while(num2<=num1){\\n            res = num1*num1+num2*num2;\\n            if(res==c){\\n                return true;\\n            }else if(res<c){\\n                num2++;\\n            }else{num1--;}\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Sum of Square Numbers.\\nMemory Usage: 5.9 MB, less than 25.58% of C++ online submissions for Sum of Square Numbers.**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long num1=sqrt(c);\\n        long res=0;\\n        long num2=0;\\n        while(num2<=num1){\\n            res = num1*num1+num2*num2;\\n            if(res==c){\\n                return true;\\n            }else if(res<c){\\n                num2++;\\n            }else{num1--;}\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974057,
                "title": "javascript-binary-search",
                "content": "Since a and b must less than or equal sqrt(c), we have lower bound at 0 and upper bound at sqrt(c).\\n\\n```\\nvar judgeSquareSum = function(c) {\\n    let low = 0;\\n    let high = Math.floor(Math.sqrt(c));\\n    \\n    while (low <= high) {\\n        const sum = low*low + high*high;\\n        const mid = Math.floor(low + (high - low)/2);\\n        \\n        \\n        if (sum === c) {\\n            return true\\n        }\\n        \\n        if (sum < c) {\\n            low = mid*mid + high*high < c ? mid + 1: low +1;\\n        }\\n        \\n        if (sum > c) {\\n            high = mid * mid + low * low > c ? mid - 1 : high - 1;\\n        }\\n        \\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nvar judgeSquareSum = function(c) {\\n    let low = 0;\\n    let high = Math.floor(Math.sqrt(c));\\n    \\n    while (low <= high) {\\n        const sum = low*low + high*high;\\n        const mid = Math.floor(low + (high - low)/2);\\n        \\n        \\n        if (sum === c) {\\n            return true\\n        }\\n        \\n        if (sum < c) {\\n            low = mid*mid + high*high < c ? mid + 1: low +1;\\n        }\\n        \\n        if (sum > c) {\\n            high = mid * mid + low * low > c ? mid - 1 : high - 1;\\n        }\\n        \\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1948640,
                "title": "2-solutions-using-binary-search-using-two-pointer",
                "content": "1 : Using Two Pointer\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int n) {\\n        int root = (int) Math.sqrt(n);\\n        long low = 0;\\n        long high = root;\\n        \\n        while(low<=high){\\n           long sum = (low*low)+(high*high);\\n            if(sum==n){\\n                return true;\\n            }\\n            if(sum>n){\\n                high--;\\n            }\\n            else{\\n                low++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n2 : Using Binary Search\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int n) {\\n        \\n        long low = 0;\\n        long high = Math.min(n, Integer.MAX_VALUE/2);\\n        \\n        while(low<=high){\\n            long ls = low*low;\\n            long hs = high*high;\\n            \\n            long sum = ls+hs;\\n            if(sum==n){\\n                return true;\\n            }\\n            long mid = low+(high-low)/2;\\n            long ms = mid*mid;\\n            //if sum > n, then some how we have to decrese the high value\\n            if(sum>n){\\n                if(ms+ls>n){\\n                    high = mid-1;\\n                }else{\\n                    high--;\\n                }\\n            } // if sum < n, then some how we have to increse the low value \\n            else{\\n                if(ms+hs<n){\\n                    low = mid+1;\\n                }else{\\n                    low++;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nIf you understand then please upvote it.",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int n) {\\n        int root = (int) Math.sqrt(n);\\n        long low = 0;\\n        long high = root;\\n        \\n        while(low<=high){\\n           long sum = (low*low)+(high*high);\\n            if(sum==n){\\n                return true;\\n            }\\n            if(sum>n){\\n                high--;\\n            }\\n            else{\\n                low++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int n) {\\n        \\n        long low = 0;\\n        long high = Math.min(n, Integer.MAX_VALUE/2);\\n        \\n        while(low<=high){\\n            long ls = low*low;\\n            long hs = high*high;\\n            \\n            long sum = ls+hs;\\n            if(sum==n){\\n                return true;\\n            }\\n            long mid = low+(high-low)/2;\\n            long ms = mid*mid;\\n            //if sum > n, then some how we have to decrese the high value\\n            if(sum>n){\\n                if(ms+ls>n){\\n                    high = mid-1;\\n                }else{\\n                    high--;\\n                }\\n            } // if sum < n, then some how we have to increse the low value \\n            else{\\n                if(ms+hs<n){\\n                    low = mid+1;\\n                }else{\\n                    low++;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711795,
                "title": "two-pointer-solution-python3",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        first=0\\n        last=int(sqrt(c))\\n        if c<=2:\\n            return True\\n        \\n        while first<=last:\\n            k=(first*first) + (last*last) \\n            if k==c:\\n                return True\\n            elif k<c:\\n                first=first+1\\n            else:\\n                last=last-1\\n        return False\\n\\t\\t\\n\\t\\t# we can know that those two nums will be in the         \\n\\t    # range of 0,sqrt(num) inclusive\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        first=0\\n        last=int(sqrt(c))\\n        if c<=2:\\n            return True\\n        \\n        while first<=last:\\n            k=(first*first) + (last*last) \\n            if k==c:\\n                return True\\n            elif k<c:\\n                first=first+1\\n            else:\\n                last=last-1\\n        return False\\n\\t\\t\\n\\t\\t# we can know that those two nums will be in the         \\n\\t    # range of 0,sqrt(num) inclusive\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561775,
                "title": "java-two-pointers-solution-not-working-for-input-2147483600-solution",
                "content": "\\tpublic boolean judgeSquareSum(int c) {\\n        long i = 0, int j =  (int) Math.sqrt(c);;\\n        while (i <= j) {\\n            long sum = i * i + j * j;\\n            if (sum == c) {\\n                return true;\\n            } else if (c > sum) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n\\nFor those who receives wrong answers that shows not valide for 2147483600 as input with using two pointers method. Simply replace int with long will resolve the issue.\\n",
                "solutionTags": [],
                "code": "\\tpublic boolean judgeSquareSum(int c) {\\n        long i = 0, int j =  (int) Math.sqrt(c);;\\n        while (i <= j) {\\n            long sum = i * i + j * j;\\n            if (sum == c) {\\n                return true;\\n            } else if (c > sum) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n\\nFor those who receives wrong answers that shows not valide for 2147483600 as input with using two pointers method. Simply replace int with long will resolve the issue.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1426666,
                "title": "c-two-pointer-no-extra-space-easy-to-understand-for-beginners",
                "content": "first of all we need to find the floor square root value of the c.\\neg if c=20 floor sqrt value=4;\\nand then we will use two pointer concept to find if we we achive the c by adding square of the two pointer numbers.\\nlet  i=0;\\nand j=floor(sqrt(c));\\nnow  **if sum of square is greater than c, then move j back i.e j--, if less than c move i++; if found equal return true.**\\n\\n**please like if you find helpfull**\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long k=sqrt(c);\\n        if(k*k==c){\\n            return true;\\n        }\\n        long long i=0;\\n        long long j=k;\\n        while(i<=j){\\n            long long int p=(i*i+j*j);\\n            if(p==c){\\n                return true;\\n            }\\n            if(p<c){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long k=sqrt(c);\\n        if(k*k==c){\\n            return true;\\n        }\\n        long long i=0;\\n        long long j=k;\\n        while(i<=j){\\n            long long int p=(i*i+j*j);\\n            if(p==c){\\n                return true;\\n            }\\n            if(p<c){\\n                i++;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425217,
                "title": "c-solution-0ms-100-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        \\n        long long int i = 0, j = sqrt(c);\\n        if(c == 2 || c == 1 ||c == 0) return true;\\n        while(i <= j){\\n            if(i*i + j*j == c)\\n                return true;\\n            else if(i*i + j*j > c)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        \\n        long long int i = 0, j = sqrt(c);\\n        if(c == 2 || c == 1 ||c == 0) return true;\\n        while(i <= j){\\n            if(i*i + j*j == c)\\n                return true;\\n            else if(i*i + j*j > c)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425062,
                "title": "c-simple-and-short-solution-using-two-pointers-o-sqrt-n-tc-o-1-sc",
                "content": "**Time Complexity:** O(sqrt(n))\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        size_t hi = (int)sqrt(c), lo = 0;\\n        \\n        while (lo <= hi) {\\n            int curr = lo * lo + hi * hi;\\n            if (curr == c) return true;\\n            else if (curr < c) lo++;\\n            else hi--;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        size_t hi = (int)sqrt(c), lo = 0;\\n        \\n        while (lo <= hi) {\\n            int curr = lo * lo + hi * hi;\\n            if (curr == c) return true;\\n            else if (curr < c) lo++;\\n            else hi--;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779561,
                "title": "javascript",
                "content": "\\n```\\nvar judgeSquareSum = function(c) {\\n    if (c === 0) {\\n        return true\\n    }\\n    for (let a = 0; a*a < c; a++) {\\n        let b = Math.sqrt(parseFloat(c-a*a));\\n        if (b - Math.round(b) === 0) {\\n            return true;\\n        }\\n    }\\n        return false\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar judgeSquareSum = function(c) {\\n    if (c === 0) {\\n        return true\\n    }\\n    for (let a = 0; a*a < c; a++) {\\n        let b = Math.sqrt(parseFloat(c-a*a));\\n        if (b - Math.round(b) === 0) {\\n            return true;\\n        }\\n    }\\n        return false\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3893393,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(sqrt(c)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/0f0752c6-96cd-4d1f-8d8d-2d248ee7f5df_1691732717.0036974.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        // Initialize two pointers: i starts at 0, and j starts at the square root of \\'c\\'\\n        long i = 0;\\n        long j = (long)Math.sqrt(c);\\n\\n        // Use a two-pointer approach to search for a pair of squares that sum up to \\'c\\'\\n        while (i <= j) {\\n            // Calculate the sum of squares of \\'i\\' and \\'j\\'\\n            long sum = (i * i) + (j * j);\\n\\n            // If the sum is equal to \\'c\\', we\\'ve found a valid pair\\n            if (sum == c) {\\n                return true;\\n            } else if (sum < c) {\\n                // If the sum is less than \\'c\\', increment the smaller pointer (i)\\n                i++;\\n            } else {\\n                // If the sum is greater than \\'c\\', decrement the larger pointer (j)\\n                j--;\\n            }\\n        }\\n\\n        // No pair of squares found that sum up to \\'c\\'\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        // Initialize two pointers: i starts at 0, and j starts at the square root of \\'c\\'\\n        long i = 0;\\n        long j = (long)Math.sqrt(c);\\n\\n        // Use a two-pointer approach to search for a pair of squares that sum up to \\'c\\'\\n        while (i <= j) {\\n            // Calculate the sum of squares of \\'i\\' and \\'j\\'\\n            long sum = (i * i) + (j * j);\\n\\n            // If the sum is equal to \\'c\\', we\\'ve found a valid pair\\n            if (sum == c) {\\n                return true;\\n            } else if (sum < c) {\\n                // If the sum is less than \\'c\\', increment the smaller pointer (i)\\n                i++;\\n            } else {\\n                // If the sum is greater than \\'c\\', decrement the larger pointer (j)\\n                j--;\\n            }\\n        }\\n\\n        // No pair of squares found that sum up to \\'c\\'\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818682,
                "title": "c-simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe search for a number whose square is just less than c\\nThen we find a number whose square can fill the gap between c and the other number\\'s square\\nif found returned true\\nelse false\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if (c == 0) return true;\\n\\n        for (long long i = 0; i * i <= c; i++) {\\n            long long cc = c - i * i;\\n            long long cc_sqrt = sqrt(cc);\\n            if (cc_sqrt * cc_sqrt == cc) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if (c == 0) return true;\\n\\n        for (long long i = 0; i * i <= c; i++) {\\n            long long cc = c - i * i;\\n            long long cc_sqrt = sqrt(cc);\\n            if (cc_sqrt * cc_sqrt == cc) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608793,
                "title": "c-solution-using-two-pointers-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long a = 0, b = sqrt(c);\\n        if(c<0){\\n            return false;\\n        }\\n        while(a<=b){\\n            if(a*a+b*b==c){\\n                return true;\\n            }\\n            else if(a*a+b*b<c){\\n                a++;\\n            }\\n            else{\\n                b--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/5d3e9031-892f-4e35-a497-bc27a087f86b_1686133726.1488855.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long a = 0, b = sqrt(c);\\n        if(c<0){\\n            return false;\\n        }\\n        while(a<=b){\\n            if(a*a+b*b==c){\\n                return true;\\n            }\\n            else if(a*a+b*b<c){\\n                a++;\\n            }\\n            else{\\n                b--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504430,
                "title": "easy-c-solution-runtime-beats-100-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if(c<0)\\n          return false;\\n        long long l=0, r=sqrt(c);\\n        while(l<=r)\\n         {\\n             long long p=l*l+r*r;\\n             if(p<c)\\n               l++;\\n              else if(p>c)\\n                 r--;\\n                else if(p==c)\\n                  return true;\\n         }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if(c<0)\\n          return false;\\n        long long l=0, r=sqrt(c);\\n        while(l<=r)\\n         {\\n             long long p=l*l+r*r;\\n             if(p<c)\\n               l++;\\n              else if(p>c)\\n                 r--;\\n                else if(p==c)\\n                  return true;\\n         }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416476,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if(c==1)\\n            return true;\\n      long long  int left=0, right = sqrt(c);\\n        while(left<=right){\\n           long long int sum = (left*left) + (right*right);\\n            if(sum==c)\\n                return true;\\n            else if(sum<c)\\n                left++;\\n            else\\n                right--;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        i = 2\\n        while i * i <= c:\\n            count = 0\\n            if c % i == 0:\\n                while c % i == 0:\\n                    count += 1\\n                    c //= i\\n                if count % 2 and i % 4 == 3:\\n                    return False\\n            i += 1\\n        return c % 4 != 3\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for (int i = 2; i * i <= c; i++) {\\n            int count = 0;\\n            if (c % i == 0) {\\n                while (c % i == 0) {\\n                    count++;\\n                    c /= i;\\n                }\\n                if (i % 4 == 3 && count % 2 != 0)\\n                    return false;\\n            }\\n        }\\n        return c % 4 != 3;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if(c==1)\\n            return true;\\n      long long  int left=0, right = sqrt(c);\\n        while(left<=right){\\n           long long int sum = (left*left) + (right*right);\\n            if(sum==c)\\n                return true;\\n            else if(sum<c)\\n                left++;\\n            else\\n                right--;\\n        }\\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        i = 2\\n        while i * i <= c:\\n            count = 0\\n            if c % i == 0:\\n                while c % i == 0:\\n                    count += 1\\n                    c //= i\\n                if count % 2 and i % 4 == 3:\\n                    return False\\n            i += 1\\n        return c % 4 != 3\\n```\n```Java []\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for (int i = 2; i * i <= c; i++) {\\n            int count = 0;\\n            if (c % i == 0) {\\n                while (c % i == 0) {\\n                    count++;\\n                    c /= i;\\n                }\\n                if (i % 4 == 3 && count % 2 != 0)\\n                    return false;\\n            }\\n        }\\n        return c % 4 != 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308579,
                "title": "easy-python-solution-using-binary-search-2-different-solution-using-bs",
                "content": "# #Solution 1\\n![image.png](https://assets.leetcode.com/users/images/6e67f58e-4c7a-4c6c-b444-438967201ed4_1679075137.5026033.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        i=0\\n        j=int(c**(1/2))\\n        while i<=j:\\n            m=i*i+j*j\\n            if m==c:\\n                return True\\n            elif m>c:\\n                j-=1\\n            else:i+=1\\n        return False\\n```\\n## #Solution 2\\n![image.png](https://assets.leetcode.com/users/images/eeab6eeb-e8a2-48cb-b423-f3de84dcedc1_1679075186.4167922.png)\\n\\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        val=c\\n        if c>2000:val=sqrt(c)\\n        lst=[i*i for i in range(int(val)+1)]\\n        def bs(val,lst):\\n            i=0\\n            j=len(lst)-1\\n            while i<=j:\\n                m=(i+j)//2\\n                if lst[m]==val:\\n                    return 1\\n                elif lst[m]>val:\\n                    j=m-1\\n                else:i=m+1\\n            return 0\\n        for i in lst:\\n            val=c-i\\n            if val<0:break\\n            ans=bs(val,lst)\\n            if val==0 or ans==True:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        i=0\\n        j=int(c**(1/2))\\n        while i<=j:\\n            m=i*i+j*j\\n            if m==c:\\n                return True\\n            elif m>c:\\n                j-=1\\n            else:i+=1\\n        return False\\n```\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        val=c\\n        if c>2000:val=sqrt(c)\\n        lst=[i*i for i in range(int(val)+1)]\\n        def bs(val,lst):\\n            i=0\\n            j=len(lst)-1\\n            while i<=j:\\n                m=(i+j)//2\\n                if lst[m]==val:\\n                    return 1\\n                elif lst[m]>val:\\n                    j=m-1\\n                else:i=m+1\\n            return 0\\n        for i in lst:\\n            val=c-i\\n            if val<0:break\\n            ans=bs(val,lst)\\n            if val==0 or ans==True:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953558,
                "title": "two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long a = 0;\\n        long b = (long)Math.sqrt(c);\\n        while(a<=b){\\n            if((a*a + b*b) == c){\\n                return true;\\n            }\\n            else if((a*a + b*b)<c){\\n                a++;\\n            }else{\\n                b--;\\n            }\\n        } \\n        return false;      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long a = 0;\\n        long b = (long)Math.sqrt(c);\\n        while(a<=b){\\n            if((a*a + b*b) == c){\\n                return true;\\n            }\\n            else if((a*a + b*b)<c){\\n                a++;\\n            }else{\\n                b--;\\n            }\\n        } \\n        return false;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719908,
                "title": "javascript-two-pointer-method-and-binary-search-helpful-comments",
                "content": "**Two pointer method**\\n```\\n// Time: O(n)\\n// Space: O(n)\\nconst judgeSquareSum = (c) => {\\n    let low = 0;\\n    let high = Math.ceil(Math.sqrt(c));\\n\\n    while (low <= high) {\\n        const currProd = low ** 2 + high ** 2;\\n\\n        if (c > currProd) {\\n\\t\\t\\t// moving pointer to right increases sum/product\\n            low++;\\n        } else if (c < currProd) {\\n\\t\\t\\t// moving pointer to left decreases sum/product\\n            high--;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```\\n\\n**Binary Search Method**\\n\\n```\\n// Time: O(log n)\\n// Space: O(1)\\nconst judgeSquareSum = (c) => {\\n    let low = 0;\\n    let high = Math.ceil(Math.sqrt(c));\\n\\n    while (low <= high) {\\n        const sum = low ** 2 + high ** 2;\\n        const mid = Math.floor(low + (high - low) / 2);\\n\\n        if (c > sum) {\\n            // c is greater than sum, so we move low to right to increase\\n\\n            // if c > mid**2 + high**2, then we know low is after mid + 1\\n            // otherwise, we know low is between mid and low, so low + 1\\n            low = c > mid ** 2 + high ** 2 ? mid + 1 : low + 1;\\n        } else if (c < sum) {\\n            //c is less than sum, so we move high to left to decrease\\n\\n            // if c < mid ** 2 + low ** 2, we know high isn\\'t to right of mid, so mid -1\\n            // otherwise, we know high is on that right side, so high - 1\\n            high = c < mid ** 2 + low ** 2 ? mid - 1 : high - 1;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n// Time: O(n)\\n// Space: O(n)\\nconst judgeSquareSum = (c) => {\\n    let low = 0;\\n    let high = Math.ceil(Math.sqrt(c));\\n\\n    while (low <= high) {\\n        const currProd = low ** 2 + high ** 2;\\n\\n        if (c > currProd) {\\n\\t\\t\\t// moving pointer to right increases sum/product\\n            low++;\\n        } else if (c < currProd) {\\n\\t\\t\\t// moving pointer to left decreases sum/product\\n            high--;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```\n```\\n// Time: O(log n)\\n// Space: O(1)\\nconst judgeSquareSum = (c) => {\\n    let low = 0;\\n    let high = Math.ceil(Math.sqrt(c));\\n\\n    while (low <= high) {\\n        const sum = low ** 2 + high ** 2;\\n        const mid = Math.floor(low + (high - low) / 2);\\n\\n        if (c > sum) {\\n            // c is greater than sum, so we move low to right to increase\\n\\n            // if c > mid**2 + high**2, then we know low is after mid + 1\\n            // otherwise, we know low is between mid and low, so low + 1\\n            low = c > mid ** 2 + high ** 2 ? mid + 1 : low + 1;\\n        } else if (c < sum) {\\n            //c is less than sum, so we move high to left to decrease\\n\\n            // if c < mid ** 2 + low ** 2, we know high isn\\'t to right of mid, so mid -1\\n            // otherwise, we know high is on that right side, so high - 1\\n            high = c < mid ** 2 + low ** 2 ? mid - 1 : high - 1;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528826,
                "title": "java-two-pointers-easy",
                "content": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long left = 0;\\n        long right = (long) Math.sqrt(c);\\n        \\n        while (left <= right) {\\n            if (left * left + right * right == c) {\\n                return true;\\n            }\\n            if (left * left + right * right > c) {\\n                right--;\\n            }\\n            else {\\n                left++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long left = 0;\\n        long right = (long) Math.sqrt(c);\\n        \\n        while (left <= right) {\\n            if (left * left + right * right == c) {\\n                return true;\\n            }\\n            if (left * left + right * right > c) {\\n                right--;\\n            }\\n            else {\\n                left++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218584,
                "title": "fastest-python-binary-search-explained",
                "content": "# Python Binary Search Solution.\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n\\t    # If we take two integers a and b and we check if the sum of their squares equals c.\\n\\t\\t# a and b lie within range (0, c**0.5) so we look in this range.\\n        l = 0\\n        r = int(c**0.5) # exponent to get the square root\\n        while l<=r:\\n            total = (l*l + r*r)\\n            if total == c:\\n                return True\\n            elif total > c:\\n                r-=1\\n            else:\\n                l+=1\\n        return False\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n\\t    # If we take two integers a and b and we check if the sum of their squares equals c.\\n\\t\\t# a and b lie within range (0, c**0.5) so we look in this range.\\n        l = 0\\n        r = int(c**0.5) # exponent to get the square root\\n        while l<=r:\\n            total = (l*l + r*r)\\n            if total == c:\\n                return True\\n            elif total > c:\\n                r-=1\\n            else:\\n                l+=1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929909,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func judgeSquareSum(_ c: Int) -> Bool {\\n        if c < 0 { return false }\\n        if c == 0 || c == 1 || c == 2 { return true }\\n        for i in 0...Int(sqrt(Double(c))) {\\n            let val = sqrt(Double(c - i * i))\\n            if val == Double(Int(val)) { return true }\\n        }\\n        return false\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    // 1 * 1 + 2 * 2 = 5\\n    func test0() {\\n        let value = solution.judgeSquareSum(5)\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test1() {\\n        let value = solution.judgeSquareSum(3)\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func judgeSquareSum(_ c: Int) -> Bool {\\n        if c < 0 { return false }\\n        if c == 0 || c == 1 || c == 2 { return true }\\n        for i in 0...Int(sqrt(Double(c))) {\\n            let val = sqrt(Double(c - i * i))\\n            if val == Double(Int(val)) { return true }\\n        }\\n        return false\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    // 1 * 1 + 2 * 2 = 5\\n    func test0() {\\n        let value = solution.judgeSquareSum(5)\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test1() {\\n        let value = solution.judgeSquareSum(3)\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426148,
                "title": "python3-o-n-time-solution",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        if math.sqrt(c) % 1 == 0: # if number is a perfect square\\n            return True\\n        \\n        for a in range(int(math.sqrt(c)) + 1):\\n            b = math.sqrt(c - a**2)\\n            if b % 1 == 0:\\n                return True\\n        return False\\n```\\nPS : Considering the fact that `math.sqrt()` takes O(1) time to calculate the square root of a specified integer, not O(log n).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        if math.sqrt(c) % 1 == 0: # if number is a perfect square\\n            return True\\n        \\n        for a in range(int(math.sqrt(c)) + 1):\\n            b = math.sqrt(c - a**2)\\n            if b % 1 == 0:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425243,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        unordered_map<int,int> m;\\n        for(int i = 0;i <= 46340; i++){\\n            m[(i*i)]++;\\n            if(m.find(c - (i*i))!=m.end())return true;\\n        }\\n        return false;        \\n    }\\n};\\n```\\n**Questions/ Discussions are welcome.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        unordered_map<int,int> m;\\n        for(int i = 0;i <= 46340; i++){\\n            m[(i*i)]++;\\n            if(m.find(c - (i*i))!=m.end())return true;\\n        }\\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950396,
                "title": "two-pointer-solution-in-java",
                "content": "I use two pointer solution in Java\\n```\\npublic static boolean judgeSquareSum(int c) {\\n        int powMax = (int) Math.sqrt(c);\\n        int i = 0;\\n        int j = powMax;\\n        while (i <= j) {\\n            int sum = i * i + j * j;\\n            if (sum == c) {\\n                return true;\\n            } else if (c > sum) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic static boolean judgeSquareSum(int c) {\\n        int powMax = (int) Math.sqrt(c);\\n        int i = 0;\\n        int j = powMax;\\n        while (i <= j) {\\n            int sum = i * i + j * j;\\n            if (sum == c) {\\n                return true;\\n            } else if (c > sum) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536537,
                "title": "python-3-3-easy-solutions-brief-explanation",
                "content": "```\\n## Two bidrectional pointers -- left and right pointers converge to the middle\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        left, right = 0, int(math.sqrt(c))\\n        while left <= right:\\n            if left ** 2 + right ** 2 > c:\\n                right -= 1\\n            elif left ** 2 + right ** 2 < c:\\n                left += 1\\n            else:\\n                return True\\n        return False\\n                \\n## Generated list -- range return a list. Judge whether the result of c minus one square number is also a square number\\nfrom math import sqrt\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        def isSquare(n):\\n            return int(sqrt(n)) ** 2 == n\\n        \\n        return any(isSquare(c-num**2) for num in range(int(sqrt(c))+1))\\n                \\n## Loop -- Same idea as the previous method, during the loop, judging whether existing one more square number\\nfrom math import sqrt\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        if c == 0:\\n            return True\\n        \\n        for i in range(1, int(math.sqrt(c) + 1)):\\n            j = c - i ** 2\\n            if int(math.sqrt(j)) ** 2 == j:\\n                return True\\n        return False\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n## Two bidrectional pointers -- left and right pointers converge to the middle\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        left, right = 0, int(math.sqrt(c))\\n        while left <= right:\\n            if left ** 2 + right ** 2 > c:\\n                right -= 1\\n            elif left ** 2 + right ** 2 < c:\\n                left += 1\\n            else:\\n                return True\\n        return False\\n                \\n## Generated list -- range return a list. Judge whether the result of c minus one square number is also a square number\\nfrom math import sqrt\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        def isSquare(n):\\n            return int(sqrt(n)) ** 2 == n\\n        \\n        return any(isSquare(c-num**2) for num in range(int(sqrt(c))+1))\\n                \\n## Loop -- Same idea as the previous method, during the loop, judging whether existing one more square number\\nfrom math import sqrt\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        if c == 0:\\n            return True\\n        \\n        for i in range(1, int(math.sqrt(c) + 1)):\\n            j = c - i ** 2\\n            if int(math.sqrt(j)) ** 2 == j:\\n                return True\\n        return False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 104938,
                "title": "simple-c-solution",
                "content": "```\\nbool judgeSquareSum(int c) {\\n        int a = 0;\\n        int b = sqrt(c);\\n        \\n        while(a <= b){\\n            \\n            if(a*a + b*b == c)return true;\\n            else if(a*a + b*b > c)b--;\\n            else a++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool judgeSquareSum(int c) {\\n        int a = 0;\\n        int b = sqrt(c);\\n        \\n        while(a <= b){\\n            \\n            if(a*a + b*b == c)return true;\\n            else if(a*a + b*b > c)b--;\\n            else a++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 104948,
                "title": "swift-solution-binary-search-set-two-pointers",
                "content": "```\\nclass Solution {\\n    func judgeSquareSum_BinarySearch(_ c: Int) -> Bool {\\n        let sqrtC = Int(sqrt(Double(c)))\\n        \\n        for i in 0...sqrtC {\\n            var left = i\\n            var right = sqrtC\\n            let middle = (i + sqrtC) / 2\\n            while left <= right {\\n                if i * i + middle * middle == c {\\n                    return true\\n                } else if i * i + middle * middle < c {\\n                    left = middle + 1\\n                } else {\\n                    right = middle - 1\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    func judgeSquareSum_TwoPointer(_ c: Int) -> Bool {\\n        var left = 0\\n        var right = Int(sqrt(Double(c)))\\n        \\n        while left <= right {\\n            let sum = left * left + right * right\\n            if sum == c {\\n                return true\\n            } else if sum < c {\\n                left += 1\\n            } else {\\n                right -= 1\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    func judgeSquareSum_Set(_ c: Int) -> Bool {\\n        var set = Set<Int>()\\n        \\n        for i in 0...Int(sqrt(Double(c))) {\\n            let i2 = i * i\\n            set.insert(i2)\\n            if set.contains(c - i2) {\\n                return true\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Two Pointers",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    func judgeSquareSum_BinarySearch(_ c: Int) -> Bool {\\n        let sqrtC = Int(sqrt(Double(c)))\\n        \\n        for i in 0...sqrtC {\\n            var left = i\\n            var right = sqrtC\\n            let middle = (i + sqrtC) / 2\\n            while left <= right {\\n                if i * i + middle * middle == c {\\n                    return true\\n                } else if i * i + middle * middle < c {\\n                    left = middle + 1\\n                } else {\\n                    right = middle - 1\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    func judgeSquareSum_TwoPointer(_ c: Int) -> Bool {\\n        var left = 0\\n        var right = Int(sqrt(Double(c)))\\n        \\n        while left <= right {\\n            let sum = left * left + right * right\\n            if sum == c {\\n                return true\\n            } else if sum < c {\\n                left += 1\\n            } else {\\n                right -= 1\\n            }\\n        }\\n        \\n        return false\\n    }\\n    \\n    func judgeSquareSum_Set(_ c: Int) -> Bool {\\n        var set = Set<Int>()\\n        \\n        for i in 0...Int(sqrt(Double(c))) {\\n            let i2 = i * i\\n            set.insert(i2)\\n            if set.contains(c - i2) {\\n                return true\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519896,
                "title": "0-ms-two-pointers-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long  first = 0;\\n        long long second = int(sqrt(c));\\n        while(first<=second)\\n        {\\n            long long total = first*first +second*second;\\n            if(total == c)\\n            return true;\\n            else if(total>c)\\n            second--;\\n            else\\n            first++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long  first = 0;\\n        long long second = int(sqrt(c));\\n        while(first<=second)\\n        {\\n            long long total = first*first +second*second;\\n            if(total == c)\\n            return true;\\n            else if(total>c)\\n            second--;\\n            else\\n            first++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474876,
                "title": "very-easy-9-line-java-solution-using-two-pointer-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long l=0,h=(long)Math.sqrt(c);\\n        while(l<=h)\\n        {\\n            if(l*l+h*h==c)\\n                return true;\\n            else if(l*l+h*h<c)\\n                l++;\\n            else\\n                h--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long l=0,h=(long)Math.sqrt(c);\\n        while(l<=h)\\n        {\\n            if(l*l+h*h==c)\\n                return true;\\n            else if(l*l+h*h<c)\\n                l++;\\n            else\\n                h--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261072,
                "title": "c-beats-100-2-pointers-binary-search-easy",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int start = 0 ; \\n        long long int end = sqrt(c) ; \\n\\n        while (start <= end)\\n        {\\n            long long int mul = (start * start) + (end * end) ; \\n\\n            if (mul == c)\\n            {\\n                return true ; \\n            }\\n\\n            else if (mul < c)\\n            {\\n                start ++ ; \\n            }\\n\\n            else if (mul > c)\\n            {\\n                end -- ; \\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/e11f3c98-6a46-4f7f-b63d-7c1d2f583e51_1678035460.8629658.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int start = 0 ; \\n        long long int end = sqrt(c) ; \\n\\n        while (start <= end)\\n        {\\n            long long int mul = (start * start) + (end * end) ; \\n\\n            if (mul == c)\\n            {\\n                return true ; \\n            }\\n\\n            else if (mul < c)\\n            {\\n                start ++ ; \\n            }\\n\\n            else if (mul > c)\\n            {\\n                end -- ; \\n            }\\n        }\\n        return false ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255904,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int square_root(int n)\\n    {\\n        if (n == 1 || n == 0)\\n            return n;\\n        int start = 0;\\n        int end = n;\\n        while (start <= end)\\n        {\\n            long int mid = start + (end - start) / 2;\\n            if (mid * mid == n)\\n                return mid;\\n            else if (mid * mid < n)\\n                start = mid + 1;\\n            else if (mid * mid > n)\\n                end = mid - 1;\\n        }\\n        return end;\\n    }\\n\\n    bool judgeSquareSum(int n) {\\n    long int start = 0;\\n    long int end = square_root(n);\\n    while (start <= end)\\n    {\\n        long int sum = start * start + end * end;\\n        if (sum == n)\\n            return true;\\n        else if (sum > n)\\n            end--;\\n        else if (sum < n)\\n            start++;\\n    }\\n    return false;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int square_root(int n)\\n    {\\n        if (n == 1 || n == 0)\\n            return n;\\n        int start = 0;\\n        int end = n;\\n        while (start <= end)\\n        {\\n            long int mid = start + (end - start) / 2;\\n            if (mid * mid == n)\\n                return mid;\\n            else if (mid * mid < n)\\n                start = mid + 1;\\n            else if (mid * mid > n)\\n                end = mid - 1;\\n        }\\n        return end;\\n    }\\n\\n    bool judgeSquareSum(int n) {\\n    long int start = 0;\\n    long int end = square_root(n);\\n    while (start <= end)\\n    {\\n        long int sum = start * start + end * end;\\n        if (sum == n)\\n            return true;\\n        else if (sum > n)\\n            end--;\\n        else if (sum < n)\\n            start++;\\n    }\\n    return false;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254122,
                "title": "beats100-simple-c-solution-using-fermat-s-theorem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number c has the following form\\n$$ c=2^{e_2}c_0$$\\nwhere $c_0$ is an odd number either $c_0 \\\\equiv 3 \\\\pmod{4}$ or $c_0 \\\\equiv 1 \\\\pmod{4}$ . \\nIf $c_0 \\\\equiv 3 \\\\pmod{4}$, c cannot be a sum of squares.\\nIt needs only to check the odd factors $k$ for $c_0\\\\equiv 1 \\\\pmod{4}$ of the form 4j+3.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[https://www.youtube.com/watch?v=eJQaUffgxzo](https://www.youtube.com/watch?v=eJQaUffgxzo)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if (c<=2) return 1;\\n        while(c% 2==0) c/=2; \\n        if (c%4 ==3) return 0;\\n        double&& sqrt_c=sqrt(c);\\n        for (int k = 3; k<=sqrt_c; k+=4) {\\n            int exp = 0;\\n            if (c % k == 0) {\\n                while (c % k == 0) {\\n                    exp++;\\n                    c /= k;\\n                }\\n                if (exp %2 != 0)\\n                    return 0;\\n            }\\n        }    \\n        return c%4!=3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if (c<=2) return 1;\\n        while(c% 2==0) c/=2; \\n        if (c%4 ==3) return 0;\\n        double&& sqrt_c=sqrt(c);\\n        for (int k = 3; k<=sqrt_c; k+=4) {\\n            int exp = 0;\\n            if (c % k == 0) {\\n                while (c % k == 0) {\\n                    exp++;\\n                    c /= k;\\n                }\\n                if (exp %2 != 0)\\n                    return 0;\\n            }\\n        }    \\n        return c%4!=3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197658,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int a=0,b=sqrt(c);\\n        long long int sqrt=1;\\n        while(a<=b){\\n            sqrt=a*a+b*b;\\n            if(sqrt==c){\\n                return true;\\n            }\\n            else if(sqrt>c){\\n                b--;\\n            }\\n            else{\\n                a++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int a=0,b=sqrt(c);\\n        long long int sqrt=1;\\n        while(a<=b){\\n            sqrt=a*a+b*b;\\n            if(sqrt==c){\\n                return true;\\n            }\\n            else if(sqrt>c){\\n                b--;\\n            }\\n            else{\\n                a++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146630,
                "title": "sum-of-square-numbers",
                "content": "\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        for i in range(int(math.sqrt(c)) + 1):\\n            b = math.sqrt(c - i*i)\\n            if b==int(b):\\n                return True\\n        return False\\n        # l = []\\n        # for i in range(100001):\\n        #     l.append(i**2)\\n        # for i in l:\\n        #     if i>c:\\n        #         return False\\n        #         break\\n        #     for j in l:\\n        #         if i+j==c:\\n        #             return True\\n        #             break\\n        # else:\\n        #     return False                \\n    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        for i in range(int(math.sqrt(c)) + 1):\\n            b = math.sqrt(c - i*i)\\n            if b==int(b):\\n                return True\\n        return False\\n        # l = []\\n        # for i in range(100001):\\n        #     l.append(i**2)\\n        # for i in l:\\n        #     if i>c:\\n        #         return False\\n        #         break\\n        #     for j in l:\\n        #         if i+j==c:\\n        #             return True\\n        #             break\\n        # else:\\n        #     return False                \\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103153,
                "title": "c-solution-easy-to-understand",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Sum of Square Numbers.\\nMemory Usage: 6 MB, less than 10.54% of C++ online submissions for Sum of Square Numbers.\\n\\n\\tclass Solution {\\n\\tpublic:\\n    bool judgeSquareSum(int c) {\\n        long long int left=0,right=sqrt(c);\\n        while(left<=right){\\n            if(left*left+right*right==c)\\n\\t\\t\\t\\treturn true;\\n            else if(left*left+right*right>c)\\n                right--;\\n            else\\n                left++;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool judgeSquareSum(int c) {\\n        long long int left=0,right=sqrt(c);\\n        while(left<=right){\\n            if(left*left+right*right==c)\\n\\t\\t\\t\\treturn true;\\n            else if(left*left+right*right>c)\\n                right--;\\n            else\\n                left++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3075565,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for (int i = 2; i * i <= c; i++) {\\n            int count = 0;\\n            if (c % i == 0) {\\n                while (c % i == 0) {\\n                    count++;\\n                    c /= i;\\n                }\\n                if (i % 4 == 3 && count % 2 != 0)\\n                    return false;\\n            }\\n        }\\n        return c % 4 != 3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for (int i = 2; i * i <= c; i++) {\\n            int count = 0;\\n            if (c % i == 0) {\\n                while (c % i == 0) {\\n                    count++;\\n                    c /= i;\\n                }\\n                if (i % 4 == 3 && count % 2 != 0)\\n                    return false;\\n            }\\n        }\\n        return c % 4 != 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730230,
                "title": "python-two-pointers-easy",
                "content": "```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        # Get the root of the value of C\\n        rootC = int(c ** 0.5)\\n        \\n        # Create two pointers from 0 to the root of C \\n        # (lowest possible value to highest possible value)\\n        low, high = 0, rootC\\n        \\n        # Loop through low and high looking if the lowest value squared \\n        # plus the highest value squared is the desired value. \\n        while low <= high:\\n            result = low ** 2 + high ** 2\\n            \\n            if result == c:\\n                return True\\n            elif result > c:\\n                high -= 1\\n            else:\\n                low += 1\\n                \\n        return False\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        \"\"\"\\n        :type c: int\\n        :rtype: bool\\n        \"\"\"\\n        # Get the root of the value of C\\n        rootC = int(c ** 0.5)\\n        \\n        # Create two pointers from 0 to the root of C \\n        # (lowest possible value to highest possible value)\\n        low, high = 0, rootC\\n        \\n        # Loop through low and high looking if the lowest value squared \\n        # plus the highest value squared is the desired value. \\n        while low <= high:\\n            result = low ** 2 + high ** 2\\n            \\n            if result == c:\\n                return True\\n            elif result > c:\\n                high -= 1\\n            else:\\n                low += 1\\n                \\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 2711765,
                "title": "python-easy-solution-using-binary-search",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l=0\\n        h=int(sqrt(c))\\n        while l<=h:\\n            m=l**2+h**2\\n            if m==c:\\n                return True\\n            elif m>c:\\n                h-=1\\n            else:\\n                l+=1\\n        return False\\n ````",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l=0\\n        h=int(sqrt(c))\\n        while l<=h:\\n            m=l**2+h**2\\n            if m==c:\\n                return True\\n            elif m>c:\\n                h-=1\\n            else:\\n                l+=1\\n        return False\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2688387,
                "title": "python3-solution-two-pointer-o-c",
                "content": "`Time Complexity` : `O(\\u221Ac)`\\n`Time Complexity` : `O(1)`\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c):\\n        l, r = 0, int(c ** 0.5)\\n        while l <= r:\\n            lhs = l*l + r*r\\n            if lhs == c: return True\\n            if lhs < c: l += 1\\n            else: r -= 1\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c):\\n        l, r = 0, int(c ** 0.5)\\n        while l <= r:\\n            lhs = l*l + r*r\\n            if lhs == c: return True\\n            if lhs < c: l += 1\\n            else: r -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686979,
                "title": "c-python-binary-search",
                "content": "# Python\\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        s, e = 0, int(sqrt(c))\\n        while(s <= e):\\n            p = s ** 2 + e ** 2\\n            if p == c: return True\\n            if p < c: s += 1\\n            else: e -= 1\\n        return False\\n```\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int s = 0, e = sqrt(c);\\n        while(s <= e) {\\n            long long p = (long long)s * s + e * e;\\n            if(p == c) return true;\\n            p < c ? s++ : e--;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        s, e = 0, int(sqrt(c))\\n        while(s <= e):\\n            p = s ** 2 + e ** 2\\n            if p == c: return True\\n            if p < c: s += 1\\n            else: e -= 1\\n        return False\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int s = 0, e = sqrt(c);\\n        while(s <= e) {\\n            long long p = (long long)s * s + e * e;\\n            if(p == c) return true;\\n            p < c ? s++ : e--;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632957,
                "title": "explained-solution-java-binarysearch-twopointers-suggestoptimizedsolution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean judgeSquareSum(int c) {\\n\\t\\t\\t//Root of C lies in Between 0 to Sqrt of C ->\\n\\t\\t\\t//So Low -> 0 && High -> Sqrt of C \\n\\t\\t\\tlong start = 0 ;\\n\\t\\t\\tint root = (int)Math.sqrt(c) ;\\n\\t\\t\\tlong end = root ;\\n\\t\\t\\tlong mid = 0 ;\\n\\n\\t\\t\\twhile(start <= end){\\n\\t\\t\\t\\t//Finding the Two Integers that Square up to C ->\\n\\t\\t\\t\\tmid = start*start + end*end ;\\n\\n\\t\\t\\t\\t// If Addn of Sq is == C -> True\\n\\t\\t\\t\\tif(mid == (long)c){\\n\\t\\t\\t\\t\\treturn true ;\\n\\t\\t\\t\\t}  \\n\\t\\t\\t\\t// If Addn of Sq is Greater than C -> End decrement..\\n\\t\\t\\t\\telse if(mid > (long)c){\\n\\t\\t\\t\\t\\tend-- ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start Increment ..\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tstart++ ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false ;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean judgeSquareSum(int c) {\\n\\t\\t\\t//Root of C lies in Between 0 to Sqrt of C ->\\n\\t\\t\\t//So Low -> 0 && High -> Sqrt of C \\n\\t\\t\\tlong start = 0 ;\\n\\t\\t\\tint root = (int)Math.sqrt(c) ;\\n\\t\\t\\tlong end = root ;\\n\\t\\t\\tlong mid = 0 ;\\n\\n\\t\\t\\twhile(start <= end){\\n\\t\\t\\t\\t//Finding the Two Integers that Square up to C ->\\n\\t\\t\\t\\tmid = start*start + end*end ;\\n\\n\\t\\t\\t\\t// If Addn of Sq is == C -> True\\n\\t\\t\\t\\tif(mid == (long)c){\\n\\t\\t\\t\\t\\treturn true ;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2571136,
                "title": "with-explanation-comments-time-4-ms-60-65-space-5-7-mb-89-47",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        \\n        //handle invalid cases\\n        if(c<0)\\n            return false;\\n        \\n        //initialize mainly two pointer-> one on initial value 0 & one on the root of given value\\n        long long left=0, right=sqrt(c);\\n        \\n        //loop while the left pointer is before or on the same position as the right one\\n        while(left<=right){\\n            \\n            //the third pointer mid-> is exactly the sum of the squrares of the two pointers\\n            long long curr=pow(left,2)+pow(right,2);\\n            \\n            //base case: if his value equals the given number-> true\\n            if(curr==c)\\n                return true;\\n            \\n            //case 2: if his value smaller than the given number-> move the left pointer by one forward\\n            else if(curr<c)\\n                left++;\\n            \\n            //case 3: if his value greater than the given number-> move the right pointer by one back\\n            else\\n                right--;\\n        }\\n        \\n        //after that, if there\\'s no valid value-> false\\n        return false;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        \\n        //handle invalid cases\\n        if(c<0)\\n            return false;\\n        \\n        //initialize mainly two pointer-> one on initial value 0 & one on the root of given value\\n        long long left=0, right=sqrt(c);\\n        \\n        //loop while the left pointer is before or on the same position as the right one\\n        while(left<=right){\\n            \\n            //the third pointer mid-> is exactly the sum of the squrares of the two pointers\\n            long long curr=pow(left,2)+pow(right,2);\\n            \\n            //base case: if his value equals the given number-> true\\n            if(curr==c)\\n                return true;\\n            \\n            //case 2: if his value smaller than the given number-> move the left pointer by one forward\\n            else if(curr<c)\\n                left++;\\n            \\n            //case 3: if his value greater than the given number-> move the right pointer by one back\\n            else\\n                right--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2426430,
                "title": "c-common-go-for-binary-search-code",
                "content": "****UPVOTE IF YOU LIKE THE APPROACH :)\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        \\n         long long int  l=0,r=sqrt(c);\\n        while(l<=r){\\n            long long int a=l*l+r*r;\\n            \\n            if(l==r&&a!=c)return false;\\n            \\n            if(a==c)return true;\\n            else if(a>c){\\n                r=sqrt(c-l*l);\\n            }\\n            else{\\n                l=ceil(sqrt(c-r*r));\\n            }   \\n        }\\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        \\n         long long int  l=0,r=sqrt(c);\\n        while(l<=r){\\n            long long int a=l*l+r*r;\\n            \\n            if(l==r&&a!=c)return false;\\n            \\n            if(a==c)return true;\\n            else if(a>c){\\n                r=sqrt(c-l*l);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2237187,
                "title": "python-easy-to-understand-binary-search-with-two-pointer",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l=0\\n        r=int(math.sqrt(c))\\n        while(l<=r):\\n            if (l*l+r*r==c):\\n                return True\\n            elif(l*l+r*r>c):\\n                r-=1\\n            else:\\n                l+=1\\n        return False\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l=0\\n        r=int(math.sqrt(c))\\n        while(l<=r):\\n            if (l*l+r*r==c):\\n                return True\\n            elif(l*l+r*r>c):\\n                r-=1\\n            else:\\n                l+=1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147090,
                "title": "binary-search-c-solution-with-explanation",
                "content": "upvote if u understood...\\n```\\nbool search(int s,int e,int vl)\\n    {\\n        while(s<=e)\\n        {\\n            long long   mid=s+(e-s)/2;\\n            long long temp =(long long )mid*(long long )mid; \\n            if(temp==vl)\\n            {\\n                return true;\\n            }else if(mid*mid>vl){\\n                e=mid-1;\\n            }else{\\n                s=mid+1;\\n            }\\n                \\n        }\\n        return false;\\n    }\\n    bool judgeSquareSum(int c) {\\n        bool ans=false;\\n        for(int i=0;i<=sqrt(c);i++)\\n        {\\n\\t\\t\\t//we have a =i ,so search for b which must be equals to  c-i*i using binary search in (0-c)\\n             ans=search(0,c,c-i*i);\\n            if(ans) return true;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nbool search(int s,int e,int vl)\\n    {\\n        while(s<=e)\\n        {\\n            long long   mid=s+(e-s)/2;\\n            long long temp =(long long )mid*(long long )mid; \\n            if(temp==vl)\\n            {\\n                return true;\\n            }else if(mid*mid>vl){\\n                e=mid-1;\\n            }else{\\n                s=mid+1;\\n            }\\n                \\n        }\\n        return false;\\n    }\\n    bool judgeSquareSum(int c) {\\n        bool ans=false;\\n        for(int i=0;i<=sqrt(c);i++)\\n        {\\n\\t\\t\\t//we have a =i ,so search for b which must be equals to  c-i*i using binary search in (0-c)\\n             ans=search(0,c,c-i*i);\\n            if(ans) return true;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2131029,
                "title": "fastest-solution-in-c-o-root-n",
                "content": "Time Complexity - O(root N)\\n\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int i,k,j;\\n        for(i=0;i<46340 && i*i<=c;i++){\\n            k=(int)Math.sqrt((double)(c-i*i));\\n            if(k*k==(c-i*i))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int i,k,j;\\n        for(i=0;i<46340 && i*i<=c;i++){\\n            k=(int)Math.sqrt((double)(c-i*i));\\n            if(k*k==(c-i*i))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118632,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long i=0,j=(int)Math.sqrt(c);\\n        while(i<=j)\\n        {\\n            long s=i*i+j*j;\\n            if(s<c)\\n                i++;\\n            else if(s>c)\\n                j--;\\n            else\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long i=0,j=(int)Math.sqrt(c);\\n        while(i<=j)\\n        {\\n            long s=i*i+j*j;\\n            if(s<c)\\n                i++;\\n            else if(s>c)\\n                j--;\\n            else\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2101079,
                "title": "java-three-approch-binary-search-math-sqrt-and-two-pointer",
                "content": "(1) Binary Search\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c;i++){\\n            int target=c-(int)(i*i);\\n            if(bs(target)) return true;\\n        }\\n        return false;\\n    }\\n    public static boolean bs(int target){\\n        long start=0;\\n        long end=target;\\n        while(start<=end){\\n            long mid=start+(end-start)/2;\\n            if(mid*mid==target) return true;\\n            if(mid*mid>target) end=mid-1;\\n            else start=mid+1;\\n       }\\n       return false;\\n    }\\n}\\n```\\n\\n(2) Using Math.sqrt()\\n\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n         for(long i=0;i*i<=c;i++){\\n             if(Math.floor(Math.sqrt(c-(i*i)))==Math.sqrt(c-(i*i))) return true;\\n         }\\n        return false;\\n    }\\n}\\n```\\n\\n(3) Two-Pointers(96% faster)\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long start=0;\\n        long end=(long)Math.sqrt(c);\\n        while(start<=end){\\n             long sum=start*start+end*end;\\n             if(sum==c) return true;\\n             else if(sum>c) end--;\\n             else start++;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c;i++){\\n            int target=c-(int)(i*i);\\n            if(bs(target)) return true;\\n        }\\n        return false;\\n    }\\n    public static boolean bs(int target){\\n        long start=0;\\n        long end=target;\\n        while(start<=end){\\n            long mid=start+(end-start)/2;\\n            if(mid*mid==target) return true;\\n            if(mid*mid>target) end=mid-1;\\n            else start=mid+1;\\n       }\\n       return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n         for(long i=0;i*i<=c;i++){\\n             if(Math.floor(Math.sqrt(c-(i*i)))==Math.sqrt(c-(i*i))) return true;\\n         }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036938,
                "title": "c-math-trick-100-faster-easy-understanding",
                "content": "consider two numbers a , b\\nc = a * a + b * b;\\nb = sqrt(c - a*a)\\nif a=0, b is sqrt(c). i.e b will at max reach to sqrt(c)\\n\\n```\\n bool judgeSquareSum(int c) {\\n        unsigned long long a =0, b = sqrt(c);\\n        while(a <= b) {\\n            unsigned long long prod =  a*a + b*b;\\n            if(prod == c) {\\n                return true;\\n            }else if( prod < c){\\n                a++;\\n            }else {\\n                b--;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool judgeSquareSum(int c) {\\n        unsigned long long a =0, b = sqrt(c);\\n        while(a <= b) {\\n            unsigned long long prod =  a*a + b*b;\\n            if(prod == c) {\\n                return true;\\n            }else if( prod < c){\\n                a++;\\n            }else {\\n                b--;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018321,
                "title": "100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int sr=sqrt(c);\\n        if(sr*sr==c)return 1;\\n        \\n        unsigned long long r=sqrt(c);\\n        \\n        unsigned long long l=1;\\n        \\n        while( l<=r){\\n          unsigned long long val= l*l+r*r;\\n            if(val==c)return 1;\\n            \\n            if(val>c){\\n                r-=1;\\n            }\\n            \\n            else{ \\n                l+=1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int sr=sqrt(c);\\n        if(sr*sr==c)return 1;\\n        \\n        unsigned long long r=sqrt(c);\\n        \\n        unsigned long long l=1;\\n        \\n        while( l<=r){\\n          unsigned long long val= l*l+r*r;\\n            if(val==c)return 1;\\n            \\n            if(val>c){\\n                r-=1;\\n            }\\n            \\n            else{ \\n                l+=1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879742,
                "title": "c-easy-solution-100",
                "content": "```\\nbool judgeSquareSum(int c) {\\n        if ( !c ) return true;\\n        for( long i = 0 ; i * i < c ; i++ )\\n        {\\n            long b = sqrt(c - i*i );\\n            if( b * b + i * i == c ) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nbool judgeSquareSum(int c) {\\n        if ( !c ) return true;\\n        for( long i = 0 ; i * i < c ; i++ )\\n        {\\n            long b = sqrt(c - i*i );\\n            if( b * b + i * i == c ) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1706543,
                "title": "c-math-two-pointers-o-sqrt-c-explaination",
                "content": "**a and b will be less than or equal to sqaure root of c. Therefore we can easily apply two pointers as we applied in two sum using left pointer to be 0 and right pointer to be sqrt(c).**\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int l=0,r=sqrt(c);\\n        while(l<=r){\\n            long long val=(long long)l*l+(long long)r*r;\\n            if(val==c){\\n                return true;\\n            }\\n            \\n            if(val>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n**Another Solution using sqrt function. As we know our answer means a and b will be in range of sqrt(c) if they are possible so we will iterate from i=0 to i=sqrt(c) and check there exists a b*b = c - a*a means if there is a b whose sqaure is c-i*i we will return true. **\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int l=0,r=sqrt(c);\\n        for(int i=0;i<=r;i++){\\n            int num=c-i*i;\\n            double n=sqrt(num);\\n            if(floor(n)==ceil(n)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int l=0,r=sqrt(c);\\n        while(l<=r){\\n            long long val=(long long)l*l+(long long)r*r;\\n            if(val==c){\\n                return true;\\n            }\\n            \\n            if(val>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int l=0,r=sqrt(c);\\n        for(int i=0;i<=r;i++){\\n            int num=c-i*i;\\n            double n=sqrt(num);\\n            if(floor(n)==ceil(n)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525786,
                "title": "simple-c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    #define lli long long int   //using this to avoid integer overflow\\n    bool judgeSquareSum(int c) {\\n       unordered_map<lli,lli>mp;\\n        for(lli i{0};i*i<=c;i++){\\n            mp[i*i]=i;\\n        }\\n        for(auto it:mp){\\n            lli first_num=it.first;\\n            lli sec_num=c-it.first;\\n            if(mp.find(sec_num)!=mp.end()){\\n               return true; \\n            }\\n        }\\n      return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define lli long long int   //using this to avoid integer overflow\\n    bool judgeSquareSum(int c) {\\n       unordered_map<lli,lli>mp;\\n        for(lli i{0};i*i<=c;i++){\\n            mp[i*i]=i;\\n        }\\n        for(auto it:mp){\\n            lli first_num=it.first;\\n            lli sec_num=c-it.first;\\n            if(mp.find(sec_num)!=mp.end()){\\n               return true; \\n            }\\n        }\\n      return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496425,
                "title": "c-easy-to-understand-two-pointers-beats-100",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        //using two pointers \\n        if(c < 3) return true;\\n        \\n\\t\\t//use long int to avoid integer overflow\\n        long int st=0,end=sqrt(c),sqsum;\\n        \\n        while(st <= end){\\n            sqsum = st*st + end*end;\\n            \\n            if(sqsum == c) return true;\\n            \\n            else if(sqsum > c) end--;\\n            \\n            else st++;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'\\nPlease upvote, if you find it helpful :)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        //using two pointers \\n        if(c < 3) return true;\\n        \\n\\t\\t//use long int to avoid integer overflow\\n        long int st=0,end=sqrt(c),sqsum;\\n        \\n        while(st <= end){\\n            sqsum = st*st + end*end;\\n            \\n            if(sqsum == c) return true;\\n            \\n            else if(sqsum > c) end--;\\n            \\n            else st++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1463834,
                "title": "sum-of-square-numbers",
                "content": "\\n\\n    bool judgeSquareSum(int c) {\\n        long a=0,b=sqrt(c);\\n        while(a<=b){\\n            if(a*a+b*b<c) a++;\\n            else if(a*a+b*b>c) b--;\\n            else return true;\\n        }\\n        return false ;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n    bool judgeSquareSum(int c) {\\n        long a=0,b=sqrt(c);\\n        while(a<=b){\\n            if(a*a+b*b<c) a++;\\n            else if(a*a+b*b>c) b--;\\n            else return true;\\n        }\\n        return false ;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1428076,
                "title": "swift-readable-solution-binary-search",
                "content": "```\\nclass Solution {\\n    func judgeSquareSum(_ c: Int) -> Bool {\\n        var low = 0\\n        var high = Int(Double(c).squareRoot())\\n\\n        while low <= high {\\n            let guess = low * low + high * high\\n            if guess < c {\\n                low += 1\\n            } else if guess > c {\\n                high -= 1\\n            } else {\\n                return true\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    func judgeSquareSum(_ c: Int) -> Bool {\\n        var low = 0\\n        var high = Int(Double(c).squareRoot())\\n\\n        while low <= high {\\n            let guess = low * low + high * high\\n            if guess < c {\\n                low += 1\\n            } else if guess > c {\\n                high -= 1\\n            } else {\\n                return true\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427829,
                "title": "easy-2-pointers-java",
                "content": "Upvote if you like the solution :)\\n\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if (c==0) return true;\\n        int l=0, r=(int) Math.sqrt(c);\\n        while (l<=r){\\n            int res=l*l+r*r;\\n            if (res<c) l++;\\n            else if (res>c) r--;\\n            else return true;\\n        }\\n        return false;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if (c==0) return true;\\n        int l=0, r=(int) Math.sqrt(c);\\n        while (l<=r){\\n            int res=l*l+r*r;\\n            if (res<c) l++;\\n            else if (res>c) r--;\\n            else return true;\\n        }\\n        return false;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426566,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c):\\n        values=[]\\n        for i in range(0,c+1):\\n            if i**2<=c:\\n                values.append(i**2)\\n            else:\\n                break\\n        values=values+values\\n        s=set()\\n        for i in range(0,len(values)):\\n            temp=c-values[i]\\n            if temp in s:\\n                return True\\n            s.add(values[i])\\n        \\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c):\\n        values=[]\\n        for i in range(0,c+1):\\n            if i**2<=c:\\n                values.append(i**2)\\n            else:\\n                break\\n        values=values+values\\n        s=set()\\n        for i in range(0,len(values)):\\n            temp=c-values[i]\\n            if temp in s:\\n                return True\\n            s.add(values[i])\\n        \\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426098,
                "title": "easy-solution-c-o-n-complextiy-5-line-code",
                "content": "\\n```\\n    bool judgeSquareSum(int c) {\\n        int n= sqrt(c),x,y;\\n        for(int i=0;i<=n;i++){\\n                x=c-i*i;\\n                y=sqrt(x);\\n                if(y*y==x)return true;\\n        }\\n        return false;\\n  }\\n```\\n**Please upvote and support if you liked or understood the explantion and code .**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool judgeSquareSum(int c) {\\n        int n= sqrt(c),x,y;\\n        for(int i=0;i<=n;i++){\\n                x=c-i*i;\\n                y=sqrt(x);\\n                if(y*y==x)return true;\\n        }\\n        return false;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1425865,
                "title": "python-easy-to-understand-two-pointer-solution",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l,r=0,math.floor(c**.5)\\n        while l<=r:\\n            if l**2+r**2==c:\\n                return True\\n            elif l**2+r**2<c:\\n                l+=1\\n            else:\\n                r-=1\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l,r=0,math.floor(c**.5)\\n        while l<=r:\\n            if l**2+r**2==c:\\n                return True\\n            elif l**2+r**2<c:\\n                l+=1\\n            else:\\n                r-=1\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425466,
                "title": "0-ms-faster-than-100-simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int p=0,q=sqrt(c);unsigned long int t=0;\\n        while(p<=q)\\n        {\\n            if(q*q > numeric_limits<int>::max() - p*p)\\n                return false;\\n            t=p*p + q*q;\\n            \\n            if(t==c)\\n                return true;\\n            if(t<c)\\n                p++;\\n            else\\n                q--;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        int p=0,q=sqrt(c);unsigned long int t=0;\\n        while(p<=q)\\n        {\\n            if(q*q > numeric_limits<int>::max() - p*p)\\n                return false;\\n            t=p*p + q*q;\\n            \\n            if(t==c)\\n                return true;\\n            if(t<c)\\n                p++;\\n            else\\n                q--;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425199,
                "title": "java-python3-solution-using-2-pointer-technique",
                "content": "so it is given that c is an integer lets us try to predict the maxima of variable a interms of c\\n\\nso  a=sqrt(c-b*b)\\n\\nthe value of a will be maximum if b==0;\\n\\nso the max value of a is sqrt(c)\\n\\nso let us think of 2 pointer technique we will assign left pointer at starting index and right pointer at sqrt(c)\\n\\nand will find the left*left+right*right if this is equal c then we return true.\\nbut if it is greater than c then we decrease the right pointer as right pointer is at atmost position \\n\\nthe same way if it is less than c then will increase left\\n\\nbut the termination is left<=right\\n\\nleft =right because there may be condition that a,b are equal (ex:-2=1*1+1*1)\\n\\n**code**\\n**PYTHON 3**\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        left = 0\\n        right = int(sqrt(c))\\n        while left <= right:\\n            ans = left * left + right * right\\n            if ans == c: return True\\n            if ans < c:\\n                left += 1\\n            else:\\n                right -= 1\\n        return False\\n\\n```\\n\\n**JAVA**\\n```\\nclass Solution {\\n    \\n    \\n    \\n    public boolean judgeSquareSum(int c) {\\n        \\n        \\n        int left=0;\\n        int right=(int)Math.sqrt(c);\\n        System.out.println(right);\\n        while(left<=right){\\n            \\n            double ans=left*left+right*right;\\n            \\n            if(ans==c){\\n                return true;\\n            }\\n            if(ans<c){\\n                left++;\\n            }\\n            if(ans>c){\\n                right--;\\n            }\\n            \\n            \\n        }\\n        return false;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        left = 0\\n        right = int(sqrt(c))\\n        while left <= right:\\n            ans = left * left + right * right\\n            if ans == c: return True\\n            if ans < c:\\n                left += 1\\n            else:\\n                right -= 1\\n        return False\\n\\n```\n```\\nclass Solution {\\n    \\n    \\n    \\n    public boolean judgeSquareSum(int c) {\\n        \\n        \\n        int left=0;\\n        int right=(int)Math.sqrt(c);\\n        System.out.println(right);\\n        while(left<=right){\\n            \\n            double ans=left*left+right*right;\\n            \\n            if(ans==c){\\n                return true;\\n            }\\n            if(ans<c){\\n                left++;\\n            }\\n            if(ans>c){\\n                right--;\\n            }\\n            \\n            \\n        }\\n        return false;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424987,
                "title": "c-solution-using-fermat-theorem-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for (int i = 2 ; i * i <= c ; i++){\\n            int cnt = 0;\\n            if (c % i == 0){\\n                while(c % i == 0){\\n                    cnt ++;\\n                    c /= i;\\n                }\\n                if (i % 4 == 3 && cnt % 2 != 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return c % 4 != 3;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for (int i = 2 ; i * i <= c ; i++){\\n            int cnt = 0;\\n            if (c % i == 0){\\n                while(c % i == 0){\\n                    cnt ++;\\n                    c /= i;\\n                }\\n                if (i % 4 == 3 && cnt % 2 != 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return c % 4 != 3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371137,
                "title": "python-using-binary-search",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        def binary_search(start,end,num):\\n            mid = (start+end)//2\\n            if start > end:\\n                return False\\n            if (mid*mid) == num:\\n                return True\\n            elif (mid*mid) > num:\\n                return binary_search(start, mid-1, num)\\n            elif (mid*mid) < num:\\n                return binary_search(mid+1, end, num)\\n        a = 0\\n        while (a*a) <= c:\\n            b = c - int(a*a)\\n            if binary_search(0,b,b):\\n                return True\\n            a += 1\\n        return False\\n```\\n```\\n#simple code of above approach\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        if c == 0:\\n            return True\\n        for i in range(0, int((c**0.5)+1)):\\n            start = 0\\n            end = c\\n            mid = 0\\n            while end >= start:\\n                mid = (start+end)//2\\n                if (mid*mid) > (c - i**2):\\n                    end = mid -1\\n                elif (mid*mid) < (c - i**2):\\n                    start = mid + 1\\n                elif (mid*mid) == (c - i**2):\\n                    return True\\n        return False\\n\\t\\t#upvote if you find it useful\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        def binary_search(start,end,num):\\n            mid = (start+end)//2\\n            if start > end:\\n                return False\\n            if (mid*mid) == num:\\n                return True\\n            elif (mid*mid) > num:\\n                return binary_search(start, mid-1, num)\\n            elif (mid*mid) < num:\\n                return binary_search(mid+1, end, num)\\n        a = 0\\n        while (a*a) <= c:\\n            b = c - int(a*a)\\n            if binary_search(0,b,b):\\n                return True\\n            a += 1\\n        return False\\n```\n```\\n#simple code of above approach\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        if c == 0:\\n            return True\\n        for i in range(0, int((c**0.5)+1)):\\n            start = 0\\n            end = c\\n            mid = 0\\n            while end >= start:\\n                mid = (start+end)//2\\n                if (mid*mid) > (c - i**2):\\n                    end = mid -1\\n                elif (mid*mid) < (c - i**2):\\n                    start = mid + 1\\n                elif (mid*mid) == (c - i**2):\\n                    return True\\n        return False\\n\\t\\t#upvote if you find it useful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351577,
                "title": "twopointers-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int i = 0, j = (int)sqrt(c);\\n        while(i<=j){\\n            long long int temp = (i*i +j*j) ;\\n            if(temp ==c){\\n                return true;\\n            }else if(temp<c){\\n                i++;\\n            }else{\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int i = 0, j = (int)sqrt(c);\\n        while(i<=j){\\n            long long int temp = (i*i +j*j) ;\\n            if(temp ==c){\\n                return true;\\n            }else if(temp<c){\\n                i++;\\n            }else{\\n                j--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288206,
                "title": "one-liner-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(long i = 0; i*i <= c; i++) {\\n            double n = sqrt(c - i*i);\\n            if(ceil(n)==floor(n)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\nBe careful with data types and c = 0 case.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(long i = 0; i*i <= c; i++) {\\n            double n = sqrt(c - i*i);\\n            if(ceil(n)==floor(n)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199027,
                "title": "c-simple-solution-faster-than-00-eg",
                "content": "class Solution {\\npublic:\\n\\n    bool judgeSquareSum(int c) {\\n        long long left = 0 ;\\n        long long right = sqrt(c) ;\\n        while (left<=right){\\n            if ((left*left)+(right*right)==c)\\n                return true; \\n            else if ((left*left)+(right*right)>c)\\n                right-- ;\\n            else \\n                left++ ;\\n        }\\n        // this algo is O(sqrt(c)) time , constant time space O(1) ;\\n        return false ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool judgeSquareSum(int c) {\\n        long long left = 0 ;\\n        long long right = sqrt(c) ;\\n        while (left<=right){\\n            if ((left*left)+(right*right)==c)\\n                return true; \\n            else if ((left*left)+(right*right)>c)\\n                right-- ;\\n            else \\n                left++ ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1155238,
                "title": "python-see-if-c-a-2-is-a-square",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        \\n        for a in range(int(c**(1/2)+1)):\\n            \\n            b = (c - a**2)**(1/2)\\n            \\n            if int(b) == b:\\n                return True\\n            \\n        return False\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        \\n        for a in range(int(c**(1/2)+1)):\\n            \\n            b = (c - a**2)**(1/2)\\n            \\n            if int(b) == b:\\n                return True\\n            \\n        return False\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 877459,
                "title": "python-fermat-s-sum-of-2-squares-theorem-beats-100",
                "content": "**idea:** [sum of two squares theorem](https://en.wikipedia.org/wiki/Sum_of_two_squares_theorem)\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        i=2\\n        while i*i<=c:\\n            k=0\\n            while c%i==0:\\n                c//=i\\n                k+=1\\n            if i%4==3 and k%2==1:\\n                return False\\n            i+=1\\n        if c%4==3:\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        i=2\\n        while i*i<=c:\\n            k=0\\n            while c%i==0:\\n                c//=i\\n                k+=1\\n            if i%4==3 and k%2==1:\\n                return False\\n            i+=1\\n        if c%4==3:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810342,
                "title": "javascript-easy-to-understand",
                "content": "```\\nvar judgeSquareSum = function(c) {\\n    for (let a = 0; a * a <=c; a++) {\\n        const b = Math.sqrt(c - a*a);\\n        if (Math.floor(b) === b) return true;\\n    }\\n    return false;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar judgeSquareSum = function(c) {\\n    for (let a = 0; a * a <=c; a++) {\\n        const b = Math.sqrt(c - a*a);\\n        if (Math.floor(b) === b) return true;\\n    }\\n    return false;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 680867,
                "title": "c-binary-search-solution",
                "content": "```\\nbool judgeSquareSum(int c) {\\n\\tint start = 0, end = sqrt(c);\\n\\twhile (start <= end) {\\n\\t\\tint res = c - start * start;\\n\\t\\tif (res == end * end)\\n\\t\\t\\treturn true;\\n\\t\\telse if (res < end * end)\\n\\t\\t\\tend--;\\n\\t\\telse\\n\\t\\t\\tstart++;\\n\\t}\\n\\treturn false;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool judgeSquareSum(int c) {\\n\\tint start = 0, end = sqrt(c);\\n\\twhile (start <= end) {\\n\\t\\tint res = c - start * start;\\n\\t\\tif (res == end * end)\\n\\t\\t\\treturn true;\\n\\t\\telse if (res < end * end)\\n\\t\\t\\tend--;\\n\\t\\telse\\n\\t\\t\\tstart++;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 620027,
                "title": "using-the-sum-of-squares-theorem-in-python",
                "content": "Using the Sum of Squares Theorem\\n https://en.wikipedia.org/wiki/Sum_of_two_squares_theorem\\n ```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        i=2\\n        while i*i < c:\\n            count = 0\\n            if c%i == 0:\\n                #count the power of prime factor i(i will always be a prime number)\\n                while c%i == 0:\\n                    count+=1\\n                    c = c//i\\n                if i%4 == 3 and count%2!=0:\\n                    return False\\n            i+=1\\n        return c%4!=3\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        i=2\\n        while i*i < c:\\n            count = 0\\n            if c%i == 0:\\n                #count the power of prime factor i(i will always be a prime number)\\n                while c%i == 0:\\n                    count+=1\\n                    c = c//i\\n                if i%4 == 3 and count%2!=0:\\n                    return False\\n            i+=1\\n        return c%4!=3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545632,
                "title": "python-two-pointers-solution-easy-understanding",
                "content": "\\'\\'\\'\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        low = 0\\n        high = int(math.sqrt(c))\\n        while low <= high:\\n            sum = low**2 + high**2\\n            if sum < c:\\n                low += 1\\n            if sum > c:\\n                high -= 1\\n            if sum == c:\\n                return True\\n        return False\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        low = 0\\n        high = int(math.sqrt(c))\\n        while low <= high:\\n            sum = low**2 + high**2\\n            if sum < c:\\n                low += 1\\n            if sum > c:\\n                high -= 1\\n            if sum == c:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499496,
                "title": "python-two-pointer",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        a = 0\\n        b = int(math.sqrt(c))\\n        while a<=b:\\n            squaresum = a*a + b*b\\n            if squaresum == c:\\n                return True\\n            elif squaresum < c:\\n                a += 1\\n            else:\\n                b -= 1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        a = 0\\n        b = int(math.sqrt(c))\\n        while a<=b:\\n            squaresum = a*a + b*b\\n            if squaresum == c:\\n                return True\\n            elif squaresum < c:\\n                a += 1\\n            else:\\n                b -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478164,
                "title": "java-two-pointer-solution",
                "content": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int a = 0;\\n        int b = (int)Math.sqrt(c);\\n        while(a<=b){\\n            if(a*a+b*b == c){\\n                return true;\\n            }\\n            else if(a*a+b*b > c){\\n                b--;\\n            }else{\\n                a++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int a = 0;\\n        int b = (int)Math.sqrt(c);\\n        while(a<=b){\\n            if(a*a+b*b == c){\\n                return true;\\n            }\\n            else if(a*a+b*b > c){\\n                b--;\\n            }else{\\n                a++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474728,
                "title": "python-97-time-100-memory-o-sqrt-n-time",
                "content": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n\\n        l = 0\\n        r = int(c ** 0.5)\\n        while l <= r:\\n            test = l * l + r * r\\n            if test < c:\\n                l += 1\\n            elif test > c:\\n                r -= 1\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n\\n        l = 0\\n        r = int(c ** 0.5)\\n        while l <= r:\\n            test = l * l + r * r\\n            if test < c:\\n                l += 1\\n            elif test > c:\\n                r -= 1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386379,
                "title": "easy-c-solutions-0ms-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Sum of Square Numbers.\\nMemory Usage: 8 MB, less than 100.00% of C++ online submissions for Sum of Square Numbers.\\n\\n```\\nbool judgeSquareSum(int c) {\\n        \\n        if(c == 0)\\n            return true;\\n        \\n        for(int i = 0; i <= sqrt(c/2); i++)\\n        {\\n            if(i*i +  pow(floor(sqrt(c-i*i)),2) == c)\\n                return true;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Sum of Square Numbers.\\nMemory Usage: 8 MB, less than 100.00% of C++ online submissions for Sum of Square Numbers.\\n\\n```\\nbool judgeSquareSum(int c) {\\n        \\n        if(c == 0)\\n            return true;\\n        \\n        for(int i = 0; i <= sqrt(c/2); i++)\\n        {\\n            if(i*i +  pow(floor(sqrt(c-i*i)),2) == c)\\n                return true;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 148516,
                "title": "java-2-pointer-beats-96",
                "content": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c == 0 || c == 1 || c==2) return true;\\n        int sqrt = (int)Math.sqrt(c);\\n        int square = sqrt * sqrt;\\n        int left = square;\\n        int right = c - square;\\n        while(left >= right) {\\n            if(isPerfectSquare(left) && isPerfectSquare(right)) return true;\\n            else {\\n                sqrt--;\\n                square = sqrt * sqrt;\\n                left = square;\\n                right = c - square;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    \\n    private boolean isPerfectSquare(int val) {\\n        return Math.pow((int)Math.sqrt(val), 2) == val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c == 0 || c == 1 || c==2) return true;\\n        int sqrt = (int)Math.sqrt(c);\\n        int square = sqrt * sqrt;\\n        int left = square;\\n        int right = c - square;\\n        while(left >= right) {\\n            if(isPerfectSquare(left) && isPerfectSquare(right)) return true;\\n            else {\\n                sqrt--;\\n                square = sqrt * sqrt;\\n                left = square;\\n                right = c - square;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    \\n    private boolean isPerfectSquare(int val) {\\n        return Math.pow((int)Math.sqrt(val), 2) == val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124127,
                "title": "why-i-i-c-is-tle-but-int-math-sqrt-c-is-ac",
                "content": "why i*i<c is TLE  but (int)Math.sqrt(\\'c\\') is AC? I would very much appreciate anyone who can spend a bit of his time to explain it.\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c<=1)return true;\\n       for(int i=0;i*i<=c;i++){\\n           if(Math.pow((int)Math.sqrt(c-i*i),2)==c-i*i)\\n           return true;\\n           \\n       }\\n        return false;\\n        \\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c<=1)return true;\\n       for(int i=0;i<=(int)Math.sqrt(c);i++){\\n           if(Math.pow((int)Math.sqrt(c-i*i),2)==c-i*i)\\n           return true;\\n           \\n       }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c<=1)return true;\\n       for(int i=0;i*i<=c;i++){\\n           if(Math.pow((int)Math.sqrt(c-i*i),2)==c-i*i)\\n           return true;\\n           \\n       }\\n        return false;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c<=1)return true;\\n       for(int i=0;i<=(int)Math.sqrt(c);i++){\\n           if(Math.pow((int)Math.sqrt(c-i*i),2)==c-i*i)\\n           return true;\\n           \\n       }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104952,
                "title": "easy-python-solution-sum-of-two",
                "content": "The idea is to use two pointers scanning the `sqrt(c)` length, one from the beginning, the other from the end.\\n```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        n=int(math.sqrt(c))\\n        i,j=0,n\\n        while i<=j:\\n            res=i*i+j*j\\n            if res==c:\\n                return True\\n            elif res>c:\\n                j-=1\\n            else:\\n                i+=1\\n        return False\\n#124 / 124 test cases passed.\\n#Status: Accepted\\n#Runtime: 139 ms\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def judgeSquareSum(self, c):\\n        n=int(math.sqrt(c))\\n        i,j=0,n\\n        while i<=j:\\n            res=i*i+j*j\\n            if res==c:\\n                return True\\n            elif res>c:\\n                j-=1\\n            else:\\n                i+=1\\n        return False\\n#124 / 124 test cases passed.\\n#Status: Accepted\\n#Runtime: 139 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039915,
                "title": "beats-100-of-the-user-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nit is very basic approach\\n\\n made by me using similar to \\nbinary searching\\nwe make a low val =1 \\nand hign value to sqrt to the number c we not need to treverse to till c \\n\\nif we get the number less than the c(that is given numaber)\\nwe just have to low ++update the low value\\n\\nelse if(we get lesser value )\\nwe update the lower value to low++\\n\\nalso we take the number low and high as long long int  date type for large value \\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n      long long int l=0 ,h=sqrt(c);\\n      while(l<=h){\\n        if((l*l + h*h) ==c ||l*l==c || h*h==c ){\\n          return true;\\n        }\\n        else if((l*l + h*h) <c){\\n          l++;\\n        }\\n        else {\\n          h--;\\n        }\\n      }\\n      return false;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n      long long int l=0 ,h=sqrt(c);\\n      while(l<=h){\\n        if((l*l + h*h) ==c ||l*l==c || h*h==c ){\\n          return true;\\n        }\\n        else if((l*l + h*h) <c){\\n          l++;\\n        }\\n        else {\\n          h--;\\n        }\\n      }\\n      return false;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017183,
                "title": "clean-and-intuitive-java-code-math-explained-binary-search-two-pointers-self-explanatory",
                "content": "# Code\\n\\n```\\n/*\\n\\n    Maths Explaination :\\n\\n    a^2 + b^2 =c;\\n   \\n    Possible values of a =0,1,2,3,4,5,6...... (Even if you take -ve values of \\'a\\' the a^2 will remain the same)\\n    i.e Possible values of a^2 =0,1,4,9,16,25,36......\\n                            \\n    Similarly;\\n\\n    Possible values of b =0,1,2,3,4,5,6......(Even if you take -ve values of \\'b\\' the b^2 will remain the same)\\n    i.e Possible values of b^2 =0,1,4,9,16,25,36......\\n    \\n    if you observe Carefully all these possible values of a^2 and b^2 are perfect Squares.(an we already know how to check  perfect Squares).\\n    \\n    How to derieve Condition?\\n    \\n    minimum possible value of b^2=0;\\n    which gives maximum possible value of a^2 i.e a^2 =c;\\n    \\n    thus generalised (while loop)condition is a^2<=c or a<=Math.sqrt(c);\\n    \\n    Or\\n\\n    minimum possible value of a^2=0;\\n    which gives maximum possible value of b^2 i.e b^2 =c;\\n    \\n    thus generalised (while loop)condition is  : b^2<=c or b<=Math.sqrt(c);\\n   \\n    Conclusion :\\n    minimum possible value of a =0\\n    minimum possible value of b =0\\n    maximum possible value of a =Math.sqrt(c);\\n    maximum possible value of b =Math.sqrt(c);\\n\\n*/\\n```\\n\\n```\\n\\n// Method 1 - Using Binary Search\\n\\n/* Intuitive Implementation :\\n\\nHow To Efficiently Find Next perfect square ?\\n\\nThe very first perfect square is important for this method. Now the original answer is hidden over this pattern i.e. 0, 1, 4, 9, 16, 25, 36, 49, 64,..... \\nthe difference between 0 and 1 is 1 \\nthe difference between 1 and 4 is 3 \\nthe difference between 4 and 9 is 5 and so on\\u2026 \\nwhich means that the difference between two perfect squares is always an odd number.\\nNow, the question arises what must be added to get the next number and the answer is (sqrt(X) * 2) + 1 where X is the already known perfect square.\\n\\n*/\\n\\n\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n      int aSqr=0; //0 is the First perfect Square Number\\n\\n      while(aSqr<=c)\\n      {\\n        if(isPerfectSquare(c-aSqr)) //b^2=(c-a^2);check if b^2 is perfect square or not\\n          return true;\\n\\t  \\n        aSqr=nextPerfectSquareNumber(aSqr);\\n      }\\n      return false; \\n    }\\n\\n    public boolean isPerfectSquare(int num)\\n    {\\n       if(mySqrt(num)!=-1)\\n         return true;\\n         \\n       return false;\\n    }\\n    \\n    public int mySqrt(int x)\\n    {\\n      int low =0,high=x;\\n      while(low<=high)\\n      {\\n        long mid=low+(high-low)/2;\\n\\n        if(x==(mid*mid))\\n           return (int)mid;\\n        else if(x>(mid*mid))\\n          low=(int)mid+1;\\n        else//if(x<(mid*mid))\\n          high=(int)mid-1;\\n      }\\n      return -1;\\n    }\\n    \\n    public int nextPerfectSquareNumber(int num)\\n    {\\n      int next=num+(mySqrt(num)*2)+1;\\n      return next;\\n    }\\n}\\n\\n\\n\\n//Optimal Implementation\\n\\nclass Solution {\\n    public boolean judgeSquareSum(int c){\\n      int sqrt_c=(int)Math.sqrt(c);\\n      for(int a=0;a<=sqrt_c;a++)\\n        if(isPerfectSquare(c-a*a))  //b^2=(c-a^2),check if b^2 is perfect square or not\\n          return true;\\n        \\n       return false;\\n    }\\n    \\n    public boolean isPerfectSquare(int num)\\n    {\\n       return mySqrt(num);\\n    }\\n    \\n    public boolean mySqrt(int x)\\n    {\\n      int low =0,high=x;\\n      long mid;\\n      while(low<=high)\\n      {\\n        mid=low+(high-low)/2;\\n\\n        if(x==(mid*mid))\\n           return true; //x is a perfect square\\n        else if(x>(mid*mid))\\n          low=(int)mid+1;\\n        else //if(x<(mid*mid))\\n          high=(int)mid-1;\\n      }\\n      return false; //x is not a perfect square\\n    }\\n}\\n\\n```\\n\\n```\\n\\n//Method 2 - Using Two Pointer Technique\\n\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n       /*\\n        lb_a=0; - minimum possible value of a =0\\n        lb_b=0; - minimum possible value of b =0\\n        ub_a=Math.sqrt(c); - maximum possible value of a =Math.sqrt(c);\\n        ub_b=Math.sqrt(c); - maximum possible value of b =Math.sqrt(c);\\n        */\\n\\n        int sqrt_c=(int)Math.sqrt(c);\\n        long a=0; // long is used to Avoid Integer Overflow\\n        int b=sqrt_c;\\n        \\n        while(a<=sqrt_c && b>=0)\\n        { \\n            long sumOfSqr=(b*b)+(a*a); \\n            \\n            if(sumOfSqr==c) \\n              return true;\\n            if(sumOfSqr>c) \\n              b--;\\n            else //(sumOfSqr<c)\\n              a++;\\n        }\\n\\n      return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n/*\\n\\n    Maths Explaination :\\n\\n    a^2 + b^2 =c;\\n   \\n    Possible values of a =0,1,2,3,4,5,6...... (Even if you take -ve values of \\'a\\' the a^2 will remain the same)\\n    i.e Possible values of a^2 =0,1,4,9,16,25,36......\\n                            \\n    Similarly;\\n\\n    Possible values of b =0,1,2,3,4,5,6......(Even if you take -ve values of \\'b\\' the b^2 will remain the same)\\n    i.e Possible values of b^2 =0,1,4,9,16,25,36......\\n    \\n    if you observe Carefully all these possible values of a^2 and b^2 are perfect Squares.(an we already know how to check  perfect Squares).\\n    \\n    How to derieve Condition?\\n    \\n    minimum possible value of b^2=0;\\n    which gives maximum possible value of a^2 i.e a^2 =c;\\n    \\n    thus generalised (while loop)condition is a^2<=c or a<=Math.sqrt(c);\\n    \\n    Or\\n\\n    minimum possible value of a^2=0;\\n    which gives maximum possible value of b^2 i.e b^2 =c;\\n    \\n    thus generalised (while loop)condition is  : b^2<=c or b<=Math.sqrt(c);\\n   \\n    Conclusion :\\n    minimum possible value of a =0\\n    minimum possible value of b =0\\n    maximum possible value of a =Math.sqrt(c);\\n    maximum possible value of b =Math.sqrt(c);\\n\\n*/\\n```\n```\\n\\n// Method 1 - Using Binary Search\\n\\n/* Intuitive Implementation :\\n\\nHow To Efficiently Find Next perfect square ?\\n\\nThe very first perfect square is important for this method. Now the original answer is hidden over this pattern i.e. 0, 1, 4, 9, 16, 25, 36, 49, 64,..... \\nthe difference between 0 and 1 is 1 \\nthe difference between 1 and 4 is 3 \\nthe difference between 4 and 9 is 5 and so on\\u2026 \\nwhich means that the difference between two perfect squares is always an odd number.\\nNow, the question arises what must be added to get the next number and the answer is (sqrt(X) * 2) + 1 where X is the already known perfect square.\\n\\n*/\\n\\n\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n      int aSqr=0; //0 is the First perfect Square Number\\n\\n      while(aSqr<=c)\\n      {\\n        if(isPerfectSquare(c-aSqr)) //b^2=(c-a^2);check if b^2 is perfect square or not\\n          return true;\\n\\t  \\n        aSqr=nextPerfectSquareNumber(aSqr);\\n      }\\n      return false; \\n    }\\n\\n    public boolean isPerfectSquare(int num)\\n    {\\n       if(mySqrt(num)!=-1)\\n         return true;\\n         \\n       return false;\\n    }\\n    \\n    public int mySqrt(int x)\\n    {\\n      int low =0,high=x;\\n      while(low<=high)\\n      {\\n        long mid=low+(high-low)/2;\\n\\n        if(x==(mid*mid))\\n           return (int)mid;\\n        else if(x>(mid*mid))\\n          low=(int)mid+1;\\n        else//if(x<(mid*mid))\\n          high=(int)mid-1;\\n      }\\n      return -1;\\n    }\\n    \\n    public int nextPerfectSquareNumber(int num)\\n    {\\n      int next=num+(mySqrt(num)*2)+1;\\n      return next;\\n    }\\n}\\n\\n\\n\\n//Optimal Implementation\\n\\nclass Solution {\\n    public boolean judgeSquareSum(int c){\\n      int sqrt_c=(int)Math.sqrt(c);\\n      for(int a=0;a<=sqrt_c;a++)\\n        if(isPerfectSquare(c-a*a))  //b^2=(c-a^2),check if b^2 is perfect square or not\\n          return true;\\n        \\n       return false;\\n    }\\n    \\n    public boolean isPerfectSquare(int num)\\n    {\\n       return mySqrt(num);\\n    }\\n    \\n    public boolean mySqrt(int x)\\n    {\\n      int low =0,high=x;\\n      long mid;\\n      while(low<=high)\\n      {\\n        mid=low+(high-low)/2;\\n\\n        if(x==(mid*mid))\\n           return true; //x is a perfect square\\n        else if(x>(mid*mid))\\n          low=(int)mid+1;\\n        else //if(x<(mid*mid))\\n          high=(int)mid-1;\\n      }\\n      return false; //x is not a perfect square\\n    }\\n}\\n\\n```\n```\\n\\n//Method 2 - Using Two Pointer Technique\\n\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n       /*\\n        lb_a=0; - minimum possible value of a =0\\n        lb_b=0; - minimum possible value of b =0\\n        ub_a=Math.sqrt(c); - maximum possible value of a =Math.sqrt(c);\\n        ub_b=Math.sqrt(c); - maximum possible value of b =Math.sqrt(c);\\n        */\\n\\n        int sqrt_c=(int)Math.sqrt(c);\\n        long a=0; // long is used to Avoid Integer Overflow\\n        int b=sqrt_c;\\n        \\n        while(a<=sqrt_c && b>=0)\\n        { \\n            long sumOfSqr=(b*b)+(a*a); \\n            \\n            if(sumOfSqr==c) \\n              return true;\\n            if(sumOfSqr>c) \\n              b--;\\n            else //(sumOfSqr<c)\\n              a++;\\n        }\\n\\n      return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890924,
                "title": "sum-of-square-numbers-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long a = 0;\\n        long b = (long) Math.sqrt(c);\\n\\n        while(a<=b){\\n            if(((a*a) + (b*b)) == c){\\n                return true;\\n            }\\n            else if((((a*a)+(b*b)) < c)){\\n                a++;\\n            }\\n            else{\\n                b--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long a = 0;\\n        long b = (long) Math.sqrt(c);\\n\\n        while(a<=b){\\n            if(((a*a) + (b*b)) == c){\\n                return true;\\n            }\\n            else if((((a*a)+(b*b)) < c)){\\n                a++;\\n            }\\n            else{\\n                b--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416881,
                "title": "simpliest-ts-js-solution-beats-92-86",
                "content": "\\n# Code\\n```\\nfunction judgeSquareSum(c: number): boolean {\\n    if (c === 0 || c === 1) return true\\n\\n    const sqC = Math.trunc(Math.sqrt(c))\\n\\n    for (let num=1; num<sqC+1; num++){\\n        const secondNum = Math.sqrt(c - num**2)\\n\\n        if (secondNum === Math.trunc(secondNum)) return true\\n    }\\n\\n    return false\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction judgeSquareSum(c: number): boolean {\\n    if (c === 0 || c === 1) return true\\n\\n    const sqC = Math.trunc(Math.sqrt(c))\\n\\n    for (let num=1; num<sqC+1; num++){\\n        const secondNum = Math.sqrt(c - num**2)\\n\\n        if (secondNum === Math.trunc(secondNum)) return true\\n    }\\n\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3392231,
                "title": "c-two-pointers",
                "content": "# Approach\\nUse two pointer:\\n- `lo` from 0\\n- `hi` $$\\\\sqrt{c}$$\\n\\nIf sum $$(lo^2 + hi^2)$$:\\n- equals `c` - we found solution => return true\\n- > `c` - decrement `hi`\\n- < `c` - increment `lo`\\n\\n# Complexity\\n- Time complexity: $$O(\\\\sqrt{n})$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool JudgeSquareSum(int c)\\n    {\\n        var lo = 0L;\\n        var hi = (long)Math.Sqrt(c);\\n\\n        while (lo <= hi)\\n        {\\n            var sum = lo * lo + hi * hi;\\n            if (sum == c)\\n            {\\n                return true;\\n            }\\n\\n            if (sum > c)\\n            {\\n                --hi;\\n            }\\n            else\\n            {\\n                ++lo;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool JudgeSquareSum(int c)\\n    {\\n        var lo = 0L;\\n        var hi = (long)Math.Sqrt(c);\\n\\n        while (lo <= hi)\\n        {\\n            var sum = lo * lo + hi * hi;\\n            if (sum == c)\\n            {\\n                return true;\\n            }\\n\\n            if (sum > c)\\n            {\\n                --hi;\\n            }\\n            else\\n            {\\n                ++lo;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310147,
                "title": "633-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize left and right pointers to 0 and the integer square root of c respectively.\\n2. While the left pointer is less than or equal to the right pointer, compute the current sum of squares.\\n3. If the current sum is equal to c, return True.\\n4. If the current sum is less than c, increment the left pointer by 1.\\n5. If the current sum is greater than c, decrement the right pointer by 1.\\n6. If the loop completes without finding a valid pair of integers, return False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        left, right = 0, int(c**0.5)  # initialize left and right pointers\\n        while left <= right:\\n            curr_sum = left**2 + right**2\\n            if curr_sum == c:\\n                return True\\n            elif curr_sum < c:\\n                left += 1\\n            else:\\n                right -= 1\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        left, right = 0, int(c**0.5)  # initialize left and right pointers\\n        while left <= right:\\n            curr_sum = left**2 + right**2\\n            if curr_sum == c:\\n                return True\\n            elif curr_sum < c:\\n                left += 1\\n            else:\\n                right -= 1\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155900,
                "title": "easy-java-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long a = 0;\\n        long b = (long) Math.sqrt(c); // it will return the sqrt of number, \\n// eg if, c = 4 then it will be 2,so we will start from a = 0; to b = 2; \\n\\n        while (a <= b) {\\n\\n            if (a * a + b * b == c) {\\n                return true;\\n            } else if (a * a + b * b > c) { // sqrt is maximum,\\n// means a is at it\\'s min, and b is at their max level, as a is\\n// starting from 0 and b from sqrt(c)\\n// max , so we will decrement b;\\n                b--;\\n            } else { // If the value is less than c , means \\n// (as b is alwats max so we will have to increment a )\\n                a++;\\n            }\\n        }\\n        return false; // at the end if none of the condition\\n// executes, we will return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long a = 0;\\n        long b = (long) Math.sqrt(c); // it will return the sqrt of number, \\n// eg if, c = 4 then it will be 2,so we will start from a = 0; to b = 2; \\n\\n        while (a <= b) {\\n\\n            if (a * a + b * b == c) {\\n                return true;\\n            } else if (a * a + b * b > c) { // sqrt is maximum,\\n// means a is at it\\'s min, and b is at their max level, as a is\\n// starting from 0 and b from sqrt(c)\\n// max , so we will decrement b;\\n                b--;\\n            } else { // If the value is less than c , means \\n// (as b is alwats max so we will have to increment a )\\n                a++;\\n            }\\n        }\\n        return false; // at the end if none of the condition\\n// executes, we will return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105976,
                "title": "c-easiest-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRuntime: 0 ms, faster than 68.00% of C++ online submissions for Sum of Square Numbers.\\nMemory Usage: 6 MB, less than 10.54% of C++ online submissions for Sum of Square Numbers.Runtime: 0 ms, faster than 100.00% of C++ online submissions for Sum of Square Numbers.\\nMemory Usage: 6 MB, less than 10.54% of C++ online submissions for Sum of Square Numbers.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int a=0,b=sqrt(c);\\n        long long int sqrt=1;\\n        while(a<=b){\\n            sqrt=a*a+b*b;\\n            if(sqrt==c){\\n                return true;\\n            }\\n            else if(sqrt>c){\\n                b--;\\n            }\\n            else{\\n                a++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int a=0,b=sqrt(c);\\n        long long int sqrt=1;\\n        while(a<=b){\\n            sqrt=a*a+b*b;\\n            if(sqrt==c){\\n                return true;\\n            }\\n            else if(sqrt>c){\\n                b--;\\n            }\\n            else{\\n                a++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973342,
                "title": "2-solutions-in-java-binary-search-two-pointer",
                "content": "If I put any wrong time complextity please let me know. If this post is helpful please give an upvote. Thank you!\\n\\n# Approach\\n- Binary Search\\n- Two pointer (my favorite)\\n\\n# Binary Search\\n- Time complexity: O(sqrt(c) * log(sqrt(c)))\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c == 0) return true;\\n\\n        for(int i = 0; i < Math.sqrt(c) + 1; i++) {\\n            int target = c - i*i;\\n            int s = 0;\\n            int e = (int)Math.sqrt(c);\\n            \\n            while(s <= e) {\\n                int mid = (s+e)/2;\\n        \\n                if(mid*mid == target) return true;\\n                else if(mid*mid < target) s = mid + 1;\\n                else e = mid - 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n# Two pointer\\n- Time complexity: O(sqrt(c))\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int s = 0;\\n        int e = (int)Math.sqrt(c); //if end > sqrt(c) then s^2 + e^2 > c\\n\\n        while(s <= e) {\\n            int res = (int)(Math.pow(s, 2) + Math.pow(e, 2));\\n            if(res > c) e--;\\n            else if(res == c) return true;\\n            else s++;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        if(c == 0) return true;\\n\\n        for(int i = 0; i < Math.sqrt(c) + 1; i++) {\\n            int target = c - i*i;\\n            int s = 0;\\n            int e = (int)Math.sqrt(c);\\n            \\n            while(s <= e) {\\n                int mid = (s+e)/2;\\n        \\n                if(mid*mid == target) return true;\\n                else if(mid*mid < target) s = mid + 1;\\n                else e = mid - 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int s = 0;\\n        int e = (int)Math.sqrt(c); //if end > sqrt(c) then s^2 + e^2 > c\\n\\n        while(s <= e) {\\n            int res = (int)(Math.pow(s, 2) + Math.pow(e, 2));\\n            if(res > c) e--;\\n            else if(res == c) return true;\\n            else s++;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772957,
                "title": "python-o-c-o-sqrt-c-log-sqrt-c-o-sqrt-c-explained",
                "content": "## **1. BRUTE FORCE APPROACH - O(sqrt(c)^2) \\u279C O(c)**\\n\\nThe constraint says that \"c\" can be as large as \"2^31 - 1\" which means even an O(c) solution will give TLE. This is a hint that we need to write a solution that is better than even O(c) solution. \\n\\nAnyways, the idea is that since we are asked for two numbers \"a\" and \"b\" such that - \\n\\n\\t\\ta^2 + b^2 = c\\n\\t\\t\\nIt means, \"a\" and \"b\" should be in the range 0 to sqrt(c). And that\\'s the range in which we can find two values, if they exist.\\n\\nSo, in Brute Force approach, for every possible value of \"a\", we go through every possible value of \"b\". Since both loops run from 0 to sqrt(c), the time complexity is O(sqrt(c) ^ 2) or O(c)\\n\\n\\n    def judgeSquareSum(self, c: int) -> bool:\\n        # Since we want two numbers \"a\" and \"b\" such that \\n        # a^2 + b^2 = c\\n        \\n        # So, these two numbers should be in the range -> 0 to square root of \"c\"\\n        squareRoot = int(sqrt(c))\\n        \\n        # In Brute Force Approach, for every possible value of \"a\"\\n        for a in range(0, squareRoot + 1):\\n            # We need to go through every possible value of \"b\"\\n            for b in range(0, squareRoot + 1):\\n                # If we find a pair, then return True\\n                if (a * a) + (b * b) == c: return True\\n        \\n        \\n        # If we come out of the loop, that means no pair exists\\n        return False\\n\\t\\t\\n\\t\\t\\n## **2. BINARY SEARCH APPROACH #1 - O(sqrt(c) * log(sqrt(c)))**\\n\\nAs discussed above, the range for both \"a\" and \"b\" is from 0 to sqrt(c). This range is also in a sorted order. This means, instead of linear scan, we can use Binary Search in the inner loop such that we search for a valid value of \"b\" that satisfies the equation.\\n\\nIn each iteration of Binary Search, we will get a new \"mid\" or in other words, a new value of \"b\". And we just need to check if the equation \"a^2 + b^2\" gives us \"c\" or not. If it does, then we can straight away return \"True\".\\n\\nBut if it does not, there are two cases - \\n\\n\\t1. \"a^2 + b^2\" is more than c\\n\\t2. \"a^2 + b^2\" is less than c\\n\\nIf it is more than \"c\", then that means the value of \"b\" is more than required. Because \"a\" and \"c\" will remain the same for every iteration of inner loop. But only \"b\" can increase or decrease. This means, the value of equation being more or less than \"c\" depends on \"b\" or \"mid\". Hence, we search on left side of \"mid\".\\n\\nIf the value is less than \"c\", that means value of \"b\" needs to be increased, hence we search on right side of mid.\\n\\n\\n    def judgeSquareSum(self, c: int) -> bool:\\n        # Since we want two numbers \"a\" and \"b\" such that \\n        # a^2 + b^2 = c\\n        \\n        squareRoot = int(sqrt(c))\\n        \\n        # For every possible value of \"a\"\\n        for a in range(0, squareRoot + 1):\\n            # Instead of linear scan, we can try Binary Search as range is in sorted order\\n            start = 0\\n            end = squareRoot + 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                value = (a * a) + (mid * mid)\\n                \\n                # If b = mid then, if condition is satisfied\\n                # We found a pair\\n                if value == c: return True\\n                \\n                # If the value becomes more than \"c\", then we need to decrease value of \"b\"\\n                # Because \"a\" is constant in this while loop and only \"b\" can change\\n                if value > c: end = mid - 1\\n                    \\n                # If the value becomes less than \"c\", then we need to increase value of \"b\"\\n                else: start = mid + 1\\n\\n        # If we come out of the loop, that means no pair exists\\n        return False\\n\\n\\n## **3. BINARY SEARCH APPROACH #2 - O(sqrt(c) * log(sqrt(c)))**\\n\\nAnother way to apply Binary search is to directly search for the value of \"b\" that will satisfy the equation. \\n\\nWe are given that - \\n\\t\\t\\n\\t\\t\\ta^2 + b^2 = c\\n\\t\\tor, b^2 = c - a^2\\n\\t\\tor, b = sqrt(c - a^2)\\n\\t\\t\\nHence, all we need to Binary Search is this value of \"b\" in the range 0 to sqrt(c).\\n\\n```\\ndef judgeSquareSum(self, c: int) -> bool:\\n        # Since we want two numbers \"a\" and \"b\" such that \\n        # a^2 + b^2 = c\\n        \\n        # So, these two numbers should be in the range -> 0 to square root of \"c\"\\n        squareRoot = int(sqrt(c))\\n        \\n        # For every possible value of \"a\"\\n        for a in range(0, squareRoot + 1):\\n            # Instead of linear scan, we can try Binary Search as range is in sorted order\\n            # When we are here, we have \"a\" value and \"c\" value. So all that we are looking for is the \"b\" value\\n            \\n            # a^2 + b^2 = c\\n            # From this, b^2 = c - a^2\\n            # Or, b = sqrt(c - a^2)\\n\\n            # So this is the value we need to search for in the range 0 to sqrt(c)\\n            target = sqrt(c - (a * a))\\n\\n            start = 0\\n            end = squareRoot\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if mid == target: return True\\n                \\n                if mid > target: end = mid - 1\\n                else: start = mid + 1\\n\\n        # If we come out of the loop, that means no pair exists\\n        return False\\n```\\n\\n\\n## **4. TWO POINTERS APPROACH - O(sqrt(c))**\\n\\nThe most efficient way to solve this problem is using Two Pointer approach that will have a time complexity of O(sqrt(c)).\\n\\nWe know that both values are in range 0 to sqrt(c)\\n\\nSo what we can do is initially, set \"a\" as the smallest value in this range i.e., 0\\nAnd set \"b\" as the largest value i.e., sqrt(c)\\n\\nAnd now, while a is <= b, we will check the equation. If it is satisfies, we found a pair.\\n\\nBut, if \"a^2 + b^2\" is more than \"c\", that means, either \"a\" is larger than what we need or \"b\" is larger than what we need. And it makes sense to decrease \"b\" in this case because \"b\" is always the larger of the two.\\n\\nSimilarly, if \"a^2 + b^2\" is less than \"c\", that means, either \"a\" is smaller than what we need or \"b\" is smaller than what we need. And it makes sense to increase \"a\" in this case because \"a\" is always the smaller of the two.\\n\\n```\\ndef judgeSquareSum(self, c: int) -> bool:\\n        # Since we want two numbers \"a\" and \"b\" such that \\n        # a^2 + b^2 = c\\n        \\n        # So, these two numbers should be in the range -> 0 to square root of \"c\"\\n\\n        # We can use a two pointer approach where initially \"a\" is smallest possible value\\n        # and \"b\" is the largest possible value in the range 0 to sqrt(c)\\n        a = 0\\n        b = int(sqrt(c))\\n        \\n        while a <= b:\\n            value = (a * a) + (b * b)\\n            \\n            # If the result of expression is equal to \"c\", we found a pair\\n            if value == c: return True\\n            \\n            # If the value is less than \"c\", that means \"a\" needs to be increased\\n            # Because \"b\" is already a larger number among the two so \"a\" needs to be increased\\n            if value < c: a += 1\\n                \\n            # If the value is more than \"c\", that means \"b\" needs to be decreased\\n            # Because \"a\" is already a smaller number among the two\\n            else: b -= 1\\n            \\n        \\n        return False\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef judgeSquareSum(self, c: int) -> bool:\\n        # Since we want two numbers \"a\" and \"b\" such that \\n        # a^2 + b^2 = c\\n        \\n        # So, these two numbers should be in the range -> 0 to square root of \"c\"\\n        squareRoot = int(sqrt(c))\\n        \\n        # For every possible value of \"a\"\\n        for a in range(0, squareRoot + 1):\\n            # Instead of linear scan, we can try Binary Search as range is in sorted order\\n            # When we are here, we have \"a\" value and \"c\" value. So all that we are looking for is the \"b\" value\\n            \\n            # a^2 + b^2 = c\\n            # From this, b^2 = c - a^2\\n            # Or, b = sqrt(c - a^2)\\n\\n            # So this is the value we need to search for in the range 0 to sqrt(c)\\n            target = sqrt(c - (a * a))\\n\\n            start = 0\\n            end = squareRoot\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if mid == target: return True\\n                \\n                if mid > target: end = mid - 1\\n                else: start = mid + 1\\n\\n        # If we come out of the loop, that means no pair exists\\n        return False\\n```\n```\\ndef judgeSquareSum(self, c: int) -> bool:\\n        # Since we want two numbers \"a\" and \"b\" such that \\n        # a^2 + b^2 = c\\n        \\n        # So, these two numbers should be in the range -> 0 to square root of \"c\"\\n\\n        # We can use a two pointer approach where initially \"a\" is smallest possible value\\n        # and \"b\" is the largest possible value in the range 0 to sqrt(c)\\n        a = 0\\n        b = int(sqrt(c))\\n        \\n        while a <= b:\\n            value = (a * a) + (b * b)\\n            \\n            # If the result of expression is equal to \"c\", we found a pair\\n            if value == c: return True\\n            \\n            # If the value is less than \"c\", that means \"a\" needs to be increased\\n            # Because \"b\" is already a larger number among the two so \"a\" needs to be increased\\n            if value < c: a += 1\\n                \\n            # If the value is more than \"c\", that means \"b\" needs to be decreased\\n            # Because \"a\" is already a smaller number among the two\\n            else: b -= 1\\n            \\n        \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2576959,
                "title": "java-commented-code-explained",
                "content": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        //Logic-->\\n        /* We need two numbers a, b such that a^2 + b^2 = c. So, it is clear that the  max(a,b) must be less c.\\n        Suppose c = 10 then, a = 0 and b = 9(3^2). */\\n        long low = 0, high = (long)Math.sqrt(c);\\n        while(low <= high){\\n            if(low*low + high*high == c){\\n                return true;\\n            }\\n            else if(low*low + high*high < c){\\n                low++;\\n            }\\n            else{\\n                high--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        //Logic-->\\n        /* We need two numbers a, b such that a^2 + b^2 = c. So, it is clear that the  max(a,b) must be less c.\\n        Suppose c = 10 then, a = 0 and b = 9(3^2). */\\n        long low = 0, high = (long)Math.sqrt(c);\\n        while(low <= high){\\n            if(low*low + high*high == c){\\n                return true;\\n            }\\n            else if(low*low + high*high < c){\\n                low++;\\n            }\\n            else{\\n                high--;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575699,
                "title": "c-2-pointers-approach-simplest-solution-of-comment-sec",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int s=0,e=sqrt(c);\\n        while(s<=e){\\n            long long int ans=s*s+e*e;\\n            if(ans>c){\\n                e--;\\n            }\\n            else if(ans<c){\\n                s++;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n**If you have any doubts then feel free to ask in the comment section.\\nplease upvote as it acts as a motivation for me as well.**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int s=0,e=sqrt(c);\\n        while(s<=e){\\n            long long int ans=s*s+e*e;\\n            if(ans>c){\\n                e--;\\n            }\\n            else if(ans<c){\\n                s++;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563659,
                "title": "100-faster-c-easy",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Sum of Square Numbers.\\nMemory Usage: 5.9 MB, less than 25.67% of C++ online submissions for Sum of Square Numbers.\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if(c<0){\\n            return false;\\n        }\\n        long long start=0;\\n        long long end=sqrt(c);\\n        while(start<=end){\\n            long long sq=(start*start)+(end*end);\\n            if(sq==c){\\n                return true;\\n            }else if(sq<c){\\n                start++;\\n            }else{\\n                end--;\\n            }\\n        }\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        if(c<0){\\n            return false;\\n        }\\n        long long start=0;\\n        long long end=sqrt(c);\\n        while(start<=end){\\n            long long sq=(start*start)+(end*end);\\n            if(sq==c){\\n                return true;\\n            }else if(sq<c){\\n                start++;\\n            }else{\\n                end--;\\n            }\\n        }\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560649,
                "title": "easy-java-solution",
                "content": "**please upvote if you like**\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int n) {\\n        int root = (int) Math.sqrt(n);\\n        long low = 0;\\n        long high = root;\\n        \\n        while(low<=high){\\n           long sum = (low*low)+(high*high);\\n            if(sum==n){\\n                return true;\\n            }\\n            if(sum>n){\\n                high--;\\n            }\\n            else{\\n                low++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int n) {\\n        int root = (int) Math.sqrt(n);\\n        long low = 0;\\n        long high = root;\\n        \\n        while(low<=high){\\n           long sum = (low*low)+(high*high);\\n            if(sum==n){\\n                return true;\\n            }\\n            if(sum>n){\\n                high--;\\n            }\\n            else{\\n                low++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544624,
                "title": "c-5-lines-code-easy-to-understand",
                "content": "** c - a^2c\\u2212a 2 is a perfect square using sum of odd numbers, we can make use of the inbuilt sqrtsqrt function and check if sqrt{c - a^2} \\nc\\u2212a \\n2 turns out to be an integer. If it happens for any value of aa in the range  [0, sqrt{c}][0,c] , we can return a True value immediately.\\n\\n**\\n\\n\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        \\n            for (long a = 0; a * a <= c; a++) {\\n            double b = sqrt(c - a * a);\\n            if (b == (int) b)\\n                return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        \\n            for (long a = 0; a * a <= c; a++) {\\n            double b = sqrt(c - a * a);\\n            if (b == (int) b)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2483077,
                "title": "simple-o-n-java-solution-using-2-pointers",
                "content": "```\\n\\nclass Solution {\\n    public boolean judgeSquareSum(int c) \\n    {\\n        long i=0;\\n        long j = (int)Math.sqrt(c);\\n        \\n        while(i <= j)\\n        {\\n            long ans = i*i + j*j;\\n            \\n            if(ans == c)\\n                return true;\\n            \\n            if(ans > c)\\n                j--;\\n            \\n            else\\n                i++;\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean judgeSquareSum(int c) \\n    {\\n        long i=0;\\n        long j = (int)Math.sqrt(c);\\n        \\n        while(i <= j)\\n        {\\n            long ans = i*i + j*j;\\n            \\n            if(ans == c)\\n                return true;\\n            \\n            if(ans > c)\\n                j--;\\n            \\n            else\\n                i++;\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458461,
                "title": "java-short-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n      HashSet<Integer> set = new HashSet<>();\\n      \\n      for(int i = 0; i <= Math.sqrt(c); i ++) {\\n        set.add(i * i);\\n        if(set.contains(c - i * i))\\n          return true;\\n      }\\n      return false;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n      HashSet<Integer> set = new HashSet<>();\\n      \\n      for(int i = 0; i <= Math.sqrt(c); i ++) {\\n        set.add(i * i);\\n        if(set.contains(c - i * i))\\n          return true;\\n      }\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433800,
                "title": "100-0ms-dcode",
                "content": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long left=0;\\n        long right=(long) Math.sqrt(c);\\n        \\n        while(left<=right){\\n            long total = left*left + right*right;\\n            if(total==c)\\n                return true;\\n            \\n            if(total>c)\\n                right--;\\n            else\\n                left++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        long left=0;\\n        long right=(long) Math.sqrt(c);\\n        \\n        while(left<=right){\\n            long total = left*left + right*right;\\n            if(total==c)\\n                return true;\\n            \\n            if(total>c)\\n                right--;\\n            else\\n                left++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386262,
                "title": "two-pointers-solution-o-sqrt-c-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long start=0,end=0;\\n        while(end*end<c){\\n            end++;\\n        }\\n        long long target=c;\\n        while(start<=end){\\n            long long product=start*start+end*end;\\n            if(product==target){\\n                return true;\\n            } else if(product>c){\\n                end--;\\n            } else {\\n                start++;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long start=0,end=0;\\n        while(end*end<c){\\n            end++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2379397,
                "title": "0ms-c-two-pointers-without-using-long-simple",
                "content": "```\\nbool judgeSquareSum(int c) {\\n        int low=0,high=sqrt(c);\\n        while(low<=high) {\\n            int h=high*high;\\n            int l=low*low;\\n            if(INT_MAX-h<l) high--;\\n            else if(l+h==c) return true;\\n            else if(l+h<c) low++;\\n            else high--;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nbool judgeSquareSum(int c) {\\n        int low=0,high=sqrt(c);\\n        while(low<=high) {\\n            int h=high*high;\\n            int l=low*low;\\n            if(INT_MAX-h<l) high--;\\n            else if(l+h==c) return true;\\n            else if(l+h<c) low++;\\n            else high--;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2368294,
                "title": "c-two-pointer-solution",
                "content": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int a=0;\\n        long long int b=sqrt(c);\\n        while(a<=b){\\n            long long int t=(a*a)+(b*b);\\n            if(c<t){\\n                b--;\\n            }\\n            else if(c>t){\\n                a++;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long int a=0;\\n        long long int b=sqrt(c);\\n        while(a<=b){\\n            long long int t=(a*a)+(b*b);\\n            if(c<t){\\n                b--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2368284,
                "title": "c-2-pointer-easy-solution-brute-force",
                "content": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n       long long int i=0;\\n        long long int j=sqrt(c);\\n        while(i<=j)\\n        {\\n            long long int t=(i*i)+(j*j);\\n            if(t>c)\\n            {\\n                j--;\\n            }\\n            else if(t<c)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n       long long int i=0;\\n        long long int j=sqrt(c);\\n        while(i<=j)\\n        {\\n            long long int t=(i*i)+(j*j);\\n            if(t>c)\\n            {\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2359839,
                "title": "79-tc-and-76-sc-easy-python-solution",
                "content": "```\\ndef judgeSquareSum(self, c: int) -> bool:\\n\\td = set()\\n\\tfor i in range(int(c**0.5)+1):\\n\\t\\td.add(i*i)\\n\\t\\tif(c-i*i in d):\\n\\t\\t\\treturn 1\\n\\treturn 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef judgeSquareSum(self, c: int) -> bool:\\n\\td = set()\\n\\tfor i in range(int(c**0.5)+1):\\n\\t\\td.add(i*i)\\n\\t\\tif(c-i*i in d):\\n\\t\\t\\treturn 1\\n\\treturn 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2336984,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if(num==0)\\n            return false;\\n        if(num==1)\\n            return true;\\n        long lo=0,hi=num;\\n        while(hi-lo>1){\\n            long mid=lo + (hi-lo)/2;\\n            long x=mid*mid;\\n            if(x == num)\\n                return true;\\n            else if(x<num)\\n                lo=mid;\\n            else\\n                hi=mid;\\n        }\\n        return false;\\n    }\\n    bool judgeSquareSum(int c) {\\n        if(c==0 || c==1)\\n            return true;\\n        for(int i=0;i*1LL*i<c;i++){\\n            if(isPerfectSquare(c-i*1LL*i))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        if(num==0)\\n            return false;\\n        if(num==1)\\n            return true;\\n        long lo=0,hi=num;\\n        while(hi-lo>1){\\n            long mid=lo + (hi-lo)/2;\\n            long x=mid*mid;\\n            if(x == num)\\n                return true;\\n            else if(x<num)\\n                lo=mid;\\n            else\\n                hi=mid;\\n        }\\n        return false;\\n    }\\n    bool judgeSquareSum(int c) {\\n        if(c==0 || c==1)\\n            return true;\\n        for(int i=0;i*1LL*i<c;i++){\\n            if(isPerfectSquare(c-i*1LL*i))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317752,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long int t = 0;\\n        long int k = sqrt(c);\\n        while(t <= k) {\\n        if(t * t + k * k == c)\\n            return true;\\n        else if(t * t + k * k < c){\\n            t++;\\n        }else \\n            k--;\\n      }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long int t = 0;\\n        long int k = sqrt(c);\\n        while(t <= k) {\\n        if(t * t + k * k == c)\\n            return true;\\n        else if(t * t + k * k < c){\\n            t++;\\n        }else \\n            k--;\\n      }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285240,
                "title": "java-without-hashmap-simple-to-understand-solution-using-two-pointers",
                "content": "class Solution {\\n    public boolean judgeSquareSum(int c) {\\n\\t//initializing the two pointers i to 0 and j to sqrt(c)\\n    long i=0;\\n        long j= (int) (Math.sqrt(c)) ; //taking the integer part of sqrt of given number\\n        \\n        while(i<=j){ \\n            long e=j*j+(i*i);   \\n            if(e==c) return true; //returns true if addition of squares of i and j equals to c\\n            if(e>c ) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n}\\n\\n\\nPlease upvote guys if you understood this solution",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean judgeSquareSum(int c) {\\n\\t//initializing the two pointers i to 0 and j to sqrt(c)\\n    long i=0;\\n        long j= (int) (Math.sqrt(c)) ; //taking the integer part of sqrt of given number\\n        \\n        while(i<=j){ \\n            long e=j*j+(i*i);   \\n            if(e==c) return true; //returns true if addition of squares of i and j equals to c\\n            if(e>c ) j--;\\n            else i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2264323,
                "title": "c-two-pointer-easy-o-root-n-time-o-1-space",
                "content": "```\\n    bool judgeSquareSum(int c) {\\n        int l=0,h=sqrt(c);\\n        while(l<=h) {\\n            if(pow(l,2)+pow(h,2) == c)\\n                return true;\\n            else if(pow(l,2)+pow(h,2) < c)\\n                l++;\\n            else\\n                h--;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    bool judgeSquareSum(int c) {\\n        int l=0,h=sqrt(c);\\n        while(l<=h) {\\n            if(pow(l,2)+pow(h,2) == c)\\n                return true;\\n            else if(pow(l,2)+pow(h,2) < c)\\n                l++;\\n            else\\n                h--;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2241175,
                "title": "c-2methods-easy-and-fast",
                "content": "**METHOD 1:**\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long i=0,j=sqrt(c);\\n        while(i<=j){\\n            if((i*i + j*j)==c)\\n                return true;\\n            else if((i*i + j*j)<c)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n\\n\\n**METHOD 2:**\\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(long long int a = 0 ; a <= sqrt(c) ; a++)\\n        {\\n            double b = sqrt(c - a * a);\\n            if(b == (int)b)\\n            {\\n                return true ;\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n\\n```\\n**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me (^~^)***\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long i=0,j=sqrt(c);\\n        while(i<=j){\\n            if((i*i + j*j)==c)\\n                return true;\\n            else if((i*i + j*j)<c)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return false;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        for(long long int a = 0 ; a <= sqrt(c) ; a++)\\n        {\\n            double b = sqrt(c - a * a);\\n            if(b == (int)b)\\n            {\\n                return true ;\\n            }\\n        }\\n        return false ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233772,
                "title": "c-easy-fast-binary-search-best-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long s=0,e = int (pow(c,0.5));\\n        \\n        while(s<=e){\\n            long long ans = (s*s) + (e*e);\\n            if(ans == c) return 1;\\n            else if (ans>c) e--;\\n            else s++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**Upvote if you like the solution :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n        long long s=0,e = int (pow(c,0.5));\\n        \\n        while(s<=e){\\n            long long ans = (s*s) + (e*e);\\n            if(ans == c) return 1;\\n            else if (ans>c) e--;\\n            else s++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226131,
                "title": "java-simple-math-explained-solution",
                "content": "the given equation is` c = a^2 + b^2` ,\\nwhich can re rewritten as  `b^2 = c - a^2`\\nstarting for a=0 ,  we find the value of b acordingly.\\na is starting from 0 because `4=a^2+0^2` , in this case the given number is already a perfect aquare.\\nthe base condition is when a becomes greater than b , \\nfor example values of a and b inside while loop for input 56.\\n![image](https://assets.leetcode.com/users/images/48bc33ed-aa74-4069-ba6b-3cbe10c1850f_1656745995.165983.png)\\n\\n\\nas we can see after the `a==b` , the the possible values of a and b get changed .\\nit will just increase the complexity.\\n\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int a=0;\\n        int b=(int)Math.sqrt(c);\\n        while(a<=b){\\n            b=(int)Math.sqrt(c-(a*a));\\n            if((b*b)+(a*a)==c){\\n                return true;\\n            }\\n            a++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int a=0;\\n        int b=(int)Math.sqrt(c);\\n        while(a<=b){\\n            b=(int)Math.sqrt(c-(a*a));\\n            if((b*b)+(a*a)==c){\\n                return true;\\n            }\\n            a++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218057,
                "title": "javascript-two-pointers-easy",
                "content": "var judgeSquareSum = function(c) {\\n    let start=0;\\n    let end=Math.floor(Math.sqrt(c));\\n    \\n    while(start<=end){\\n        let sum = start*start + end*end;\\n        \\n        if(sum<c){\\n            start++\\n        }else if(sum>c){\\n            end--\\n        }else{\\n            return true\\n        }\\n    }\\n    return false\\n    \\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "var judgeSquareSum = function(c) {\\n    let start=0;\\n    let end=Math.floor(Math.sqrt(c));\\n    \\n    while(start<=end){\\n        let sum = start*start + end*end;\\n        \\n        if(sum<c){\\n            start++\\n        }else if(sum>c){\\n            end--\\n        }else{\\n            return true\\n        }\\n    }\\n    return false\\n    \\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2212784,
                "title": "java-and-python-two-pointers-easy-reading",
                "content": "# JAVA\\n```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        long r=(int)Math.sqrt(c);\\n        while(l<=r){\\n            if(l*l+r*r==c){\\n                return true;\\n            }\\n            else if(l*l+r*r>c){\\n                r-=1;\\n            }\\n            else{\\n                l+=1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```\\n# PYTHON\\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l=0\\n        r=int(math.sqrt(c))\\n        while(l<=r):\\n            if l*l+r*r==c:\\n                return True\\n            elif(l*l+r*r>c):\\n                r-=1\\n            else:\\n                l+=1\\n        return False\\n        \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        long r=(int)Math.sqrt(c);\\n        while(l<=r){\\n            if(l*l+r*r==c){\\n                return true;\\n            }\\n            else if(l*l+r*r>c){\\n                r-=1;\\n            }\\n            else{\\n                l+=1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def judgeSquareSum(self, c: int) -> bool:\\n        l=0\\n        r=int(math.sqrt(c))\\n        while(l<=r):\\n            if l*l+r*r==c:\\n                return True\\n            elif(l*l+r*r>c):\\n                r-=1\\n            else:\\n                l+=1\\n        return False\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1644885,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1567310,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1838239,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 2036405,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1914661,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1766859,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1714057,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1960217,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 2060072,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 2060067,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1644885,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1567310,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1838239,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 2036405,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1914661,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1766859,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1714057,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 1960217,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 2060072,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            },
            {
                "id": 2060067,
                "content": [
                    {
                        "username": "Kashif_Rahman",
                        "content": "1) Simply do two pointer where start is 0 and the end is sqrt of c(as we have to iterate till sqrt of c ).\n2) If sum (a^2+b^2) is equal to the sum then return true ;\n3) Else if sum is greater than c then decrease the end ;\n4) Else if sum is smaller than c then increase then start;\n\n"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "[@sdjkdghkusd](/sdjkdghkusd)  you should also check for 2 times the l**2 == target and same for the right then only this will execute"
                    },
                    {
                        "username": "RavindraKumar",
                        "content": "[@Shahrukh15](/Shahrukh15) class Solution {\\npublic:\\n    bool judgeSquareSum(int c) {\\n\\n\\n        double l=0;\\nint r=sqrt(c);\\ndouble sum=0;\\n\\n\\nwhile(l<=r){\\nsum=l*l+r*r;\\nif(sum==c){\\nreturn true;\\n}else if(sum>c){\\nr--;\\n}else{\\nl++;\\n}\\n}\\nreturn false;\\n        \\n    }\\n};\\n\\n\\nYour logic is correct bro but you will get integer overflow if you use int as sum"
                    },
                    {
                        "username": "sdjkdghkusd",
                        "content": "I followed this approach but one only 124 test cases are passed out of 127.\\nHere is my code.\\nclass Solution {\\n    public boolean judgeSquareSum(int c) {\\n        int l=0;\\n        int r=(int)Math.sqrt(c);\\n        int sum=0;\\n        while(l<=r){\\n            sum=l*l+r*r;\\n            if(sum==c){\\n                 return true;\\n            }else if(sum>c){\\n                r--;\\n            }else{\\n                l++;\\n            }\\n        }\\n       return false;\\n\\n    }\\n}\\n\\nCan you please Point out where is an error ?"
                    },
                    {
                        "username": "piaofu",
                        "content": "https://en.wikipedia.org/wiki/Fermat%27s_theorem_on_sums_of_two_squares\\n\\n`c = a^2 + b^2` if and only if all the prime factor of `c` that can be written as `4k+3` have even power.\\n`c = a^2 + b^2` \\u5F53\\u4E14\\u4EC5\\u5F53 `c` \\u7684\\u6240\\u6709 `4k+3` \\u578B\\u7D20\\u56E0\\u5B50\\u5E42\\u6B21\\u5747\\u4E3A\\u5076\\u6570\\u3002\\n"
                    },
                    {
                        "username": "HIMANSHU73",
                        "content": "You should write in English so that everyone is able to understand it."
                    },
                    {
                        "username": "prerna2798",
                        "content": "The description needs to be improved, please mention that a == b is also possible and a,b >= 0."
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "yes they need to improve the description... "
                    },
                    {
                        "username": "avsssai",
                        "content": "a can be equal to b, \\nthat explain true for test case c = 2.\\n1 square + 1 square"
                    },
                    {
                        "username": "Mamun429",
                        "content": "if c = 4 how can it be true?\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "2 squared + 0 squared"
                    },
                    {
                        "username": "Nikhil10i",
                        "content": "yes"
                    },
                    {
                        "username": "LeoCy",
                        "content": "0 is also int"
                    },
                    {
                        "username": "HA_RI",
                        "content": "int i=0;\\n        int j=sqrt(c);\\n        while(i<=j){\\n            long  sum=pow(i,2)+pow(j,2);\\n            if(sum==c)\\n            return true;\\n            else if(sum>c)\\n          j--;\\n          else\\n          i++;\\n        }\\n        return false;\\n      "
                    },
                    {
                        "username": "Sar2580P",
                        "content": "c =2147483647\\nif i run this test_case for fermat_theorem code , it is giving TLE , but when i submit the code ,it is accepted\\n\\nHow\\'s this possible ?"
                    },
                    {
                        "username": "adiraj04",
                        "content": "you might have entered wrong result in custom test case"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "begin two pointers with \\nlow=0\\nhigh=sqrt(c)\\nwhy sqrt(C)? because it will reduce time complexity and (a,b) will always lie before sqrt(c) .\\nif we iterate for (a,b)>sqrt(c) then the sum of their sqares will always be greater than c.\\nthe we use two pointers approach to find the answer.\\nplease upvote."
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could someone please explain me why we can\\'t use the binary search here . This code is giving me correct outputs in online compilers but in leetcode compiler it is showing as time limit exceeded error\\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n     int i=0;\\n     int rem=c;\\n     int mid=0;\\n     int sum=-1;\\n    while(i<=rem){\\n        mid=(i+rem)/2 ;\\n        if(mid*mid >c){\\n        rem=mid-1;\\n        continue;\\n        }\\n        if(mid*mid<c){\\n            sum=c-mid*mid ;\\n            int a=(int)Math.sqrt(sum);\\n            if(a*a==sum)\\n            return true;\\n            else\\n            i=mid+1;\\n        }\\n    }\\n    return false;\\n\\t}\\n}"
                    },
                    {
                        "username": "sai_krishna_",
                        "content": "could anyone explain me why we need to use long type of variable to store the values .This is the code \\n\\nclass Solution {\\n\\tpublic boolean judgeSquareSum(int c) {\\n        for(long i=0;i*i<=c ; i++){\\n            long a=(int)Math.sqrt(c-i*i) ;\\n            if(a*a==c-i*i)\\n            return true;\\n        }\\n        return false;\\n\\t}\\n}\\nwhy i am getting error if i use int datatype instead of long datatype ."
                    }
                ]
            }
        ]
    }
]