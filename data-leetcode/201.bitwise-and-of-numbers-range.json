[
    {
        "title": "Bitwise AND of Numbers Range",
        "question_content": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n&nbsp;\nExample 1:\n\nInput: left = 5, right = 7\nOutput: 4\n\nExample 2:\n\nInput: left = 0, right = 0\nOutput: 0\n\nExample 3:\n\nInput: left = 1, right = 2147483647\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t0 <= left <= right <= 231 - 1",
        "solutions": [
            {
                "id": 56729,
                "title": "bit-operation-solution-java",
                "content": "The idea is very simple: \\n\\n1. last bit of (odd number & even number) is 0.   \\n2. when m != n, There is at least an odd number and an even number, so the last bit position result is 0.   \\n3. Move m and n rigth a position.\\n\\nKeep doing step 1,2,3 until m equal to n, use a factor to record the iteration time.\\n\\n    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            if(m == 0){\\n                return 0;\\n            }\\n            int moveFactor = 1;\\n            while(m != n){\\n                m >>= 1;\\n                n >>= 1;\\n                moveFactor <<= 1;\\n            }\\n            return m * moveFactor;\\n        }\\n    }\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            if(m == 0){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 593317,
                "title": "simple-3-line-java-solution-faster-than-100",
                "content": "The trick here is that :\\n**Bitwise-AND of any two numbers will always produce a number less than or equal to the smaller number.**\\n\\nConsider the following example:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t12 ---- 1100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t11 ---- 1011\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t10 ---- 1010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t9  ---- 1001\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t8  ---- 1000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t7  ---- 0111\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t6  ---- 0110\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t5  ---- 0101\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nDesired Range: [5,12]\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\nStarting from 12, the loop will first do \\n12 & 11 = 8\\n\\nNext iteration, the loop will do \\n8 & 7 = 0\\n\\nwhy did we skip anding of 10,9? Because even if we did so, the result would eventually be anded with 8 whose value would be lesser than equal to 8. \\n\\nHence, you start from the range end and keep working your way down the range till you reach the start. \\n\\n```\\n while(n>m)\\n           n = n & n-1;\\n return m&n;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n while(n>m)\\n           n = n & n-1;\\n return m&n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56746,
                "title": "one-line-c-solution",
                "content": "   Consider the bits from low to high. if n > m, the lowest bit will be 0, and then we could transfer the problem to sub-problem:  rangeBitwiseAnd(m>>1, n>>1).  \\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n    }",
                "solutionTags": [],
                "code": "   Consider the bits from low to high. if n > m, the lowest bit will be 0, and then we could transfer the problem to sub-problem:  rangeBitwiseAnd(m>>1, n>>1).  \\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56719,
                "title": "java-python-easy-solution-with-explanation",
                "content": "First let's think what does bitwise AND do to two numbers, for example ( 0b means base 2)\\n\\n    4 & 7 = 0b100 & 0b111 = 0b100\\n    5 & 7 = 0b101 & 0b111 = 0b101\\n    5 & 6 = 0b101 & 0b110 = 0b100\\n\\nThe operator & is keeping those bits which is set in both number.\\n\\nFor several numbers, the operator & is keeping those bits which is 1 in every number.\\n\\nIn other word, a bit is 0 in any number will result in 0 in the answer's corresponding bit.\\n\\nNow consider a range \\n\\n    [m = 0bxyz0acd, n=0bxyz1rst]\\n\\nhere xyzpacdrst all are digits in base 2.\\n\\nWe can find two numbers that are special in the range [m, n]\\n\\n    (1) m' = 0bxyz0111\\n    (2) n' = 0bxyz1000\\n\\nThe bitwise AND of all the numbers in range [m, n] is just the bitwise AND of the two special number\\n\\n    rangeBitwiseAnd(m, n) = m' & n' = 0bxyz0000\\n\\nThis tells us, the bitwise and of the range is keeping the common bits of m and n from left to right until the first bit that they are different, padding zeros for the rest. \\n\\n**Java**\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int i = 0;\\n        for (; m != n; ++i) {\\n            m >>= 1;\\n            n >>= 1;\\n        }\\n        return n << i;\\n    }\\n\\n    // 8266 / 8266 test cases passed.\\n    // Status: Accepted\\n    // Runtime: 8 ms\\n\\n**Python**\\n\\n    def rangeBitwiseAnd(self, m, n):\\n        i = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            i += 1\\n        return n << i\\n\\n    # 8266 / 8266 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 208 ms",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "First let's think what does bitwise AND do to two numbers, for example ( 0b means base 2)\\n\\n    4 & 7 = 0b100 & 0b111 = 0b100\\n    5 & 7 = 0b101 & 0b111 = 0b101\\n    5 & 6 = 0b101 & 0b110 = 0b100\\n\\nThe operator & is keeping those bits which is set in both number.\\n\\nFor several numbers, the operator & is keeping those bits which is 1 in every number.\\n\\nIn other word, a bit is 0 in any number will result in 0 in the answer's corresponding bit.\\n\\nNow consider a range \\n\\n    [m = 0bxyz0acd, n=0bxyz1rst]\\n\\nhere xyzpacdrst all are digits in base 2.\\n\\nWe can find two numbers that are special in the range [m, n]\\n\\n    (1) m' = 0bxyz0111\\n    (2) n' = 0bxyz1000\\n\\nThe bitwise AND of all the numbers in range [m, n] is just the bitwise AND of the two special number\\n\\n    rangeBitwiseAnd(m, n) = m' & n' = 0bxyz0000\\n\\nThis tells us, the bitwise and of the range is keeping the common bits of m and n from left to right until the first bit that they are different, padding zeros for the rest. \\n\\n**Java**\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int i = 0;\\n        for (; m != n; ++i) {\\n            m >>= 1;\\n            n >>= 1;\\n        }\\n        return n << i;\\n    }\\n\\n    // 8266 / 8266 test cases passed.\\n    // Status: Accepted\\n    // Runtime: 8 ms\\n\\n**Python**\\n\\n    def rangeBitwiseAnd(self, m, n):\\n        i = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            i += 1\\n        return n << i\\n\\n    # 8266 / 8266 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 208 ms",
                "codeTag": "Python3"
            },
            {
                "id": 56721,
                "title": "2-line-solution-the-fastest-with-detailed-explanation",
                "content": "public int rangeBitwiseAnd(int m, int n) {\\n            while(m<n) n = n & (n-1);\\n            return n;\\n        }\\n\\nThe key point:  reduce n by removing the rightest '1' bit until n<=m;\\n\\n\\n**(1)if n>m**,suppose m = yyyzzz, n = xxx100, because m is less than n, m can be equal to three cases:\\n\\n    (a) xxx011 (if yyy==xxx)\\n    (b) less than xxx011 (if yyy==xxx)\\n    (c) yyyzzz (if yyy<xxx)\\n   \\n   for case (a), and (b), xxx011 will always be ANDed to the result, which results in xxx011 & xxx100 = uuu000(uuu == yyy&xxx == xxx);\\n\\n   for case (c), xxx000/xxx011 will always be ANDed to the result, which results in yyyzzz & xxx000 & xxx011 & xxx100 = uuu000 (uuu <= yyy & xxx)\\n \\n   => for any case, you will notice that: rangBitWiseAnd(vvvzzz,xxx100) == **uuu000** == rangBitWiseAnd(vvvzzz,xxx000), (not matter what the value of\"uuu\" will be, the last three digits will be all zero)\\n\\n   => This is why the rightest '1' bit can be removed by : n = n & (n-1);\\n  \\n    \\n**(2)when n==m,** obviously n is the result.\\n\\n **(3)when n < m**, suppose we reduce n from rangBitWiseAnd(yyyzzz,xxx100) to rangBitWiseAnd(yyyzzz,xxx000);\\n\\n  i)  xxx100 >yyyzzz => xxx >= yyy;\\n\\n  ii) xxx000 < yyyzzz => xxx <= yyy;\\n\\n=> xxx == yyy;\\n\\n=> rangBitWiseAnd(yyyzzz,xxx000) == rangeBitWiseAnd(xxxzzz,xxx000); \\n\\n=>result is xxx000, which is also n;",
                "solutionTags": [],
                "code": "public int rangeBitwiseAnd(int m, int n) {\\n            while(m<n) n = n & (n-1);\\n            return n;\\n        }\\n\\nThe key point:  reduce n by removing the rightest '1' bit until n<=m;\\n\\n\\n**(1)if n>m**,suppose m = yyyzzz, n = xxx100, because m is less than n, m can be equal to three cases:\\n\\n    (a) xxx011 (if yyy==xxx)\\n    (b) less than xxx011 (if yyy==xxx)\\n    (c) yyyzzz (if yyy<xxx)\\n   \\n   for case (a), and (b), xxx011 will always be ANDed to the result, which results in xxx011 & xxx100 = uuu000(uuu == yyy&xxx == xxx);\\n\\n   for case (c), xxx000/xxx011 will always be ANDed to the result, which results in yyyzzz & xxx000 & xxx011 & xxx100 = uuu000 (uuu <= yyy & xxx)\\n \\n   => for any case, you will notice that: rangBitWiseAnd(vvvzzz,xxx100) == **uuu000** == rangBitWiseAnd(vvvzzz,xxx000), (not matter what the value of\"uuu\" will be, the last three digits will be all zero)\\n\\n   => This is why the rightest '1' bit can be removed by : n = n & (n-1);\\n  \\n    \\n**(2)when n==m,** obviously n is the result.\\n\\n **(3)when n < m**, suppose we reduce n from rangBitWiseAnd(yyyzzz,xxx100) to rangBitWiseAnd(yyyzzz,xxx000);\\n\\n  i)  xxx100 >yyyzzz => xxx >= yyy;\\n\\n  ii) xxx000 < yyyzzz => xxx <= yyy;\\n\\n=> xxx == yyy;\\n\\n=> rangBitWiseAnd(yyyzzz,xxx000) == rangeBitWiseAnd(xxxzzz,xxx000); \\n\\n=>result is xxx000, which is also n;",
                "codeTag": "Unknown"
            },
            {
                "id": 592288,
                "title": "100-memory-c-solution-with-explanation",
                "content": "We are given range of numbers m to n. We are asked to find the bitwise and in the given range [m,n].\\nA simple solution would be to go from m to n and do a bitwise and given as following:\\t\\n\\t\\n\\tint and=0;\\n\\tfor (m;m<=n;m++)\\n\\t     {\\n\\t\\t and&=m;\\n\\t\\t }\\n\\t\\t \\nBut the solution is not effective and efficient for large range of numbers. \\nSo we use bit manipulations for solving this problem.\\nConsider the case where range is given as [5,7].\\nThe representation is given as following:\\n5 - 0101 \\n6 - 0110\\n7 - 0111\\nsince we are dealing with and(&) operator any presence of 0 with a 1 gives 0. We loop through the binary representation and in the lsbs of elements m and n if there is a 0 and a 1 then the resultant value is 0, so we shift the elements right till there are equal and count the increments made i.e for each of the shift till both the numbers become equal. When both elements m and n are equal we get the value in the lsb as 1. From the above binary representation of the numbers and range we make the following observations:\\n    1. The third bit from lsb is common for all the three numbers in the range.\\n    2. There are zeros in the first and second positions from the lsb so the resultant value will be 0 in that postion.\\n  Count is a variable wich keeps a track of number of zeros from the lsb to the case of m==n.\\n  \\n  The code is as following \\n```\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n         int count=0;\\n       // simple solution is to do bitwise and and return the sum. \\n      //     for(int i=m;i<=n;i++)\\n      //               sum&=i;        \\n\\t\\t //      return sum;\\n        while(m!=n)  // see till both numbers are equal\\n        {   // right shift both numbers by 1\\n            m>>=1; \\n            n>>=1;\\n            count++;  // increment the count.\\n        }\\n\\t\\t//count gives the number of zero places from the lsb so left shift m by count.\\n        return m<<count;\\n    }\\n\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t",
                "solutionTags": [],
                "code": "We are given range of numbers m to n. We are asked to find the bitwise and in the given range [m,n].\\nA simple solution would be to go from m to n and do a bitwise and given as following:\\t\\n\\t\\n\\tint and=0;\\n\\tfor (m;m<=n;m++)\\n\\t     {\\n\\t\\t and&=m;\\n\\t\\t }\\n\\t\\t \\nBut the solution is not effective and efficient for large range of numbers. \\nSo we use bit manipulations for solving this problem.\\nConsider the case where range is given as [5,7].\\nThe representation is given as following:\\n5 - 0101 \\n6 - 0110\\n7 - 0111\\nsince we are dealing with and(&) operator any presence of 0 with a 1 gives 0. We loop through the binary representation and in the lsbs of elements m and n if there is a 0 and a 1 then the resultant value is 0, so we shift the elements right till there are equal and count the increments made i.e for each of the shift till both the numbers become equal. When both elements m and n are equal we get the value in the lsb as 1. From the above binary representation of the numbers and range we make the following observations:\\n    1. The third bit from lsb is common for all the three numbers in the range.\\n    2. There are zeros in the first and second positions from the lsb so the resultant value will be 0 in that postion.\\n  Count is a variable wich keeps a track of number of zeros from the lsb to the case of m==n.\\n  \\n  The code is as following \\n```\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n         int count=0;\\n       // simple solution is to do bitwise and and return the sum. \\n      //     for(int i=m;i<=n;i++)\\n      //               sum&=i;        \\n\\t\\t //      return sum;\\n        while(m!=n)  // see till both numbers are equal\\n        {   // right shift both numbers by 1\\n            m>>=1; \\n            n>>=1;\\n            count++;  // increment the count.\\n        }\\n\\t\\t//count gives the number of zero places from the lsb so left shift m by count.\\n        return m<<count;\\n    }\\n\\t\\t \\n\\t\\t \\n\\t\\t \\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 56753,
                "title": "accepted-c-solution-with-simple-explanation",
                "content": "    int rangeBitwiseAnd(int m, int n) {\\n    \\tint c=0;\\n    \\twhile(m!=n){\\n    \\t\\tm>>=1;\\n    \\t\\tn>>=1;\\n    \\t\\t++c;\\n    \\t}\\n    \\treturn n<<c;\\n    }\\n\\n----------\\n\\nthe result of a range bitwise is the common 'left header' of m and n.",
                "solutionTags": [],
                "code": "    int rangeBitwiseAnd(int m, int n) {\\n    \\tint c=0;\\n    \\twhile(m!=n){\\n    \\t\\tm>>=1;\\n    \\t\\tn>>=1;\\n    \\t\\t++c;\\n    \\t}\\n    \\treturn n<<c;\\n    }\\n\\n----------\\n\\nthe result of a range bitwise is the common 'left header' of m and n.",
                "codeTag": "Unknown"
            },
            {
                "id": 56845,
                "title": "my-simple-java-solution-3-lines",
                "content": "The idea is to use a mask to find the leftmost common digits of m and n. \\nExample: m=1110001, n=1110111, and you just need to find 1110000 and it will be the answer.\\n\\n    public class Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int r=Integer.MAX_VALUE;\\n        while((m&r)!=(n&r))  r=r<<1;\\n        return n&r;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int r=Integer.MAX_VALUE;\\n        while((m&r)!=(n&r))  r=r<<1;\\n        return n&r;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1513866,
                "title": "c-super-simple-intuitive-explained-solution-different-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        // edge case - zero AND anything will always stay zero\\n        if ((m == 0) || (n == 0)) return 0;\\n        \\n        // if there is a different amount of digits in binary - always will be zero\\n        if ((int)log2(m) != (int)log2(n)) return 0;\\n        \\n        // None of the above - not too many numbers left to calculate one by one...\\n        int res = m;\\n        for (long i = m; i <= n; i++)\\n            res &= i;\\n                \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        // edge case - zero AND anything will always stay zero\\n        if ((m == 0) || (n == 0)) return 0;\\n        \\n        // if there is a different amount of digits in binary - always will be zero\\n        if ((int)log2(m) != (int)log2(n)) return 0;\\n        \\n        // None of the above - not too many numbers left to calculate one by one...\\n        int res = m;\\n        for (long i = m; i <= n; i++)\\n            res &= i;\\n                \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56849,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int diffBits = 0;\\n            while (m != n) {\\n                m >>= 1;\\n                n >>= 1;\\n                diffBits++;\\n            }\\n            return n<<diffBits;\\n        }\\n    }\\n\\nIt's a problem that can be reduced to find the same prefix of the numbers in this range.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int diffBits = 0;\\n            while (m != n) {\\n                m >>= 1;\\n                n >>= 1;\\n                diffBits++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 593403,
                "title": "bit-masks-no-loops",
                "content": "The approach outlined here constructs a mask of all bits that the numbers between `m` and `n` would zero when AND\\'ed together. It then ANDs this with `m & n` to get the result. This requires no loops and a small number of operations.\\n\\n## Brute force\\n\\nThe brute force solution is to iterate through all the numbers and perform the bitwise AND on the result.\\n\\n```python\\nresult = m\\n# n + 1 as the problem statement is inclusive of n\\nfor x in range(m + 1, n + 1):\\n    result &= x\\nreturn x\\n```\\n\\n## Creating a mask\\n\\nInstead of doing this, we can take the AND with `n` directly as a first step:\\n\\n```python\\nresult = m & n\\n```\\n\\nBut what about all the numbers in between `m` and `n`?\\n\\nRecall that the ith bit will change every 2^i increments. For example, the `i = 0` bit changes for every 2^0 = 1 you add:\\n\\n```\\n00\\n# Added 2^0, flip the i = 0 bit\\n01\\n# Added 2^0, flip the i = 0 bit again\\n11\\n# Added 2^0, flip the i = 0 bit again\\n10\\n```\\n\\nThe `i = 1` bit changes every 2^1 = 2 you add:\\n\\n```\\n000\\n001\\n# Added 2^1, flip the i = 1 bit\\n010\\n011\\n# Added 2^1, flip the i = 1 bit again\\n100\\n101\\n# Added 2^1, flip the i = 1 bit again\\n110\\n111\\n```\\n\\n**If there is a number `m + 2^i` in between `m` and `n`, the ith bit will be flipped**. This is the key of this solution.\\n\\nBecause we perform a bitwise AND with _every_ number in between `m` and `n`, _any_ flip of the ith bit means the ith bit in the final result will also be zero: it will either be zero in `m` to start with, or it will be one to start with and it will flip _at least once_ from 1 to 0 after we\\'ve added 2^i. The bitwise AND will pick up the flip to zero and it will \\'stick\\' in the result.\\n\\nPutting all this together, the most significant bit of the _difference_ between `m` and `n` gives us the highest bit at which all bits will become zero.\\n\\nAs an example, take `m = 5` and `n = 7`. This gives:\\n\\n```\\nm = 101\\nn = 111\\ndifference = 010\\n```\\n\\nThe difference is 2. This means the `i = 0` bit will flip, because `difference >= 2**0`, and the `i = 1` bit will also flip, because `difference >= 2**1`. The `i = 2` bit will not flip because `difference < 2**2`.\\n\\nWe can find the index of the most significant by taking the base-2 logarithm.\\n\\n```python\\nimport math\\n\\ndifference = n - m\\nmsb = math.floor(math.log2(difference))\\n```\\n\\nThen we just need to create a mask out of this so that we can zero all bits at and below this index in the result.\\n\\nOne technique is to shift the most-significant bit up one place and then subtract one, leaving all ones. For example when the the difference is 2:\\n\\n```\\ndifference = 2\\n# msb is 010\\nmsb = 1 << 2\\n# Shift up by one to get 100, then subtract one to get 011\\nbits_to_remove = (msb << 1) - 1\\n```\\n\\nWe now have a mask of all bits which the numbers between `m` and `n` will flip.\\n\\nAll that\\'s left to do is zero these bits in the result. To do this, we can just invert the mask and AND it with the `m & n` we had previously.\\n\\n```\\n# bits_to_remove was 011, so the inverse is 100\\nresult &= ~bits_to_remove\\n```\\n\\n## Final solution\\n\\nAfter taking care of the trivial case `m` = `n`, compute the difference and the mask, and then AND together `m`, `n`, and the mask.\\n\\n```\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n    if m == n:\\n\\t    return m\\n\\tdifference = n - m\\n\\tmsb = 1 << math.floor(math.log2(difference))\\n\\tbits_to_remove = (msb << 1) - 1\\n\\treturn m & n & ~bits_to_remove\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```python\\nresult = m\\n# n + 1 as the problem statement is inclusive of n\\nfor x in range(m + 1, n + 1):\\n    result &= x\\nreturn x\\n```\n```python\\nresult = m & n\\n```\n```\\n00\\n# Added 2^0, flip the i = 0 bit\\n01\\n# Added 2^0, flip the i = 0 bit again\\n11\\n# Added 2^0, flip the i = 0 bit again\\n10\\n```\n```\\n000\\n001\\n# Added 2^1, flip the i = 1 bit\\n010\\n011\\n# Added 2^1, flip the i = 1 bit again\\n100\\n101\\n# Added 2^1, flip the i = 1 bit again\\n110\\n111\\n```\n```\\nm = 101\\nn = 111\\ndifference = 010\\n```\n```python\\nimport math\\n\\ndifference = n - m\\nmsb = math.floor(math.log2(difference))\\n```\n```\\ndifference = 2\\n# msb is 010\\nmsb = 1 << 2\\n# Shift up by one to get 100, then subtract one to get 011\\nbits_to_remove = (msb << 1) - 1\\n```\n```\\n# bits_to_remove was 011, so the inverse is 100\\nresult &= ~bits_to_remove\\n```\n```\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n    if m == n:\\n\\t    return m\\n\\tdifference = n - m\\n\\tmsb = 1 << math.floor(math.log2(difference))\\n\\tbits_to_remove = (msb << 1) - 1\\n\\treturn m & n & ~bits_to_remove\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 56803,
                "title": "share-my-simple-java-solution",
                "content": "The little trick is to return the left common parts of two numbers.  When not equal, move right for 1 bit, util equal, return the common parts.\\n \\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n            int count = 0;\\n    \\t\\twhile(m != n){\\n    \\t\\t\\tm >>= 1;\\n    \\t\\t\\tn >>= 1;\\n    \\t\\t\\tcount++;\\n    \\t\\t}\\n    \\t\\treturn m<<=count;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The little trick is to return the left common parts of two numbers.  When not equal, move right for 1 bit, util equal, return the common parts.\\n \\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n            int count = 0;\\n    \\t\\twhile(m != n){\\n    \\t\\t\\tm >>= 1;\\n    \\t\\t\\tn >>= 1;\\n    \\t\\t\\tcount++;\\n    \\t\\t}\\n    \\t\\treturn m<<=count;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 56827,
                "title": "fast-three-line-c-solution-and-explanation-with-no-loops-or-recursion-and-one-extra-variable",
                "content": "Whenever a bit changes when counting from `m` to `n`, that bit will be 0 in the AND of the range. So we consider the XOR `x` of `m` and `n`. The leftmost 1 bit in `x` is the last bit that changes at some point when counting from `m` to `n`. This bit and the bits to the right of it are all 0 in the AND of the range. We can easily fill all the bits to the right of that bit with 1s using the OR operations below to create a mask. This technique \"smears\" the 1 bits in `x` to the right. Then it's just a matter of returning the rest of `m` excluding those bits (the bits in `m` that did not change when counting up to `n`), which is precisely the AND of the range from `m` to `n`.\\n\\n    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            unsigned int x = m ^ n;\\n            x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, x |= x >> 16;\\n            return m & ~x;  \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            unsigned int x = m ^ n;\\n            x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, x |= x >> 16;\\n            return m & ~x;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1514018,
                "title": "python-o-log-n-short-solution-explained",
                "content": "The key observation here is that if binary length of numbers is different, then the answer is equal to zero. If lengths are equal, we remove the first symbol (which is \\u201C1\\u201D) and do recursion. Basically, for two binary numbers `a1...an` and `b1...bn` the answer will be the common prefix and the rest are zeros.\\n\\n#### Complexity\\nIt is `O(log n)` both for time and space.\\n\\n#### Code\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m, n):\\n        if n == m or m == 0:\\n            return m\\n        elif len(bin(m)) != len(bin(n)):\\n            return 0\\n        else:\\n            pref = 1<<(len(bin(m))-3)\\n            return pref ^ self.rangeBitwiseAnd(m - pref, n - pref)\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m, n):\\n        if n == m or m == 0:\\n            return m\\n        elif len(bin(m)) != len(bin(n)):\\n            return 0\\n        else:\\n            pref = 1<<(len(bin(m))-3)\\n            return pref ^ self.rangeBitwiseAnd(m - pref, n - pref)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593298,
                "title": "python-o-log-n-find-common-prefix",
                "content": "Suppose `S` is the bit string of `n` and `T` is the bit string of `m`. Then the answer\\'s bit string is the `common_prefix(S, T)` padding the rest bits with `0`. \\n\\nProof:\\nWe can set both `S` and `T` with a fixed length of `32` by padding multiple leading `0`.\\nLet `P` to be the common prefix. Then the range of number is `[P + [0] + S1, P + [1] + S2]` as the first bit follows `P` are different with `S` and `T`.\\nLet `k = len(S1)` and this range must include `P + [0] + [1] * k` and `P + [1] + [0] * k`. And these two values make bitwise AND produce a `P + [0] * (k+1)`. And this make the entire Bitwise AND to be `P + [0] * (k+1)`.\\n\\n```\\ndef rangeBitwiseAnd(m, n):\\n    k = 0\\n    while n != m:\\n        n >>= 1\\n        m >>= 1\\n        k += 1\\n    return n << k\\n```\\nOne line recursive way\\n```\\ndef rangeBitwiseAnd(m, n):\\n    return rangeBitwiseAnd(m >> 1, n >> 1) << 1 if m != n else m\\n```",
                "solutionTags": [],
                "code": "```\\ndef rangeBitwiseAnd(m, n):\\n    k = 0\\n    while n != m:\\n        n >>= 1\\n        m >>= 1\\n        k += 1\\n    return n << k\\n```\n```\\ndef rangeBitwiseAnd(m, n):\\n    return rangeBitwiseAnd(m >> 1, n >> 1) << 1 if m != n else m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 56793,
                "title": "8line-c-simple-clear-solution",
                "content": "        class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            while(m!=n){\\n                m=m>>1;\\n                n=n>>1;\\n                ++i;        \\n            }\\n            return m<<i;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            while(m!=n){\\n                m=m>>1;\\n                n=n>>1;\\n                ++i;        \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 56735,
                "title": "java-8-ms-one-liner-o-log-32-no-loop-no-explicit-log",
                "content": "    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & ~((Integer.highestOneBit(m ^ n) << 1) - 1);\\n    }\\n\\nThe idea here is pretty simple: when we go from `m` to `n` some higher part may remain the same. The lower part changes. If we take the highest bit that is different, then it must be true that it is `1` in `n` and `0` in `m`, simply because `n` is larger than `m`. That means that at some point it went from `0` to `1`, and at that very point the lower digits must have all turned to zeroes, just like it happens in decimal when we go up to 1000 from 999. That means that all lower bits will be zero in the result. The differing bit will also be zero for obvious reasons. The higher part (if any) will remain as it is because it didn\\'t change at all.\\n\\nTherefore, we take that differing bit (`Integer.highestOneBit(m ^ n)`) and then create a mask that fills the whole thing with `1` to the right, including that bit. We achieve that by shifting that bit left (we can do it because we know that `n < Integer.MAX_VALUE`), then we subtract `1` so that bit goes to zero and everything to the right turns into ones. Then we bit-reverse the mask and apply it either to `m` or to `n`, doesn\\'t matter because the higher part is identical.\\n\\nUnfortunately, that doesn\\'t quite work when `m == n` because then `m ^ n` will be zero and we\\'ll end up zeroing the whole thing.\\n\\nBut it doesn\\'t end here. As noted by @gorokhovsky in a comment below, we don\\'t even have to shift the mask at all, but then we\\'ll *have* to apply it to `m`. We can do this because we know that the highest differing bit is zero in `m`, so it doesn\\'t really matter whether it\\'s zero or one in the mask. This leads to the following solution:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & ~(Integer.highestOneBit(m ^ n) - 1);\\n    }\\n\\nNow, if you have a good understanding of two\\'s complement, you should instantly recognize that `~(something - 1)` is just `something` negated, which leads us to @gorokhovsky\\'s solution, refactored into one-liner:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & -Integer.highestOneBit(m ^ n);\\n    }\\n\\n\\nIn case anyone feels like using `Integer.highestOneBit` is cheating, here is it\\'s code, from the standard Java library:\\n\\n        i |= (i >>  1);\\n        i |= (i >>  2);\\n        i |= (i >>  4);\\n        i |= (i >>  8);\\n        i |= (i >> 16);\\n        return i - (i >>> 1);\\n\\nDoesn\\'t look *that* complicated, does it? (If you think it does, look at `Integer.reverse` or something.)\\n\\nWhat happens here is that we first OR bit pair-wise. If any bit was `1` to begin with or had `1` to the left, it will now be `1`. Then we do the same thing with resulting pairs. Now every bit will be `1` if at least one of the following is true:\\n\\n- it was `1` to begin with;\\n- its left neighbor was `1` (so it became `1` on the previous step);\\n- its next left neighbor was `1` (because now we OR exactly with this next neighbor);\\n- its next-next left neighbor was `1` (because now we OR exactly with this next neighbor and that neighbor was ORed with its neighbor on the previous step).\\n\\nSo each *ith* bit will be `1` if at least of the bits `i + 1`, `i + 2`, `i + 3` was `1`. Note that the code uses signed shifting, but it doesn\\'t really matter because if `i` is negative we\\'ll fill everything with `1` anyway.\\n\\nBy repeating this process we finally have a mask that fills everything with `1` from the highest bit and to the right. By shifting it and subtracting we get the highest bit. Speaking of which, looks like we can use this code directly to solve our problem, although it won\\'t be a one-liner any more:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        if (m == n) {\\n            return m;\\n        }\\n        int i = m ^ n;\\n        i |= (i >>> 1);\\n        i |= (i >>> 2);\\n        i |= (i >>> 4);\\n        i |= (i >>> 8);\\n        i |= (i >>> 16);\\n        return m & ~i;\\n    }\\n\\nOne advantage in writing the code like this is that the complexity becomes clearer. Note that we have 5 shifts here. 5 is because we use 32-bit integers. If we had `long` instead of `int`, we\\'d need 6 shifts. 32 and 64 are 5th and 6th powers of 2. Therefore, the complexity is `O(log p)`, where `p` is the number of binary digits, which is 32 in our case, but if we used arbitrary length numbers, then it\\'d be something like `O(log(log(max(m, n))))` or `O(log(log(m+n)))` for simplicity because it\\'s of the same order anyway.",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & ~((Integer.highestOneBit(m ^ n) << 1) - 1);\\n    }\\n\\nThe idea here is pretty simple: when we go from `m` to `n` some higher part may remain the same. The lower part changes. If we take the highest bit that is different, then it must be true that it is `1` in `n` and `0` in `m`, simply because `n` is larger than `m`. That means that at some point it went from `0` to `1`, and at that very point the lower digits must have all turned to zeroes, just like it happens in decimal when we go up to 1000 from 999. That means that all lower bits will be zero in the result. The differing bit will also be zero for obvious reasons. The higher part (if any) will remain as it is because it didn\\'t change at all.\\n\\nTherefore, we take that differing bit (`Integer.highestOneBit(m ^ n)`) and then create a mask that fills the whole thing with `1` to the right, including that bit. We achieve that by shifting that bit left (we can do it because we know that `n < Integer.MAX_VALUE`), then we subtract `1` so that bit goes to zero and everything to the right turns into ones. Then we bit-reverse the mask and apply it either to `m` or to `n`, doesn\\'t matter because the higher part is identical.\\n\\nUnfortunately, that doesn\\'t quite work when `m == n` because then `m ^ n` will be zero and we\\'ll end up zeroing the whole thing.\\n\\nBut it doesn\\'t end here. As noted by @gorokhovsky in a comment below, we don\\'t even have to shift the mask at all, but then we\\'ll *have* to apply it to `m`. We can do this because we know that the highest differing bit is zero in `m`, so it doesn\\'t really matter whether it\\'s zero or one in the mask. This leads to the following solution:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & ~(Integer.highestOneBit(m ^ n) - 1);\\n    }\\n\\nNow, if you have a good understanding of two\\'s complement, you should instantly recognize that `~(something - 1)` is just `something` negated, which leads us to @gorokhovsky\\'s solution, refactored into one-liner:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        return m == n ? m : m & -Integer.highestOneBit(m ^ n);\\n    }\\n\\n\\nIn case anyone feels like using `Integer.highestOneBit` is cheating, here is it\\'s code, from the standard Java library:\\n\\n        i |= (i >>  1);\\n        i |= (i >>  2);\\n        i |= (i >>  4);\\n        i |= (i >>  8);\\n        i |= (i >> 16);\\n        return i - (i >>> 1);\\n\\nDoesn\\'t look *that* complicated, does it? (If you think it does, look at `Integer.reverse` or something.)\\n\\nWhat happens here is that we first OR bit pair-wise. If any bit was `1` to begin with or had `1` to the left, it will now be `1`. Then we do the same thing with resulting pairs. Now every bit will be `1` if at least one of the following is true:\\n\\n- it was `1` to begin with;\\n- its left neighbor was `1` (so it became `1` on the previous step);\\n- its next left neighbor was `1` (because now we OR exactly with this next neighbor);\\n- its next-next left neighbor was `1` (because now we OR exactly with this next neighbor and that neighbor was ORed with its neighbor on the previous step).\\n\\nSo each *ith* bit will be `1` if at least of the bits `i + 1`, `i + 2`, `i + 3` was `1`. Note that the code uses signed shifting, but it doesn\\'t really matter because if `i` is negative we\\'ll fill everything with `1` anyway.\\n\\nBy repeating this process we finally have a mask that fills everything with `1` from the highest bit and to the right. By shifting it and subtracting we get the highest bit. Speaking of which, looks like we can use this code directly to solve our problem, although it won\\'t be a one-liner any more:\\n\\n    public int rangeBitwiseAnd(int m, int n) {\\n        if (m == n) {\\n            return m;\\n        }\\n        int i = m ^ n;\\n        i |= (i >>> 1);\\n        i |= (i >>> 2);\\n        i |= (i >>> 4);\\n        i |= (i >>> 8);\\n        i |= (i >>> 16);\\n        return m & ~i;\\n    }\\n\\nOne advantage in writing the code like this is that the complexity becomes clearer. Note that we have 5 shifts here. 5 is because we use 32-bit integers. If we had `long` instead of `int`, we\\'d need 6 shifts. 32 and 64 are 5th and 6th powers of 2. Therefore, the complexity is `O(log p)`, where `p` is the number of binary digits, which is 32 in our case, but if we used arbitrary length numbers, then it\\'d be something like `O(log(log(max(m, n))))` or `O(log(log(m+n)))` for simplicity because it\\'s of the same order anyway.",
                "codeTag": "Unknown"
            },
            {
                "id": 1514377,
                "title": "java-easy-solution",
                "content": "**Idea**\\nJust update the right value and because we know that during \\'&\\' operations the value either remain the same or get decreases so we can skip many iterations!\\n\\n````\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        \\n        for(int i=right-1;i>=left;i--) {\\n            \\n            right=right&i;\\n            i=right;\\n        }\\n        return right;\\n    }\\n}\\n````\\nI really hope you get it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        \\n        for(int i=right-1;i>=left;i--) {\\n            \\n            right=right&i;\\n            i=right;\\n        }\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220550,
                "title": "201-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach to solve this problem is to perform a bitwise AND operation on all numbers between the left and right limits. However, performing this operation on every number will be a costly operation.\\n\\nIf we consider the bitwise representation of the numbers in the given range, we observe that the result of the bitwise AND operation on these numbers gives us the common bits present in the left and right limits.\\n\\nThus, the task of finding the bitwise AND operation of all numbers between left and right limits reduces to finding the common bits between the left and right limits.\\n\\nTo find these common bits, we find the leftmost common bits between the left and right limits. We can start from the leftmost bit and move rightwards and check the bits of the left and right limits. If there is a mismatch between the bits, then all the bits to the right of the current bit will be set in the result of the bitwise AND operation. If there is no mismatch between the bits, then the current bit will be set in the result of the bitwise AND operation.\\n\\nAlgorithm:\\n\\n1. Initialize a variable \\'shift\\' to 0.\\n2. While the left and right limits are not equal,\\na. Right shift the left limit by 1 bit.\\nb. Right shift the right limit by 1 bit.\\nc. Increment the \\'shift\\' variable by 1.\\n3. Left shift the left limit by \\'shift\\' bits and return the result.\\n\\n# Complexity\\n- Time complexity:\\nO(1), as we are performing a constant number of operations.\\n\\n- Space complexity:\\nO(1), as we are not using any extra data structures.\\n\\n# Code\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        \\n        # Initialize a variable \\'shift\\' to 0.\\n        shift = 0\\n        \\n        # While the left and right limits are not equal,\\n        while left < right:\\n            \\n            # Right shift the left limit by 1 bit.\\n            left >>= 1\\n            \\n            # Right shift the right limit by 1 bit.\\n            right >>= 1\\n            \\n            # Increment the \\'shift\\' variable by 1.\\n            shift += 1\\n        \\n        # Left shift the left limit by \\'shift\\' bits and return the result.\\n        return left << shift\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        \\n        # Initialize a variable \\'shift\\' to 0.\\n        shift = 0\\n        \\n        # While the left and right limits are not equal,\\n        while left < right:\\n            \\n            # Right shift the left limit by 1 bit.\\n            left >>= 1\\n            \\n            # Right shift the right limit by 1 bit.\\n            right >>= 1\\n            \\n            # Increment the \\'shift\\' variable by 1.\\n            shift += 1\\n        \\n        # Left shift the left limit by \\'shift\\' bits and return the result.\\n        return left << shift\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083395,
                "title": "simple-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is very simple, we just need to take number started with left range and do the AND operation with consecutive numbers untill the number reaches its value equal to right range value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNeed to avoid some of the cases.\\n1. If any one of the left or right range value is zero then we return 0 since Anynum&0 = 0.\\n2. If binary representation of left and right numbers are of different digits then also we should result 0.\\nExample: suppose we have got left as 1 and right as 64. So the binary values are left = 1, right = 1000000.\\nSo if we start with left AND with left + 1, i.e. 1 & 2 result becomes 0. So from next operation onwards it is always zero.\\n\\nOnce we validate these..then the solution is simple. Take the value and performe AND operation with next number.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        // if both the numbers left and right is same, return anyone\\n        if(left==0 || right ==0) return 0;\\n\\n        // if there binary numbers for left and right are of different digits\\n        if((int)log2(left)!=(int)log2(right)) return 0; \\n        //initialize output with left range\\n        int res = left;\\n\\n        while(left<right){\\n            res &= ++left;\\n        }\\n        return res;\\n    }\\n};\\n# IF THIS CODE  IS HELPFUL,  THEN  PLEASE UPVOTE!!!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        // if both the numbers left and right is same, return anyone\\n        if(left==0 || right ==0) return 0;\\n\\n        // if there binary numbers for left and right are of different digits\\n        if((int)log2(left)!=(int)log2(right)) return 0; \\n        //initialize output with left range\\n        int res = left;\\n\\n        while(left<right){\\n            res &= ++left;\\n        }\\n        return res;\\n    }\\n};\\n# IF THIS CODE  IS HELPFUL,  THEN  PLEASE UPVOTE!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285877,
                "title": "c-solution-using-brian-kernighan-s-algo",
                "content": "So given the range [left, right] , we need to find bitwise AND of all the numbers. \\nLet\\'s say the bitwise representation of left = 101001 , right =  111001 ; Notice that the numbers between left and right ;  will ideally have some bit flips wrt left order to reach the right number . (Increment of left by 1 for every number) ; Since any one of the 0 in the bitwise representation will ultimately lead to 0 in the AND representation, so flips will lead to 0. This gives you a hint that, the part which is prefix and common to both left and right, will remain same for the entire range and the remaining part that flips , will lead to zero.\\n\\nNow the problem is to find the Prefix part which is common. \\nsay left = 1010100 and right = 1011001 , The prefix part which is common is 101, and the numbers between this range will be 101XXXX which will ultimately AND to form 1010000.\\n\\nHow Brian Kernighan\\'s algo works :  x&(x-1) will drop the lowest set bit to 0. The beauty of this Algo is, that it works in O(set bits) time. So we dont have to iterate through all the bits.\\n\\nNow we start from the larger value, and we keep dropping the least set bit until it becomes equal to n, which is the common prefix part;\\nfor ex - left = 1010001001 right = 1010101000 ; in first iteration, right becomes - 1010100000 ; Now right>left; So Again we do x &=(x-1) and drop the last set bit to form - 1010000000 , now right <left; This means that we cant drop any further bits . ( also handles 0 case);\\n\\nCode :\\n```\\nint rangeBitwiseAnd(int left, int right) {\\n        //Basically we want to find the common prefix, so what we will do is, we drop the least set bit in the higher value, and compare if it is equal to the left, if so, this is the common part \\n        int x = right;\\n        while(x>left){\\n            x = x&(x-1);\\n        }\\n        return x;\\n    }\\n\\t\\n```\\n\\nExtremely sorry if I wasn\\'t able to explain it properly, this is my first time trying to post here.  You can ping me and I\\'ll try to explain as best as possible.",
                "solutionTags": [],
                "code": "```\\nint rangeBitwiseAnd(int left, int right) {\\n        //Basically we want to find the common prefix, so what we will do is, we drop the least set bit in the higher value, and compare if it is equal to the left, if so, this is the common part \\n        int x = right;\\n        while(x>left){\\n            x = x&(x-1);\\n        }\\n        return x;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56855,
                "title": "bit-wise-solution-c-40ms",
                "content": "    int mask = ~0;\\n\\twhile (mask != 0)\\n\\t{\\n\\t\\tif ((m & mask) == (n & mask))\\n\\t\\t{\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tmask <<= 1;\\n\\t}\\n\\treturn m & mask;",
                "solutionTags": [],
                "code": "    int mask = ~0;\\n\\twhile (mask != 0)\\n\\t{\\n\\t\\tif ((m & mask) == (n & mask))\\n\\t\\t{\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tmask <<= 1;\\n\\t}\\n\\treturn m & mask;",
                "codeTag": "Unknown"
            },
            {
                "id": 56779,
                "title": "java-7-ms-solution",
                "content": "    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            for(; i<32; i ++)\\n                if(m>>i == n >>i)\\n                    break;\\n            return m>>i << i;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            for(; i<32; i ++)\\n                if(m>>i == n >>i)\\n                    break;\\n            return m>>i << i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56856,
                "title": "python-different-solutions",
                "content": "        \\n    def rangeBitwiseAnd1(self, m, n):\\n        d = n-m\\n        p = 0\\n        while d:\\n            p += 1\\n            d /= 2\\n        return ((m&n)>>p)<<p\\n        \\n    def rangeBitwiseAnd2(self, m, n):\\n        if m == n:\\n            return m\\n        return self.rangeBitwiseAnd(m>>1, n>>1) << 1\\n        \\n    def rangeBitwiseAnd3(self, m, n):\\n        p = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            p += 1\\n        return m << p\\n        \\n    def rangeBitwiseAnd(self, m, n):\\n        p = 0\\n        q = m^n\\n        while q:\\n            p += 1\\n            q >>= 1\\n        return ((m&n)>>p)<<p",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "        \\n    def rangeBitwiseAnd1(self, m, n):\\n        d = n-m\\n        p = 0\\n        while d:\\n            p += 1\\n            d /= 2\\n        return ((m&n)>>p)<<p\\n        \\n    def rangeBitwiseAnd2(self, m, n):\\n        if m == n:\\n            return m\\n        return self.rangeBitwiseAnd(m>>1, n>>1) << 1\\n        \\n    def rangeBitwiseAnd3(self, m, n):\\n        p = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            p += 1\\n        return m << p\\n        \\n    def rangeBitwiseAnd(self, m, n):\\n        p = 0\\n        q = m^n\\n        while q:\\n            p += 1\\n            q >>= 1\\n        return ((m&n)>>p)<<p",
                "codeTag": "Python3"
            },
            {
                "id": 1513529,
                "title": "c-simple-short-o-31-solution",
                "content": "**Let\\'s Start:-**\\n1. We know, for every bit position, numbers are lying in a certain range and they form the arithmetic progression\\n2. Example:- bit position 0:- (1-1,3-3,5-5,7-7...and so on).\\n3. Example bit position1 :- (2-3,6-7,10-11,14-15... and so on).\\n4. Example bit position 2:- (4-7,12-15,20-23,28-31 and so on).\\n5. Example bit position 3:- (8-15,24-31,40-47,56-63 and so on).\\n....so on.\\nHence, we will work on every bit position and since we need to focus on bitwise AND, so numbers in the range [left,right], if they all have 1 at current bit position, **we\\'ll include (1<<i) into our answer.**\\n\\n**Wait:-**  How we\\'ll check ?\\n**Idea?:-**  We\\'ll find our interval which is closest to [left and right] and check [left,right] completely lies inside our interval [l1,r1] then, we\\'re done...we\\'ll include (1<<i) into our answer since we know [l1,r1] will contain all 1s at current bit position.\\n\\n**How to find [l1,r1]:-** For every bit position...left bound of interval follows the Arithmetic Progression...Hence you can easily find the interval closest to [left, right]. **I expect, you can do further mathematical calculations since you passed class 10th right (XD) ?**\\n\\n**If you find the Post Helpful, Do give me upvotes!**\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int rangeBitwiseAnd(int left, int right) {\\n        ll ans = 0;\\n        for(ll i=0;i<=30;i++){\\n            ll a = (1LL<<i);\\n            ll l = left - a,p = l/(a*2);\\n            ll l1 = p*a*2 + a,r1 = l1 + a - 1;\\n            if(left>=l1 and right<=r1)\\n                ans+=a;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int rangeBitwiseAnd(int left, int right) {\\n        ll ans = 0;\\n        for(ll i=0;i<=30;i++){\\n            ll a = (1LL<<i);\\n            ll l = left - a,p = l/(a*2);\\n            ll l1 = p*a*2 + a,r1 = l1 + a - 1;\\n            if(left>=l1 and right<=r1)\\n                ans+=a;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469130,
                "title": "python-iterative-sol-based-on-bit-manipulation",
                "content": "Python iterative sol. based on bit-manipulation\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        \\n        shift = 0\\n        \\n        # find the common MSB bits.\\n        while m != n:\\n            \\n            m = m >> 1\\n            n = n >> 1\\n        \\n            shift += 1\\n        \\n        \\n        return m << shift\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        \\n        shift = 0\\n        \\n        # find the common MSB bits.\\n        while m != n:\\n            \\n            m = m >> 1\\n            n = n >> 1\\n        \\n            shift += 1\\n        \\n        \\n        return m << shift\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185693,
                "title": "c-short-simple-solution-o-1-time-o-1-space-with-explanation-and-bonus-binary-search",
                "content": "The problem, while not obvious at first, can be solved by finding longest bit string, starting at the most significant bit, where _m_ and _n_ match.\\n\\nAn example will make things a bit clearer. Take the given example of [5, 7] and for simplicity, considering them as 4 bit numbers. The following table can be formed.\\n\\n|value|**8**|**4**|**2**|**1**|\\n|:-:|:-:|:-:|:-:|:-:|\\n|5|0|1|0|1|\\n|6|0|1|1|0|\\n|7|0|1|1|1|\\n|result|0|1|0|0|\\n\\nYou can see that only the 8, and 4, columns are the same. It also shows that 7 is in fact the upper bound when using 5. While 5 could be reduced to 4 and still return the same result. The result of course being 0100b or 4.\\n\\n|value|**8**|**4**|**2**|**1**|\\n|:-:|:-:|:-:|:-:|:-:|\\n|5|0|1|0|1|\\n|6|0|1|1|0|\\n|7|0|1|1|1|\\n|8|1|0|0|0|\\n|result|0|0|0|0|\\n\\nUsing this table, we can see that a short and simple solution that increasingly masks out more least significant bits will produce the expected result.\\n\\n```cpp\\n  int rangeBitwiseAnd(int m, int n) {\\n    int mask = 0xFFFFFFFF;\\n    for (; (m & mask) != (n & mask); mask <<= 1)\\n      ;\\n    return m & mask;\\n  }\\n```\\n\\nJust for fun, and to illustrate what we\\'re looking for, I did a binary search solution. It theory it would be faster if you had to run billions of comparisons.\\n```cpp\\n  int rangeBitwiseAnd(int m, int n) {\\n    static constexpr const uint masks[] = {\\n      0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFC, 0xFFFFFFF8, 0xFFFFFFF0, 0xFFFFFFE0, 0xFFFFFFC0, 0xFFFFFF80,\\n      0xFFFFFF00, 0xFFFFFE00, 0xFFFFFC00, 0xFFFFF800, 0xFFFFF000, 0xFFFFE000, 0xFFFFC000, 0xFFFF8000,\\n      0xFFFF0000, 0xFFFE0000, 0xFFFC0000, 0xFFF80000, 0xFFF00000, 0xFFE00000, 0xFFC00000, 0xFF800000,\\n      0xFF000000, 0xFE000000, 0xFC000000, 0xF8000000, 0xF0000000, 0xE0000000, 0xC0000000, 0x80000000\\n      };\\n\\n    auto lo = std::begin(masks);\\n    auto hi = std::end(masks);\\n    \\n    while (lo != hi) {\\n      auto mid = lo + (hi - lo) / 2;\\n      if ((m & *mid) != (n & *mid)) {\\n        lo = mid + 1;\\n      } else {\\n        hi = mid;\\n      }\\n    }\\n    \\n    return m & *lo;\\n  }\\n```\\t\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\n  int rangeBitwiseAnd(int m, int n) {\\n    int mask = 0xFFFFFFFF;\\n    for (; (m & mask) != (n & mask); mask <<= 1)\\n      ;\\n    return m & mask;\\n  }\\n```\n```cpp\\n  int rangeBitwiseAnd(int m, int n) {\\n    static constexpr const uint masks[] = {\\n      0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFC, 0xFFFFFFF8, 0xFFFFFFF0, 0xFFFFFFE0, 0xFFFFFFC0, 0xFFFFFF80,\\n      0xFFFFFF00, 0xFFFFFE00, 0xFFFFFC00, 0xFFFFF800, 0xFFFFF000, 0xFFFFE000, 0xFFFFC000, 0xFFFF8000,\\n      0xFFFF0000, 0xFFFE0000, 0xFFFC0000, 0xFFF80000, 0xFFF00000, 0xFFE00000, 0xFFC00000, 0xFF800000,\\n      0xFF000000, 0xFE000000, 0xFC000000, 0xF8000000, 0xF0000000, 0xE0000000, 0xC0000000, 0x80000000\\n      };\\n\\n    auto lo = std::begin(masks);\\n    auto hi = std::end(masks);\\n    \\n    while (lo != hi) {\\n      auto mid = lo + (hi - lo) / 2;\\n      if ((m & *mid) != (n & *mid)) {\\n        lo = mid + 1;\\n      } else {\\n        hi = mid;\\n      }\\n    }\\n    \\n    return m & *lo;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513945,
                "title": "c-naive-vs-log-iterative-vs-log-recursive-bitwise-solutions-explained-100-time-80-space",
                "content": "The main intuition is that we can just keep looping from `l` to `r`, as long as our accumulator is not `0`.\\n\\nIf for example we just start with `1` (`1` in binary too) and we move to `2` (`10` in binary), we can quickly see that `&`ing them would result in `0`, since they have no matching bits:\\n\\n```cpp\\n01 // 1\\n10 // 2\\n```\\nOr again, we can move from `5` to `8` this way:\\n\\n```cpp\\n0101 // 5\\n0110 // 6\\n0111 // 7\\n1000 // 8\\n```\\nAnd again we quickly get to a situation giving us a flat `0`, since no single bit is present in all the numbers.\\n\\nImplementing this logic is then trivial and does not even time out for larger numbers (when it would take more to move to the next significant bit):\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        int res = l;\\n        while (res && l < r) res &= ++l;\\n        return res;\\n    }\\n};\\n```\\nCan we do better? Well, yes, if we notice that we are basically proceeding shaving the least significant bit as long as `l` and `r` are different; consider for example having to work with `25` (11001` in binary) and `29` (`11101` in binary):\\n\\n```cpp\\n11001 // 25\\n11101 // 29\\n```\\nWe can successfully proceed so that we will shave the least signficant bit of both numbers as long as they are different: `25`, for example, would lose its leftmost bit as soon as we parse `26` and the central bit in `29` will never make the cut, considering smaller numbers before.\\n\\nOnce we are done shaving bits off, once we reach a situation so that `l == r`, we can just return that number, shifted left by the amount of steps we did before, to remove the diverging bits.\\n\\nIn our example above, we will end up with a value of `3` (`11` in binary) and then, shifted left by the number of steps we did to reach this position, we will get back `24` (`11000` in binary), which is the correct answer.\\n\\nFor extra optimisation, we can actually stop as soon as we shaved off the last bit of `l` (ie: `l == 0`), since there would be no point on going on in that case and shave more bits out of `r`: we just know that there are no matching bits in that range. \\n\\nThe code for the logarithmic approach (unsurprisingly blazingly faster than the linear approach above):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        int count = 0;\\n        while (l && l != r) l >>= 1, r >>= 1, count++;\\n        return l << count;\\n    }\\n};\\n```\\n\\nSame, but recursive because it\\'s cooler:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        return (l && l != r) ? (rangeBitwiseAnd(l >> 1, r >> 1) << 1) : l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n01 // 1\\n10 // 2\\n```\n```cpp\\n0101 // 5\\n0110 // 6\\n0111 // 7\\n1000 // 8\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        int res = l;\\n        while (res && l < r) res &= ++l;\\n        return res;\\n    }\\n};\\n```\n```cpp\\n11001 // 25\\n11101 // 29\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        int count = 0;\\n        while (l && l != r) l >>= 1, r >>= 1, count++;\\n        return l << count;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r) {\\n        return (l && l != r) ? (rangeBitwiseAnd(l >> 1, r >> 1) << 1) : l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513722,
                "title": "for-mere-mortals-like-myself",
                "content": "write bitwise representation for all numbers possible with n bits, for ex with just 3 bits we can have:\\n\\n100\\n101\\n110\\n111\\nif we AND these with any numbers which need more than 3 bits to represent(8 to 15), the answer will be 0\\n\\nNow, we have broken the problem into a smaller set. We just need to individually check the 2 numbers only if they can be represented by same number of bits. We run a simple loop for that. \\n\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        int bitsLeft = 0;\\n        int bitsRight = 0;\\n        int l = left;\\n        int r = right;\\n        if (left == right) \\n            return left;\\n        while(left > 1) {\\n            left = left/2;\\n            bitsLeft++;\\n        } \\n        while(right > 1) {\\n            right = right/2;\\n            bitsRight++;\\n        }\\n        \\n        long result = l;\\n        if (bitsRight == bitsLeft &&  bitsRight != 0) {\\n            for(long i = l+1; i<= r; i++) \\n                result = result & i;\\n            return (int)result;\\n        }\\n        else \\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        int bitsLeft = 0;\\n        int bitsRight = 0;\\n        int l = left;\\n        int r = right;\\n        if (left == right) \\n            return left;\\n        while(left > 1) {\\n            left = left/2;\\n            bitsLeft++;\\n        } \\n        while(right > 1) {\\n            right = right/2;\\n            bitsRight++;\\n        }\\n        \\n        long result = l;\\n        if (bitsRight == bitsLeft &&  bitsRight != 0) {\\n            for(long i = l+1; i<= r; i++) \\n                result = result & i;\\n            return (int)result;\\n        }\\n        else \\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56863,
                "title": "a-math-solution",
                "content": "    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            if (m == n){\\n                return m;\\n            }\\n            //The highest bit of 1 in diff is the highest changed bit.\\n            int diff = m ^ n;\\n            //Index is the index of the highest changed bit. Starting at 1.\\n            int index = (int)(Math.log(diff) / Math.log(2)) + 1;\\n            //Eliminate the changed part.\\n            m = m >> index;\\n            return m << index;\\n        }\\n    }\\n\\n\\nI think this is fast since it doesn't involve loops.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            if (m == n){\\n                return m;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1513133,
                "title": "c-while-loop-to-repeated-clear-out-last-digit-until-common-prefix-is-found",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int shift_count = 0;\\n        while (left != right) {\\n            // since left is not the same as right, the least significant digits must vary thus cleared.\\n            shift_count++;\\n            left /= 2;\\n            right /= 2;\\n        }\\n        return left << shift_count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int shift_count = 0;\\n        while (left != right) {\\n            // since left is not the same as right, the least significant digits must vary thus cleared.\\n            shift_count++;\\n            left /= 2;\\n            right /= 2;\\n        }\\n        return left << shift_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860667,
                "title": "ac-detailed-solution-with-bit-manipulation",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    /*\\n    We need both 1s to contribute to ans {0,0}, {0,1}, {1,0} don\\'t contribute to ans as their \"bitwise AND\" = 0\\n    We iterate binary representation of both left and right, when both numbers become equal we stop.\\n    \\n    Now we know the count of places that are different in left and right extremes, But there are (right-left-1) elements in the range, \\n    The final answer: left<<toShift. \\n    Reason? the result of a range bitwise is the common \\'left header\\' of m and n. So left shift the left number by count of bits that were different\\n    \\n        Example: [5, 7]\\n        5 - 0101\\n        7 - 0111\\n        Iteration-1:\\n        (5!=7) => left = 010, right = 011, ans = 1\\n        Iteration-2:\\n        (2!=3) => left = 01, right = 01, ans = 2\\n        Iteration-3:\\n        (1==1) break;\\n    */\\n    \\n    int rangeBitwiseAnd(int left, int right)\\n    {\\n        int toShift = 0;\\n\\t\\twhile(left != right)  // see till both numbers are equal\\n\\t\\t{\\n            // right shift both numbers by 1, basically move over to the left bit\\n\\t\\t    left = left>>1; \\n\\t\\t    right= right>>1;\\n\\t\\t    toShift++;  // increment the count.\\n\\t\\t}\\n\\t\\t//  gives the number of zero places from the lsb so left shift m by count.\\n\\t\\treturn left<<toShift;    \\n    }\\n};\\n```\\n___\\n**Edit**: Added recursive version\\nBY: @[applewolf](https://leetcode.com/problems/bitwise-and-of-numbers-range/discuss/56746/One-line-C%2B%2B-solution)\\n```\\nint rangeBitwiseAnd(int m, int n) {\\n    return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n}\\n```\\n___",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    /*\\n    We need both 1s to contribute to ans {0,0}, {0,1}, {1,0} don\\'t contribute to ans as their \"bitwise AND\" = 0\\n    We iterate binary representation of both left and right, when both numbers become equal we stop.\\n    \\n    Now we know the count of places that are different in left and right extremes, But there are (right-left-1) elements in the range, \\n    The final answer: left<<toShift. \\n    Reason? the result of a range bitwise is the common \\'left header\\' of m and n. So left shift the left number by count of bits that were different\\n    \\n        Example: [5, 7]\\n        5 - 0101\\n        7 - 0111\\n        Iteration-1:\\n        (5!=7) => left = 010, right = 011, ans = 1\\n        Iteration-2:\\n        (2!=3) => left = 01, right = 01, ans = 2\\n        Iteration-3:\\n        (1==1) break;\\n    */\\n    \\n    int rangeBitwiseAnd(int left, int right)\\n    {\\n        int toShift = 0;\\n\\t\\twhile(left != right)  // see till both numbers are equal\\n\\t\\t{\\n            // right shift both numbers by 1, basically move over to the left bit\\n\\t\\t    left = left>>1; \\n\\t\\t    right= right>>1;\\n\\t\\t    toShift++;  // increment the count.\\n\\t\\t}\\n\\t\\t//  gives the number of zero places from the lsb so left shift m by count.\\n\\t\\treturn left<<toShift;    \\n    }\\n};\\n```\n```\\nint rangeBitwiseAnd(int m, int n) {\\n    return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784272,
                "title": "c-solution-with-explanations",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        if ((m == 0) || (n == 0)) // edge case 1 - zero AND anything will always stay zero\\n            return 0;\\n        \\n        if (m == n) // edge case 2 - only one number in range\\n            return m;\\n        \\n        if (n-m == 1) // edge case 3 - only two numbers in range\\n            return m&n;\\n        \\n        if ((int)log2(m) != (int)log2(n)) // if there is a different amount of digits in binary - always will be zero\\n            return 0;\\n        \\n        else // None of the above - not too many numbers left to calculate one by one...\\n        {\\n            int res = m;\\n            for (int i=m+1; i<=n;i++)\\n                res &= i;\\n                \\n            return res;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        if ((m == 0) || (n == 0)) // edge case 1 - zero AND anything will always stay zero\\n            return 0;\\n        \\n        if (m == n) // edge case 2 - only one number in range\\n            return m;\\n        \\n        if (n-m == 1) // edge case 3 - only two numbers in range\\n            return m&n;\\n        \\n        if ((int)log2(m) != (int)log2(n)) // if there is a different amount of digits in binary - always will be zero\\n            return 0;\\n        \\n        else // None of the above - not too many numbers left to calculate one by one...\\n        {\\n            int res = m;\\n            for (int i=m+1; i<=n;i++)\\n                res &= i;\\n                \\n            return res;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593239,
                "title": "easy-python-with-explanation-100-memory",
                "content": "The idea is very simple.\\nIf m and n are on different sides of nearest power of 2 then the result will be zero.\\nIf they are on the same side then we need to calculate.\\nExample:\\nm = 3 n = 5\\n3 and 5 are on different sides of nearest power of 2 wich is 4. This means stepping over 4 will eats everything and become zero. Try it on paper - you will get it.\\n```\\nimport math\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m == 0:\\n            return 0\\n        top = int(math.log(n,2))\\n        bottom = int(math.log(m,2))\\n        if top != bottom:\\n            return 0\\n\\n        res = m\\n        for i in range(m + 1, n + 1):\\n            res = res & i\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m == 0:\\n            return 0\\n        top = int(math.log(n,2))\\n        bottom = int(math.log(m,2))\\n        if top != bottom:\\n            return 0\\n\\n        res = m\\n        for i in range(m + 1, n + 1):\\n            res = res & i\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56785,
                "title": "one-line-java-solution-kerninghan-algorithm-turn-off-right-most-bit",
                "content": "    public int rangeBitwiseAnd(int m, int n) {\\n        while (n > m) n &= (n-1);\\n        return n;\\n    }\\n\\n`n & (n-1)` turns off the right most bit.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int rangeBitwiseAnd(int m, int n) {\\n        while (n > m) n &= (n-1);\\n        return n;\\n    }\\n\\n`n & (n-1)` turns off the right most bit.",
                "codeTag": "Unknown"
            },
            {
                "id": 2743659,
                "title": "using-java-faster-than-97-52",
                "content": "public class Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int res = 0;\\n        while( m != n){\\n            m >>= 1;\\n            n >>= 1;\\n            res++;\\n        }\\n\\n        return m << res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int res = 0;\\n        while( m != n){\\n            m >>= 1;\\n            n >>= 1;\\n            res++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2661382,
                "title": "c-detailed-explanation-bit-manipulation-observation",
                "content": "```\\n/*\\n\\nTime Complexity  : O(log(right))\\nSpace Complexity : O(1)\\n\\nAlgorithm :->\\n\\n(1) First check whether there exists a transition (0-->1 / 1-->0) at a \\nparticular bit position for any two consecutive elements in the given \\nrange.\\n\\n(2) If transition exists , then the final bit will be set to zero(0) for that bit \\nindex , else set to one(1).\\n\\n(3) Another major observation would be , if there is a transition at bit \\nposition \\'i\\' , then definitely there is a transition at bit position \\'i-1\\' , \\'i-2\\' , \\n\\'i-3\\' , ...... , \\'0\\'.\\n\\n(4) So we will traverse from the right side until and unless the left and \\nright values are equal to each other.\\n\\n10100 --> 1010 --> 101 left==right\\n10101 --> 1010 --> 101\\n10110 --> 1011 --> 101\\n10111 --> 1011 --> 101 right==left\\n\\n(5) Finally , bitwise and for these range of numbers , [left...right] will be \\n(remaining_left) after the right shift operations.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        int count = 0;\\n        \\n        while(left != right){\\n            \\n            left>>=1;\\n            right>>=1;\\n            count++;\\n            \\n        }\\n        \\n        return (left<<count);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\nTime Complexity  : O(log(right))\\nSpace Complexity : O(1)\\n\\nAlgorithm :->\\n\\n(1) First check whether there exists a transition (0-->1 / 1-->0) at a \\nparticular bit position for any two consecutive elements in the given \\nrange.\\n\\n(2) If transition exists , then the final bit will be set to zero(0) for that bit \\nindex , else set to one(1).\\n\\n(3) Another major observation would be , if there is a transition at bit \\nposition \\'i\\' , then definitely there is a transition at bit position \\'i-1\\' , \\'i-2\\' , \\n\\'i-3\\' , ...... , \\'0\\'.\\n\\n(4) So we will traverse from the right side until and unless the left and \\nright values are equal to each other.\\n\\n10100 --> 1010 --> 101 left==right\\n10101 --> 1010 --> 101\\n10110 --> 1011 --> 101\\n10111 --> 1011 --> 101 right==left\\n\\n(5) Finally , bitwise and for these range of numbers , [left...right] will be \\n(remaining_left) after the right shift operations.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        int count = 0;\\n        \\n        while(left != right){\\n            \\n            left>>=1;\\n            right>>=1;\\n            count++;\\n            \\n        }\\n        \\n        return (left<<count);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571613,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        while(left < right)\\n            right &= right-1;\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        while(left < right)\\n            right &= right-1;\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894629,
                "title": "c-o-1-solution-bitwise-operations",
                "content": "This solution takes advantage of one key property of the two numbers -- the difference between them. While the code below isn\\'t necessarily the most cleanest way to solve this problem, I believe that it provides a good intuition has to why the solution works.\\n\\nNow, we have two cases -- the number of bits used to represent each number is the same (`log2(n) == log2(m)`) or the number of bits used to represent the two numbers are different (`log2(n) != log2(m)`). We can tackle the latter case first, because it is easier to understand, and then move on to the former.\\n\\nTo establish a base case, clearly, if the numbers are the same (i.e. `diff == 0`), then the bitwise AND of all the numbers in the range is simply the same as the numbers, or number, themselves. Now let us move on to our other cases.\\n\\nIf the numbers `m` and `n` differ by a number, say, `x`, then the only bits that will change within their implementation are the bits that are used to represent their difference.\\n\\n* If the number of bits used to represent each number differs, then, we can show that the bitwise and of the two numbers will always be zero. The reason is because if we ignore all leading zeros and just look at the numbers themselves, in order to count from `m`, the smaller number, to `n`, the larger number, at some point, we must flip all the bits while counting up between the numbers, progressively adding on more and more bits to express the numbers until we reach `n`. Therefore, at some point while counting, which just represents the numbers in our range, each bit will be unset at some point. Therefore, since we are doing AND and all these bits are unset, this means that the result will be zero.\\n* Otherwise, if the bits used to represent the numbers are the same, this means that we need to consider the difference between the numbers and use this to construct our final solution. The number of bits used to represent the difference are *guaranteed* to change throughout the course of the reaching from `m` to `n`, since on each addition, at least on of these bits will flip. Therefore, we just need to create a mask that clears all these bits that can change, but keeps the other \"common\" bits the same.\\n\\nNow how does this manifest in the code? Well, start out by seeing that `curr = m & n`, or just the bitwise AND of our range bounds, and \\n`diff = n - m`. Obviously, if the difference is zero, then the numbers are the same, so we just return `m & n = m = n`. Otherwise, let\\'s try and construct a mask that captures the process we explained above. We can see that we are setting all the bits in our mask while `diff > 1`, and then doing one operation bitset after that. The operation after that is really part of the same process, but as removed from the loop to avoid infinite looping in certain cases. Now, after doing this process, what are we left with. We are left with a bitmask that is set to `1` for all bits that are used to represent our `diff`. \\n\\nTherefore, looking back at our two original cases, we can see that if `m` and `n` require a different number of bits to be expressed, then the bits in either number *that are not* used in the expression of the other (e.g. if you have the numbers `27 = 11011` and `15 = 1111`, bit 5 will already be zero, since the bits used to express the range are different). After this, the bits that are in the range of our difference (e.g. in this case, `27 - 15 = 12`, which uses the first four bits, so these four bits would be part of our `difference` bits) become set to zero, which is what our mask does in the last line. Any other common bits remain set.\\n\\nIf the number of bits used to express the numbers are the same, then `m` and `n` are in fact the same, then we repeat a similar process as above, just noting that there could be a set of common bits in the beginning which are the same throughout, since they aren\\'t in the range that our `difference` bits can count through. As a result, since the `difference` bits won\\'t reach this range, these bits will not be flipped at any point in our range, and will therefore show up in our final answer as captured by `m & n`. As an example, consider the case of `7 = 111` and `5 = 101`. In this case, the are expressed with 3 bits each. Since our difference is `2`, which is expressed in two bits, the bits which are guaranteed to change value when moving in this range are bits `0` and `1`. Therefore, any bits after this (i.e. the third bit and onwards) will remain the same in the ANDing of these two numbers, since the difference bits cannot count through this range and alter those higher-order bits.\\n\\nTo accomplish this, we are simplying doing `curr & (~mask)`, which clears all of our `difference` bits, and then leaves only the common ones that remain in the end as our final answer.\\n\\n```\\nint rangeBitwiseAnd(int m, int n) {\\n        int curr = m & n;\\n        int diff = n - m;\\n        if (!diff) {\\n            return curr;\\n        }\\n        int mask = 1;\\n        while (diff > 1) {\\n            diff >>= 1;\\n            mask |= 1;\\n            mask <<= 1; \\n        }\\n        mask |= 1;\\n        return curr & (~mask);\\n    }",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "This solution takes advantage of one key property of the two numbers -- the difference between them. While the code below isn\\'t necessarily the most cleanest way to solve this problem, I believe that it provides a good intuition has to why the solution works.\\n\\nNow, we have two cases -- the number of bits used to represent each number is the same (`log2(n) == log2(m)`) or the number of bits used to represent the two numbers are different (`log2(n) != log2(m)`). We can tackle the latter case first, because it is easier to understand, and then move on to the former.\\n\\nTo establish a base case, clearly, if the numbers are the same (i.e. `diff == 0`), then the bitwise AND of all the numbers in the range is simply the same as the numbers, or number, themselves. Now let us move on to our other cases.\\n\\nIf the numbers `m` and `n` differ by a number, say, `x`, then the only bits that will change within their implementation are the bits that are used to represent their difference.\\n\\n* If the number of bits used to represent each number differs, then, we can show that the bitwise and of the two numbers will always be zero. The reason is because if we ignore all leading zeros and just look at the numbers themselves, in order to count from `m`, the smaller number, to `n`, the larger number, at some point, we must flip all the bits while counting up between the numbers, progressively adding on more and more bits to express the numbers until we reach `n`. Therefore, at some point while counting, which just represents the numbers in our range, each bit will be unset at some point. Therefore, since we are doing AND and all these bits are unset, this means that the result will be zero.\\n* Otherwise, if the bits used to represent the numbers are the same, this means that we need to consider the difference between the numbers and use this to construct our final solution. The number of bits used to represent the difference are *guaranteed* to change throughout the course of the reaching from `m` to `n`, since on each addition, at least on of these bits will flip. Therefore, we just need to create a mask that clears all these bits that can change, but keeps the other \"common\" bits the same.\\n\\nNow how does this manifest in the code? Well, start out by seeing that `curr = m & n`, or just the bitwise AND of our range bounds, and \\n`diff = n - m`. Obviously, if the difference is zero, then the numbers are the same, so we just return `m & n = m = n`. Otherwise, let\\'s try and construct a mask that captures the process we explained above. We can see that we are setting all the bits in our mask while `diff > 1`, and then doing one operation bitset after that. The operation after that is really part of the same process, but as removed from the loop to avoid infinite looping in certain cases. Now, after doing this process, what are we left with. We are left with a bitmask that is set to `1` for all bits that are used to represent our `diff`. \\n\\nTherefore, looking back at our two original cases, we can see that if `m` and `n` require a different number of bits to be expressed, then the bits in either number *that are not* used in the expression of the other (e.g. if you have the numbers `27 = 11011` and `15 = 1111`, bit 5 will already be zero, since the bits used to express the range are different). After this, the bits that are in the range of our difference (e.g. in this case, `27 - 15 = 12`, which uses the first four bits, so these four bits would be part of our `difference` bits) become set to zero, which is what our mask does in the last line. Any other common bits remain set.\\n\\nIf the number of bits used to express the numbers are the same, then `m` and `n` are in fact the same, then we repeat a similar process as above, just noting that there could be a set of common bits in the beginning which are the same throughout, since they aren\\'t in the range that our `difference` bits can count through. As a result, since the `difference` bits won\\'t reach this range, these bits will not be flipped at any point in our range, and will therefore show up in our final answer as captured by `m & n`. As an example, consider the case of `7 = 111` and `5 = 101`. In this case, the are expressed with 3 bits each. Since our difference is `2`, which is expressed in two bits, the bits which are guaranteed to change value when moving in this range are bits `0` and `1`. Therefore, any bits after this (i.e. the third bit and onwards) will remain the same in the ANDing of these two numbers, since the difference bits cannot count through this range and alter those higher-order bits.\\n\\nTo accomplish this, we are simplying doing `curr & (~mask)`, which clears all of our `difference` bits, and then leaves only the common ones that remain in the end as our final answer.\\n\\n```\\nint rangeBitwiseAnd(int m, int n) {\\n        int curr = m & n;\\n        int diff = n - m;\\n        if (!diff) {\\n            return curr;\\n        }\\n        int mask = 1;\\n        while (diff > 1) {\\n            diff >>= 1;\\n            mask |= 1;\\n            mask <<= 1; \\n        }\\n        mask |= 1;\\n        return curr & (~mask);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 595748,
                "title": "c-o-1-time-and-memory-8ms-time-100-memory-5-line-easy-understand",
                "content": "We know that, if any number between m and n have a 0 at rth index.\\nThen the `AND` of all numbers between m and n will have 0 at rth index. \\n\\nThe solution is based on the difference between the 2 numbers `m` and `n`.\\n\\nConsider the binary represenations of numbers. If count from LSB to MSB and start our indexing with 0.\\n\\n0 => 00**0**0 \\n1 => 00**0**1 \\n2 => 00**1**0 \\n3 => 00**1**1 \\n4 => 01**0**0 \\n5 => 01**0**1 \\n6 => 01**1**0 \\n7 => 01**1**1 \\n8 => 10**0**0 \\n9 => 10**0**1 \\n\\nWe can clearly see that,\\n0th bit flips after every 1 number.\\n1th bit flips after every 2 number.\\n2nd bit flips after every 4 number.\\nSimilarly, kth bit flips after every 2^k number.\\n\\nSo, if the difference between the numbers m and n is greater than 2^k then all bits till kth bit are 0 as they must be 0 in atleast 1 number in range[m,n].\\n\\nOther bits after kth bit can flip atmost 1 time in the range [m,n]. So we have to take the AND of number `m` and `n` and that will give all the bits after kth bit.\\n\\n```\\nint rangeBitwiseAnd(int m, int n) {\\n\\tif(!(n-m))\\n\\t\\treturn n;\\n\\n\\tint l = (int) log2(n-m);\\n\\n\\tl++;\\n\\tm &= n;\\n\\tm >>= l;\\n\\tm <<= l;\\n\\n\\treturn m;\\n```\\n\\nSo, Worst case Time complexity is O(1) .\\nAnd, Worst case Space complexity is O(1).",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) {\\n\\tif(!(n-m))\\n\\t\\treturn n;\\n\\n\\tint l = (int) log2(n-m);\\n\\n\\tl++;\\n\\tm &= n;\\n\\tm >>= l;\\n\\tm <<= l;\\n\\n\\treturn m;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594464,
                "title": "detailed-python-solution-using-binary-string",
                "content": "**Idea**\\nBitwise AND has two properties:  \\n1. ANDing same bits always results in the original bit. 1 & 1 = 1, 0 & 0 = 0.\\n2. ANDing different bits always results in zero. 1 & 0 = 0, 0 & 1 = 0.\\n\\nTherefore, given two numbers `m,n` and their binary representation `mbin, nbin`, WLOG assumme `mbin < nbin` and `len(mbin) == len(nbin)`\\n- Th result of `mbin & nbin` has the same longest common prefix `common` as `mbin` and `nbin` (property 1).  \\n- If we AND every binary number ranging from `mbin` to `nbin`, every number in [mbin, nbin] has `common` prefix, hence the result will definitely have the `common` prefix. \\n- However, the result\\'s remaining bits are zero. Why? Every bit at remaining positions, regardless of their initial value, have a chance of becoming zero as we increment from `mbin` to `nbin`. According to property 2, every remaining position is ANDed with `0` at least once, so corresponding position in result will be `0`\\n\\nFor example, given `m=49`, `n=51`, we have :\\n`mbin = 110001`, and \\n`nbin = 110011`\\n`mbin & nbin = 110001`\\nThe longest common prefix is `1100` from `m` and `n`. Therefore, `mbin & mbin+1`, `mbin+1 & nbin` also has `1100` as its prefix.\\n`result = mbin & mbin+1 & ... & nbin`\\n`= 110001 & 110010 & 110011` \\n`= 110000`\\n`1100` is still the prefix, but remaining bits are `00` since `01 & 10 & 11 = 00`\\n\\nWhat if `len(mbin) != len(nbin)`? If we right align `mbin` and `nbin`, we will see they have no common prefix, in other words `len(common) == 0`, so the result will definitely be zero. \\n\\nFor example, `m=12, n=44` have no common prefix:\\n`mbin=001100`\\n`nbin=101100`\\n\\n**Code**  \\n```py\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        mbin, nbin = bin(m)[2:], bin(n)[2:] # take out the \"0b\" format\\n        ml, nl = len(mbin), len(nbin)\\n\\t\\t# pre-pad the shorter one of mbin, nbin with zeros to make them equal in length\\n\\t\\t# optim: directly return 0 if detect ml != nl, beats 98% Python solutions\\n        if ml < nl:\\n            mbin = \\'0\\' * (nl-ml) + mbin\\n        elif nl < ml:\\n            nbin = \\'0\\' * (ml-nl) + nbin\\n\\t\\t# at this point, mbin and nbin are aligned at least significant bit, len(mbin) = len(nbin)\\n        \\n\\t\\t# find out the length of longest common prefix\\n        common_prefix_length = 0\\n        for mbit, nbit in zip(mbin, nbin):\\n            if mbit == nbit:\\n                common_prefix_length += 1\\n            else: # detect the first different bit, the end of common prefix \\n                break\\n\\n\\t\\t# the result has the common prefix mbin[:common], and 0 as remaining bits. Total length should be max(ml,nl)\\n        res = mbin[:common_prefix_length] + \\'0\\'*(max(ml,nl)-common_prefix_length)\\n        return int(res, 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```py\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        mbin, nbin = bin(m)[2:], bin(n)[2:] # take out the \"0b\" format\\n        ml, nl = len(mbin), len(nbin)\\n\\t\\t# pre-pad the shorter one of mbin, nbin with zeros to make them equal in length\\n\\t\\t# optim: directly return 0 if detect ml != nl, beats 98% Python solutions\\n        if ml < nl:\\n            mbin = \\'0\\' * (nl-ml) + mbin\\n        elif nl < ml:\\n            nbin = \\'0\\' * (ml-nl) + nbin\\n\\t\\t# at this point, mbin and nbin are aligned at least significant bit, len(mbin) = len(nbin)\\n        \\n\\t\\t# find out the length of longest common prefix\\n        common_prefix_length = 0\\n        for mbit, nbit in zip(mbin, nbin):\\n            if mbit == nbit:\\n                common_prefix_length += 1\\n            else: # detect the first different bit, the end of common prefix \\n                break\\n\\n\\t\\t# the result has the common prefix mbin[:common], and 0 as remaining bits. Total length should be max(ml,nl)\\n        res = mbin[:common_prefix_length] + \\'0\\'*(max(ml,nl)-common_prefix_length)\\n        return int(res, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594192,
                "title": "javascript-bit-manipulation-w-comments-explanation",
                "content": "**solution:**\\n```\\nfunction rangeBitwiseAnd(m, n) {\\n    // number of shifts we had to make\\n    let i = 0;\\n\\t\\n    // go until m and n are equal\\n    while (m !== n) {\\n        // right shift both m and n\\n        m >>= 1;\\n        n >>= 1;\\n        // that\\'s 1 more shift\\n        i++;\\n    }\\n\\t\\n    // pad 0\\'s on right of m by right shifting by i\\n    return (m <<= i);\\n}\\n```\\n**explanation:**\\nthe idea here is to keep right shifting m and n until they are equal.\\nwe do this, because, until they are equal, the bits that are lost in the right shift will ultimately end up yielding a 0 bit on the ANDs anyways.\\n\\nExample: \\n```\\nlet m = 27, n = 31\\n```\\n\\n* 27 = 11011\\n* 31 = 11111\\n\\n**1st shift**\\n1101\\n1111\\nshifts = 1\\n\\n**2nd shift**\\n110\\n111\\nshifts = 2\\n\\n**3rd shift**\\n11\\n11\\nshifts = 3\\n\\nThey are now equal, and that required 3 shifts.\\n\\nWe take that `11`, and after left shifting 3 times, it becomes 11000 which is `24`.\\n\\nThe reason this is the answer, is because if we were to loop from m and n, ANDing everything, everything to the right of that 1 would become a zero anyways, due to differing bits, since they weren\\'t equal until this point anyways.\\n",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction rangeBitwiseAnd(m, n) {\\n    // number of shifts we had to make\\n    let i = 0;\\n\\t\\n    // go until m and n are equal\\n    while (m !== n) {\\n        // right shift both m and n\\n        m >>= 1;\\n        n >>= 1;\\n        // that\\'s 1 more shift\\n        i++;\\n    }\\n\\t\\n    // pad 0\\'s on right of m by right shifting by i\\n    return (m <<= i);\\n}\\n```\n```\\nlet m = 27, n = 31\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593348,
                "title": "summary-of-5-solutions",
                "content": "## core idea\\n\\nm := leading_common_bits + 0 + remaining_bits_of_m\\nn  := leading_common_bits + 1 + remaining_bits_of_n\\n( leading_common_bits can be 0 )\\nthen the result should be:\\nleading_common_bits + 0 + remaining_bits_all_0\\n\\nSo the crux is to find the highest bit that is different between m and n.\\n\\nWe use `1-bit` to denote a bit that is set to 1 in the following.\\n\\n\\n## solution 1\\uFF1Areduce and conquer\\nO(logN)\\n1. if n > m\\uFF0Cthen there are at least 2 consecutive numbers, their lowest bits are 0 and 1 respectively, so the lowest bit of the bitwise AND result must be 0. \\n2.   n >>= 1, m >>= 1 \\u2192  back to step 1\\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:        \\n        pos = 0        \\n        while n > m:\\n            n, m, pos = n >> 1, m >> 1, pos + 1            \\n        return m << pos\\n```\\n\\n## solution 2\\uFF1Afind the highest 1-bit of m^n\\n\\n### solution 2.1\\nO(logN)\\n```python\\npos = 0\\nwhile diff:\\n    pos, diff = pos + 1, diff >> 1\\n```\\n\\n### solution 2.2 pythonic\\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:        \\n        diff = n ^ m\\n        pos = diff.bit_length()                 \\n        return ( m >> pos ) << pos\\n```\\n\\n### solution 2.3 a bit faster than logN\\nThe highest `1-bit` of m^n \\u2208 `1-bit`s of n. \\nSo we don\\'t need to check all the bits (as in solution 1 or solution 2.1). \\nInstead, we can skip the `0-bit`s of n by iteratively setting the lowest `1-bit` of n to 0 until n <= m.\\nIf we assume the probability of a bit to be 1 is 0.5, then theoretically, solution 2.3 costs half the time of solution 2.1 in average.\\n\\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        while n > m:\\n            n &= (n-1)     # setting the lowest `1-bit` of n to 0 \\n        return n\\n```\\n\\n\\n## solution 3\\uFF1A O(loglogN)\\nStill we are trying to find the highest `1-bit` of m^n, but in logarithmic of the number of bits of N, thus `O(loglogN)`.\\n\\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        diff = m ^ n\\n        for i in 1,2,4,8,16:\\n            diff |= diff >> i\\n        return m & (~diff)\\n```\\n\\nexplanation:\\n```python\\ni |= (i >>  1);   # the following 1 bit of 1-bit is set to 1\\ni |= (i >>  2);   # the following 3 bit of 1-bit is set to 1\\ni |= (i >>  4);  # the following 7 bit of 1-bit is set to 1\\ni |= (i >>  8);   # the following 15 bit of 1-bit is set to 1\\ni |= (i >> 16);   # the following 31 bit of 1-bit is set to 1\\n```\\nThus in the end, all the following bits of the highest `1-bit` is set to 1",
                "solutionTags": [],
                "code": "```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:        \\n        pos = 0        \\n        while n > m:\\n            n, m, pos = n >> 1, m >> 1, pos + 1            \\n        return m << pos\\n```\n```python\\npos = 0\\nwhile diff:\\n    pos, diff = pos + 1, diff >> 1\\n```\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:        \\n        diff = n ^ m\\n        pos = diff.bit_length()                 \\n        return ( m >> pos ) << pos\\n```\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        while n > m:\\n            n &= (n-1)     # setting the lowest `1-bit` of n to 0 \\n        return n\\n```\n```python\\ndef rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        diff = m ^ n\\n        for i in 1,2,4,8,16:\\n            diff |= diff >> i\\n        return m & (~diff)\\n```\n```python\\ni |= (i >>  1);   # the following 1 bit of 1-bit is set to 1\\ni |= (i >>  2);   # the following 3 bit of 1-bit is set to 1\\ni |= (i >>  4);  # the following 7 bit of 1-bit is set to 1\\ni |= (i >>  8);   # the following 15 bit of 1-bit is set to 1\\ni |= (i >> 16);   # the following 31 bit of 1-bit is set to 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 333497,
                "title": "c-o-1-solution-clever-clever-trix-koderz-kamp",
                "content": "\\nOne think to consider... to get from any lesset bit to any higher bit via all the numbers in-between, you must visit all lower bits than the higher bit.\\n\\nExample:\\n0010 to 0 1000\\n\\nYou would have to visit the following:\\n\\n0010\\n0011\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nSo, we have to toggle all bits after the 1st 1.\\n\\nAnd these all together and you get ZERO...\\n\\nNow try this:\\n10000 to 0 10100\\n\\nYou would have to visit the following:\\n\\n10000\\n10001\\n10010\\n10011\\n10100\\n\\nAnd these all together and you get 10000\\n\\nAnd so a pattern emerges. Every bit which is not equal, means we must flop all lower bits to get to said digit.\\n\\nSo, we can just keep shifting both numbers right until they are equal. Count this number of shifts, and then shift back by that amount. Everything in the lower \"nibble\" of this potato chip would be too fattening, and so we would need to cut it out like bad origami. \\n\\nAnd so our code becomes this:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        if ((m & n) == 0) { return 0; }\\n        \\n        int aLow = m;\\n        int aHigh = n;\\n        int aShiftCount = 0;\\n        \\n        while (aLow != aHigh) {\\n            aLow = aLow >> 1;\\n            aHigh = aHigh >> 1;\\n            aShiftCount += 1;\\n        }\\n        \\n        return (aHigh << aShiftCount);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        if ((m & n) == 0) { return 0; }\\n        \\n        int aLow = m;\\n        int aHigh = n;\\n        int aShiftCount = 0;\\n        \\n        while (aLow != aHigh) {\\n            aLow = aLow >> 1;\\n            aHigh = aHigh >> 1;\\n            aShiftCount += 1;\\n        }\\n        \\n        return (aHigh << aShiftCount);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56799,
                "title": "the-most-terrific-and-simplest-solution-accepted-as-best-submission-in-c-well-explained",
                "content": "Since we are doing bitwise then let's think as it is. AND all numbers from m to n inclusive then all the right different bits will be erased until all bits are identical in the left part; why? the consecutive attribute of the problem -> from m to n inclusive means gradual increments from m to n  <font color=\"#ff0000\">each step with another 1 addition causing more bits zero</font>\\n\\nBang! End of Story!\\n\\n- space cost O(1).\\n- time cost O(1) - > the digits' number is limited under 32 considering the range.\\n\\n\\n----------\\n\\n    int rangeBitwiseAnd(int m, int n)\\n    {\\n        int count = 0;\\n        while(m != n)\\n        {\\n            m >>= 1;\\n            n >>= 1;\\n            count++;\\n        }\\n        return m << count;\\n    }",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "Since we are doing bitwise then let's think as it is. AND all numbers from m to n inclusive then all the right different bits will be erased until all bits are identical in the left part; why? the consecutive attribute of the problem -> from m to n inclusive means gradual increments from m to n  <font color=\"#ff0000\">each step with another 1 addition causing more bits zero</font>\\n\\nBang! End of Story!\\n\\n- space cost O(1).\\n- time cost O(1) - > the digits' number is limited under 32 considering the range.\\n\\n\\n----------\\n\\n    int rangeBitwiseAnd(int m, int n)\\n    {\\n        int count = 0;\\n        while(m != n)\\n        {\\n            m >>= 1;\\n            n >>= 1;\\n            count++;\\n        }\\n        return m << count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56894,
                "title": "water-problem",
                "content": "if m-n+1>=2, then the last bit must be 0;\\n\\nthen we just operater m>>=1, n>>=1, and repeat until m==n (m-n+1==1), in this situation, the last digits would the same as m or n.\\n\\n    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int ans = 0;\\n            int i = 0;\\n            while (m != n) {\\n                n >>= 1;\\n                m >>= 1;\\n                ++i;\\n            }\\n            ans += (m<<i);\\n            return ans;\\n        }\\n    };\\n\\nUPD :\\nthanks @[zhanqing][1]\\n , the code can be further cleaned as :\\n\\n    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            while (m != n) {\\n                n >>= 1;\\n                m >>= 1;\\n                ++i;\\n            }\\n            return (m << i);\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/user/zhanqing",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int ans = 0;\\n            int i = 0;\\n            while (m != n) {\\n                n >>= 1;\\n                m >>= 1;\\n                ++i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3637655,
                "title": "c-easiest-solution-bit-manipulation",
                "content": "\\n# Approach\\nFind the common bits from the MSB side of both numbers. Rest bits will end up having 0 as the ANDed value.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int ans = 0;\\n\\n        for(int i=31;i>=0;i--){\\n            if((m & (1 << i)) != (n & (1 << i))){\\n                break;\\n            }\\n            else{\\n                ans |= ((m & (1 << i)));\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n***PLEASE UPVOTE IF THIS WAS HELPFUL***",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int ans = 0;\\n\\n        for(int i=31;i>=0;i--){\\n            if((m & (1 << i)) != (n & (1 << i))){\\n                break;\\n            }\\n            else{\\n                ans |= ((m & (1 << i)));\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514159,
                "title": "c-brute-force-thinking",
                "content": "```\\nObserve  any range which are like left < 2^i , right >= 2^i ,for all i\\nyou will always get 0 for these type of ranges. for example 3 < (2^2), 5>=(2^2)\\ntheir binary 3 - 011, 4 - 100 ,5 - 101 ,beacuse at every position of digit u can always\\nhave one are more 0\\'s.\\n\\nso for the rest case which will be small we can loop them.\\n\\nit\\'s not quite good solution but it\\'s also one way to do the things! :)\\n```\\n                               \\n```\\nint rangeBitwiseAnd(int left, int right) {\\n        int c1 = 0,c2 =0;\\n        for(int i=0;i<32;i++)\\n        {\\n            if(left>>i & 1) c1 = i;\\n            if(right>>i & 1) c2 = i;\\n        }\\n        \\n        if(c1 == c2)\\n        {\\n            int ans = left;\\n            for(long i=left;i<=right;i++)\\n                ans &= i;\\n            return ans;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nObserve  any range which are like left < 2^i , right >= 2^i ,for all i\\nyou will always get 0 for these type of ranges. for example 3 < (2^2), 5>=(2^2)\\ntheir binary 3 - 011, 4 - 100 ,5 - 101 ,beacuse at every position of digit u can always\\nhave one are more 0\\'s.\\n\\nso for the rest case which will be small we can loop them.\\n\\nit\\'s not quite good solution but it\\'s also one way to do the things! :)\\n```\n```\\nint rangeBitwiseAnd(int left, int right) {\\n        int c1 = 0,c2 =0;\\n        for(int i=0;i<32;i++)\\n        {\\n            if(left>>i & 1) c1 = i;\\n            if(right>>i & 1) c2 = i;\\n        }\\n        \\n        if(c1 == c2)\\n        {\\n            int ans = left;\\n            for(long i=left;i<=right;i++)\\n                ans &= i;\\n            return ans;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513209,
                "title": "go-solution-so-easy-even-a-caveman-can-do-it-o-1",
                "content": "In all honesty, it can be tricky to come up with this. Even I had a hard time thinking about it. What helps is using a large number of examples to help you realize that we can get common prefixes for numbers.\\n\\nTime: O(logn) - see comments below for explanation.\\nSpace: O(1)\\n\\n```go\\nfunc rangeBitwiseAnd(left int, right int) int {\\n    // Shift both numbers to the right until you find something in common in the prefix of both numbers\\n    count := 0\\n    for left != right {\\n        left >>= 1\\n        right >>= 1\\n        count += 1\\n    }\\n    \\n    return left << count // Shift back to get the prefix in the original bit positions it appeared in\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc rangeBitwiseAnd(left int, right int) int {\\n    // Shift both numbers to the right until you find something in common in the prefix of both numbers\\n    count := 0\\n    for left != right {\\n        left >>= 1\\n        right >>= 1\\n        count += 1\\n    }\\n    \\n    return left << count // Shift back to get the prefix in the original bit positions it appeared in\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1231665,
                "title": "short-easy-and-fastest-c-solution-with-explanation-bit-manipulation",
                "content": "The idea to iterate over all the elements from left to right is not a good one, instead I suggest something better than this. \\nIf we can get the \"Common Bit Prefix\" of left and right, that itself is our answer.\\nFor Example, let us consider: left = 357 and right = 366\\nUsing Binary representation, (only 9 bits represented and other 21 bits are all 0\\'s )\\nleft     = 101100101\\nright   = 101101110\\nThe common prefix is \" 10110 \" so the answer will be 256+0+64+32+0 = 352 .\\nThe above idea holds true because there always exists a number between left and right, such that after the first prefix mismatching bit in left and right, all the other combinations of 0\\'s and 1\\'s after the mismatching bit are covered by the numbers between left and right and the Bitwise AND of the range results in low ( 0 ) if any of the numbers between left and right is low ( 0 ) for that particular bit.\\n```\\nclass Solution { \\npublic:                                    \\n    int rangeBitwiseAnd(int left, int right) { \\n        //Finding the Common Prefix of left and right is the answer\\n        int ans=0;\\n        for(int bit=30;bit>=0;bit--){\\n            // To check for a specific bit number\\n            if((left&(1<<bit))!=(right&(1<<bit)))\\n                break; //Not Common: so no need to check further\\n            else\\n                ans|=(left&(1<<bit)); //Common: add the value of specific bit and continue \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution { \\npublic:                                    \\n    int rangeBitwiseAnd(int left, int right) { \\n        //Finding the Common Prefix of left and right is the answer\\n        int ans=0;\\n        for(int bit=30;bit>=0;bit--){\\n            // To check for a specific bit number\\n            if((left&(1<<bit))!=(right&(1<<bit)))\\n                break; //Not Common: so no need to check further\\n            else\\n                ans|=(left&(1<<bit)); //Common: add the value of specific bit and continue \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 595968,
                "title": "java-beginner-s-solution",
                "content": "My logic works on the principle that if any 2^x`[x is an int]` is present in the range, excluding m, then the value will be 0.\\nAs in, between 5 and 10, there is 8 `[2^3]` which corresponds to `1000` in binary. when this happens, the bitwise AND with its previous number will always yield 0.\\n\\nNow to find that number, take m and find it\\'s` result = log base 2(m)`. Check if `2^(result+1) <= n`. \\n\\nOtherwise do normal bitwise operation.\\n\\n    private static long getLogBase2(int a) {\\n        return (long)(Math.log(a)/Math.log(2));\\n    }    \\n    public int rangeBitwiseAnd(int m, int n) {\\n        if (m == 0) return 0;\\n        long nextVal = getLogBase2(m);\\n        if (Math.pow(2, nextVal + 1) <= n) return 0;\\n        \\n        long value = m;\\n        for (long i=value+1; i<=n; i++) {\\n            value = value & i;\\n            if (value == 0) return (int)value;\\n        }\\n        \\n        return (int)value;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "My logic works on the principle that if any 2^x`[x is an int]` is present in the range, excluding m, then the value will be 0.\\nAs in, between 5 and 10, there is 8 `[2^3]` which corresponds to `1000` in binary. when this happens, the bitwise AND with its previous number will always yield 0.\\n\\nNow to find that number, take m and find it\\'s` result = log base 2(m)`. Check if `2^(result+1) <= n`. \\n\\nOtherwise do normal bitwise operation.\\n\\n    private static long getLogBase2(int a) {\\n        return (long)(Math.log(a)/Math.log(2));\\n    }    \\n    public int rangeBitwiseAnd(int m, int n) {\\n        if (m == 0) return 0;\\n        long nextVal = getLogBase2(m);\\n        if (Math.pow(2, nextVal + 1) <= n) return 0;\\n        \\n        long value = m;\\n        for (long i=value+1; i<=n; i++) {\\n            value = value & i;\\n            if (value == 0) return (int)value;\\n        }\\n        \\n        return (int)value;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56810,
                "title": "my-c-solution-2-with-explanation",
                "content": "The intuition is from here.\\n\\nhttps://leetcode.com/discuss/75805/share-my-o-1-time-solution-with-explanation-and-proof   \\n\\n     class Solution {\\n        public:\\n            int rangeBitwiseAnd(int m, int n) {\\n                // When we excute m & m+1 & m+2 & ... & n-1 & n, only the common bits of all these number will surrive\\n                // n     : 0110101101 10000000\\n                // n-1   : 0110101101 01111111\\n                //  ....\\n                // m+3   : 0110101101 0000011\\n                // m+2   : 0110101101 0000010\\n                // m+1   : 0110101101 0000001\\n                // m     : 0110101101 0000000\\n                // We can see that , only the leftmost common bits of m and n will meet that requirement\\n                // so the job here is to find the leftmost common bits of m and n\\n                // There is another way.\\n                // n - m will eliminate all the left common bit of m and n. \\n                // n -m : 0000000000 10000000 \\n                // we can use log(n-m, 2)+1 to get how many number of bits beside the leftmost common bits of m and n\\n                // after we get the number cnt, we set the rightmost cnt bits to 0\\n                // mask : 1111111111 00000000\\n                // by dong mask & m & n, we will get the leftmost common bits of m and n\\n                int cnt = log(n-m)/log(2)+1;\\n                int mask = 0x7fffffff ^ ((1<<cnt) -1);\\n                return mask & m & n;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            int rangeBitwiseAnd(int m, int n) {\\n                // When we excute m & m+1 & m+2 & ... & n-1 & n, only the common bits of all these number will surrive\\n                // n     : 0110101101 10000000\\n                // n-1   : 0110101101 01111111\\n                //  ....\\n                // m+3   : 0110101101 0000011\\n                // m+2   : 0110101101 0000010\\n                // m+1   : 0110101101 0000001\\n                // m     : 0110101101 0000000\\n                // We can see that , only the leftmost common bits of m and n will meet that requirement\\n                // so the job here is to find the leftmost common bits of m and n\\n                // There is another way.\\n                // n - m will eliminate all the left common bit of m and n. \\n                // n -m : 0000000000 10000000 \\n                // we can use log(n-m, 2)+1 to get how many number of bits beside the leftmost common bits of m and n\\n                // after we get the number cnt, we set the rightmost cnt bits to 0\\n                // mask : 1111111111 00000000\\n                // by dong mask & m & n, we will get the leftmost common bits of m and n\\n                int cnt = log(n-m)/log(2)+1;\\n                int mask = 0x7fffffff ^ ((1<<cnt) -1);\\n                return mask & m & n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3764763,
                "title": "c-bit-manipulation-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int left , int right){\\n        if(left == 0)return 0;\\n        int bit1 = log2(left);\\n        int bit2 = log2(right);\\n        if(bit1 < bit2)return 0;\\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \\n    }\\n    int rangeBitwiseAnd(int left, int right) {\\n         return solve(left , right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int left , int right){\\n        if(left == 0)return 0;\\n        int bit1 = log2(left);\\n        int bit2 = log2(right);\\n        if(bit1 < bit2)return 0;\\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \\n    }\\n    int rangeBitwiseAnd(int left, int right) {\\n         return solve(left , right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665661,
                "title": "201-bitwise-and-of-numbers-range-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        int result = right;\\n\\n        while(right>left){\\n            result = right & (right - 1);\\n            right = result;\\n        }\\n        return result;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        int result = right;\\n\\n        while(right>left){\\n            result = right & (right - 1);\\n            right = result;\\n        }\\n        return result;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731500,
                "title": "98-faster-3-lines-solution-very-easy-easy-to-understand",
                "content": "** The bitwise AND in number ranges\\n  \\n\\n```\\n\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right)\\n    {\\n       int i=0;\\n        \\n        while(left!=right)\\n        {\\n           i++;\\n            left>>=1;\\n            right>>=1;\\n            \\n        }\\n        \\n        return left<<i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right)\\n    {\\n       int i=0;\\n        \\n        while(left!=right)\\n        {\\n           i++;\\n            left>>=1;\\n            right>>=1;\\n            \\n        }\\n        \\n        return left<<i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469070,
                "title": "bit-manipulation-c-easy-understanding",
                "content": "The main observation here is we just need to check next 2^power number greater than L \\nnow let next power of 2 greater than L is X\\nnow two cases arises here \\n\\n1->if(X<=R) then answer will be 0\\nlet me explain it\\nlet takes L=5 and R=10\\nnext 2 power of L is 8 \\nnow in binary representation\\n\\n5->0101\\n6->0110\\n7->0111\\n8->1000 here in 8 starting three bits are 000 which will make our ans Zero because in & operation 0 have highest priority\\n\\nwe dont need to chack number greater than 8 because it will give zero\\n\\ncase 2->In this case we can iterate from L to R and get the ans\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(long long int left,long long int right) {\\n      long long int next=1;\\n        \\n        while(next<=left)\\n            next*=2;\\n        \\n        if(next<=right)\\n            return 0;\\n        \\n        long long  ans=left;\\n        \\n        for(long long int i=left+1;i<=right&&i<=next;i++)\\n            ans&=i;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(long long int left,long long int right) {\\n      long long int next=1;\\n        \\n        while(next<=left)\\n            next*=2;\\n        \\n        if(next<=right)\\n            return 0;\\n        \\n        long long  ans=left;\\n        \\n        for(long long int i=left+1;i<=right&&i<=next;i++)\\n            ans&=i;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790745,
                "title": "cpp-easy-explanation",
                "content": "things to keep in mind\\n1.any of the bit that will flip in a column of bitwise representation will have all preceeding flips tured 0 as a new flip will occur at nearest power of 2\\n\\n2. all the columns before the column of left most common bit would be considered 0 as they would already have tested all the combination resulting in 0 in some column that will render whole column 0\\n\\n3. so the fixed bits which are same till the left most common bit will be same in the resulting and operator result\\n```\\nclass Solution {\\npublic:\\n      //the and that will be carried across\\n      // all the numbers will preserve the left most \\n      // common part of the bits of the number while the\\n      // other bits on the right will null out due to \\n      // flipping of digits \\n    int rangeBitwiseAnd(int left, int right) {\\n     int count=0;\\n        while(left!=right){\\n            left=left>>1;\\n            right=right>>1;\\n            count++;\\n        }\\n         left=left<<count;\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      //the and that will be carried across\\n      // all the numbers will preserve the left most \\n      // common part of the bits of the number while the\\n      // other bits on the right will null out due to \\n      // flipping of digits \\n    int rangeBitwiseAnd(int left, int right) {\\n     int count=0;\\n        while(left!=right){\\n            left=left>>1;\\n            right=right>>1;\\n            count++;\\n        }\\n         left=left<<count;\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747449,
                "title": "java-easy-and-clean-code-with-comments-100-00-faster",
                "content": "Runtime: 4 ms, faster than 100.00% of Java online submissions for Bitwise AND of Numbers Range.\\n\\n```\\n/*\\nExample : left = 36, right = 40\\n\\nDecimal number  :  Binary Form \\n    36          :    100100\\n    37          :    100101\\n    38          :    100110\\n    39          :    100111\\n    40          :    101000\\n    \\nFor 36 and 40, only their first two bits(from MSB) are same, rest are different, so their AND will be 0. \\nSo we don\\'t have to check for the numbers in between. \\n\\nWorking : left = 36(100100)  |   right = 40(101000)  |   count = 0\\n          left = 18(10010)   |   right = 20(10100)   |   count = 1\\n          left = 9(1001)     |   right = 10(1010)    |   count = 2\\n          left = 4(100)      |   right = 5(101)      |   count = 3\\n          left = 2(10)       |   right = 2(10)       |   count = 4\\n          \\n     Now they have become equal, so left shift the number(left or right) by count times.\\n     -> left <<= count; \\n     -> 2(10) <= 4; \\n     -> 32(100000)\\n     \\n*/\\n\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        //How many bits are different in left and right from LSB to MSB. \\n\\t\\t//As they are flipped so their AND will be 0.\\n        int count = 0;\\n        \\n        //To preserve the bits that are same in left and right from MSB to LSB.\\n        while (left != right) {\\n            //Right shift left and right.\\n            left >>= 1;\\n            right >>= 1;\\n            //Increase the count.\\n            count++;\\n        }\\n        \\n        //After the above loop, left will be equal to right. \\n\\t\\t//Now left shift count times to add 0 on it\\'s right side.\\n        return left <<= count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\nExample : left = 36, right = 40\\n\\nDecimal number  :  Binary Form \\n    36          :    100100\\n    37          :    100101\\n    38          :    100110\\n    39          :    100111\\n    40          :    101000\\n    \\nFor 36 and 40, only their first two bits(from MSB) are same, rest are different, so their AND will be 0. \\nSo we don\\'t have to check for the numbers in between. \\n\\nWorking : left = 36(100100)  |   right = 40(101000)  |   count = 0\\n          left = 18(10010)   |   right = 20(10100)   |   count = 1\\n          left = 9(1001)     |   right = 10(1010)    |   count = 2\\n          left = 4(100)      |   right = 5(101)      |   count = 3\\n          left = 2(10)       |   right = 2(10)       |   count = 4\\n          \\n     Now they have become equal, so left shift the number(left or right) by count times.\\n     -> left <<= count; \\n     -> 2(10) <= 4; \\n     -> 32(100000)\\n     \\n*/\\n\\nclass Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        //How many bits are different in left and right from LSB to MSB. \\n\\t\\t//As they are flipped so their AND will be 0.\\n        int count = 0;\\n        \\n        //To preserve the bits that are same in left and right from MSB to LSB.\\n        while (left != right) {\\n            //Right shift left and right.\\n            left >>= 1;\\n            right >>= 1;\\n            //Increase the count.\\n            count++;\\n        }\\n        \\n        //After the above loop, left will be equal to right. \\n\\t\\t//Now left shift count times to add 0 on it\\'s right side.\\n        return left <<= count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677958,
                "title": "1-liner-recursive-solution-in-c-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n    return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n    return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200277,
                "title": "c-dead-easy-100-faster",
                "content": "Just check how many bits from start of both numbers are equal \\n   coz when u do & operation all the non common ones(from the point where left and right differed) will change and will result in 0 while performing & operation.\\n   so what i mean is \\n    5 - 1(equal) | 01(non equal)                    \\n\\t7 - 1(equal) | 11(non equal) ans:-4 \\n\\t12 - 11(equal) | 00(non equal)\\n\\t15 - 11(equal) | 11(non equal) ans :- 12\\n\\tfirst non equal bits are at index 1 and index 2 for both examples respectively\\n\\t\\nEven then if u dont get it just think ... u will\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right){\\n            left=left>>1;\\n            right=right>>1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right){\\n            left=left>>1;\\n            right=right>>1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123441,
                "title": "easy-observation-based-algorithm-with-code-c",
                "content": "**Approach :**\\n1. By observation, we can see that all the numbers between left and right, will have some commons bits, at the beginning.\\n\\nExample - \\n```\\nInput: left = 5, right = 7\\nOutput: 4\\n\\nlocation =     432 10\\n5 =            001 01\\n6 =            001 10\\n7 =            001 11\\n```\\nWhat we can see is that all the numbers in the range have a common prefix bit (here, 001).\\nFor the bits, following the prefix (common) bits, we encounter a **0** in any of the numbers, in the range (left, right).\\n\\nHere in above example - \\n1. We have common bits for all the positions starting from location no. 31 to 2 (as total size = 32 bits)\\n2. For bit locations following the common part, we encounter 0, in atleast any of the numbers.\\n Here,  we get 0 at location 1, from binary of 5. similarly we get 0 at location 0, from 6.\\n3. So, when we take AND of all these our answer will contain only the prefix common part, following by all 0s. \\n (as, contribution of 0 in AND will lead to 0, at that bit, in the answer.).\\n \\n The code is short, and will explain the above steps, in a more detailed manner.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) \\n    {\\n        int ans = 0; // answer containing all 32 bits as 0.\\n        \\n        for(int i=31;i>=0;i--) // iterating over all the 32 bits\\n        {\\n            if( (left & (1<<i) ) != (right & (1<<i) ) ) \\n                break;  //finding if bits are common or not.\\n            \\n            else\\n            ans |= (left & (1<<i));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nPlease upvote, if its helpful.\\nFind more Leetcode solutions [HERE](https://github.com/noob-hu-yaar/Leetcode/tree/master/nandincpp)\\n****\\n\\n",
                "solutionTags": [],
                "code": "```\\nInput: left = 5, right = 7\\nOutput: 4\\n\\nlocation =     432 10\\n5 =            001 01\\n6 =            001 10\\n7 =            001 11\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) \\n    {\\n        int ans = 0; // answer containing all 32 bits as 0.\\n        \\n        for(int i=31;i>=0;i--) // iterating over all the 32 bits\\n        {\\n            if( (left & (1<<i) ) != (right & (1<<i) ) ) \\n                break;  //finding if bits are common or not.\\n            \\n            else\\n            ans |= (left & (1<<i));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988867,
                "title": "100-fast-detailed-explanation-c-solution",
                "content": "let us take two numbers suppose 3 and 5,\\n3 & 4 & 5 ==> \\n          0 1 1 \\n\\t\\t     1 0 0 \\n\\t\\t     1 0 1\\nwe can notice that their is no prefix common in all,\\n\\nNow let us take 13,14\\n\\n13 & 14 ==> \\n1 1 0 1 \\n  1 1 1 0\\n              \\ncommon prefix in both is : 1 1 .... After the starting 1 1 every bit after it is confirmed to be flipped off so we will append 0 after that. Hence, 1 1 0 0.\\nAlgo:\\ni.e, 1. Find the common prefix in both the number. (DO BY JUST DOING RIGHT SHIFT UNTIL BOTH NUMBERS ARE EQUAL)\\n2 . Count the numbers of shift\\n3. Just make left shift to the count of the right shift to generate the desired result.\\neg:\\n1st right shift\\n1 1 0 1 -------------------> 1 1 0\\n1 1 1 0 -------------------> 1 1 1    \\n\\n2nd right shift\\n1 1 0 ---------------------> 1 1\\n1 1 1 ---------------------> 1 1   (BOTH THE NUMBERS ARE EQUAL,STOP!!!)\\n\\n\\nNOW JUST MAKE TWO LEFT SHIFT(Number Of Right Shift)  TO GET THE DESIRED RESULT \\n1 1 -----------------------> 1 1 0 0 (Ans)\\n\\nBelow is the implementation of the above algorithm which is self explanatory.\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n       \\n        int shift=0;\\n        \\n        if(m == n) return m;\\n        \\n        while(m != n)\\n        {  m >>= 1;\\n           n >>= 1;\\n           ++shift;\\n        }\\n        \\n      \\n       return m << shift; \\n          \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n       \\n        int shift=0;\\n        \\n        if(m == n) return m;\\n        \\n        while(m != n)\\n        {  m >>= 1;\\n           n >>= 1;\\n           ++shift;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 857269,
                "title": "c-bit-manipulation-o-1",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int count=0;\\n        while (m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            count++;\\n        }\\n        return m<<=count;\\n    } \\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int count=0;\\n        while (m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 709339,
                "title": "python-longest-common-prefix-o-1-solution",
                "content": "1. If we know the longest common prefix (LCP) of `m` and `n` represented in binary, that\\'s our answer.\\n\\n2. Let\\'s run through a few examples.\\n\\n```\\nm = 5, n = 7\\n\\n    1   0   1\\n(&) 1   1   0\\n(&) 1   1   1\\n______________\\n    1   0   0\\n\\t\\n\\t\\nLCP(5, 7) = 1 X X --> the X is to pad the RHS with 0\\'s.\\nHence, bitwise AND of [5, 7] = \\'0b100\\' = 4\\n\\n```\\n<br>\\n\\n```\\nm = 8, n = 11\\n\\n    1   0   0   0\\n(&) 1   0   0   1\\n(&) 1   0   1   0\\n(&) 1   0   1   1\\n__________________\\n    1   0   0   0\\n\\t\\n\\t\\nLCP(8, 11) = 1 0 X X --> the X is to pad the RHS with 0\\'s\\nHence, bitwise AND of [8, 11] = \\'0b1000\\' = 8\\n\\n```\\n\\n<br>\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        \\n        # TRACK THE NUMBER OF RIGHT SHIFTS WE DID\\n        rightShifts = 0\\n        \\n        # WE KEEP RIGHT-SHFITING UNTIL M == N\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            rightShifts += 1\\n            \\n        # ONCE M == N, WE\\'VE THE LONGEST COMMON PREFIX = M = N, RETURN IT\\n        return m * (2 ** rightShifts)\\n```",
                "solutionTags": [],
                "code": "```\\nm = 5, n = 7\\n\\n    1   0   1\\n(&) 1   1   0\\n(&) 1   1   1\\n______________\\n    1   0   0\\n\\t\\n\\t\\nLCP(5, 7) = 1 X X --> the X is to pad the RHS with 0\\'s.\\nHence, bitwise AND of [5, 7] = \\'0b100\\' = 4\\n\\n```\n```\\nm = 8, n = 11\\n\\n    1   0   0   0\\n(&) 1   0   0   1\\n(&) 1   0   1   0\\n(&) 1   0   1   1\\n__________________\\n    1   0   0   0\\n\\t\\n\\t\\nLCP(8, 11) = 1 0 X X --> the X is to pad the RHS with 0\\'s\\nHence, bitwise AND of [8, 11] = \\'0b1000\\' = 8\\n\\n```\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        \\n        # TRACK THE NUMBER OF RIGHT SHIFTS WE DID\\n        rightShifts = 0\\n        \\n        # WE KEEP RIGHT-SHFITING UNTIL M == N\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            rightShifts += 1\\n            \\n        # ONCE M == N, WE\\'VE THE LONGEST COMMON PREFIX = M = N, RETURN IT\\n        return m * (2 ** rightShifts)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594259,
                "title": "100-memory-python-3-one-line-short-with-math",
                "content": "\\'\\'\\'\\n\\n\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        return 0 if  n >= m*2 else functools.reduce(lambda x, y: x & y, range(m, n+1))\\n\\n\\'\\'\\'\\nIn math it is easy to see when the last number >= first number *2, the return must be 0\\nIn other case, I use & to loop. (using of & seems illegal after I saw other\\'s beautiful solutions.\\nAnyway, just another perspective for everyone.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        return 0 if  n >= m*2 else functools.reduce(lambda x, y: x & y, range(m, n+1))\\n\\n\\'\\'\\'\\nIn math it is easy to see when the last number >= first number *2, the return must be 0\\nIn other case, I use & to loop. (using of & seems illegal after I saw other\\'s beautiful solutions.\\nAnyway, just another perspective for everyone.",
                "codeTag": "Python3"
            },
            {
                "id": 593850,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nObserve the bitwise pattern which occurs in sequential numbers between each range of powers of 2.  More formally, if the range `M..N` is contained within the range of powers of 2 from 2<sup>i</sup> non-inclusive  to 2<sup>i - 1</sup> inclusive, then we can set the bit in the answer for 2<sup>i - 1</sup>.  We search for the range of powers of 2 in descending order since each number in the range `M..N` could potentially be in multiple ranges of powers of 2.  For example, consider `M = 6` and `N = 7`, the range `6..7` has the 2<sup>2</sup> and 2<sup>1</sup> bits set in common, thus to check each subsequent range of powers of 2, simply subtract `M` and `N` by the lower bound of current range of powers of 2 (see example below).\\n\\n![image](https://assets.leetcode.com/users/claytonjwong/image_1587655962.png)\\n\\n\\n*Example:* `M = 6` and `N = 7`\\n\\n`M` and `N` fall within the range of powers of 2 between 2<sup>3</sup> and 2<sup>2</sup>, ie. `8 > 7` and `6 >= 4`.  This occurs when `i = 3` and `i - 1 = 2`.  So we set the bit in the answer for 2<sup>2</sup> = 4, then subtract `M` and `N` by `4`, thus, `M = 2` and `N = 3`.  Now `M` and `N` fall within the range of powers of 2 between 2<sup>2</sup> and 2<sup>1</sup>, ie. `4 > 3` and `2 >= 2`.  This occurs when `i = 2` and `i - 1 = 1`.  So we set the bit in the answer for 2<sup>1</sup> = 2.  Thus the answer is `4 + 2 = 6`.\\n\\n---\\n\\n*Javascript*\\n```\\nlet rangeBitwiseAnd = (M, N, ans = 0) => {\\n    for (let i = 31; i > 0; --i)\\n        if (2**i > N && M >= 2**(i - 1))\\n            ans |= 2**(i - 1),\\n              M -= 2**(i - 1),\\n              N -= 2**(i - 1);\\n    return ans;\\n};\\n```\\n\\n---\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int M, int N, int ans = 0) {\\n        for (unsigned int i = 1 << 31; i > 0; i >>= 1)\\n            if (i > N && M >= i >> 1)\\n                ans |= i >> 1,\\n                  N -= i >> 1,\\n                  M -= i >> 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet rangeBitwiseAnd = (M, N, ans = 0) => {\\n    for (let i = 31; i > 0; --i)\\n        if (2**i > N && M >= 2**(i - 1))\\n            ans |= 2**(i - 1),\\n              M -= 2**(i - 1),\\n              N -= 2**(i - 1);\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int M, int N, int ans = 0) {\\n        for (unsigned int i = 1 << 31; i > 0; i >>= 1)\\n            if (i > N && M >= i >> 1)\\n                ans |= i >> 1,\\n                  N -= i >> 1,\\n                  M -= i >> 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593777,
                "title": "pretty-much-explained-cpp-with-pseudo-code",
                "content": "**ATLAST we see: for [a,b] a&b<=min(a,b)**\\nAt the first glance, looping from m to n seems straightforward but obviously time limit exceeds.\\nIterating from m to n seems unavailable, but we can consider looping from bit to bit.\\n(works good for nos of 2^31 range)(save sis from runtime error)\\nLet\\'s first write down some binary numbers:\\n1    000001\\n2    000010\\n3    000011\\n4    000100\\n5    000101\\n6    000110\\n7    000111\\n8    001000\\nAs we can see,every consecutive numbers lowest bit(LSB) is either 1 or 0.So,doing \\'&\\' operation over consecutive nos results 0 or 1 in LSB positon.\\nSo,if there are nos between given range[m,n],LSB will be 0 after & operation.\\nSo,for every bit from LSB to MSB,we shift both and compare them,if(n>m) then some nos are between them,so lowest bit now in answer will be 0.\\nAgain we go on shifting until we reach equality.\\nAfter equality, answer bits will be same as any one of them(since 0&0 =0,1&1 =1).\\nWe can see it from below example..\\n\\nm =  01000\\nn =   01011\\n\\n(1)   01011 > 01000  ->  lowest bit = 0\\n(2)   0101 > 0100      ->  2nd lowest bit  = 0\\n(3)   010 = 010          ->  3rd lowest bit = current lowest bit  0\\n(4)   01 = 01              ->  4th lowest bit = current lowest bit   1\\n(5)   0 = 0                  ->  5th lowest bit = current lowest bit   0\\n\\nFinal result:   01000\\n**We can see that step (3)-(5) is unnecessary, when m=n, the other bits are just the same as current m (or n), then we can easily get the final result.**\\n\\nFinally, incurred from this is\\nfor range [a,b];\\na&b<=min(a,b);\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while(m!=n){\\n            count++;\\n            m = m>>1;\\n            n = n>>1;\\n        }\\n        return m<<count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while(m!=n){\\n            count++;\\n            m = m>>1;\\n            n = n>>1;\\n        }\\n        return m<<count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56808,
                "title": "share-my-c-solution-with-explanation-easy-to-understand",
                "content": "    //For two consecutive numbers A and B,they must have different Least Significant Bit(LSB),\\n    //beause B = A + 1,if the LSB is 0 in A,then LSB must be 1 in B,and vice versa.\\n    //If m != n,there must be 0 in LSB in the range [m, n].So we just right shift one bit to \\n    //check the  next bit( i.e. update the LSB).If m == n, we need left shift some bits to get \\n    //the right answer.\\n    \\n    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            \\n            while (m != n)\\n            {\\n                m = m >> 1;\\n                n = n >> 1;\\n                i++;\\n            }\\n            \\n            return m << i;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = 0;\\n            \\n            while (m != n)\\n            {\\n                m = m >> 1;\\n                n = n >> 1;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 56837,
                "title": "40ms-solution-by-c",
                "content": "    int rangeBitwiseAnd(int m, int n) {\\n        int i;\\n        for(i=0;m!=n;m>>=1,n>>=1)i++;\\n        return m<<i;\\n    }",
                "solutionTags": [],
                "code": "    int rangeBitwiseAnd(int m, int n) {\\n        int i;\\n        for(i=0;m!=n;m>>=1,n>>=1)i++;\\n        return m<<i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56875,
                "title": "my-o-1-solution-using-bitwise-xor-and",
                "content": "    //34ms    \\n    int rangeBitwiseAnd(int m, int n) {\\n                int xmask = m ^ n;\\n                int mlen = 0;\\n                int mask;\\n                \\n                if ((xmask >> (mlen + 16)) > 0) mlen += 16;\\n                if ((xmask >> (mlen + 8)) > 0) mlen += 8;\\n                if ((xmask >> (mlen + 4)) > 0) mlen += 4;\\n                if ((xmask >> (mlen + 2)) > 0) mlen += 2;\\n                if ((xmask >> (mlen + 1)) > 0) mlen ++;\\n                \\n                mask = ~0 << mlen;\\n                \\n                return m & mask;\\n        }",
                "solutionTags": [],
                "code": "    //34ms    \\n    int rangeBitwiseAnd(int m, int n) {\\n                int xmask = m ^ n;\\n                int mlen = 0;\\n                int mask;\\n                \\n                if ((xmask >> (mlen + 16)) > 0) mlen += 16;\\n                if ((xmask >> (mlen + 8)) > 0) mlen += 8;\\n                if ((xmask >> (mlen + 4)) > 0) mlen += 4;\\n                if ((xmask >> (mlen + 2)) > 0) mlen += 2;\\n                if ((xmask >> (mlen + 1)) > 0) mlen ++;\\n                \\n                mask = ~0 << mlen;\\n                \\n                return m & mask;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 56898,
                "title": "my-c-solution-iterate-32-bits",
                "content": "The code just iterates every bits for the two numbers. Then determine to break, count, or just contiune.\\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        int result = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = 1 << i;\\n            if ((n & bit) > 0) {\\n                if ((m & bit) == 0) { break; }\\n                result |= bit;\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "The code just iterates every bits for the two numbers. Then determine to break, count, or just contiune.\\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        int result = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = 1 << i;\\n            if ((n & bit) > 0) {\\n                if ((m & bit) == 0) { break; }\\n                result |= bit;\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3602246,
                "title": "c-bit-manipulation-solution-w-intution-simple-logic-tc-o-n",
                "content": "# Intuition\\nThe intuition behind this problem is the to find the bits that don\\'t change at all in the given interval.\\nLet\\'s take two numbers: `82` and `94`\\n```\\n     6 5 4 3 2 1 0\\n82 - 1 0 1 0 0 1 0\\n\\n83 - 1 0 1 0 0 1 1\\n84 - 1 0 1 0 1 0 0\\n85 - 1 0 1 0 1 0 1\\n86 - 1 0 1 0 1 1 0\\n87 - 1 0 1 0 1 1 1\\n88 - 1 0 1 1 0 0 0\\n89 - 1 0 1 1 0 0 1\\n90 - 1 0 1 1 0 1 0\\n91 - 1 0 1 1 0 1 1\\n92 - 1 0 1 1 1 0 0\\n93 - 1 0 1 1 1 0 1\\n\\n94 - 1 0 1 1 1 1 0\\n```\\nHere, the bits are changing till the $$3^{rd}$$ bit. If you see, the each bit from `0` to `3` will at least turn 0 once in the interval.\\nThis tells us that we need to take the longest common series of bits starting from the `MSB` (Most Significant Bit), $$6^{th}$$ bit in this case.\\n\\n# Approach\\n1. Move bits from left and right to another variable.\\n2. If left\\'s LSB and right\\'s LSB are equal then shift the bit value into the variable.\\n3. If they are not equal then make the variable 0 again.\\n4. Repeat this until both left and right become 0 or in this case since the number is 31 bit only, we do it 31 time. (makes it easier to reverse bits in next step).\\n5. Now we have our answer but it\\'s in reverse form so start moving the bits into a different variable for 31 time.\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if (left == right)\\n            return left;\\n        int temp{0};\\n        for(int i=0; i<31; i++, left>>=1, right>>=1, temp<<=1) {\\n            if ((left&1) == (right&1))\\n                temp |= (left&1);\\n            else\\n                temp = 0;\\n        }\\n        int res{0};\\n        for(int i=0; i<31; i++) {\\n            res |= (temp&1);\\n            temp >>= 1;\\n            res <<= 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(2*31) \\\\approx O(1)$$\\nTraversed 31 bits to get the common sequence of bits and again to reverse them.\\n- Space complexity: $$O(1)$$\\nNo extra space used.\\n\\n\\n> ### Note\\n> - Upvote if you liked my solution\\n> - Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n     6 5 4 3 2 1 0\\n82 - 1 0 1 0 0 1 0\\n\\n83 - 1 0 1 0 0 1 1\\n84 - 1 0 1 0 1 0 0\\n85 - 1 0 1 0 1 0 1\\n86 - 1 0 1 0 1 1 0\\n87 - 1 0 1 0 1 1 1\\n88 - 1 0 1 1 0 0 0\\n89 - 1 0 1 1 0 0 1\\n90 - 1 0 1 1 0 1 0\\n91 - 1 0 1 1 0 1 1\\n92 - 1 0 1 1 1 0 0\\n93 - 1 0 1 1 1 0 1\\n\\n94 - 1 0 1 1 1 1 0\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if (left == right)\\n            return left;\\n        int temp{0};\\n        for(int i=0; i<31; i++, left>>=1, right>>=1, temp<<=1) {\\n            if ((left&1) == (right&1))\\n                temp |= (left&1);\\n            else\\n                temp = 0;\\n        }\\n        int res{0};\\n        for(int i=0; i<31; i++) {\\n            res |= (temp&1);\\n            temp >>= 1;\\n            res <<= 1;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670409,
                "title": "c-3-lines-simple-code-without-iteration-or-recursion",
                "content": "Some Explanation Here:\\n1. If we have more than 1 numbers in the range, then 0-bit must be 0 since two adjacent numbers have different bits at 0-bit.\\n2. If we have more than 2 numbers in the range, then 1-bit must be 0 in the same way.\\n3. If we have more than 4 numbers in the range, then 2-bit must be 0 ...\\n\\nHence we can simply ignore the lower bits according to how many numbers we have in the range, which is done by ```~(((uint32_t)1<<offset)-1)```.\\n\\nAs for the higher bits, let us take certain nth-bit for example. Because we have limited range of numbers, there are only three situations:\\n1. They are all zeros.\\n2. They are all ones.\\n3. They are 0..000111...1 or 1...111000...0.\\n\\nIn any of three ways, we only need to check the greatest and smallest boundary of the range, i.e. left and right: ```right & left```.\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if (right == left) return right;\\n        int offset = log2(right - left) + 1;\\n        return ~(((uint32_t)1<<offset)-1) & right & left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```~(((uint32_t)1<<offset)-1)```\n```right & left```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if (right == left) return right;\\n        int offset = log2(right - left) + 1;\\n        return ~(((uint32_t)1<<offset)-1) & right & left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336688,
                "title": "c-short-simple-to-the-point-code",
                "content": "```\\nint rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right){\\n            left>>=1; right>>=1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right){\\n            left>>=1; right>>=1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1871634,
                "title": "python-easy-to-understand-solution",
                "content": "All we need to do is return the longest common prefix between the two binary digits.\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        left, right = bin(left)[2:], bin(right)[2:]\\n        if len(left) != len(right): return 0\\n        \\n        num = 0\\n        for i in range(len(left)):\\n            if left[i] == right[i] == \\'1\\':\\n                num += pow(2, len(left)-i-1)\\n            elif left[i] != right[i]:\\n                break\\n        \\n        return num",
                "solutionTags": [],
                "code": "All we need to do is return the longest common prefix between the two binary digits.\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        left, right = bin(left)[2:], bin(right)[2:]\\n        if len(left) != len(right): return 0\\n        \\n        num = 0\\n        for i in range(len(left)):\\n            if left[i] == right[i] == \\'1\\':\\n                num += pow(2, len(left)-i-1)\\n            elif left[i] != right[i]:\\n                break\\n        \\n        return num",
                "codeTag": "Java"
            },
            {
                "id": 1524535,
                "title": "easy-to-understand-python-solution",
                "content": "if binary length of left is shorter than the binary length of right, let\\'s say left: 3 `0b11` and right 7 `0b111`, there must be a `0b100` in the range which would lead the result to 0.\\n\\nIf two integers have the same length, there must be part of suffix with a different leading bit `0` and `1` for two integers, this applied to the former conclusion and the suffix could be all zero.\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        if len(bin(left)) != len(bin(right)):\\n            return 0\\n        shift = 0\\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            shift += 1\\n        return left << shift\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        if len(bin(left)) != len(bin(right)):\\n            return 0\\n        shift = 0\\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            shift += 1\\n        return left << shift\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513901,
                "title": "c-significant-no-in-range-mask",
                "content": "**Idea behind solution  :generate the no in range with maximum continuous zeros in right\\nonce that no is generated do AND with left to get result\\nex: \\nleft===============    10100111\\nright==============    10111110\\nrequired no.=========    10110000\\nresult=left & required no=   10100000**\\n```\\nclass Solution {\\npublic:\\n    int getMsb(int left)\\n    {\\n        int msb=0;\\n        while(left>>=1)\\n            msb++;\\n        return msb;\\n    }\\n    int rangeBitwiseAnd(int left, int right)\\n    { \\n        unsigned int temp=0,msb=getMsb(left)+2;//+1 extra  to balance first --msb\\n        while(temp<left)\\n        {\\n            temp|=(1<<--msb);\\n            if(temp>right)\\n                temp^=(1<<msb);//undo last or\\n        }\\n        return left&temp;\\n    }\\n};\\n```\\n**much easier approach\\n1.)generate mask with zeros till leftmost bit position where left and right differs(and all remaining bits set)\\n2.)do AND with left to get result\\n3.left==============    10100111\\nright==============    10111110\\nmask========   (1 till 31)11100000\\nresult=left & mask= =====10100000**\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) \\n    {\\n        if(left==right) return left;\\n        int msb=log2(left^right);\\n        int mask=(1U<<msb+1)-1;\\n        return left&~mask;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMsb(int left)\\n    {\\n        int msb=0;\\n        while(left>>=1)\\n            msb++;\\n        return msb;\\n    }\\n    int rangeBitwiseAnd(int left, int right)\\n    { \\n        unsigned int temp=0,msb=getMsb(left)+2;//+1 extra  to balance first --msb\\n        while(temp<left)\\n        {\\n            temp|=(1<<--msb);\\n            if(temp>right)\\n                temp^=(1<<msb);//undo last or\\n        }\\n        return left&temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) \\n    {\\n        if(left==right) return left;\\n        int msb=log2(left^right);\\n        int mask=(1U<<msb+1)-1;\\n        return left&~mask;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031250,
                "title": "c-3-lines-solution-no-recursion-easy-to-understand-find-the-common-binary-prefix",
                "content": "The bitwise `AND` of numbers between `m` and `n` will not **affect** the common binary prefix(CBP) of them(because they are sharing the same CBP), so the idea is to find the CBP of `m` and `n`.\\n```\\n                        5   b\\'01 01\\n                        7   b\\'01 11\\nCommon binary prefix    4   b\\'01(00)\\n```\\nWe use an unsigned-int mask filled with `1` (`0xffffffff`) to  `AND` with `m` and `n` to find the common binary prefix.\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        uint32_t mask = 0xffffffff;\\n        while ((m & mask) != (n & mask)) mask <<= 1;\\n        return m & mask;\\n    }\\n};\\n```\\nThere is a more interesting code to find the CBP:\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        uint32_t x = m ^ n;\\n        x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, x |= x >> 16;\\n        return m & ~x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n                        5   b\\'01 01\\n                        7   b\\'01 11\\nCommon binary prefix    4   b\\'01(00)\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        uint32_t mask = 0xffffffff;\\n        while ((m & mask) != (n & mask)) mask <<= 1;\\n        return m & mask;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        uint32_t x = m ^ n;\\n        x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, x |= x >> 16;\\n        return m & ~x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999501,
                "title": "c-o-1-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        // if m==0, then answer is 0\\n        if(m==0) return 0;\\n        // if number is same, then answer is that number\\n        int diff = n-m;\\n        if(!diff) return m;\\n        // if number of bits required to represent the numbers are different, then answer is zero, because in order to go from e.g 5 bits to 6 bits, we have to flip all the 5 bits to zero.\\n        if(int(log2(n)) != int(log2(m))) {    return 0;}\\n        // if number of bits are same, then difference between the numbers in binary form are the bits that we have to change\\n        //like if m=35 and n = 57, then diff = 22 ~ 10110 so only 5 last 5 bits will be changed, but first take AND of m and n, then change last 5 bits. \\n        int k = log2(diff);\\n        cout<<k;\\n        m = m&n;\\n        for(int i= k; i>=0;i--){\\n            // here we are setting the ith bit to zero\\n            m = m & (~(1<<i));\\n        }\\n        return m;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int rangeBitwiseAnd(int m, int n) {\\n        // if m==0, then answer is 0\\n        if(m==0) return 0;\\n        // if number is same, then answer is that number\\n        int diff = n-m;\\n        if(!diff) return m;\\n        // if number of bits required to represent the numbers are different, then answer is zero, because in order to go from e.g 5 bits to 6 bits, we have to flip all the 5 bits to zero.\\n        if(int(log2(n)) != int(log2(m))) {    return 0;}",
                "codeTag": "Java"
            },
            {
                "id": 819089,
                "title": "easy-java-solution-with-video-explanation",
                "content": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int shift = 0;\\n        while (m != n) {\\n            m >>= 1;\\n            n >>= 1;\\n            shift++;\\n        }\\n        n <<= shift;\\n        return n;\\n    }\\n}\\n```\\n\\nMy video explanation: \\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/j3XRFREnPWI\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int shift = 0;\\n        while (m != n) {\\n            m >>= 1;\\n            n >>= 1;\\n            shift++;\\n        }\\n        n <<= shift;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741067,
                "title": "java-clean-code-with-explanation",
                "content": "When the bit is different, then for bitwise AND we get 0. Continue this until two numbers match.\\nNow, the final result could be obtained when we shift the first number (which is less than the other) to that many bits to the left. Because the rest of the bits are zero.\\n**For example** - 1001 - 1011\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tIteration 1 -> \\n\\t\\t\\t\\t\\t\\t\\t\\t0100, 0101\\n\\t\\t\\t\\t\\t\\t\\t\\t-> 0010, 0010\\n\\t\\t\\tTotal dropped -> 2\\n\\t\\t\\tResult -> \\n\\t\\t\\t\\t\\t\\t\\t\\t0010 << 2 -> 1000 (8)\\n\\t\\t\\tThis is the bitwise AND of 9 to 11.\\n\\n```java\\npublic int rangeBitwiseAnd(int m, int n) {\\n\\tif (m == n) return m;\\n\\tif (m == 0 || n == 0) return 0;\\n\\n\\tint droppedBitCount = 0;\\n\\t\\n\\twhile (m != n) {\\n\\t\\tm = m >> 1;\\n\\t\\tn = n >> 1;\\n\\t\\tdroppedBitCount++;\\n\\t}\\n\\treturn m << droppedBitCount;\\n}",
                "solutionTags": [],
                "code": "When the bit is different, then for bitwise AND we get 0. Continue this until two numbers match.\\nNow, the final result could be obtained when we shift the first number (which is less than the other) to that many bits to the left. Because the rest of the bits are zero.\\n**For example** - 1001 - 1011\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tIteration 1 -> \\n\\t\\t\\t\\t\\t\\t\\t\\t0100, 0101\\n\\t\\t\\t\\t\\t\\t\\t\\t-> 0010, 0010\\n\\t\\t\\tTotal dropped -> 2\\n\\t\\t\\tResult -> \\n\\t\\t\\t\\t\\t\\t\\t\\t0010 << 2 -> 1000 (8)\\n\\t\\t\\tThis is the bitwise AND of 9 to 11.\\n\\n```java\\npublic int rangeBitwiseAnd(int m, int n) {\\n\\tif (m == n) return m;\\n\\tif (m == 0 || n == 0) return 0;\\n\\n\\tint droppedBitCount = 0;\\n\\t\\n\\twhile (m != n) {\\n\\t\\tm = m >> 1;\\n\\t\\tn = n >> 1;\\n\\t\\tdroppedBitCount++;\\n\\t}\\n\\treturn m << droppedBitCount;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 692428,
                "title": "cpp-easy-solution-faster-than-100",
                "content": "The question is essentially asking the common prefix. So as long as there is a difference between bits you can ignore it. keep right shifting the lower and upper limit and when they are equal we know they are equal to common prefix. Finally, just shift it left by the number of positions where the bits were not common since it will be succeded by the zeros.\\n```\\nclass Solution {\\npublic:\\n   \\n    int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while(m!=n){\\n            m = m>>1;\\n            n = n>>1;\\n            count++;\\n        }\\n        return m<<count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while(m!=n){\\n            m = m>>1;\\n            n = n>>1;\\n            count++;\\n        }\\n        return m<<count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653015,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int i = 0;\\n        while (m!=n){\\n            m = m >> 1;\\n            n = n >> 1;\\n            i++;\\n        }\\n        return m << i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int i = 0;\\n        while (m!=n){\\n            m = m >> 1;\\n            n = n >> 1;\\n            i++;\\n        }\\n        return m << i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594153,
                "title": "different-solution-using-logarithm",
                "content": "My intuition took me to somewhere else rather than other solutions.\\n\\n**Intuition:**\\n* If numbers (m and n) are in different power of twos, then it means that the result is 0 every time.\\n* Else if numbers are in the same power of two then it means that the first bit is countable and we will check rest bits with recursion. \\n\\n**Let me explain with examples:**\\n\\n```\\n13 - 001101\\n14 - 001110\\n15 - 001111\\n16 - 010000 <- it will change all bits to 0. (Look at example 1)\\n17 - 010001\\n18 - 010010\\n19 - 010011\\n20 - 010100 <- 3rd and 5th bits are 1 (Look at example 2)\\n21 - 010101\\n22 - 010111 <- 3rd and 5th bits are 1\\n23 - 011000\\n```\\n\\n1. Example 1) `(m, n) = (14, 19)`. In this case, as I mentioned before, 16 (010000) will change all bits to 0 and that is why the result is 0. Surely this approach works for all such where m and n are in different power of twos. \\n\\n1. Example 2) `(m, n) = (20, 22)`. As the power of 2s are the same we should add the power of two of current number to result and traverse all rest of bits. \\n\\n**Java:**\\n```java\\npublic int rangeBitwiseAnd(int m, int n) {        \\n\\tint pm = log2(m);\\n\\tint pn = log2(n);\\n\\n\\tif (m == 0 || n == 0 || pm != pn) {                         // if logarithms of numbers are different\\n\\t\\treturn 0;\\n\\t} \\n\\n\\tint newm = 1 << pm;                                         // adding number to result \\n\\treturn newm + rangeBitwiseAnd(m & (newm-1), n & (newm-1));  // unsetting first bits of both m and n \\n}\\n\\nprivate int log2(int a) {\\n\\treturn (int) (Math.log(a) / Math.log(2));\\n}\\n```\\n\\n**Python:**\\n```python\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m == 0 or n == 0:\\n            return 0\\n     \\n        pm = int(math.log2(m))\\n        pn = int(math.log2(n))\\n\\n        if pm != pn:\\n            return 0\\n\\n        newm = 1 << pm\\n        return newm + self.rangeBitwiseAnd(m & (newm-1), n & (newm-1))\\n```\\n\\n**Golang:**\\n```golang\\nfunc rangeBitwiseAnd(m int, n int) int {\\n\\tif m == 0 || n == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tpm := int(math.Log2(float64(m)))\\n\\tpn := int(math.Log2(float64(n)))\\n\\n\\tif pm != pn {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tnewm := 1 << pm\\n\\treturn newm + rangeBitwiseAnd(m&(newm-1), n&(newm-1))\\n}\\n```\\n\\n**Complexity:**\\nIn the worst case it will traverse all bits one by one and number of iteration in the algorithm is bounded by the number of bits in an integer number, which is constant - O(1)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Go"
                ],
                "code": "```\\n13 - 001101\\n14 - 001110\\n15 - 001111\\n16 - 010000 <- it will change all bits to 0. (Look at example 1)\\n17 - 010001\\n18 - 010010\\n19 - 010011\\n20 - 010100 <- 3rd and 5th bits are 1 (Look at example 2)\\n21 - 010101\\n22 - 010111 <- 3rd and 5th bits are 1\\n23 - 011000\\n```\n```java\\npublic int rangeBitwiseAnd(int m, int n) {        \\n\\tint pm = log2(m);\\n\\tint pn = log2(n);\\n\\n\\tif (m == 0 || n == 0 || pm != pn) {                         // if logarithms of numbers are different\\n\\t\\treturn 0;\\n\\t} \\n\\n\\tint newm = 1 << pm;                                         // adding number to result \\n\\treturn newm + rangeBitwiseAnd(m & (newm-1), n & (newm-1));  // unsetting first bits of both m and n \\n}\\n\\nprivate int log2(int a) {\\n\\treturn (int) (Math.log(a) / Math.log(2));\\n}\\n```\n```python\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m == 0 or n == 0:\\n            return 0\\n     \\n        pm = int(math.log2(m))\\n        pn = int(math.log2(n))\\n\\n        if pm != pn:\\n            return 0\\n\\n        newm = 1 << pm\\n        return newm + self.rangeBitwiseAnd(m & (newm-1), n & (newm-1))\\n```\n```golang\\nfunc rangeBitwiseAnd(m int, n int) int {\\n\\tif m == 0 || n == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tpm := int(math.Log2(float64(m)))\\n\\tpn := int(math.Log2(float64(n)))\\n\\n\\tif pm != pn {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tnewm := 1 << pm\\n\\treturn newm + rangeBitwiseAnd(m&(newm-1), n&(newm-1))\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 593999,
                "title": "javascript-solution",
                "content": "```\\nvar rangeBitwiseAnd = function(m, n) {\\n    let count = 0;\\n    \\n    while (m != n) {\\n        count++;\\n        m >>= 1;\\n        n >>= 1;\\n    }\\n    \\n    return m << count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rangeBitwiseAnd = function(m, n) {\\n    let count = 0;\\n    \\n    while (m != n) {\\n        count++;\\n        m >>= 1;\\n        n >>= 1;\\n    }\\n    \\n    return m << count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593340,
                "title": "one-liner-python-with-dirty-math-no-import-math",
                "content": "```\\nreturn m & (-1 << (0 if m == n else len(bin(m ^ n))-2))\\n```\\nor\\n```\\nreturn m & (-1 << (len(bin(m ^ n))-2 - int(m == n)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nreturn m & (-1 << (0 if m == n else len(bin(m ^ n))-2))\\n```\n```\\nreturn m & (-1 << (len(bin(m ^ n))-2 - int(m == n)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593281,
                "title": "java-alternative-easy-solution-4-5ms",
                "content": "The idea is to go through the all bits and check if it present in both numbers and if this bit is not larger then the difference `n-m`. \\n\\nSo in first `while` we discard all bits that are less than `n-m`, because if it is so - it means that on the way from `m` to `n` that bit will change at least once.\\n\\nIn the next `while` we append all bits that are present in both numbers and larger than difference, so it means they won\\'t change on that way. \\n\\nWe can stop when our bit is larger than `m`, because all the next bits won\\'t be present in `m`.\\n\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int d = n - m;\\n        int res = 0;\\n        long p = 1;\\n        while (p <= m && p <= d) { p = p << 1; }\\n        while (p <= m) {\\n            if ((p&n) != 0 && (p&m) != 0) res |= p;\\n            p = p << 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int d = n - m;\\n        int res = 0;\\n        long p = 1;\\n        while (p <= m && p <= d) { p = p << 1; }\\n        while (p <= m) {\\n            if ((p&n) != 0 && (p&m) != 0) res |= p;\\n            p = p << 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593205,
                "title": "easy-python-3-lsb-solution",
                "content": "Easy python- find LSB and keep flipping as long as we\\'re within the range. \\nThis all hinges on the fact that the 2\\'s complement of n is -n. So the loop runs until we exceed the range from m-n (inclusive) and we keep getting the least significant bit and subtracting that from n. When we\\'re no longer within the range, we return the value of n we\\'ve arrived at. \\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m==n:\\n            return m\\n        \\n        while (m<n):\\n            n -= (n & -n)\\n        \\n        return n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        if m==n:\\n            return m\\n        \\n        while (m<n):\\n            n -= (n & -n)\\n        \\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433266,
                "title": "c-concise-solution-with-explanation",
                "content": "The bit positions that will be set to `1` in our result are those which are `1` in every number in our given range.\\n\\nWe check each bit position as long as the value of that bit is greater than or equal to the difference between our upper and lower bound. Any lesser bits are guaranteed to flip at least once in the given range, so we don\\'t bother checking those.\\n\\nFor each bit position, simply check that the bit is set in both given bounds, since that will also ensure that every number within the range has that bit set. Add this bit to our result and continue.\\n\\n```cpp\\nint rangeBitwiseAnd(int m, int n, int res = 0) {\\n\\tfor (int p = 1 << 30; p >= max(1, n - m); p >>= 1)\\n\\t\\tif ((m & p) && (n & p))\\n\\t\\t\\tres += p;\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nint rangeBitwiseAnd(int m, int n, int res = 0) {\\n\\tfor (int p = 1 << 30; p >= max(1, n - m); p >>= 1)\\n\\t\\tif ((m & p) && (n & p))\\n\\t\\t\\tres += p;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 406460,
                "title": "bit-manipulation-solution-in-java",
                "content": "This solution makes use of the intuition of what is occuring when we AND numbers between m and n. Example given below:\\n\\nm = 5 = 0x**01**01\\nn = 7 =  0x**01**11\\n\\nNotice when we increment 5 to 7, the **01** portion never changes.\\n\\nAnother example:\\n\\nm = 73 = 0x**010**01001\\nn = 82 = 0x**010**10010\\n\\nThe **010** portion never changes.\\n\\nAs we can see, this is the portion that we care about, all other bits are subject to change as m approaches n and thus evaluate to 0 as we AND among the numbers in the range. The bolded field are the bits that will remain intact.\\n\\nWith the given intuition, we just need to grab the bolded bits and return that as the answer. The solution given below:\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int p = m ^ n;\\n        p |= p >> 1;\\n        p |= p >> 2;\\n        p |= p >> 4;\\n        p |= p >> 8;\\n        p |= p >> 16;\\n        return ~p & n;\\n    }\\n}\\n```\\n\\n`int p = m ^ n` gives us the difference between m and n. The higher-order bits that were equal in m and n will evaluate to zero. However, the bits in the lower-order bits are potentially combination of 1\\'s and 0\\'s (minus the bit adjacent to the right-most higher-order bit) illustrated below:\\n\\n0x**010**01001 ^ 0x**010**10010 = 0x**000**11011\\n\\nWe simply set all lower-level bits to 1 which is what the five lines of bit-shifts are doing. Inverse the final value to get our desired bitmask and AND it by n which gives you the answer.\\n\\np = 0x**000**11011 -> 0x**000**11111 -> 0x**111**00000\\n\\nn = 0x**010**10010\\n\\nAnswer = 0x**111**00000 & 0x**010**10010 = 0x**010**00000 = 64",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int p = m ^ n;\\n        p |= p >> 1;\\n        p |= p >> 2;\\n        p |= p >> 4;\\n        p |= p >> 8;\\n        p |= p >> 16;\\n        return ~p & n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260812,
                "title": "java-simple-explanation-100",
                "content": "Inspired from - [this Stack Overflow ans](https://stackoverflow.com/questions/31949524/bitwise-and-for-range-of-numbers).\\n2 things to consider\\n1. if the 2 numbers are equal, then their Binary representations are equal. so return the number.\\n2. We need to keep chopping off the LSB, ie. so we keep right shifting until `m` becomes equal to `n`.\\n\\nWhen it does become equal, we left shift either m or n, step times to the left, and return the resultant value.\\n\\n```\\npublic int rangeBitwiseAnd(int m, int n) {\\n        \\n        //********************\\n        int ans = 0;\\n        int step = 0;\\n        while (m != n) {\\n            //we need to keep chopping off the lsb\\n            m = m >>> 1;\\n            n = n >>> 1;\\n            step++;\\n        }\\n        ans = m << step;\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int rangeBitwiseAnd(int m, int n) {\\n        \\n        //********************\\n        int ans = 0;\\n        int step = 0;\\n        while (m != n) {\\n            //we need to keep chopping off the lsb\\n            m = m >>> 1;\\n            n = n >>> 1;\\n            step++;\\n        }\\n        ans = m << step;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224460,
                "title": "simple-c-98-solution-with-clear-explanation-in-24ms",
                "content": "Actually, if the numbers of the range of m and n are different in lowbits, after AND operation, the lowbits will be zero 0 and only these highbits can be saved , which is the final result. \\nFor example,  5 ->101,  6->110, 7->111, we can infer that the low two bits are different ,so after AND, they will be zero. The highest bit will be saved,the final result is 4->100. So only select the high bits can we get the final result, in which we can right shift operation all the numbers untill they equal to each other. for instance, 5,6,7 >> operate twice which can get the same result 4. But actually,  we just need operate the m and n, because the low bits of the numbers of boundary is more likely different.  \\n```\\nint rangeBitwiseAnd(int m, int n) \\n    {\\n        int i=0;\\n        while(m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            i++;\\n        }\\n        return m<<i;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) \\n    {\\n        int i=0;\\n        while(m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            i++;\\n        }\\n        return m<<i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 211810,
                "title": "c-o-32-shift",
                "content": "```\\nint rangeBitwiseAnd(int m, int n) {\\n    int count = 0;\\n    while(m != n){\\n        m >>= 1;\\n        n >>= 1;\\n        count += 1;\\n    }\\n    return m <<= count;\\n}\\n```\\nobservation 1:\\nm = aaaaaa1xx...xx \\nn  = aaaaaa0xx...xx\\nm, n must have the form that\\n\"the next digit\" of common prefix digits is 1 for m and 0 for n\\n\\nobservation 2:\\nn = aaaaaa0xx...xx <= aaaaaa0111...111 <= aaaaaa1000...000 <= aaaaaa1xx...xx = m\\n\\nobservation 3:\\naaaaaa0111...111 & aaaaaa1000...000 = aaaaaa0000...000\\n\\nobservation 4:\\nfor any k in [m, n], k has common prefix aaaaaa\\n\\nTherefore,  the anser is the longest common prefix in binary digits",
                "solutionTags": [],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) {\\n    int count = 0;\\n    while(m != n){\\n        m >>= 1;\\n        n >>= 1;\\n        count += 1;\\n    }\\n    return m <<= count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56720,
                "title": "simple-c-solution-counting-different-lower-bits",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int len = 0;\\n        while (m != n) { m >>= 1; n >>= 1; ++len; }\\n        return m << len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int len = 0;\\n        while (m != n) { m >>= 1; n >>= 1; ++len; }\\n        return m << len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 56756,
                "title": "simple-c-1-liner-solution-with-detailed-explanation",
                "content": "There are four steps to the solution:\\n\\n**Step 1 :** Compute Range of Numbers\\nGiven by, **( n - m )**\\n\\n**Step 2 :** Compute Number of Bits that will toggle in this range\\nGiven by, **ceil ( log ( n - m ) / log ( 2 ) )**\\n```\\nThe idea is that:\\nBit 0 (LSB) will toggle every time we move from m to n\\nBit 1 will toggle alternately\\nBit 2 will toggle every one in four times\\nand so on...\\n\\nSo taking logarithm base 2 of the above range,\\nwe can compute the number of bits that will toggle from going from right to left, \\nand hence will definitely be zero in the result.\\n```\\n\\n**Step 3 :** Take a INT_MAX integer and left shift it to the count above\\nGiven by, **INT_MAX << ( ceil ( log ( n - m ) / log ( 2 ) ) )**\\n```\\nThe idea is that:\\nResult will definitely have the number of bits calculated above as 0\\nSince these bits toggle; and\\nAND operator requires all bits under consideration to be 1 to output 1\\n```\\n**Step 4 :** Just AND the above output with m and n\\nGiven by, **( INT_MAX << ( ceil ( log ( n - m ) / log ( 2 ) ) ) ) & m & n**\\n```\\nThe idea is that:\\nWe need to retain only those bits now that are set in both m and n\\nAND it to the result from previous step\\n```\\n**So, our final code is:**\\n```\\nreturn ((INT_MAX<<((int)ceil(log(n-m)/log(2))))&m&n);\\n```",
                "solutionTags": [],
                "code": "```\\nThe idea is that:\\nBit 0 (LSB) will toggle every time we move from m to n\\nBit 1 will toggle alternately\\nBit 2 will toggle every one in four times\\nand so on...\\n\\nSo taking logarithm base 2 of the above range,\\nwe can compute the number of bits that will toggle from going from right to left, \\nand hence will definitely be zero in the result.\\n```\n```\\nThe idea is that:\\nResult will definitely have the number of bits calculated above as 0\\nSince these bits toggle; and\\nAND operator requires all bits under consideration to be 1 to output 1\\n```\n```\\nThe idea is that:\\nWe need to retain only those bits now that are set in both m and n\\nAND it to the result from previous step\\n```\n```\\nreturn ((INT_MAX<<((int)ceil(log(n-m)/log(2))))&m&n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56768,
                "title": "two-line-c-simple-solution",
                "content": "```\\nint rangeBitwiseAnd(int m, int n) {\\n    while (n > m) n &= (n-1);\\n    return n;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) {\\n    while (n > m) n &= (n-1);\\n    return n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 56791,
                "title": "my-simple-c-code",
                "content": "    int rangeBitwiseAnd(int m, int n) \\n    {\\n        for(int k=0; m>0&&n>0; k++)\\n        {\\n            if(m==n)\\n            {\\n                while(k>0)\\n                {\\n                    m=m<<1;\\n                    k--;\\n                }\\n                return m;\\n            }\\n            m=m>>1;\\n            n=n>>1;\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "    int rangeBitwiseAnd(int m, int n) \\n    {\\n        for(int k=0; m>0&&n>0; k++)\\n        {\\n            if(m==n)\\n            {\\n                while(k>0)\\n                {\\n                    m=m<<1;\\n                    k--;\\n                }\\n                return m;\\n            }\\n            m=m>>1;\\n            n=n>>1;\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56801,
                "title": "check-all-the-common-bits-from-most-significant-bit",
                "content": "    public int rangeBitwiseAnd(int m, int n) {\\n        int result = 0;\\n        \\n        for(int i = 30; i >= 0; i--){\\n            int mask = 1 << i;\\n            \\n            if((n & mask) == (m & mask)){\\n                result |= (mask & m);\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    public int rangeBitwiseAnd(int m, int n) {\\n        int result = 0;\\n        \\n        for(int i = 30; i >= 0; i--){\\n            int mask = 1 << i;\\n            \\n            if((n & mask) == (m & mask)){\\n                result |= (mask & m);\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56806,
                "title": "three-different-solutions-in-c-very-terse-and-clean",
                "content": "    int rangeBitwiseAnd(int m, int n)\\n    {\\n        int count = 0;\\n        while(m != n) //until the left identical bits, all the right will be cancelled by increments from m to n;;\\n        {\\n            m >>= 1;\\n            n >>= 1;\\n            count++;\\n        }\\n        return m << count;\\n    }\\n    \\n    \\n----------\\n    \\n    \\n    //AC - get the left common part;\\n    int rangeBitwiseAnd1(int m, int n)\\n    {\\n        int r = INT_MAX;\\n        while((m&r) != (n&r)) r <<= 1;\\n        return n&r;\\n    }\\n    \\n----------\\n    \\n    \\n    int rangeBitwiseAnd(int m, int n)\\n    {\\n        while(m < n) n &= n-1; //remove the right bit-1 until equal to or less than m;\\n        return n;\\n    }",
                "solutionTags": [],
                "code": "    int rangeBitwiseAnd(int m, int n)\\n    {\\n        int count = 0;\\n        while(m != n) //until the left identical bits, all the right will be cancelled by increments from m to n;;\\n        {\\n            m >>= 1;\\n            n >>= 1;\\n            count++;\\n        }\\n        return m << count;\\n    }\\n    \\n    \\n----------\\n    \\n    \\n    //AC - get the left common part;\\n    int rangeBitwiseAnd1(int m, int n)\\n    {\\n        int r = INT_MAX;\\n        while((m&r) != (n&r)) r <<= 1;\\n        return n&r;\\n    }\\n    \\n----------\\n    \\n    \\n    int rangeBitwiseAnd(int m, int n)\\n    {\\n        while(m < n) n &= n-1; //remove the right bit-1 until equal to or less than m;\\n        return n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56809,
                "title": "two-lines-solution-just-a-math-problem-python-c-java",
                "content": " C++:\\n\\n    #include <cmath>\\n    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int t = (int) ceil(log(n-m+1)/log(2));\\n            return m&n>>t<<t;\\n        }\\n    };\\nPython\\n\\n    from math import *\\n    class Solution(object):\\n        def rangeBitwiseAnd(self, m, n):\\n            t =  int(ceil(log(n-m+1)/log(2)))\\n            return m&n >> t << t\\n            \\nJava:\\n\\n    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int t = (int) Math.ceil(Math.log(n-m+1)/Math.log(2));\\n            return m&n >> t << t;\\n        }\\n    }\\n\\nExplanation:\\n\\n> 0b11111110000   \\n> 0b11111110001  \\n> 0b11111110010  \\n> 0b11111110011   \\n> 0b11111110100  \\n> 0b11111110101    \\n> 0b11111110110  \\n> 0b11111110111   \\n> 0b11111111000  \\n> 0b11111111001   \\n> 0b11111111010   \\n> 0b11111111011   \\n> 0b11111111100   \\n> 0b11111111101   \\n> 0b11111111110    \\n> 0b11111111111  \\n\\nWe can see every 1+1/2+1/4+1/8+1/16+1/... adjacent numbers, there must be a digit change in binary form. And if it is a \"16 + 1\" change, the smaller ones(i.e. \"8+1\", \"4+1\", \"2+1\", \"1+1\") must change (more than once) as well. And once changed, it must be from 0 to 1, or 1 to 0. Either will get 0.\\n\\nIf it is a 16+1 change, (or rather there are 16+1 numbers between m and n --- n-m+1=16+1=17) then last 5 ( ceil(log17/log2) = 5 ) must be zero after all the \"&\" operations. That's why doing \">>t<<t\", to make last five digits to be zero.\\n\\nThe special case is we are not sure about the 6th digit has changed or not, but we can know it by using m&n.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int t = (int) ceil(log(n-m+1)/log(2));\\n            return m&n>>t<<t;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 56826,
                "title": "share-my-o-1-time-solution-with-explanation-and-proof",
                "content": "With a little bit observation, we can come to a quick conclusion\\n \\n 0. when n - m == 0: the result is **n & m** \\n 1. when n - m == 1: the result is **n & m masked last 1 bit as 0**,\\n 2. when n - m == 2: the result is **n & m masked last 2 bit as 0**,\\n 3. when n - m == 4: the result is **n & m masked last 3 bit as 0**,\\n 4. when n - m == 2^i: the result is **n & m masked last i bit as 0**\\n\\nWe can proof with Induction: \\n\\nAssume when n - m = 2^i, where i > 1, we have the result of continuous AND operation from [n,m] is  **n & m masked last i bit as 0**. We denotes **R_i as number R with last i bits masked as 0**. Thus result of AND through [n, m] is **(n & m)_i**\\n\\nWe can easily proof when i == 0 and i == 1, the assumption holds.\\n\\nWhen **n'** - m == 2^(i+1). We can rewrites it as (2n-m) - m == 2^(i+1). So, AND through [m, 2n-m] equals AND through [m, n] and then through [n+1, 2n-m]. We denotes the result is **R\\u2018**\\n\\n**R'** = (m & n)_i & [ (n+1) & (2n-m)]_i \\n\\nit won't bother if we AND anther n in [n+1, 2n-m], thus\\n\\n**R'** = (m & n )_i  &  [ ( **n** ) & (2n-m) ]_i \\n\\n== (m)_i   &   (n)_i   &  (n)_i   &   (2n-m)_i \\n\\n== (m)_i  &  (n)_i & (2n-m)_i  //  since  (n)_i  & (n)_i =  (n)_i\\n\\n== (m)_i  &  (m+2^i)_i & [m+2^(i+1)]_i  // since n = m + 2^i\\n\\nDenotes the i-th bit of m as m(i), we can easily proof that when {m(i+1), m(i)} are {0,0}, {0,1}, {1,0} or {1,1},  the (i+1)-th bit of previous equation will always be 0. Moreover, we already masked last i bits, so ,the last (i+1) bits of the previous equation is 0.\\n\\n\\n\\n    class Solution(object):\\n    def rangeBitwiseAnd(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        import math\\n        if m == n: return m&n\\n        i = int(math.log(n-m, 2))\\n        return (0x7fffffff ^ (1<<i+1) -1 ) & m & n",
                "solutionTags": [],
                "code": "With a little bit observation, we can come to a quick conclusion\\n \\n 0. when n - m == 0: the result is **n & m** \\n 1. when n - m == 1: the result is **n & m masked last 1 bit as 0**,\\n 2. when n - m == 2: the result is **n & m masked last 2 bit as 0**,\\n 3. when n - m == 4: the result is **n & m masked last 3 bit as 0**,\\n 4. when n - m == 2^i: the result is **n & m masked last i bit as 0**\\n\\nWe can proof with Induction: \\n\\nAssume when n - m = 2^i, where i > 1, we have the result of continuous AND operation from [n,m] is  **n & m masked last i bit as 0**. We denotes **R_i as number R with last i bits masked as 0**. Thus result of AND through [n, m] is **(n & m)_i**\\n\\nWe can easily proof when i == 0 and i == 1, the assumption holds.\\n\\nWhen **n'** - m == 2^(i+1). We can rewrites it as (2n-m) - m == 2^(i+1). So, AND through [m, 2n-m] equals AND through [m, n] and then through [n+1, 2n-m]. We denotes the result is **R\\u2018**\\n\\n**R'** = (m & n)_i & [ (n+1) & (2n-m)]_i \\n\\nit won't bother if we AND anther n in [n+1, 2n-m], thus\\n\\n**R'** = (m & n )_i  &  [ ( **n** ) & (2n-m) ]_i \\n\\n== (m)_i   &   (n)_i   &  (n)_i   &   (2n-m)_i \\n\\n== (m)_i  &  (n)_i & (2n-m)_i  //  since  (n)_i  & (n)_i =  (n)_i\\n\\n== (m)_i  &  (m+2^i)_i & [m+2^(i+1)]_i  // since n = m + 2^i\\n\\nDenotes the i-th bit of m as m(i), we can easily proof that when {m(i+1), m(i)} are {0,0}, {0,1}, {1,0} or {1,1},  the (i+1)-th bit of previous equation will always be 0. Moreover, we already masked last i bits, so ,the last (i+1) bits of the previous equation is 0.\\n\\n\\n\\n    class Solution(object):\\n    def rangeBitwiseAnd(self, m, n):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        import math\\n        if m == n: return m&n\\n        i = int(math.log(n-m, 2))\\n        return (0x7fffffff ^ (1<<i+1) -1 ) & m & n",
                "codeTag": "Java"
            },
            {
                "id": 56843,
                "title": "simple-and-fast-java-solution-with-explanation",
                "content": "For this problem, the naive approach is to iterate from n to m and & all the values. However, this approach is time consuming because it waste time to & values which will eventually be 0.  The insight  of this problem is that we can be sure the value & from n to m will be 0 if the index of the highest 1 in n's binary representation is different from the index of the highest 1 in m's binary representation. For example if we have n=001 and m=110, we will have two value in between which could be 001 and 100 and these two & will be 0 which makes the whole value 0.  Here goes my code in java, hope it will explain itself:\\n\\n    public class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int p1=0, p2=0;\\n            int val1=m, val2=n;\\n            while(val1>1 || val2>1)\\n            {\\n                if(val1>1) \\n                {\\n                    val1=val1/2;\\n                    p1++;\\n                }\\n                if(val2>1)\\n                {\\n                    val2=val2/2;\\n                    p2++;\\n                }\\n            }\\n            if(p1!=p2) return 0;\\n            \\n            int result=~0;\\n            for(int i=m;i<n;i++)\\n                result=result&i;\\n            result=result&n;\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int rangeBitwiseAnd(int m, int n) {\\n            int p1=0, p2=0;\\n            int val1=m, val2=n;\\n            while(val1>1 || val2>1)\\n            {\\n                if(val1>1) \\n                {\\n                    val1=val1/2;\\n                    p1++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 56848,
                "title": "share-a-simple-four-line-python-solution-using-bit-operation",
                "content": "It seems that no one has post this solution which is pretty simple.\\n\\nIf we go through all the numbers from m to n, only those digits which are constantly 1 can remain to be 1 at last. So we simply operate m xor n to calculate the number of zeros at the end of result. \\n\\nThe final result should be  n>>zeors concatenates to zeros. Here is the code.\\n\\n    class Solution:\\n    # @param {integer} m\\n    # @param {integer} n\\n    # @return {integer}\\n    def rangeBitwiseAnd(self, m, n):\\n        if m == n:\\n            return m\\n        zeros = len(bin(m^n)) - 2\\n        return (n >> zeros) * (2**zeros)",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 56860,
                "title": "a-3-line-non-recursive-c-solution-with-clear-explanation",
                "content": "    // The idea is not to loop all numbers in-between or recursive\\n    // Thinking in this way:\\n    //   1. Binary counter has only 1 or 0 at each bit,\\n    //       so once it was changed once, the result on this bit must be 0,\\n    //       therefore we are looking for the bits which were changed in-between the 2 numbers.\\n    //   2. To find out the changed bits, we need only a ^ operation between m and n, for\\n    //         it's reflecting the 2 numbers difference as well as the bits part changed.\\n    //         Below sample shows the m^n result and we are interested in the leftest position of 1\\n    //       A sample: m: 00000001,10101010,00101011,11010111\\n    //                 n: 00000001,10101010,00110001,01111001\\n    //                m^n:00000000,00000000,00011010,10101110\\n    //   3. Next step is to find out the leftest position of 1 in m^n, and this is going to be done by a \\n    //        for loop and a counter. Counter will be used clear 0 in m\\n    //   4. Right shift m the counter times then shift left back same counter times,\\n    //         as is to clear all changed parts to 0.\\n    public int RangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        for(int changed = m^n; changed > 0; changed /= 2, count++); //Counting length\\n        return m >> count << count; //Clear 0s at changed bits\\n    }",
                "solutionTags": [],
                "code": "    // The idea is not to loop all numbers in-between or recursive\\n    // Thinking in this way:\\n    //   1. Binary counter has only 1 or 0 at each bit,\\n    //       so once it was changed once, the result on this bit must be 0,\\n    //       therefore we are looking for the bits which were changed in-between the 2 numbers.\\n    //   2. To find out the changed bits, we need only a ^ operation between m and n, for\\n    //         it's reflecting the 2 numbers difference as well as the bits part changed.\\n    //         Below sample shows the m^n result and we are interested in the leftest position of 1\\n    //       A sample: m: 00000001,10101010,00101011,11010111\\n    //                 n: 00000001,10101010,00110001,01111001\\n    //                m^n:00000000,00000000,00011010,10101110\\n    //   3. Next step is to find out the leftest position of 1 in m^n, and this is going to be done by a \\n    //        for loop and a counter. Counter will be used clear 0 in m\\n    //   4. Right shift m the counter times then shift left back same counter times,\\n    //         as is to clear all changed parts to 0.\\n    public int RangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        for(int changed = m^n; changed > 0; changed /= 2, count++); //Counting length\\n        return m >> count << count; //Clear 0s at changed bits\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56867,
                "title": "c-accepted-easy-to-understand-recursive",
                "content": "\\nThis answer is from @applewolf 's one line solution:\\nhttps://leetcode.com/discuss/34918/one-line-c-solution\\n\\nif number m < n, then at the last bit, there must exist both 1 and 0, so the AND result at the last bit would be 0.\\n\\nFor example,\\n4: 0100\\nAND\\n5: 0101\\n\\nSo the problem became:\\n4 >> 1: 0010 \\nAND\\n5 >> 1: 0010\\n\\nThen back 1 bit\\n0010 << 1 = 0100\\n\\n\\n    public static int RangeBitwiseAnd(int m, int n)\\n    {\\n        if (m < n)\\n        {\\n            return (RangeBitwiseAnd(m >> 1, n >> 1) << 1);\\n        }\\n        else\\n        {\\n            // m = n\\n            return m;\\n        }\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\nThis answer is from @applewolf 's one line solution:\\nhttps://leetcode.com/discuss/34918/one-line-c-solution\\n\\nif number m < n, then at the last bit, there must exist both 1 and 0, so the AND result at the last bit would be 0.\\n\\nFor example,\\n4: 0100\\nAND\\n5: 0101\\n\\nSo the problem became:\\n4 >> 1: 0010 \\nAND\\n5 >> 1: 0010\\n\\nThen back 1 bit\\n0010 << 1 = 0100\\n\\n\\n    public static int RangeBitwiseAnd(int m, int n)\\n    {\\n        if (m < n)\\n        {\\n            return (RangeBitwiseAnd(m >> 1, n >> 1) << 1);\\n        }\\n        else\\n        {\\n            // m = n\\n            return m;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56877,
                "title": "100-ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = n^m;\\n            int p = -1;\\n            while(i!=0){\\n                i>>=1;\\n                p<<=1;\\n            }\\n            return m&p;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rangeBitwiseAnd(int m, int n) {\\n            int i = n^m;\\n            int p = -1;\\n            while(i!=0){\\n                i>>=1;\\n                p<<=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 56889,
                "title": "c-cpp-soln-no-loops-recursion",
                "content": "   \\n\\n    int Log2(int n) {\\n            return log(n)/log(2);\\n     }\\n    \\n    int rangeBitwiseAnd(int m, int n) {\\n        int diff;\\n        // special case    \\n        if (m == n) \\n            return m;\\n        \\n        else {\\n            diff = Log2(n-m) + 1;\\n    \\t    m >>= diff;\\n    \\t    n >>= diff;\\n            return (m & n) << diff;\\n    \\t\\n        }\\n    \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "   \\n\\n    int Log2(int n) {\\n            return log(n)/log(2);\\n     }\\n    \\n    int rangeBitwiseAnd(int m, int n) {\\n        int diff;\\n        // special case    \\n        if (m == n) \\n            return m;\\n        \\n        else {\\n            diff = Log2(n-m) + 1;\\n    \\t    m >>= diff;\\n    \\t    n >>= diff;\\n            return (m & n) << diff;\\n    \\t\\n        }\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 56892,
                "title": "java-solution-using-math-log",
                "content": "    /*\\n        From right to left, the ith bit (start from 0) will flip every pow(2,i) numbers.\\n        We can know that some bits of result will always be 0 resulting from such bit flip.\\n        The number of that kind of bits is log2(n-m)+1. (Exception is n-m=0).\\n        And these bits are adjacent, starting from right.\\n        Let L = log2(n-m)+1. (n-m!=0)\\n        We can create a mask that all bits are '1'. And set L bits counting from right to left to '0'.\\n        Use this mask to do AND operation with (m & n).\\n        \\n        For example m=6(0000 0110) n=12(0000 1100).\\n        L = 3\\n        mask = (1111 1000)\\n        result = m & n & mask = 0\\n    */\\n    public int rangeBitwiseAnd(int m, int n) {\\n        if(m==n)\\n            return m;\\n        int dif = n-m;\\n        int log = (int) (Math.log(dif)/Math.log(2));//log = log2(dif)\\n        int base = 0xffffffff;\\n        int mask = base<<(log+1);\\n        return m & n & mask;\\n    }",
                "solutionTags": [],
                "code": "    /*\\n        From right to left, the ith bit (start from 0) will flip every pow(2,i) numbers.\\n        We can know that some bits of result will always be 0 resulting from such bit flip.\\n        The number of that kind of bits is log2(n-m)+1. (Exception is n-m=0).\\n        And these bits are adjacent, starting from right.\\n        Let L = log2(n-m)+1. (n-m!=0)\\n        We can create a mask that all bits are '1'. And set L bits counting from right to left to '0'.\\n        Use this mask to do AND operation with (m & n).\\n        \\n        For example m=6(0000 0110) n=12(0000 1100).\\n        L = 3\\n        mask = (1111 1000)\\n        result = m & n & mask = 0\\n    */\\n    public int rangeBitwiseAnd(int m, int n) {\\n        if(m==n)\\n            return m;\\n        int dif = n-m;\\n        int log = (int) (Math.log(dif)/Math.log(2));//log = log2(dif)\\n        int base = 0xffffffff;\\n        int mask = base<<(log+1);\\n        return m & n & mask;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3689623,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        return (right>left)? (rangeBitwiseAnd(left/2,right/2)<<1):left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        return (right>left)? (rangeBitwiseAnd(left/2,right/2)<<1):left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195650,
                "title": "c-solution-with-explaination",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    /* \\n    Check last bit every time \\n    When (left != right), there is at least an 1 and 0 \\n    Right shift left and right\\n    Keep doing those steps until (left = right), use a factor to record the iteration time.\\n    Find the bigest same part\\n    Left shift to get the result\\n    */\\n    public int RangeBitwiseAnd(int left, int right) \\n    {\\n        var count = 0;\\n\\n        while(left != right)\\n        {\\n            count++;\\n            left = left >> 1;\\n            right = right >> 1;\\n        }\\n\\n        return left << count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    /* \\n    Check last bit every time \\n    When (left != right), there is at least an 1 and 0 \\n    Right shift left and right\\n    Keep doing those steps until (left = right), use a factor to record the iteration time.\\n    Find the bigest same part\\n    Left shift to get the result\\n    */\\n    public int RangeBitwiseAnd(int left, int right) \\n    {\\n        var count = 0;\\n\\n        while(left != right)\\n        {\\n            count++;\\n            left = left >> 1;\\n            right = right >> 1;\\n        }\\n\\n        return left << count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177705,
                "title": "aisa-soln-nahi-dekha-hoga",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left==0 || right==0) return 0;\\n        if(left==right) return left;\\n        int x = log10(left)/log10(2);\\n        int y = log10(right)/log10(2);\\n        if(y-x>=1) return 0;\\n        long long ans = left;\\n        for(long long i=left+1;i<=right;i++) ans&=i; \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left==0 || right==0) return 0;\\n        if(left==right) return left;\\n        int x = log10(left)/log10(2);\\n        int y = log10(right)/log10(2);\\n        if(y-x>=1) return 0;\\n        long long ans = left;\\n        for(long long i=left+1;i<=right;i++) ans&=i; \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164488,
                "title": "short-simple-javascript-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst shift the left & right AND\\'s while they are not equal. Once they are equal then add zero at the end the number of times we shifted, the resultent is our answer.\\n# Code\\n```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar rangeBitwiseAnd = function(left, right) {\\n    var i = 0\\n    while(left != right){\\n        i++\\n        left >>= 1\\n        right >>= 1\\n\\n    }\\n    return left << i\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nvar rangeBitwiseAnd = function(left, right) {\\n    var i = 0\\n    while(left != right){\\n        i++\\n        left >>= 1\\n        right >>= 1\\n\\n    }\\n    return left << i\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3110066,
                "title": "201-simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left==right)\\n        return left;\\n        for(long long int i=left;i<=right;i++)\\n        {\\n            left&=i;\\n            if(left==0)\\n            return left;    \\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left==right)\\n        return left;\\n        for(long long int i=left;i<=right;i++)\\n        {\\n            left&=i;\\n            if(left==0)\\n            return left;    \\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811354,
                "title": "c-bit-manipulation-self-explanatory-clean-short",
                "content": "![image](https://assets.leetcode.com/users/images/ffad2c35-4435-40c8-9dd4-36d08ccb5c81_1668353836.3737333.png)\\n\\n**n==right-left\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint rangeBitwiseAnd(int left, int right) {\\n\\t\\t\\t\\tlong long ans=left;\\n\\t\\t\\t\\tfor(long long i=left;i<=right;i++){\\n\\t\\t\\t\\t\\tans&=i;\\n\\t\\t\\t\\t\\tif(!ans) return 0;\\n\\t\\t\\t\\t}    \\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint rangeBitwiseAnd(int left, int right) {\\n\\t\\t\\t\\tlong long ans=left;\\n\\t\\t\\t\\tfor(long long i=left;i<=right;i++){\\n\\t\\t\\t\\t\\tans&=i;\\n\\t\\t\\t\\t\\tif(!ans) return 0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2686827,
                "title": "python-bits-manipulation-solution-with-detailed-intuition",
                "content": "```\\n\\'\\'\\'\\n# Intuition:\\nTraverse from LSB to MSB and keep right-shifting left and right until both of them become equal. \\nIf at any bit position left side bits of left and right are equal ie. left == right, \\nthen all numbers in [left, right] will also be equal.\\n\\ne.g.\\nbit index =  3 2 1 0\\nleft =  12 = 1 1 0 0\\n        13 = 1 1 0 1\\n        14 = 1 1 1 0\\nright = 15 = 1 1 1 1\\n\\nAfter right-shifting left and right 2 times(ie. count = 2), left == right = 12 = 13 = 14 = 15 = 0 0 1 1\\nSo \\'&\\' of all number in [left, right] is (left << count)\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        count = 0\\n        \\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            count += 1\\n        \\n        return left << count\\n                \\n        \\n# Time: O(1)\\n# Space: O(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\'\\'\\'\\n# Intuition:\\nTraverse from LSB to MSB and keep right-shifting left and right until both of them become equal. \\nIf at any bit position left side bits of left and right are equal ie. left == right, \\nthen all numbers in [left, right] will also be equal.\\n\\ne.g.\\nbit index =  3 2 1 0\\nleft =  12 = 1 1 0 0\\n        13 = 1 1 0 1\\n        14 = 1 1 1 0\\nright = 15 = 1 1 1 1\\n\\nAfter right-shifting left and right 2 times(ie. count = 2), left == right = 12 = 13 = 14 = 15 = 0 0 1 1\\nSo \\'&\\' of all number in [left, right] is (left << count)\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        count = 0\\n        \\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            count += 1\\n        \\n        return left << count\\n                \\n        \\n# Time: O(1)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686824,
                "title": "python-bits-manipulation-solution-with-detailed-intuition",
                "content": "```\\n\\'\\'\\'\\n# Intuition:\\nTraverse from LSB to MSB and keep right-shifting left and right until both of them become equal. \\nIf at any bit position left side bits of left and right are equal ie. left == right, \\nthen all numbers in [left, right] will also be equal.\\n\\ne.g.\\nbit index =  3 2 1 0\\nleft =  12 = 1 1 0 0\\n        13 = 1 1 0 1\\n        14 = 1 1 1 0\\nright = 15 = 1 1 1 1\\n\\nAfter right-shifting left and right 2 times(ie. count = 2), left == right = 12 = 13 = 14 = 15 = 0 0 1 1\\nSo \\'&\\' of all number in [left, right] is (left << count)\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        count = 0\\n        \\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            count += 1\\n        \\n        return left << count\\n                \\n        \\n# Time: O(1)\\n# Space: O(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\'\\'\\'\\n# Intuition:\\nTraverse from LSB to MSB and keep right-shifting left and right until both of them become equal. \\nIf at any bit position left side bits of left and right are equal ie. left == right, \\nthen all numbers in [left, right] will also be equal.\\n\\ne.g.\\nbit index =  3 2 1 0\\nleft =  12 = 1 1 0 0\\n        13 = 1 1 0 1\\n        14 = 1 1 1 0\\nright = 15 = 1 1 1 1\\n\\nAfter right-shifting left and right 2 times(ie. count = 2), left == right = 12 = 13 = 14 = 15 = 0 0 1 1\\nSo \\'&\\' of all number in [left, right] is (left << count)\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        count = 0\\n        \\n        while left != right:\\n            left = left >> 1\\n            right = right >> 1\\n            count += 1\\n        \\n        return left << count\\n                \\n        \\n# Time: O(1)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549796,
                "title": "c-two-simple-approach-brute-force-and-bit-manipulation",
                "content": "**Brute Force Approach:**\\nThe naive approach would be to traverse all the numbers from left to right, compute the AND, and subsequently store it as we proceed. \\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        long ans=left;\\n        for(long i=left; i<=right; i++) {\\n            ans &= i;\\n            if(ans==0) return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n`Time Complexity: O(n)`\\n\\n</br>\\n\\n**Bit Manipulation (Considering LSB):**\\nApproach...\\n* For every pair of continuous numbers, the last bit is different from the previous one(one is always 0 and the other is always 1 because continuous numbers form an even-odd pair or vice-versa). Hence, until both numbers are not equal, the resultant bitwise AND of the rightmost bit is always zero.\\n* So we check if the bits of *left* are equal to that of *right* or not.\\n* If they are not equal, we right shift our numbers, which basically removes the rightmost bit from the numbers.\\n* We keep a count of the number of shifts, say *count*.\\n* If the numbers are equal, we leftshift the remaining number count times. \\n* This gives us the required answer.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right) {\\n            left >>= 1;\\n            right >>= 1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n};\\n```\\n\\n`Time Complexity: O(log(n))`\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        long ans=left;\\n        for(long i=left; i<=right; i++) {\\n            ans &= i;\\n            if(ans==0) return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count=0;\\n        while(left!=right) {\\n            left >>= 1;\\n            right >>= 1;\\n            count++;\\n        }\\n        return left<<count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528555,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Bit Manipulation***\\n\\n* ***Time Complexity :- O(Constant)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        // count the no. of right shift required to make left and right equal\\n        \\n        int right_shift_count = 0;\\n        \\n        // do right shifting of both the left and right until both becomes equal\\n        \\n        while(left != right)\\n        {\\n            left = left >> 1;\\n            \\n            right = right >> 1;\\n            \\n            right_shift_count++;\\n        }\\n        \\n        // now do the left shift of left by right_shift_count\\n        \\n        int ans = left << right_shift_count;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        // count the no. of right shift required to make left and right equal\\n        \\n        int right_shift_count = 0;\\n        \\n        // do right shifting of both the left and right until both becomes equal\\n        \\n        while(left != right)\\n        {\\n            left = left >> 1;\\n            \\n            right = right >> 1;\\n            \\n            right_shift_count++;\\n        }\\n        \\n        // now do the left shift of left by right_shift_count\\n        \\n        int ans = left << right_shift_count;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332948,
                "title": "c-using-bit-manipulation-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int t=0;\\n        while(left!=right){\\n            left= left>>1;\\n            right= right>>1;\\n            t++;\\n        }\\n        int ans= left;\\n        while(t--){\\n            ans= ans<<1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int t=0;\\n        while(left!=right){\\n            left= left>>1;\\n            right= right>>1;\\n            t++;\\n        }\\n        int ans= left;\\n        while(t--){\\n            ans= ans<<1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163983,
                "title": "c-solution-93-71-time-74-32-space-left-and-right-shift",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right);\\n};\\n/**************************************************************************/\\nint Solution::rangeBitwiseAnd(int left, int right) {\\n    int i{};\\n    while (left != right) {\\n        ++i;\\n        left>>=1; \\n        right>>=1;\\n    }\\n    return left<<i;\\n}\\n/**************************************************************************/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right);\\n};\\n/**************************************************************************/\\nint Solution::rangeBitwiseAnd(int left, int right) {\\n    int i{};\\n    while (left != right) {\\n        ++i;\\n        left>>=1; \\n        right>>=1;\\n    }\\n    return left<<i;\\n}\\n/**************************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154765,
                "title": "c-solution-with-explanation",
                "content": "We can observe that whenever a bit is flipped going from left to right, the output for that bit will be 0 (as 1&0 and 0&1 both equals 0.) and also see that whichever column has a flipped bit, all the columns right to that will also have a flipped bit. \\nexample: left = 20; right = 24;\\nleft = 20 =>    10100\\nright = 23 =>  10111\\nrightmost 2 columns will give 00(as both have flipped bits) while the other three columns will remain as it is.\\nso we can maintain a counter for the no. of flipped bits and right shift until m == n. when m==n we will left shift by count to add 0s at the end which came from the flipped bits.\\nso for this the output will be 10100.\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count = 0;\\n        while(left != right) {\\n            left>>=1;\\n            right>>=1;\\n            count++;\\n        }\\n        return left<<=count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        int count = 0;\\n        while(left != right) {\\n            left>>=1;\\n            right>>=1;\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1884657,
                "title": "c-o-32-bit-operation-simple-solution-with-explanation",
                "content": "# Solution 1 (R)\\n\\nWe can find the most shared bits from left side to right side for `left` and `right` by `right &= (right-1)` until `right` \\u2264 `left` .\\n\\nFor example: `right` = `11100011`, `left` = `11000010`, then shared bits would be `11000000`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        while (right > left) {\\n            right &= (right-1);\\n        }\\n        return right;\\n    }\\n};\\n```\\n\\n**Time:** `O(32)`   \\n**Space:** `O(1)`",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        while (right > left) {\\n            right &= (right-1);\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850975,
                "title": "intuitive-simple-and-clean-well-explained-with-proof",
                "content": "Claim :  if run loop on bits from right to left if we came accross any bits which are unequal \\nwe will break from there and calculate the answer while looping why it is so ? \\n\\nleft :    00000010000000\\nright :  00000010101010\\n\\nBecause there exists an number which is in the form of the power of 2 which will make always make 0\\nrest of the bits.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        int ans = 0;\\n        for(int i=30;i>=0;i--){\\n            if((m & (1 << i)) != (n & (1 << i))) break;\\n            ans = ans | (m & (1 << i));\\n        }\\n        return ans;   \\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        int ans = 0;\\n        for(int i=30;i>=0;i--){\\n            if((m & (1 << i)) != (n & (1 << i))) break;\\n            ans = ans | (m & (1 << i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1741397,
                "title": "c",
                "content": "If a bit at ```i```-th (```0 <= i <= 31```) position is ```0``` in either ```left``` or ```right``` then the bit in the result at this position will also be ```0```, since we need at least one ```0``` to set all bits to ```0```. If not, i.e., both have their bits set at this ```i```, then check if the gap between these two numbers is less than or equal to ```2^i - 1```. On observation, one can see that the max-run of ```1```s (or ```0```s) is equal to ```2^i``` for the ```i```-th bit. Thus, if gap between inputs is greater than this range, then this range has at least one ```0``` for this ```i```.\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r)\\n    {\\n        if (l == r) return l;\\n        if (!l || !r) return 0;\\n        int n = 0;\\n        for (int i = 0; i < 31; ++i) {\\n            if (((l & (1 << i)) == 0) || ((r & (1 << i)) == 0)) continue;\\n            if ((r - l <= (1 << i) - 1)) {\\n                n |= (1 << i);\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```i```\n```0 <= i <= 31```\n```0```\n```left```\n```right```\n```0```\n```0```\n```0```\n```i```\n```2^i - 1```\n```1```\n```0```\n```2^i```\n```i```\n```0```\n```i```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int l, int r)\\n    {\\n        if (l == r) return l;\\n        if (!l || !r) return 0;\\n        int n = 0;\\n        for (int i = 0; i < 31; ++i) {\\n            if (((l & (1 << i)) == 0) || ((r & (1 << i)) == 0)) continue;\\n            if ((r - l <= (1 << i) - 1)) {\\n                n |= (1 << i);\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726706,
                "title": "c-all-possible-solutions",
                "content": "Approach 1: Brute force\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        int result = left;\\n        \\n        for(int i = left + 1; i <= right; i++)\\n            result = result & i;\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nApproach 2: Use the property of BITWISE AND\\nMore explanation [here](https://leetcode.com/problems/bitwise-and-of-numbers-range/discuss/593317/Simple-3-line-Java-solution-faster-than-100#:~:text=Consider%20the%20following%20example%3A)\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        // Idea is bitwise and of 2 numbers will be less than or equal to that number\\n        // When u are given numbers in range there is no need to do repetitve AND\\n        // if u get a less answer that is good as ultimately u will reach there anyhow.\\n        // so, if u are reaching end directly why take longer steps to reach there.\\n        \\n        int result = right;\\n        \\n        while(right > left) {\\n            result = right & (right - 1);\\n            right = result;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        int result = left;\\n        \\n        for(int i = left + 1; i <= right; i++)\\n            result = result & i;\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        \\n        // Idea is bitwise and of 2 numbers will be less than or equal to that number\\n        // When u are given numbers in range there is no need to do repetitve AND\\n        // if u get a less answer that is good as ultimately u will reach there anyhow.\\n        // so, if u are reaching end directly why take longer steps to reach there.\\n        \\n        int result = right;\\n        \\n        while(right > left) {\\n            result = right & (right - 1);\\n            right = result;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602277,
                "title": "simple-c-solution-0ms-100",
                "content": "```\\nint rangeBitwiseAnd(int left, int right){\\n    int reset = 0;\\n    while(left != right)\\n    {\\n        left >>= 1;\\n        right >>= 1;\\n        reset += 1;\\n    }\\n    return left << reset;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rangeBitwiseAnd(int left, int right){\\n    int reset = 0;\\n    while(left != right)\\n    {\\n        left >>= 1;\\n        right >>= 1;\\n        reset += 1;\\n    }\\n    return left << reset;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1595589,
                "title": "java-solution-kernighans-algo",
                "content": "class Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        \\n\\n     while(right>left){         \\n         right=right&(right-1);         \\n     }\\n    return right;\\n}}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int rangeBitwiseAnd(int left, int right) {\\n        \\n\\n     while(right>left){         \\n         right=right&(right-1);         \\n     }",
                "codeTag": "Java"
            },
            {
                "id": 1514638,
                "title": "one-line-solution-for-any-language-o-log-n",
                "content": "The key is to realise that if the left and right are equal, then that is your answer. If they are unequal, then you *know* that:\\n\\n(a) the last digit of your answer must be 0 \\n    (because your range contains at least one odd and one even number)\\nand\\n\\n(b) the remaining digits can be solved by recursively calling yourself, with the last digit removed from both the left and the right.\\n\\nThis is classic recursion which is easiest to understand like this:\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        if right==left:\\n            return left\\n        if right>left:\\n            return 2*Solution.rangeBitwiseAnd(self,left>>1,right>>1)\\n```\\n\\nThe one-line version? Just use a ternary expression in your language of choice. 8-)\\n\\nPython\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n\\t\\treturn left if right==left else Solution.rangeBitwiseAnd(self,left>>1,right>>1)*2\\n```\\n\\t\\t\\t\\nJavascript and other curly-bracket languages with a \"?\", \":\" ternary operator can use this one-liner:\\n\\n\\t\\treturn (right===left) ? left : Solution.rangeBitwiseAnd(self,left>>1,right>>1)*2\\n\\nI think this is easier than the other so-called \"medium\" cases that took me hours and hours!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        if right==left:\\n            return left\\n        if right>left:\\n            return 2*Solution.rangeBitwiseAnd(self,left>>1,right>>1)\\n```\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n\\t\\treturn left if right==left else Solution.rangeBitwiseAnd(self,left>>1,right>>1)*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514567,
                "title": "javascript-loop-less-o-1-explained",
                "content": "For a range of binary numbers, observe the following:\\n\\n- Bitwise AND means that the `n`th bit of the result is `1` only if there are no `0`s at the `n`th bit of any numbers in the range.\\n- If the `n`th bit changes in the range, then either of them must be `0`, so the `n`th bit of the output will be `0`.\\n- If the `n`th bit changes in the range, the `n-1`th bit must also change (it must carry to the `n`th bit, resetting to `0` in  the process).\\n\\nConsidering these, we can figure out that we have to find the the last bit from the left that doesn\\'t change; all bits to the right of that bit will be zeros.\\n\\nTo find changes, we can use XOR, that will make the `n`th bit a `1` if it is different in the start and the end number of the range. Although this doesn\\'t detect bits that change multiple times in the range, we are only looking for the first change, which has to be a single change (otherwise it would carry, causing the next bit to change once). Then, find the bit before the first `1` (i.e. the first change) by using `Math.clz32()` (`c`ount `l`eading `z`eroes `32` bit).\\n\\nOnce we have that, we can just make a bitmask by starting with an all-ones pattern (i.e. `0xffffffff`, NOT `0` or `~0`), then shifting it to the left as many times as many bits we have to the right of the last `0` (equal) bit. That can be found by subtracting the count of leading zeroes from the number of bits, `32` in this case.\\n\\nFinally, AND the mask with either number in the range (the relevant part is where they\\'re all the same, so it doesn\\'t matter which one).\\n\\nCode:\\n```\\nvar rangeBitwiseAnd = function(left, right) {\\n  return left & (~0 << (32 - Math.clz32(left ^ right)))\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rangeBitwiseAnd = function(left, right) {\\n  return left & (~0 << (32 - Math.clz32(left ^ right)))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514420,
                "title": "python-solution-explained",
                "content": "It\\'s clear that a naive loop or map ANDing all the numbers in the range is inefficient and unnecessary.\\n\\nFor AND to return 1 for a particular bit in a range of numbers that bit has to be set for every number in said range. Which leads to the observation that only bits that are 1 in both left and right can possibly be 1 in our answer.\\n\\nso possible_bits = left & right gets us part way to the solution.\\n\\nNow we only have to consider bits that flip as you increment left to get to right.\\n\\nThe least significant bit can only ever be 1 in a \"range\" of 1 number. It will flip if you increment just once. Similarly the 2nd bit can only be 1 in a range of 2 numbers, ending ...bbb10 and ...bbb11. Another increment and we end ...bb100 flipping the 2nd bit...and so on.\\n\\nSo we can create a mask as the logical NOT of 1 less than the next power of 2 of the length of the range, and use it to mask out the least significant bits in our possible_bits. e.g if our range is 5, the mask is bbbb11111000. \\n\\n```\\n   def nextPowerOf2(n):\\n        n -= 1\\n        n |= n >> 1\\n        n |= n >> 2\\n        n |= n >> 4\\n        n |= n >> 8\\n        n |= n >> 16\\n        n += 1\\n        return n\\n    mask = ~(nextPowerOf2(right - left + 1) - 1)\\n    possible_bits = left & right\\n    return possible_bits & mask\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n   def nextPowerOf2(n):\\n        n -= 1\\n        n |= n >> 1\\n        n |= n >> 2\\n        n |= n >> 4\\n        n |= n >> 8\\n        n |= n >> 16\\n        n += 1\\n        return n\\n    mask = ~(nextPowerOf2(right - left + 1) - 1)\\n    possible_bits = left & right\\n    return possible_bits & mask\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1514194,
                "title": "c-simple-solution-one-line-0ms-faster-than-100-with-explanation",
                "content": "when we list the range from left to right, we can find that when a binary number is carried, the number after this number will be 0.\\nlike 0011 to 0100, the number behind 01 become 00 -> 0100.\\n```\\n0001\\n0010\\n0011\\n0100\\n0101\\n0110\\n0111\\n1000\\n```\\nif we know the leftmost carried number, the number behind the leftmost carried number will be 0 too.\\nAnd we know that the number before the leftmost carried number will not change.\\nSo the answer has to be:\\n1. the number behind the leftmost carried number will be 0.\\n2. the number before the leftmost carried number will not change.\\n\\n\\nThen how to find out the leftmost carried number?\\nwe know that the carried number between the left and right is differnt.\\nfor example [5,7]\\n![image](https://assets.leetcode.com/users/images/d50b3000-04e5-43b3-91ef-3f70568bc353_1633869900.7822227.png)\\nthen we just need to use right(111) to & 100 (the number behind the leftmost carried number is 0)\\n111 & 100 = 100\\n\\nAnother Example: 38(100110) -> 45(101101)\\n![image](https://assets.leetcode.com/users/images/1a79db5c-e2a4-48a0-85f9-14b2fc98c5d6_1633870763.4848013.png)\\nthen 32(100000) is the answer we want.\\nHow can we find the leftmost carried number, and turn the number behind the leftmost carried number into 0?\\nwe know that the number before the leftmost carried number will not change. \\nWhy don\\'t we turn every rightmost 1 into 0 and check if the rest of the numbers are the same?\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        for(; left < right; right -= right & -right);\\n\\t\\treturn right;\\n    }\\n};\\n```\\nwe can use expression (x & -x) to find out the rightmost 1.\\n\\nCan we find out leftmost carried numebr without using loop?\\nyes we can. we know that carried number is different in binary numbers.\\nWe can use left ^ right to get every different number, and the leftmost 1 is the leftmost carried number.\\nthen 1 << (int)log2(left ^ right) is the leftmost carried number we want.\\n\\nhow can we use this number to turn the number behind into 0, and keep the other number the same?\\nwe can use -1 ^ ((1 << (int)log2(left ^ right)) - 1)) to do that.\\nfor example [38, 45]\\nleft ^ right = 11 (001011)\\n1 << (int)log2(left ^ right) = 8 (001000)\\n-1 ^ ((1 << (int)log2(left ^ right)) - 1)) = (111000)\\n1 & no matter 1 or 0 is to be the same.\\nso we use 1 to keep the number before the leftmost carried number the same.\\nright 45(101101) & (111000) = 101000\\nwe also need to change the leftmost number into 0.\\nso we use left 38(100110) & 101000 = 100000\\nthen we get the answer.\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        return left & right & (left == right? -1 : -1 ^ ((1 << (int)log2(left ^ right)) - 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n0001\\n0010\\n0011\\n0100\\n0101\\n0110\\n0111\\n1000\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        for(; left < right; right -= right & -right);\\n\\t\\treturn right;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n        return left & right & (left == right? -1 : -1 ^ ((1 << (int)log2(left ^ right)) - 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513163,
                "title": "c-match-prefix",
                "content": "**Intuition**\\nSummarizing the problem, we\\'d like to calculate the below:\\n`rangeAnd(left, right) = left & left + 1 & ... & right - 1 & right`\\nin a smarter fashion. \\n\\nThe main trick to this problem is the observation that only the common most signficant bits between the left and right ranges are preserved when performing an `AND` operation between all values in the range `[left, right]`. \\n\\nTo see why this is the case, we can supposing that the numbers do indeed differ at some intermediate bit, with `left < right`. This will result in something like:\\n```\\nleft:  0 0 ... 1 x0 x1 ... xp-1 xp 0 y y ... y y\\nright: 0 0 ... 1 x0 x1 ... xp-1 xp 1 y y ... y y\\n```\\n\\nwhere the `1 x0 x1 ... xp-1 xp` headers align in `left` and `right`. Notice that because we include all numbers within `[left, right]`, we know that the number `mid` exists in the range, which will effectively clear out the rightmost range:\\n```\\nleft:  0 0 ... 1 x0 x1 ... xp-1 xp 0 y y ... y y\\nright: 0 0 ... 1 x0 x1 ... xp-1 xp 1 y y ... y y\\nmid:   0 0 ... 1 x0 x1 ... xp-1 xp 1 0 0 ... 0 0\\n```\\n\\nFurthermore, the `0` and `1` mismatch between `left` and `right` implies that this position will be cleared after performing all `AND` operations, due to the contribution of `left`. Therefore, the expected `AND` of all numbers in `[left, right]` and be summarized by:\\n```\\nrangeAnd(left, right) = left & mid & right = longest matching prefix of left and right\\n```\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    /***\\n     * Return the bitwise and of all numbers from left to right inclusive\\n     * Key: Suppose left is something like:\\n     * 00001xxxxx\\n     * and right is something larger, so it\\'s:\\n     * yxxxxxxxxx\\n     * \\n     * Off the rip we know the largest bit of left to largest bit of right should be zeroed out\\n     * Ex:\\n     * left = 7 = 0111\\n     * right= 9 = 1001\\n     * Because 8 = 1000 falls in between all three bits will end up being cleared...\\n     * Optimal: just get the longest prefix chain of 1s that are common between left and right\\n     ***/\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left > right) {\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        for(\\n            int bit = 0, lMSB = getMsb(left), rMSB = getMsb(right);\\n            (bit = (lMSB & left)) == (rMSB & right) && lMSB != 0;  // prefix matches and haven\\'t exhausted both\\n            res |= bit, lMSB >>= 1, rMSB >>= 1                     // extend result, extract next msb\\n        );\\n        \\n        return res;\\n    }\\n    \\n    /***\\n     * Given a 32-bit integer x get its most significant bit only\\n     * Ex: x = 0000 0000 0000 0000 0000 1xxx xxxx xxxx\\n             =>0000 0000 0000 0000 0000 1000 0000 0000\\n     ***/\\n    int getMsb(int x) {\\n        if(x == 0) {\\n            return 0;\\n        }\\n        \\n        int res = 0x01; // figure out where to put the singleton 1\\n        if(x & 0xFFFF0000) { // check top 16 bits of 32-bit number; if any bit is set within this range, adjust\\n            x >>= 16;\\n            res <<= 16;\\n        }\\n        \\n        if(x & 0x0000FF00) { // check top 8 bits of 16-bit number\\n            x >>= 8;\\n            res <<= 8;\\n        }\\n        \\n        if(x & 0x000000F0) { // check top 4 bits of 8 bit number\\n            x >>= 4;\\n            res <<= 4;\\n        }\\n        \\n        if(x & 0x0000000c) { // check top 2 bits of 4 bit number \\n            x >>= 2;\\n            res <<= 2;\\n        }\\n        \\n        if(x & 0x00000002) {\\n            x >>= 1;\\n            res <<= 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nleft:  0 0 ... 1 x0 x1 ... xp-1 xp 0 y y ... y y\\nright: 0 0 ... 1 x0 x1 ... xp-1 xp 1 y y ... y y\\n```\n```\\nleft:  0 0 ... 1 x0 x1 ... xp-1 xp 0 y y ... y y\\nright: 0 0 ... 1 x0 x1 ... xp-1 xp 1 y y ... y y\\nmid:   0 0 ... 1 x0 x1 ... xp-1 xp 1 0 0 ... 0 0\\n```\n```\\nrangeAnd(left, right) = left & mid & right = longest matching prefix of left and right\\n```\n```\\nclass Solution {\\npublic:\\n    /***\\n     * Return the bitwise and of all numbers from left to right inclusive\\n     * Key: Suppose left is something like:\\n     * 00001xxxxx\\n     * and right is something larger, so it\\'s:\\n     * yxxxxxxxxx\\n     * \\n     * Off the rip we know the largest bit of left to largest bit of right should be zeroed out\\n     * Ex:\\n     * left = 7 = 0111\\n     * right= 9 = 1001\\n     * Because 8 = 1000 falls in between all three bits will end up being cleared...\\n     * Optimal: just get the longest prefix chain of 1s that are common between left and right\\n     ***/\\n    int rangeBitwiseAnd(int left, int right) {\\n        if(left > right) {\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        for(\\n            int bit = 0, lMSB = getMsb(left), rMSB = getMsb(right);\\n            (bit = (lMSB & left)) == (rMSB & right) && lMSB != 0;  // prefix matches and haven\\'t exhausted both\\n            res |= bit, lMSB >>= 1, rMSB >>= 1                     // extend result, extract next msb\\n        );\\n        \\n        return res;\\n    }\\n    \\n    /***\\n     * Given a 32-bit integer x get its most significant bit only\\n     * Ex: x = 0000 0000 0000 0000 0000 1xxx xxxx xxxx\\n             =>0000 0000 0000 0000 0000 1000 0000 0000\\n     ***/\\n    int getMsb(int x) {\\n        if(x == 0) {\\n            return 0;\\n        }\\n        \\n        int res = 0x01; // figure out where to put the singleton 1\\n        if(x & 0xFFFF0000) { // check top 16 bits of 32-bit number; if any bit is set within this range, adjust\\n            x >>= 16;\\n            res <<= 16;\\n        }\\n        \\n        if(x & 0x0000FF00) { // check top 8 bits of 16-bit number\\n            x >>= 8;\\n            res <<= 8;\\n        }\\n        \\n        if(x & 0x000000F0) { // check top 4 bits of 8 bit number\\n            x >>= 4;\\n            res <<= 4;\\n        }\\n        \\n        if(x & 0x0000000c) { // check top 2 bits of 4 bit number \\n            x >>= 2;\\n            res <<= 2;\\n        }\\n        \\n        if(x & 0x00000002) {\\n            x >>= 1;\\n            res <<= 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498764,
                "title": "python-if-the-range-contains-any-number-which-is-a-power-of-2-then-the-answer-will-always-be-0",
                "content": "```\\n# if there is a power of 2 in the range then the answer will always be zero due to the fact that ((2^n&((2^n)-1)) = 0)\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        # this is to check if there is a power of 2 in the range\\n        if left*2 <= right:\\n            return 0\\n        result = left\\n        for i in range(left+1,right+1):\\n            result = result&i\\n        return result;\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# if there is a power of 2 in the range then the answer will always be zero due to the fact that ((2^n&((2^n)-1)) = 0)\\nclass Solution:\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        # this is to check if there is a power of 2 in the range\\n        if left*2 <= right:\\n            return 0\\n        result = left\\n        for i in range(left+1,right+1):\\n            result = result&i\\n        return result;\\n",
                "codeTag": "Java"
            },
            {
                "id": 1391827,
                "title": "bitwise-and-of-numbers-range-c-solution-constant-space-and-constant-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n     \\n        int count = 0;\\n        while(left != right){\\n            left >>= 1;\\n            right >>= 1;\\n            count++;\\n        }\\n        \\n        int ans = left<<count;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n     \\n        int count = 0;\\n        while(left != right){\\n            left >>= 1;\\n            right >>= 1;\\n            count++;\\n        }\\n        \\n        int ans = left<<count;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241050,
                "title": "python-faster-than-98",
                "content": "\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        shift = 0\\n        #find the common left header (or, same prefix) of left and right\\n        while left != right:\\n            left >>= 1 #shift to right by 1 bit\\n            right >>= 1\\n            shift += 1\\n        #then shift back to left to form the final result\\n        #(the remaining bits are not the same, so definitely result in 0 after AND)\\n        return left << shift",
                "solutionTags": [],
                "code": "\\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\\n        shift = 0\\n        #find the common left header (or, same prefix) of left and right\\n        while left != right:\\n            left >>= 1 #shift to right by 1 bit\\n            right >>= 1\\n            shift += 1\\n        #then shift back to left to form the final result\\n        #(the remaining bits are not the same, so definitely result in 0 after AND)\\n        return left << shift",
                "codeTag": "Python3"
            },
            {
                "id": 1227393,
                "title": "c-if-condition-and-one-for-loop-simple-observation",
                "content": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n    long long int res=left; \\n    if(left==right)\\n        return left;\\n        \\n    if(  int( log2(right) ) !=  int( log2(left) ) )\\n            return 0;\\n        \\n    for(long long int i=left+1;i<=right;i++)\\n         res=res&i;\\n        \\n     return res;\\n    }\\n};\\n```\\n\\nSimple Observation is\\n if(  int( log2(right) ) !=  int( log2(left) ) )\\n            return 0;\\n\\n4    100\\n5    101\\n6    110\\n7    111\\n---------\\n8   1000\\n\\nso from number 4 to 7  (all having their integral log base 2 value same))\\nso any range between [ 4 , 7 ] will never be zero over AND Operation. and we can find answer by iterating from left to right.\\n\\nBut as soon as you add 8 in the range AND of all elements is zero.\\nie. say left= 5 and right=8 \\nlog2(left) =2 and log2(right)=3   not equal.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int left, int right) {\\n    long long int res=left; \\n    if(left==right)\\n        return left;\\n        \\n    if(  int( log2(right) ) !=  int( log2(left) ) )\\n            return 0;\\n        \\n    for(long long int i=left+1;i<=right;i++)\\n         res=res&i;\\n        \\n     return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905732,
                "title": "python-3-faster-than-94-less-space-than-100",
                "content": "Explanation:\\n1. If bit m[i] == 0 or n[i] == 0 -> res[i] == 0\\n2. Therefor we need to deal only with cases of m[i] == n[i] == 1, and check whether in range m-n bit i == 0.\\n3. bit i will change from 1 to 0 if n - m is more or equal to pow(2, i)\\n4. (if bit i changed from 1 to 0 with n -m < pow(2, i) - that means n[i] == 0 and its covered in #1)\\n5. the result is  m & n (#1) & mask_that_holds_0_for_bits_that_change\\n\\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        diff = n - m\\n        mask = 9223372036854775807  # sys.maxsize\\n        for i in range(0, 32):\\n            curr = 1 << i           # pow(2, i)\\n            if diff >= curr:        # somewhere in range m - n bit i will be 0, if m[i] == 1\\n                mask = mask ^ curr  #  set bit i to 0\\n            else:\\n                break\\n            \\n        return m & mask & n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        diff = n - m\\n        mask = 9223372036854775807  # sys.maxsize\\n        for i in range(0, 32):\\n            curr = 1 << i           # pow(2, i)\\n            if diff >= curr:        # somewhere in range m - n bit i will be 0, if m[i] == 1\\n                mask = mask ^ curr  #  set bit i to 0\\n            else:\\n                break\\n            \\n        return m & mask & n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873267,
                "title": "java-vary-easy-understanding-solution",
                "content": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        // m <= n so,\\n        // m = xxxx0____\\n        // n = xxxx1____ because \\n        // xxxx01.111 >= m and\\n        // xxxx10.000 <= n \\n        // xxxx01.111, and xxxx10.000 are between m and n, and their AND result is 0\\n        // so we only need to find the first bit where m and differs. \\n        int ans = 0;\\n        for (int i = 30; i >= 0; i--) {\\n            if ( (m >> i & 1) != (n >> i & 1) ) {\\n                break;\\n            } else {\\n                if( (m >> i & 1) == 1 ){\\n                    ans += 1 << i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        // m <= n so,\\n        // m = xxxx0____\\n        // n = xxxx1____ because \\n        // xxxx01.111 >= m and\\n        // xxxx10.000 <= n \\n        // xxxx01.111, and xxxx10.000 are between m and n, and their AND result is 0\\n        // so we only need to find the first bit where m and differs. \\n        int ans = 0;\\n        for (int i = 30; i >= 0; i--) {\\n            if ( (m >> i & 1) != (n >> i & 1) ) {\\n                break;\\n            } else {\\n                if( (m >> i & 1) == 1 ){\\n                    ans += 1 << i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729023,
                "title": "simple-c-explaination",
                "content": "Consider the binary represenations of numbers. If count from LSB to MSB and start our indexing with 0.\\n\\n0 => 0000\\n1 => 0001\\n2 => 0010\\n3 => 0011\\n4 => 0100\\n5 => 0101\\n6 => 0110\\n7 => 0111\\n8 => 1000\\n9 => 1001\\n\\nWe can clearly see that,\\n0th bit flips after every 1 number.\\n1th bit flips after every 2 number.\\n2nd bit flips after every 4 number.\\nSimilarly, kth bit flips after every 2^k number. We find that for kth bit to be 1 ,m/powerof2 should be equal to n/powerof2 and both should be odd ( I found it from above pattern).\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int power,sum=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            power=1<<i;\\n            if((m/power)==0)\\n                break;\\n            if((m/power)%2==1 && (m/power)==(n/power))\\n                sum+=power;\\n        }\\n        return sum;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        int power,sum=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            power=1<<i;\\n            if((m/power)==0)\\n                break;\\n            if((m/power)%2==1 && (m/power)==(n/power))\\n                sum+=power;\\n        }\\n        return sum;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 717678,
                "title": "c-easy-solution-with-photo-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/13d7af5d-5937-47fb-b144-97bd2d0a34e6_1593773814.6153946.png)\\n\\n```\\nint rangeBitwiseAnd(int m, int n) {\\n        int placeCounter = 0;\\n        while (m != n) {\\n            m = m >> 1;\\n            n = n >> 1;\\n            ++placeCounter;\\n        }\\n        return m << placeCounter;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) {\\n        int placeCounter = 0;\\n        while (m != n) {\\n            m = m >> 1;\\n            n = n >> 1;\\n            ++placeCounter;\\n        }\\n        return m << placeCounter;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696270,
                "title": "alternative-python-solution-with-explanation",
                "content": "The way I approach this is to first find the AND of the binary representations of m & n.\\n\\nLet i be the most significant bit of the result that is a 1.\\n\\nSuppose we AND this result with every number between m & n.\\n\\nNotice that none of the resulting bits can change from 0 to 1.\\n\\nHowever, a bit might change from 1 to 0.\\n\\nFor instance, suppose the bit representing 4 is originally a 1 in the result.\\n\\nThat means it\\'s a 1 in both m and n.\\n\\nIt can become a 0 only if one of the numbers between m and n have a 0 for this bit.\\n\\nThis can only happen if m and n have a difference of at least 4.\\n\\nSo after computing AND of m & n, we simply need to determine which resulting bit we should change from 1 to 0 based on the difference n-m.\\n```\\nclass Solution(object):\\n    def rangeBitwiseAnd(self, m, n):\\n        result = m&n\\n        diff = n-m\\n        bit = 1\\n        while bit <= diff:\\n            result &= ~bit\\n            bit *= 2\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rangeBitwiseAnd(self, m, n):\\n        result = m&n\\n        diff = n-m\\n        bit = 1\\n        while bit <= diff:\\n            result &= ~bit\\n            bit *= 2\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638403,
                "title": "c-bit-operations-with-explanaion",
                "content": "/* The idea is very simple:\\n\\nlast bit of (odd number & even number) is 0.\\nwhen m != n, There is at least an odd number and an even number, so the last bit position result is 0.\\nMove m and n rigth a position.\\nKeep doing step 1,2,3 until m equal to n, use a factor to record the iteration time.\\n*/\\n\\npublic class Solution {\\n    public int RangeBitwiseAnd(int m, int n) {\\n        int shift = 0;\\n        while( m < n){\\n            m >>= 1;\\n            n >>= 1;\\n            shift++;\\n        }\\n        return m << shift;\\n            \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int RangeBitwiseAnd(int m, int n) {\\n        int shift = 0;\\n        while( m < n){\\n            m >>= 1;\\n            n >>= 1;\\n            shift++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 630905,
                "title": "easy-to-understand-solution-pigeonhole-principle-intuition",
                "content": "Notice that the k\\'th bit flips every 2^k numbers\\nConsider k=2\\nwe have 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000\\nThe 2nd bit was unset 0-3, set from 4-7, unset 8-11, and will be set again 12-15, changing every 4 numbers\\nSo if the difference between m and n is greater than 4, we know that there must be at least one number such that the 2nd bit is unset\\nOtherwise, we must check both the k\\'th bit in m and the k\\'th bit in n to see if it was unset in either one\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        bitset<31>res(INT_MAX),x(m),y(n);\\n        for(int i=0;i<32;++i){\\n            if(n-m>(1<<i) || x[i]==0 || y[i]==0)res[i]=0;\\n        }   \\n        return (int)(res.to_ulong());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        bitset<31>res(INT_MAX),x(m),y(n);\\n        for(int i=0;i<32;++i){\\n            if(n-m>(1<<i) || x[i]==0 || y[i]==0)res[i]=0;\\n        }   \\n        return (int)(res.to_ulong());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615660,
                "title": "another-way-of-looking-at-solution-3",
                "content": "You might find it easier to understand the third solution by switching the while condition as follows:\\n\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        while ((m & n) != n) {\\n            n &= n - 1;\\n        }\\n        return n;\\n    }\\n}\\n```\\n\\nThe idea is that we keep turning off the least significant bit set to 1 in `n` until `m & n` is equal to `n`.\\n\\n* When `m & n` is equal to `n`, we will have found the longest common prefix between `m` and `n`, and it will be `n`.\\n* If there is no such common prefix, `n` will eventually be 0, causing the loop to termiate and the function to return `0`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        while ((m & n) != n) {\\n            n &= n - 1;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595031,
                "title": "c-solution-with-explaination",
                "content": "The bruteforce solution to this problem would be to initialize x=1 and & x from m to n.\\nWhile this is efficient we can do better using some bit logic.\\nLets take two nubers\\n**m = 1000010010110\\nn = 1000101011011**\\nso this is the range givven to us.\\nWe kniw that even one 0 is present it can  make the whole result 0.\\nAs this is a range given here in m and n whatever it is the first 4 digits from the left will be the same \\nwhatsoever ans the rest will be 0s as there will be atleast 1 0.\\nSo we can leverage this fact and decrease our original complexity to logarithmic.\\nwe rightshift m and n unti they are equal and right shift if by the sam amount as the above logic mentioned\\nall the other eements will be 0.\\n```\\n    int rangeBitwiseAnd(int m, int n) {\\n        int i=0;\\n        while(m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            i++;\\n        }\\n        return m<<i;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int rangeBitwiseAnd(int m, int n) {\\n        int i=0;\\n        while(m!=n)\\n        {\\n            m>>=1;\\n            n>>=1;\\n            i++;\\n        }\\n        return m<<i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594704,
                "title": "2-java-solution-from-brute-force-to-constant-time-with-explaination",
                "content": "# Approach 1->\\nbasic approach is to loop from m to n and keep on doing bitwise &. But it takes o(n) time.\\n```\\npublic int rangeBitwiseAnd(int left, int right) {\\n    if(left==right) {\\n        return left;\\n    }\\n    int res = left;\\n    for (int i = left + 1; i < right; i++) {\\n        if (res == 0) {\\n            return 0;\\n        }\\n        res = res & i;\\n    }\\n    return res & right;\\n}\\n```\\n# Approach 2-> using some bits observation. \\n1.We can do it faster just by observing some property of bit.\\n3.\\tright shift by 1 will remove last digit from binary representation of number\\n4.\\tleft shift by 1 will add 0 after last digit in binary representation of number\\n5.\\t**Example 1**-> Suppose m=16 and n=19 ->\\nM=10000\\nN =10011\\nNumbers are \\u2013 \\n10000\\n10001\\n10010\\n10011 \\nResult =        10000\\nIt is clear that if we go from left to right (i.e. from MSB to LSB) for m and n only. The common digits will be in the result and remaining digit will be zero in result.\\n10000 and 10011 has 100 common and after that we have two digits left so we append two 0 at end. So result will be 10000.\\n**Example 2**->\\nm = 00110\\nn = 11111\\nhere there is no common digit from left to right. hence answer will be 0\\n**Example 3**->\\nm = 110001\\nn = 111011\\nhere common digit is 11. hence answer will be 110000\\n6.\\tSo, now problem is to find common digits from left to right. We can do it by performing right shift of m and n till m and n are same. And keep counter to count number of shift done.\\nSo, we get 100 whose decimal value is 4 and now if we do left shift of this 4 by count number of times. We get the result. As left shift will append zero to result count number of times.\\n\\nMaximum time below while loop will run is 32. which is fixed irrepective how range will grow.\\nhence time complexity is constant.\\n```\\npublic int rangeBitwiseAnd(int m, int n) {\\n        int c=0;\\n        while(m!=n){\\n            m=m>>1;\\n            n=n>>1;\\n            c++;\\n        }\\n        return m<<c;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int rangeBitwiseAnd(int left, int right) {\\n    if(left==right) {\\n        return left;\\n    }\\n    int res = left;\\n    for (int i = left + 1; i < right; i++) {\\n        if (res == 0) {\\n            return 0;\\n        }\\n        res = res & i;\\n    }\\n    return res & right;\\n}\\n```\n```\\npublic int rangeBitwiseAnd(int m, int n) {\\n        int c=0;\\n        while(m!=n){\\n            m=m>>1;\\n            n=n>>1;\\n            c++;\\n        }\\n        return m<<c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594522,
                "title": "solution-in-java-beats-100",
                "content": "Goal is to get the MSB of both m and n, we keep shifting m and n to the **RIGHT** until they are same and keep a track how many times we shifted the integers. Then shift either m or n to the **LEFT** by counter times.\\n\\nm = 18 (10010) base 2\\nn = 20  (10100) base 2\\n\\nBackground Info: \\n**1**0010 AND **1**0100 = **1**0000\\n\\nThe answer of the AND operation also seems to be our MSB. \\n\\n**Control Flow of the Logic:** \\n\\nm >> 1 = 01001\\nn  >> 1 = 01010\\ncount++\\n\\nm >> 1 = 00100\\nn  >> 1 = 00101\\ncount++\\n\\nm >> 1 = 00100\\nn  >> 1 = 00010\\ncount++\\n\\nanswer = m << count = 10010 << 3 = 10000\\n\\n```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while (m != n) {\\n            m = m >> 1;\\n            n = n >> 1;\\n            count++;\\n        }\\n        return m << count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rangeBitwiseAnd(int m, int n) {\\n        int count = 0;\\n        while (m != n) {\\n            m = m >> 1;\\n            n = n >> 1;\\n            count++;\\n        }\\n        return m << count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594336,
                "title": "easy-bitwise-operation-o-1-explained",
                "content": "##### So the idea is that when any bit flips for a given position in [M,N] then entire column & val =0\\n##### We simply do the right shifting till we get a common leftmost bit. And then copy the remaining bits by zero.\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        int count=0;\\n        \\n        while(m!=n){\\n            m>>=1;\\n            n>>=1;\\n            count++;\\n        }\\n        return m<<=count;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n        \\n        int count=0;\\n        \\n        while(m!=n){\\n            m>>=1;\\n            n>>=1;\\n            count++;\\n        }\\n        return m<<=count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593872,
                "title": "find-longest-common-prefix-with-straightforward-bit-operation-simulation",
                "content": "# [subject] find longest common prefix with straightforward bit operation simulation\\n\\nThe hardest part of this problem is to find the regular pattern.\\nLet\\'s begin with two cases:\\n\\nCase 1:(We assume the least significant bit(LSB) is in right end, most significant bit(MSB) is in left end)\\nFor example, for number 5 to 7\\nTheir binary form are:\\n**1**01\\n**1**10\\n**1**11\\nExpected result: \\n100\\nThat is: 4 in decimal format.\\nNote, the longest common prefix is:  the first bit in the left\\n\\nCase 2:\\nFor example, for number 26 to 30\\nTheir binary form are:\\n**11**010\\n**11**011\\n**11**100\\u3000\\u3000\\n**11**101\\u3000\\u3000\\n**11**110\\nExpected result: \\n11000\\nThat is : 24 in decimal format.\\nNote, the longest common prefix is:  the first two bits in the left\\n\\nObservation:\\nBecause we are trying to find bitwise AND, so if any bit there are at least one 0 and one 1, it always 0. In this case, it is 100, and 11000, respectively.\\nSo we are go to cut all these bit that they are different. In this case we cut the right 2 and 3 bit, respetively.\\n\\nI think after understand this, the code is trivial:\\nTalk is cheap, let\\u2019s code:\\n\\n ```\\nclass Solution {// Best: Bit operation simulation\\npublic://Time/Space complexity: O(logn); O(1)\\n    int rangeBitwiseAnd(int m, int n) {\\n        while (m < n)\\n            n &= (n-1); //Note1\\n        // while(m < n) n -= n & (-n); // also okay\\n        return n; // once here,  m == n must be true, so we can return either m or n\\n    }\\n};\\n/*\\nNote1: \\nEverty time, we only check bigest two numbers: n, n-1\\nIt can disclose higher and higher significant 0\\n*/\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n      int i = 0; // i means how many bits are 0 on the right\\n      while(m != n){\\n        m >>= 1;\\n        n >>= 1;\\n        i++;  \\n      }  \\n      return m << i;  \\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic: //Time/Space complexity: O(logn); O(logn)\\n    int rangeBitwiseAnd(int m, int n) {\\n        return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;        \\n    }\\n};\\n```\\n\\nP.S.\\nCase 3:\\nFor example, for number 10 to 11\\nTheir binary form are:\\n**101**0\\n**101**1\\nExpected result: \\n**101**0\\nThat is: 10 in decimal format.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {// Best: Bit operation simulation\\npublic://Time/Space complexity: O(logn); O(1)\\n    int rangeBitwiseAnd(int m, int n) {\\n        while (m < n)\\n            n &= (n-1); //Note1\\n        // while(m < n) n -= n & (-n); // also okay\\n        return n; // once here,  m == n must be true, so we can return either m or n\\n    }\\n};\\n/*\\nNote1: \\nEverty time, we only check bigest two numbers: n, n-1\\nIt can disclose higher and higher significant 0\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int rangeBitwiseAnd(int m, int n) {\\n      int i = 0; // i means how many bits are 0 on the right\\n      while(m != n){\\n        m >>= 1;\\n        n >>= 1;\\n        i++;  \\n      }  \\n      return m << i;  \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic: //Time/Space complexity: O(logn); O(logn)\\n    int rangeBitwiseAnd(int m, int n) {\\n        return (n > m) ? (rangeBitwiseAnd(m/2, n/2) << 1) : m;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593812,
                "title": "c-brute-force",
                "content": "```\\nint rangeBitwiseAnd(int m, int n) {\\n\\tif (m == n)\\n\\t\\treturn m;\\n\\n\\tlong ret = m;\\n\\tfor (long i = m + 1; i <= n; i++) {\\n\\t\\tret &= i;\\n\\t\\tif (ret == 0)\\n\\t\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rangeBitwiseAnd(int m, int n) {\\n\\tif (m == n)\\n\\t\\treturn m;\\n\\n\\tlong ret = m;\\n\\tfor (long i = m + 1; i <= n; i++) {\\n\\t\\tret &= i;\\n\\t\\tif (ret == 0)\\n\\t\\t\\tbreak;\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1814370,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1567464,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1953918,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1569253,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1905888,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1785705,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 2053637,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1951412,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1777966,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1723778,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1814370,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1567464,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1953918,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1569253,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1905888,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1785705,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 2053637,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1951412,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1777966,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            },
            {
                "id": 1723778,
                "content": [
                    {
                        "username": "zendemion",
                        "content": "Excuse me?\n```\nTime Limit Exceeded 8268 / 8268 testcases passed\nLast Executed Input\n\nleft =\n```\nWhat happened there?"
                    },
                    {
                        "username": "venkatsaketh",
                        "content": "Even I am facing same issue, last testcase it is not showing left and right values."
                    },
                    {
                        "username": "stephen_byerley",
                        "content": "There is, I think?, a leetcode platform issue with displaying the input for a Time Limit Exceeded fail on the last testcase, but it should be something like - \\n\\nleft = INT_MAX-2^29\\nright = INT_MAX\\n\\nto check for an iterative solution with incomplete pruning."
                    },
                    {
                        "username": "0icy",
                        "content": "you are excused\\n"
                    },
                    {
                        "username": "abheping",
                        "content": "It was probably left =1 and right = 1\\n\\n"
                    },
                    {
                        "username": "hwc0919",
                        "content": "At first, it is easy to think of the brute force solution, BIT_AND all the way from `m` to `n`.\\n\\nBut we doesn\\'t need to calculate all of them.\\n\\nNotice: whenever we reach `t = 2^k`, the last `k` binary digits of `t` are all `0`!\\n\\nWhen we meet the first `2^k` above `m`, the result will be `0`. No matter what is following.\\n\\nLet `t` be the first `2^k` above `m`, that is,   `2^(k - 1) <= m < 2^k = t`\\n\\nIf `n >= t`, the result will be `0`.\\n\\nWe only need to calculate between [m, n], when `n < t`.\\n\\nAlso there are other better solutions, but this one is very easy to understand."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "bit manipulation is tough man\\ncan\\'t seem to optimize my brute force solution :)"
                    },
                    {
                        "username": "asw2156",
                        "content": "Why is the result 4 for 7 (111) & 5 (101) ? Should\\'nt  it be 5"
                    },
                    {
                        "username": "xozotic",
                        "content": "its 5&6&7"
                    },
                    {
                        "username": "aashishomre11",
                        "content": "we have to perform and (&) operation  for all numbers between ( left to right).\\nso here left=4 -->100\\n                    5-->0101\\n                    6-->0110\\n           right  7-->0111\\n              -------------------\\n           ans -->    0100 "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "0. The bitwise operation `AND` results in a binary digit of `1` only when all the numbers involved have a binary digit of `1` in that specific position.\\n\\n1. Let us consider two numbers, denoted as `left` and `right.` If the condition `left != right` is true, it indicates that they differ by at least one unit. This implies the existence of a number between them, whose binary representation ends with a digit of `0.`\\n\\n2. Consequently, whenever we encounter the condition `left != right,` we proceed to right-shift both numbers by one position. This action aligns with the aforementioned observation, ensuring that the last digit is consistently `0.` Simultaneously, we keep track of the count of `0s` towards the right. Upon reaching a position where `left == right,` we terminate the process. At this point, all the digits up to that position remain unchanged. We then append `count` number of `0s` to obtain the desired number."
                    },
                    {
                        "username": "aman_empires",
                        "content": "Brute force is easy to understand and complete this problem."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To get the result, you need to find the common prefix of left and right in their binary representation. `Hint`\\n\\n#### Example 1:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 01**01 (5)\\n> **0000 0000 0000 0000 0000 0000 0000 01**11 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0100 (4)\\n\\n\\n#### Example 2:\\n\\n> **0000 0000 0000 0000 0000 0000 0000 011**0 (6)\\n> **0000 0000 0000 0000 0000 0000 0000 011**1 (7)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 01100 (6)\\n\\n#### Example 3:\\n\\n> **0**000 0000 0000 0000 0000 0000 0000 0001 (1)\\n> **0**111 1111 1111 1111 1111 1111 1111 1111 (2147483647)\\n>\\n> prefix = 0000 0000 0000 0000 0000 0000 0000 0000 (0)\\n\\n<br>\\n\\n*Don\\'t get overwhelmed by the examples. They are simply for visualization, and **everyone** understands things differently.*"
                    },
                    {
                        "username": "VineetBhoria",
                        "content": "Hey everyone!!\nOn my last test case  input is nothing but it shows time limit exceeded.\nI dont know why as range is from 0 to INT_MAX.\nThis is question , Test case No 8269 / 8269 :\nhttps://leetcode.com/problems/bitwise-and-of-numbers-range/\n\n[@Ankush Rawat](/AnkushR10)"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "My all test cases are passed still showing TLE \nits coming 8268/8268 test cases based and TLE\nhelp please\n\nMY CODE : \nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n       if(left==right)\n       {\n           return left;\n       } \n       if(left==0)\n       {\n           return 0;\n       }\n       long long k = left;\n       long long a = left;\n       while(k<=right)\n       {\n           a = a&k;\n           if(k==INT_MAX)\n           {\n               return a;\n           }\n           k++;\n           if(a==0)\n           {\n               return 0;\n           }\n       }\n       return a;\n    }\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/201_bitwise_and_of_number_range.cpp"
                    }
                ]
            }
        ]
    }
]