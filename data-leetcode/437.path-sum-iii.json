[
    {
        "title": "Path Sum III",
        "question_content": "Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values&nbsp;along the path equals&nbsp;targetSum.\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n&nbsp;\nExample 1:\n\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\n\nExample 2:\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [0, 1000].\n\t-109 <= Node.val <= 109\n\t-1000 <= targetSum <= 1000",
        "solutions": [
            {
                "id": 141424,
                "title": "python-step-by-step-walk-through-easy-to-understand-two-solutions-comparison",
                "content": "# 1. Brute Force: O(nlogn) ~ O(n^2)\\n## 1.1 High level walk-through: \\n1. (Define return) Define a global var: `self.numOfPaths` in the main function.\\n2. (1st layer DFS) Use recursive traverse to go through each `node` (can be **any order**: pre, in, post all fine).\\n3. (2nd layer DFS) For each `node`, walk all paths. If a path sum equals to the `target`: `self.numOfPaths += 1`\\n4. Return result:  `return self.numOfPaths` \\n## 1.2 Complexity analysis\\n### 1.2.1 Space \\n1. Space complexity is O(1), due to there is no extra cache. However, for **any recursive** question, we need to think about **stack overflow**, namely the recursion should not go too deep. \\n2. Assume we have **n** TreeNodes in total, the tree height will vary from **O(n)** (single sided tree) to **O(logn)**(balanced tree). \\n3. The two DFS will go as deep as the tree height.\\n### 1.2.2 Time\\n1. Time complexity depends on the two DFS.\\n2. 1st layer DFS will always take **O(n)**, due to here we will take each node out, there are in total **n** TreeNodes\\n3. 2nd layer DFS will take range from **O(n)** (single sided tree) to **O(logn)**(balanced tree). This is due to here we are get all the paths from a given node. The length of path is proportional to the tree height.\\n4. Therefore, the total time complexity is **O(nlogn)** to **O(n^2)**.\\n## 1.3 Code\\n```\\nclass Solution(object):\\n    def pathSum(self, root, target):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        # define global return var\\n        self.numOfPaths = 0\\n        # 1st layer DFS to go through each node\\n        self.dfs(root, target)\\n        # return result\\n        return self.numOfPaths\\n    \\n    # define: traverse through the tree, at each treenode, call another DFS to test if a path sum include the answer\\n    def dfs(self, node, target):\\n        # exit condition\\n        if node is None:\\n            return \\n        # dfs break down \\n        self.test(node, target) # you can move the line to any order, here is pre-order\\n        self.dfs(node.left, target)\\n        self.dfs(node.right, target)\\n        \\n    # define: for a given node, DFS to find any path that sum == target, if find self.numOfPaths += 1\\n    def test(self, node, target):\\n        # exit condition\\n        if node is None:\\n            return\\n        if node.val == target:\\n            self.numOfPaths += 1\\n            \\n        # test break down\\n        self.test(node.left, target-node.val)\\n        self.test(node.right, target-node.val)\\n```\\n\\n# 2. Memorization of path sum: O(n)\\n## 2.1 High level walk through\\n1. In order to optimize from the brutal force solution, we will have to think of a clear way to memorize the intermediate result. Namely in the brutal force solution, we did a lot repeated calculation. For example `1->3->5`, we calculated: 1, 1+3, 1+3+5, 3, 3+5, 5. \\n2. This is a classical \\'space and time tradeoff\\': we can create a dictionary (named `cache`) which saves all the path sum (from root to current node) and their frequency.\\n3. Again, we traverse through the tree, at each node, we can get the `currPathSum` (from root to current node). If within this path, there is a valid solution, then there must be a `oldPathSum` such that `currPathSum - oldPathSum = target`. \\n4. We just need to add the frequency of the `oldPathSum` to the result. \\n5. During the DFS break down, we need to -1 in  `cache[currPathSum]`, because this path is not available in later traverse. \\n6. Check the graph below for easy visualization. \\n![image](https://s3-lc-upload.s3.amazonaws.com/users/wonderlives/image_1529701359.png)\\n\\n## 2.2 Complexity analysis:\\n### 2.2.1 Space complexity\\nO(n) extra space\\n### 2.2.1 Time complexity\\nO(n) as we just traverse once\\n\\n## 2.3 Code:\\n```\\nclass Solution(object):\\n    def pathSum(self, root, target):\\n        # define global result and path\\n        self.result = 0\\n        cache = {0:1}\\n        \\n        # recursive to get result\\n        self.dfs(root, target, 0, cache)\\n        \\n        # return result\\n        return self.result\\n    \\n    def dfs(self, root, target, currPathSum, cache):\\n        # exit condition\\n        if root is None:\\n            return  \\n        # calculate currPathSum and required oldPathSum\\n        currPathSum += root.val\\n        oldPathSum = currPathSum - target\\n        # update result and cache\\n        self.result += cache.get(oldPathSum, 0)\\n        cache[currPathSum] = cache.get(currPathSum, 0) + 1\\n        \\n        # dfs breakdown\\n        self.dfs(root.left, target, currPathSum, cache)\\n        self.dfs(root.right, target, currPathSum, cache)\\n        # when move to a different branch, the currPathSum is no longer available, hence remove one. \\n        cache[currPathSum] -= 1\\n```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pathSum(self, root, target):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        # define global return var\\n        self.numOfPaths = 0\\n        # 1st layer DFS to go through each node\\n        self.dfs(root, target)\\n        # return result\\n        return self.numOfPaths\\n    \\n    # define: traverse through the tree, at each treenode, call another DFS to test if a path sum include the answer\\n    def dfs(self, node, target):\\n        # exit condition\\n        if node is None:\\n            return \\n        # dfs break down \\n        self.test(node, target) # you can move the line to any order, here is pre-order\\n        self.dfs(node.left, target)\\n        self.dfs(node.right, target)\\n        \\n    # define: for a given node, DFS to find any path that sum == target, if find self.numOfPaths += 1\\n    def test(self, node, target):\\n        # exit condition\\n        if node is None:\\n            return\\n        if node.val == target:\\n            self.numOfPaths += 1\\n            \\n        # test break down\\n        self.test(node.left, target-node.val)\\n        self.test(node.right, target-node.val)\\n```\n```\\nclass Solution(object):\\n    def pathSum(self, root, target):\\n        # define global result and path\\n        self.result = 0\\n        cache = {0:1}\\n        \\n        # recursive to get result\\n        self.dfs(root, target, 0, cache)\\n        \\n        # return result\\n        return self.result\\n    \\n    def dfs(self, root, target, currPathSum, cache):\\n        # exit condition\\n        if root is None:\\n            return  \\n        # calculate currPathSum and required oldPathSum\\n        currPathSum += root.val\\n        oldPathSum = currPathSum - target\\n        # update result and cache\\n        self.result += cache.get(oldPathSum, 0)\\n        cache[currPathSum] = cache.get(currPathSum, 0) + 1\\n        \\n        # dfs breakdown\\n        self.dfs(root.left, target, currPathSum, cache)\\n        self.dfs(root.right, target, currPathSum, cache)\\n        # when move to a different branch, the currPathSum is no longer available, hence remove one. \\n        cache[currPathSum] -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91878,
                "title": "17-ms-o-n-java-prefix-sum-method",
                "content": "So the idea is similar as Two sum, using HashMap to store ( key : the prefix sum, value : how many ways get to this prefix sum) , and whenever reach a node, we check if prefix sum - target exists in hashmap or not, if it does, we added up the ways of prefix sum - target into res.\\nFor instance : in one path we have 1,2,-1,-1,2, then the prefix sum will be: 1, 3, 2, 1, 3, let's say we want to find target sum is 2, then we will have{2}, {1,2,-1},  {2,-1,-1,2} and {2}ways.\\n\\nI used global variable count, but obviously we can avoid global variable by passing the count from bottom up. The time complexity is O(n). This is my first post in discuss, open to any improvement or criticism. :)\\n\\n```\\n    public int pathSum(TreeNode root, int sum) {\\n        HashMap<Integer, Integer> preSum = new HashMap();\\n        preSum.put(0,1);\\n        helper(root, 0, sum, preSum);\\n        return count;\\n    }\\n    int count = 0;\\n    public void helper(TreeNode root, int currSum, int target, HashMap<Integer, Integer> preSum) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        currSum += root.val;\\n\\n        if (preSum.containsKey(currSum - target)) {\\n            count += preSum.get(currSum - target);\\n        }\\n        \\n        if (!preSum.containsKey(currSum)) {\\n            preSum.put(currSum, 1);\\n        } else {\\n            preSum.put(currSum, preSum.get(currSum)+1);\\n        }\\n        \\n        helper(root.left, currSum, target, preSum);\\n        helper(root.right, currSum, target, preSum);\\n        preSum.put(currSum, preSum.get(currSum) - 1);\\n    }\\n```\\n\\nThanks for your advice, @StefanPochmann . Here is the modified version, concise and shorter:\\n```\\n    public int pathSum(TreeNode root, int sum) {\\n        HashMap<Integer, Integer> preSum = new HashMap();\\n        preSum.put(0,1);\\n        return helper(root, 0, sum, preSum);\\n    }\\n    \\n    public int helper(TreeNode root, int currSum, int target, HashMap<Integer, Integer> preSum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        currSum += root.val;\\n        int res = preSum.getOrDefault(currSum - target, 0);\\n        preSum.put(currSum, preSum.getOrDefault(currSum, 0) + 1);\\n        \\n        res += helper(root.left, currSum, target, preSum) + helper(root.right, currSum, target, preSum);\\n        preSum.put(currSum, preSum.get(currSum) - 1);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int pathSum(TreeNode root, int sum) {\\n        HashMap<Integer, Integer> preSum = new HashMap();\\n        preSum.put(0,1);\\n        helper(root, 0, sum, preSum);\\n        return count;\\n    }\\n    int count = 0;\\n    public void helper(TreeNode root, int currSum, int target, HashMap<Integer, Integer> preSum) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        currSum += root.val;\\n\\n        if (preSum.containsKey(currSum - target)) {\\n            count += preSum.get(currSum - target);\\n        }\\n        \\n        if (!preSum.containsKey(currSum)) {\\n            preSum.put(currSum, 1);\\n        } else {\\n            preSum.put(currSum, preSum.get(currSum)+1);\\n        }\\n        \\n        helper(root.left, currSum, target, preSum);\\n        helper(root.right, currSum, target, preSum);\\n        preSum.put(currSum, preSum.get(currSum) - 1);\\n    }\\n```\n```\\n    public int pathSum(TreeNode root, int sum) {\\n        HashMap<Integer, Integer> preSum = new HashMap();\\n        preSum.put(0,1);\\n        return helper(root, 0, sum, preSum);\\n    }\\n    \\n    public int helper(TreeNode root, int currSum, int target, HashMap<Integer, Integer> preSum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        currSum += root.val;\\n        int res = preSum.getOrDefault(currSum - target, 0);\\n        preSum.put(currSum, preSum.getOrDefault(currSum, 0) + 1);\\n        \\n        res += helper(root.left, currSum, target, preSum) + helper(root.right, currSum, target, preSum);\\n        preSum.put(currSum, preSum.get(currSum) - 1);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91889,
                "title": "simple-java-dfs",
                "content": "Typical recursive DFS.\\nSpace: O(n) due to recursion.\\nTime: O(n^2) in worst case (no branching); O(nlogn) in best case (balanced tree).\\n```\\npublic class Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        if (root == null) return 0;\\n        return pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);\\n    }\\n    \\n    private int pathSumFrom(TreeNode node, int sum) {\\n        if (node == null) return 0;\\n        return (node.val == sum ? 1 : 0) \\n            + pathSumFrom(node.left, sum - node.val) + pathSumFrom(node.right, sum - node.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        if (root == null) return 0;\\n        return pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);\\n    }\\n    \\n    private int pathSumFrom(TreeNode node, int sum) {\\n        if (node == null) return 0;\\n        return (node.val == sum ? 1 : 0) \\n            + pathSumFrom(node.left, sum - node.val) + pathSumFrom(node.right, sum - node.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683906,
                "title": "c-dfs-clean-solution-t-89-m-80",
                "content": "***Please upvote if you found the post helpful :)***\\nShoutout to @prateeksharma. \\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int pathSum(TreeNode* root, int sum) {\\n        if(root){\\n            dfs(root,sum);\\n            pathSum(root->left,sum);\\n            pathSum(root->right,sum);\\n        }\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, int sum){\\n        if(!root)return;\\n        if(root->val==sum)ans++;\\n        dfs(root->left,sum-root->val);\\n        dfs(root->right,sum-root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int pathSum(TreeNode* root, int sum) {\\n        if(root){\\n            dfs(root,sum);\\n            pathSum(root->left,sum);\\n            pathSum(root->right,sum);\\n        }\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, int sum){\\n        if(!root)return;\\n        if(root->val==sum)ans++;\\n        dfs(root->left,sum-root->val);\\n        dfs(root->right,sum-root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91877,
                "title": "c-5-line-body-code-dfs-solution",
                "content": "For tree structure problems. recursion is usually intuitive and easy to write. lol\\n```\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        if(!root) return 0;\\n        return sumUp(root, 0, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\\n    }\\nprivate:\\n    int sumUp(TreeNode* root, int pre, int& sum){\\n        if(!root) return 0;\\n        int current = pre + root->val;\\n        return (current == sum) + sumUp(root->left, current, sum) + sumUp(root->right, current, sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        if(!root) return 0;\\n        return sumUp(root, 0, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\\n    }\\nprivate:\\n    int sumUp(TreeNode* root, int pre, int& sum){\\n        if(!root) return 0;\\n        int current = pre + root->val;\\n        return (current == sum) + sumUp(root->left, current, sum) + sumUp(root->right, current, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91892,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Path Sum III** https://leetcode.com/problems/path-sum-iii/\\n\\n**Brute Force Solution**\\n* The simplest solution is to traverse each node (preorder traversal) and then find all paths which sum to the target using this node as root.\\n* The worst case complexity for this method is N^2. \\n* If we have a balanced tree, we have the recurrence: T(N) = N + 2T(N/2). This is the merge sort recurrence and suggests NlgN.\\n```\\nclass SolutionBruteForce(object):\\n    def find_paths(self, root, target):\\n        if root:\\n            return int(root.val == target) + self.find_paths(root.left, target-root.val) + self.find_paths(root.right, target-root.val)\\n        return 0\\n\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        if root:\\n            return self.find_paths(root, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum)\\n        return 0\\n```\\n\\n**Two Sum Method: Optimized Solution**\\n\\n* A more efficient implementation uses the Two Sum idea. It uses a hash table (extra memory of order N). With more space, it gives us an O(N) complexity.\\n* As we traverse down the tree, at an arbitrary node N, we store the sum until this node N (sum_so_far (prefix) + N.val). in hash-table.  Note this sum is the sum from root to N.\\n* Now at a grand-child of N, say G, we can compute the sum from the root until G since we have the prefix_sum until this grandchild available.We pass in our recursive routine.\\n* How do we know if we have a path of target sum which ends at this grand-child G? Say there are multiple such paths that end at G and say they start at A, B, C where A,B,C are predecessors of G. Then sum(root->G) - sum(root->A) = target. Similarly sum(root->G)-sum(root>B) = target. Therefore we can compute the complement at G as sum_so_far+G.val-target and look up the hash-table for the number of paths which had this sum\\n* Now after we are done with a node and all its grandchildren, we remove it from the hash-table. This makes sure that the number of complement paths returned always correspond to paths that ended at a predecessor node.\\n```\\nclass Solution(object):\\n    def helper(self, root, target, so_far, cache):\\n        if root:\\n            complement = so_far + root.val - target\\n            if complement in cache:\\n                self.result += cache[complement]\\n            cache.setdefault(so_far+root.val, 0)\\n            cache[so_far+root.val] += 1\\n            self.helper(root.left, target, so_far+root.val, cache)\\n            self.helper(root.right, target, so_far+root.val, cache)\\n            cache[so_far+root.val] -= 1\\n        return\\n\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        self.result = 0\\n        self.helper(root, sum, 0, {0:1})\\n        return self.result\\n```",
                "solutionTags": [],
                "code": "```\\nclass SolutionBruteForce(object):\\n    def find_paths(self, root, target):\\n        if root:\\n            return int(root.val == target) + self.find_paths(root.left, target-root.val) + self.find_paths(root.right, target-root.val)\\n        return 0\\n\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        if root:\\n            return self.find_paths(root, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum)\\n        return 0\\n```\n```\\nclass Solution(object):\\n    def helper(self, root, target, so_far, cache):\\n        if root:\\n            complement = so_far + root.val - target\\n            if complement in cache:\\n                self.result += cache[complement]\\n            cache.setdefault(so_far+root.val, 0)\\n            cache[so_far+root.val] += 1\\n            self.helper(root.left, target, so_far+root.val, cache)\\n            self.helper(root.right, target, so_far+root.val, cache)\\n            cache[so_far+root.val] -= 1\\n        return\\n\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        self.result = 0\\n        self.helper(root, sum, 0, {0:1})\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525380,
                "title": "easy-o-n-solution-hashmap-c-code-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<long, int> map;\\n    int count = 0;\\n    \\n    void countPathSum(TreeNode* root, int target, long sum){\\n        if(!root)\\n            return;\\n        sum += root->val;        //Path sum from root\\n        if(sum == target)\\n            count++;\\n        if(map.find(sum - target) != map.end())         //checking whether any target sum path present in the path from root to the current node\\n            count += map[sum - target];\\n        map[sum]++;\\n        countPathSum(root->left, target, sum);\\n        countPathSum(root->right, target, sum);\\n        map[sum]--;      //After visiting the left and right subtree, we have to reduce this path sum count from map since we are leaving this path\\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        countPathSum(root, targetSum, 0);\\n        return count;\\n    }\\n};\\n```\\n\\n* **Time Complexity = O(N)**, where N is the no of nodes in the binary tree. In the recursion we are visiting each node only once. Hence O(N) T.C.\\n* **Space Complexity = O(N)**, Our hashmap takes O(N) space, also we need to concider the space taken by the recursive function calls, in the worst case of a skew binary tree, our stack can contain upto N function calls.\\n**IF YOU FIND IT HELPFUL, SHOW SOME LOVE IN THE FORM OF UPVOTE\\uD83D\\uDE0D**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<long, int> map;\\n    int count = 0;\\n    \\n    void countPathSum(TreeNode* root, int target, long sum){\\n        if(!root)\\n            return;\\n        sum += root->val;        //Path sum from root\\n        if(sum == target)\\n            count++;\\n        if(map.find(sum - target) != map.end())         //checking whether any target sum path present in the path from root to the current node\\n            count += map[sum - target];\\n        map[sum]++;\\n        countPathSum(root->left, target, sum);\\n        countPathSum(root->right, target, sum);\\n        map[sum]--;      //After visiting the left and right subtree, we have to reduce this path sum count from map since we are leaving this path\\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        countPathSum(root, targetSum, 0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91884,
                "title": "simple-ac-java-solution-dfs",
                "content": "Each time find all the path start from current node\\nThen move start node to the child and repeat. \\nTime Complexity should be O(N^2) for the worst case and O(NlogN) for balanced binary Tree.\\n```\\npublic class Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return 0;\\n        return findPath(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);\\n    }\\n    \\n    public int findPath(TreeNode root, int sum){\\n        int res = 0;\\n        if(root == null)\\n            return res;\\n        if(sum == root.val)\\n            res++;\\n        res += findPath(root.left, sum - root.val);\\n        res += findPath(root.right, sum - root.val);\\n        return res;\\n    }\\n   \\n}\\n````\\nA better solution is suggested in <a href =\"https://discuss.leetcode.com/topic/64526/17-ms-o-n-java-prefix-sum-method\"> 17ms O(n) java prefix sum </a> by tankztc. It use a hash map to store all the prefix sum and each time check if the any subarray sum to the target, add with some comments:\\n```\\n    public int pathSum(TreeNode root, int sum) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);  //Default sum = 0 has one count\\n        return backtrack(root, 0, sum, map); \\n    }\\n    //BackTrack one pass\\n    public int backtrack(TreeNode root, int sum, int target, Map<Integer, Integer> map){\\n        if(root == null)\\n            return 0;\\n        sum += root.val;\\n        int res = map.getOrDefault(sum - target, 0);    //See if there is a subarray sum equals to target\\n        map.put(sum, map.getOrDefault(sum, 0)+1);\\n        //Extend to left and right child\\n        res += backtrack(root.left, sum, target, map) + backtrack(root.right, sum, target, map);\\n        map.put(sum, map.get(sum)-1);   //Remove the current node so it wont affect other path\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return 0;\\n        return findPath(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);\\n    }\\n    \\n    public int findPath(TreeNode root, int sum){\\n        int res = 0;\\n        if(root == null)\\n            return res;\\n        if(sum == root.val)\\n            res++;\\n        res += findPath(root.left, sum - root.val);\\n        res += findPath(root.right, sum - root.val);\\n        return res;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91908,
                "title": "c-solution-with-prefix-sum-stored-in-hash-table",
                "content": "The idea is simple: along the path, record all prefix sums in a hash table. For current prefix sum x, check if (x - target) appears in the hash table. \\n```\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        unordered_map<int, int> m;\\n        m[0]++;\\n        \\n        int total = 0;\\n        helper(root, 0, sum, total, m);\\n        return total;\\n    }\\n    \\n    void helper(TreeNode *p, int cur, int sum, int &total, unordered_map<int, int> &m) {\\n        if (!p) return;\\n        \\n        cur += p->val;\\n        if (m.find(cur - sum) != m.end()) total += m[cur - sum];\\n        m[cur]++;\\n        \\n        helper(p->left, cur, sum, total, m);\\n        helper(p->right, cur, sum, total, m);\\n        \\n        m[cur]--;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        unordered_map<int, int> m;\\n        m[0]++;\\n        \\n        int total = 0;\\n        helper(root, 0, sum, total, m);\\n        return total;\\n    }\\n    \\n    void helper(TreeNode *p, int cur, int sum, int &total, unordered_map<int, int> &m) {\\n        if (!p) return;\\n        \\n        cur += p->val;\\n        if (m.find(cur - sum) != m.end()) total += m[cur - sum];\\n        m[cur]++;\\n        \\n        helper(p->left, cur, sum, total, m);\\n        helper(p->right, cur, sum, total, m);\\n        \\n        m[cur]--;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779575,
                "title": "c-3-dfs-based-solutions-explained-and-compared-up-to-100-time-75-space",
                "content": "This is a nice problem, as it is the composition of 2 classical ones: getting a series of values traversing a tree and verifying if any of those numbers have one or more subarrays summing up to a given `targetSum`.\\n\\nThe latter problem is [here](https://leetcode.com/problems/subarray-sum-equals-k/) if you want a warm up and [here](https://leetcode.com/problems/subarray-sum-equals-k/discuss/431725/) I explained how it worked in more detail.\\n\\nSo my approach followed basically these 2 bits of logic, doing a composition of a DFS based tree traversal and at each iteration checking if the very last value mins the `targetSum` were already spotted; I used a vector initially, then moved up to an array to keep track of the already `seen` values with a huge performance boost.\\n\\nIn my approach I use 3 class variables:\\n* my typical accumulator variable `res` initialised to `0` to count the number of matching occurrences;\\n* `sum` that takes the values of `targetSum` and replaces it in all of my recursive calls (so that I do not have to pass it as a parameter)\\n* `seen`, as mentioned to keep track of the values I spotted so far and created to hold `1001` values (an initial `0` at root level, plus other potential `1000` different ones, as specified in the specs).\\n\\nInside my main function I initialise the values and then, provided the tree is not empty (ie: `!root`), I call `dfs`.\\n\\nThis function receives 3 parameters:\\n* a mandatory `root`, which is the node we are currently exploring;\\n* an optional `partialSum` value, defaulted to `0` and keeping track of our current partial sum going down a specific branch;\\n* an optional `pos` to tell us where to put out next value in `seen` and up to which point browse it (muuuch faster than expanding and reducing a vector, try the alternative code down below!)\\n\\nWe are looking for all the occurrences of values in `seen` which are `partialSum - sum`, because it means that said value `n` plus `partialSum` would equal `sum`, and for each such instance we increase `res` by one.\\n\\nIf we have a `->left` branch we do the same with it, passing the update `root`, `partialSum` and `pos` (increased by `1`) down as parameters; same thing with a `->right` branch, if it exists.\\n\\nWhen we are done, we just return `res` :)\\n\\nThe improved code (using an array for `seen`):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0, sum;\\n    int seen[1001];\\n    void dfs(TreeNode* root, int partialSum = 0, int pos = 1) {\\n        // updating partialSum with the current node\\n        partialSum += root->val;\\n        // checking if we already found an interval summing up to that\\n        for (int i = 0; i < pos; i++) if (seen[i] == partialSum - sum) res++;\\n        // updating seen\\n        seen[pos] = partialSum;\\n        // searching potential left and right branches\\n        if (root->left) dfs(root->left, partialSum, pos + 1);\\n        if (root->right) dfs(root->right, partialSum, pos + 1);\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        sum = targetSum;\\n        // seen set with initial value 0 will help us match from the root\\n        seen[0] = 0;\\n        if (!root) return res;\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\\n\\nOriginal approach, vector-based with some extra backtracking logic and going for about a meager ~60% Time, ~50% Space:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0, sum;\\n    // seen set with initial value 0 will help us match from the root\\n    vector<int> seen = {0};\\n    void dfs(TreeNode* root, int partialSum = 0) {\\n        // updating partialSum with the current node\\n        partialSum += root->val;\\n        // checking if we already found an interval summing up to that\\n        for (auto n: seen) if (n == partialSum - sum) res++;\\n        // updating seen\\n        seen.push_back(partialSum);\\n        // searching potential left and right branches\\n        if (root->left) dfs(root->left, partialSum);\\n        if (root->right) dfs(root->right, partialSum);\\n        // clearing seen one level, for backtracking purposes\\n        seen.pop_back();\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        sum = targetSum;\\n        if (!root) return res;\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\\n\\nAlternative with `unordered_map`, almost as fast, but with space going down to 20% (I believe it used around 40-50% more space on average):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0, sum;\\n    unordered_map<int, int> seen;\\n    void dfs(TreeNode* root, int partialSum = 0) {\\n        // updating partialSum with the current node\\n        partialSum += root->val;\\n        // checking if we already found an interval summing up to that\\n        res += seen[partialSum - sum];\\n        // updating seen\\n        seen[partialSum]++;\\n        // searching potential left and right branches\\n        if (root->left) dfs(root->left, partialSum);\\n        if (root->right) dfs(root->right, partialSum);\\n        // clearing seen of the last value, for backtracking purposes\\n        seen[partialSum]--;\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        sum = targetSum;\\n        // seen set with initial value 0 will help us match from the root\\n        seen[0] = 1;\\n        if (!root) return res;\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int res = 0, sum;\\n    int seen[1001];\\n    void dfs(TreeNode* root, int partialSum = 0, int pos = 1) {\\n        // updating partialSum with the current node\\n        partialSum += root->val;\\n        // checking if we already found an interval summing up to that\\n        for (int i = 0; i < pos; i++) if (seen[i] == partialSum - sum) res++;\\n        // updating seen\\n        seen[pos] = partialSum;\\n        // searching potential left and right branches\\n        if (root->left) dfs(root->left, partialSum, pos + 1);\\n        if (root->right) dfs(root->right, partialSum, pos + 1);\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        sum = targetSum;\\n        // seen set with initial value 0 will help us match from the root\\n        seen[0] = 0;\\n        if (!root) return res;\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0, sum;\\n    // seen set with initial value 0 will help us match from the root\\n    vector<int> seen = {0};\\n    void dfs(TreeNode* root, int partialSum = 0) {\\n        // updating partialSum with the current node\\n        partialSum += root->val;\\n        // checking if we already found an interval summing up to that\\n        for (auto n: seen) if (n == partialSum - sum) res++;\\n        // updating seen\\n        seen.push_back(partialSum);\\n        // searching potential left and right branches\\n        if (root->left) dfs(root->left, partialSum);\\n        if (root->right) dfs(root->right, partialSum);\\n        // clearing seen one level, for backtracking purposes\\n        seen.pop_back();\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        sum = targetSum;\\n        if (!root) return res;\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int res = 0, sum;\\n    unordered_map<int, int> seen;\\n    void dfs(TreeNode* root, int partialSum = 0) {\\n        // updating partialSum with the current node\\n        partialSum += root->val;\\n        // checking if we already found an interval summing up to that\\n        res += seen[partialSum - sum];\\n        // updating seen\\n        seen[partialSum]++;\\n        // searching potential left and right branches\\n        if (root->left) dfs(root->left, partialSum);\\n        if (root->right) dfs(root->right, partialSum);\\n        // clearing seen of the last value, for backtracking purposes\\n        seen[partialSum]--;\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        sum = targetSum;\\n        // seen set with initial value 0 will help us match from the root\\n        seen[0] = 1;\\n        if (!root) return res;\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170367,
                "title": "python-solution",
                "content": "DFS with memoization: Use a variable `prevSum` to record the sum of all node values from the root `r` to the parent `p` of the current node. Then including the current node, the sum becomes `currSum = prevSum + node.val`. Now for each node on the path, we can calculate their respective `currSum`, we use a dictionary `rec` to record the frequency of all such sums. If the sum of nodes on a path ending with the current node has value `sum`, it implies that `currSum - sum` is in `rec`. Moreover, the number of such paths is `rec[currSum - sum]`. Then we can do DFS on the left and right child of the current node, with `currSum` being their `prevSum`. Also note that we need to do `rec[currSum] -= 1` after DFS on the left and right child of the current node, because the current node is not on the path of DFSs on other nodes, hence `currSum` is not available for other DFSs.\\n \\n Time complexity: `O(n)`, space complexity: `O(n)`.\\n \\n```\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        def dfs(root, prevSum, sum):\\n            if not root:\\n                return \\n            currSum = prevSum + root.val\\n            if currSum - sum in rec:\\n                self.count += rec[currSum - sum]\\n            if currSum in rec:\\n                rec[currSum] += 1\\n            else:\\n                rec[currSum] = 1\\n            dfs(root.left, currSum, sum)\\n            dfs(root.right, currSum, sum)\\n            rec[currSum] -= 1\\n            \\n        self.count = 0\\n        rec = {0:1}\\n        dfs(root, 0, sum)\\n        return self.count\\n```\\n\\nSlightly better solution without the variable `self.count`:\\n```\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        def dfs(root, prevSum, sum):\\n            if not root:\\n                return 0\\n            count = 0\\n            currSum = prevSum + root.val\\n            if currSum - sum in rec:\\n                count += rec[currSum - sum]\\n            if currSum in rec:\\n                rec[currSum] += 1\\n            else:\\n                rec[currSum] = 1\\n            count += dfs(root.left, currSum, sum)\\n            count += dfs(root.right, currSum, sum)\\n            rec[currSum] -= 1\\n            return count\\n            \\n        rec = {0:1}\\n        return dfs(root, 0, sum)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        def dfs(root, prevSum, sum):\\n            if not root:\\n                return \\n            currSum = prevSum + root.val\\n            if currSum - sum in rec:\\n                self.count += rec[currSum - sum]\\n            if currSum in rec:\\n                rec[currSum] += 1\\n            else:\\n                rec[currSum] = 1\\n            dfs(root.left, currSum, sum)\\n            dfs(root.right, currSum, sum)\\n            rec[currSum] -= 1\\n            \\n        self.count = 0\\n        rec = {0:1}\\n        dfs(root, 0, sum)\\n        return self.count\\n```\n```\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        def dfs(root, prevSum, sum):\\n            if not root:\\n                return 0\\n            count = 0\\n            currSum = prevSum + root.val\\n            if currSum - sum in rec:\\n                count += rec[currSum - sum]\\n            if currSum in rec:\\n                rec[currSum] += 1\\n            else:\\n                rec[currSum] = 1\\n            count += dfs(root.left, currSum, sum)\\n            count += dfs(root.right, currSum, sum)\\n            rec[currSum] -= 1\\n            return count\\n            \\n        rec = {0:1}\\n        return dfs(root, 0, sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780231,
                "title": "java-dfs-easy-to-understand",
                "content": "**PLEASE upvote if helpful!!**\\n\\n```\\nclass Solution {\\n    int counter = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n\\n        if (root == null) return 0;\\n\\n        pathSumHelper(root, sum, 0);\\n        pathSum(root.left, sum);\\n        pathSum(root.right, sum);\\n\\n        return counter;\\n\\n    }\\n\\n    void pathSumHelper(TreeNode root, int sum, int currentSum) {\\n        if (root == null) {\\n            return;\\n        }\\n        currentSum += root.val;\\n        if (currentSum == sum) {\\n            counter++;\\n        }\\n        pathSumHelper(root.left, sum, currentSum);\\n        pathSumHelper(root.right, sum, currentSum);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int counter = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n\\n        if (root == null) return 0;\\n\\n        pathSumHelper(root, sum, 0);\\n        pathSum(root.left, sum);\\n        pathSum(root.right, sum);\\n\\n        return counter;\\n\\n    }\\n\\n    void pathSumHelper(TreeNode root, int sum, int currentSum) {\\n        if (root == null) {\\n            return;\\n        }\\n        currentSum += root.val;\\n        if (currentSum == sum) {\\n            counter++;\\n        }\\n        pathSumHelper(root.left, sum, currentSum);\\n        pathSumHelper(root.right, sum, currentSum);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779227,
                "title": "python-dfs-hash-table-using-cumulative-sums-explained",
                "content": "If we can have any solution, that this problem is indeed medium. However if we wan to have `O(n)` time solution, in my opinion it is more like hard, because we need to use dfs + hash table in the same time.\\n\\nFirst of all, let us evaluate cumulative sum of our tree, what does it mean? Here an example: for each node we evaluate sum of path from this node to root.\\n\\n![image](https://assets.leetcode.com/users/images/119b5a72-5244-4cd7-bb6e-60784d94c2a0_1596872120.09719.png)\\n\\n\\nAlso we evaluate number of nodes in our tree. What we need to find now? Number of pairs of two nodes, one of them is descendant of another and difference of cumulative sums is equal to `sum`. Let me explain my `dfs(self, root, sum)` function:\\n\\n1. If we reached `None`, just go back.\\n2. We have `self.count` hash table, where we put `root.val + sum`: number we are looking for when we visited this node: for example if we are in node with value `15` now (see our example), then we want to find node with values `15+8` inside. \\n3. Also, we add to our final result number of solution for our `root.val`. \\n4. Run recursively our `dfs` for left and right children\\n5. Remove our `root.val + sum` from our hash table, because we are not anymore in `root` node.\\n\\nNow, let us consider our `pathSum(self, root, sum)` function:\\n1. If tree is empty, we return `0`\\n2. Define some global variables.\\n3. Run our `cumSum` function to evaluate cumulative sums\\n4. Run `dfs` method.\\n5. In the end we need to subtract `self.n*(sum == 0)` from our result. Why? Because if `sum = 0`, then we will count exactly `self.n` empty cumulative sums, which consist of zero elements.\\n\\n**Complexity**: Time complexity to evaluate cumulative sums is `O(n)`. The same time complexity is for `dfs` function. Space complexity is also `O(n)`, because we need to keep this amount of information in our `count` hash table.\\n\\n```\\nclass Solution:\\n    def cumSum(self, root):\\n        self.n += 1\\n        for child in filter(None, [root.left, root.right]):\\n            child.val += root.val\\n            self.cumSum(child)\\n                \\n    def dfs(self, root, sum):\\n        if not root: return None\\n        \\n        self.count[root.val + sum] += 1\\n        self.result += self.count[root.val]\\n        self.dfs(root.left, sum)\\n        self.dfs(root.right, sum)\\n        self.count[root.val + sum] -= 1\\n \\n    def pathSum(self, root, sum):\\n        if not root: return 0\\n        \\n        self.n, self.result, self.count = 0, 0, defaultdict(int)\\n        self.cumSum(root)\\n        self.count[sum] = 1\\n        self.dfs(root, sum)\\n        return self.result  - self.n*(sum == 0) \\n```\\n\\n**Update**: thanks @rkmd for pointing out that we do not really need to evaluate cumlative sums, we can do in on the fly. Also if we do it on the fly, we do not need to check case if `sum == 0`. Here is the code:\\n\\n```\\nclass Solution:\\n    def dfs(self, root, sum, root_sum):\\n        if not root: return None\\n        \\n        root_sum += root.val\\n        self.result += self.count[root_sum]  \\n        self.count[root_sum + sum] += 1\\n        self.dfs(root.left, sum, root_sum)\\n        self.dfs(root.right, sum, root_sum)\\n        self.count[root_sum + sum] -= 1\\n \\n    def pathSum(self, root, sum):\\n        self.result, self.count = 0, defaultdict(int)\\n        self.count[sum] = 1\\n        self.dfs(root, sum, 0)\\n        return self.result\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def cumSum(self, root):\\n        self.n += 1\\n        for child in filter(None, [root.left, root.right]):\\n            child.val += root.val\\n            self.cumSum(child)\\n                \\n    def dfs(self, root, sum):\\n        if not root: return None\\n        \\n        self.count[root.val + sum] += 1\\n        self.result += self.count[root.val]\\n        self.dfs(root.left, sum)\\n        self.dfs(root.right, sum)\\n        self.count[root.val + sum] -= 1\\n \\n    def pathSum(self, root, sum):\\n        if not root: return 0\\n        \\n        self.n, self.result, self.count = 0, 0, defaultdict(int)\\n        self.cumSum(root)\\n        self.count[sum] = 1\\n        self.dfs(root, sum)\\n        return self.result  - self.n*(sum == 0) \\n```\n```\\nclass Solution:\\n    def dfs(self, root, sum, root_sum):\\n        if not root: return None\\n        \\n        root_sum += root.val\\n        self.result += self.count[root_sum]  \\n        self.count[root_sum + sum] += 1\\n        self.dfs(root.left, sum, root_sum)\\n        self.dfs(root.right, sum, root_sum)\\n        self.count[root_sum + sum] -= 1\\n \\n    def pathSum(self, root, sum):\\n        self.result, self.count = 0, defaultdict(int)\\n        self.count[sum] = 1\\n        self.dfs(root, sum, 0)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91888,
                "title": "18ms-fast-one-pass-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int help(TreeNode* root, int sum, unordered_map<int, int>& store, int pre) {\\n        if (!root) return 0;\\n        root->val += pre;\\n        int res = (root->val == sum) + (store.count(root->val - sum) ? store[root->val - sum] : 0);\\n        store[root->val]++;\\n        res += help(root->left, sum, store, root->val) + help(root->right, sum, store, root->val);\\n        store[root->val]--;\\n        return res;\\n    }\\n\\n    int pathSum(TreeNode* root, int sum) {\\n        unordered_map<int, int> store;\\n        return help(root, sum, store, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(TreeNode* root, int sum, unordered_map<int, int>& store, int pre) {\\n        if (!root) return 0;\\n        root->val += pre;\\n        int res = (root->val == sum) + (store.count(root->val - sum) ? store[root->val - sum] : 0);\\n        store[root->val]++;\\n        res += help(root->left, sum, store, root->val) + help(root->right, sum, store, root->val);\\n        store[root->val]--;\\n        return res;\\n    }\\n\\n    int pathSum(TreeNode* root, int sum) {\\n        unordered_map<int, int> store;\\n        return help(root, sum, store, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581442,
                "title": "python-dfs-recursive-solution",
                "content": "```\\nclass Solution:\\n    cnt = 0\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        def dfs(root, start, s):\\n            if not root:\\n                return\\n            s -= root.val \\n            if s==0:\\n                self.cnt+=1\\n            dfs(root.left,False, s)\\n            dfs(root.right,False, s)\\n            if start: \\n                dfs(root.left,True,sum)\\n                dfs(root.right,True,sum)\\n        \\n        dfs(root, True, sum)\\n        return self.cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    cnt = 0\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        def dfs(root, start, s):\\n            if not root:\\n                return\\n            s -= root.val \\n            if s==0:\\n                self.cnt+=1\\n            dfs(root.left,False, s)\\n            dfs(root.right,False, s)\\n            if start: \\n                dfs(root.left,True,sum)\\n                dfs(root.right,True,sum)\\n        \\n        dfs(root, True, sum)\\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91996,
                "title": "easy-to-understand-java-solution-with-comment",
                "content": "Any suggestion is greatly appreciated.\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n \\n/*\\nfor each parent node in the tree, we have 2 choices:\\n1. include it in the path to reach sum.\\n2. not include it in the path to reach sum. \\n\\nfor each child node in the tree, we have 2 choices:\\n1. take what your parent left you.\\n2. start from yourself to form the path.\\n\\none little thing to be careful:\\nevery node in the tree can only try to be the start point once.\\n\\nfor example, When we try to start with node 1, node 3, as a child, could choose to start by itself.\\n             Later when we try to start with 2, node 3, still as a child, \\n             could choose to start by itself again, but we don't want to add the count to result again.\\n     1\\n      \\\\\\n       2\\n        \\\\\\n         3\\n         \\n*/ \\npublic class Solution {\\n    int target;\\n    Set<TreeNode> visited;\\n    public int pathSum(TreeNode root, int sum) {\\n        target = sum;\\n        visited = new HashSet<TreeNode>();  // to store the nodes that have already tried to start path by themselves.\\n        return pathSumHelper(root, sum, false);\\n    }\\n    \\n    public int pathSumHelper(TreeNode root, int sum, boolean hasParent) {\\n        if(root == null) return 0;\\n        //the hasParent flag is used to handle the case when parent path sum is 0.\\n        //in this case we still want to explore the current node.\\n        if(sum == target && visited.contains(root) && !hasParent) return 0;\\n        if(sum == target && !hasParent) visited.add(root);\\n        int count = (root.val == sum)?1:0;\\n        count += pathSumHelper(root.left, sum - root.val, true);\\n        count += pathSumHelper(root.right, sum - root.val, true);\\n        count += pathSumHelper(root.left, target , false);\\n        count += pathSumHelper(root.right, target, false);\\n        return count;\\n    }\\n}````",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n \\n/*\\nfor each parent node in the tree, we have 2 choices:\\n1. include it in the path to reach sum.\\n2. not include it in the path to reach sum. \\n\\nfor each child node in the tree, we have 2 choices:\\n1. take what your parent left you.\\n2. start from yourself to form the path.\\n\\none little thing to be careful:\\nevery node in the tree can only try to be the start point once.\\n\\nfor example, When we try to start with node 1, node 3, as a child, could choose to start by itself.\\n             Later when we try to start with 2, node 3, still as a child, \\n             could choose to start by itself again, but we don't want to add the count to result again.\\n     1\\n      \\\\\\n       2\\n        \\\\\\n         3\\n         \\n*/ \\npublic class Solution {\\n    int target;\\n    Set<TreeNode> visited;\\n    public int pathSum(TreeNode root, int sum) {\\n        target = sum;\\n        visited = new HashSet<TreeNode>();  // to store the nodes that have already tried to start path by themselves.\\n        return pathSumHelper(root, sum, false);\\n    }\\n    \\n    public int pathSumHelper(TreeNode root, int sum, boolean hasParent) {\\n        if(root == null) return 0;\\n        //the hasParent flag is used to handle the case when parent path sum is 0.\\n        //in this case we still want to explore the current node.\\n        if(sum == target && visited.contains(root) && !hasParent) return 0;\\n        if(sum == target && !hasParent) visited.add(root);\\n        int count = (root.val == sum)?1:0;\\n        count += pathSumHelper(root.left, sum - root.val, true);\\n        count += pathSumHelper(root.right, sum - root.val, true);\\n        count += pathSumHelper(root.left, target , false);\\n        count += pathSumHelper(root.right, target, false);\\n        return count;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 91942,
                "title": "easy-recursive-python-7-lines-solution",
                "content": "Similar to #112 and #113, check the whole tree.\\nThe only difference is: Any node can play as start or end in a valid path.\\nAfter each visit, use current node as start, and update the \"targets\" list.\\nPass the updated targets and initial target through.\\n\\nBase case:\\n1. node is None\\n\\nRecursive case:\\n1. node fits in certain path sum.\\n2. node doesn't meet.\\n\\n```\\nclass Solution(object):\\n    def pathSum(self, root, s):\\n        return self.helper(root, s, [s])\\n\\n    def helper(self, node, origin, targets):\\n        if not node: return 0\\n        hit = 0\\n        for t in targets:\\n            if not t-node.val: hit += 1                          # count if sum == target\\n        targets = [t-node.val for t in targets]+[origin]         # update the targets\\n        return hit+self.helper(node.left, origin, targets)+self.helper(node.right, origin, targets)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def pathSum(self, root, s):\\n        return self.helper(root, s, [s])\\n\\n    def helper(self, node, origin, targets):\\n        if not node: return 0\\n        hit = 0\\n        for t in targets:\\n            if not t-node.val: hit += 1                          # count if sum == target\\n        targets = [t-node.val for t in targets]+[origin]         # update the targets\\n        return hit+self.helper(node.left, origin, targets)+self.helper(node.right, origin, targets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540077,
                "title": "c-simple-dfs-solution-t-88-41-m-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int pathcount;\\n    void getsum(TreeNode* root, int sum){//checking paths at each node.\\n        if(!root)return;\\n        if(root->val==sum){\\n            pathcount++;\\n        }\\n        getsum(root->left,sum-root->val);\\n        getsum(root->right,sum-root->val);\\n    }\\n    int pathSum(TreeNode* root, int& sum) {//perform simple dfs checking for each node\\n        if(root){\\n            getsum(root,sum);\\n            pathSum(root->left,sum);\\n            pathSum(root->right,sum);\\n        }\\n        return pathcount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pathcount;\\n    void getsum(TreeNode* root, int sum){//checking paths at each node.\\n        if(!root)return;\\n        if(root->val==sum){\\n            pathcount++;\\n        }\\n        getsum(root->left,sum-root->val);\\n        getsum(root->right,sum-root->val);\\n    }\\n    int pathSum(TreeNode* root, int& sum) {//perform simple dfs checking for each node\\n        if(root){\\n            getsum(root,sum);\\n            pathSum(root->left,sum);\\n            pathSum(root->right,sum);\\n        }\\n        return pathcount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525060,
                "title": "easy-solution-using-java-dfs-map",
                "content": "**Simple Solution:**\\n\\nStart helper method from all the nodes and compute the total count.\\n\\n```\\nclass Solution {\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root == null)\\n            return 0;\\n        \\n        return pathSum(root.left, targetSum) + pathSum(root.right, targetSum) + helper(root, 0, targetSum);\\n    }\\n    \\n    int helper(TreeNode root, int current, int target) {\\n        if(root == null)\\n            return 0;\\n        \\n        current += root.val;\\n        \\n        return (current == target ? 1 : 0) + helper(root.left, current, target) + helper(root.right, current, target);\\n    }\\n}\\n```\\n\\nThis approach is time consuming since we will be visiting each non-root node more than once. We can optimize this using path sum in each node and map.\\n\\n**Optimized solution**\\n![image](https://assets.leetcode.com/users/images/2757c4b0-67c2-4bad-9330-cc0774845458_1634437241.3073082.jpeg)\\n\\n\\nFrom the above tree, lets take a path\\n\\n10 -> 5 -> 2 -> 1, target = 8\\n\\nmap -> [0, 1], [10, 1], [15, 1], [17, 1]\\n\\nwhen we reach element 1, current path sum is 18. but our target is 8. we can check in the map if we have sum 10(18-8). if so we can add it the count.\\n\\n```\\nclass Solution {\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root == null)\\n            return 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        return helper(root, 0, targetSum, map);\\n    }\\n    \\n    public int helper(TreeNode root, int current, int target, Map<Integer, Integer> map) {\\n        if(root == null)\\n            return 0;\\n        \\n        current += root.val;\\n        int count = 0;\\n        \\n        count += map.getOrDefault(current - target, 0);\\n        map.put(current, map.getOrDefault(current, 0) + 1);\\n        \\n        count += helper(root.left, current, target, map);\\n        count += helper(root.right, current, target, map);\\n        \\n        map.put(current, map.get(current) - 1);\\n        return count;\\n    }\\n}\\n```\\n\\nWhy do we need to use map? Why can\\'t we use set and add 1 to the count?\\n```\\n      0\\n 1       1\\n \\n\\ntarget = 1\\n \\nfor this example, result is 4\\n\\n1) 1\\n2) 1\\n3) 0 -> 1\\n4) 0 -> 1\\n```\\nif we are not keeping the count, then result will be incorrect.\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root == null)\\n            return 0;\\n        \\n        return pathSum(root.left, targetSum) + pathSum(root.right, targetSum) + helper(root, 0, targetSum);\\n    }\\n    \\n    int helper(TreeNode root, int current, int target) {\\n        if(root == null)\\n            return 0;\\n        \\n        current += root.val;\\n        \\n        return (current == target ? 1 : 0) + helper(root.left, current, target) + helper(root.right, current, target);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root == null)\\n            return 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        return helper(root, 0, targetSum, map);\\n    }\\n    \\n    public int helper(TreeNode root, int current, int target, Map<Integer, Integer> map) {\\n        if(root == null)\\n            return 0;\\n        \\n        current += root.val;\\n        int count = 0;\\n        \\n        count += map.getOrDefault(current - target, 0);\\n        map.put(current, map.getOrDefault(current, 0) + 1);\\n        \\n        count += helper(root.left, current, target, map);\\n        count += helper(root.right, current, target, map);\\n        \\n        map.put(current, map.get(current) - 1);\\n        return count;\\n    }\\n}\\n```\n```\\n      0\\n 1       1\\n \\n\\ntarget = 1\\n \\nfor this example, result is 4\\n\\n1) 1\\n2) 1\\n3) 0 -> 1\\n4) 0 -> 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526096,
                "title": "python-one-pass-dfs-faster-than-99",
                "content": "Please feel free to give suggestions or ask questions. **Upvote** if you like the solution.\\nO(h) space if we delete zero-valued items from sums.\\n\\n**Idea**: Maintain prefix sums while doing dfs from root to leaf. If currentSum-prefixSum=targetSum, then we\\'ve found a path that has a value of target. If we encountered prefixSum n times, then we\\'ve found n such paths.\\n```\\ndef pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n\\n\\t# prefix sums encountered in current path\\n\\tsums = defaultdict(int)\\n\\tsums[0] = 1\\n\\n\\tdef dfs(root, total):\\n\\t\\tcount = 0\\n\\t\\tif root:\\n\\t\\t\\ttotal += root.val\\n\\t\\t\\t# Can remove sums[currSum-targetSum] prefixSums to get target\\n\\t\\t\\tcount = sums[total-targetSum]\\n\\n\\t\\t\\t# Add value of this prefixSum\\n\\t\\t\\tsums[total] += 1\\n\\t\\t\\t# Explore children\\n\\t\\t\\tcount += dfs(root.left, total) + dfs(root.right, total)\\n\\t\\t\\t# Remove value of this prefixSum (path\\'s been explored)\\n\\t\\t\\tsums[total] -= 1\\n\\n\\t\\treturn count\\n\\n\\treturn dfs(root, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Prefix Sum"
                ],
                "code": "```\\ndef pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n\\n\\t# prefix sums encountered in current path\\n\\tsums = defaultdict(int)\\n\\tsums[0] = 1\\n\\n\\tdef dfs(root, total):\\n\\t\\tcount = 0\\n\\t\\tif root:\\n\\t\\t\\ttotal += root.val\\n\\t\\t\\t# Can remove sums[currSum-targetSum] prefixSums to get target\\n\\t\\t\\tcount = sums[total-targetSum]\\n\\n\\t\\t\\t# Add value of this prefixSum\\n\\t\\t\\tsums[total] += 1\\n\\t\\t\\t# Explore children\\n\\t\\t\\tcount += dfs(root.left, total) + dfs(root.right, total)\\n\\t\\t\\t# Remove value of this prefixSum (path\\'s been explored)\\n\\t\\t\\tsums[total] -= 1\\n\\n\\t\\treturn count\\n\\n\\treturn dfs(root, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779262,
                "title": "c-using-2-one-liner-function-easy-code-too",
                "content": "```\\nclass Solution {\\npublic:\\n    int DFS(TreeNode *root,int sum){\\n        return root?(root->val==sum) + DFS(root->left,sum-root->val) + DFS(root->right,sum-root->val):0;\\n    }\\n    int pathSum(TreeNode* root, int sum) {\\n        return root? DFS(root,sum) + pathSum(root->left,sum) + pathSum(root->right,sum):0;\\n    }\\n};\\n```\\n**or Can Try This**\\n```Same Concept But Easy To Understand```\\n```\\nclass Solution {\\npublic:\\n    int DFS(TreeNode *root,int sum){\\n        if(root==nullptr)\\n            return 0;\\n        int ans = root->val==sum?1:0;\\n        return ans + DFS(root->left,sum-root->val) + DFS(root->right,sum-root->val);\\n    }\\n    int pathSum(TreeNode* root, int sum) {\\n        if(root==nullptr)\\n            return 0;\\n        return DFS(root,sum) + pathSum(root->left,sum) + pathSum(root->right,sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int DFS(TreeNode *root,int sum){\\n        return root?(root->val==sum) + DFS(root->left,sum-root->val) + DFS(root->right,sum-root->val):0;\\n    }\\n    int pathSum(TreeNode* root, int sum) {\\n        return root? DFS(root,sum) + pathSum(root->left,sum) + pathSum(root->right,sum):0;\\n    }\\n};\\n```\n```Same Concept But Easy To Understand```\n```\\nclass Solution {\\npublic:\\n    int DFS(TreeNode *root,int sum){\\n        if(root==nullptr)\\n            return 0;\\n        int ans = root->val==sum?1:0;\\n        return ans + DFS(root->left,sum-root->val) + DFS(root->right,sum-root->val);\\n    }\\n    int pathSum(TreeNode* root, int sum) {\\n        if(root==nullptr)\\n            return 0;\\n        return DFS(root,sum) + pathSum(root->left,sum) + pathSum(root->right,sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779355,
                "title": "java-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n\\t\\n\\tint paths = 0;\\n\\t\\n\\tprivate void helper (TreeNode root, int sum) {\\n\\t\\t\\n\\t\\tif (root != null && root.val == sum) {\\n\\t\\t\\t++paths;\\n\\t\\t}\\n\\t\\tif (root != null) {\\n\\t\\t\\tsum -= root.val;\\n\\t\\t\\thelper (root.left, sum);\\n\\t\\t\\thelper (root.right, sum);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic int pathSum (TreeNode root, int sum) {\\n\\t\\t\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\thelper (root, sum);\\n\\t\\tpathSum (root.left, sum);\\n\\t\\tpathSum (root.right, sum);\\n\\t\\treturn paths;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tint paths = 0;\\n\\t\\n\\tprivate void helper (TreeNode root, int sum) {\\n\\t\\t\\n\\t\\tif (root != null && root.val == sum) {\\n\\t\\t\\t++paths;\\n\\t\\t}\\n\\t\\tif (root != null) {\\n\\t\\t\\tsum -= root.val;\\n\\t\\t\\thelper (root.left, sum);\\n\\t\\t\\thelper (root.right, sum);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic int pathSum (TreeNode root, int sum) {\\n\\t\\t\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\thelper (root, sum);\\n\\t\\tpathSum (root.left, sum);\\n\\t\\tpathSum (root.right, sum);\\n\\t\\treturn paths;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216263,
                "title": "easy-to-understand-java-solution",
                "content": "For each node in the tree we call the helper function.\\n```\\nclass Solution {\\n    int result = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n        helper(root, sum);\\n        pathSum(root.left, sum);\\n        pathSum(root.right, sum);\\n        return result;\\n    }\\n    \\n    public void helper(TreeNode root, int sum) {\\n        if (root == null) return;\\n        if (sum - root.val == 0) result+=1;\\n        helper(root.left, sum-root.val);\\n        helper(root.right, sum-root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n        if(root == null) return 0;\\n        helper(root, sum);\\n        pathSum(root.left, sum);\\n        pathSum(root.right, sum);\\n        return result;\\n    }\\n    \\n    public void helper(TreeNode root, int sum) {\\n        if (root == null) return;\\n        if (sum - root.val == 0) result+=1;\\n        helper(root.left, sum-root.val);\\n        helper(root.right, sum-root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478927,
                "title": "python-solution-dfs-hashtable-o-n-time-o-n-space",
                "content": "#### Explanation\\n- depth first search through each node\\n- store the hash of prefix sum of the current path ([key -> prefix sum] : value -> count )\\n- A path exist when currentSum - prefixSum = sum, therefore occurence of prefixSum (currentSum - sum) in sumHash represents the number of paths ending at current node\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n        \\n        def dfs(sumHash, prefixSum, node):\\n\\n            if not node:\\n                return 0\\n            \\n\\t\\t\\t# Sum of current path\\n            prefixSum += node.val\\n            \\n\\t\\t\\t# number of paths that ends at current node\\n            path = sumHash[prefixSum - sum] \\n            \\n\\t\\t\\t# add currentSum to prefixSum Hash\\n            sumHash[prefixSum] += 1\\n            \\n\\t\\t\\t# traverse left and right of tree\\n            path += dfs(sumHash, prefixSum, node.left) + dfs(sumHash, prefixSum, node.right)\\n        \\n\\t\\t    # remove currentSum from prefixSum Hash\\n            sumHash[prefixSum] -= 1\\n            \\n            return path\\n        \\n        # depth first search, initialize sumHash with prefix sum of 0, occurring once\\n        return dfs(collections.defaultdict(int, {0: 1}), 0, root)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Prefix Sum"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n        \\n        def dfs(sumHash, prefixSum, node):\\n\\n            if not node:\\n                return 0\\n            \\n\\t\\t\\t# Sum of current path\\n            prefixSum += node.val\\n            \\n\\t\\t\\t# number of paths that ends at current node\\n            path = sumHash[prefixSum - sum] \\n            \\n\\t\\t\\t# add currentSum to prefixSum Hash\\n            sumHash[prefixSum] += 1\\n            \\n\\t\\t\\t# traverse left and right of tree\\n            path += dfs(sumHash, prefixSum, node.left) + dfs(sumHash, prefixSum, node.right)\\n        \\n\\t\\t    # remove currentSum from prefixSum Hash\\n            sumHash[prefixSum] -= 1\\n            \\n            return path\\n        \\n        # depth first search, initialize sumHash with prefix sum of 0, occurring once\\n        return dfs(collections.defaultdict(int, {0: 1}), 0, root)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 249400,
                "title": "python-iterative-dfs-with-a-stack",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def pathSum(self, root, total):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return 0\\n        \\n        stack = [(root, [root.val])]\\n        num = 0\\n        \\n        while stack:\\n            node, totals = stack.pop()\\n            \\n            num += totals.count(total)\\n                \\n            if node.left:\\n                stack.append((node.left, [x+node.left.val for x in totals]+[node.left.val]))\\n            if node.right:\\n                stack.append((node.right, [x+node.right.val for x in totals]+[node.right.val]))\\n        return num\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def pathSum(self, root, total):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return 0\\n        \\n        stack = [(root, [root.val])]\\n        num = 0\\n        \\n        while stack:\\n            node, totals = stack.pop()\\n            \\n            num += totals.count(total)\\n                \\n            if node.left:\\n                stack.append((node.left, [x+node.left.val for x in totals]+[node.left.val]))\\n            if node.right:\\n                stack.append((node.right, [x+node.right.val for x in totals]+[node.right.val]))\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049652,
                "title": "python-solution",
                "content": "What I found helps with this problem is to have two recursive functions:\\n- `dfs` simply recurses through each node of the tree\\n- `find_path_from_node` tries to find paths starting from the given node\\n\\nI ran into problems when I tried to merge these functions into one. A lesson for me is to split up recursive functions so each recursive function has a single responsibility.\\n\\n\\n```python\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        \\n        global result\\n        result = 0\\n        \\n        def dfs(node, target):\\n            if node is None: return\\n            find_path_from_node(node, target)\\n            dfs(node.left, target)\\n            dfs(node.right, target)\\n                \\n        def find_path_from_node(node, target):\\n            global result\\n            if node is None: return\\n            if node.val == target: result += 1\\n            find_path_from_node(node.left, target-node.val)\\n            find_path_from_node(node.right, target-node.val)\\n            \\n        dfs(root, sum)\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        \\n        global result\\n        result = 0\\n        \\n        def dfs(node, target):\\n            if node is None: return\\n            find_path_from_node(node, target)\\n            dfs(node.left, target)\\n            dfs(node.right, target)\\n                \\n        def find_path_from_node(node, target):\\n            global result\\n            if node is None: return\\n            if node.val == target: result += 1\\n            find_path_from_node(node.left, target-node.val)\\n            find_path_from_node(node.right, target-node.val)\\n            \\n        dfs(root, sum)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449878,
                "title": "easiest-to-understand-java-solution",
                "content": "```\\n    public int pathSum(TreeNode root, int sum) {\\n        int curCount = isMeetSum(root, sum);\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        return curCount + pathSum(root.left, sum) + pathSum(root.right, sum);\\n    }\\n\\n    public int isMeetSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int count = 0;\\n        if (root.val == sum) {\\n            count++;\\n        }\\n        return count + isMeetSum(root.left, sum - root.val) + isMeetSum(root.right, sum - root.val);\\n    }\\n```\\n\\nThe `isMeetSum` method find the number of solutions that starting at the root, it doesn\\'t matter where it ends. \\nThe `pathSum` mehtod basically iterate to each node and add everything up. \\n\\nNot the best solution as it does a lot of repeated calcualtion.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int pathSum(TreeNode root, int sum) {\\n        int curCount = isMeetSum(root, sum);\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        return curCount + pathSum(root.left, sum) + pathSum(root.right, sum);\\n    }\\n\\n    public int isMeetSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int count = 0;\\n        if (root.val == sum) {\\n            count++;\\n        }\\n        return count + isMeetSum(root.left, sum - root.val) + isMeetSum(root.right, sum - root.val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91940,
                "title": "c-2-lines-body-code-with-explanation",
                "content": "Explanation for helper function `f` is below. The rest should be self-explanatory.\\n```\\n    class Solution {\\n    public:\\n    int pathSum(TreeNode* root, int sum) {\\n        return root ? f(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum) : 0;\\n    }\\n    \\n    int f(TreeNode* root, int sum) {\\n        return root ? (root->val == sum) + f(root->left, sum - root->val) + f(root->right, sum - root->val) : 0;\\n    }\\n};\\n```\\n\\nHelper function `f(root, sum)` = **path sum if we only consider paths beginning at root**\\n\\nFor example, for the following tree, `f(root, sum=6)` is `1` based on path `[5, 3, -2]`. \\n\\nAlthough path `[3, 3]` also sums to `6`, it's not counted because it doesn't begin with root `node 5`.\\n```\\n    5 \\n   / \\\\ \\n  3   2 \\n / \\\\   \\\\\\n3  -2   1\\n```",
                "solutionTags": [],
                "code": "```\\n    class Solution {\\n    public:\\n    int pathSum(TreeNode* root, int sum) {\\n        return root ? f(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum) : 0;\\n    }\\n    \\n    int f(TreeNode* root, int sum) {\\n        return root ? (root->val == sum) + f(root->left, sum - root->val) + f(root->right, sum - root->val) : 0;\\n    }\\n};\\n```\n```\\n    5 \\n   / \\\\ \\n  3   2 \\n / \\\\   \\\\\\n3  -2   1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91915,
                "title": "my-detailed-explanation-to-the-hashmap-method",
                "content": "This is a recursion problem involved tree and HashMap. It requires a through understanding of recursion. I am surprised that this problem is categorized to \"easy\" in LeetCode. \\n\\nA simple version of this problem: each node represents a number and find out **whether** existing a path that sums to a given number. Let's call it Problem A. \\n\\nA further simplified problem: given an array, find out whether existing a subarray whose sum is a given number. Let's call it Problem B.\\n\\nHow to solve Problem B? The idea is to use a HashSet to store prefix sum. Iteratively scan each number in the array and calculate the current sum, then check if `curSum - target` exists in the HashSet, if so return true; otherwise add curSum to the HashSet. Maybe you can get the idea quickly from the code: \\n\\n```\\n// input parameters: int[] nums, int target\\nSet<Integer> set = new HashSet<>();\\ncurSum = 0;\\nfor (int i : nums) {\\n\\tcurSum += i;\\n\\tif (set.contains(curSum - target)) {\\n\\t\\treturn true;\\n\\t} else {\\n\\t\\tset.add(curSum);\\n\\t}\\n}\\nreturn false;\\n```\\n  \\nNow you can see that, after `nums[i]` is visited, the HashSet stores prefix sums from 0th element to the 0th element, 1st element, 2nd element, ... , ith element. If `curSum - target` exists in the HashSet, it means there is one subarray ended at current element, whose sum is `target`. Time complexity is O(n) and space complexity is O(n).\\n\\nNow let's go to Problem A. Because array is 1D data structure and tree is 1.5D data structure, so the idea to use a HashSet to store the prefix sum also works on Problem A. So the HashSet stores all the prefix sum corresponding to the current node, when visiting the node, calcuate the currrent sum then check if `curSum - target` exists in the HashSet. One thing worthes mention: if the node's value can be negative, when returning from a child node to its parent node, the HashSet needs to be updated as following:\\n\\n1. from the HashSet, remove the `curSum` of the child, if it is added to the HashSet successfully when visiting the child node,\\n2.  do nothing to the HashSet if the `curSum` of the child can not add to the HashSet when visiting the child node(menas the number `curSum` already exists).\\n\\nIf all nodes' values are positive, then just remove `curSum` when it goes back to the parent node. The key point here is that make sure the HashSet is always correctly updated when iterating the tree.\\n\\nNow it is time for the original problem which requires the number of paths. Because nodes' values can be negative, it means that there might be multiple paths whose sum is the given value. So we need to use a HashMap whose key is the prefix sum and the value is the corresponding frequency.  Thanks to @kekezi for her clean code.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // if sum == target, map.get(sum - target) return 1\\n        map.put(0, 1);\\n        return findPathSum(root, 0, sum, map);\\n    }\\n    \\n    private int findPathSum(TreeNode curr, int sum, int target, Map<Integer, Integer> map) {\\n        if (curr == null) {\\n            return 0;\\n        }\\n        // update the prefix sum by adding the current val\\n        sum += curr.val;\\n        // get the number of valid path, ended by the current node\\n        int numPathToCurr = map.getOrDefault(sum - target, 0); \\n        // update the map with the current sum, so the map is good to be passed to the next recursion\\n        map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        // add the 3 parts discussed in 8. together\\n        int res = numPathToCurr + findPathSum(curr.left, sum, target, map) + findPathSum(curr.right, sum, target, map);\\n        // restore the map, as the recursion goes from the bottom to the top\\n        map.put(sum, map.get(sum) - 1);\\n        return res;\\n    }\\n}\\n```\\nTime complexity is O(n) and space complexity is O(h) where h is the height of tree and worst case it can be n.",
                "solutionTags": [],
                "code": "```\\n// input parameters: int[] nums, int target\\nSet<Integer> set = new HashSet<>();\\ncurSum = 0;\\nfor (int i : nums) {\\n\\tcurSum += i;\\n\\tif (set.contains(curSum - target)) {\\n\\t\\treturn true;\\n\\t} else {\\n\\t\\tset.add(curSum);\\n\\t}\\n}\\nreturn false;\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // if sum == target, map.get(sum - target) return 1\\n        map.put(0, 1);\\n        return findPathSum(root, 0, sum, map);\\n    }\\n    \\n    private int findPathSum(TreeNode curr, int sum, int target, Map<Integer, Integer> map) {\\n        if (curr == null) {\\n            return 0;\\n        }\\n        // update the prefix sum by adding the current val\\n        sum += curr.val;\\n        // get the number of valid path, ended by the current node\\n        int numPathToCurr = map.getOrDefault(sum - target, 0); \\n        // update the map with the current sum, so the map is good to be passed to the next recursion\\n        map.put(sum, map.getOrDefault(sum, 0) + 1);\\n        // add the 3 parts discussed in 8. together\\n        int res = numPathToCurr + findPathSum(curr.left, sum, target, map) + findPathSum(curr.right, sum, target, map);\\n        // restore the map, as the recursion goes from the bottom to the top\\n        map.put(sum, map.get(sum) - 1);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525690,
                "title": "c-o-n-8ms-prefix-sum-solution-with-explanation-99-07-faster",
                "content": "For each node, we will calculate cumulative sum of node val and add it to the map. If the value of sum is greater than target sum, that means we have extra (sum - target) value to our sum. Now, we will check our hashmap if (sum-target) extra value is availble to our map or not. If it\\'s available that means we can remove some nodes from top to get target sum.\\n\\n**Time Complexity**: O(n)\\n**Space Complexity**: O(n)\\n\\n```\\nclass Solution {\\n    unordered_map<long, int> hashMap;\\n    int count;\\n    int target;\\n    void find(TreeNode* root, long sum) {\\n        if (root == 0) return;\\n        sum += root->val;\\n        int prefixSum = sum - target;\\n        if (hashMap.count(prefixSum)) {\\n            count += hashMap[prefixSum];\\n        }\\n        hashMap[sum]++;\\n        find(root->left, sum);\\n        find(root->right, sum);\\n        hashMap[sum]--;\\n    }\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        count = 0;\\n        target = targetSum;\\n        hashMap[0] = 1;\\n        find(root, 0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<long, int> hashMap;\\n    int count;\\n    int target;\\n    void find(TreeNode* root, long sum) {\\n        if (root == 0) return;\\n        sum += root->val;\\n        int prefixSum = sum - target;\\n        if (hashMap.count(prefixSum)) {\\n            count += hashMap[prefixSum];\\n        }\\n        hashMap[sum]++;\\n        find(root->left, sum);\\n        find(root->right, sum);\\n        hashMap[sum]--;\\n    }\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        count = 0;\\n        target = targetSum;\\n        hashMap[0] = 1;\\n        find(root, 0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328128,
                "title": "simple-python-solution-top-down-dfs-dp",
                "content": "Please see and vote for my solutions for these similar problems.\\n\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/discuss/309004/Different-DFS-Python-solutions)\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\\n\\n[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/328123/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/328033/Top-down-Python-DFS-Solution)\\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/328119/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/discuss/328124/Simple-Python-Solution%3A-top-down-DFS)\\n\\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\\n\\n[113. Path Sum II](https://leetcode.com/problems/path-sum-ii/discuss/328125/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\\n\\n[437. Path Sum III](https://leetcode.com/problems/path-sum-iii/discuss/328128/Simple-Python-Solution%3A-top-down-DFS-%2B-DP) (Similar problem: 560. Subarray Sum Equals K)\\n\\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779863,
                "title": "path-sum-iii-java",
                "content": "```\\nclass Solution {\\n\\n    public int pathSum(TreeNode root, int sum) {\\n        if( root == null ) return 0;\\n        return dfs(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);\\n    }\\n\\t\\n    static int dfs(TreeNode root,int sum){\\n        if( root == null ) return 0;\\n        int ans = 0;\\n\\t\\tsum -= root.val;\\n        if( sum == 0 ) ans++;\\n        ans += dfs(root.left,sum);\\n        ans += dfs(root.right,sum);\\n        return ans;\\n    }\\n\\t\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int pathSum(TreeNode root, int sum) {\\n        if( root == null ) return 0;\\n        return dfs(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);\\n    }\\n\\t\\n    static int dfs(TreeNode root,int sum){\\n        if( root == null ) return 0;\\n        int ans = 0;\\n\\t\\tsum -= root.val;\\n        if( sum == 0 ) ans++;\\n        ans += dfs(root.left,sum);\\n        ans += dfs(root.right,sum);\\n        return ans;\\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424018,
                "title": "python-iterative-solution",
                "content": "This problem is similar to 560: Subarray Sum Equals K.\\nTo prevent extra copy, use a backtrack flag to control the sum_d .\\n\\n```\\nimport collections\\n\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:     \\n        if not root:\\n            return 0\\n        \\n        target = sum\\n        path_sum_cnt = 0   \\n        sum_d = collections.defaultdict(int)\\n        sum_d[0] = 1\\n        \\n        stack = [(root, 0, False)]\\n        while stack:\\n            node, cur_sum, backtrack = stack.pop()\\n            if backtrack:\\n                sum_d[cur_sum] -= 1\\n                continue\\n              \\n            cur_sum += node.val\\n            # prev_sum + target = cur_sum\\n            path_sum_cnt += sum_d[cur_sum - target]\\n            \\n            sum_d[cur_sum] += 1\\n            stack.append((None, cur_sum, True))\\n            if node.left:\\n                stack.append((node.left, cur_sum, False))\\n                \\n            if node.right:\\n                stack.append((node.right, cur_sum, False))\\n                \\n        return path_sum_cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:     \\n        if not root:\\n            return 0\\n        \\n        target = sum\\n        path_sum_cnt = 0   \\n        sum_d = collections.defaultdict(int)\\n        sum_d[0] = 1\\n        \\n        stack = [(root, 0, False)]\\n        while stack:\\n            node, cur_sum, backtrack = stack.pop()\\n            if backtrack:\\n                sum_d[cur_sum] -= 1\\n                continue\\n              \\n            cur_sum += node.val\\n            # prev_sum + target = cur_sum\\n            path_sum_cnt += sum_d[cur_sum - target]\\n            \\n            sum_d[cur_sum] += 1\\n            stack.append((None, cur_sum, True))\\n            if node.left:\\n                stack.append((node.left, cur_sum, False))\\n                \\n            if node.right:\\n                stack.append((node.right, cur_sum, False))\\n                \\n        return path_sum_cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92004,
                "title": "c-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        int res = 0;\\n        pathSumHelper(root, sum, res, false);\\n        return res;\\n    }\\n    void pathSumHelper(TreeNode* root, int sum, int &res, bool parent_used) {\\n        if (!root)\\n            return;\\n        if (sum - root->val == 0)\\n            res++;\\n        pathSumHelper(root->left, sum - root->val, res, true);\\n        pathSumHelper(root->right, sum - root->val, res, true);\\n        if (parent_used == false) { //if parent is part of the sum, then we cannot start a new path which jump over this node\\n            pathSumHelper(root->left, sum, res, false);\\n            pathSumHelper(root->right, sum, res, false);\\n        }\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        int res = 0;\\n        pathSumHelper(root, sum, res, false);\\n        return res;\\n    }\\n    void pathSumHelper(TreeNode* root, int sum, int &res, bool parent_used) {\\n        if (!root)\\n            return;\\n        if (sum - root->val == 0)\\n            res++;\\n        pathSumHelper(root->left, sum - root->val, res, true);\\n        pathSumHelper(root->right, sum - root->val, res, true);\\n        if (parent_used == false) { //if parent is part of the sum, then we cannot start a new path which jump over this node\\n            pathSumHelper(root->left, sum, res, false);\\n            pathSumHelper(root->right, sum, res, false);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472805,
                "title": "intitutive-c-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->just run dfs on the tree and at every node assume it to be as root node and calculate number of path which has sum equal to targetsum using helper function.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int ans=0;\\n   int helper(TreeNode* root, int targetSum,long long curr)\\n   {\\n       if(root==NULL) return 0;\\n       curr=curr+root->val;\\n       if(curr==targetSum)\\n       {\\n           return 1+helper(root->left,targetSum,curr)+helper(root->right,targetSum,curr);\\n       }\\n       return helper(root->left,targetSum,curr)+helper(root->right,targetSum,curr);\\n   }\\n\\nvoid dfs(TreeNode* root, int targetSum)\\n{\\n   if(root==NULL) return;\\n       ans=ans+helper(root,targetSum,0);\\n       pathSum(root->left,targetSum);\\n       pathSum(root->right,targetSum);\\n}\\n\\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n        dfs(root,targetSum);\\n        return ans;\\n      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int ans=0;\\n   int helper(TreeNode* root, int targetSum,long long curr)\\n   {\\n       if(root==NULL) return 0;\\n       curr=curr+root->val;\\n       if(curr==targetSum)\\n       {\\n           return 1+helper(root->left,targetSum,curr)+helper(root->right,targetSum,curr);\\n       }\\n       return helper(root->left,targetSum,curr)+helper(root->right,targetSum,curr);\\n   }\\n\\nvoid dfs(TreeNode* root, int targetSum)\\n{\\n   if(root==NULL) return;\\n       ans=ans+helper(root,targetSum,0);\\n       pathSum(root->left,targetSum);\\n       pathSum(root->right,targetSum);\\n}\\n\\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n        dfs(root,targetSum);\\n        return ans;\\n      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271820,
                "title": "437-space-93-92-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define the function with the given input parameters: a binary tree root node and an integer targetSum. The function should return an integer representing the number of paths in the tree that sum to the targetSum.\\n\\n2. Create a class variable called count and initialize it to 0. This variable will keep track of the number of paths that sum to the targetSum.\\n\\n3. Create a dictionary called prefix_sum and initialize it with a key-value pair of 0 and 1. This dictionary will keep track of the prefix sum values and the number of times they occur in the path.\\n\\n4. Define a recursive helper function called dfs that takes three parameters: a node in the binary tree, the targetSum, and the current sum of the path. This function will perform a depth-first search on the binary tree.\\n\\n5. If the current node is None, return.\\n\\n6. Add the value of the current node to the current sum.\\n\\n7. Check if the difference between the current sum and the targetSum is present in the prefix_sum dictionary. If it is, add the value of the key to the count variable.\\n\\n8. Add the current sum to the prefix_sum dictionary with a value of 1 if it is not already present. If it is present, increment the value by 1.\\n\\n9. Recursively call the dfs function on the left child of the current node with the updated current sum.\\n\\n10. Recursively call the dfs function on the right child of the current node with the updated current sum.\\n\\n11. Decrement the value of the current sum in the prefix_sum dictionary by 1, as this node is no longer in the path.\\n\\n12. Call the dfs function on the root node with a current sum of 0.\\n\\n13. Return the count variable.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> int:\\n        self.count = 0\\n        self.prefix_sum = {0: 1}\\n        self.dfs(root, targetSum, 0)\\n        return self.count\\n        \\n    def dfs(self, node: TreeNode, targetSum: int, curr_sum: int) -> None:\\n        if not node:\\n            return\\n        \\n        curr_sum += node.val\\n        self.count += self.prefix_sum.get(curr_sum - targetSum, 0)\\n        self.prefix_sum[curr_sum] = self.prefix_sum.get(curr_sum, 0) + 1\\n        \\n        self.dfs(node.left, targetSum, curr_sum)\\n        self.dfs(node.right, targetSum, curr_sum)\\n        \\n        self.prefix_sum[curr_sum] -= 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> int:\\n        self.count = 0\\n        self.prefix_sum = {0: 1}\\n        self.dfs(root, targetSum, 0)\\n        return self.count\\n        \\n    def dfs(self, node: TreeNode, targetSum: int, curr_sum: int) -> None:\\n        if not node:\\n            return\\n        \\n        curr_sum += node.val\\n        self.count += self.prefix_sum.get(curr_sum - targetSum, 0)\\n        self.prefix_sum[curr_sum] = self.prefix_sum.get(curr_sum, 0) + 1\\n        \\n        self.dfs(node.left, targetSum, curr_sum)\\n        self.dfs(node.right, targetSum, curr_sum)\\n        \\n        self.prefix_sum[curr_sum] -= 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525734,
                "title": "c-python-simple-and-easy-dfs-solutions-faster-than-99",
                "content": "**Idea:**\\nWe keep the prefix sums in a hashmap and then in each stage we can check if we have `prev_sum - target`, which means that we got a path sum equals `target`.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int target, int prev_sum) {\\n        if (!root) return;\\n        prev_sum += root->val;\\n        \\n        res += prefix[prev_sum - target];\\n        \\n        prefix[prev_sum]++;\\n        \\n        dfs(root->left, target, prev_sum);\\n        dfs(root->right, target, prev_sum);\\n        \\n        prefix[prev_sum]--;\\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        prefix[0]++;\\n        dfs(root, targetSum, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    unordered_map<int, int> prefix;\\n    int res = 0;\\n};\\n```\\n****\\n**Python:**\\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        prefix = defaultdict(int)\\n        prefix[0] = 1\\n        self.res = 0\\n        \\n        def dfs(root:TreeNode, target:int, prev_sum:int):\\n            if not root:\\n                return\\n            \\n            prev_sum += root.val\\n            self.res += prefix[prev_sum - target]\\n            prefix[prev_sum] += 1\\n            \\n            dfs(root.left, target, prev_sum)\\n            dfs(root.right, target, prev_sum)\\n            \\n            prefix[prev_sum] -= 1\\n            \\n        dfs(root, sum, 0)\\n        return self.res\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int target, int prev_sum) {\\n        if (!root) return;\\n        prev_sum += root->val;\\n        \\n        res += prefix[prev_sum - target];\\n        \\n        prefix[prev_sum]++;\\n        \\n        dfs(root->left, target, prev_sum);\\n        dfs(root->right, target, prev_sum);\\n        \\n        prefix[prev_sum]--;\\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        prefix[0]++;\\n        dfs(root, targetSum, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    unordered_map<int, int> prefix;\\n    int res = 0;\\n};\\n```\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        prefix = defaultdict(int)\\n        prefix[0] = 1\\n        self.res = 0\\n        \\n        def dfs(root:TreeNode, target:int, prev_sum:int):\\n            if not root:\\n                return\\n            \\n            prev_sum += root.val\\n            self.res += prefix[prev_sum - target]\\n            prefix[prev_sum] += 1\\n            \\n            dfs(root.left, target, prev_sum)\\n            dfs(root.right, target, prev_sum)\\n            \\n            prefix[prev_sum] -= 1\\n            \\n        dfs(root, sum, 0)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91916,
                "title": "concise-javascript-o-n-solution-using-map",
                "content": "```\\nvar pathSum = function(root, sum, presums = { '0': 1 }, prev = 0) {\\n    if (!root) return 0;\\n    let curr = prev + root.val;\\n    presums[curr] = (presums[curr] || 0) + 1;\\n    let res = (presums[curr - sum] || 0) - !sum;\\n    res += pathSum(root.left, sum, presums, curr) + pathSum(root.right, sum, presums, curr);\\n    presums[curr]--;\\n    return res;\\n};\\n```\\nThis turns out to be the same as @tankztc's solution [here](https://discuss.leetcode.com/topic/64526/17-ms-o-n-java-prefix-sum-method), though I was inspired by backtracking problems since we \"backtrack\" on the prefix sums.\\n\\nFor a balanced tree we use O(log n) space, otherwise as bad as O(n). Also, I think the \"easy\" categorization should be changed to \"pain in the...\" :P.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pathSum = function(root, sum, presums = { '0': 1 }, prev = 0) {\\n    if (!root) return 0;\\n    let curr = prev + root.val;\\n    presums[curr] = (presums[curr] || 0) + 1;\\n    let res = (presums[curr - sum] || 0) - !sum;\\n    res += pathSum(root.left, sum, presums, curr) + pathSum(root.right, sum, presums, curr);\\n    presums[curr]--;\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91958,
                "title": "12-line-python-o-n-guaranteed",
                "content": "Just copy the code from another problem Maximum size subarray sum which is solved by an O(N) algorithm.\\n\\n```\\nclass Solution(object):\\n    def pathSum(self, root, target):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        self.count = 0\\n        preDict = {0: 1}\\n        def dfs(p, target, pathSum, preDict):\\n            if p:\\n                pathSum += p.val\\n                self.count += preDict.get(pathSum - target, 0)\\n                preDict[pathSum] = preDict.get(pathSum, 0) + 1\\n                dfs(p.left, target, pathSum, preDict)\\n                dfs(p.right, target, pathSum, preDict)\\n                preDict[pathSum] -= 1\\n        dfs(root, target, 0, preDict)\\n        return self.count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pathSum(self, root, target):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        self.count = 0\\n        preDict = {0: 1}\\n        def dfs(p, target, pathSum, preDict):\\n            if p:\\n                pathSum += p.val\\n                self.count += preDict.get(pathSum - target, 0)\\n                preDict[pathSum] = preDict.get(pathSum, 0) + 1\\n                dfs(p.left, target, pathSum, preDict)\\n                dfs(p.right, target, pathSum, preDict)\\n                preDict[pathSum] -= 1\\n        dfs(root, target, 0, preDict)\\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658840,
                "title": "java-pass-new-test-case-with-dfs-map-o-n",
                "content": "New test case:\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\nJust change the type of key from Integer to Long\\n\\n```java\\n    public int pathSum(TreeNode root, int targetSum) {\\n        Map<Long, Integer> map = new HashMap<>();\\n        map.put(0L, 1);\\n        return helper(root, (long) targetSum, 0, map);\\n    }\\n\\n    private int helper(TreeNode node, long targetSum, long preSum, Map<Long, Integer> map) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        preSum += node.val;\\n        int res = map.getOrDefault(preSum - targetSum, 0);\\n        map.put(preSum, map.getOrDefault(preSum, 0) + 1);\\n        res += helper(node.left, targetSum, preSum, map) + helper(node.right, targetSum, preSum, map);\\n        map.put(preSum, map.get(preSum) - 1);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```java\\n    public int pathSum(TreeNode root, int targetSum) {\\n        Map<Long, Integer> map = new HashMap<>();\\n        map.put(0L, 1);\\n        return helper(root, (long) targetSum, 0, map);\\n    }\\n\\n    private int helper(TreeNode node, long targetSum, long preSum, Map<Long, Integer> map) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        preSum += node.val;\\n        int res = map.getOrDefault(preSum - targetSum, 0);\\n        map.put(preSum, map.getOrDefault(preSum, 0) + 1);\\n        res += helper(node.left, targetSum, preSum, map) + helper(node.right, targetSum, preSum, map);\\n        map.put(preSum, map.get(preSum) - 1);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745666,
                "title": "explanation-detailed-javascript-solution",
                "content": "```\\n/**\\n * DFS - Preorder\\n * \\n * pathSum: sum of all values from current node to root\\n * map(pathSum - targetSum): frequency of targetSum in the path (up to current node)\\n * \\n * Case 1: valid tree path sum that starts from the root node\\n *          - pathSum === targetSum\\n *             => increment output by 1\\n * Case 2: valid tree path sum that starts middle of the tree\\n *          - check for frequency of target sum in the current path\\n *             * if True, it means that we found targetSum \\n *                * map[pathSum - targetSum] number of times\\n *             => increment output by frequency of map(pathSum - targetSum)\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 134 ms, faster than 51.52% of JavaScript online submissions for Path Sum III.\\n// Memory Usage: 47.5 MB, less than 12.82% of JavaScript online submissions for Path Sum III.\\nconst pathSum = (root, targetSum) => {\\n\\tlet output = 0;\\n\\tlet map = {};\\n\\n\\tconst traverse = (root, pathSum) => {\\n\\t\\tif (!root) return null;\\n\\n\\t\\tpathSum += root.val; // current path sum\\n\\n\\t\\t// Case 1: starts from root node\\n\\t\\tif (pathSum === targetSum) output++;\\n\\n\\t\\t// Case 2: starts from middle of tree\\n\\t\\t// frequency of targetSum in the current path (up to current node)\\n\\t\\tif (map[pathSum - targetSum]) output += map[pathSum - targetSum];\\n\\n\\t\\t// memoize current path sum (root to current node) and it\\'s frequency\\n\\t\\tif (map[pathSum]) map[pathSum]++;\\n\\t\\telse map[pathSum] = 1;\\n\\n\\t\\tif (root.left) traverse(root.left, pathSum);\\n\\t\\tif (root.right) traverse(root.right, pathSum);\\n\\n\\t\\t// remove the current path sum\\n\\t\\t// to note that path is not available/visited\\n\\t\\tmap[pathSum]--;\\n\\t};\\n\\n\\ttraverse(root, 0);\\n\\treturn output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * DFS - Preorder\\n * \\n * pathSum: sum of all values from current node to root\\n * map(pathSum - targetSum): frequency of targetSum in the path (up to current node)\\n * \\n * Case 1: valid tree path sum that starts from the root node\\n *          - pathSum === targetSum\\n *             => increment output by 1\\n * Case 2: valid tree path sum that starts middle of the tree\\n *          - check for frequency of target sum in the current path\\n *             * if True, it means that we found targetSum \\n *                * map[pathSum - targetSum] number of times\\n *             => increment output by frequency of map(pathSum - targetSum)\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 134 ms, faster than 51.52% of JavaScript online submissions for Path Sum III.\\n// Memory Usage: 47.5 MB, less than 12.82% of JavaScript online submissions for Path Sum III.\\nconst pathSum = (root, targetSum) => {\\n\\tlet output = 0;\\n\\tlet map = {};\\n\\n\\tconst traverse = (root, pathSum) => {\\n\\t\\tif (!root) return null;\\n\\n\\t\\tpathSum += root.val; // current path sum\\n\\n\\t\\t// Case 1: starts from root node\\n\\t\\tif (pathSum === targetSum) output++;\\n\\n\\t\\t// Case 2: starts from middle of tree\\n\\t\\t// frequency of targetSum in the current path (up to current node)\\n\\t\\tif (map[pathSum - targetSum]) output += map[pathSum - targetSum];\\n\\n\\t\\t// memoize current path sum (root to current node) and it\\'s frequency\\n\\t\\tif (map[pathSum]) map[pathSum]++;\\n\\t\\telse map[pathSum] = 1;\\n\\n\\t\\tif (root.left) traverse(root.left, pathSum);\\n\\t\\tif (root.right) traverse(root.right, pathSum);\\n\\n\\t\\t// remove the current path sum\\n\\t\\t// to note that path is not available/visited\\n\\t\\tmap[pathSum]--;\\n\\t};\\n\\n\\ttraverse(root, 0);\\n\\treturn output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780095,
                "title": "python-easy-dfs-solution-using-prefix-sum-approach",
                "content": "This problem can be solved by applying same approach as [problem 560](https://leetcode.com/problems/subarray-sum-equals-k/) which used prefix-sum method. Both the solutions are given below.\\n\\n**Problem 437 : [Path Sum III](https://leetcode.com/problems/path-sum-iii/)**\\n\\n```python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        if not root:\\n            return 0\\n        \\n        # Recursive DFS\\n\\t\\t# Using Prefix Sum approach\\n        \\n        def dfs(node, curr_sum, sum):\\n            if not node:\\n                return 0\\n            \\n            res = 0\\n            curr_sum += node.val\\n            \\n            if (curr_sum - sum) in mapping:\\n                res += mapping[curr_sum - sum]\\n            if curr_sum in mapping:\\n                mapping[curr_sum] += 1\\n            else:\\n                mapping[curr_sum] = 1\\n                \\n            res += dfs(node.left, curr_sum, sum)\\n            res += dfs(node.right, curr_sum, sum)\\n            mapping[curr_sum] -= 1\\n            \\n            return res\\n            \\n        mapping = defaultdict(int)\\n        mapping[0] = 1\\n        return dfs(root, 0, sum)\\n        \\t\\t\\n```\\n\\n\\n**Problem 560 : [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)**\\n\\n```python\\nclass Solution:\\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        # Time Complexity - O(n)\\n        # Space Complexity - O(n)\\n        curr_sum = res = 0\\n        mapping = defaultdict(int)\\n        for i in nums:\\n            curr_sum += i\\n            if (curr_sum - k) in mapping:\\n                res += mapping[curr_sum - k]\\n            mapping[curr_sum] += 1\\n        res += mapping[k]\\n        return res\\n        \\t\\t\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Prefix Sum"
                ],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        if not root:\\n            return 0\\n        \\n        # Recursive DFS\\n\\t\\t# Using Prefix Sum approach\\n        \\n        def dfs(node, curr_sum, sum):\\n            if not node:\\n                return 0\\n            \\n            res = 0\\n            curr_sum += node.val\\n            \\n            if (curr_sum - sum) in mapping:\\n                res += mapping[curr_sum - sum]\\n            if curr_sum in mapping:\\n                mapping[curr_sum] += 1\\n            else:\\n                mapping[curr_sum] = 1\\n                \\n            res += dfs(node.left, curr_sum, sum)\\n            res += dfs(node.right, curr_sum, sum)\\n            mapping[curr_sum] -= 1\\n            \\n            return res\\n            \\n        mapping = defaultdict(int)\\n        mapping[0] = 1\\n        return dfs(root, 0, sum)\\n        \\t\\t\\n```\n```python\\nclass Solution:\\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        # Time Complexity - O(n)\\n        # Space Complexity - O(n)\\n        curr_sum = res = 0\\n        mapping = defaultdict(int)\\n        for i in nums:\\n            curr_sum += i\\n            if (curr_sum - k) in mapping:\\n                res += mapping[curr_sum - k]\\n            mapping[curr_sum] += 1\\n        res += mapping[k]\\n        return res\\n        \\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482336,
                "title": "javascript-dfs-straightforward-two-methods",
                "content": "```\\nvar pathSum = function(root, sum) {\\n    let res = 0;\\n    const helper = (root, sum) => {\\n        if(!root) return;\\n        sum -= root.val;\\n        if(sum === 0){\\n            res++;\\n        }\\n        helper(root.left, sum);\\n        helper(root.right, sum);\\n    }\\n    const main = (root, sum) => {\\n        if(!root) return 0;\\n        helper(root, sum);\\n        main(root.left, sum);\\n        main(root.right, sum);\\n        return ;\\n    }\\n    main(root, sum);\\n    return res;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar pathSum = function(root, sum) {\\n    let res = 0;\\n    const helper = (root, sum) => {\\n        if(!root) return;\\n        sum -= root.val;\\n        if(sum === 0){\\n            res++;\\n        }\\n        helper(root.left, sum);\\n        helper(root.right, sum);\\n    }\\n    const main = (root, sum) => {\\n        if(!root) return 0;\\n        helper(root, sum);\\n        main(root.left, sum);\\n        main(root.right, sum);\\n        return ;\\n    }\\n    main(root, sum);\\n    return res;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 268961,
                "title": "java-dfs-easy-understanding",
                "content": "```\\nclass Solution {\\n    private int cnt;\\n    \\n    public int pathSum(TreeNode root, int sum) {\\n        cnt = 0;\\n        find(root, sum);\\n        return cnt;\\n    }\\n    \\n    private void find(TreeNode root, int sum) {\\n        if (root == null) return;\\n        path(root, sum);\\n        find(root.left, sum);\\n        find(root.right, sum);\\n    }\\n    \\n    private void path(TreeNode root, int sum) {\\n        if (root == null) return;\\n        if (sum - root.val == 0) cnt++;\\n        path(root.left, sum - root.val);\\n        path(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int cnt;\\n    \\n    public int pathSum(TreeNode root, int sum) {\\n        cnt = 0;\\n        find(root, sum);\\n        return cnt;\\n    }\\n    \\n    private void find(TreeNode root, int sum) {\\n        if (root == null) return;\\n        path(root, sum);\\n        find(root.left, sum);\\n        find(root.right, sum);\\n    }\\n    \\n    private void path(TreeNode root, int sum) {\\n        if (root == null) return;\\n        if (sum - root.val == 0) cnt++;\\n        path(root.left, sum - root.val);\\n        path(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222224,
                "title": "c-simple-solution-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode *root,int targetSum,vector<int> &sum,int &c)\\n    {\\n        if(!root)\\n            return;\\n        sum.push_back(root->val);\\n        long long int csum=0;\\n        for(int i=sum.size()-1;i>=0;i--)\\n        {\\n            csum+=sum[i];\\n            if(csum==targetSum)\\n                c++;\\n        }\\n        solve(root->left,targetSum,sum,c);\\n        solve(root->right,targetSum,sum,c);\\n        sum.pop_back();\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        int c=0;\\n        vector<int> sum;\\n        solve(root,targetSum,sum,c);\\n        return c;\\n    }\\n};\\n```\\n**IF YOU LIKE IT , DO UPVOTE**\\n**HAPPY CODING;**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode *root,int targetSum,vector<int> &sum,int &c)\\n    {\\n        if(!root)\\n            return;\\n        sum.push_back(root->val);\\n        long long int csum=0;\\n        for(int i=sum.size()-1;i>=0;i--)\\n        {\\n            csum+=sum[i];\\n            if(csum==targetSum)\\n                c++;\\n        }\\n        solve(root->left,targetSum,sum,c);\\n        solve(root->right,targetSum,sum,c);\\n        sum.pop_back();\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        int c=0;\\n        vector<int> sum;\\n        solve(root,targetSum,sum,c);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945903,
                "title": "python-recursive",
                "content": "helper: return the path starts from the root and has path sum = target. \\n\\nThe paths that have path_sum = target can only be \\n1. Paths start from root;\\n2. Paths inside the left subtree of root;\\n3. Paths inside the right subtree of root;\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        if root:\\n            c = self.helper(root, sum) # start from the root\\n            l = self.pathSum(root.left, sum) # inside the left subtree\\n            r = self.pathSum(root.right, sum) # inside the right subtree\\n            return c + l + r\\n        return 0 \\n        \\n    def helper(self, root, sum): \\n        if root:\\n            l = self.helper(root.left, sum - root.val)\\n            r = self.helper(root.right, sum - root.val)\\n            return l + r  +  (root.val == sum)\\n        return 0 \\n          \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        if root:\\n            c = self.helper(root, sum) # start from the root\\n            l = self.pathSum(root.left, sum) # inside the left subtree\\n            r = self.pathSum(root.right, sum) # inside the right subtree\\n            return c + l + r\\n        return 0 \\n        \\n    def helper(self, root, sum): \\n        if root:\\n            l = self.helper(root.left, sum - root.val)\\n            r = self.helper(root.right, sum - root.val)\\n            return l + r  +  (root.val == sum)\\n        return 0 \\n          \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779663,
                "title": "java-100-faster-hashmap-cumulative-sum",
                "content": "This is similar to finding subarray sum equal to target. \\n![image](https://assets.leetcode.com/users/images/fe07abf7-6531-4998-bdd8-9c842aacc5d0_1596892479.6344945.png)\\nIn this example, different arrays are paths from root to all leaves\\n```\\n[10,5,3,3]\\n[10,5,3,-2]\\n[10,5,2,1]\\n[10,-3,11]\\n```\\n\\nInstead of storing all the subarrays, we just calculate the cumulative sum from root to that node using **cSum**. Also, keep track of all the sums seen so far from root to that node in hashmap **map**. The hashmap stores the sum seen so far and the count (how many times that sum is found).\\nAfter traversing left and right subtrees, we have to backtrack by reduce count from hashmap.\\n\\n```\\nclass Solution {\\n    int result;\\n    public int pathSum(TreeNode root, int sum) {\\n        HashMap map = new HashMap<Integer,Integer>();\\n      \\n        result = 0;\\n        map.put(0,1);\\n        pathSumUtil(map,root,0,sum);\\n        return result;\\n    }\\n    \\n    void pathSumUtil(HashMap<Integer,Integer> map, TreeNode root,int cSum,int sum){\\n        if(root == null)\\n            return;\\n\\t\\t// calculate cumulative sum\\n        int temp = cSum+root.val;\\n        if(map.containsKey(temp-sum))\\n            result+= map.get(temp-sum);\\n        \\n\\t\\t// add the sum seen so far in hashmap\\n        map.put(temp,map.getOrDefault(temp,0)+1);\\n        // recur for left and right subtrees \\n        if(root.left != null) pathSumUtil(map,root.left,cSum+root.val,sum);\\n        if(root.right != null) pathSumUtil(map,root.right,cSum+root.val,sum);\\n\\t\\t// backtrack\\n        map.put(temp,map.get(temp)-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[10,5,3,3]\\n[10,5,3,-2]\\n[10,5,2,1]\\n[10,-3,11]\\n```\n```\\nclass Solution {\\n    int result;\\n    public int pathSum(TreeNode root, int sum) {\\n        HashMap map = new HashMap<Integer,Integer>();\\n      \\n        result = 0;\\n        map.put(0,1);\\n        pathSumUtil(map,root,0,sum);\\n        return result;\\n    }\\n    \\n    void pathSumUtil(HashMap<Integer,Integer> map, TreeNode root,int cSum,int sum){\\n        if(root == null)\\n            return;\\n\\t\\t// calculate cumulative sum\\n        int temp = cSum+root.val;\\n        if(map.containsKey(temp-sum))\\n            result+= map.get(temp-sum);\\n        \\n\\t\\t// add the sum seen so far in hashmap\\n        map.put(temp,map.getOrDefault(temp,0)+1);\\n        // recur for left and right subtrees \\n        if(root.left != null) pathSumUtil(map,root.left,cSum+root.val,sum);\\n        if(root.right != null) pathSumUtil(map,root.right,cSum+root.val,sum);\\n\\t\\t// backtrack\\n        map.put(temp,map.get(temp)-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779413,
                "title": "path-sum-iii-dfs-dynamic-prefix-sum-o-n-time",
                "content": "This problem is similar to finding number of subarrays having s.\\nHere we have to find number of paths(defined as from any node to it\\'s succesor) having sum s.\\n\\nWe can maintain all prefix sums from root node to current node in hashmap while traversing the tree in dfs, and we need to remove the prefix sum accounted by \\'node\\' when we return as this prefix sum should not exist for other paths.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int pathSum(TreeNode* root, int sum) {\\n        \\n        unordered_map<int, int> map;\\n        return dfs(root, 0, sum, map);\\n\\t}\\n    \\n    int dfs(TreeNode *node, int root_to_par, int s, unordered_map<int, int> &map) {\\n        if(!node)\\n            return 0;\\n        \\n        int root_to_node = root_to_par + node->val;\\n        \\n        // stores the count of number of paths having sum = s and ending on current node in dfs()\\n        int num_paths_ending_on_node = map[root_to_node - s] + (root_to_node == s ? 1 : 0);  \\n        \\n        map[root_to_node] += 1;\\n        \\n        int left  =  dfs(node->left,  root_to_node, s, map);\\n        int right =  dfs(node->right, root_to_node, s, map);\\n        \\n        map[root_to_node] -= 1; \\n        \\n        return num_paths_ending_on_node + left + right;\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int pathSum(TreeNode* root, int sum) {\\n        \\n        unordered_map<int, int> map;\\n        return dfs(root, 0, sum, map);\\n\\t}\\n    \\n    int dfs(TreeNode *node, int root_to_par, int s, unordered_map<int, int> &map) {\\n        if(!node)\\n            return 0;\\n        \\n        int root_to_node = root_to_par + node->val;\\n        \\n        // stores the count of number of paths having sum = s and ending on current node in dfs()\\n        int num_paths_ending_on_node = map[root_to_node - s] + (root_to_node == s ? 1 : 0);  \\n        \\n        map[root_to_node] += 1;\\n        \\n        int left  =  dfs(node->left,  root_to_node, s, map);\\n        int right =  dfs(node->right, root_to_node, s, map);\\n        \\n        map[root_to_node] -= 1; \\n        \\n        return num_paths_ending_on_node + left + right;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779392,
                "title": "c-explained-clean-code-same-problem-as-leetcode-560-o-n-o-n",
                "content": "If you notice that this problem is the same as the \\'Subarray Sum Equals K\\' one, then the solution becomes trivial. Instead of searching for subarrays with the given sum in an array, we search for subpaths in our tree.\\nIf you, however, either don\\'t know the \\'Subarray Sum Equals K\\' problem, or you don\\'t observe the trick, read my explanation. \\n```\\nclass Solution {\\npublic:\\n    int nr = 0;                                               // This is our answer\\n    void dfs(TreeNode *node, int s, unordered_map <int, int> di, int sum) {\\n        if (!node) return;                                    // If we don\\'t have any nodes in our path, we leave the recursion\\n        s += node->val;                                       // Every time we have a node with a value, we add its value to our \\'s\\'\\n        nr += di[s - sum];                                    // Our map maintains how many times we\\'ve already got a specific sum (left pointer). \\'s\\' is the right pointer. If we\\'ve got a left pointer with the value \\'s - sum\\', then we have a subpath with the sum \\'s - (s - sum)\\' = \\'sum\\', which is what we need\\n        di[s] ++;                                             // Increase the number of left pointers which have the sum \\'s\\'\\n        dfs(node->left , s, di, sum);                         // Continue our path to the left\\n        dfs(node->right, s, di, sum);                         // Continue our path to the right\\n    }\\n    int pathSum(TreeNode* root, int sum) {\\n        dfs(root, 0, unordered_map <int, int> {{0, 1}}, sum); // We run a dfs from the root; See \\'P.s.\\' for the \\'unordered_map <int, int> {{0, 1}}\\' part\\n        return nr;                                            // return answer\\n    }\\n};\\n```\\nP.s. Let us take an example with a tree which has only one node with value equal to our target sum. Its clear that the answer should be 1, where we take our node to our path. The pair {0, 1} from our map creates a left pointer for such cases. In other words, we create a dummy node before our root with a value 0. You can check that \\'dfs(new TreeNode(0, root, NULL), 0, unordered_map <int, int> {}, sum);\\' also works.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nr = 0;                                               // This is our answer\\n    void dfs(TreeNode *node, int s, unordered_map <int, int> di, int sum) {\\n        if (!node) return;                                    // If we don\\'t have any nodes in our path, we leave the recursion\\n        s += node->val;                                       // Every time we have a node with a value, we add its value to our \\'s\\'\\n        nr += di[s - sum];                                    // Our map maintains how many times we\\'ve already got a specific sum (left pointer). \\'s\\' is the right pointer. If we\\'ve got a left pointer with the value \\'s - sum\\', then we have a subpath with the sum \\'s - (s - sum)\\' = \\'sum\\', which is what we need\\n        di[s] ++;                                             // Increase the number of left pointers which have the sum \\'s\\'\\n        dfs(node->left , s, di, sum);                         // Continue our path to the left\\n        dfs(node->right, s, di, sum);                         // Continue our path to the right\\n    }\\n    int pathSum(TreeNode* root, int sum) {\\n        dfs(root, 0, unordered_map <int, int> {{0, 1}}, sum); // We run a dfs from the root; See \\'P.s.\\' for the \\'unordered_map <int, int> {{0, 1}}\\' part\\n        return nr;                                            // return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455838,
                "title": "java-dfs-solution",
                "content": "```\\n\\tpublic int pathSum(TreeNode root, int sum) {\\n        if(root == null) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\treturn pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);\\n    }\\n\\t\\n\\tprivate int pathSumFrom(TreeNode root, int sum) {\\n\\t\\tif(root == null) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint s = pathSumFrom(root.left, sum-root.val) + pathSumFrom(root.right, sum-root.val);\\n\\t\\tif(root.val == sum) {\\n\\t\\t\\ts++;\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int pathSum(TreeNode root, int sum) {\\n        if(root == null) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\treturn pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);\\n    }\\n\\t\\n\\tprivate int pathSumFrom(TreeNode root, int sum) {\\n\\t\\tif(root == null) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint s = pathSumFrom(root.left, sum-root.val) + pathSumFrom(root.right, sum-root.val);\\n\\t\\tif(root.val == sum) {\\n\\t\\t\\ts++;\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293247,
                "title": "java-double-100-solution-using-prefix-travsersing-hashmap",
                "content": "For an array [2, -1, 3, -2, 1], given the targer value tar = 1, if you were asked to find out all subarrays whose sum equals to tar, what will you do?\\nThe basic idea is that, let sum[i] be the sum of elements from 0 to i; Then sum[j] - sum[i] is the sum of elements from i to j; if sum[j] - sum[i] = tar, then the subarray of [i, j] is one of the expected array. If you store sum[i] in a HashMap with key sum[i] and  frequence f, every time you estimate new sum[j], you just need to check if the HashMap contains the key sum[j] - tar, if it does, then we will have f different ways to get the tar.\\nApplying the same idea to tree. By using prefix travsering, we can regrard the tree as an array.\\n```java\\nclass Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        return pathSum(root, 0, sum, map);\\n    }\\n    private int pathSum(TreeNode root, int curSum, int sum, HashMap<Integer, Integer> map) {\\n        if (root == null) return 0;\\n        curSum += root.val;\\n        int res = map.getOrDefault(curSum - sum, 0);\\n        map.put(curSum, map.getOrDefault(curSum, 0) + 1);\\n        res += pathSum(root.left, curSum, sum, map) + pathSum(root.right, curSum, sum, map);\\n        map.put(curSum, map.get(curSum) - 1);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        return pathSum(root, 0, sum, map);\\n    }\\n    private int pathSum(TreeNode root, int curSum, int sum, HashMap<Integer, Integer> map) {\\n        if (root == null) return 0;\\n        curSum += root.val;\\n        int res = map.getOrDefault(curSum - sum, 0);\\n        map.put(curSum, map.getOrDefault(curSum, 0) + 1);\\n        res += pathSum(root.left, curSum, sum, map) + pathSum(root.right, curSum, sum, map);\\n        map.put(curSum, map.get(curSum) - 1);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046844,
                "title": "simple-compact-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck for left and right subtree and keep decrementing target sum\\nand if root->data equal to target sum then c++.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo recursive call for all the nodes and check how many times target sum will occur . \\n - Note : take sum as long long to avoid integer overflow\\n\\n# Complexity\\n- Time complexity:O(N^2) in wrost\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\nint c=0;\\n  \\n   void getPath(TreeNode * root ,long long int sum){\\n       if(!root)return ;\\n      if(root->val==sum)c++;\\n      getPath(root->left,sum-root->val);\\n      getPath(root->right,sum-root->val);\\n     \\n   }\\n    int pathSum(TreeNode* root, int t) {\\n      if(!root)return 0;\\n      getPath(root,(long long)t);\\n      pathSum(root->left,t);\\n      pathSum(root->right,t);\\n      return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nint c=0;\\n  \\n   void getPath(TreeNode * root ,long long int sum){\\n       if(!root)return ;\\n      if(root->val==sum)c++;\\n      getPath(root->left,sum-root->val);\\n      getPath(root->right,sum-root->val);\\n     \\n   }\\n    int pathSum(TreeNode* root, int t) {\\n      if(!root)return 0;\\n      getPath(root,(long long)t);\\n      pathSum(root->left,t);\\n      pathSum(root->right,t);\\n      return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935770,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    unordered_map<long, int> mp;\\n    void dfs(TreeNode* root, int target, long sum)\\n    {\\n        if(root)\\n        {\\n            sum+=root->val;\\n            if(mp.find(sum-target)!=mp.end())\\n                ans+=mp[sum-target];\\n            mp[sum]++;\\n            dfs(root->left, target, sum);\\n            dfs(root->right, target, sum);\\n            mp[sum]--;\\n        }\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        ans=0;\\n        mp[0]=1;\\n        dfs(root, targetSum, 0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    unordered_map<long, int> mp;\\n    void dfs(TreeNode* root, int target, long sum)\\n    {\\n        if(root)\\n        {\\n            sum+=root->val;\\n            if(mp.find(sum-target)!=mp.end())\\n                ans+=mp[sum-target];\\n            mp[sum]++;\\n            dfs(root->left, target, sum);\\n            dfs(root->right, target, sum);\\n            mp[sum]--;\\n        }\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        ans=0;\\n        mp[0]=1;\\n        dfs(root, targetSum, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839880,
                "title": "2-ms-faster-than-100-00-java-hashmap-o-n-prefix-sum",
                "content": "```\\nclass Solution {\\n\\n    public int pathSum(TreeNode root, int targetSum) {\\n        int[] ans = new int[1];\\n        Map<Integer,Integer> map = new HashMap<>(); // to store all prefix sum\\n        map.put(0,1); // to handle case where currSum == target\\n        traverse(root,0,map,ans,targetSum);\\n        return ans[0];\\n \\n    }\\n    \\n    public void traverse(TreeNode root, int currSum, Map<Integer,Integer> map, int[] ans, int targetSum){\\n        if(root == null)\\n            return;\\n        currSum+=root.val;\\n        \\n        if(map.containsKey(currSum - targetSum) && map.get(currSum - targetSum) > 0)\\n            ans[0]+=map.get(currSum - targetSum);\\n        map.put(currSum,map.getOrDefault(currSum,0)+1);\\n        traverse(root.left, currSum, map, ans,targetSum);\\n        traverse(root.right, currSum, map, ans, targetSum);\\n        map.put(currSum,map.getOrDefault(currSum,0)-1); // backtrack\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int pathSum(TreeNode root, int targetSum) {\\n        int[] ans = new int[1];\\n        Map<Integer,Integer> map = new HashMap<>(); // to store all prefix sum\\n        map.put(0,1); // to handle case where currSum == target\\n        traverse(root,0,map,ans,targetSum);\\n        return ans[0];\\n \\n    }\\n    \\n    public void traverse(TreeNode root, int currSum, Map<Integer,Integer> map, int[] ans, int targetSum){\\n        if(root == null)\\n            return;\\n        currSum+=root.val;\\n        \\n        if(map.containsKey(currSum - targetSum) && map.get(currSum - targetSum) > 0)\\n            ans[0]+=map.get(currSum - targetSum);\\n        map.put(currSum,map.getOrDefault(currSum,0)+1);\\n        traverse(root.left, currSum, map, ans,targetSum);\\n        traverse(root.right, currSum, map, ans, targetSum);\\n        map.put(currSum,map.getOrDefault(currSum,0)-1); // backtrack\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135579,
                "title": "simple-solution-in-o-n-time-complexity-in-c-using-pre-fix-sum-and-hashmap",
                "content": "Method : Prefix Sum in a Hasmap\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\nExplanation:\\nA prefix sum can be used to get continous sums between 2 indices in an array in O(1) time (given we know the indices). A similar concept can be used here to get continous sums between nodes.\\n1. We maintain curr_sum, which is the running sum of the nodes encountered from the root(actual root) to the current node.\\n2. We keep storing this sum in a Hashmap Times, representing the number of times we have encountered a branch with sum curr_sum.\\n3. Then we check if we have a branch that if we subtract from our current branch that will give us the sum \"*sum*\". This can be done by checking times[curr_sum - sum] and adding that count to *count* variable.\\n4. After that we can solve for the left and right nodes.\\n5. After returning from the subtrees, we must decrement the times[curr_sum]. This step is the **backtracking** step. \\n5. We must initialize the hashmap times[0] = 1, as if we encounter a branch that originates from root and has sum == *sum*, then count should be increased by 1.\\n\\nC++ code is as follows\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> times;\\n    int count = 0;\\n    void solve(TreeNode* root, int curr_sum, int sum){\\n        if(root == NULL) return;\\n        curr_sum += root->val;\\n        count += times[curr_sum - sum];\\n        times[curr_sum]++;\\n        solve(root->left, curr_sum, sum);\\n        solve(root->right, curr_sum, sum);\\n        times[curr_sum]--;\\n        return;\\n    }\\n    \\n    int pathSum(TreeNode* root, int sum) {\\n        times[0] = 1;\\n        solve(root, 0, sum);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> times;\\n    int count = 0;\\n    void solve(TreeNode* root, int curr_sum, int sum){\\n        if(root == NULL) return;\\n        curr_sum += root->val;\\n        count += times[curr_sum - sum];\\n        times[curr_sum]++;\\n        solve(root->left, curr_sum, sum);\\n        solve(root->right, curr_sum, sum);\\n        times[curr_sum]--;\\n        return;\\n    }\\n    \\n    int pathSum(TreeNode* root, int sum) {\\n        times[0] = 1;\\n        solve(root, 0, sum);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495646,
                "title": "javascript-recursion",
                "content": "```\\n/**\\n * @param {TreeNode} root\\n * @param {number} sum\\n * @return {number}\\n */\\nvar pathSum = function(root, sum) {\\n  if (!root) return 0;\\n  return (\\n    pathSumOnlyStart(root, sum) +\\n    pathSum(root.left, sum) +\\n    pathSum(root.right, sum)\\n  );\\n};\\n\\nconst pathSumOnlyStart = (root, sum) => {\\n  if (!root) return 0;\\n  const self = root.val === sum ? 1 : 0;\\n  return (\\n    self +\\n    pathSumOnlyStart(root.left, sum - root.val) +\\n    pathSumOnlyStart(root.right, sum - root.val)\\n  );\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @param {number} sum\\n * @return {number}\\n */\\nvar pathSum = function(root, sum) {\\n  if (!root) return 0;\\n  return (\\n    pathSumOnlyStart(root, sum) +\\n    pathSum(root.left, sum) +\\n    pathSum(root.right, sum)\\n  );\\n};\\n\\nconst pathSumOnlyStart = (root, sum) => {\\n  if (!root) return 0;\\n  const self = root.val === sum ? 1 : 0;\\n  return (\\n    self +\\n    pathSumOnlyStart(root.left, sum - root.val) +\\n    pathSumOnlyStart(root.right, sum - root.val)\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 398148,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 16 ms, faster than 61.39% of Go online submissions for Path Sum III.\\nMemory Usage: 4.3 MB, less than 100.00% of Go online submissions for Path Sum III.\\n\\n```go\\nfunc pathSum(root *TreeNode, sum int) int {\\n    if root == nil { return 0 }\\n    return helper(root, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum)\\n}\\n\\nfunc helper(root *TreeNode, sum int) int {\\n    count := 0\\n    if root == nil { return 0 }\\n    if root.Val == sum { count++ }\\n    return count + helper(root.Left, sum - root.Val) + helper(root.Right, sum - root.Val)\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc pathSum(root *TreeNode, sum int) int {\\n    if root == nil { return 0 }\\n    return helper(root, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum)\\n}\\n\\nfunc helper(root *TreeNode, sum int) int {\\n    count := 0\\n    if root == nil { return 0 }\\n    if root.Val == sum { count++ }\\n    return count + helper(root.Left, sum - root.Val) + helper(root.Right, sum - root.Val)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 318343,
                "title": "o-n-java-solution",
                "content": "This is a variation of https://leetcode.com/problems/subarray-sum-equals-k/. For key intuition/approach, please refer to that problem, as it\\'s easier to understand than the current problem.\\n\\nOnly diff is the sums are unique to each path, hence every time we finish a recursive call, we should remove the current sum from it so other paths don\\'t end up with irrelevant sums:\\n\\n\\tclass Solution {\\n\\t\\tint count = 0, target = 0;\\n\\t\\tpublic int pathSum(TreeNode root, int sum) {\\n\\t\\t\\ttarget = sum;\\n\\t\\t\\tMap<Integer, Integer> sumMap = new HashMap<>();\\n\\t\\t\\tsumMap.put(0, 1);\\n\\t\\t\\tcount(root, 0, sumMap);\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\n\\t\\tprivate void count(TreeNode n, int sum, Map<Integer, Integer> prevSums) {\\n\\t\\t\\tif (n == null) return;\\n\\t\\t\\tsum += n.val;\\n\\t\\t\\tcount += prevSums.getOrDefault(sum - target, 0);\\n\\n\\t\\t\\tprevSums.put(sum, prevSums.getOrDefault(sum, 0) + 1);\\n\\t\\t\\tcount(n.left, sum, prevSums);\\n\\t\\t\\tcount(n.right, sum, prevSums);\\n\\t\\t\\tprevSums.put(sum, prevSums.getOrDefault(sum, 0) - 1);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint count = 0, target = 0;\\n\\t\\tpublic int pathSum(TreeNode root, int sum) {\\n\\t\\t\\ttarget = sum;\\n\\t\\t\\tMap<Integer, Integer> sumMap = new HashMap<>();\\n\\t\\t\\tsumMap.put(0, 1);\\n\\t\\t\\tcount(root, 0, sumMap);\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 278494,
                "title": "javascript-o-n-solution-time-o-n-space",
                "content": "this is a translation of https://leetcode.com/problems/path-sum-iii/discuss/141424/Python-step-by-step-walk-through.-Easy-to-understand.-Two-solutions-comparison.-%3A-), @wonderlives explains it very well there\\n```javascript\\nvar pathSum = function (root, sum) {\\n    const freq = { 0: 1 }\\n    function dfs (root, currSum) {\\n        if (!root) return 0\\n        currSum += root.val\\n        const oldSum = currSum - sum\\n        let res = freq[oldSum] || 0\\n        freq[currSum] = (freq[currSum] || 0) + 1\\n        res += dfs(root.left, currSum) + dfs(root.right, currSum)\\n        freq[currSum]--\\n        return res\\n    }\\n    return dfs(root, 0)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar pathSum = function (root, sum) {\\n    const freq = { 0: 1 }\\n    function dfs (root, currSum) {\\n        if (!root) return 0\\n        currSum += root.val\\n        const oldSum = currSum - sum\\n        let res = freq[oldSum] || 0\\n        freq[currSum] = (freq[currSum] || 0) + 1\\n        res += dfs(root.left, currSum) + dfs(root.right, currSum)\\n        freq[currSum]--\\n        return res\\n    }\\n    return dfs(root, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746713,
                "title": "c-easy-understanding-similar-to-k-sum-pair",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![WhatsApp Image 2023-07-10 at 11.20.21 PM.jpeg](https://assets.leetcode.com/users/images/d41a887c-62d4-4b6d-ba4c-12bc3588ea7f_1689011450.127706.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<int> v,int &ct,int k){\\n        if(root == NULL) return ;\\n        v.push_back(root->val);\\n\\n        solve(root->left,v,ct,k);\\n        solve(root->right,v,ct,k);\\n\\n        int n = v.size();\\n        long long sum = 0;\\n\\n        for(int i = n - 1;i >= 0;--i){\\n            sum += v[i];\\n            if(sum == k)\\n                ct++;\\n        }\\n        v.pop_back();\\n    }\\n    int pathSum(TreeNode* root, int k) {\\n        vector<int> v;\\n        int ct = 0;\\n        solve(root,v,ct,k);\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<int> v,int &ct,int k){\\n        if(root == NULL) return ;\\n        v.push_back(root->val);\\n\\n        solve(root->left,v,ct,k);\\n        solve(root->right,v,ct,k);\\n\\n        int n = v.size();\\n        long long sum = 0;\\n\\n        for(int i = n - 1;i >= 0;--i){\\n            sum += v[i];\\n            if(sum == k)\\n                ct++;\\n        }\\n        v.pop_back();\\n    }\\n    int pathSum(TreeNode* root, int k) {\\n        vector<int> v;\\n        int ct = 0;\\n        solve(root,v,ct,k);\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799463,
                "title": "c-easy-simple-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        \\n        if(root == nullptr){return 0;}\\n        return  pathSum(root->left, sum) + pathSum(root->right, sum) + dfs(root, sum);          \\n    }\\n    \\n    int dfs(TreeNode* root, int sum)\\n    {\\n        if(root == nullptr){return 0;}\\n        \\n        int count = 0;\\n        if(root->val == sum){ ++count;}\\n        count += dfs(root->left, sum-root->val);\\n        count += dfs(root->right, sum-root->val);\\n        return count;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        \\n        if(root == nullptr){return 0;}\\n        return  pathSum(root->left, sum) + pathSum(root->right, sum) + dfs(root, sum);          \\n    }\\n    \\n    int dfs(TreeNode* root, int sum)\\n    {\\n        if(root == nullptr){return 0;}\\n        \\n        int count = 0;\\n        if(root->val == sum){ ++count;}\\n        count += dfs(root->left, sum-root->val);\\n        count += dfs(root->right, sum-root->val);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526041,
                "title": "c-prefix-summ-dfs-solution-explained-99-time-80-space",
                "content": "I already solved this problem [thrice](https://leetcode.com/problems/path-sum-iii/discuss/779575/C%2B%2B-3-DFS-Based-Solutions-Explained-and-Compared-up-to-~100-Time-~75-Space), but I also forgot it I did and it was okay, since I went on for another run, outperforming all my previous attempts :)\\n\\nTo solve this problem, the approach we will be using here remains the same (a preoder DFS traversal) and what we change is where/how we store our data, leveraging the full power of a prefix sum.\\n\\nTo do so,  we will declare first of all a few class variables:\\n* `sums` is an array of `1001` elements (the maximum we will have to store according to the specs and we will actually get a test cases with only right nodes for that size;\\n* `pos` is the pointer to what cell of `sums` we are going to write in next, initially set to `0`, the first cell;\\n* `t` is a copy of our `targetSum` variable, so not to have to pass it around all the time;\\n* `res` is our accumulator variable and it will be increased by `1` for each match we will find, initially set to `0` too.\\n\\nIn our main function, we will first of all check if we have a single node to parse at all or not (and if not, just `return` `0`), then assign the correct value to `t` and call our `dfs` helper passing `root`.\\n\\nThis help takes a `TreeNode` pointer `root` as its solve parameter and:\\n* extracts `root->val` and stores into `val`;\\n* checks if that `val` itself is a match for our target (since single node paths are still valid) and in case increases `res` by `1`;\\n* updates all the values currently stored in `sums` adding `val` to them and again checking if said values are matches, in case further increasing `res`;\\n* adds the current value itself to `sums` and moves `pos` forward by one step;\\n* checks if we have now any more `left` or `right` children and in case recurses to them;\\n* finally, it backtracks our work on `sums`, reducing `pos` by `1` and subtracting `val` from each remaining value.\\n\\nOnce done, we will be back in our main function and we will just have to `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    int sums[1001], pos = 0, t, res = 0;\\n    void dfs(TreeNode *root) {\\n        // support variables\\n        int val = root->val;\\n        // checking if val alone matches t\\n        if (val == t) res++;\\n        // updating all the prefix sums and then the value itself at the end of it\\n        for (int i = 0; i < pos; i++) {\\n            sums[i] += val;\\n            if (sums[i] == t) res++;\\n        }\\n        sums[pos++] = val;\\n        if (root->left) dfs(root->left);\\n        if (root->right) dfs(root->right);\\n        // backtracking on the prefix sums\\n        pos--;\\n        for (int i = 0; i < pos; i++) sums[i] -= val;\\n    }\\npublic:\\n    int pathSum(TreeNode *root, int targetSum) {\\n        if (!root) return 0;\\n        t = targetSum;\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\\n\\nMicro-optimised version of `dfs` that does not bother backtracking when we are on the rightmost segment:\\n\\n```cpp\\n    void dfs(TreeNode *root, bool isRight = true) {\\n        // support variables\\n        int val = root->val;\\n        // checking if val alone matches t\\n        if (val == t) res++;\\n        // updating all the prefix sums and then the value itself at the end of it\\n        for (int i = 0; i < pos; i++) {\\n            sums[i] += val;\\n            if (sums[i] == t) res++;\\n        }\\n        sums[pos++] = val;\\n        if (root->left) dfs(root->left, false);\\n        if (root->right) dfs(root->right, isRight);\\n        // backtracking on the prefix sums\\n        if (!isRight) {\\n            pos--;\\n            for (int i = 0; i < pos; i++) sums[i] -= val;\\n        }\\n    }\\n```\\n\\nAnd even better, if we just keep track of the last node we saw while traversing - I actually manage to save memory and run a bit faster on average \\uD83C\\uDF89 :\\n\\n```cpp\\n    void dfs(TreeNode *root, bool isLast = true) {\\n        // support variables\\n        int val = root->val;\\n        // checking if val alone matches t\\n        if (val == t) res++;\\n        // updating all the prefix sums and then the value itself at the end of it\\n        for (int i = 0; i < pos; i++) {\\n            sums[i] += val;\\n            if (sums[i] == t) res++;\\n        }\\n        sums[pos++] = val;\\n        if (root->left) dfs(root->left, isLast && !root->right);\\n        if (root->right) dfs(root->right, isLast);\\n        // backtracking on the prefix sums\\n        if (!isLast) {\\n            pos--;\\n            for (int i = 0; i < pos; i++) sums[i] -= val;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\n    int sums[1001], pos = 0, t, res = 0;\\n    void dfs(TreeNode *root) {\\n        // support variables\\n        int val = root->val;\\n        // checking if val alone matches t\\n        if (val == t) res++;\\n        // updating all the prefix sums and then the value itself at the end of it\\n        for (int i = 0; i < pos; i++) {\\n            sums[i] += val;\\n            if (sums[i] == t) res++;\\n        }\\n        sums[pos++] = val;\\n        if (root->left) dfs(root->left);\\n        if (root->right) dfs(root->right);\\n        // backtracking on the prefix sums\\n        pos--;\\n        for (int i = 0; i < pos; i++) sums[i] -= val;\\n    }\\npublic:\\n    int pathSum(TreeNode *root, int targetSum) {\\n        if (!root) return 0;\\n        t = targetSum;\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\n```cpp\\n    void dfs(TreeNode *root, bool isRight = true) {\\n        // support variables\\n        int val = root->val;\\n        // checking if val alone matches t\\n        if (val == t) res++;\\n        // updating all the prefix sums and then the value itself at the end of it\\n        for (int i = 0; i < pos; i++) {\\n            sums[i] += val;\\n            if (sums[i] == t) res++;\\n        }\\n        sums[pos++] = val;\\n        if (root->left) dfs(root->left, false);\\n        if (root->right) dfs(root->right, isRight);\\n        // backtracking on the prefix sums\\n        if (!isRight) {\\n            pos--;\\n            for (int i = 0; i < pos; i++) sums[i] -= val;\\n        }\\n    }\\n```\n```cpp\\n    void dfs(TreeNode *root, bool isLast = true) {\\n        // support variables\\n        int val = root->val;\\n        // checking if val alone matches t\\n        if (val == t) res++;\\n        // updating all the prefix sums and then the value itself at the end of it\\n        for (int i = 0; i < pos; i++) {\\n            sums[i] += val;\\n            if (sums[i] == t) res++;\\n        }\\n        sums[pos++] = val;\\n        if (root->left) dfs(root->left, isLast && !root->right);\\n        if (root->right) dfs(root->right, isLast);\\n        // backtracking on the prefix sums\\n        if (!isLast) {\\n            pos--;\\n            for (int i = 0; i < pos; i++) sums[i] -= val;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347010,
                "title": "java-solution-easy-to-understand-intuitive",
                "content": "```\\nclass Solution {\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return 0;\\n        }\\n        ArrayList<Integer> path=new ArrayList<>();\\n        int[]count=new int[1];\\n        helper(root,targetSum,count,path);\\n        return count[0];\\n    }\\n    public void helper(TreeNode root,int targetSum,int[] count,ArrayList<Integer> path){\\n        if(root==null){\\n            return;\\n        }\\n        path.add(root.val);\\n        int sum=0;\\n        for(int i=path.size()-1;i>=0;i--){\\n            sum+=path.get(i);\\n            if(sum==targetSum){\\n                count[0]++;\\n            }\\n        }\\n        helper(root.left,targetSum,count,path);\\n        helper(root.right,targetSum,count,path);\\n        path.remove(path.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root==null){\\n            return 0;\\n        }\\n        ArrayList<Integer> path=new ArrayList<>();\\n        int[]count=new int[1];\\n        helper(root,targetSum,count,path);\\n        return count[0];\\n    }\\n    public void helper(TreeNode root,int targetSum,int[] count,ArrayList<Integer> path){\\n        if(root==null){\\n            return;\\n        }\\n        path.add(root.val);\\n        int sum=0;\\n        for(int i=path.size()-1;i>=0;i--){\\n            sum+=path.get(i);\\n            if(sum==targetSum){\\n                count[0]++;\\n            }\\n        }\\n        helper(root.left,targetSum,count,path);\\n        helper(root.right,targetSum,count,path);\\n        path.remove(path.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851719,
                "title": "c-intuitive-solution",
                "content": "Solve with 2 DFS functions:\\nThe first DFS traverse the tree and set each node as starting point\\nThe second DFS visit subtree from the starting point\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int pathSum(TreeNode* root, int sum) {\\n        runAllNode(root, sum);\\n        return ans;\\n    }\\n\\n    void runAllNode(TreeNode* &current, int& target){\\n        if(current){\\n            updateAns(current, target, current->val);\\n            runAllNode(current->left, target);\\n            runAllNode(current->right, target);\\n        }\\n    }\\n    \\n    void updateAns(TreeNode* &current, int& target, int curSum){\\n        if(curSum == target){\\n            ans += 1;\\n        }\\n        if(current->left){\\n            updateAns(current->left, target, curSum + current->left->val);\\n        }\\n        if(current->right){\\n            updateAns(current->right, target, curSum + current->right->val);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int pathSum(TreeNode* root, int sum) {\\n        runAllNode(root, sum);\\n        return ans;\\n    }\\n\\n    void runAllNode(TreeNode* &current, int& target){\\n        if(current){\\n            updateAns(current, target, current->val);\\n            runAllNode(current->left, target);\\n            runAllNode(current->right, target);\\n        }\\n    }\\n    \\n    void updateAns(TreeNode* &current, int& target, int curSum){\\n        if(curSum == target){\\n            ans += 1;\\n        }\\n        if(current->left){\\n            updateAns(current->left, target, curSum + current->left->val);\\n        }\\n        if(current->right){\\n            updateAns(current->right, target, curSum + current->right->val);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748062,
                "title": "naive-but-easy-to-understand-only-faster-than-55",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n        helper(root,sum);\\n        return count;\\n    }\\n    \\n    private void helper(TreeNode root,int sum){\\n        if(root == null)return;\\n        dfs(root,sum,0);\\n        helper(root.left,sum);\\n        helper(root.right,sum);\\n    }\\n    \\n    private void dfs(TreeNode root , int target,int sum){\\n        if(root == null)return;\\n        if(root.val + sum == target){\\n            count++;\\n        }\\n        dfs(root.left,target,sum + root.val);\\n        dfs(root.right,target,sum+root.val);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n        helper(root,sum);\\n        return count;\\n    }\\n    \\n    private void helper(TreeNode root,int sum){\\n        if(root == null)return;\\n        dfs(root,sum,0);\\n        helper(root.left,sum);\\n        helper(root.right,sum);\\n    }\\n    \\n    private void dfs(TreeNode root , int target,int sum){\\n        if(root == null)return;\\n        if(root.val + sum == target){\\n            count++;\\n        }\\n        dfs(root.left,target,sum + root.val);\\n        dfs(root.right,target,sum+root.val);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367636,
                "title": "python-recursion-easy-to-follow",
                "content": "```\\n\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n\\n        if not root:\\n            return 0\\n        \\n        self.ans = 0\\n\\n        def search(root, memo):\\n            \\n            self.ans += memo.count(sum)\\n            \\n            if root.left:\\n                search(root.left, [x+root.left.val for x in memo] + [root.left.val])\\n            \\n            if root.right:\\n                search(root.right, [x+root.right.val for x in memo] + [root.right.val])\\n                \\n        search(root, [root.val])\\n        return self.ans\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def pathSum(self, root, sum):\\n\\n        if not root:\\n            return 0\\n        \\n        self.ans = 0\\n\\n        def search(root, memo):\\n            \\n            self.ans += memo.count(sum)\\n            \\n            if root.left:\\n                search(root.left, [x+root.left.val for x in memo] + [root.left.val])\\n            \\n            if root.right:\\n                search(root.right, [x+root.right.val for x in memo] + [root.right.val])\\n                \\n        search(root, [root.val])\\n        return self.ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 3688388,
                "title": "100-beats-cpp-c-tc-o-n-use-hashmap-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    // private: int total=0;\\n    // private: int count=0;\\n    // private:\\n    // void dfs(TreeNode* root,int k,int sum){\\n    //     if(root==NULL){\\n    //         return;\\n    //     }\\n    //     sum+=root->val;\\n    //     if(sum==k){\\n    //         count++;\\n    //     }\\n    //     dfs(root->left,k,sum);\\n    //     dfs(root->right,k,sum);\\n    // }\\n// private:\\n//     void solve(TreeNode* root, int k,int sum,HashMap<int,int>hm){\\n//         if(root==NULL){\\n//             return;\\n//         }\\n//         sum+=root->val;\\n//         if(hm.containskey(sum-k)){\\n//             total+=hm.get(sum-k);\\n//         }\\n//         hm.put(sum,getOrDefault(sum,0)+1);\\n//         solve(root->left,k,sum,hm);\\n//         solve(root->right,k,sum,hm);\\n//         hm.put(sum,hm.get(sum)-1);\\n//         return;\\n//     }\\npublic:\\n    #define ll long long\\n    map<ll ,int> mp;\\n    int ans=0;\\n    void solve(TreeNode* root, int targetSum,ll currSum){\\n        if(root==NULL) return;\\n        currSum+=root->val;\\n        ans+=mp[currSum-targetSum];//it mean between the ongoing process there is a place where targetSum is generated.\\n        mp[currSum]++;\\n        solve(root->left , targetSum,currSum);\\n        solve(root->right , targetSum,currSum);\\n        mp[currSum]--;\\n        currSum-=root->val;\\n\\n    }\\n    int pathSum(TreeNode* root, int k) {\\n        // TIME COMPLEXITY ORDER OF (N*2).\\n        // if(root==NULL){\\n        //     return 0;\\n        // }\\n        // // int count=0;\\n        // dfs(root,k,0);\\n        // pathSum(root->left,k);\\n        // pathSum(root->right,k);\\n        // return count;\\n        // TIME COMPLEXITY ORDER OF (N).\\n        // if(root==NULL){\\n        //     return 0;\\n        // }\\n        // HashMap<int,int>hm=new HashMap<>();\\n        // hm.put(0,1);\\n        // solve(root,k,0,hm);\\n        // return total;\\n        // ALTERNATIVE SOLUTION.(O(N)) TIME.\\n         mp[0]++;\\n        ll currSum=0;\\n        solve(root,k,currSum);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    // private: int total=0;\\n    // private: int count=0;\\n    // private:\\n    // void dfs(TreeNode* root,int k,int sum){\\n    //     if(root==NULL){\\n    //         return;\\n    //     }\\n    //     sum+=root->val;\\n    //     if(sum==k){\\n    //         count++;\\n    //     }\\n    //     dfs(root->left,k,sum);\\n    //     dfs(root->right,k,sum);\\n    // }\\n// private:\\n//     void solve(TreeNode* root, int k,int sum,HashMap<int,int>hm){\\n//         if(root==NULL){\\n//             return;\\n//         }\\n//         sum+=root->val;\\n//         if(hm.containskey(sum-k)){\\n//             total+=hm.get(sum-k);\\n//         }\\n//         hm.put(sum,getOrDefault(sum,0)+1);\\n//         solve(root->left,k,sum,hm);\\n//         solve(root->right,k,sum,hm);\\n//         hm.put(sum,hm.get(sum)-1);\\n//         return;\\n//     }\\npublic:\\n    #define ll long long\\n    map<ll ,int> mp;\\n    int ans=0;\\n    void solve(TreeNode* root, int targetSum,ll currSum){\\n        if(root==NULL) return;\\n        currSum+=root->val;\\n        ans+=mp[currSum-targetSum];//it mean between the ongoing process there is a place where targetSum is generated.\\n        mp[currSum]++;\\n        solve(root->left , targetSum,currSum);\\n        solve(root->right , targetSum,currSum);\\n        mp[currSum]--;\\n        currSum-=root->val;\\n\\n    }\\n    int pathSum(TreeNode* root, int k) {\\n        // TIME COMPLEXITY ORDER OF (N*2).\\n        // if(root==NULL){\\n        //     return 0;\\n        // }\\n        // // int count=0;\\n        // dfs(root,k,0);\\n        // pathSum(root->left,k);\\n        // pathSum(root->right,k);\\n        // return count;\\n        // TIME COMPLEXITY ORDER OF (N).\\n        // if(root==NULL){\\n        //     return 0;\\n        // }\\n        // HashMap<int,int>hm=new HashMap<>();\\n        // hm.put(0,1);\\n        // solve(root,k,0,hm);\\n        // return total;\\n        // ALTERNATIVE SOLUTION.(O(N)) TIME.\\n         mp[0]++;\\n        ll currSum=0;\\n        solve(root,k,currSum);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042640,
                "title": "c-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void dfs(TreeNode* root,long long tar){\\n        if(!root) return ;\\n        \\n        if(root->val== tar)ans++;\\n        dfs(root->left, tar-(root->val));\\n        dfs(root->right,tar-(root->val));\\n    }\\n    \\n    \\n    int pathSum(TreeNode* root, int tar) {\\n        if(!root)return 0;\\n        \\n        dfs(root,tar);\\n        pathSum(root->left, tar);\\n        pathSum(root->right,tar);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void dfs(TreeNode* root,long long tar){\\n        if(!root) return ;\\n        \\n        if(root->val== tar)ans++;\\n        dfs(root->left, tar-(root->val));\\n        dfs(root->right,tar-(root->val));\\n    }\\n    \\n    \\n    int pathSum(TreeNode* root, int tar) {\\n        if(!root)return 0;\\n        \\n        dfs(root,tar);\\n        pathSum(root->left, tar);\\n        pathSum(root->right,tar);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618641,
                "title": "easy-simple-and-crisp-solution-cpp-code-with-commented-explanation",
                "content": "**\\u2B06\\uFE0F UPVOTE \\u2B06\\uFE0F**\\nThe Simple catch in the question is that we need to take each node as a root and traverse from that node till the end(leaf node), if at any node we see the current sum == target Sum, we increament the answer......else we keep traversal going on on the left and right sub-trees.\\n\\nBelow is the Full Code :\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void solve(TreeNode* root,int sum,long long &curr)\\n    {\\n        if(!root)return;\\n        curr=(curr+root->val);  \\n        if(curr==sum)ans++;     //if(curr==targetSum, increament ans)\\n        solve(root->left,sum,curr);  //recur for left subtree\\n        solve(root->right,sum,curr);   //recur for right subtree\\n        curr-=root->val;     //Backtracking \\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        \\n        \\n        if(!root)return 0;\\n        long long curr=0;\\n        solve(root,targetSum,curr);\\n        pathSum(root->left,targetSum);  //taking left child as root and calling pathSum function\\n        pathSum(root->right,targetSum);  ////taking left child as root and calling pathSum function\\n        return ans;\\n    }\\n};\\n```\\n***Please, please do \\u2B06\\uFE0F upvote \\u2B06\\uFE0F if you found it helpful, it keeps me motivated to post more of such solutions :) and feel free to ask in comments if you have any queries/doubts :)***\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void solve(TreeNode* root,int sum,long long &curr)\\n    {\\n        if(!root)return;\\n        curr=(curr+root->val);  \\n        if(curr==sum)ans++;     //if(curr==targetSum, increament ans)\\n        solve(root->left,sum,curr);  //recur for left subtree\\n        solve(root->right,sum,curr);   //recur for right subtree\\n        curr-=root->val;     //Backtracking \\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        \\n        \\n        if(!root)return 0;\\n        long long curr=0;\\n        solve(root,targetSum,curr);\\n        pathSum(root->left,targetSum);  //taking left child as root and calling pathSum function\\n        pathSum(root->right,targetSum);  ////taking left child as root and calling pathSum function\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590794,
                "title": "easy-java-solution-100-faster-91-memory",
                "content": "```\\nclass Solution {\\n    int sum = 0;\\n    public int pathSum(TreeNode root, int targetSum) {\\n      if (root == null)\\n        return 0;\\n      Map<Long, Integer> map = new HashMap<>();\\n      map.put((long)0, 1);\\n      \\n      dfs(root, targetSum, map, (long)0);\\n      \\n      return sum; \\n  }\\n  \\n    public void dfs(TreeNode root, int target, Map<Long, Integer> map, long current) {\\n      \\n      if (root == null)\\n        return; \\n      \\n      current = current + root.val;\\n      \\n      if (map.containsKey(current - target)) {\\n        sum += map.get(current - target);\\n      }\\n      \\n      map.put(current, map.getOrDefault(current, 0) + 1);\\n      \\n      if (root.left != null)\\n        dfs(root.left, target, map, current);\\n      \\n      if (root.right != null)\\n        dfs(root.right, target, map, current); \\n        \\n        map.put(current, map.get(current) - 1);\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int pathSum(TreeNode root, int targetSum) {\\n      if (root == null)\\n        return 0;\\n      Map<Long, Integer> map = new HashMap<>();\\n      map.put((long)0, 1);\\n      \\n      dfs(root, targetSum, map, (long)0);\\n      \\n      return sum; \\n  }\\n  \\n    public void dfs(TreeNode root, int target, Map<Long, Integer> map, long current) {\\n      \\n      if (root == null)\\n        return; \\n      \\n      current = current + root.val;\\n      \\n      if (map.containsKey(current - target)) {\\n        sum += map.get(current - target);\\n      }\\n      \\n      map.put(current, map.getOrDefault(current, 0) + 1);\\n      \\n      if (root.left != null)\\n        dfs(root.left, target, map, current);\\n      \\n      if (root.right != null)\\n        dfs(root.right, target, map, current); \\n        \\n        map.put(current, map.get(current) - 1);\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409601,
                "title": "three-aproach-1-brute-force-2-vector-method-3-hash-map-method",
                "content": "Brute Force approch\\n```\\nclass Solution \\n{ \\npublic: \\n    int PathSum2(TreeNode* node, long long sum) \\n    { \\n        if (node == NULL) \\n            return 0; \\n        int count = 0; \\n        if (node->val == sum) \\n            count = 1; \\n        long long newSum = sum - node->val; \\n        count += PathSum2(node->left, newSum); \\n        count += PathSum2(node->right, newSum); \\n        return count; \\n    } \\n    int pathSum(TreeNode* root, int sum) //main function \\n    { \\n        if (root == NULL) \\n            return 0; \\n        return pathSum(root->left, sum) +  \\n                pathSum(root->right, sum) + \\n                  PathSum2(root, sum); //check for every node\\n    } \\n};\\n```\\nVector method\\n```\\nclass Solution { \\npublic: \\n    int count=0; \\n    vector<int>v; \\n    int pathSum(TreeNode* root, int targetSum) { \\n        sol(root,targetSum); \\n        return count; \\n    } \\n    void sol(TreeNode* root,int sum){ \\n        if(root==NULL){ \\n            return; \\n        } \\n        v.push_back(root->val); \\n        sol(root->left,sum); \\n        sol(root->right,sum); \\n        long long temp=0; \\n        for(int i=v.size()-1;i>=0;i--){ \\n            temp+=v[i]; \\n            if(temp==sum){ \\n                count++; \\n            } \\n        } \\n        v.pop_back(); \\n    } \\n};\\n```\\nHash Map approach\\n```\\nclass Solution {\\npublic:\\n    int total =0;\\n    int pathSum(TreeNode* root, int targetsum) {\\n        if(!root)return 0;\\n        unordered_map<long long ,int>map;\\n        sol(root,0,targetsum,map);\\n        return total;\\n    }\\n    void sol(TreeNode* root, long long sum ,int targetsum,unordered_map<long long ,int>map){\\n        if(!root)return;\\n        sum=sum+root->val;\\n        if(sum==targetsum)total++;\\n        if(map.find(sum-targetsum)!=map.end()){\\n            total=total+map[sum-targetsum];\\n        }\\n        map[sum]++;\\n        sol(root->left,sum,targetsum,map);\\n        sol(root->right,sum,targetsum,map);\\n        map[sum]--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{ \\npublic: \\n    int PathSum2(TreeNode* node, long long sum) \\n    { \\n        if (node == NULL) \\n            return 0; \\n        int count = 0; \\n        if (node->val == sum) \\n            count = 1; \\n        long long newSum = sum - node->val; \\n        count += PathSum2(node->left, newSum); \\n        count += PathSum2(node->right, newSum); \\n        return count; \\n    } \\n    int pathSum(TreeNode* root, int sum) //main function \\n    { \\n        if (root == NULL) \\n            return 0; \\n        return pathSum(root->left, sum) +  \\n                pathSum(root->right, sum) + \\n                  PathSum2(root, sum); //check for every node\\n    } \\n};\\n```\n```\\nclass Solution { \\npublic: \\n    int count=0; \\n    vector<int>v; \\n    int pathSum(TreeNode* root, int targetSum) { \\n        sol(root,targetSum); \\n        return count; \\n    } \\n    void sol(TreeNode* root,int sum){ \\n        if(root==NULL){ \\n            return; \\n        } \\n        v.push_back(root->val); \\n        sol(root->left,sum); \\n        sol(root->right,sum); \\n        long long temp=0; \\n        for(int i=v.size()-1;i>=0;i--){ \\n            temp+=v[i]; \\n            if(temp==sum){ \\n                count++; \\n            } \\n        } \\n        v.pop_back(); \\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int total =0;\\n    int pathSum(TreeNode* root, int targetsum) {\\n        if(!root)return 0;\\n        unordered_map<long long ,int>map;\\n        sol(root,0,targetsum,map);\\n        return total;\\n    }\\n    void sol(TreeNode* root, long long sum ,int targetsum,unordered_map<long long ,int>map){\\n        if(!root)return;\\n        sum=sum+root->val;\\n        if(sum==targetsum)total++;\\n        if(map.find(sum-targetsum)!=map.end()){\\n            total=total+map[sum-targetsum];\\n        }\\n        map[sum]++;\\n        sol(root->left,sum,targetsum,map);\\n        sol(root->right,sum,targetsum,map);\\n        map[sum]--;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390356,
                "title": "simplest-solution-easiest-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public int pathSum(TreeNode root, int targetSum) {\\n        \\n        if(root==null)\\n            return 0;\\n        \\n        return helper(root,targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);\\n    }\\n    \\n    public int helper(TreeNode root, long sum) {\\n     \\n        if(root==null)\\n            return 0;\\n        \\n        int res=0;\\n        \\n        if(root.val==sum)\\n            res++;\\n        \\n        res+= helper(root.left,sum-root.val);\\n        res+= helper(root.right,sum-root.val);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int pathSum(TreeNode root, int targetSum) {\\n        \\n        if(root==null)\\n            return 0;\\n        \\n        return helper(root,targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);\\n    }\\n    \\n    public int helper(TreeNode root, long sum) {\\n     \\n        if(root==null)\\n            return 0;\\n        \\n        int res=0;\\n        \\n        if(root.val==sum)\\n            res++;\\n        \\n        res+= helper(root.left,sum-root.val);\\n        res+= helper(root.right,sum-root.val);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291766,
                "title": "c-easy-to-understand-dfs-approach",
                "content": "```\\nclass Solution {\\n    int count=0;\\n    void getAllPath(TreeNode *root,long long targetSum){\\n        if(root==NULL) return;\\n        if(targetSum == root->val){\\n            count++;\\n        }\\n        getAllPath(root->left,targetSum-root->val);\\n        getAllPath(root->right,targetSum-root->val);\\n    }\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n        getAllPath(root,targetSum);\\n        pathSum(root->left,targetSum);\\n        pathSum(root->right,targetSum);\\n        return count;\\n    }\\n};\\n```\\nIf you like the solution, don\\'t forget to upvote! :) \\u2B06\\uFE0F\\n*Thanks!* \\uD83D\\uDE0A",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int count=0;\\n    void getAllPath(TreeNode *root,long long targetSum){\\n        if(root==NULL) return;\\n        if(targetSum == root->val){\\n            count++;\\n        }\\n        getAllPath(root->left,targetSum-root->val);\\n        getAllPath(root->right,targetSum-root->val);\\n    }\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n        getAllPath(root,targetSum);\\n        pathSum(root->left,targetSum);\\n        pathSum(root->right,targetSum);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205014,
                "title": "iterative-post-order-prefix-sum-with-explanation-and-pictures-spent-2-days-to-learn-post-order",
                "content": "To solve this problem we can combine two techniques: post-order tree traversal and prefix sum.\\n![image](https://assets.leetcode.com/users/images/52b1c3c7-2c4c-4bba-a20c-503fe861c74d_1656332451.4314165.png)\\n\\nFor post-order, at first we going to the left (or to the right if there is no left node) and bottom (until we find the leaf):\\n![image](https://assets.leetcode.com/users/images/a07c9077-a7e9-4667-9240-07bc97f5f463_1656331565.2107663.png)\\n\\n```\\nfunction postOrder(root: TreeNode): void {\\n  let curr = root;\\n\\n  const stack = [];\\n\\n  while (stack.length || curr) {\\n    // Going to the bottom\\n    while (curr) {\\n      stack.push(curr);\\n\\n      if (curr.left) {\\n        curr = curr.left;\\n      } else if (curr.right) {\\n        curr = curr.right;\\n      } else {\\n        curr = null;\\n      }\\n    }\\n\\n    // the last unhandled node\\n    const nPopped = stack.pop();\\n\\tcalcTreeNode(nPopped);\\n\\n    // if the current node is not left child of the latest node in stack\\n    // than it means we already checked the right side\\n\\t// in other words - if the current node is the left child than we must go right\\n    if (stack.length && stack[stack.length - 1].left == nPopped) {\\n      curr = stack[stack.length - 1].right;\\n    }\\n  }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/c8e71983-809d-4eef-bff9-04fd3a04bfdd_1656331914.2940583.png)\\n\\nNow, lets combine with prefix sum. While going to the bottom let\\'s calculate our sum, count and count for the current sum. \\n```\\n      currentSumm += curr.val;\\n      count += map.get(currentSumm - targetSum) ?? 0;\\n      map.set(currentSumm, (map.get(currentSumm) ?? 0) + 1);\\n```\\nAlso, we must remember to backtrack the sum after we popped the node.\\n```\\n    map.set(currentSumm, map.get(currentSumm) - 1);\\n    currentSumm -= nPopped.val;\\n```\\n\\nFull code:\\n```\\nfunction pathSum(root: TreeNode | null, targetSum: number): number {\\n  let curr = root;\\n\\n  const stack = [];\\n\\n  let currentSumm = 0;\\n  const map = new Map();\\n  map.set(0, 1);\\n\\n  let count = 0;\\n\\n  while (stack.length || curr) {\\n    // Going to the leftmost bottom\\n    while (curr) {\\n      stack.push(curr);\\n\\n      //calculate summ, current count\\n      currentSumm += curr.val;\\n\\n      count += map.get(currentSumm - targetSum) ?? 0;\\n      map.set(currentSumm, (map.get(currentSumm) ?? 0) + 1);\\n\\n      if (curr.left) {\\n        curr = curr.left;\\n      } else if (curr.right) {\\n        curr = curr.right;\\n      } else {\\n        curr = null;\\n      }\\n    }\\n\\n    const nPopped = stack.pop();\\n\\n    // Revert summ operations\\n    map.set(currentSumm, map.get(currentSumm) - 1);\\n    currentSumm -= nPopped.val;\\n    //\\n\\n    // if the current node is not left child of the latest node in stack\\n    // than it means we already checked the right side\\n    if (stack.length && stack[stack.length - 1].left == nPopped) {\\n      curr = stack[stack.length - 1].right;\\n    }\\n  }\\n\\n  return count;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Iterator"
                ],
                "code": "```\\nfunction postOrder(root: TreeNode): void {\\n  let curr = root;\\n\\n  const stack = [];\\n\\n  while (stack.length || curr) {\\n    // Going to the bottom\\n    while (curr) {\\n      stack.push(curr);\\n\\n      if (curr.left) {\\n        curr = curr.left;\\n      } else if (curr.right) {\\n        curr = curr.right;\\n      } else {\\n        curr = null;\\n      }\\n    }\\n\\n    // the last unhandled node\\n    const nPopped = stack.pop();\\n\\tcalcTreeNode(nPopped);\\n\\n    // if the current node is not left child of the latest node in stack\\n    // than it means we already checked the right side\\n\\t// in other words - if the current node is the left child than we must go right\\n    if (stack.length && stack[stack.length - 1].left == nPopped) {\\n      curr = stack[stack.length - 1].right;\\n    }\\n  }\\n}\\n```\n```\\n      currentSumm += curr.val;\\n      count += map.get(currentSumm - targetSum) ?? 0;\\n      map.set(currentSumm, (map.get(currentSumm) ?? 0) + 1);\\n```\n```\\n    map.set(currentSumm, map.get(currentSumm) - 1);\\n    currentSumm -= nPopped.val;\\n```\n```\\nfunction pathSum(root: TreeNode | null, targetSum: number): number {\\n  let curr = root;\\n\\n  const stack = [];\\n\\n  let currentSumm = 0;\\n  const map = new Map();\\n  map.set(0, 1);\\n\\n  let count = 0;\\n\\n  while (stack.length || curr) {\\n    // Going to the leftmost bottom\\n    while (curr) {\\n      stack.push(curr);\\n\\n      //calculate summ, current count\\n      currentSumm += curr.val;\\n\\n      count += map.get(currentSumm - targetSum) ?? 0;\\n      map.set(currentSumm, (map.get(currentSumm) ?? 0) + 1);\\n\\n      if (curr.left) {\\n        curr = curr.left;\\n      } else if (curr.right) {\\n        curr = curr.right;\\n      } else {\\n        curr = null;\\n      }\\n    }\\n\\n    const nPopped = stack.pop();\\n\\n    // Revert summ operations\\n    map.set(currentSumm, map.get(currentSumm) - 1);\\n    currentSumm -= nPopped.val;\\n    //\\n\\n    // if the current node is not left child of the latest node in stack\\n    // than it means we already checked the right side\\n    if (stack.length && stack[stack.length - 1].left == nPopped) {\\n      curr = stack[stack.length - 1].right;\\n    }\\n  }\\n\\n  return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994282,
                "title": "c-easy-to-understand-bruteforce-optimised-solution-explained-with-recusrsive-tree-diagram",
                "content": "**Approach is simple just we have to find all the possible path and check wheather it is equal to sum or not.**\\n**Take a vector to store the path while traversing the tree.**\\n### ***Recursive tree diagram :***\\n\\n![image](https://assets.leetcode.com/users/images/428e139f-9fab-4dc3-995d-0a4734f1902e_1651326452.8400233.jpeg)\\n\\n**NOTE :** *While adding values from vector, always start adding from the recently added node(i.e.from the end of vector).*\\n\\n**Below is the implementation of above approach :**\\n\\n```\\npublic:\\n    int count = 0;\\n    void helper(TreeNode* root, int targetSum,vector<int> &path)\\n    {\\n        if(!root){\\n            return;\\n        }\\n        \\n        // push current node inside the path vector\\n        path.push_back(root->val);  \\n        helper(root->left,targetSum,path);\\n        helper(root->right,targetSum,path);\\n        \\n        int size = path.size();\\n        long long int sum = 0;\\n        for(int i = size - 1 ; i >= 0; --i){\\n            sum += path[i];\\n            if(sum == targetSum){\\n                count++;\\n            } \\n        }\\n        \\n        // remove the current node, in otherwords backtrack\\n        path.pop_back();\\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum)\\n    {\\n        vector<int> path; // to store the path \\n        helper(root,targetSum,path);\\n        return count;\\n    }\\n};\\n```\\n***T.C : BestCase O(n*h) and Worst case O(n^2)**\\n\\n### **Optimised solution using maps by storing prefix sum :**\\nI will advice you to solve this problem *https://leetcode.com/problems/subarray-sum-equals-k/ *first before moving to this solution :)\\n```\\nclass Solution {\\npublic:\\n int pathSum(TreeNode* root, int tsum) {\\n        unordered_map<int, int> m;\\n        m[0]++;  // m[0] = 1  : if currsum - k = 0, then it means that currsum = k for that we have to be already map 0 with freq 1 i.e.[0] -> 1\\n        \\n        int count = 0;\\n        helper(root, 0, tsum, count, m);\\n        return count;\\n    }\\n    \\n    void helper(TreeNode *p, long int cur, int tsum, int &count, unordered_map<int, int> &m) {\\n        if (!p) return;\\n        \\n        cur += p->val;\\n        if (m.find(cur - tsum) != m.end()){\\n            count += m[cur - tsum];\\n        }\\n        m[cur]++;  // increment freq of current sum in map\\n        \\n        helper(p->left, cur, tsum, count, m);\\n        helper(p->right, cur, tsum, count, m);\\n        \\n        m[cur]--;  // decrement freq of current sum from map\\n   }\\n};\\n```\\n**TC : O(n)**\\n\\n\\n\\n*If you liked it please upvote my solution :)*",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\npublic:\\n    int count = 0;\\n    void helper(TreeNode* root, int targetSum,vector<int> &path)\\n    {\\n        if(!root){\\n            return;\\n        }\\n        \\n        // push current node inside the path vector\\n        path.push_back(root->val);  \\n        helper(root->left,targetSum,path);\\n        helper(root->right,targetSum,path);\\n        \\n        int size = path.size();\\n        long long int sum = 0;\\n        for(int i = size - 1 ; i >= 0; --i){\\n            sum += path[i];\\n            if(sum == targetSum){\\n                count++;\\n            } \\n        }\\n        \\n        // remove the current node, in otherwords backtrack\\n        path.pop_back();\\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum)\\n    {\\n        vector<int> path; // to store the path \\n        helper(root,targetSum,path);\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n int pathSum(TreeNode* root, int tsum) {\\n        unordered_map<int, int> m;\\n        m[0]++;  // m[0] = 1  : if currsum - k = 0, then it means that currsum = k for that we have to be already map 0 with freq 1 i.e.[0] -> 1\\n        \\n        int count = 0;\\n        helper(root, 0, tsum, count, m);\\n        return count;\\n    }\\n    \\n    void helper(TreeNode *p, long int cur, int tsum, int &count, unordered_map<int, int> &m) {\\n        if (!p) return;\\n        \\n        cur += p->val;\\n        if (m.find(cur - tsum) != m.end()){\\n            count += m[cur - tsum];\\n        }\\n        m[cur]++;  // increment freq of current sum in map\\n        \\n        helper(p->left, cur, tsum, count, m);\\n        helper(p->right, cur, tsum, count, m);\\n        \\n        m[cur]--;  // decrement freq of current sum from map\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878062,
                "title": "simple-js-dfs",
                "content": "The way I think about it: \\nWould top down or bottom up work best for this? - I think bottom up, so that we can calculate the total at each node as we go towards the top\\n\\nSo...\\nLets go DFS and Inorder, at each node, we find the total sums as we traverse down again. \\nThis means that we are bubbling up, and doing a dfs at each node with another function. \\n\\nI hope this helps someone!\\n\\n\\n```\\nvar pathSum = function(root, targetSum) {\\n    if(!root) return 0;\\n    let count = 0;\\n    \\n    function helper(node, sum){\\n        if(!node) return;\\n\\t\\t//traversing down the tree again, add up the sum\\n        sum += node.val;\\n        if(sum === targetSum) count++;\\n        return helper(node.left, sum) || helper(node.right, sum)\\n    }\\n    \\n    \\n    function dfs(node){\\n        if(!node) return;\\n\\t\\t\\n\\t\\t//inorder\\n        node.left && dfs(node.left);\\n        helper(node, 0); //instantiate a new sum of 0 at each node\\n        node.right && dfs(node.right);\\n    }\\n    \\n    dfs(root);\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar pathSum = function(root, targetSum) {\\n    if(!root) return 0;\\n    let count = 0;\\n    \\n    function helper(node, sum){\\n        if(!node) return;\\n\\t\\t//traversing down the tree again, add up the sum\\n        sum += node.val;\\n        if(sum === targetSum) count++;\\n        return helper(node.left, sum) || helper(node.right, sum)\\n    }\\n    \\n    \\n    function dfs(node){\\n        if(!node) return;\\n\\t\\t\\n\\t\\t//inorder\\n        node.left && dfs(node.left);\\n        helper(node, 0); //instantiate a new sum of 0 at each node\\n        node.right && dfs(node.right);\\n    }\\n    \\n    dfs(root);\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1689614,
                "title": "c-solution-recusrsion-with-one-variable-only",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void travel(TreeNode* root, int sum)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root->val == sum)\\n            ans++;\\n        travel(root->left, sum-root->val);\\n        travel(root->right, sum-root->val);\\n    }\\n    \\n    int pathSum(TreeNode* root, int sum) {\\n        if(root == NULL)\\n            return 0;\\n        travel(root, sum);\\n        pathSum(root->left, sum);\\n        pathSum(root->right, sum);\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void travel(TreeNode* root, int sum)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root->val == sum)\\n            ans++;\\n        travel(root->left, sum-root->val);\\n        travel(root->right, sum-root->val);\\n    }\\n    \\n    int pathSum(TreeNode* root, int sum) {\\n        if(root == NULL)\\n            return 0;\\n        travel(root, sum);\\n        pathSum(root->left, sum);\\n        pathSum(root->right, sum);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525756,
                "title": "c-faster-gp-hash-table-solution",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\nusing namespace __gnu_pbds;\\nclass Solution {\\npublic:\\n    \\n    int recurse(TreeNode* root,int sum,int target,gp_hash_table<int,int>& mp){\\n        if(root==NULL)\\n            return 0;\\n        int ans = 0;\\n        sum+=root->val;\\n        if(mp.find(sum-target)!=mp.end())\\n            ans+=mp[sum-target];\\n        mp[sum]++;\\n        ans+=recurse(root->left,sum,target,mp);\\n        ans+=recurse(root->right,sum,target,mp);\\n        if(--mp[sum]==0)\\n            mp.erase(sum);\\n        return ans;\\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        gp_hash_table<int,int> mp;\\n        mp[0]++;\\n        return recurse(root,0,targetSum,mp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\nusing namespace __gnu_pbds;\\nclass Solution {\\npublic:\\n    \\n    int recurse(TreeNode* root,int sum,int target,gp_hash_table<int,int>& mp){\\n        if(root==NULL)\\n            return 0;\\n        int ans = 0;\\n        sum+=root->val;\\n        if(mp.find(sum-target)!=mp.end())\\n            ans+=mp[sum-target];\\n        mp[sum]++;\\n        ans+=recurse(root->left,sum,target,mp);\\n        ans+=recurse(root->right,sum,target,mp);\\n        if(--mp[sum]==0)\\n            mp.erase(sum);\\n        return ans;\\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        gp_hash_table<int,int> mp;\\n        mp[0]++;\\n        return recurse(root,0,targetSum,mp);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1252131,
                "title": "two-approaches-brute-force-using-prefix-sum",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n\\n**Approach 1 :- Time O(n)**\\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void solve(TreeNode* root , int target , int curr_sum , unordered_map<int,int> u)\\n    {\\n        if(root == NULL)\\n            return;\\n        curr_sum += root->val;\\n        if(curr_sum == target)\\n        {\\n            count++;\\n        }\\n        if(u.count(curr_sum - target))\\n        {\\n            count += u[curr_sum - target];\\n        }\\n        u[curr_sum]++;\\n        solve(root->left , target , curr_sum  , u);\\n        solve(root->right , target , curr_sum  , u);\\n        u[curr_sum]--;\\n    }\\n\\t\\n    int pathSum(TreeNode* root , int target)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int curr_sum = 0;\\n        unordered_map<int , int> u;\\n        solve(root , target , curr_sum , u);\\n        return count;\\n    }\\n};\\n```\\n**Approach 2 :- Time O(n^2)**\\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void solve(TreeNode* root , int target , int curr_sum)\\n    {\\n        if(root == NULL)\\n\\t   \\t return;\\n        curr_sum += root->val;\\n        if(curr_sum == target)\\n        {\\n\\t    \\tcount++;\\n\\t\\t}\\n        solve(root->left , target , curr_sum);\\n        solve(root->right , target , curr_sum);\\n    }\\n\\t\\n    int pathSum(TreeNode* root, int target) {\\n        if(root == NULL)\\n         return 0;\\n        int curr_sum = 0;\\n        solve(root , target , curr_sum);\\n        pathSum(root->left , target);\\n        pathSum(root->right , target);\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void solve(TreeNode* root , int target , int curr_sum , unordered_map<int,int> u)\\n    {\\n        if(root == NULL)\\n            return;\\n        curr_sum += root->val;\\n        if(curr_sum == target)\\n        {\\n            count++;\\n        }\\n        if(u.count(curr_sum - target))\\n        {\\n            count += u[curr_sum - target];\\n        }\\n        u[curr_sum]++;\\n        solve(root->left , target , curr_sum  , u);\\n        solve(root->right , target , curr_sum  , u);\\n        u[curr_sum]--;\\n    }\\n\\t\\n    int pathSum(TreeNode* root , int target)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int curr_sum = 0;\\n        unordered_map<int , int> u;\\n        solve(root , target , curr_sum , u);\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    void solve(TreeNode* root , int target , int curr_sum)\\n    {\\n        if(root == NULL)\\n\\t   \\t return;\\n        curr_sum += root->val;\\n        if(curr_sum == target)\\n        {\\n\\t    \\tcount++;\\n\\t\\t}\\n        solve(root->left , target , curr_sum);\\n        solve(root->right , target , curr_sum);\\n    }\\n\\t\\n    int pathSum(TreeNode* root, int target) {\\n        if(root == NULL)\\n         return 0;\\n        int curr_sum = 0;\\n        solve(root , target , curr_sum);\\n        pathSum(root->left , target);\\n        pathSum(root->right , target);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204973,
                "title": "c-prefix-sum-beats-99",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int count = 0, target;\\n    unordered_map<int, int> seen;\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        target = targetSum;\\n        _pathSum(root, 0);\\n        return count;\\n    }\\n    void _pathSum(TreeNode* node, int sum) {\\n        // EMPTY\\n        if(!node) return;\\n        // UPDATE\\n        sum += node -> val;\\n        // Scenario 1 (sum path from root)\\n        if(sum == target) count++;\\n        // Scenario 2 (sum path from \"middle\" of tree)\\n        if(seen.find(sum - target) != seen.end()) count += seen[sum - target];\\n        seen[sum]++;\\n        // RECURSE\\n        _pathSum(node -> left, sum);\\n        _pathSum(node -> right, sum);\\n        // UNDO (backtrack)\\n        seen[sum]--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int count = 0, target;\\n    unordered_map<int, int> seen;\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        target = targetSum;\\n        _pathSum(root, 0);\\n        return count;\\n    }\\n    void _pathSum(TreeNode* node, int sum) {\\n        // EMPTY\\n        if(!node) return;\\n        // UPDATE\\n        sum += node -> val;\\n        // Scenario 1 (sum path from root)\\n        if(sum == target) count++;\\n        // Scenario 2 (sum path from \"middle\" of tree)\\n        if(seen.find(sum - target) != seen.end()) count += seen[sum - target];\\n        seen[sum]++;\\n        // RECURSE\\n        _pathSum(node -> left, sum);\\n        _pathSum(node -> right, sum);\\n        // UNDO (backtrack)\\n        seen[sum]--;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779234,
                "title": "c-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,int sum,int cur,int &ans){\\n        if(root){\\n            cur+=root->val;\\n            if(cur==sum){\\n                ans++;\\n            }\\n            dfs(root->left,sum,cur,ans);\\n            dfs(root->right,sum,cur,ans);\\n        }\\n    }\\n    \\n    void fromNode(TreeNode *root,int sum,int &ans){\\n        if(root){\\n            dfs(root,sum,0,ans);\\n            fromNode(root->left,sum,ans);\\n            fromNode(root->right,sum,ans);\\n        }        \\n    }\\n    \\n    int pathSum(TreeNode* root, int sum) {\\n        int ans=0;\\n        fromNode(root,sum,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,int sum,int cur,int &ans){\\n        if(root){\\n            cur+=root->val;\\n            if(cur==sum){\\n                ans++;\\n            }\\n            dfs(root->left,sum,cur,ans);\\n            dfs(root->right,sum,cur,ans);\\n        }\\n    }\\n    \\n    void fromNode(TreeNode *root,int sum,int &ans){\\n        if(root){\\n            dfs(root,sum,0,ans);\\n            fromNode(root->left,sum,ans);\\n            fromNode(root->right,sum,ans);\\n        }        \\n    }\\n    \\n    int pathSum(TreeNode* root, int sum) {\\n        int ans=0;\\n        fromNode(root,sum,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421674,
                "title": "c-beats-90-10-lines-with-explanation",
                "content": "```\\nclass Solution {\\nprivate:\\n    int cnt{}; // Keep a count\\n    \\n    void getPathSum(TreeNode* root, int target, int sum) {\\n        if (!root) return; // If we reached the bottom exit\\n        if (sum + root->val == target) cnt++; // If along the way we hit the target, return\\n        getPathSum(root->left, target, sum + root->val); // Move onto left node with the running sum\\n        getPathSum(root->right, target, sum + root->val); // Move onto right node with the running sum\\n    }\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        if (!root) return 0;\\n        getPathSum(root, sum, 0);\\n        pathSum(root->left, sum); // Apply the same formula to each node in the tree.\\n        pathSum(root->right, sum);\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\nprivate:\\n    int cnt{}",
                "codeTag": "Java"
            },
            {
                "id": 401013,
                "title": "easy-c-solution-using-dfs",
                "content": "Runtime: 20 ms, faster than 76.21% of C++ online submissions for Path Sum III.\\nMemory Usage: 14.7 MB, less than 87.10% of C++ online submissions for Path Sum III.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        \\n        if(root == nullptr)\\n            return 0;\\n        return helper(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\\n          \\n    }\\n    \\n    int helper(TreeNode* root, int sum)\\n    {\\n        if(root == nullptr)\\n            return 0;\\n        \\n        int count = 0;\\n        if(root->val == sum) ++count;\\n        count += helper(root->left, sum-root->val);\\n        count += helper(root->right, sum-root->val);\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        \\n        if(root == nullptr)\\n            return 0;\\n        return helper(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\\n          \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 398655,
                "title": "simple-4-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        if(!root)   return 0;\\n        return pathSum1(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\\n    }\\n    int pathSum1(TreeNode* root, int sum){\\n        if(!root)return 0;\\n        return (root->val == sum ? 1 : 0) + pathSum1(root->left, sum - root->val) + pathSum1(root->right, sum - root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        if(!root)   return 0;\\n        return pathSum1(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\\n    }\\n    int pathSum1(TreeNode* root, int sum){\\n        if(!root)return 0;\\n        return (root->val == sum ? 1 : 0) + pathSum1(root->left, sum - root->val) + pathSum1(root->right, sum - root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377535,
                "title": "javascript-read-this-solution-if-you-ve-given-up-hope-and-just-want-to-see-some-progress",
                "content": "Like others have echoed, I found this question way harder than Easy. I couldn\\'t solve it at all. I had no problem writing the code to `dfs` down the children and also start a `dfs` at every node, but it just wouldn\\'t pass.\\n\\nThat\\'s when I saw the `visited` (renamed to `startedFrom` here to make more set) hash table/Set idea to make sure you don\\'t erroneously start from a node more than once.\\n\\nIn the `[1,null,2,null,3,null]` tree example, 2 would be visited twice, 3 would be visited 4 times with this kind of code:\\n```\\nfunction dfs(...) {\\n\\tdfs()\\n\\tdfs()\\n}\\n```\\n\\nNotice that I also do the check for \"whether we have matched the path sum\" at the node itself, instead of doing the `remaining - node.val` subtraction and waiting for the child node to `return` + `count++` for us.\\nThis is because I did not want the left child and right child double-counting a matched path sum for a parent node. There\\'s probably better way to code it.\\n\\nHere is a tracing of the code in the `[1,null,2,null,3,null]` scenario mentioned above, showing how the node (3) gets visited 4 times, and **thus is incorrect.** The second **red** counting of (3) should not happen.\\n![image](https://assets.leetcode.com/users/lcgt/image_1567922046.png)\\n\\n\\n```\\nvar pathSum = (root, sum) => {\\n    let count = 0;\\n    let startedFrom = new Set();\\n    dfs(root, sum, true); // the `true` here doesn\\'t matter, you can\\'t visit root node twice.\\n    return count;\\n    \\n    function dfs(node, remaining, isStartingFromThisNode) {\\n        if(!node) return;\\n        \\n        if(isStartingFromThisNode) {\\n            // Trick: only start from this node once throughout the whole solution\\n            // doing 2 dfs() calls from each node means each node of depth h gets visited 2^h times, which is undesirable\\n            if(startedFrom.has(node)) return;\\n            startedFrom.add(node);\\n        }\\n        \\n        if(remaining - node.val === 0) {\\n            count++;\\n        }\\n            \\n        dfs(node.left, remaining-node.val, false);\\n        dfs(node.right, remaining-node.val, false);\\n        \\n        dfs(node.left, sum, true);\\n        dfs(node.right, sum, true);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction dfs(...) {\\n\\tdfs()\\n\\tdfs()\\n}\\n```\n```\\nvar pathSum = (root, sum) => {\\n    let count = 0;\\n    let startedFrom = new Set();\\n    dfs(root, sum, true); // the `true` here doesn\\'t matter, you can\\'t visit root node twice.\\n    return count;\\n    \\n    function dfs(node, remaining, isStartingFromThisNode) {\\n        if(!node) return;\\n        \\n        if(isStartingFromThisNode) {\\n            // Trick: only start from this node once throughout the whole solution\\n            // doing 2 dfs() calls from each node means each node of depth h gets visited 2^h times, which is undesirable\\n            if(startedFrom.has(node)) return;\\n            startedFrom.add(node);\\n        }\\n        \\n        if(remaining - node.val === 0) {\\n            count++;\\n        }\\n            \\n        dfs(node.left, remaining-node.val, false);\\n        dfs(node.right, remaining-node.val, false);\\n        \\n        dfs(node.left, sum, true);\\n        dfs(node.right, sum, true);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201160,
                "title": "simple-python-recursion",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.count=0\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        def helper(root,su):\\n            if not root: return \\n            if su+root.val==sum:\\n                self.count+=1\\n            if root.left:\\n                helper(root.left,su+root.val)\\n            if root.right:\\n                helper(root.right,su+root.val)\\n            \\n        \\n        if not root: return 0\\n        \\n        helper(root,0)\\n     \\n        if root.left:\\n            self.pathSum(root.left, sum)\\n        if root.right:\\n            self.pathSum(root.right, sum)\\n        return self.count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.count=0\\n    def pathSum(self, root, sum):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        def helper(root,su):\\n            if not root: return \\n            if su+root.val==sum:\\n                self.count+=1\\n            if root.left:\\n                helper(root.left,su+root.val)\\n            if root.right:\\n                helper(root.right,su+root.val)\\n            \\n        \\n        if not root: return 0\\n        \\n        helper(root,0)\\n     \\n        if root.left:\\n            self.pathSum(root.left, sum)\\n        if root.right:\\n            self.pathSum(root.right, sum)\\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197943,
                "title": "my-elegant-8ms-java-solution-beats-99",
                "content": "```\\nclass Solution {\\n    int result = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        map.put(0, 1); // to handle the root\\n        dfs(map, root, 0, sum);\\n        return result;\\n    }\\n    public void dfs(Map<Integer, Integer> map, TreeNode root, int here, int sum) {\\n        if (root == null) {\\n            return;\\n        }\\n        here += root.val;\\n        result += map.getOrDefault(here - sum, 0);\\n        map.put(here, map.getOrDefault(here, 0) + 1); // update the frequency\\n        dfs(map, root.left, here, sum);\\n        dfs(map, root.right, here, sum);\\n        map.put(here, map.get(here) - 1); // backtrack the modification of the frequency of here, \\n                                          // we don\\'t want our sibling nodes knows our presum\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int result = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        map.put(0, 1); // to handle the root\\n        dfs(map, root, 0, sum);\\n        return result;\\n    }\\n    public void dfs(Map<Integer, Integer> map, TreeNode root, int here, int sum) {\\n        if (root == null) {\\n            return;\\n        }\\n        here += root.val;\\n        result += map.getOrDefault(here - sum, 0);\\n        map.put(here, map.getOrDefault(here, 0) + 1); // update the frequency\\n        dfs(map, root.left, here, sum);\\n        dfs(map, root.right, here, sum);\\n        map.put(here, map.get(here) - 1); // backtrack the modification of the frequency of here, \\n                                          // we don\\'t want our sibling nodes knows our presum\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128654,
                "title": "python-3-iterative-and-recursive-solution",
                "content": "For the iterative post-order traversal algorithm, check the following link for more detail:\\nhttps://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45539/Iterative-method-to-do-three-kinds-of-traversal-just-like-recursive-method-only-changing-one-line-code\\n\\n```\\nclass Solution_iterative_postorder:\\n    def pathSum(self, root, target):\\n        count, total, d = 0, 0, {0: 1}\\n        stack = [(0, root)]\\n        while stack:\\n            seen, node = stack.pop()\\n            if node is None:\\n                continue\\n            if not seen:\\n                stack.extend([(1, node), (0, node.right), (0, node.left)])\\n                total += node.val\\n                count += d.get(total - target, 0)\\n                d[total] = d.get(total, 0) + 1\\n            else:\\n                d[total] -= 1\\n                total -= node.val\\n        return count\\n\\n\\nclass Solution_recursive_with_dict:\\n    def pathSum(self, root, target):\\n        def helper(root, target, d, total):\\n            if root is None:\\n                return 0\\n            total += root.val\\n            count = d.get(total - target, 0)\\n            d[total] = d.get(total, 0) + 1\\n            count += helper(root.left, target, d, total) + helper(root.right, target, d, total)\\n            d[total] -= 1\\n            return count\\n\\n        return helper(root, target, {0: 1}, 0)\\n\\n\\n# search for pathSum for every node in root\\nclass Solution_naive_recursive:\\n    def pathSum(self, root, target):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        return self.path(root, target, 0) + self.pathSum(root.left, target) + self.pathSum(root.right, target)\\n\\n    def path(self, root, target, total):\\n        if root is None:\\n            return 0\\n        total += root.val\\n        if total == target:\\n            return 1 + self.path(root.left, target, total) + self.path(root.right, target, total)\\n        return self.path(root.left, target, total) + self.path(root.right, target, total)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution_iterative_postorder:\\n    def pathSum(self, root, target):\\n        count, total, d = 0, 0, {0: 1}\\n        stack = [(0, root)]\\n        while stack:\\n            seen, node = stack.pop()\\n            if node is None:\\n                continue\\n            if not seen:\\n                stack.extend([(1, node), (0, node.right), (0, node.left)])\\n                total += node.val\\n                count += d.get(total - target, 0)\\n                d[total] = d.get(total, 0) + 1\\n            else:\\n                d[total] -= 1\\n                total -= node.val\\n        return count\\n\\n\\nclass Solution_recursive_with_dict:\\n    def pathSum(self, root, target):\\n        def helper(root, target, d, total):\\n            if root is None:\\n                return 0\\n            total += root.val\\n            count = d.get(total - target, 0)\\n            d[total] = d.get(total, 0) + 1\\n            count += helper(root.left, target, d, total) + helper(root.right, target, d, total)\\n            d[total] -= 1\\n            return count\\n\\n        return helper(root, target, {0: 1}, 0)\\n\\n\\n# search for pathSum for every node in root\\nclass Solution_naive_recursive:\\n    def pathSum(self, root, target):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type sum: int\\n        :rtype: int\\n        \"\"\"\\n        if root is None:\\n            return 0\\n        return self.path(root, target, 0) + self.pathSum(root.left, target) + self.pathSum(root.right, target)\\n\\n    def path(self, root, target, total):\\n        if root is None:\\n            return 0\\n        total += root.val\\n        if total == target:\\n            return 1 + self.path(root.left, target, total) + self.path(root.right, target, total)\\n        return self.path(root.left, target, total) + self.path(root.right, target, total)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 91895,
                "title": "javascript-solution-bfs-and-dfs-with-explanation",
                "content": "1) The idea here is to use BFS to hit each node in the tree using a queue and a while loop. We want to hit each node because each node is a potential start node to reach the target sum. \\n2) We will call dfs on each node to get the path each node takes to get to the bottom of the tree. \\n3) We keep track of a number called carrySum and we pass this variable to the next recursive dfs function call. This carrySum keeps track of the running sum(adding node.val in each recursive step) for each node we hit in the first step(BFS).\\n4) If we ever get a carrySum ==== sum, we increment our counter by 1!\\n```\\nvar pathSum = function(root, sum) {\\n    if(root === null) return 0;\\n    const queue = [root];\\n    let count = 0;\\n    \\n    function dfs(node, carrySum) {\\n        if(!node) return;\\n        carrySum += node.val\\n        \\n        \\n        if(carrySum === sum) {\\n            count += 1;\\n        }\\n        dfs(node.left, carrySum);\\n        dfs(node.right, carrySum);    \\n        \\n    }\\n    \\n    while(queue.length > 0) {\\n        const currentNode = queue.shift();\\n        \\n        if(currentNode) {\\n            queue.push(currentNode.left);\\n            queue.push(currentNode.right);\\n            dfs(currentNode, 0);    \\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar pathSum = function(root, sum) {\\n    if(root === null) return 0;\\n    const queue = [root];\\n    let count = 0;\\n    \\n    function dfs(node, carrySum) {\\n        if(!node) return;\\n        carrySum += node.val\\n        \\n        \\n        if(carrySum === sum) {\\n            count += 1;\\n        }\\n        dfs(node.left, carrySum);\\n        dfs(node.right, carrySum);    \\n        \\n    }\\n    \\n    while(queue.length > 0) {\\n        const currentNode = queue.shift();\\n        \\n        if(currentNode) {\\n            queue.push(currentNode.left);\\n            queue.push(currentNode.right);\\n            dfs(currentNode, 0);    \\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91987,
                "title": "java-solution-by-using-dfs-two-times",
                "content": "```\\npublic class Solution {\\n    int count = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n        if (root != null){\\n            fun(root,sum);\\n            pathSum(root.left,sum);\\n            pathSum(root.right,sum);\\n        }\\n        return count;\\n    }\\n    public void fun(TreeNode root,int sum){\\n        if (root != null){\\n            if (sum - root.val == 0){\\n                count++;\\n            }\\n            fun(root.left,sum - root.val);\\n            fun(root.right,sum - root.val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int count = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n        if (root != null){\\n            fun(root,sum);\\n            pathSum(root.left,sum);\\n            pathSum(root.right,sum);\\n        }\\n        return count;\\n    }\\n    public void fun(TreeNode root,int sum){\\n        if (root != null){\\n            if (sum - root.val == 0){\\n                count++;\\n            }\\n            fun(root.left,sum - root.val);\\n            fun(root.right,sum - root.val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92002,
                "title": "c-dfs",
                "content": "class Solution {\\n\\n    public:\\n        int num = 0;\\n\\n    public:\\n        void dfs_counting(TreeNode* root, int sum){\\n            if(root == NULL) return;\\n            sum -= root->val;\\n            if(0 == sum) num++;\\n            if(root->left){\\n                dfs_counting(root->left, sum);\\n            }\\n            if(root->right){\\n                dfs_counting(root->right, sum);\\n            }\\n        }\\n\\n    void dfs(TreeNode* root, int sum){\\n        if(root == NULL) return;\\n        dfs_counting(root, sum);\\n        if(root->left){\\n            dfs(root->left, sum);\\n        }\\n        if(root->right){\\n            dfs(root->right, sum);\\n        }\\n    }\\n\\n    int pathSum(TreeNode* root, int sum) {\\n        dfs(root, sum);\\n        return num;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\n    public:\\n        int num = 0;\\n\\n    public:\\n        void dfs_counting(TreeNode* root, int sum){\\n            if(root == NULL) return;\\n            sum -= root->val;\\n            if(0 == sum) num++;\\n            if(root->left){\\n                dfs_counting(root->left, sum);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3589899,
                "title": "hashmap-long-long-easy-code",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result=0;\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root == null)return 0;\\n        HashMap<Long,Integer>map=new HashMap<>();\\n\\n        map.put(0l,1);\\n        long sum=0;\\n        find_Sum(root,sum,targetSum,map);\\n        return result;\\n    }\\n    public void find_Sum(TreeNode curr,long sum,int target, HashMap<Long,Integer>map){\\n        if(curr==null)return ;\\n        sum+=curr.val;\\n\\n        if(map.containsKey(sum-target))\\n        result+=map.get(sum-target);\\n\\n        map.put(sum,map.getOrDefault(sum,0)+1);\\n        find_Sum(curr.left,sum,target,map);\\n        find_Sum(curr.right,sum,target,map);\\n        map.put(sum,map.get(sum)-1);\\n        return ;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result=0;\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root == null)return 0;\\n        HashMap<Long,Integer>map=new HashMap<>();\\n\\n        map.put(0l,1);\\n        long sum=0;\\n        find_Sum(root,sum,targetSum,map);\\n        return result;\\n    }\\n    public void find_Sum(TreeNode curr,long sum,int target, HashMap<Long,Integer>map){\\n        if(curr==null)return ;\\n        sum+=curr.val;\\n\\n        if(map.containsKey(sum-target))\\n        result+=map.get(sum-target);\\n\\n        map.put(sum,map.getOrDefault(sum,0)+1);\\n        find_Sum(curr.left,sum,target,map);\\n        find_Sum(curr.right,sum,target,map);\\n        map.put(sum,map.get(sum)-1);\\n        return ;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478445,
                "title": "python-simple-clean-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], k: int) -> int:\\n        def helper(root, currSum):\\n            if not root: return \\n            \\n            nonlocal paths\\n\\n            currSum += root.val\\n            if m[currSum - k] != 0:\\n                paths += m[currSum - k]\\n\\n            m[currSum] += 1\\n            helper(root.left, currSum)\\n            helper(root.right, currSum) \\n            m[currSum] -= 1\\n\\n        paths = 0\\n        m = defaultdict(int)\\n        m[0] = 1\\n        \\n        helper(root, 0)\\n\\n        return paths\\n```\\n\\n```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], k: int) -> int:\\n        def take(root, s):\\n            if not root:\\n                return 0\\n            res = 0\\n            if root.val == s: res += 1\\n            res += take(root.left, s - root.val) + take(root.right, s - root.val)\\n            return res\\n        \\n        if not root:\\n            return 0\\n        return self.pathSum(root.left, k) + self.pathSum(root.right, k) + take(root, k)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], k: int) -> int:\\n        def helper(root, currSum):\\n            if not root: return \\n            \\n            nonlocal paths\\n\\n            currSum += root.val\\n            if m[currSum - k] != 0:\\n                paths += m[currSum - k]\\n\\n            m[currSum] += 1\\n            helper(root.left, currSum)\\n            helper(root.right, currSum) \\n            m[currSum] -= 1\\n\\n        paths = 0\\n        m = defaultdict(int)\\n        m[0] = 1\\n        \\n        helper(root, 0)\\n\\n        return paths\\n```\n```\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], k: int) -> int:\\n        def take(root, s):\\n            if not root:\\n                return 0\\n            res = 0\\n            if root.val == s: res += 1\\n            res += take(root.left, s - root.val) + take(root.right, s - root.val)\\n            return res\\n        \\n        if not root:\\n            return 0\\n        return self.pathSum(root.left, k) + self.pathSum(root.right, k) + take(root, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371061,
                "title": "easiest-inorder-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    long count = 0;\\n    long simi = 0;\\n    long numele = 0;\\n    \\n    public void pathi(TreeNode root , int targetSum , long simi) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(simi == targetSum) {\\n            count++;\\n        }\\n        if(root.left != null) {\\n            pathi(root.left , targetSum , simi + root.left.val);\\n        }\\n        if(root.right != null) {\\n            pathi(root.right , targetSum , simi + root.right.val);\\n        }\\n    }\\n\\n    public void inorder(TreeNode root , int targetSum) {\\n        if(root != null) {\\n            numele++;\\n            inorder(root.left , targetSum);\\n            pathi(root , targetSum , root.val);\\n            inorder(root.right , targetSum);\\n        }\\n    }\\n    \\n    public int pathSum(TreeNode root, int targetSum) {\\n        inorder(root, targetSum);\\n        return (int)count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    long count = 0;\\n    long simi = 0;\\n    long numele = 0;\\n    \\n    public void pathi(TreeNode root , int targetSum , long simi) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(simi == targetSum) {\\n            count++;\\n        }\\n        if(root.left != null) {\\n            pathi(root.left , targetSum , simi + root.left.val);\\n        }\\n        if(root.right != null) {\\n            pathi(root.right , targetSum , simi + root.right.val);\\n        }\\n    }\\n\\n    public void inorder(TreeNode root , int targetSum) {\\n        if(root != null) {\\n            numele++;\\n            inorder(root.left , targetSum);\\n            pathi(root , targetSum , root.val);\\n            inorder(root.right , targetSum);\\n        }\\n    }\\n    \\n    public int pathSum(TreeNode root, int targetSum) {\\n        inorder(root, targetSum);\\n        return (int)count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659996,
                "title": "c-solution",
                "content": "*****SUGGESTION**:\\nWhen we are trying to approach a problem, we should always start from brute force solution, even though you have been trained by solving a lot of similar problems previously and been able to give a O(N) solution off the top of your head, I still recommend you to start from a brute force solution. This is the only way you can avoid geting stuck in your fixed mindset when you encounter a completely unseen or unfamiliar problem that unfortunately doesn\\'t match any existing pattern in your trained mind.***\\n```\\nclass Solution {\\n    private:\\n    int result;\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        result=0;\\n        long long sum=0;\\n        inorderTraversal(root,targetSum,sum);\\n     return result;  \\n    }\\n    \\n    void inorderTraversal(TreeNode* root,int &targetSum,long long &sum)\\n    {\\n        if(!root)\\n            return;\\n        result+=fun(root,targetSum,sum);\\n        inorderTraversal(root->left,targetSum,sum);\\n        inorderTraversal(root->right,targetSum,sum);\\n    }\\n    int fun(TreeNode* root,int &targetSum,long long sum)\\n    { \\n        if(!root)\\n            return 0;\\n         \\n        // Do pre-calculation\\n        int ans=0;\\n        sum+=root->val;\\n            if(targetSum==sum)\\n               ans+=1;\\n        ans+=fun(root->left,targetSum,sum);\\n        ans+=fun(root->right,targetSum,sum);\\n        sum-=root->val;\\n        return ans;\\n    }\\n};\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n^2)\\n\\n** Accepted **\\n```\\n\\n```\\nclass Solution {\\n    private:\\n    int result;\\n    unordered_map<long,int>mp;\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        result=0;\\n        long long sum=0;\\n        mp[0]=1;\\n        fun(root,targetSum,sum);\\n        return result;    \\n    }\\n    void fun(TreeNode* root,int &targetSum,long long &sum)\\n    {\\n        // Base Case\\n        if(!root)\\n            return;\\n        \\n        // Recursive Case\\n            // Do pre-calculation\\n                sum+=root->val;\\n           // Check if there is path exist for targetSum\\n                if(mp[sum-targetSum])\\n                    result+=mp[sum-targetSum];\\n             // Add element in hashmap, \\n               mp[sum]++;\\n            \\n          // Go on left subtree\\n            fun(root->left,targetSum,sum);\\n          // Go on right subtree\\n            fun(root->right,targetSum,sum);\\n          \\n          // Do post-calculation\\n          mp[sum]--;\\n          sum-=root->val;\\n         \\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)+O(n), Hashmap + Recursive Stack\\n\\n** Accepted **\\n```\\n\\n***Please correct me if i take time complexity wrong.***\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELPFUL, MEANS A LOT ;)***\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int result;\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        result=0;\\n        long long sum=0;\\n        inorderTraversal(root,targetSum,sum);\\n     return result;  \\n    }\\n    \\n    void inorderTraversal(TreeNode* root,int &targetSum,long long &sum)\\n    {\\n        if(!root)\\n            return;\\n        result+=fun(root,targetSum,sum);\\n        inorderTraversal(root->left,targetSum,sum);\\n        inorderTraversal(root->right,targetSum,sum);\\n    }\\n    int fun(TreeNode* root,int &targetSum,long long sum)\\n    { \\n        if(!root)\\n            return 0;\\n         \\n        // Do pre-calculation\\n        int ans=0;\\n        sum+=root->val;\\n            if(targetSum==sum)\\n               ans+=1;\\n        ans+=fun(root->left,targetSum,sum);\\n        ans+=fun(root->right,targetSum,sum);\\n        sum-=root->val;\\n        return ans;\\n    }\\n};\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n^2)\\n\\n** Accepted **\\n```\n```\\nclass Solution {\\n    private:\\n    int result;\\n    unordered_map<long,int>mp;\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        result=0;\\n        long long sum=0;\\n        mp[0]=1;\\n        fun(root,targetSum,sum);\\n        return result;    \\n    }\\n    void fun(TreeNode* root,int &targetSum,long long &sum)\\n    {\\n        // Base Case\\n        if(!root)\\n            return;\\n        \\n        // Recursive Case\\n            // Do pre-calculation\\n                sum+=root->val;\\n           // Check if there is path exist for targetSum\\n                if(mp[sum-targetSum])\\n                    result+=mp[sum-targetSum];\\n             // Add element in hashmap, \\n               mp[sum]++;\\n            \\n          // Go on left subtree\\n            fun(root->left,targetSum,sum);\\n          // Go on right subtree\\n            fun(root->right,targetSum,sum);\\n          \\n          // Do post-calculation\\n          mp[sum]--;\\n          sum-=root->val;\\n         \\n    }\\n};\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)+O(n), Hashmap + Recursive Stack\\n\\n** Accepted **\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421926,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    int count = 0;\\n    public int pathSum(TreeNode root, int targetSum) {\\n        \\n        countTarget_temp(root , targetSum);\\n        return count;\\n    }\\n    public void countTarget_temp(TreeNode node , int targetSum){\\n        if(node == null){\\n            return;\\n        }\\n        //if(node.val == -2)\\n        countTarget(node , 0 , targetSum);\\n        \\n        countTarget_temp(node.left , targetSum);\\n        countTarget_temp(node.right , targetSum);\\n    }\\n    \\n    public void countTarget(TreeNode node , long csum , int targetSum){\\n        if(node == null){\\n\\n            return;\\n        }\\n        //System.out.println(node.val + \" \" + csum);\\n        if(csum+node.val == targetSum){\\n            //System.out.println(csum  + \" \" + node.val);\\n            count++;\\n        }\\n        countTarget(node.left , csum+node.val , targetSum);\\n        countTarget(node.right , csum+node.val , targetSum);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    int count = 0;\\n    public int pathSum(TreeNode root, int targetSum) {\\n        \\n        countTarget_temp(root , targetSum);\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2321965,
                "title": "java-recursive-arraylist-accepted-solution",
                "content": "**Status: Accepted***\\nRuntime: 7 ms\\nMemory Usage: 44.4 MB\\n128 / 128 test cases passed.\\n\\n***plz... upvote! if you find my solution helpful.***\\n\\n```\\nclass Solution {\\n    int count =0;\\n    ArrayList<Long> list = new ArrayList<>();\\n    public int pathSum(TreeNode root, int targetSum) {\\n        getSum(root, targetSum);\\n        return count;\\n    }\\n    public void getSum(TreeNode root, int sum) {\\n        if(root == null) return;\\n        list.add((long)root.val);\\n        getSum(root.left, sum);\\n        getSum(root.right, sum);\\n        long temp =0;\\n        for(int i=list.size()-1; i>=0; i--) {\\n            temp += list.get(i);\\n            if(temp == sum) {\\n                count++;\\n            }\\n        }\\n        list.remove(list.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count =0;\\n    ArrayList<Long> list = new ArrayList<>();\\n    public int pathSum(TreeNode root, int targetSum) {\\n        getSum(root, targetSum);\\n        return count;\\n    }\\n    public void getSum(TreeNode root, int sum) {\\n        if(root == null) return;\\n        list.add((long)root.val);\\n        getSum(root.left, sum);\\n        getSum(root.right, sum);\\n        long temp =0;\\n        for(int i=list.size()-1; i>=0; i--) {\\n            temp += list.get(i);\\n            if(temp == sum) {\\n                count++;\\n            }\\n        }\\n        list.remove(list.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309165,
                "title": "dfs-2-solutions-9ms",
                "content": "**Be careful with your shallow copy and deep copy in the currentPath parameter**\\n- As you see in my 1st solution: I use deep copy for every new currentPath, that would be a little bit slower, but you don\\'t need to remove the last item you append to the recursion stack later (The line before the return statement)\\n\\t- Deep copy\\n\\t`newCurrentPath := make([]int, len(currentPath))`\\n    `copy(newCurrentPath, currentPath)`\\n\\n- In 2nd solution, I use the shallow copy, basically, it means all the recursion use the same currentPath, that\\'s why you need to remove item from recursion stack (The line before the return statement)\\n\\t- Shallow copy\\n\\tThen need to remove \\n\\t`currentPath = currentPath[:len(currentPath)-1]`\\n\\n```\\nfunc pathSum(root *TreeNode, targetSum int) int {\\n    return dfs(root, targetSum, []int{})\\n}\\n\\nfunc dfs(root *TreeNode, target int, currentPath []int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    newCurrentPath := make([]int, len(currentPath))\\n    copy(newCurrentPath, currentPath)\\n    \\n    newCurrentPath = append(newCurrentPath, root.Val)\\n    pathCount, pathSum := 0, 0\\n    \\n    for i := len(newCurrentPath)-1; i >= 0; i-- {\\n        pathSum += newCurrentPath[i]\\n        \\n        if pathSum == target {\\n            pathCount++\\n        }\\n    }\\n    \\n    pathCount += dfs(root.Left, target, newCurrentPath)\\n    pathCount += dfs(root.Right, target, newCurrentPath)\\n    \\n    return pathCount\\n}\\n```\\n\\n```\\nfunc pathSum(root *TreeNode, targetSum int) int {\\n    return dfs(root, targetSum, []int{})\\n}\\n\\nfunc dfs(root *TreeNode, target int, currentPath []int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    currentPath = append(currentPath, root.Val)\\n    pathCount, pathSum := 0, 0\\n    \\n    for i := len(currentPath)-1; i >= 0; i-- {\\n        pathSum += currentPath[i]\\n        \\n        if pathSum == target {\\n            pathCount++\\n        }\\n    }\\n    \\n    pathCount += dfs(root.Left, target, currentPath)\\n    pathCount += dfs(root.Right, target, currentPath)\\n    \\n    currentPath = currentPath[:len(currentPath)-1]\\n    \\n    return pathCount\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfunc pathSum(root *TreeNode, targetSum int) int {\\n    return dfs(root, targetSum, []int{})\\n}\\n\\nfunc dfs(root *TreeNode, target int, currentPath []int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    newCurrentPath := make([]int, len(currentPath))\\n    copy(newCurrentPath, currentPath)\\n    \\n    newCurrentPath = append(newCurrentPath, root.Val)\\n    pathCount, pathSum := 0, 0\\n    \\n    for i := len(newCurrentPath)-1; i >= 0; i-- {\\n        pathSum += newCurrentPath[i]\\n        \\n        if pathSum == target {\\n            pathCount++\\n        }\\n    }\\n    \\n    pathCount += dfs(root.Left, target, newCurrentPath)\\n    pathCount += dfs(root.Right, target, newCurrentPath)\\n    \\n    return pathCount\\n}\\n```\n```\\nfunc pathSum(root *TreeNode, targetSum int) int {\\n    return dfs(root, targetSum, []int{})\\n}\\n\\nfunc dfs(root *TreeNode, target int, currentPath []int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    \\n    currentPath = append(currentPath, root.Val)\\n    pathCount, pathSum := 0, 0\\n    \\n    for i := len(currentPath)-1; i >= 0; i-- {\\n        pathSum += currentPath[i]\\n        \\n        if pathSum == target {\\n            pathCount++\\n        }\\n    }\\n    \\n    pathCount += dfs(root.Left, target, currentPath)\\n    pathCount += dfs(root.Right, target, currentPath)\\n    \\n    currentPath = currentPath[:len(currentPath)-1]\\n    \\n    return pathCount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604056,
                "title": "solution-similar-to-subarray-target-sum-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int pathSum(TreeNode* root, int targetSum) {\\n        map<int, int> seen;\\n        seen[0]=1;\\n        solve(root, seen, targetSum, 0);\\n        return ans;\\n    }\\n    \\n    void solve(TreeNode* root, map<int, int> seen, int k, int cur_sum){\\n        if(root==nullptr)\\n            return;\\n        \\n        cur_sum+=root->val;\\n        if(seen[cur_sum-k]>0)\\n            ans+=seen[cur_sum-k];\\n        \\n        seen[cur_sum]++;\\n        solve(root->left, seen, k, cur_sum);\\n        solve(root->right, seen, k, cur_sum);\\n    }\\n};\\n```\\nI am keeping track of all the sums visited on each path by passing a copy of hashmap onto each time so that it contains the sums encountered on that path only. If we are at cur_sum and have encountered cur_sum-target on our path then we add this path into our answer.\\n\\nP.S.-My first post on Leetcode, be nice :) .",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int pathSum(TreeNode* root, int targetSum) {\\n        map<int, int> seen;\\n        seen[0]=1;\\n        solve(root, seen, targetSum, 0);\\n        return ans;\\n    }\\n    \\n    void solve(TreeNode* root, map<int, int> seen, int k, int cur_sum){\\n        if(root==nullptr)\\n            return;\\n        \\n        cur_sum+=root->val;\\n        if(seen[cur_sum-k]>0)\\n            ans+=seen[cur_sum-k];\\n        \\n        seen[cur_sum]++;\\n        solve(root->left, seen, k, cur_sum);\\n        solve(root->right, seen, k, cur_sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492698,
                "title": "c-recursive-solution",
                "content": "```\\nint ans = 0;\\n\\nvoid findSum(TreeNode *root, int sum, int target){\\n    if (!root) return;\\n    sum += root->val;\\n    if (sum == target) ans++;\\n    findSum(root->left, sum, target);\\n    findSum(root->right, sum, target);\\n}\\n\\nvoid path(TreeNode *root, int target){\\n    if (!root) return;\\n    findSum(root, 0, target);\\n    path(root->left, target);\\n    path(root->right, target);\\n}\\n\\nint pathSum(TreeNode *root, int targetSum){\\n    path(root, targetSum);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint ans = 0;\\n\\nvoid findSum(TreeNode *root, int sum, int target){\\n    if (!root) return;\\n    sum += root->val;\\n    if (sum == target) ans++;\\n    findSum(root->left, sum, target);\\n    findSum(root->right, sum, target);\\n}\\n\\nvoid path(TreeNode *root, int target){\\n    if (!root) return;\\n    findSum(root, 0, target);\\n    path(root->left, target);\\n    path(root->right, target);\\n}\\n\\nint pathSum(TreeNode *root, int targetSum){\\n    path(root, targetSum);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1394845,
                "title": "easy-to-understand-simple-beginners-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    void getNodes(TreeNode* root, vector<TreeNode*>&v)\\n    {\\n        if(root==NULL)\\n            return;\\n        v.push_back(root);\\n        getNodes(root->left,v);\\n        getNodes(root->right,v);\\n    }\\n    void sumOfNodes(TreeNode*root,int targetSum,int sum, int &totSum)\\n    {\\n        if(root==NULL)\\n            return;\\n        sum+=root->val;\\n        if(sum==targetSum)\\n           totSum+=1;\\n        sumOfNodes(root->left,targetSum,sum,totSum);\\n        sumOfNodes(root->right,targetSum,sum,totSum);\\n    }\\n    int pathSum(TreeNode* root, int targetSum) \\n    {\\n        vector<TreeNode*>v;\\n        getNodes(root,v);\\n        //totSum -> tot_paths_with_TargetSum;\\n        int totSum=0;\\n        for(auto it: v)\\n        {\\n            sumOfNodes(it,targetSum,0,totSum);\\n        }\\n        return totSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void getNodes(TreeNode* root, vector<TreeNode*>&v)\\n    {\\n        if(root==NULL)\\n            return;\\n        v.push_back(root);\\n        getNodes(root->left,v);\\n        getNodes(root->right,v);\\n    }\\n    void sumOfNodes(TreeNode*root,int targetSum,int sum, int &totSum)\\n    {\\n        if(root==NULL)\\n            return;\\n        sum+=root->val;\\n        if(sum==targetSum)\\n           totSum+=1;\\n        sumOfNodes(root->left,targetSum,sum,totSum);\\n        sumOfNodes(root->right,targetSum,sum,totSum);\\n    }\\n    int pathSum(TreeNode* root, int targetSum) \\n    {\\n        vector<TreeNode*>v;\\n        getNodes(root,v);\\n        //totSum -> tot_paths_with_TargetSum;\\n        int totSum=0;\\n        for(auto it: v)\\n        {\\n            sumOfNodes(it,targetSum,0,totSum);\\n        }\\n        return totSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352876,
                "title": "python-dictionary-faster-than-91-02",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    count = 0\\n    \\n    def getans(self, root, targetSum, cursum, D):\\n        if not root: return\\n        cursum += root.val;\\n        if D[cursum-targetSum] != 0: self.count += D[cursum-targetSum]\\n        D[cursum] += 1\\n        self.getans(root.left, targetSum, cursum, D)\\n        self.getans(root.right, targetSum, cursum, D)\\n        D[cursum] -= 1\\n    \\n    def pathSum(self, root: TreeNode, targetSum: int) -> int:\\n        D = defaultdict(int)\\n        D[0] = 1\\n        self.getans(root, targetSum, 0, D)\\n        return self.count\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    count = 0\\n    \\n    def getans(self, root, targetSum, cursum, D):\\n        if not root: return\\n        cursum += root.val;\\n        if D[cursum-targetSum] != 0: self.count += D[cursum-targetSum]\\n        D[cursum] += 1\\n        self.getans(root.left, targetSum, cursum, D)\\n        self.getans(root.right, targetSum, cursum, D)\\n        D[cursum] -= 1\\n    \\n    def pathSum(self, root: TreeNode, targetSum: int) -> int:\\n        D = defaultdict(int)\\n        D[0] = 1\\n        self.getans(root, targetSum, 0, D)\\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238555,
                "title": "simple-python3-using-recursion-and-prefix-sum-dictionary-o-n",
                "content": "Explanation: Use dfs to go through every path in the tree and then keep track of prefix sum of path. Since we keep track of the prefix sum in a dictionary we can check if a subpath has sum target in O(1) time by querying our dictionary.\\n\\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> int:\\n        from collections import defaultdict\\n        \\n        if root is None:\\n            return 0\\n        \\n        self.count = 0\\n        self.target = targetSum\\n        cache = defaultdict(int, {0: 1})\\n        self.dfs(root, cache, 0)\\n        \\n        return self.count\\n        \\n    \\n    def dfs(self, node, cache, val):\\n        \\n        val += node.val\\n        self.count += cache[val - self.target]\\n        cache[val] += 1\\n        \\n        if node.left:\\n            self.dfs(node.left, cache, val)\\n        \\n        if node.right:\\n            self.dfs(node.right, cache, val)\\n        \\n        cache[val] -=1\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, targetSum: int) -> int:\\n        from collections import defaultdict\\n        \\n        if root is None:\\n            return 0\\n        \\n        self.count = 0\\n        self.target = targetSum\\n        cache = defaultdict(int, {0: 1})\\n        self.dfs(root, cache, 0)\\n        \\n        return self.count\\n        \\n    \\n    def dfs(self, node, cache, val):\\n        \\n        val += node.val\\n        self.count += cache[val - self.target]\\n        cache[val] += 1\\n        \\n        if node.left:\\n            self.dfs(node.left, cache, val)\\n        \\n        if node.right:\\n            self.dfs(node.right, cache, val)\\n        \\n        cache[val] -=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933097,
                "title": "from-n-2-by-using-array-to-n-by-using-hashmap-solution",
                "content": "So the main idea for the first solution is that the sum we get at each level for each path is appended and updated in the array and then we check if any of the sums are equal to our required sum.\\n\\nin the worse case of a list it will have N elements in array and time complexity will be N*N.\\n\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int pathSum(TreeNode* root, int sum) {\\n        vector<int> arr;\\n        dfs(root,sum,arr);\\n        return ans;\\n    }\\n    \\n    void dfs(TreeNode* root,int sum,vector<int>arr)\\n    {\\n        if(root==NULL) return;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            arr[i]=arr[i]+root->val;\\n            \\n            if(arr[i]==sum)\\n            {\\n                ans++;\\n            }\\n        }\\n        if(root->val==sum) ans++;\\n        arr.push_back(root->val);\\n        \\n        dfs(root->left,sum,arr);\\n        dfs(root->right,sum,arr);\\n        \\n        return;\\n        \\n    }\\n};\\n```\\n\\nA much more effecient solution can be obtained by using a hashmap , again the idea will be kinda same that we will be storing the the sum at each level of the path to the hashmap.\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int pathSum(TreeNode* root, int sum) {\\n        unordered_map<int,int> hashmap;\\n        hashmap[0]=1;\\n        dfs(root,sum,0,hashmap);\\n        return ans;\\n        \\n    }\\n    \\n    \\n    void dfs( TreeNode* root,int req_Sum,int so_Far,unordered_map<int,int> hashmap)\\n    {\\n        if(root==NULL) return;\\n        \\n        int curr_Sum=so_Far+root->val;\\n        \\n        if(hashmap.find(curr_Sum-req_Sum)!=hashmap.end())\\n        {\\n            ans+=hashmap[curr_Sum-req_Sum];\\n        }\\n        hashmap[curr_Sum]+=1;\\n        \\n    dfs(root->left,req_Sum,curr_Sum,hashmap);\\n    dfs(root->right,req_Sum,curr_Sum,hashmap);\\n\\n        \\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int pathSum(TreeNode* root, int sum) {\\n        vector<int> arr;\\n        dfs(root,sum,arr);\\n        return ans;\\n    }\\n    \\n    void dfs(TreeNode* root,int sum,vector<int>arr)\\n    {\\n        if(root==NULL) return;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            arr[i]=arr[i]+root->val;\\n            \\n            if(arr[i]==sum)\\n            {\\n                ans++;\\n            }\\n        }\\n        if(root->val==sum) ans++;\\n        arr.push_back(root->val);\\n        \\n        dfs(root->left,sum,arr);\\n        dfs(root->right,sum,arr);\\n        \\n        return;\\n        \\n    }\\n};\\n```\n```\\n\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int pathSum(TreeNode* root, int sum) {\\n        unordered_map<int,int> hashmap;\\n        hashmap[0]=1;\\n        dfs(root,sum,0,hashmap);\\n        return ans;\\n        \\n    }\\n    \\n    \\n    void dfs( TreeNode* root,int req_Sum,int so_Far,unordered_map<int,int> hashmap)\\n    {\\n        if(root==NULL) return;\\n        \\n        int curr_Sum=so_Far+root->val;\\n        \\n        if(hashmap.find(curr_Sum-req_Sum)!=hashmap.end())\\n        {\\n            ans+=hashmap[curr_Sum-req_Sum];\\n        }\\n        hashmap[curr_Sum]+=1;\\n        \\n    dfs(root->left,req_Sum,curr_Sum,hashmap);\\n    dfs(root->right,req_Sum,curr_Sum,hashmap);\\n\\n        \\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887339,
                "title": "c-dfs-subarray-sum-like-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/path-sum-iii/\\n    \\n    TC: O(N)\\n    SC: O(N), worst case: skewed tree\\n    \\n    Since the paths to check for start from top and continue from parent to\\n    child subtrees. So each path from parent A to a node in some nested subchild \\n    B is basically a path which can have sum equivalent to req. sum. We can look\\n    at the problem as finding a subarray sum in an array which matches the given sum.\\n    SO to do that we start tracking all the sums seen during traversal from\\n    top to bottom and at each node also check if we found paths matching the req. sum.\\n*/\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findPaths(TreeNode* root, int sum, int path,\\n                   int &paths, unordered_map<int, int>& path_sums) {\\n        if(root) {\\n            // add current node to path\\n            path += root->val;\\n            // check the number of paths found with req. sum\\n            paths += path_sums[path - sum];\\n            // Add the current path to the \\n            ++path_sums[path];\\n\\n            findPaths(root->left, sum, path, paths, path_sums);\\n            findPaths(root->right, sum, path, paths, path_sums);\\n            // remove the current path from visited paths\\n            --path_sums[path];\\n        }    \\n    }\\n\\n    int pathSum(TreeNode* root, int sum) {\\n        int paths = 0;\\n        // <path sum, number of such paths>\\n        unordered_map<int, int> path_sums;\\n        // 0 node path\\n        path_sums[0] += 1;\\n        findPaths(root, sum, 0, paths, path_sums);\\n\\n        return paths;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/path-sum-iii/\\n    \\n    TC: O(N)\\n    SC: O(N), worst case: skewed tree\\n    \\n    Since the paths to check for start from top and continue from parent to\\n    child subtrees. So each path from parent A to a node in some nested subchild \\n    B is basically a path which can have sum equivalent to req. sum. We can look\\n    at the problem as finding a subarray sum in an array which matches the given sum.\\n    SO to do that we start tracking all the sums seen during traversal from\\n    top to bottom and at each node also check if we found paths matching the req. sum.\\n*/\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findPaths(TreeNode* root, int sum, int path,\\n                   int &paths, unordered_map<int, int>& path_sums) {\\n        if(root) {\\n            // add current node to path\\n            path += root->val;\\n            // check the number of paths found with req. sum\\n            paths += path_sums[path - sum];\\n            // Add the current path to the \\n            ++path_sums[path];\\n\\n            findPaths(root->left, sum, path, paths, path_sums);\\n            findPaths(root->right, sum, path, paths, path_sums);\\n            // remove the current path from visited paths\\n            --path_sums[path];\\n        }    \\n    }\\n\\n    int pathSum(TreeNode* root, int sum) {\\n        int paths = 0;\\n        // <path sum, number of such paths>\\n        unordered_map<int, int> path_sums;\\n        // 0 node path\\n        path_sums[0] += 1;\\n        findPaths(root, sum, 0, paths, path_sums);\\n\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843773,
                "title": "clean-clear-iterative-dfs-solution-python3",
                "content": "This solution is just a striaghtforward application of DFS (Depth First Search) using iteration no bells or whistles. For me this was the clearest way to slove this problem. I have provided a brief explanation and for those interested a more detailed explanation. \\n\\n**Brief**\\neach path sum is accumulated during the DFS traversal and at the end of each path, the paths sum is compared to the target sum. if it is the same the path count is incremented. At the end of the entire traversal the path count is returned.\\n\\n\\n**Submission**\\n```Python\\ndef pathSum(self, root, sum):\\n\\tif not root:\\n\\t\\treturn 0\\n\\tstack = [root]\\n\\tpath_count = 0 \\n\\t# visit every tree node in DFS order \\n\\twhile stack:\\n\\t\\tcurr = stack.pop()\\n\\t\\t# follow all paths starting from any source node\\n\\t\\tpath_count = self.path_from_source(curr, path_count, sum)\\n\\t\\tif curr.left:\\n\\t\\t\\tstack.append(curr.left)\\n\\t\\tif curr.right:\\n\\t\\t\\tstack.append(curr.right)\\n\\n\\treturn path_count\\n\\ndef path_from_source(self, source, count, sum):\\n\\tif not source:\\n\\t\\treturn path_count\\n\\tstack = [(source, source.val)]\\n\\twhile stack:\\n\\t\\tcurr, path_sum = stack.pop()\\n\\t\\tif path_sum == sum:\\n\\t\\t\\tcount += 1\\n\\t\\tif curr.left:\\n\\t\\t\\t#add nodes value to sum in DFS order\\n\\t\\t\\tstack.append((curr.left, path_sum + curr.left.val))\\n\\t\\tif curr.right:\\n\\t\\t\\tstack.append((curr.right, path_sum + curr.right.val))\\n\\treturn count\\n```\\n\\n**Detailed**\\n\\nThe task is to count all paths that sum to a target value. path does not need to start at root or end at leaf.  \\n\\nThis problem can be reduced to solving [path sum](https://leetcode.com/problems/path-sum/) question on leetcode iteratively using DFS with a few minor tweaks. Here is the original path sum solution \\n```Python\\ndef hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        stack = [(root, root.val)]\\n        while stack:\\n            curr, path_sum = stack.pop()\\n\\t\\t\\t# if we have found a leaf and the target sum\\n            if not curr.left and not curr.right and path_sum == sum:  \\n                return True\\n            if curr.left:\\n                stack.append((curr.left, path_sum + curr.left.val))\\n            if curr.right:\\n                stack.append((curr.right, path_sum + curr.right.val))\\n        return False\\n```\\n the tweaks are result of the fact that path sum asks us to find root to leaf paths. thus we have two adustments to make. \\n 1.  find all paths from that need not end on a leaf\\n 2.  find all paths that need not start from root \\n\\nadjustment 1 can be made by simply removing the leaf check in the problem  \\n``` Python \\n    # leaf check and found target sum\\n\\tif not curr.left and not curr.right and path_sum == sum:\\n\\t\\treturn True\\n\\t#changes to....\\n\\t\\n\\t#count all paths from root \\n\\tif path_sum == sum:\\n\\t\\tpath_count += 1\\n\\t\\n``` \\nNow path sum will count all paths that start from root whether they end on a leaf or not\\n\\nThe second adjustment requires some additional code. \\n \\n**The key observation is we already have a function that counts paths with a sum eqaul to target sum (the adjusted path sum function)** \\n\\n```Python \\ndef path_from_source(self, source, count, sum):\\n\\tif not source:\\n\\t\\treturn path_count\\n\\tstack = [(source, source.val)]\\n\\twhile stack:\\n\\t\\tcurr, path_sum = stack.pop()\\n\\t\\tif path_sum == sum:\\n\\t\\t\\tcount += 1\\n\\t\\tif curr.left:\\n\\t\\t\\t#add nodes value to sum in DFS order\\n\\t\\t\\tstack.append((curr.left, path_sum + curr.left.val))\\n\\t\\tif curr.right:\\n\\t\\t\\tstack.append((curr.right, path_sum + curr.right.val))\\n\\treturn count\\n```\\n\\nAll that must be done is to call this function on every node in a DFS order. To accomplish this simply do a  DFS traversal where at every iteration, the path sum function (``` path_from_source``` function from above)  is called. \\n \\n ```Python\\n def pathSum(self, root, sum):\\n\\tif not root:\\n\\t\\treturn 0\\n\\tstack = [root]\\n\\tpath_count = 0 \\n\\t# visit every tree node in DFS order \\n\\twhile stack:\\n\\t\\tcurr = stack.pop()\\n\\t\\t# count path sums for source node (path can start from any node)\\n\\t\\tpath_count = self.path_from_source(curr, path_count, sum)\\n\\t\\tif curr.left:\\n\\t\\t\\tstack.append(curr.left)\\n\\t\\tif curr.right:\\n\\t\\t\\tstack.append(curr.right)\\n\\n\\treturn path_count\\n ````",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```Python\\ndef pathSum(self, root, sum):\\n\\tif not root:\\n\\t\\treturn 0\\n\\tstack = [root]\\n\\tpath_count = 0 \\n\\t# visit every tree node in DFS order \\n\\twhile stack:\\n\\t\\tcurr = stack.pop()\\n\\t\\t# follow all paths starting from any source node\\n\\t\\tpath_count = self.path_from_source(curr, path_count, sum)\\n\\t\\tif curr.left:\\n\\t\\t\\tstack.append(curr.left)\\n\\t\\tif curr.right:\\n\\t\\t\\tstack.append(curr.right)\\n\\n\\treturn path_count\\n\\ndef path_from_source(self, source, count, sum):\\n\\tif not source:\\n\\t\\treturn path_count\\n\\tstack = [(source, source.val)]\\n\\twhile stack:\\n\\t\\tcurr, path_sum = stack.pop()\\n\\t\\tif path_sum == sum:\\n\\t\\t\\tcount += 1\\n\\t\\tif curr.left:\\n\\t\\t\\t#add nodes value to sum in DFS order\\n\\t\\t\\tstack.append((curr.left, path_sum + curr.left.val))\\n\\t\\tif curr.right:\\n\\t\\t\\tstack.append((curr.right, path_sum + curr.right.val))\\n\\treturn count\\n```\n```Python\\ndef hasPathSum(self, root, sum):\\n        if not root:\\n            return False\\n        stack = [(root, root.val)]\\n        while stack:\\n            curr, path_sum = stack.pop()\\n\\t\\t\\t# if we have found a leaf and the target sum\\n            if not curr.left and not curr.right and path_sum == sum:  \\n                return True\\n            if curr.left:\\n                stack.append((curr.left, path_sum + curr.left.val))\\n            if curr.right:\\n                stack.append((curr.right, path_sum + curr.right.val))\\n        return False\\n```\n``` Python \\n    # leaf check and found target sum\\n\\tif not curr.left and not curr.right and path_sum == sum:\\n\\t\\treturn True\\n\\t#changes to....\\n\\t\\n\\t#count all paths from root \\n\\tif path_sum == sum:\\n\\t\\tpath_count += 1\\n\\t\\n```\n```Python \\ndef path_from_source(self, source, count, sum):\\n\\tif not source:\\n\\t\\treturn path_count\\n\\tstack = [(source, source.val)]\\n\\twhile stack:\\n\\t\\tcurr, path_sum = stack.pop()\\n\\t\\tif path_sum == sum:\\n\\t\\t\\tcount += 1\\n\\t\\tif curr.left:\\n\\t\\t\\t#add nodes value to sum in DFS order\\n\\t\\t\\tstack.append((curr.left, path_sum + curr.left.val))\\n\\t\\tif curr.right:\\n\\t\\t\\tstack.append((curr.right, path_sum + curr.right.val))\\n\\treturn count\\n```\n``` path_from_source```\n```Python\\n def pathSum(self, root, sum):\\n\\tif not root:\\n\\t\\treturn 0\\n\\tstack = [root]\\n\\tpath_count = 0 \\n\\t# visit every tree node in DFS order \\n\\twhile stack:\\n\\t\\tcurr = stack.pop()\\n\\t\\t# count path sums for source node (path can start from any node)\\n\\t\\tpath_count = self.path_from_source(curr, path_count, sum)\\n\\t\\tif curr.left:\\n\\t\\t\\tstack.append(curr.left)\\n\\t\\tif curr.right:\\n\\t\\t\\tstack.append(curr.right)\\n\\n\\treturn path_count\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 785459,
                "title": "java-100-faster-than-other-solutions-easy",
                "content": "```\\n\\nHashMap<Integer,Integer> m; \\n    int ans = 0;\\n    \\n    \\n    public void dfs(TreeNode root,int curr, int sum){\\n        if(root == null){\\n            return;\\n        }\\n        \\n        int temp = curr + root.val;\\n        if(m.containsKey(temp - sum)){\\n            ans += m.get(temp - sum);\\n            // System.out.println(root.val+\" ans\");\\n        }\\n        \\n        \\n        // System.out.println(temp+\" sum so far\");\\n        \\n        if(m.containsKey(temp)){\\n            int v = m.get(temp);\\n            v++;\\n            m.put(temp,v);\\n        }else{\\n            m.put(temp,1);\\n        }\\n        \\n        dfs(root.left,temp,sum);\\n        dfs(root.right,temp,sum);\\n        \\n        if(m.containsKey(temp)){\\n            int geto = m.get(temp);\\n            geto--;\\n            if(geto == 0){\\n                m.remove(temp);\\n            }else{\\n                m.put(temp,geto);\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    public int pathSum(TreeNode root, int sum) {\\n        if(root == null){\\n            return 0;\\n        }\\n        m = new HashMap<> ();\\n        m.put(0,1);\\n        dfs(root,0,sum);\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\nHashMap<Integer,Integer> m; \\n    int ans = 0;\\n    \\n    \\n    public void dfs(TreeNode root,int curr, int sum){\\n        if(root == null){\\n            return;\\n        }\\n        \\n        int temp = curr + root.val;\\n        if(m.containsKey(temp - sum)){\\n            ans += m.get(temp - sum);\\n            // System.out.println(root.val+\" ans\");\\n        }\\n        \\n        \\n        // System.out.println(temp+\" sum so far\");\\n        \\n        if(m.containsKey(temp)){\\n            int v = m.get(temp);\\n            v++;\\n            m.put(temp,v);\\n        }else{\\n            m.put(temp,1);\\n        }\\n        \\n        dfs(root.left,temp,sum);\\n        dfs(root.right,temp,sum);\\n        \\n        if(m.containsKey(temp)){\\n            int geto = m.get(temp);\\n            geto--;\\n            if(geto == 0){\\n                m.remove(temp);\\n            }else{\\n                m.put(temp,geto);\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    public int pathSum(TreeNode root, int sum) {\\n        if(root == null){\\n            return 0;\\n        }\\n        m = new HashMap<> ();\\n        m.put(0,1);\\n        dfs(root,0,sum);\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726364,
                "title": "python-o-n-optimal-solution-with-detailed-explanation",
                "content": "This is an optimal (O(N)) solution with python 3.\\n\\nKey ideas:\\n1. A brute-force solution can do as good as O(N logN) because each node (N) would be visited every time any node on its parent chain is visited (hence logN).\\n2. To remove that logN, we can do some caching. Yah, you got it, HashMap! There\\'s one thing we do repeatedly: if you think of a path from the root down (anywhere) as an array, we\\'re essentially trying to find any continuous subarray that sums to the `target`, and we can do that in O(N) time by using a HashMap to store the running sum (from the beginning to index i) as we go. When we move to the next `i`, we increment the `new_running_sum`, and to see if we got a subarray summing to `target` we just need to look for how many `new_running_sum - target` we\\'ve already got in the HashMap. If this still doesn\\'t make sense to you, read the `Think of it as this` comment below.\\n\\n```\\nfclass Solution:\\n    def pathSum(self, root: TreeNode, target: int) -> int:\\n        # Initialize all counts to 0\\n        running_sum_counter = defaultdict(lambda: 0)\\n        # This step is important; otherwise we will miss paths\\n        # from the root\\n        running_sum_counter[0] = 1\\n        \\n        def dfs(root, running_sum):\\n            if not root:\\n                return 0\\n            # Update running sum and counter\\n            # This is the trick to make it O(N) fast:\\n            # In each array, we need to look for continuous subarrays\\n            # that sum up to the target sum. To remove duplicate sums,\\n            # we keep a running sum at each index, so that when the array\\n            # is extended, to check how many subarrays would sum up to\\n            # the target, we just check the count of:\\n            # new_running_sum - target = # existing running sums\\n            # Think of it as this:\\n            # |--prevSum---|-----target-----|\\n            # |------newRunningSum----------|\\n            # target = newRunningSum - prevSum, and prevSum can be cached\\n            # so we compute each sum only once.\\n            running_sum += root.val\\n            num_paths = running_sum_counter[running_sum - target]\\n            running_sum_counter[running_sum] += 1\\n            \\n            # Go down\\n            num_paths += dfs(root.left, running_sum)\\n            num_paths += dfs(root.right, running_sum)\\n            \\n            # Before return, revert the \"damage\" -- we\\'ll be back\\n            # to a state where the updated running_sum hasn\\'t\\n            # been encountered yet\\n            running_sum_counter[running_sum] -= 1\\n            return num_paths\\n        \\n        return dfs(root, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nfclass Solution:\\n    def pathSum(self, root: TreeNode, target: int) -> int:\\n        # Initialize all counts to 0\\n        running_sum_counter = defaultdict(lambda: 0)\\n        # This step is important; otherwise we will miss paths\\n        # from the root\\n        running_sum_counter[0] = 1\\n        \\n        def dfs(root, running_sum):\\n            if not root:\\n                return 0\\n            # Update running sum and counter\\n            # This is the trick to make it O(N) fast:\\n            # In each array, we need to look for continuous subarrays\\n            # that sum up to the target sum. To remove duplicate sums,\\n            # we keep a running sum at each index, so that when the array\\n            # is extended, to check how many subarrays would sum up to\\n            # the target, we just check the count of:\\n            # new_running_sum - target = # existing running sums\\n            # Think of it as this:\\n            # |--prevSum---|-----target-----|\\n            # |------newRunningSum----------|\\n            # target = newRunningSum - prevSum, and prevSum can be cached\\n            # so we compute each sum only once.\\n            running_sum += root.val\\n            num_paths = running_sum_counter[running_sum - target]\\n            running_sum_counter[running_sum] += 1\\n            \\n            # Go down\\n            num_paths += dfs(root.left, running_sum)\\n            num_paths += dfs(root.right, running_sum)\\n            \\n            # Before return, revert the \"damage\" -- we\\'ll be back\\n            # to a state where the updated running_sum hasn\\'t\\n            # been encountered yet\\n            running_sum_counter[running_sum] -= 1\\n            return num_paths\\n        \\n        return dfs(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680863,
                "title": "java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    int ans;\\n    public int pathSum(TreeNode root, int sum) {\\n        if (root == null)\\n            return 0;\\n        map = new HashMap<>();\\n        map.put(0, 1);\\n        ans = 0;\\n        helper(root, 0, sum);\\n        return ans;\\n    }\\n    \\n    private void helper(TreeNode root, int curSum, int sum){\\n        if (root == null)\\n            return;\\n        curSum += root.val;\\n        if (map.containsKey(curSum - sum)){\\n            ans += map.get(curSum - sum);\\n        }\\n        map.put(curSum, map.getOrDefault(curSum, 0) + 1);\\n        helper(root.left, curSum, sum);\\n        helper(root.right, curSum, sum);\\n        map.put(curSum, map.get(curSum) - 1);\\n        if (map.get(curSum) == 0)\\n            map.remove(curSum);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    int ans;\\n    public int pathSum(TreeNode root, int sum) {\\n        if (root == null)\\n            return 0;\\n        map = new HashMap<>();\\n        map.put(0, 1);\\n        ans = 0;\\n        helper(root, 0, sum);\\n        return ans;\\n    }\\n    \\n    private void helper(TreeNode root, int curSum, int sum){\\n        if (root == null)\\n            return;\\n        curSum += root.val;\\n        if (map.containsKey(curSum - sum)){\\n            ans += map.get(curSum - sum);\\n        }\\n        map.put(curSum, map.getOrDefault(curSum, 0) + 1);\\n        helper(root.left, curSum, sum);\\n        helper(root.right, curSum, sum);\\n        map.put(curSum, map.get(curSum) - 1);\\n        if (map.get(curSum) == 0)\\n            map.remove(curSum);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565827,
                "title": "java-dfs-simple",
                "content": "\\tint count = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n        sumPath(root, sum, new ArrayList<Integer>());\\n        return count;\\n    }\\n    \\n    public void sumPath(TreeNode root, int sum, List<Integer> path) {\\n        if(root == null) return;\\n        \\n        path.add(root.val);\\n        int curSum = 0;\\n        for(int i = path.size()-1; i >= 0; i--) {\\n            curSum += path.get(i);\\n            if(curSum == sum) count++;\\n        }\\n        sumPath(root.left, sum, path);\\n        sumPath(root.right, sum, path);\\n        path.remove(path.size() -1);\\n    }",
                "solutionTags": [],
                "code": "\\tint count = 0;\\n    public int pathSum(TreeNode root, int sum) {\\n        sumPath(root, sum, new ArrayList<Integer>());\\n        return count;\\n    }\\n    \\n    public void sumPath(TreeNode root, int sum, List<Integer> path) {\\n        if(root == null) return;\\n        \\n        path.add(root.val);\\n        int curSum = 0;\\n        for(int i = path.size()-1; i >= 0; i--) {\\n            curSum += path.get(i);\\n            if(curSum == sum) count++;\\n        }\\n        sumPath(root.left, sum, path);\\n        sumPath(root.right, sum, path);\\n        path.remove(path.size() -1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 525503,
                "title": "python-o-n-sol-by-dfs-and-memorization-93-with-reference",
                "content": "Python O(n) sol by DFS and memorization\\n\\n---\\n\\n**Reference**:\\nThis one is a remake of [**Memorization of path sum** in this article by @**wonderlives**](https://leetcode.com/problems/path-sum-iii/discuss/141424/Python-step-by-step-walk-through.-Easy-to-understand.-Two-solutions-comparison.-%3A-))\\n\\nIt is highly recommended reading the article above, due to its **clear explanation** and **thought-provoking diagram**.\\n\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        \\n        sum_counter_dict = { 0 : 1}\\n        \\n        counter_valid_path = 0\\n        \\n        def helper( node: TreeNode, target: int, cur_sum: int, table: dict):\\n            \\n            if not node:\\n                # empty node or empty tree\\n                return\\n            \\n            \\n            cur_sum += node.val\\n            \\n            # compute candidate sum\\n            candidate_sum = cur_sum - target\\n            \\n            # update counter of valid path if candidate sum exist in table\\n            nonlocal counter_valid_path\\n            counter_valid_path += table.get(candidate_sum, 0)\\n            \\n            table[cur_sum] = table.get(cur_sum, 0) + 1\\n            \\n            # DFS down to next level\\n            helper( node.left, target, cur_sum, table)\\n            helper( node.right, target, cur_sum, table)\\n            \\n            # This subtree DFS is completed, decrease the method count of cur_sum by 1\\n            table[cur_sum] -= 1\\n            \\n        # ----------------------------------------\\n        helper( root, sum, 0, sum_counter_dict)\\n        return counter_valid_path\\n```\\n\\n---\\n\\nAnother implementation using answer return instend of global method counter\\n\\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        \\n        cache = { 0 : 1}\\n        \\n        def helper( node: TreeNode, target: int, cur_sum: int, table: dict):\\n            \\n            if node:\\n                cur_sum = cur_sum + node.val\\n\\n                candidate = cur_sum - target\\n\\n                cur_method_count = table.get(candidate, 0 )\\n                \\n                table[cur_sum] = table.get( cur_sum, 0) + 1\\n\\n                left_method_count = helper( node.left, target, cur_sum, table )\\n                right_method_count = helper( node.right, target, cur_sum, table )\\n\\n                table[cur_sum] -= 1\\n\\n                return left_method_count + cur_method_count + right_method_count\\n            else:\\n                # empty node has no chance to create path sum, which meets target\\n                return 0\\n        # --------------------\\n        \\n        return helper( root, sum, 0, cache)\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #112 Path Sum](https://leetcode.com/problems/path-sum/)\\n\\n[Leetcode #113 Path Sum II](https://leetcode.com/problems/path-sum-ii/)\\n\\n[Leetcode #687 Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python step-by-step walk through. Easy to understand. Two solutions comparison. : )](https://leetcode.com/problems/path-sum-iii/discuss/141424/Python-step-by-step-walk-through.-Easy-to-understand.-Two-solutions-comparison.-%3A-))\\n\\n[2] [Python official docs about dictionary: dict()](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        \\n        sum_counter_dict = { 0 : 1}\\n        \\n        counter_valid_path = 0\\n        \\n        def helper( node: TreeNode, target: int, cur_sum: int, table: dict):\\n            \\n            if not node:\\n                # empty node or empty tree\\n                return\\n            \\n            \\n            cur_sum += node.val\\n            \\n            # compute candidate sum\\n            candidate_sum = cur_sum - target\\n            \\n            # update counter of valid path if candidate sum exist in table\\n            nonlocal counter_valid_path\\n            counter_valid_path += table.get(candidate_sum, 0)\\n            \\n            table[cur_sum] = table.get(cur_sum, 0) + 1\\n            \\n            # DFS down to next level\\n            helper( node.left, target, cur_sum, table)\\n            helper( node.right, target, cur_sum, table)\\n            \\n            # This subtree DFS is completed, decrease the method count of cur_sum by 1\\n            table[cur_sum] -= 1\\n            \\n        # ----------------------------------------\\n        helper( root, sum, 0, sum_counter_dict)\\n        return counter_valid_path\\n```\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        \\n        cache = { 0 : 1}\\n        \\n        def helper( node: TreeNode, target: int, cur_sum: int, table: dict):\\n            \\n            if node:\\n                cur_sum = cur_sum + node.val\\n\\n                candidate = cur_sum - target\\n\\n                cur_method_count = table.get(candidate, 0 )\\n                \\n                table[cur_sum] = table.get( cur_sum, 0) + 1\\n\\n                left_method_count = helper( node.left, target, cur_sum, table )\\n                right_method_count = helper( node.right, target, cur_sum, table )\\n\\n                table[cur_sum] -= 1\\n\\n                return left_method_count + cur_method_count + right_method_count\\n            else:\\n                # empty node has no chance to create path sum, which meets target\\n                return 0\\n        # --------------------\\n        \\n        return helper( root, sum, 0, cache)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373201,
                "title": "c-power-of-hashmap-dfs-hashmap-solution-97-fast-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, int> NodeSum;\\n    int Tsum;\\n    int ans;\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        Tsum = sum;\\n        ans = 0;\\n        NodeSum[0] = 1;        \\n        DFS(root, 0);\\n        return ans;\\n    }\\n    \\n    void DFS(TreeNode* root, int sum){\\n        if(root==NULL) return;\\n        sum+=root->val;\\n        ans += NodeSum[sum - Tsum];\\n        NodeSum[sum]++;\\n        DFS(root->left, sum);\\n        DFS(root->right, sum);\\n        NodeSum[sum]--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, int> NodeSum;\\n    int Tsum;\\n    int ans;\\npublic:\\n    int pathSum(TreeNode* root, int sum) {\\n        Tsum = sum;\\n        ans = 0;\\n        NodeSum[0] = 1;        \\n        DFS(root, 0);\\n        return ans;\\n    }\\n    \\n    void DFS(TreeNode* root, int sum){\\n        if(root==NULL) return;\\n        sum+=root->val;\\n        ans += NodeSum[sum - Tsum];\\n        NodeSum[sum]++;\\n        DFS(root->left, sum);\\n        DFS(root->right, sum);\\n        NodeSum[sum]--;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329239,
                "title": "python-easy-understand-and-beat-80-solution-long-details-in-chinese",
                "content": "#### Subarray Sum Equals K\\n\\u5EFA\\u8BAE\\u5148\\u5B8C\\u6210 [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\n0. \\u6211\\u4EEC\\u53EF\\u4EE5\\u89C2\\u5BDF\\u5230\\u5BF9\\u4E8E\\u4EFB\\u610F\\u6570\\u7EC4 sum(array[i, j]) = sum(array[0, j] - sum(array[0, i-1])\\n1. \\u6240\\u4EE5\\u6211\\u4EEC\\u53EF\\u4EE5\\u5148\\u521B\\u5EFA\\u4E00\\u4E2A presum \\u6570\\u7EC4\\uFF0C\\u5176\\u4E2D presum[i] = sum(A[0,i])\\uFF0C\\u4F8B\\u5982 array = [1, 2, 3], \\u5219 presum = [1, 3, 6]\\n2. \\u6839\\u636E 0\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u5F97\\u5230 sum(array[i, j]) = presum[j] - presum[i-1]\\n\\n       array[1:2] = 5 = presum[2] - presum[0]\\n       array[1:1] = 3 = presum[1] - presum[0]\\n\\n#### Path Sum III\\n\\n          10\\n         /  \\\\\\n        5   -3\\n       / \\\\    \\\\\\n      3   2   11\\n     / \\\\   \\\\\\n    3  -2   1\\n\\ntarget = 8\\n\\n\\u6CE8\\u610F\\u7684\\u662F\\uFF1A\\u8FD9\\u91CC\\u7684 path \\u4E0D\\u5305\\u62EC \\u7531\\u526F\\u8282\\u70B9\\u540C\\u65F6\\u8FDE\\u63A5\\u5DE6\\u53F3\\u5B50\\u8282\\u70B9\\u7684\\u60C5\\u51B5\\uFF0C\\u4F8B\\u5982 [3, 5, 2] \\u6216\\u8005 [5, 10, -3]\\uFF0C\\u5408\\u6CD5\\u7684 path \\u53EA\\u80FD\\u76F4\\u63A5\\u4ECE\\u7236\\u8282\\u70B9\\u5230\\u5B50\\u8282\\u70B9\\u3002\\n    \\n0. brute force \\u7684\\u89E3\\u6CD5\\u91CD\\u590D\\u8BA1\\u7B97\\u4E86\\u8282\\u70B9\\u548C\\uFF0C\\u4F8B\\u5982\\u5728\\u8282\\u70B9 3 \\u7684\\u65F6\\u5019\\uFF0C\\u8BA1\\u7B97\\u4E86 10 + 5 + 3\\uFF0C\\u4E0D\\u8FC7 10 + 5 \\u5728\\u8BA1\\u7B97 3 \\u7684\\u7236\\u8282\\u70B9 5 \\u7684\\u65F6\\u5019\\u5DF2\\u7ECF\\u8BA1\\u7B97\\u8FC7\\u3002\\u6240\\u4EE5\\u6211\\u4EEC\\u53EF\\u4EE5\\u7528\\u4E00\\u4E2A presum \\u5217\\u8868\\u4FDD\\u5B58\\u4ECE root \\u8282\\u70B9\\u5230\\u5F53\\u524D\\u8282\\u70B9\\u7684 presum\\u3002\\n1. \\u5355\\u72EC\\u770B path [10, 5, 3, 3]\\uFF0Ctarget \\u4E3A 8\\uFF0C\\u5F53\\u8BA1\\u7B97\\u5230\\u7B2C\\u4E09\\u4E2A\\u8282\\u70B9 3 \\u4E4B\\u524D\\uFF0Cpresum \\u4FDD\\u5B58\\u4E86 [10, 15]\\uFF0C\\u5230\\u7B2C\\u4E09\\u4E2A\\u8282\\u70B9\\u7684\\u65F6\\u5019\\uFF0C\\u65B0\\u7684 new_presum \\u503C\\u7B49\\u4E8E 18\\uFF0C\\u5728\\u6DFB\\u52A0\\u5230 presum \\u6570\\u7EC4\\u4E4B\\u524D\\u6211\\u4EEC\\u53EF\\u4EE5\\u904D\\u5386 presum \\u6570\\u7EC4\\uFF0C\\u770B new_presum - presum[i] \\u662F\\u5426\\u7B49\\u4E8E target\\uFF0C\\u5728\\u8FD9\\u4E2A\\u4F8B\\u5B50\\u4E2D\\uFF0Cnew_presum - presum[0] = target\\uFF0C\\u6700\\u7EC8\\u7ED3\\u679C\\u52A0 1\\n2. \\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528hash table \\u6765\\u66FF\\u4EE3\\u6570\\u7EC4\\uFF0C\\u770B new_presum - presum[i] \\u662F\\u5426\\u5728 hash table \\u7684\\u952E\\u4E2D\\uFF0C\\u53EF\\u4EE5\\u51CF\\u5C11\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF0C\\u540C\\u65F6\\u6211\\u4EEC\\u7528 hash table \\u7684\\u503C\\u6765\\u8BB0\\u5F55\\u6570\\u91CF\\u3002\\n\\n```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        if not root:\\n            return 0\\n        self.count = 0\\n\\t\\t# \\u8FB9\\u754C\\u60C5\\u51B5\\n        self.dic = {0:1}\\n        self.dfs(root, 0, sum)\\n        return self.count\\n\\n    def dfs(self, node, pre, sum):\\n\\t    # \\u5982\\u679C presum[j] - target \\u5728 hashtable\\u4E2D\\n        if node.val + pre - sum in self.dic:\\n            self.count += self.dic[node.val + pre - sum]\\n        # \\u66F4\\u65B0 hashtable\\n        if pre + node.val in self.dic:\\n            self.dic[pre+node.val] += 1\\n        else:\\n            self.dic[pre+node.val] = 1\\n        for n in (node.left, node.right):\\n            if n:\\n                self.dfs(n, pre+node.val, sum)\\n        self.dic[pre+node.val] -= 1\\n```\\n\\n\\u6211\\u603B\\u7ED3\\u4E86\\u4E00\\u4E9B\\u89E3\\u9898\\u6A21\\u5F0F\\uFF0C\\u5E0C\\u671B\\u53EF\\u4EE5\\u5E2E\\u52A9\\u5230\\u4F60\\uFF1A [DFS \\u89E3\\u9898\\u6A21\\u5F0F](https://www.enginego.org/%E7%AE%97%E6%B3%95/leetcode/dfs-%E8%A7%A3%E9%A2%98%E6%A8%A1%E5%BC%8F/)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        if not root:\\n            return 0\\n        self.count = 0\\n\\t\\t# \\u8FB9\\u754C\\u60C5\\u51B5\\n        self.dic = {0:1}\\n        self.dfs(root, 0, sum)\\n        return self.count\\n\\n    def dfs(self, node, pre, sum):\\n\\t    # \\u5982\\u679C presum[j] - target \\u5728 hashtable\\u4E2D\\n        if node.val + pre - sum in self.dic:\\n            self.count += self.dic[node.val + pre - sum]\\n        # \\u66F4\\u65B0 hashtable\\n        if pre + node.val in self.dic:\\n            self.dic[pre+node.val] += 1\\n        else:\\n            self.dic[pre+node.val] = 1\\n        for n in (node.left, node.right):\\n            if n:\\n                self.dfs(n, pre+node.val, sum)\\n        self.dic[pre+node.val] -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297635,
                "title": "simple-efficient-and-easy-to-understand-recursion-java",
                "content": "A path can start at any node and go down. We have to consider the cumulative number due to all of them. The procedure would be:\\n* Fix a node as the path\\'s starting point.\\n* Calculate the number of paths that can come out of this node.\\n* Do this for all the nodes.\\n* Sum up the total number of paths.\\n\\n```\\nclass Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return 0;\\n        return numPathStartingAtNode(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);\\n    }\\n    private int numPathStartingAtNode(TreeNode root, int sum){\\n        if(root == null)\\n            return 0;\\n        return (root.val == sum ? 1 : 0) + numPathStartingAtNode(root.left, sum - root.val) + numPathStartingAtNode(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return 0;\\n        return numPathStartingAtNode(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);\\n    }\\n    private int numPathStartingAtNode(TreeNode root, int sum){\\n        if(root == null)\\n            return 0;\\n        return (root.val == sum ? 1 : 0) + numPathStartingAtNode(root.left, sum - root.val) + numPathStartingAtNode(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238528,
                "title": "was-this-really-an-easy-question",
                "content": "I think this binary tree question is tougher than a lot of other Medium questions.\\n\\nNot sure if many members agree, since this question received a good amount of up-votes.\\n\\nJust wondering if I am the only one.  :)\\n\\nHere is my answer to the question... hopefully it is helpful.\\n\\n```\\nclass Solution(object):\\n\\tdef __init__(self, count = 0):\\n\\t\\tself.count = count\\n\\tdef pathSum(self, root, summ):\\n\\t\\tif not root : return 0\\n\\t\\tdef bst(root, summ):\\n\\t\\t\\tif not root: return\\n\\t\\t\\tif root.val == summ:\\n\\t\\t\\t\\tself.count += 1\\n\\t\\t\\tbst(root.left, summ - root.val);\\n\\t\\t\\tbst(root.right, summ - root.val);\\n\\n\\t\\tbst(root, summ)\\n\\t\\tself.pathSum(root.left, summ)\\n\\t\\tself.pathSum(root.right, summ)\\n\\t\\treturn self.count\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\tdef __init__(self, count = 0):\\n\\t\\tself.count = count\\n\\tdef pathSum(self, root, summ):\\n\\t\\tif not root : return 0\\n\\t\\tdef bst(root, summ):\\n\\t\\t\\tif not root: return\\n\\t\\t\\tif root.val == summ:\\n\\t\\t\\t\\tself.count += 1\\n\\t\\t\\tbst(root.left, summ - root.val);\\n\\t\\t\\tbst(root.right, summ - root.val);\\n\\n\\t\\tbst(root, summ)\\n\\t\\tself.pathSum(root.left, summ)\\n\\t\\tself.pathSum(root.right, summ)\\n\\t\\treturn self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235343,
                "title": "javascript",
                "content": "**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u4E0D\\u65AD\\u9012\\u5F52node, node.left, node.right, \\u5C06sum\\u503C\\u4EE3\\u5165.\\n2. \\u6BCF\\u6B21\\u5411\\u4E0B\\u9012\\u5F52, \\u5747\\u8981\\u51CF\\u53BB\\u5F53\\u524D\\u7684\\u8282\\u70B9\\u503C.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar pathSum = function(root, sum) {\\n  let count = 0;\\n  const check = (node, _sum) => {\\n    if (node) {\\n      if (node.val === _sum) count++;\\n      check(node.left, _sum - node.val);\\n      check(node.right, _sum - node.val);\\n    }\\n  }\\n  const tree = node => {\\n    if (node) {\\n      check(node, sum);\\n      tree(node.left);\\n      tree(node.right);\\n    }\\n  }\\n  tree(root);\\n  return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar pathSum = function(root, sum) {\\n  let count = 0;\\n  const check = (node, _sum) => {\\n    if (node) {\\n      if (node.val === _sum) count++;\\n      check(node.left, _sum - node.val);\\n      check(node.right, _sum - node.val);\\n    }\\n  }\\n  const tree = node => {\\n    if (node) {\\n      check(node, sum);\\n      tree(node.left);\\n      tree(node.right);\\n    }\\n  }\\n  tree(root);\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91903,
                "title": "very-clean-c-solution-beats-90-problem-should-be-medium-on-leetcode-not-easy",
                "content": "```\\nint result;\\npublic int PathSum(TreeNode root, int sum)\\n{\\n    Dictionary<int, int> dict = new Dictionary<int, int>();\\n    dict.Add(0, 1);\\n\\n    PathSumIII_helper(root, 0, sum, dict);\\n\\n    return result;\\n}\\nprivate void PathSumIII_helper(TreeNode root, int curr_sum, int target_sum, Dictionary<int, int> dict)\\n{\\n    if (root == null) return;\\n\\n    curr_sum += root.val;\\n    int find = curr_sum - target_sum;\\n    if (dict.ContainsKey(find)) result += dict[find];\\n\\n    AddOrIncrement(dict, curr_sum);\\n\\n    PathSumIII_helper(root.left, curr_sum, target_sum, dict);\\n    PathSumIII_helper(root.right, curr_sum, target_sum, dict);\\n\\n    RemoveOrDecrement(dict, curr_sum);\\n    curr_sum -= root.val;\\n}\\n\\nprivate void AddOrIncrement(Dictionary<int, int> dict, int sum)\\n{\\n    if (!dict.ContainsKey(sum))\\n        dict.Add(sum, 0);\\n    dict[sum]++;\\n}\\nprivate void RemoveOrDecrement(Dictionary<int, int> dict, int curr_sum)\\n{\\n    if (dict[curr_sum] == 1) dict.Remove(curr_sum);\\n    else dict[curr_sum]--;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint result;\\npublic int PathSum(TreeNode root, int sum)\\n{\\n    Dictionary<int, int> dict = new Dictionary<int, int>();\\n    dict.Add(0, 1);\\n\\n    PathSumIII_helper(root, 0, sum, dict);\\n\\n    return result;\\n}\\nprivate void PathSumIII_helper(TreeNode root, int curr_sum, int target_sum, Dictionary<int, int> dict)\\n{\\n    if (root == null) return;\\n\\n    curr_sum += root.val;\\n    int find = curr_sum - target_sum;\\n    if (dict.ContainsKey(find)) result += dict[find];\\n\\n    AddOrIncrement(dict, curr_sum);\\n\\n    PathSumIII_helper(root.left, curr_sum, target_sum, dict);\\n    PathSumIII_helper(root.right, curr_sum, target_sum, dict);\\n\\n    RemoveOrDecrement(dict, curr_sum);\\n    curr_sum -= root.val;\\n}\\n\\nprivate void AddOrIncrement(Dictionary<int, int> dict, int sum)\\n{\\n    if (!dict.ContainsKey(sum))\\n        dict.Add(sum, 0);\\n    dict[sum]++;\\n}\\nprivate void RemoveOrDecrement(Dictionary<int, int> dict, int curr_sum)\\n{\\n    if (dict[curr_sum] == 1) dict.Remove(curr_sum);\\n    else dict[curr_sum]--;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91960,
                "title": "golang-recursive-dfs",
                "content": "```\\nfunc pathSum(root *TreeNode, sum int) int {\\n    if root == nil { return 0 }\\n    return sumUp(root, 0, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum)\\n}\\n\\nfunc sumUp(root *TreeNode, pre int, sum int) int {\\n    if root == nil { return 0 }\\n    current := pre + root.Val\\n    \\n    c:= 0\\n    \\n    if current == sum { c = 1 }\\n    return c + sumUp(root.Left, current, sum) + sumUp(root.Right, current, sum)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc pathSum(root *TreeNode, sum int) int {\\n    if root == nil { return 0 }\\n    return sumUp(root, 0, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum)\\n}\\n\\nfunc sumUp(root *TreeNode, pre int, sum int) int {\\n    if root == nil { return 0 }\\n    current := pre + root.Val\\n    \\n    c:= 0\\n    \\n    if current == sum { c = 1 }\\n    return c + sumUp(root.Left, current, sum) + sumUp(root.Right, current, sum)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91971,
                "title": "java-never-start-or-stick-to-the-end",
                "content": "Either the path has not started, or it has to go all the way to the end.\\nIsn't it like the career we chose? : )\\n\\n\\nTime Complexity: O(n log n): each node is visited by its ancestors.\\nSpace Complexity: O(1): we don't store nodes.\\n```\\n    public int pathSum(TreeNode root, int sum) {\\n        return helper(root, sum, false);\\n    }\\n    // Either the path has not started, or it has to go all the way to the end.\\n    private int helper(TreeNode root, int sum, boolean hasStarted) {\\n        if (root == null) return 0;\\n        // if the path has not started, we start now or not.\\n        if (!hasStarted) {\\n            return helper(root, sum, true) + helper(root.left, sum, false) + helper(root.right, sum, false);\\n        }\\n        // if the path has started\\n        sum -= root.val;\\n        return helper(root.left, sum, true) + helper(root.right, sum, true) + (sum == 0? 1 : 0);            \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int pathSum(TreeNode root, int sum) {\\n        return helper(root, sum, false);\\n    }\\n    // Either the path has not started, or it has to go all the way to the end.\\n    private int helper(TreeNode root, int sum, boolean hasStarted) {\\n        if (root == null) return 0;\\n        // if the path has not started, we start now or not.\\n        if (!hasStarted) {\\n            return helper(root, sum, true) + helper(root.left, sum, false) + helper(root.right, sum, false);\\n        }\\n        // if the path has started\\n        sum -= root.val;\\n        return helper(root.left, sum, true) + helper(root.right, sum, true) + (sum == 0? 1 : 0);            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 91936,
                "title": "ez-to-understand-c-solution",
                "content": "\\nTime complexity: O(N^2)\\nSpace complexity: O(1)\\n\\n\\npublic class Solution {\\n    int result = 0;\\n\\n    public int pathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return 0;\\n        includeRoot(root, sum);\\n        pathSum(root.left, sum);\\n        pathSum(root.right, sum);\\n        return result;\\n    }\\n    \\n     public void includeRoot(TreeNode root, int sum) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        if (root.val == sum) {\\n            result++;\\n        }\\n        \\n        includeRoot(root.left, sum - root.val);\\n        includeRoot(root.right, sum - root.val);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int result = 0;\\n\\n    public int pathSum(TreeNode root, int sum) {\\n        if(root == null)\\n            return 0;\\n        includeRoot(root, sum);\\n        pathSum(root.left, sum);\\n        pathSum(root.right, sum);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 91999,
                "title": "neat-java-solution-with-comment",
                "content": "```\\npublic class Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        int count = findPathWithRoot(root, sum);\\n        if (root != null) count += pathSum(root.left, sum) + pathSum(root.right, sum); //add case when root is excluded.\\n        return count;\\n    }\\n    \\n    private int findPathWithRoot(TreeNode root, int sum) { //Must contain root.val when calculating sum.\\n        if (root == null) return 0;\\n        int count = 0;\\n        if (root.val == sum) count = 1;\\n        \\n        return count + findPathWithRoot(root.left, sum - root.val) + findPathWithRoot(root.right, sum - root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        int count = findPathWithRoot(root, sum);\\n        if (root != null) count += pathSum(root.left, sum) + pathSum(root.right, sum); //add case when root is excluded.\\n        return count;\\n    }\\n    \\n    private int findPathWithRoot(TreeNode root, int sum) { //Must contain root.val when calculating sum.\\n        if (root == null) return 0;\\n        int count = 0;\\n        if (root.val == sum) count = 1;\\n        \\n        return count + findPathWithRoot(root.left, sum - root.val) + findPathWithRoot(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92003,
                "title": "dfs-java-solution",
                "content": "```\\npublic int pathSum(TreeNode root, int sum) {\\n\\treturn pathSumRec(root, sum, new ArrayList<Integer>());\\t\\n}\\n\\t\\npublic int pathSumRec(TreeNode node, int k, List<Integer> pathSums) {\\n\\tif(node==null) return 0;\\n\\tList<Integer> pathSumsLeft = new ArrayList<>();\\n\\tint pathsInLeft = pathSumRec(node.left, k, pathSumsLeft);\\n\\tList<Integer> pathSumsRight = new ArrayList<>();\\n\\tint pathsInRight = pathSumRec(node.right, k, pathSumsRight);\\n\\t\\n\\tint paths = 0;\\n\\tif(node.val==k) paths++;\\n\\tpathSums.add(node.val);\\n\\t\\n\\tfor(int i: pathSumsLeft) {\\n\\t\\tif(node.val+i==k) {\\n\\t\\t\\tpaths++;\\n\\t\\t}\\n\\t\\tpathSums.add(node.val+i);\\n\\t}\\n\\n\\tfor(int i: pathSumsRight) {\\n\\t\\tif(node.val+i==k) {\\n\\t\\t\\tpaths++;\\n\\t\\t}\\n\\t\\tpathSums.add(node.val+i);\\n\\t}\\n\\treturn paths+pathsInLeft+pathsInRight;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int pathSum(TreeNode root, int sum) {\\n\\treturn pathSumRec(root, sum, new ArrayList<Integer>());\\t\\n}\\n\\t\\npublic int pathSumRec(TreeNode node, int k, List<Integer> pathSums) {\\n\\tif(node==null) return 0;\\n\\tList<Integer> pathSumsLeft = new ArrayList<>();\\n\\tint pathsInLeft = pathSumRec(node.left, k, pathSumsLeft);\\n\\tList<Integer> pathSumsRight = new ArrayList<>();\\n\\tint pathsInRight = pathSumRec(node.right, k, pathSumsRight);\\n\\t\\n\\tint paths = 0;\\n\\tif(node.val==k) paths++;\\n\\tpathSums.add(node.val);\\n\\t\\n\\tfor(int i: pathSumsLeft) {\\n\\t\\tif(node.val+i==k) {\\n\\t\\t\\tpaths++;\\n\\t\\t}\\n\\t\\tpathSums.add(node.val+i);\\n\\t}\\n\\n\\tfor(int i: pathSumsRight) {\\n\\t\\tif(node.val+i==k) {\\n\\t\\t\\tpaths++;\\n\\t\\t}\\n\\t\\tpathSums.add(node.val+i);\\n\\t}\\n\\treturn paths+pathsInLeft+pathsInRight;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3599540,
                "title": "simple-recursion-java",
                "content": "```\\nclass Solution {\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root == null) return 0;\\n        return helper(root,targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);\\n    }\\n    private int helper(TreeNode root, long sum){\\n        if(root == null) return 0;\\n        return(sum - root.val == 0 ? 1:0) + helper(root.left, sum - root.val) + helper(root.right, sum - root.val);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root == null) return 0;\\n        return helper(root,targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);\\n    }\\n    private int helper(TreeNode root, long sum){\\n        if(root == null) return 0;\\n        return(sum - root.val == 0 ? 1:0) + helper(root.left, sum - root.val) + helper(root.right, sum - root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495729,
                "title": "easy-o-n2-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int numberOfPaths=0;\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root==null) return 0;\\n        calculatePathSum(root,targetSum,0);\\n        pathSum(root.left,targetSum);\\n        pathSum(root.right,targetSum);\\n        return numberOfPaths;\\n    }\\n    public void  calculatePathSum(TreeNode root, int targetSum,long curSum){\\n        if(root==null) return;\\n        curSum=curSum+root.val;\\n        if(targetSum==curSum){\\n            numberOfPaths++;\\n        }\\n        calculatePathSum(root.left,targetSum,curSum);\\n        calculatePathSum(root.right,targetSum,curSum);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int numberOfPaths=0;\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root==null) return 0;\\n        calculatePathSum(root,targetSum,0);\\n        pathSum(root.left,targetSum);\\n        pathSum(root.right,targetSum);\\n        return numberOfPaths;\\n    }\\n    public void  calculatePathSum(TreeNode root, int targetSum,long curSum){\\n        if(root==null) return;\\n        curSum=curSum+root.val;\\n        if(targetSum==curSum){\\n            numberOfPaths++;\\n        }\\n        calculatePathSum(root.left,targetSum,curSum);\\n        calculatePathSum(root.right,targetSum,curSum);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458358,
                "title": "easy-c-solution-using-recursion",
                "content": "# **PLS UPVOTEMY SOLUTION IF YOU LIKE IT AND KINDLY COMMENT FOR ANY DOUBTS**\\n# Approach\\nThe solve function is a recursive function that takes four parameters:\\n\\nroot: A pointer to the current TreeNode in the traversal.\\ncnt: A reference to a long long integer that keeps track of the count of paths that meet the target sum condition.\\nans: A vector of integers that stores the path values from the root to the current node.\\ntargetSum: The given target sum.\\nInside the solve function, if the current root is NULL, the function returns as there is no further traversal to be done.\\n\\nIf the current root is not NULL, the value of the current node is added to the ans vector to build the path.\\n\\nThe solve function is then recursively called for the left and right subtrees of the current root.\\n\\nAfter traversing the left and right subtrees, the loop iterates through the ans vector in reverse order (from leaf to root).\\n\\nIn the loop, a sum variable is used to keep track of the cumulative sum of the path values. If the sum becomes equal to the targetSum, the cnt counter is incremented.\\n\\nAfter processing the current node and its children, the last element is removed from the ans vector using ans.pop_back() to backtrack in the traversal.\\n\\nThe pathSum function is the main function that initializes the ans vector and the cnt counter. It calls the solve function to perform the actual traversal and counting of paths.\\n\\nThe pathSum function returns the final count of paths that meet the target sum condition.\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     long val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(long x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,long long int &cnt, vector<int>ans,int targetSum)\\n{\\n    if(root==NULL) return  ;\\n    ans.push_back(root->val);\\n    solve(root->left,cnt,ans,targetSum);\\n    solve(root->right,cnt,ans,targetSum);\\n    int size=ans.size();\\n    long long sum=0;\\n    for(int i = size-1;i>=0;i--)\\n    {\\n        sum=sum+(long long int)ans[i];\\n        if(sum==targetSum)\\n        cnt++;\\n    }\\n    ans.pop_back();\\n}\\n    int pathSum(TreeNode* root, int targetSum) {\\n        vector<int>ans;\\n        long long int cnt=0;\\n        solve(root,cnt,ans,targetSum);\\n        return\\xA0cnt;\\xA0\\xA0\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     long val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(long x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,long long int &cnt, vector<int>ans,int targetSum)\\n{\\n    if(root==NULL) return  ;\\n    ans.push_back(root->val);\\n    solve(root->left,cnt,ans,targetSum);\\n    solve(root->right,cnt,ans,targetSum);\\n    int size=ans.size();\\n    long long sum=0;\\n    for(int i = size-1;i>=0;i--)\\n    {\\n        sum=sum+(long long int)ans[i];\\n        if(sum==targetSum)\\n        cnt++;\\n    }\\n    ans.pop_back();\\n}\\n    int pathSum(TreeNode* root, int targetSum) {\\n        vector<int>ans;\\n        long long int cnt=0;\\n        solve(root,cnt,ans,targetSum);\\n        return\\xA0cnt;\\xA0\\xA0\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111361,
                "title": "java-simple-code-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    int target;\\n    HashMap<Long, Long> prefixSumToFreq = new HashMap<>();\\n    int num;\\n\\n    /*\\n    \\n    IDEA:\\n    Consider a prefix sum array -> prefixSum[i] = sum of all elements in the array in the indexes [0, i]\\n    Thus prefixSum[i] = sum of elements in [0, i] = sum of elements in [0, j] + sum of elements in [j + 1, i] where j < i\\n\\n    To find if there is a subarray which ends at index i and has sum = target we need sum of elements in [j + 1, i] = target\\n    i.e we need sum of elements in [0, j] = prefixSum[i] - target\\n\\n    We can persist this information in a hashmap which stores prefixSum and frequency it is observed\\n    So we don\\'t need an explicit array! - just track the prefixSum\\n\\n    The only caveat is since this is a tree problem you need to reduce frequency of prefixSum after you have explored the subtree\\n    \\n     */\\n\\n    public int pathSum(TreeNode root, int targetSum) {\\n        target = targetSum;\\n\\n        // when map is empty sum of all elements is 0 so we have observed prefix sum = 0 1 times\\n        prefixSumToFreq.put(0l, 1l);\\n\\n        traverse(root, 0);\\n        return num;\\n    }\\n\\n    private void traverse(TreeNode node, long prefixSum) {\\n        \\n        if(node == null)\\n            return;\\n\\n        // add current value to prefixSum (i.e we \\'include\\' it in the subarray)\\n        prefixSum += node.val;\\n\\n        // find number of subarrays with prefix sum = prefixSum - target - these are the number of paths which sum to target\\n        num += prefixSumToFreq.getOrDefault(prefixSum - target, 0l);\\n        \\n        // since we observed a subarray with sum = prefixSum increase its frequency by 1\\n        prefixSumToFreq.put(prefixSum, prefixSumToFreq.getOrDefault(prefixSum, 0l) + 1);\\n\\n        traverse(node.left, prefixSum);\\n        traverse(node.right, prefixSum);\\n\\n        // reduce frequency of prefixSum by 1\\n        // remove it from the map if reduced frequency equals 0\\n        prefixSumToFreq.put(prefixSum, prefixSumToFreq.get(prefixSum) - 1);\\n        if(prefixSumToFreq.get(prefixSum) == 0)\\n            prefixSumToFreq.remove(prefixSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    int target;\\n    HashMap<Long, Long> prefixSumToFreq = new HashMap<>();\\n    int num;\\n\\n    /*\\n    \\n    IDEA:\\n    Consider a prefix sum array -> prefixSum[i] = sum of all elements in the array in the indexes [0, i]\\n    Thus prefixSum[i] = sum of elements in [0, i] = sum of elements in [0, j] + sum of elements in [j + 1, i] where j < i\\n\\n    To find if there is a subarray which ends at index i and has sum = target we need sum of elements in [j + 1, i] = target\\n    i.e we need sum of elements in [0, j] = prefixSum[i] - target\\n\\n    We can persist this information in a hashmap which stores prefixSum and frequency it is observed\\n    So we don\\'t need an explicit array! - just track the prefixSum\\n\\n    The only caveat is since this is a tree problem you need to reduce frequency of prefixSum after you have explored the subtree\\n    \\n     */\\n\\n    public int pathSum(TreeNode root, int targetSum) {\\n        target = targetSum;\\n\\n        // when map is empty sum of all elements is 0 so we have observed prefix sum = 0 1 times\\n        prefixSumToFreq.put(0l, 1l);\\n\\n        traverse(root, 0);\\n        return num;\\n    }\\n\\n    private void traverse(TreeNode node, long prefixSum) {\\n        \\n        if(node == null)\\n            return;\\n\\n        // add current value to prefixSum (i.e we \\'include\\' it in the subarray)\\n        prefixSum += node.val;\\n\\n        // find number of subarrays with prefix sum = prefixSum - target - these are the number of paths which sum to target\\n        num += prefixSumToFreq.getOrDefault(prefixSum - target, 0l);\\n        \\n        // since we observed a subarray with sum = prefixSum increase its frequency by 1\\n        prefixSumToFreq.put(prefixSum, prefixSumToFreq.getOrDefault(prefixSum, 0l) + 1);\\n\\n        traverse(node.left, prefixSum);\\n        traverse(node.right, prefixSum);\\n\\n        // reduce frequency of prefixSum by 1\\n        // remove it from the map if reduced frequency equals 0\\n        prefixSumToFreq.put(prefixSum, prefixSumToFreq.get(prefixSum) - 1);\\n        if(prefixSumToFreq.get(prefixSum) == 0)\\n            prefixSumToFreq.remove(prefixSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856099,
                "title": "o-n2-java-o-1-space-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse through the array and check from every node\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt every node checking if somehow targetsum can be 0 or not, if 0 , then incrementing the static variable\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n2) where n --> number of nodes\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    stack space needed for recursive calls\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int count;\\n    public int pathSum(TreeNode root, int targetSum) {\\n        count=0;\\n        traverseAndCall(root,targetSum);\\n        return count;\\n    }\\n    void traverseAndCall(TreeNode root,long targetSum){\\n        if(root==null)return;\\n        checkSum(root,targetSum);\\n        traverseAndCall(root.left,targetSum);\\n        traverseAndCall(root.right,targetSum);\\n    }\\n    void checkSum(TreeNode root, long targetSum){\\n        if(root==null)return;\\n        // System.out.println(targetSum);\\n        if(targetSum-root.val==0){\\n            count++;\\n            \\n        }\\n        checkSum(root.left,targetSum-root.val);\\n        checkSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int count;\\n    public int pathSum(TreeNode root, int targetSum) {\\n        count=0;\\n        traverseAndCall(root,targetSum);\\n        return count;\\n    }\\n    void traverseAndCall(TreeNode root,long targetSum){\\n        if(root==null)return;\\n        checkSum(root,targetSum);\\n        traverseAndCall(root.left,targetSum);\\n        traverseAndCall(root.right,targetSum);\\n    }\\n    void checkSum(TreeNode root, long targetSum){\\n        if(root==null)return;\\n        // System.out.println(targetSum);\\n        if(targetSum-root.val==0){\\n            count++;\\n            \\n        }\\n        checkSum(root.left,targetSum-root.val);\\n        checkSum(root.right,targetSum-root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761785,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<long, int> map;\\n    int count = 0;\\n    \\n    void countPathSum(TreeNode* root, int target, long sum){\\n        if(!root)\\n            return;\\n        sum += root->val;        \\n        if(sum == target)\\n            count++;\\n        if(map.find(sum - target) != map.end())        \\n            count += map[sum - target];\\n        map[sum]++;\\n        countPathSum(root->left, target, sum);\\n        countPathSum(root->right, target, sum);\\n        map[sum]--;      \\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        countPathSum(root, targetSum, 0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<long, int> map;\\n    int count = 0;\\n    \\n    void countPathSum(TreeNode* root, int target, long sum){\\n        if(!root)\\n            return;\\n        sum += root->val;        \\n        if(sum == target)\\n            count++;\\n        if(map.find(sum - target) != map.end())        \\n            count += map[sum - target];\\n        map[sum]++;\\n        countPathSum(root->left, target, sum);\\n        countPathSum(root->right, target, sum);\\n        map[sum]--;      \\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        countPathSum(root, targetSum, 0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752118,
                "title": "easy-best-solution-in-c-o-n-tc-hashmap",
                "content": "# Code\\n**Please Upvote if it helps**\\uD83D\\uDE42\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count=0;\\n    unordered_map<long,int> mp;\\n    void DFS(TreeNode* root,int targetSum,long sum){\\n        if(root==NULL)\\n            return;\\n        sum+=root->val;\\n        if(sum==targetSum)\\n            count++;\\n        if(mp.find(sum-targetSum)!=mp.end())\\n            count+=mp[sum-targetSum];\\n        mp[sum]++;\\n        DFS(root->left,targetSum,sum);\\n        DFS(root->right,targetSum,sum);\\n        mp[sum]--;\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return 0;\\n        DFS(root,targetSum,0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count=0;\\n    unordered_map<long,int> mp;\\n    void DFS(TreeNode* root,int targetSum,long sum){\\n        if(root==NULL)\\n            return;\\n        sum+=root->val;\\n        if(sum==targetSum)\\n            count++;\\n        if(mp.find(sum-targetSum)!=mp.end())\\n            count+=mp[sum-targetSum];\\n        mp[sum]++;\\n        DFS(root->left,targetSum,sum);\\n        DFS(root->right,targetSum,sum);\\n        mp[sum]--;\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL)\\n            return 0;\\n        DFS(root,targetSum,0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609059,
                "title": "java-solutions-two-different-approaches-easy-to-understand",
                "content": "\\tFirst Approach: Using Recursion and no global variables\\n\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * public class TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode left;\\n\\t *     TreeNode right;\\n\\t *     TreeNode() {}\\n\\t *     TreeNode(int val) { this.val = val; }\\n\\t *     TreeNode(int val, TreeNode left, TreeNode right) {\\n\\t *         this.val = val;\\n\\t *         this.left = left;\\n\\t *         this.right = right;\\n\\t *     }\\n\\t * }\\n\\t */\\n\\tclass Solution {\\n\\t\\tpublic int pathSum(TreeNode root, int targetSum) {\\n\\t\\t\\tif(root==null)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\treturn recur(root,targetSum,0)+pathSum(root.left,targetSum)+pathSum(root.right,targetSum);\\n\\t\\t}\\n\\t\\tpublic int recur(TreeNode root, int targetSum, long currentSum)\\n\\t\\t{\\n\\t\\t\\tint count=0;\\n\\t\\t\\tif(root==null)\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\tcurrentSum= currentSum+root.val;\\n\\t\\t\\tif(currentSum==targetSum)\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\tcount=count+recur(root.left,targetSum,currentSum);\\n\\t\\t\\tcount=count+recur(root.right,targetSum,currentSum);\\n\\t\\t\\tcurrentSum=currentSum-root.val;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}\\n\\n\\tSecond Approach: Using HashMap and Global Variables\\n\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * public class TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode left;\\n\\t *     TreeNode right;\\n\\t *     TreeNode() {}\\n\\t *     TreeNode(int val) { this.val = val; }\\n\\t *     TreeNode(int val, TreeNode left, TreeNode right) {\\n\\t *         this.val = val;\\n\\t *         this.left = left;\\n\\t *         this.right = right;\\n\\t *     }\\n\\t * }\\n\\t */\\n\\tclass Solution {\\n\\t\\tint count;\\n\\t\\tHashMap<Long,Integer> map= new HashMap<>();\\n\\t\\tpublic int pathSum(TreeNode root, int targetSum) {\\n\\t\\t\\tcount=0;\\n\\t\\t\\trecur(root,targetSum,0L);\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\tpublic void recur(TreeNode root, int targetSum, long currentSum)\\n\\t\\t{\\n\\t\\t\\tif(root==null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tcurrentSum= currentSum+root.val;\\n\\t\\t\\tif(currentSum==targetSum)\\n\\t\\t\\t\\tcount++;\\n\\n\\t\\t\\tcount=count+map.getOrDefault(currentSum-targetSum,0);\\n\\n\\t\\t\\tmap.put(currentSum,map.getOrDefault(currentSum,0)+1);\\n\\n\\t\\t\\trecur(root.left,targetSum,currentSum);\\n\\t\\t\\trecur(root.right,targetSum,currentSum);\\n\\n\\t\\t\\tmap.put(currentSum,map.getOrDefault(currentSum,0)-1);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic int pathSum(TreeNode root, int targetSum) {\\n\\t\\t\\tif(root==null)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\treturn recur(root,targetSum,0)+pathSum(root.left,targetSum)+pathSum(root.right,targetSum);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2534164,
                "title": "c-subarray-sum-dfs-preorder",
                "content": "The problem is exactly same as the subarray sum with negative elements\\nThe basic idea is to use hasing using unordered_maps\\nIn arrays we move left to right here in tree we will move pre order or postorder \\nMoving down we will add root to leaf sum to the map and moving up we will remove the sum from the map\\n\\n\\nAlgorithm:\\n1. Create an unordered map and ans \\n2. Trverse the tree preorder\\n3.when node is not null, compute the root to that node sum, check whether val-targetSum is in map or not, if present in map then add it to answer and if the node value is equal to targetSum then increase answer by 1\\n4. add the sum to map and traverse left then right or right then left, both will work in our case we are traversing left then right\\n5. when done will all subnodes or the node(moving up), remove the sum from the map\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n    unordered_map<long long,long long> mp;\\n    int ans = 0;\\npublic:\\n    void getAns(TreeNode* root, int targetSum, long long current_sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        long long val = current_sum + root->val;\\n        if(val == targetSum ) {\\n            ans += 1;\\n        }\\n        if(mp.find(val - targetSum) != mp.end() && mp[val-targetSum]) {\\n            ans += mp[val-targetSum];\\n        }\\n        mp[val] += 1;\\n        getAns(root->left, targetSum, current_sum + root->val);\\n        getAns(root->right, targetSum, current_sum + root->val);\\n        mp[val] -= 1; \\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        long long current_sum = 0;\\n        getAns(root, targetSum, current_sum);\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<long long,long long> mp;\\n    int ans = 0;\\npublic:\\n    void getAns(TreeNode* root, int targetSum, long long current_sum) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        long long val = current_sum + root->val;\\n        if(val == targetSum ) {\\n            ans += 1;\\n        }\\n        if(mp.find(val - targetSum) != mp.end() && mp[val-targetSum]) {\\n            ans += mp[val-targetSum];\\n        }\\n        mp[val] += 1;\\n        getAns(root->left, targetSum, current_sum + root->val);\\n        getAns(root->right, targetSum, current_sum + root->val);\\n        mp[val] -= 1; \\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        long long current_sum = 0;\\n        getAns(root, targetSum, current_sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445478,
                "title": "c-simple-solution-using-inorder",
                "content": "class Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    void solve(TreeNode* root,ll current,int targetSum,ll &answer){\\n        if(current==targetSum){\\n            answer++;\\n        }\\n        if(root->left!=NULL){\\n            solve(root->left,current+root->left->val,targetSum,answer);\\n        }\\n        if(root->right!=NULL){\\n            solve(root->right,current+root->right->val,targetSum,answer);\\n        }\\n        return;\\n    }\\n    \\n    void inorder(TreeNode* root,int targetSum,ll &answer){\\n        if(!root){\\n            return;\\n        }\\n        inorder(root->left,targetSum,answer);\\n        solve(root,root->val,targetSum,answer);\\n        inorder(root->right,targetSum,answer);\\n        return;\\n    }\\n    \\n    ll pathSum(TreeNode* root, int targetSum) {\\n        ll answer=0;\\n        inorder(root,targetSum,answer);\\n        return answer;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    void solve(TreeNode* root,ll current,int targetSum,ll &answer){\\n        if(current==targetSum){\\n            answer++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2437618,
                "title": "not-so-optimized-but-effective-by-recursion",
                "content": "**Solution -->**\\n```\\nclass Solution {\\npublic:\\n    void helper2(TreeNode* root, int targetSum,long long& ans){\\n        if(root==NULL) return;\\n        DFS_preorder(root,targetSum,ans,0);\\n            helper2(root->left,targetSum,ans);\\n            helper2(root->right,targetSum,ans);\\n        \\n        return;\\n\\n    }\\n    void DFS_preorder(TreeNode* root, int targetSum,long long& ans,long long sum){\\n        if(root==NULL) return;\\n        \\n        sum+=root->val;\\n        \\n        if(sum==targetSum){\\n            ans++;\\n        }\\n        \\n        DFS_preorder(root->left,targetSum,ans,sum);\\n        DFS_preorder(root->right,targetSum,ans,sum);\\n        return;\\n\\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        long long ans=0;\\n        helper2(root,targetSum,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper2(TreeNode* root, int targetSum,long long& ans){\\n        if(root==NULL) return;\\n        DFS_preorder(root,targetSum,ans,0);\\n            helper2(root->left,targetSum,ans);\\n            helper2(root->right,targetSum,ans);\\n        \\n        return;\\n\\n    }\\n    void DFS_preorder(TreeNode* root, int targetSum,long long& ans,long long sum){\\n        if(root==NULL) return;\\n        \\n        sum+=root->val;\\n        \\n        if(sum==targetSum){\\n            ans++;\\n        }\\n        \\n        DFS_preorder(root->left,targetSum,ans,sum);\\n        DFS_preorder(root->right,targetSum,ans,sum);\\n        return;\\n\\n    }\\n    \\n    int pathSum(TreeNode* root, int targetSum) {\\n        long long ans=0;\\n        helper2(root,targetSum,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366508,
                "title": "python-easy-to-understand",
                "content": "Not the fastest, but easy to understand. \\n\\nLogic: Evaluate every path down from a starting node.\\n\\n```python\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        # early termination\\n        if not root:\\n            return 0\\n        \\n        # function to find sum counts for a given starting node using DFS\\n        def dfs(root, tgt):\\n            count = 0\\n            if root is None:\\n                return count\\n            if root.val == tgt:\\n                count += 1\\n            if root.left is not None:\\n                count += dfs(root.left, tgt-root.val)\\n            if root.right is not None:\\n                count += dfs(root.right, tgt-root.val)\\n            return count\\n        \\n        # using BFS, get count of paths summing to total for each starting node\\n        total_count, q = 0, [root]\\n        while q:\\n            for node in q:\\n                total_count += dfs(node, targetSum)\\n            q = [child for node in q for child in (node.left, node.right) if child is not None]\\n        \\n        return total_count\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        # early termination\\n        if not root:\\n            return 0\\n        \\n        # function to find sum counts for a given starting node using DFS\\n        def dfs(root, tgt):\\n            count = 0\\n            if root is None:\\n                return count\\n            if root.val == tgt:\\n                count += 1\\n            if root.left is not None:\\n                count += dfs(root.left, tgt-root.val)\\n            if root.right is not None:\\n                count += dfs(root.right, tgt-root.val)\\n            return count\\n        \\n        # using BFS, get count of paths summing to total for each starting node\\n        total_count, q = 0, [root]\\n        while q:\\n            for node in q:\\n                total_count += dfs(node, targetSum)\\n            q = [child for node in q for child in (node.left, node.right) if child is not None]\\n        \\n        return total_count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267553,
                "title": "c-tle-overflow-solved-with-explanation",
                "content": "**Kindly Upvote It is FREE From your end**\\n\\n\\uD83D\\uDD25 **Approach**\\n*Either You\\'ll find the sum including the root or excluding the root and same for left subtree and rightsubtree in the recursive call.*\\n\\n**PS: Make sure you use Long Long int appropriately. It took my most of the time in identifying that where was Overflow occuring.**\\n\\nFinal Solution is\\n\\n```\\n#define ll long long\\nclass Solution {\\nprivate:\\n    int incRoot(TreeNode* root, ll sum){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        ll res = 0;\\n        if(root->val == sum){\\n            res++;\\n        }\\n        \\n        res+=incRoot(root->left, (ll)sum-root->val);\\n        res+=incRoot(root->right, (ll)sum-root->val);\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        return pathSum(root->left, targetSum) + incRoot(root, targetSum) + pathSum(root->right, targetSum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\nprivate:\\n    int incRoot(TreeNode* root, ll sum){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        ll res = 0;\\n        if(root->val == sum){\\n            res++;\\n        }\\n        \\n        res+=incRoot(root->left, (ll)sum-root->val);\\n        res+=incRoot(root->right, (ll)sum-root->val);\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        return pathSum(root->left, targetSum) + incRoot(root, targetSum) + pathSum(root->right, targetSum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255708,
                "title": "javascript-dfs-easy",
                "content": "\\n\\tvar pathSum = function(root, targetSum) {\\n    let count = 0;\\n    \\n    let hasSum = (node, target) => { //helper function, calculates number of paths having sum equal to target starting from given node\\n        if(node===null){// base case\\n            return;\\n        }\\n        if(node.val===target){// if at any point path sum meets the requirement\\n            count++;\\n        }\\n        //recursive call\\n        hasSum(node.left, target-node.val);\\n        hasSum(node.right, target-node.val);\\n    }\\n    \\n    let dfs = (node) => {//dfs on every node and find sum equal to target starting from every node\\n        if(node===null)\\n            return;\\n        dfs(node.left);\\n        dfs(node.right);\\n        hasSum(node,targetSum);// find sum of path starting on this point\\n    }\\n    \\n    dfs(root);\\n    \\n    return count;\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\\n\\tvar pathSum = function(root, targetSum) {\\n    let count = 0;\\n    \\n    let hasSum = (node, target) => { //helper function, calculates number of paths having sum equal to target starting from given node\\n        if(node===null){// base case\\n            return;\\n        }\\n        if(node.val===target){// if at any point path sum meets the requirement\\n            count++;\\n        }\\n        //recursive call\\n        hasSum(node.left, target-node.val);\\n        hasSum(node.right, target-node.val);\\n    }\\n    \\n    let dfs = (node) => {//dfs on every node and find sum equal to target starting from every node\\n        if(node===null)\\n            return;\\n        dfs(node.left);\\n        dfs(node.right);\\n        hasSum(node,targetSum);// find sum of path starting on this point\\n    }\\n    \\n    dfs(root);\\n    \\n    return count;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1920899,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int pathSum(TreeNode* root, int sum) {\\n        if(root){\\n            dfs(root,sum);\\n            pathSum(root->left,sum);\\n            pathSum(root->right,sum);\\n        }\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, long long sum){\\n        if(!root)return;\\n        if(root->val==sum)ans++;\\n        dfs(root->left,sum-root->val);\\n        dfs(root->right,sum-root->val);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int pathSum(TreeNode* root, int sum) {\\n        if(root){\\n            dfs(root,sum);\\n            pathSum(root->left,sum);\\n            pathSum(root->right,sum);\\n        }\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, long long sum){\\n        if(!root)return;\\n        if(root->val==sum)ans++;\\n        dfs(root->left,sum-root->val);\\n        dfs(root->right,sum-root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745179,
                "title": "python-easy-to-understand-dfs",
                "content": "This question is about changing root everytime and finding targetsum\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def dfs(self, node, sums, k):\\n        if not node:\\n            return\\n        if sums + node.val == k:\\n            self.ans += 1\\n        self.dfs(node.left, sums+node.val, k)\\n        self.dfs(node.right, sums+node.val, k)\\n    \\n    def solve(self, root, k):\\n        if not root:\\n            return\\n        self.dfs(root, 0, k)\\n        self.solve(root.left, k)\\n        self.solve(root.right, k)\\n    \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        self.ans = 0\\n        self.solve(root, targetSum)\\n        return self.ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "This question is about changing root everytime and finding targetsum\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def dfs(self, node, sums, k):\\n        if not node:\\n            return\\n        if sums + node.val == k:\\n            self.ans += 1\\n        self.dfs(node.left, sums+node.val, k)\\n        self.dfs(node.right, sums+node.val, k)\\n    \\n    def solve(self, root, k):\\n        if not root:\\n            return\\n        self.dfs(root, 0, k)\\n        self.solve(root.left, k)\\n        self.solve(root.right, k)\\n    \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        self.ans = 0\\n        self.solve(root, targetSum)\\n        return self.ans",
                "codeTag": "Java"
            },
            {
                "id": 1680492,
                "title": "java-100-faster",
                "content": "```\\n\\tint ans;\\n\\tpublic int pathSum(TreeNode root, int targetSum) {\\n        Map<Integer, Integer> count = new HashMap();\\n        count.put(0, 1);\\n        solve(root, 0, targetSum, count);  \\n        return ans;\\n    }\\n    \\n    void solve(TreeNode root, int currSum, int target, Map<Integer, Integer> count) {\\n        if(root == null) return;\\n        int sum = currSum + root.val;\\n        if(count.containsKey(sum - target)) {\\n            ans += count.get(sum - target);\\n        }\\n        count.put(sum, count.getOrDefault(sum, 0) + 1);\\n        solve(root.left, currSum + root.val, target, count);\\n        solve(root.right, currSum + root.val, target, count);\\n        count.put(sum, count.get(sum) - 1);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tint ans;\\n\\tpublic int pathSum(TreeNode root, int targetSum) {\\n        Map<Integer, Integer> count = new HashMap();\\n        count.put(0, 1);\\n        solve(root, 0, targetSum, count);  \\n        return ans;\\n    }\\n    \\n    void solve(TreeNode root, int currSum, int target, Map<Integer, Integer> count) {\\n        if(root == null) return;\\n        int sum = currSum + root.val;\\n        if(count.containsKey(sum - target)) {\\n            ans += count.get(sum - target);\\n        }\\n        count.put(sum, count.getOrDefault(sum, 0) + 1);\\n        solve(root.left, currSum + root.val, target, count);\\n        solve(root.right, currSum + root.val, target, count);\\n        count.put(sum, count.get(sum) - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1571846,
                "title": "super-easy-backtrack-beats-99-python",
                "content": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        ans = [0]\\n        \\n        def dfs(node, curr_sum):\\n            if not node: return\\n            curr_sum += node.val\\n            if (curr_sum - sum) in mapping:\\n                ans[0] += mapping[curr_sum - sum]\\n            mapping[curr_sum] += 1\\n            dfs(node.left, curr_sum)\\n            dfs(node.right, curr_sum)\\n            mapping[curr_sum] -= 1\\n            \\n        mapping = defaultdict(int)\\n        mapping[0] = 1\\n        dfs(root, 0)\\n        return ans[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> int:\\n        ans = [0]\\n        \\n        def dfs(node, curr_sum):\\n            if not node: return\\n            curr_sum += node.val\\n            if (curr_sum - sum) in mapping:\\n                ans[0] += mapping[curr_sum - sum]\\n            mapping[curr_sum] += 1\\n            dfs(node.left, curr_sum)\\n            dfs(node.right, curr_sum)\\n            mapping[curr_sum] -= 1\\n            \\n        mapping = defaultdict(int)\\n        mapping[0] = 1\\n        dfs(root, 0)\\n        return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525782,
                "title": "easy-to-understand-brute-in-c-accepted",
                "content": "**Considering every node as the starting node of the path:**\\n\\nThe backtrack function calculates the current sum starting from the initial root passed in the function.\\nWe do not return the function after ``` if(root->val == target) ``` because there can be multiple paths within a path, eg: targetSum = 8, and the path is 5->2->1->-1->1, here there are 2 paths 5->2->1 and 5->2->1->-1->1.\\n\\nThe compute function sets the starting node for every path.\\n\\n```\\n    int res;\\n    void backtrack(TreeNode* root, int target){\\n        if(root==NULL)return;\\n        if(root->val==target){\\n            res++;\\n        }\\n        backtrack(root->left,target-root->val);\\n        backtrack(root->right, target-root->val);\\n    }\\n    void compute(TreeNode* root, int target){\\n        if(root==NULL)return;\\n        backtrack(root, target);\\n        compute(root->left, target);\\n        compute(root->right, target);\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        res=0;\\n        compute(root,targetSum);\\n        return res;\\n    }\\n```\\n\\n**Time complexity: O(n\\\\*n)** because we traverse the whole subtree for every node.\\n\\nCorrections are welcome. Hope this solution was useful.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "``` if(root->val == target) ```\n```\\n    int res;\\n    void backtrack(TreeNode* root, int target){\\n        if(root==NULL)return;\\n        if(root->val==target){\\n            res++;\\n        }\\n        backtrack(root->left,target-root->val);\\n        backtrack(root->right, target-root->val);\\n    }\\n    void compute(TreeNode* root, int target){\\n        if(root==NULL)return;\\n        backtrack(root, target);\\n        compute(root->left, target);\\n        compute(root->right, target);\\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        res=0;\\n        compute(root,targetSum);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403027,
                "title": "c-easy-o-n",
                "content": "Used the concept in the problem : https://leetcode.com/problems/subarray-sum-equals-k/\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    void p(TreeNode *root, int tsum,int sum,int &count) {\\n        if(!root) return ;\\n        sum+=root->val;\\n        count+=mp[sum-tsum];\\n        mp[sum]++;\\n        p(root->left,tsum,sum,count);\\n        p(root->right,tsum,sum,count);\\n        mp[sum]--;\\n    }\\n    int pathSum(TreeNode* root, int tsum) {\\n        int count=0;\\n        mp[0]=1;\\n        p(root,tsum,0,count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    void p(TreeNode *root, int tsum,int sum,int &count) {\\n        if(!root) return ;\\n        sum+=root->val;\\n        count+=mp[sum-tsum];\\n        mp[sum]++;\\n        p(root->left,tsum,sum,count);\\n        p(root->right,tsum,sum,count);\\n        mp[sum]--;\\n    }\\n    int pathSum(TreeNode* root, int tsum) {\\n        int count=0;\\n        mp[0]=1;\\n        p(root,tsum,0,count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395496,
                "title": "rust-0ms-100-100",
                "content": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> i32 {\\n        Self::recurse(&root, target_sum, vec![].as_mut())\\n    }\\n    pub fn recurse(root: &Option<Rc<RefCell<TreeNode>>>, target_sum: i32, vec: &mut Vec<i32>) -> i32 {\\n        return if let Some(rc_node) = root {\\n            let node = rc_node.borrow();\\n            let mut count = 0;\\n            vec.push(0);\\n            vec.iter_mut().for_each(|x| {\\n                *x = *x + node.val;\\n                if *x == target_sum {\\n                    count += 1;\\n                }\\n            });\\n            count = count + Self::recurse(&node.left, target_sum, vec) + Self::recurse(&node.right, target_sum, vec);\\n            vec.pop();\\n            vec.iter_mut().for_each(|x| *x = *x - node.val);\\n            count\\n        } else {\\n            0\\n        };\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/295d7ded-615f-46c4-b126-cdf7666d3338_1628609835.194056.png)\\n\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> i32 {\\n        Self::recurse(&root, target_sum, vec![].as_mut())\\n    }\\n    pub fn recurse(root: &Option<Rc<RefCell<TreeNode>>>, target_sum: i32, vec: &mut Vec<i32>) -> i32 {\\n        return if let Some(rc_node) = root {\\n            let node = rc_node.borrow();\\n            let mut count = 0;\\n            vec.push(0);\\n            vec.iter_mut().for_each(|x| {\\n                *x = *x + node.val;\\n                if *x == target_sum {\\n                    count += 1;\\n                }\\n            });\\n            count = count + Self::recurse(&node.left, target_sum, vec) + Self::recurse(&node.right, target_sum, vec);\\n            vec.pop();\\n            vec.iter_mut().for_each(|x| *x = *x - node.val);\\n            count\\n        } else {\\n            0\\n        };\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283439,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;int target;\\n    void recur(TreeNode* root, int& val, int& target) {\\n        if (root == nullptr) return ;\\n        val += root->val;\\n        if (val == target) ans++;\\n        recur(root->left, val, target);\\n        recur(root->right, val, target);\\n        val -= root->val;\\n        \\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if (root == nullptr) return 0;\\n        int val = 0;\\n        recur(root, val, targetSum);\\n        pathSum(root->left, targetSum);\\n        pathSum(root->right, targetSum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;int target;\\n    void recur(TreeNode* root, int& val, int& target) {\\n        if (root == nullptr) return ;\\n        val += root->val;\\n        if (val == target) ans++;\\n        recur(root->left, val, target);\\n        recur(root->right, val, target);\\n        val -= root->val;\\n        \\n    }\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if (root == nullptr) return 0;\\n        int val = 0;\\n        recur(root, val, targetSum);\\n        pathSum(root->left, targetSum);\\n        pathSum(root->right, targetSum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252414,
                "title": "easy-dfs-approach-in-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    void helper(TreeNode *root,int &count,vector<int>&path,int target)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        path.push_back(root->val);\\n        int sum=0;\\n        for(int i=path.size()-1;i>=0;i--)\\n        {\\n            sum+=path[i];\\n            if(sum==target)\\n            {\\n                count++;\\n            }\\n        }\\n        helper(root->left,count,path,target);\\n        helper(root->right,count,path,target);\\n        path.pop_back();\\n    }\\n    int pathSum(TreeNode* root, int targetSum) \\n    {\\n        int count=0;\\n        vector<int>path;\\n        helper(root,count,path,targetSum);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    void helper(TreeNode *root,int &count,vector<int>&path,int target)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        path.push_back(root->val);\\n        int sum=0;\\n        for(int i=path.size()-1;i>=0;i--)\\n        {\\n            sum+=path[i];\\n            if(sum==target)\\n            {\\n                count++;\\n            }\\n        }\\n        helper(root->left,count,path,target);\\n        helper(root->right,count,path,target);\\n        path.pop_back();\\n    }\\n    int pathSum(TreeNode* root, int targetSum) \\n    {\\n        int count=0;\\n        vector<int>path;\\n        helper(root,count,path,targetSum);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222756,
                "title": "easy-java-beats-100-solutions-using-hashmap",
                "content": "```\\nclass Solution {\\n    int total =0;\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root == null) return 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        \\n        findsum(root, 0, targetSum, map );\\n        return total;\\n    }\\n    void findsum(TreeNode root, int sum , int targetSum, HashMap<Integer, Integer> map){\\n        if(root == null) return;\\n        sum += root.val;\\n        if(map.containsKey(sum - targetSum)){\\n            total += map.get(sum-targetSum);\\n        }\\n        \\n        map.put( sum, map.getOrDefault(sum, 0) +1 );\\n        findsum(root.left, sum, targetSum, map);\\n        findsum(root.right, sum, targetSum, map);\\n        map.put(sum, map.get(sum) -1);\\n        return; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int total =0;\\n    public int pathSum(TreeNode root, int targetSum) {\\n        if(root == null) return 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        \\n        findsum(root, 0, targetSum, map );\\n        return total;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1010832,
                "title": "clean-simple-93-88-faster-soln",
                "content": "![image](https://assets.leetcode.com/users/images/af46da84-d779-443d-a25d-bab5936f6ecf_1610303283.7744627.png)\\n```\\npublic class Solution {\\n    // Time O(n^2) || Auxillary Space O(1) || Recursive Space O(h), n = no of nodes in tree, h = height of tree\\n    public int PathSum(TreeNode root, int sum) {\\n        if(root==null) return 0;\\n        return IsMatchingSum( root, sum) + PathSum( root.left, sum) + PathSum( root.right, sum);\\n    }\\n    public static int IsMatchingSum(TreeNode root, int sum)\\n    {\\n        if(root==null) return 0;\\n        sum-=root.val;\\n        return ((sum == 0) ? 1 : 0) + IsMatchingSum(root.left, sum) + IsMatchingSum(root.right, sum);\\n    }   \\n}\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time O(n^2) || Auxillary Space O(1) || Recursive Space O(h), n = no of nodes in tree, h = height of tree\\n    public int PathSum(TreeNode root, int sum) {\\n        if(root==null) return 0;\\n        return IsMatchingSum( root, sum) + PathSum( root.left, sum) + PathSum( root.right, sum);\\n    }\\n    public static int IsMatchingSum(TreeNode root, int sum)\\n    {\\n        if(root==null) return 0;\\n        sum-=root.val;\\n        return ((sum == 0) ? 1 : 0) + IsMatchingSum(root.left, sum) + IsMatchingSum(root.right, sum);\\n    }   \\n}\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988691,
                "title": "java-easy-to-understand-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        List<Integer> path = new ArrayList<>();\\n        \\n        return getNumberOfPath(root, sum, path);\\n    }\\n    \\n    private int getNumberOfPath(TreeNode root, int sum, List<Integer> path){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        path.add(root.val);\\n        int pathCount = 0, currSum = 0, size = path.size();\\n        while(--size >= 0){\\n            currSum += path.get(size);\\n            if(currSum == sum){\\n                pathCount++;\\n            }\\n        }\\n        \\n        pathCount += getNumberOfPath(root.left, sum, path);\\n        pathCount += getNumberOfPath(root.right, sum, path);\\n        path.remove(path.size()-1);\\n        \\n        return pathCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int pathSum(TreeNode root, int sum) {\\n        List<Integer> path = new ArrayList<>();\\n        \\n        return getNumberOfPath(root, sum, path);\\n    }\\n    \\n    private int getNumberOfPath(TreeNode root, int sum, List<Integer> path){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        path.add(root.val);\\n        int pathCount = 0, currSum = 0, size = path.size();\\n        while(--size >= 0){\\n            currSum += path.get(size);\\n            if(currSum == sum){\\n                pathCount++;\\n            }\\n        }\\n        \\n        pathCount += getNumberOfPath(root.left, sum, path);\\n        pathCount += getNumberOfPath(root.right, sum, path);\\n        path.remove(path.size()-1);\\n        \\n        return pathCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947252,
                "title": "java-clean-code-well-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\n           int aux(TreeNode root, int sum){\\n               if(root==null)return 0;\\n               \\n               int ans=0;\\n               if(sum - root.val == 0)ans+=1;// Don\\'t return here Otherwise many long paths would be missed\\n               \\n               ans+= aux(root.left,sum-root.val) ;\\n               ans+= aux(root.right,sum-root.val);\\n               \\n               return ans;\\n           }\\n    \\n    public int pathSum(TreeNode root, int sum) {\\n                \\n                if(root==null)return 0;\\n        \\n                return aux(root,sum) +  pathSum(root.left,sum) + pathSum(root.right,sum);// Any Traversal is fine here\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n           int aux(TreeNode root, int sum){\\n               if(root==null)return 0;\\n               \\n               int ans=0;\\n               if(sum - root.val == 0)ans+=1;// Don\\'t return here Otherwise many long paths would be missed\\n               \\n               ans+= aux(root.left,sum-root.val) ;\\n               ans+= aux(root.right,sum-root.val);\\n               \\n               return ans;\\n           }\\n    \\n    public int pathSum(TreeNode root, int sum) {\\n                \\n                if(root==null)return 0;\\n        \\n                return aux(root,sum) +  pathSum(root.left,sum) + pathSum(root.right,sum);// Any Traversal is fine here\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917254,
                "title": "c-o-n-recursion",
                "content": "Based on Number of Continuous Subarrays that Sum to Target\\n\\n```\\nclass Solution {\\npublic:\\n    int currsum=0,count=0;\\n    unordered_map<int,int>prefix;\\n    \\n    void helper(TreeNode* root, int sum)\\n    {\\n    if(root==NULL)\\n        return;\\n        \\n    currsum+=root->val;\\n    if(currsum==sum)\\n        count++;\\n    if(prefix.find(currsum-sum)!=prefix.end())\\n        count+=prefix[currsum-sum];\\n        \\n    prefix[currsum]++;\\n        \\n    helper(root->left,sum);\\n    helper(root->right,sum);\\n        \\n    prefix[currsum]--;\\n    currsum-=root->val;\\n        \\n    }\\n    \\n     int pathSum(TreeNode* root, int sum) {\\n        helper(root,sum);\\n        return count; \\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int currsum=0,count=0;\\n    unordered_map<int,int>prefix;\\n    \\n    void helper(TreeNode* root, int sum)\\n    {\\n    if(root==NULL)\\n        return;\\n        \\n    currsum+=root->val;\\n    if(currsum==sum)\\n        count++;\\n    if(prefix.find(currsum-sum)!=prefix.end())\\n        count+=prefix[currsum-sum];\\n        \\n    prefix[currsum]++;\\n        \\n    helper(root->left,sum);\\n    helper(root->right,sum);\\n        \\n    prefix[currsum]--;\\n    currsum-=root->val;\\n        \\n    }\\n    \\n     int pathSum(TreeNode* root, int sum) {\\n        helper(root,sum);\\n        return count; \\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564553,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1564654,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1707392,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1570752,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1565771,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1566140,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1567976,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1566863,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1568005,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1971476,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1564553,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1564654,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1707392,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1570752,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1565771,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1566140,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1567976,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1566863,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1568005,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1971476,
                "content": [
                    {
                        "username": "BLeet",
                        "content": "In the end the solution involves recursion across two functions. I found this to be pretty confusing and ended up spending same amount of time on this as a hard-medium problem."
                    },
                    {
                        "username": "rayrogar",
                        "content": "It\\'s more like traverse the tree y both ways, BFS and DFS"
                    },
                    {
                        "username": "alok5",
                        "content": "The O(N) solution using the hashmap is tricky, this is definitely not an easy question!"
                    },
                    {
                        "username": "sam5727",
                        "content": "For those who couldn't pass this test case.\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\n0\nJust change it to long, bc it's integer overflow.\nCheck for more details:\nhttps://leetcode.com/problems/path-sum-iii/solutions/2658840/"
                    },
                    {
                        "username": "ClaudiaMorin",
                        "content": "Because adding something that will bust the Int cap is totally related to the issue of DFT, Prefix, and Hashmaps ???    Thanks for the tip.\\n"
                    },
                    {
                        "username": "popeyehk404",
                        "content": "sin q / cos q ==  tan q  \\nbrooo\\uD83E\\uDEC2"
                    },
                    {
                        "username": "shbazhenov",
                        "content": "Thank you. Please upvote this comment, guys!"
                    },
                    {
                        "username": "indianjit",
                        "content": "Hi, I have been grinding leetcode for a almost all of my winter break. Have done like 25 medium questions and 50 easy questions (not that anyone asked). This is my experience with this problem. I spent the first hour or so just trying to think of a valid approach to it(taking breaks in between). I inititally though a brute force approach would not be the best but a brute force approach is what I ended up doing. I tried thinking of the problem in terms of a singly linked list to see how I would solve that and then I could bring those intuitions back to solve this problem. I had many many bugs which I will not recall. My approaches kind of worked but had a lot of bugs in them. \\n\\nIt hit me to think of the problem as a DFS. I deleted all of my old code and restarted. It would be easy to find all paths that started with the root and ended at some point. That could be done using a dfs. So then I did that but then did another dfs where I ran that function on all of the nodes. I looked in discussion and other people had done the same its just they went beyond and did memoization which I decided not to do cause it seemed too complicated for now. Will learn it later and do it then. First post, this was my experince just wanted to share amongst all the smart people doing it. Hopefully feels nice to see other people struggle. Overall took me like 4 hours to do it without memoization.."
                    },
                    {
                        "username": "theodor1289",
                        "content": "I think this challenge has been mislabeled. I think a more appropriate difficulty category is medium."
                    },
                    {
                        "username": "rayrogar",
                        "content": "My friend please tell me how you earn the 50 days medall??"
                    },
                    {
                        "username": "joilson",
                        "content": "Hello, I\\'d like to know you guys opinion about Path Sum III being classified as an easy question, IMO it should be classified as \"medium\", partial sums on a tree cannot be compared to all of the most \"easy\" questions here"
                    },
                    {
                        "username": "d43a66186dcc0b9978c128dc377876",
                        "content": "Hi,\\n\\nThe answer for test case [1,-2,-3,1,3,-2,null,-1] is 4 but I can only find 3 paths: -1, -2 -> 1, 1 -> -2, Is there a path I'm missing?\\n\\nThanks"
                    },
                    {
                        "username": "kashyapraina418",
                        "content": "[@johndenny](/johndenny) isnt the sum at this path is -1 ?"
                    },
                    {
                        "username": "johndenny",
                        "content": "1 => -2 => 1 => -1"
                    },
                    {
                        "username": "treelover28",
                        "content": "This question ( at least to me personally) is much harder than the previous Path Sum I and Path Sum II, it took me quite a while to get the answer ( and that is after I already consulted the Discussion forum). This should be at least a Medium."
                    },
                    {
                        "username": "stevep",
                        "content": "![0_1514775722513_0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image.png](/assets/uploads/files/1514775722828-0635ac4c-9c7e-4999-b7b7-87feb61ecb61-image-resized.png) \\n\\nWhy does this test case expect 4 paths? I only see 2 paths: 0 -> 1 and 0 ->1."
                    },
                    {
                        "username": "dionjw",
                        "content": "This response is years late, but for future readers, the paths include the paths using the 2 nodes of value \"1\" by themselves, so the paths are: 0->1, 0->1, 1, and 1."
                    },
                    {
                        "username": "yashbhargava_cs21",
                        "content": "For those who are trying this question first time i suggest first go and solve Path sum - I or Path sum - II. After solving you will find out that only you have to repeat your logic of above questions for every node in this question........not only just for root node"
                    }
                ]
            },
            {
                "id": 1568272,
                "content": [
                    {
                        "username": "mohanraj1311",
                        "content": "This by no means looks an \\'easy\\' problem. Should be atleast medium."
                    },
                    {
                        "username": "anshu2",
                        "content": "![image](https://assets.leetcode.com/users/anshu2/image_1553972279.png)\\nAs shown above when I submit the code I get different answer as to when I do trial run. Does anyone have any idea why?"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## Really, NULL  Tree, LONG Sum!!!!\\nPeople becarfull!!! \\nConsider this test case!! [4,-4,3] target: 3 ans: 2 ;)\\n"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "How would you modify it?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "LOL. How ridiculous Leetcode\\'s difficult rating system is."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few More Test Cases:\\n[2,3,4,5,6]\\n10\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\n\\n[1,-2,-3]\\n-1\\n\\n[0,1,1]\\n1\\n\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\n\\n[1,1,1,2,-1,-1]\\n2\\n\\n[1,0,1,1,2,0,-1,0,1,-1,0,-1,0,1,0]\\n2\\n\\n[1,-2,-3,1,3,-2,null,-1]\\n3"
                    },
                    {
                        "username": "eduard92",
                        "content": "Spoiler alert if you can\\'t solve this, go to similar questions and easier versions of this are there."
                    },
                    {
                        "username": "Adonis21",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,5,1]\\ntargetSum = 22\\nfor this shouldn\\'t the output be 2, but in expected it was given 3"
                    },
                    {
                        "username": "skandavyas20",
                        "content": " `your inline code...your inline code...`\n    public int pathSum(TreeNode root, int targetSum) {\n        System.out.println(targetSum +\" \" + root);\n        if(targetSum==0){\n            return 1;\n        }\n         if(root==null){\n            return 0;\n        }\n        \n        int sum = pathSum(root.left,targetSum-root.val) + \n        pathSum(root.right,targetSum-root.val) + pathSum(root.left,targetSum) + \n         pathSum(root.right,targetSum);\n        return sum;\n    }"
                    },
                    {
                        "username": "vikyw89",
                        "content": "question number 117/128\\n\\nroot = [0,1,1]\\n\\ntargetSum = 1\\n\\nexpected answer is 4\\n\\nwhile I can only find 2: [0,1] and [0,1]\\n\\nhow is there 4 ways ??"
                    },
                    {
                        "username": "vikyw89",
                        "content": "[@psionl0](/psionl0) i missed that one ! Thanks for the hints !"
                    },
                    {
                        "username": "psionl0",
                        "content": "You also have [1] and [1] (path sums don\\'t have to start at the root node)."
                    }
                ]
            },
            {
                "id": 1572569,
                "content": [
                    {
                        "username": "mohanraj1311",
                        "content": "This by no means looks an \\'easy\\' problem. Should be atleast medium."
                    },
                    {
                        "username": "anshu2",
                        "content": "![image](https://assets.leetcode.com/users/anshu2/image_1553972279.png)\\nAs shown above when I submit the code I get different answer as to when I do trial run. Does anyone have any idea why?"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## Really, NULL  Tree, LONG Sum!!!!\\nPeople becarfull!!! \\nConsider this test case!! [4,-4,3] target: 3 ans: 2 ;)\\n"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "How would you modify it?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "LOL. How ridiculous Leetcode\\'s difficult rating system is."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few More Test Cases:\\n[2,3,4,5,6]\\n10\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\n\\n[1,-2,-3]\\n-1\\n\\n[0,1,1]\\n1\\n\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\n\\n[1,1,1,2,-1,-1]\\n2\\n\\n[1,0,1,1,2,0,-1,0,1,-1,0,-1,0,1,0]\\n2\\n\\n[1,-2,-3,1,3,-2,null,-1]\\n3"
                    },
                    {
                        "username": "eduard92",
                        "content": "Spoiler alert if you can\\'t solve this, go to similar questions and easier versions of this are there."
                    },
                    {
                        "username": "Adonis21",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,5,1]\\ntargetSum = 22\\nfor this shouldn\\'t the output be 2, but in expected it was given 3"
                    },
                    {
                        "username": "skandavyas20",
                        "content": " `your inline code...your inline code...`\n    public int pathSum(TreeNode root, int targetSum) {\n        System.out.println(targetSum +\" \" + root);\n        if(targetSum==0){\n            return 1;\n        }\n         if(root==null){\n            return 0;\n        }\n        \n        int sum = pathSum(root.left,targetSum-root.val) + \n        pathSum(root.right,targetSum-root.val) + pathSum(root.left,targetSum) + \n         pathSum(root.right,targetSum);\n        return sum;\n    }"
                    },
                    {
                        "username": "vikyw89",
                        "content": "question number 117/128\\n\\nroot = [0,1,1]\\n\\ntargetSum = 1\\n\\nexpected answer is 4\\n\\nwhile I can only find 2: [0,1] and [0,1]\\n\\nhow is there 4 ways ??"
                    },
                    {
                        "username": "vikyw89",
                        "content": "[@psionl0](/psionl0) i missed that one ! Thanks for the hints !"
                    },
                    {
                        "username": "psionl0",
                        "content": "You also have [1] and [1] (path sums don\\'t have to start at the root node)."
                    }
                ]
            },
            {
                "id": 2000479,
                "content": [
                    {
                        "username": "mohanraj1311",
                        "content": "This by no means looks an \\'easy\\' problem. Should be atleast medium."
                    },
                    {
                        "username": "anshu2",
                        "content": "![image](https://assets.leetcode.com/users/anshu2/image_1553972279.png)\\nAs shown above when I submit the code I get different answer as to when I do trial run. Does anyone have any idea why?"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## Really, NULL  Tree, LONG Sum!!!!\\nPeople becarfull!!! \\nConsider this test case!! [4,-4,3] target: 3 ans: 2 ;)\\n"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "How would you modify it?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "LOL. How ridiculous Leetcode\\'s difficult rating system is."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few More Test Cases:\\n[2,3,4,5,6]\\n10\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\n\\n[1,-2,-3]\\n-1\\n\\n[0,1,1]\\n1\\n\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\n\\n[1,1,1,2,-1,-1]\\n2\\n\\n[1,0,1,1,2,0,-1,0,1,-1,0,-1,0,1,0]\\n2\\n\\n[1,-2,-3,1,3,-2,null,-1]\\n3"
                    },
                    {
                        "username": "eduard92",
                        "content": "Spoiler alert if you can\\'t solve this, go to similar questions and easier versions of this are there."
                    },
                    {
                        "username": "Adonis21",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,5,1]\\ntargetSum = 22\\nfor this shouldn\\'t the output be 2, but in expected it was given 3"
                    },
                    {
                        "username": "skandavyas20",
                        "content": " `your inline code...your inline code...`\n    public int pathSum(TreeNode root, int targetSum) {\n        System.out.println(targetSum +\" \" + root);\n        if(targetSum==0){\n            return 1;\n        }\n         if(root==null){\n            return 0;\n        }\n        \n        int sum = pathSum(root.left,targetSum-root.val) + \n        pathSum(root.right,targetSum-root.val) + pathSum(root.left,targetSum) + \n         pathSum(root.right,targetSum);\n        return sum;\n    }"
                    },
                    {
                        "username": "vikyw89",
                        "content": "question number 117/128\\n\\nroot = [0,1,1]\\n\\ntargetSum = 1\\n\\nexpected answer is 4\\n\\nwhile I can only find 2: [0,1] and [0,1]\\n\\nhow is there 4 ways ??"
                    },
                    {
                        "username": "vikyw89",
                        "content": "[@psionl0](/psionl0) i missed that one ! Thanks for the hints !"
                    },
                    {
                        "username": "psionl0",
                        "content": "You also have [1] and [1] (path sums don\\'t have to start at the root node)."
                    }
                ]
            },
            {
                "id": 1572070,
                "content": [
                    {
                        "username": "mohanraj1311",
                        "content": "This by no means looks an \\'easy\\' problem. Should be atleast medium."
                    },
                    {
                        "username": "anshu2",
                        "content": "![image](https://assets.leetcode.com/users/anshu2/image_1553972279.png)\\nAs shown above when I submit the code I get different answer as to when I do trial run. Does anyone have any idea why?"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## Really, NULL  Tree, LONG Sum!!!!\\nPeople becarfull!!! \\nConsider this test case!! [4,-4,3] target: 3 ans: 2 ;)\\n"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "How would you modify it?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "LOL. How ridiculous Leetcode\\'s difficult rating system is."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few More Test Cases:\\n[2,3,4,5,6]\\n10\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\n\\n[1,-2,-3]\\n-1\\n\\n[0,1,1]\\n1\\n\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\n\\n[1,1,1,2,-1,-1]\\n2\\n\\n[1,0,1,1,2,0,-1,0,1,-1,0,-1,0,1,0]\\n2\\n\\n[1,-2,-3,1,3,-2,null,-1]\\n3"
                    },
                    {
                        "username": "eduard92",
                        "content": "Spoiler alert if you can\\'t solve this, go to similar questions and easier versions of this are there."
                    },
                    {
                        "username": "Adonis21",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,5,1]\\ntargetSum = 22\\nfor this shouldn\\'t the output be 2, but in expected it was given 3"
                    },
                    {
                        "username": "skandavyas20",
                        "content": " `your inline code...your inline code...`\n    public int pathSum(TreeNode root, int targetSum) {\n        System.out.println(targetSum +\" \" + root);\n        if(targetSum==0){\n            return 1;\n        }\n         if(root==null){\n            return 0;\n        }\n        \n        int sum = pathSum(root.left,targetSum-root.val) + \n        pathSum(root.right,targetSum-root.val) + pathSum(root.left,targetSum) + \n         pathSum(root.right,targetSum);\n        return sum;\n    }"
                    },
                    {
                        "username": "vikyw89",
                        "content": "question number 117/128\\n\\nroot = [0,1,1]\\n\\ntargetSum = 1\\n\\nexpected answer is 4\\n\\nwhile I can only find 2: [0,1] and [0,1]\\n\\nhow is there 4 ways ??"
                    },
                    {
                        "username": "vikyw89",
                        "content": "[@psionl0](/psionl0) i missed that one ! Thanks for the hints !"
                    },
                    {
                        "username": "psionl0",
                        "content": "You also have [1] and [1] (path sums don\\'t have to start at the root node)."
                    }
                ]
            },
            {
                "id": 1569399,
                "content": [
                    {
                        "username": "mohanraj1311",
                        "content": "This by no means looks an \\'easy\\' problem. Should be atleast medium."
                    },
                    {
                        "username": "anshu2",
                        "content": "![image](https://assets.leetcode.com/users/anshu2/image_1553972279.png)\\nAs shown above when I submit the code I get different answer as to when I do trial run. Does anyone have any idea why?"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## Really, NULL  Tree, LONG Sum!!!!\\nPeople becarfull!!! \\nConsider this test case!! [4,-4,3] target: 3 ans: 2 ;)\\n"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "How would you modify it?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "LOL. How ridiculous Leetcode\\'s difficult rating system is."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few More Test Cases:\\n[2,3,4,5,6]\\n10\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\n\\n[1,-2,-3]\\n-1\\n\\n[0,1,1]\\n1\\n\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\n\\n[1,1,1,2,-1,-1]\\n2\\n\\n[1,0,1,1,2,0,-1,0,1,-1,0,-1,0,1,0]\\n2\\n\\n[1,-2,-3,1,3,-2,null,-1]\\n3"
                    },
                    {
                        "username": "eduard92",
                        "content": "Spoiler alert if you can\\'t solve this, go to similar questions and easier versions of this are there."
                    },
                    {
                        "username": "Adonis21",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,5,1]\\ntargetSum = 22\\nfor this shouldn\\'t the output be 2, but in expected it was given 3"
                    },
                    {
                        "username": "skandavyas20",
                        "content": " `your inline code...your inline code...`\n    public int pathSum(TreeNode root, int targetSum) {\n        System.out.println(targetSum +\" \" + root);\n        if(targetSum==0){\n            return 1;\n        }\n         if(root==null){\n            return 0;\n        }\n        \n        int sum = pathSum(root.left,targetSum-root.val) + \n        pathSum(root.right,targetSum-root.val) + pathSum(root.left,targetSum) + \n         pathSum(root.right,targetSum);\n        return sum;\n    }"
                    },
                    {
                        "username": "vikyw89",
                        "content": "question number 117/128\\n\\nroot = [0,1,1]\\n\\ntargetSum = 1\\n\\nexpected answer is 4\\n\\nwhile I can only find 2: [0,1] and [0,1]\\n\\nhow is there 4 ways ??"
                    },
                    {
                        "username": "vikyw89",
                        "content": "[@psionl0](/psionl0) i missed that one ! Thanks for the hints !"
                    },
                    {
                        "username": "psionl0",
                        "content": "You also have [1] and [1] (path sums don\\'t have to start at the root node)."
                    }
                ]
            },
            {
                "id": 2042516,
                "content": [
                    {
                        "username": "mohanraj1311",
                        "content": "This by no means looks an \\'easy\\' problem. Should be atleast medium."
                    },
                    {
                        "username": "anshu2",
                        "content": "![image](https://assets.leetcode.com/users/anshu2/image_1553972279.png)\\nAs shown above when I submit the code I get different answer as to when I do trial run. Does anyone have any idea why?"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## Really, NULL  Tree, LONG Sum!!!!\\nPeople becarfull!!! \\nConsider this test case!! [4,-4,3] target: 3 ans: 2 ;)\\n"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "How would you modify it?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "LOL. How ridiculous Leetcode\\'s difficult rating system is."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few More Test Cases:\\n[2,3,4,5,6]\\n10\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\n\\n[1,-2,-3]\\n-1\\n\\n[0,1,1]\\n1\\n\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\n\\n[1,1,1,2,-1,-1]\\n2\\n\\n[1,0,1,1,2,0,-1,0,1,-1,0,-1,0,1,0]\\n2\\n\\n[1,-2,-3,1,3,-2,null,-1]\\n3"
                    },
                    {
                        "username": "eduard92",
                        "content": "Spoiler alert if you can\\'t solve this, go to similar questions and easier versions of this are there."
                    },
                    {
                        "username": "Adonis21",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,5,1]\\ntargetSum = 22\\nfor this shouldn\\'t the output be 2, but in expected it was given 3"
                    },
                    {
                        "username": "skandavyas20",
                        "content": " `your inline code...your inline code...`\n    public int pathSum(TreeNode root, int targetSum) {\n        System.out.println(targetSum +\" \" + root);\n        if(targetSum==0){\n            return 1;\n        }\n         if(root==null){\n            return 0;\n        }\n        \n        int sum = pathSum(root.left,targetSum-root.val) + \n        pathSum(root.right,targetSum-root.val) + pathSum(root.left,targetSum) + \n         pathSum(root.right,targetSum);\n        return sum;\n    }"
                    },
                    {
                        "username": "vikyw89",
                        "content": "question number 117/128\\n\\nroot = [0,1,1]\\n\\ntargetSum = 1\\n\\nexpected answer is 4\\n\\nwhile I can only find 2: [0,1] and [0,1]\\n\\nhow is there 4 ways ??"
                    },
                    {
                        "username": "vikyw89",
                        "content": "[@psionl0](/psionl0) i missed that one ! Thanks for the hints !"
                    },
                    {
                        "username": "psionl0",
                        "content": "You also have [1] and [1] (path sums don\\'t have to start at the root node)."
                    }
                ]
            },
            {
                "id": 2039975,
                "content": [
                    {
                        "username": "mohanraj1311",
                        "content": "This by no means looks an \\'easy\\' problem. Should be atleast medium."
                    },
                    {
                        "username": "anshu2",
                        "content": "![image](https://assets.leetcode.com/users/anshu2/image_1553972279.png)\\nAs shown above when I submit the code I get different answer as to when I do trial run. Does anyone have any idea why?"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## Really, NULL  Tree, LONG Sum!!!!\\nPeople becarfull!!! \\nConsider this test case!! [4,-4,3] target: 3 ans: 2 ;)\\n"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "How would you modify it?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "LOL. How ridiculous Leetcode\\'s difficult rating system is."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few More Test Cases:\\n[2,3,4,5,6]\\n10\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\n\\n[1,-2,-3]\\n-1\\n\\n[0,1,1]\\n1\\n\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\n\\n[1,1,1,2,-1,-1]\\n2\\n\\n[1,0,1,1,2,0,-1,0,1,-1,0,-1,0,1,0]\\n2\\n\\n[1,-2,-3,1,3,-2,null,-1]\\n3"
                    },
                    {
                        "username": "eduard92",
                        "content": "Spoiler alert if you can\\'t solve this, go to similar questions and easier versions of this are there."
                    },
                    {
                        "username": "Adonis21",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,5,1]\\ntargetSum = 22\\nfor this shouldn\\'t the output be 2, but in expected it was given 3"
                    },
                    {
                        "username": "skandavyas20",
                        "content": " `your inline code...your inline code...`\n    public int pathSum(TreeNode root, int targetSum) {\n        System.out.println(targetSum +\" \" + root);\n        if(targetSum==0){\n            return 1;\n        }\n         if(root==null){\n            return 0;\n        }\n        \n        int sum = pathSum(root.left,targetSum-root.val) + \n        pathSum(root.right,targetSum-root.val) + pathSum(root.left,targetSum) + \n         pathSum(root.right,targetSum);\n        return sum;\n    }"
                    },
                    {
                        "username": "vikyw89",
                        "content": "question number 117/128\\n\\nroot = [0,1,1]\\n\\ntargetSum = 1\\n\\nexpected answer is 4\\n\\nwhile I can only find 2: [0,1] and [0,1]\\n\\nhow is there 4 ways ??"
                    },
                    {
                        "username": "vikyw89",
                        "content": "[@psionl0](/psionl0) i missed that one ! Thanks for the hints !"
                    },
                    {
                        "username": "psionl0",
                        "content": "You also have [1] and [1] (path sums don\\'t have to start at the root node)."
                    }
                ]
            },
            {
                "id": 2035021,
                "content": [
                    {
                        "username": "mohanraj1311",
                        "content": "This by no means looks an \\'easy\\' problem. Should be atleast medium."
                    },
                    {
                        "username": "anshu2",
                        "content": "![image](https://assets.leetcode.com/users/anshu2/image_1553972279.png)\\nAs shown above when I submit the code I get different answer as to when I do trial run. Does anyone have any idea why?"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## Really, NULL  Tree, LONG Sum!!!!\\nPeople becarfull!!! \\nConsider this test case!! [4,-4,3] target: 3 ans: 2 ;)\\n"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "How would you modify it?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "LOL. How ridiculous Leetcode\\'s difficult rating system is."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few More Test Cases:\\n[2,3,4,5,6]\\n10\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\n\\n[1,-2,-3]\\n-1\\n\\n[0,1,1]\\n1\\n\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\n\\n[1,1,1,2,-1,-1]\\n2\\n\\n[1,0,1,1,2,0,-1,0,1,-1,0,-1,0,1,0]\\n2\\n\\n[1,-2,-3,1,3,-2,null,-1]\\n3"
                    },
                    {
                        "username": "eduard92",
                        "content": "Spoiler alert if you can\\'t solve this, go to similar questions and easier versions of this are there."
                    },
                    {
                        "username": "Adonis21",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,5,1]\\ntargetSum = 22\\nfor this shouldn\\'t the output be 2, but in expected it was given 3"
                    },
                    {
                        "username": "skandavyas20",
                        "content": " `your inline code...your inline code...`\n    public int pathSum(TreeNode root, int targetSum) {\n        System.out.println(targetSum +\" \" + root);\n        if(targetSum==0){\n            return 1;\n        }\n         if(root==null){\n            return 0;\n        }\n        \n        int sum = pathSum(root.left,targetSum-root.val) + \n        pathSum(root.right,targetSum-root.val) + pathSum(root.left,targetSum) + \n         pathSum(root.right,targetSum);\n        return sum;\n    }"
                    },
                    {
                        "username": "vikyw89",
                        "content": "question number 117/128\\n\\nroot = [0,1,1]\\n\\ntargetSum = 1\\n\\nexpected answer is 4\\n\\nwhile I can only find 2: [0,1] and [0,1]\\n\\nhow is there 4 ways ??"
                    },
                    {
                        "username": "vikyw89",
                        "content": "[@psionl0](/psionl0) i missed that one ! Thanks for the hints !"
                    },
                    {
                        "username": "psionl0",
                        "content": "You also have [1] and [1] (path sums don\\'t have to start at the root node)."
                    }
                ]
            },
            {
                "id": 2014708,
                "content": [
                    {
                        "username": "mohanraj1311",
                        "content": "This by no means looks an \\'easy\\' problem. Should be atleast medium."
                    },
                    {
                        "username": "anshu2",
                        "content": "![image](https://assets.leetcode.com/users/anshu2/image_1553972279.png)\\nAs shown above when I submit the code I get different answer as to when I do trial run. Does anyone have any idea why?"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## Really, NULL  Tree, LONG Sum!!!!\\nPeople becarfull!!! \\nConsider this test case!! [4,-4,3] target: 3 ans: 2 ;)\\n"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "How would you modify it?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "LOL. How ridiculous Leetcode\\'s difficult rating system is."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few More Test Cases:\\n[2,3,4,5,6]\\n10\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\n\\n[1,-2,-3]\\n-1\\n\\n[0,1,1]\\n1\\n\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\n\\n[1,1,1,2,-1,-1]\\n2\\n\\n[1,0,1,1,2,0,-1,0,1,-1,0,-1,0,1,0]\\n2\\n\\n[1,-2,-3,1,3,-2,null,-1]\\n3"
                    },
                    {
                        "username": "eduard92",
                        "content": "Spoiler alert if you can\\'t solve this, go to similar questions and easier versions of this are there."
                    },
                    {
                        "username": "Adonis21",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,5,1]\\ntargetSum = 22\\nfor this shouldn\\'t the output be 2, but in expected it was given 3"
                    },
                    {
                        "username": "skandavyas20",
                        "content": " `your inline code...your inline code...`\n    public int pathSum(TreeNode root, int targetSum) {\n        System.out.println(targetSum +\" \" + root);\n        if(targetSum==0){\n            return 1;\n        }\n         if(root==null){\n            return 0;\n        }\n        \n        int sum = pathSum(root.left,targetSum-root.val) + \n        pathSum(root.right,targetSum-root.val) + pathSum(root.left,targetSum) + \n         pathSum(root.right,targetSum);\n        return sum;\n    }"
                    },
                    {
                        "username": "vikyw89",
                        "content": "question number 117/128\\n\\nroot = [0,1,1]\\n\\ntargetSum = 1\\n\\nexpected answer is 4\\n\\nwhile I can only find 2: [0,1] and [0,1]\\n\\nhow is there 4 ways ??"
                    },
                    {
                        "username": "vikyw89",
                        "content": "[@psionl0](/psionl0) i missed that one ! Thanks for the hints !"
                    },
                    {
                        "username": "psionl0",
                        "content": "You also have [1] and [1] (path sums don\\'t have to start at the root node)."
                    }
                ]
            },
            {
                "id": 1997220,
                "content": [
                    {
                        "username": "mohanraj1311",
                        "content": "This by no means looks an \\'easy\\' problem. Should be atleast medium."
                    },
                    {
                        "username": "anshu2",
                        "content": "![image](https://assets.leetcode.com/users/anshu2/image_1553972279.png)\\nAs shown above when I submit the code I get different answer as to when I do trial run. Does anyone have any idea why?"
                    },
                    {
                        "username": "rayrogar",
                        "content": "## Really, NULL  Tree, LONG Sum!!!!\\nPeople becarfull!!! \\nConsider this test case!! [4,-4,3] target: 3 ans: 2 ;)\\n"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "How would you modify it?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "LOL. How ridiculous Leetcode\\'s difficult rating system is."
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few More Test Cases:\\n[2,3,4,5,6]\\n10\\n[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]\\n0\\n\\n[1,-2,-3]\\n-1\\n\\n[0,1,1]\\n1\\n\\n[5,4,8,11,null,13,4,7,2,null,null,5,1]\\n22\\n\\n[1,1,1,2,-1,-1]\\n2\\n\\n[1,0,1,1,2,0,-1,0,1,-1,0,-1,0,1,0]\\n2\\n\\n[1,-2,-3,1,3,-2,null,-1]\\n3"
                    },
                    {
                        "username": "eduard92",
                        "content": "Spoiler alert if you can\\'t solve this, go to similar questions and easier versions of this are there."
                    },
                    {
                        "username": "Adonis21",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,5,1]\\ntargetSum = 22\\nfor this shouldn\\'t the output be 2, but in expected it was given 3"
                    },
                    {
                        "username": "skandavyas20",
                        "content": " `your inline code...your inline code...`\n    public int pathSum(TreeNode root, int targetSum) {\n        System.out.println(targetSum +\" \" + root);\n        if(targetSum==0){\n            return 1;\n        }\n         if(root==null){\n            return 0;\n        }\n        \n        int sum = pathSum(root.left,targetSum-root.val) + \n        pathSum(root.right,targetSum-root.val) + pathSum(root.left,targetSum) + \n         pathSum(root.right,targetSum);\n        return sum;\n    }"
                    },
                    {
                        "username": "vikyw89",
                        "content": "question number 117/128\\n\\nroot = [0,1,1]\\n\\ntargetSum = 1\\n\\nexpected answer is 4\\n\\nwhile I can only find 2: [0,1] and [0,1]\\n\\nhow is there 4 ways ??"
                    },
                    {
                        "username": "vikyw89",
                        "content": "[@psionl0](/psionl0) i missed that one ! Thanks for the hints !"
                    },
                    {
                        "username": "psionl0",
                        "content": "You also have [1] and [1] (path sums don\\'t have to start at the root node)."
                    }
                ]
            },
            {
                "id": 1991762,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "try solving no of subarray of k sum first otherwise this is gonna be hard on you .\\nAlmost seems like problems of arrays keep repeating .\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "If you solved \"subarray sum equal to k\" (Leetcode 560), then this question is a cake walk..\\nHere is my solution : https://leetcode.com/problems/path-sum-iii/solutions/3750494/easy-to-understand-java-solution-100-faster/"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "please someone tell what is the problem with my code as an naive soln\\n\\n //PLEASE SOMEONE TELL WHAT IS PROBLEM WITH MY CODE\\nclass Solution {\\npublic:\\n    int checkforeverynode(TreeNode* node,int target){\\n        if(node==NULL) return 0;\\n        int l=target-node->val,ans=0;\\n        TreeNode* n=node;\\n        while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->left!=NULL){ l=l-(n->left->val);\\n            n=n->left;\\n        }\\n        else break;\\n    }\\n    n=node;\\n     l=target-node->val;\\n    while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->right!=NULL){ l=l-(n->right->val);\\n            n=n->right;\\n        }\\n        else break;\\n    }\\n\\n    return ans;\\n    }\\n    \\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n     return checkforeverynode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right,targetSum);\\n       \\n    \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any ideas on What if the path is allowed from left to right and right to left subtrees as well? What can be the approach and complexity in that case>"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Brute force will work only need to change int to long long int"
                    },
                    {
                        "username": "hofutsai",
                        "content": " ```class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        if root is None: \n            return 0\n        print('target: {}'.format(targetSum))\n        print('value: {}'.format(root.val))\n        print('---')\n        if root.val == targetSum: \n            res = 1\n        else: \n            res = 0\n        \n        return res + self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nCan someone help see why this is not correct? The log that I print looks wrong, but I had scratched my head for a long time, and don't know why this is wrong algo\n\n"
                    },
                    {
                        "username": "shubham3701",
                        "content": "You are checking from root to leaf node but it\\'s mentioned in the statement that the path can be from any node and end need not to be leaf node. Try this:\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.count=0\\n    def helper(self,root,s,S):\\n        if root==None:\\n            return\\n        s+=root.val\\n        if s==S:\\n            self.count+=1\\n            print(self.count,s,S)\\n        self.helper(root.left,s,S)\\n        self.helper(root.right,s,S)\\n        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        \\n        \\n        \\n        if root==None:\\n            return 0\\n        self.helper(root,0,targetSum)\\n        self.pathSum(root.left,targetSum)\\n        self.pathSum(root.right,targetSum)\\n        return self.count"
                    },
                    {
                        "username": "oscarbutt",
                        "content": "Have you found what\\'s wrong? I had the exactly same logic but couldn\\'t figure what\\'s wrong"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "Should be labeled Hard if you want to actually optimise time-complexity"
                    },
                    {
                        "username": "halfengineer",
                        "content": "For those who think why we have updated the map in last, for calculating the sum from other branch we have to remove the current path sum. Hope this helps.."
                    },
                    {
                        "username": "eddy66",
                        "content": "Just wonder if this problem is designed to force us to solve it by using `long` or `long long` type on purpose? or we actually have a different way to avoid integer overflow?"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "why does root=[1] have path=1? "
                    }
                ]
            },
            {
                "id": 1965747,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "try solving no of subarray of k sum first otherwise this is gonna be hard on you .\\nAlmost seems like problems of arrays keep repeating .\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "If you solved \"subarray sum equal to k\" (Leetcode 560), then this question is a cake walk..\\nHere is my solution : https://leetcode.com/problems/path-sum-iii/solutions/3750494/easy-to-understand-java-solution-100-faster/"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "please someone tell what is the problem with my code as an naive soln\\n\\n //PLEASE SOMEONE TELL WHAT IS PROBLEM WITH MY CODE\\nclass Solution {\\npublic:\\n    int checkforeverynode(TreeNode* node,int target){\\n        if(node==NULL) return 0;\\n        int l=target-node->val,ans=0;\\n        TreeNode* n=node;\\n        while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->left!=NULL){ l=l-(n->left->val);\\n            n=n->left;\\n        }\\n        else break;\\n    }\\n    n=node;\\n     l=target-node->val;\\n    while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->right!=NULL){ l=l-(n->right->val);\\n            n=n->right;\\n        }\\n        else break;\\n    }\\n\\n    return ans;\\n    }\\n    \\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n     return checkforeverynode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right,targetSum);\\n       \\n    \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any ideas on What if the path is allowed from left to right and right to left subtrees as well? What can be the approach and complexity in that case>"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Brute force will work only need to change int to long long int"
                    },
                    {
                        "username": "hofutsai",
                        "content": " ```class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        if root is None: \n            return 0\n        print('target: {}'.format(targetSum))\n        print('value: {}'.format(root.val))\n        print('---')\n        if root.val == targetSum: \n            res = 1\n        else: \n            res = 0\n        \n        return res + self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nCan someone help see why this is not correct? The log that I print looks wrong, but I had scratched my head for a long time, and don't know why this is wrong algo\n\n"
                    },
                    {
                        "username": "shubham3701",
                        "content": "You are checking from root to leaf node but it\\'s mentioned in the statement that the path can be from any node and end need not to be leaf node. Try this:\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.count=0\\n    def helper(self,root,s,S):\\n        if root==None:\\n            return\\n        s+=root.val\\n        if s==S:\\n            self.count+=1\\n            print(self.count,s,S)\\n        self.helper(root.left,s,S)\\n        self.helper(root.right,s,S)\\n        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        \\n        \\n        \\n        if root==None:\\n            return 0\\n        self.helper(root,0,targetSum)\\n        self.pathSum(root.left,targetSum)\\n        self.pathSum(root.right,targetSum)\\n        return self.count"
                    },
                    {
                        "username": "oscarbutt",
                        "content": "Have you found what\\'s wrong? I had the exactly same logic but couldn\\'t figure what\\'s wrong"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "Should be labeled Hard if you want to actually optimise time-complexity"
                    },
                    {
                        "username": "halfengineer",
                        "content": "For those who think why we have updated the map in last, for calculating the sum from other branch we have to remove the current path sum. Hope this helps.."
                    },
                    {
                        "username": "eddy66",
                        "content": "Just wonder if this problem is designed to force us to solve it by using `long` or `long long` type on purpose? or we actually have a different way to avoid integer overflow?"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "why does root=[1] have path=1? "
                    }
                ]
            },
            {
                "id": 1962700,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "try solving no of subarray of k sum first otherwise this is gonna be hard on you .\\nAlmost seems like problems of arrays keep repeating .\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "If you solved \"subarray sum equal to k\" (Leetcode 560), then this question is a cake walk..\\nHere is my solution : https://leetcode.com/problems/path-sum-iii/solutions/3750494/easy-to-understand-java-solution-100-faster/"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "please someone tell what is the problem with my code as an naive soln\\n\\n //PLEASE SOMEONE TELL WHAT IS PROBLEM WITH MY CODE\\nclass Solution {\\npublic:\\n    int checkforeverynode(TreeNode* node,int target){\\n        if(node==NULL) return 0;\\n        int l=target-node->val,ans=0;\\n        TreeNode* n=node;\\n        while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->left!=NULL){ l=l-(n->left->val);\\n            n=n->left;\\n        }\\n        else break;\\n    }\\n    n=node;\\n     l=target-node->val;\\n    while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->right!=NULL){ l=l-(n->right->val);\\n            n=n->right;\\n        }\\n        else break;\\n    }\\n\\n    return ans;\\n    }\\n    \\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n     return checkforeverynode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right,targetSum);\\n       \\n    \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any ideas on What if the path is allowed from left to right and right to left subtrees as well? What can be the approach and complexity in that case>"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Brute force will work only need to change int to long long int"
                    },
                    {
                        "username": "hofutsai",
                        "content": " ```class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        if root is None: \n            return 0\n        print('target: {}'.format(targetSum))\n        print('value: {}'.format(root.val))\n        print('---')\n        if root.val == targetSum: \n            res = 1\n        else: \n            res = 0\n        \n        return res + self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nCan someone help see why this is not correct? The log that I print looks wrong, but I had scratched my head for a long time, and don't know why this is wrong algo\n\n"
                    },
                    {
                        "username": "shubham3701",
                        "content": "You are checking from root to leaf node but it\\'s mentioned in the statement that the path can be from any node and end need not to be leaf node. Try this:\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.count=0\\n    def helper(self,root,s,S):\\n        if root==None:\\n            return\\n        s+=root.val\\n        if s==S:\\n            self.count+=1\\n            print(self.count,s,S)\\n        self.helper(root.left,s,S)\\n        self.helper(root.right,s,S)\\n        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        \\n        \\n        \\n        if root==None:\\n            return 0\\n        self.helper(root,0,targetSum)\\n        self.pathSum(root.left,targetSum)\\n        self.pathSum(root.right,targetSum)\\n        return self.count"
                    },
                    {
                        "username": "oscarbutt",
                        "content": "Have you found what\\'s wrong? I had the exactly same logic but couldn\\'t figure what\\'s wrong"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "Should be labeled Hard if you want to actually optimise time-complexity"
                    },
                    {
                        "username": "halfengineer",
                        "content": "For those who think why we have updated the map in last, for calculating the sum from other branch we have to remove the current path sum. Hope this helps.."
                    },
                    {
                        "username": "eddy66",
                        "content": "Just wonder if this problem is designed to force us to solve it by using `long` or `long long` type on purpose? or we actually have a different way to avoid integer overflow?"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "why does root=[1] have path=1? "
                    }
                ]
            },
            {
                "id": 1936078,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "try solving no of subarray of k sum first otherwise this is gonna be hard on you .\\nAlmost seems like problems of arrays keep repeating .\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "If you solved \"subarray sum equal to k\" (Leetcode 560), then this question is a cake walk..\\nHere is my solution : https://leetcode.com/problems/path-sum-iii/solutions/3750494/easy-to-understand-java-solution-100-faster/"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "please someone tell what is the problem with my code as an naive soln\\n\\n //PLEASE SOMEONE TELL WHAT IS PROBLEM WITH MY CODE\\nclass Solution {\\npublic:\\n    int checkforeverynode(TreeNode* node,int target){\\n        if(node==NULL) return 0;\\n        int l=target-node->val,ans=0;\\n        TreeNode* n=node;\\n        while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->left!=NULL){ l=l-(n->left->val);\\n            n=n->left;\\n        }\\n        else break;\\n    }\\n    n=node;\\n     l=target-node->val;\\n    while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->right!=NULL){ l=l-(n->right->val);\\n            n=n->right;\\n        }\\n        else break;\\n    }\\n\\n    return ans;\\n    }\\n    \\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n     return checkforeverynode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right,targetSum);\\n       \\n    \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any ideas on What if the path is allowed from left to right and right to left subtrees as well? What can be the approach and complexity in that case>"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Brute force will work only need to change int to long long int"
                    },
                    {
                        "username": "hofutsai",
                        "content": " ```class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        if root is None: \n            return 0\n        print('target: {}'.format(targetSum))\n        print('value: {}'.format(root.val))\n        print('---')\n        if root.val == targetSum: \n            res = 1\n        else: \n            res = 0\n        \n        return res + self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nCan someone help see why this is not correct? The log that I print looks wrong, but I had scratched my head for a long time, and don't know why this is wrong algo\n\n"
                    },
                    {
                        "username": "shubham3701",
                        "content": "You are checking from root to leaf node but it\\'s mentioned in the statement that the path can be from any node and end need not to be leaf node. Try this:\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.count=0\\n    def helper(self,root,s,S):\\n        if root==None:\\n            return\\n        s+=root.val\\n        if s==S:\\n            self.count+=1\\n            print(self.count,s,S)\\n        self.helper(root.left,s,S)\\n        self.helper(root.right,s,S)\\n        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        \\n        \\n        \\n        if root==None:\\n            return 0\\n        self.helper(root,0,targetSum)\\n        self.pathSum(root.left,targetSum)\\n        self.pathSum(root.right,targetSum)\\n        return self.count"
                    },
                    {
                        "username": "oscarbutt",
                        "content": "Have you found what\\'s wrong? I had the exactly same logic but couldn\\'t figure what\\'s wrong"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "Should be labeled Hard if you want to actually optimise time-complexity"
                    },
                    {
                        "username": "halfengineer",
                        "content": "For those who think why we have updated the map in last, for calculating the sum from other branch we have to remove the current path sum. Hope this helps.."
                    },
                    {
                        "username": "eddy66",
                        "content": "Just wonder if this problem is designed to force us to solve it by using `long` or `long long` type on purpose? or we actually have a different way to avoid integer overflow?"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "why does root=[1] have path=1? "
                    }
                ]
            },
            {
                "id": 1912747,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "try solving no of subarray of k sum first otherwise this is gonna be hard on you .\\nAlmost seems like problems of arrays keep repeating .\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "If you solved \"subarray sum equal to k\" (Leetcode 560), then this question is a cake walk..\\nHere is my solution : https://leetcode.com/problems/path-sum-iii/solutions/3750494/easy-to-understand-java-solution-100-faster/"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "please someone tell what is the problem with my code as an naive soln\\n\\n //PLEASE SOMEONE TELL WHAT IS PROBLEM WITH MY CODE\\nclass Solution {\\npublic:\\n    int checkforeverynode(TreeNode* node,int target){\\n        if(node==NULL) return 0;\\n        int l=target-node->val,ans=0;\\n        TreeNode* n=node;\\n        while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->left!=NULL){ l=l-(n->left->val);\\n            n=n->left;\\n        }\\n        else break;\\n    }\\n    n=node;\\n     l=target-node->val;\\n    while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->right!=NULL){ l=l-(n->right->val);\\n            n=n->right;\\n        }\\n        else break;\\n    }\\n\\n    return ans;\\n    }\\n    \\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n     return checkforeverynode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right,targetSum);\\n       \\n    \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any ideas on What if the path is allowed from left to right and right to left subtrees as well? What can be the approach and complexity in that case>"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Brute force will work only need to change int to long long int"
                    },
                    {
                        "username": "hofutsai",
                        "content": " ```class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        if root is None: \n            return 0\n        print('target: {}'.format(targetSum))\n        print('value: {}'.format(root.val))\n        print('---')\n        if root.val == targetSum: \n            res = 1\n        else: \n            res = 0\n        \n        return res + self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nCan someone help see why this is not correct? The log that I print looks wrong, but I had scratched my head for a long time, and don't know why this is wrong algo\n\n"
                    },
                    {
                        "username": "shubham3701",
                        "content": "You are checking from root to leaf node but it\\'s mentioned in the statement that the path can be from any node and end need not to be leaf node. Try this:\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.count=0\\n    def helper(self,root,s,S):\\n        if root==None:\\n            return\\n        s+=root.val\\n        if s==S:\\n            self.count+=1\\n            print(self.count,s,S)\\n        self.helper(root.left,s,S)\\n        self.helper(root.right,s,S)\\n        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        \\n        \\n        \\n        if root==None:\\n            return 0\\n        self.helper(root,0,targetSum)\\n        self.pathSum(root.left,targetSum)\\n        self.pathSum(root.right,targetSum)\\n        return self.count"
                    },
                    {
                        "username": "oscarbutt",
                        "content": "Have you found what\\'s wrong? I had the exactly same logic but couldn\\'t figure what\\'s wrong"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "Should be labeled Hard if you want to actually optimise time-complexity"
                    },
                    {
                        "username": "halfengineer",
                        "content": "For those who think why we have updated the map in last, for calculating the sum from other branch we have to remove the current path sum. Hope this helps.."
                    },
                    {
                        "username": "eddy66",
                        "content": "Just wonder if this problem is designed to force us to solve it by using `long` or `long long` type on purpose? or we actually have a different way to avoid integer overflow?"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "why does root=[1] have path=1? "
                    }
                ]
            },
            {
                "id": 1894156,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "try solving no of subarray of k sum first otherwise this is gonna be hard on you .\\nAlmost seems like problems of arrays keep repeating .\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "If you solved \"subarray sum equal to k\" (Leetcode 560), then this question is a cake walk..\\nHere is my solution : https://leetcode.com/problems/path-sum-iii/solutions/3750494/easy-to-understand-java-solution-100-faster/"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "please someone tell what is the problem with my code as an naive soln\\n\\n //PLEASE SOMEONE TELL WHAT IS PROBLEM WITH MY CODE\\nclass Solution {\\npublic:\\n    int checkforeverynode(TreeNode* node,int target){\\n        if(node==NULL) return 0;\\n        int l=target-node->val,ans=0;\\n        TreeNode* n=node;\\n        while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->left!=NULL){ l=l-(n->left->val);\\n            n=n->left;\\n        }\\n        else break;\\n    }\\n    n=node;\\n     l=target-node->val;\\n    while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->right!=NULL){ l=l-(n->right->val);\\n            n=n->right;\\n        }\\n        else break;\\n    }\\n\\n    return ans;\\n    }\\n    \\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n     return checkforeverynode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right,targetSum);\\n       \\n    \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any ideas on What if the path is allowed from left to right and right to left subtrees as well? What can be the approach and complexity in that case>"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Brute force will work only need to change int to long long int"
                    },
                    {
                        "username": "hofutsai",
                        "content": " ```class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        if root is None: \n            return 0\n        print('target: {}'.format(targetSum))\n        print('value: {}'.format(root.val))\n        print('---')\n        if root.val == targetSum: \n            res = 1\n        else: \n            res = 0\n        \n        return res + self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nCan someone help see why this is not correct? The log that I print looks wrong, but I had scratched my head for a long time, and don't know why this is wrong algo\n\n"
                    },
                    {
                        "username": "shubham3701",
                        "content": "You are checking from root to leaf node but it\\'s mentioned in the statement that the path can be from any node and end need not to be leaf node. Try this:\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.count=0\\n    def helper(self,root,s,S):\\n        if root==None:\\n            return\\n        s+=root.val\\n        if s==S:\\n            self.count+=1\\n            print(self.count,s,S)\\n        self.helper(root.left,s,S)\\n        self.helper(root.right,s,S)\\n        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        \\n        \\n        \\n        if root==None:\\n            return 0\\n        self.helper(root,0,targetSum)\\n        self.pathSum(root.left,targetSum)\\n        self.pathSum(root.right,targetSum)\\n        return self.count"
                    },
                    {
                        "username": "oscarbutt",
                        "content": "Have you found what\\'s wrong? I had the exactly same logic but couldn\\'t figure what\\'s wrong"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "Should be labeled Hard if you want to actually optimise time-complexity"
                    },
                    {
                        "username": "halfengineer",
                        "content": "For those who think why we have updated the map in last, for calculating the sum from other branch we have to remove the current path sum. Hope this helps.."
                    },
                    {
                        "username": "eddy66",
                        "content": "Just wonder if this problem is designed to force us to solve it by using `long` or `long long` type on purpose? or we actually have a different way to avoid integer overflow?"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "why does root=[1] have path=1? "
                    }
                ]
            },
            {
                "id": 1799425,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "try solving no of subarray of k sum first otherwise this is gonna be hard on you .\\nAlmost seems like problems of arrays keep repeating .\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "If you solved \"subarray sum equal to k\" (Leetcode 560), then this question is a cake walk..\\nHere is my solution : https://leetcode.com/problems/path-sum-iii/solutions/3750494/easy-to-understand-java-solution-100-faster/"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "please someone tell what is the problem with my code as an naive soln\\n\\n //PLEASE SOMEONE TELL WHAT IS PROBLEM WITH MY CODE\\nclass Solution {\\npublic:\\n    int checkforeverynode(TreeNode* node,int target){\\n        if(node==NULL) return 0;\\n        int l=target-node->val,ans=0;\\n        TreeNode* n=node;\\n        while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->left!=NULL){ l=l-(n->left->val);\\n            n=n->left;\\n        }\\n        else break;\\n    }\\n    n=node;\\n     l=target-node->val;\\n    while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->right!=NULL){ l=l-(n->right->val);\\n            n=n->right;\\n        }\\n        else break;\\n    }\\n\\n    return ans;\\n    }\\n    \\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n     return checkforeverynode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right,targetSum);\\n       \\n    \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any ideas on What if the path is allowed from left to right and right to left subtrees as well? What can be the approach and complexity in that case>"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Brute force will work only need to change int to long long int"
                    },
                    {
                        "username": "hofutsai",
                        "content": " ```class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        if root is None: \n            return 0\n        print('target: {}'.format(targetSum))\n        print('value: {}'.format(root.val))\n        print('---')\n        if root.val == targetSum: \n            res = 1\n        else: \n            res = 0\n        \n        return res + self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nCan someone help see why this is not correct? The log that I print looks wrong, but I had scratched my head for a long time, and don't know why this is wrong algo\n\n"
                    },
                    {
                        "username": "shubham3701",
                        "content": "You are checking from root to leaf node but it\\'s mentioned in the statement that the path can be from any node and end need not to be leaf node. Try this:\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.count=0\\n    def helper(self,root,s,S):\\n        if root==None:\\n            return\\n        s+=root.val\\n        if s==S:\\n            self.count+=1\\n            print(self.count,s,S)\\n        self.helper(root.left,s,S)\\n        self.helper(root.right,s,S)\\n        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        \\n        \\n        \\n        if root==None:\\n            return 0\\n        self.helper(root,0,targetSum)\\n        self.pathSum(root.left,targetSum)\\n        self.pathSum(root.right,targetSum)\\n        return self.count"
                    },
                    {
                        "username": "oscarbutt",
                        "content": "Have you found what\\'s wrong? I had the exactly same logic but couldn\\'t figure what\\'s wrong"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "Should be labeled Hard if you want to actually optimise time-complexity"
                    },
                    {
                        "username": "halfengineer",
                        "content": "For those who think why we have updated the map in last, for calculating the sum from other branch we have to remove the current path sum. Hope this helps.."
                    },
                    {
                        "username": "eddy66",
                        "content": "Just wonder if this problem is designed to force us to solve it by using `long` or `long long` type on purpose? or we actually have a different way to avoid integer overflow?"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "why does root=[1] have path=1? "
                    }
                ]
            },
            {
                "id": 1782060,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "try solving no of subarray of k sum first otherwise this is gonna be hard on you .\\nAlmost seems like problems of arrays keep repeating .\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "If you solved \"subarray sum equal to k\" (Leetcode 560), then this question is a cake walk..\\nHere is my solution : https://leetcode.com/problems/path-sum-iii/solutions/3750494/easy-to-understand-java-solution-100-faster/"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "please someone tell what is the problem with my code as an naive soln\\n\\n //PLEASE SOMEONE TELL WHAT IS PROBLEM WITH MY CODE\\nclass Solution {\\npublic:\\n    int checkforeverynode(TreeNode* node,int target){\\n        if(node==NULL) return 0;\\n        int l=target-node->val,ans=0;\\n        TreeNode* n=node;\\n        while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->left!=NULL){ l=l-(n->left->val);\\n            n=n->left;\\n        }\\n        else break;\\n    }\\n    n=node;\\n     l=target-node->val;\\n    while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->right!=NULL){ l=l-(n->right->val);\\n            n=n->right;\\n        }\\n        else break;\\n    }\\n\\n    return ans;\\n    }\\n    \\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n     return checkforeverynode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right,targetSum);\\n       \\n    \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any ideas on What if the path is allowed from left to right and right to left subtrees as well? What can be the approach and complexity in that case>"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Brute force will work only need to change int to long long int"
                    },
                    {
                        "username": "hofutsai",
                        "content": " ```class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        if root is None: \n            return 0\n        print('target: {}'.format(targetSum))\n        print('value: {}'.format(root.val))\n        print('---')\n        if root.val == targetSum: \n            res = 1\n        else: \n            res = 0\n        \n        return res + self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nCan someone help see why this is not correct? The log that I print looks wrong, but I had scratched my head for a long time, and don't know why this is wrong algo\n\n"
                    },
                    {
                        "username": "shubham3701",
                        "content": "You are checking from root to leaf node but it\\'s mentioned in the statement that the path can be from any node and end need not to be leaf node. Try this:\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.count=0\\n    def helper(self,root,s,S):\\n        if root==None:\\n            return\\n        s+=root.val\\n        if s==S:\\n            self.count+=1\\n            print(self.count,s,S)\\n        self.helper(root.left,s,S)\\n        self.helper(root.right,s,S)\\n        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        \\n        \\n        \\n        if root==None:\\n            return 0\\n        self.helper(root,0,targetSum)\\n        self.pathSum(root.left,targetSum)\\n        self.pathSum(root.right,targetSum)\\n        return self.count"
                    },
                    {
                        "username": "oscarbutt",
                        "content": "Have you found what\\'s wrong? I had the exactly same logic but couldn\\'t figure what\\'s wrong"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "Should be labeled Hard if you want to actually optimise time-complexity"
                    },
                    {
                        "username": "halfengineer",
                        "content": "For those who think why we have updated the map in last, for calculating the sum from other branch we have to remove the current path sum. Hope this helps.."
                    },
                    {
                        "username": "eddy66",
                        "content": "Just wonder if this problem is designed to force us to solve it by using `long` or `long long` type on purpose? or we actually have a different way to avoid integer overflow?"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "why does root=[1] have path=1? "
                    }
                ]
            },
            {
                "id": 1769788,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "try solving no of subarray of k sum first otherwise this is gonna be hard on you .\\nAlmost seems like problems of arrays keep repeating .\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "If you solved \"subarray sum equal to k\" (Leetcode 560), then this question is a cake walk..\\nHere is my solution : https://leetcode.com/problems/path-sum-iii/solutions/3750494/easy-to-understand-java-solution-100-faster/"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "please someone tell what is the problem with my code as an naive soln\\n\\n //PLEASE SOMEONE TELL WHAT IS PROBLEM WITH MY CODE\\nclass Solution {\\npublic:\\n    int checkforeverynode(TreeNode* node,int target){\\n        if(node==NULL) return 0;\\n        int l=target-node->val,ans=0;\\n        TreeNode* n=node;\\n        while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->left!=NULL){ l=l-(n->left->val);\\n            n=n->left;\\n        }\\n        else break;\\n    }\\n    n=node;\\n     l=target-node->val;\\n    while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->right!=NULL){ l=l-(n->right->val);\\n            n=n->right;\\n        }\\n        else break;\\n    }\\n\\n    return ans;\\n    }\\n    \\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n     return checkforeverynode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right,targetSum);\\n       \\n    \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any ideas on What if the path is allowed from left to right and right to left subtrees as well? What can be the approach and complexity in that case>"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Brute force will work only need to change int to long long int"
                    },
                    {
                        "username": "hofutsai",
                        "content": " ```class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        if root is None: \n            return 0\n        print('target: {}'.format(targetSum))\n        print('value: {}'.format(root.val))\n        print('---')\n        if root.val == targetSum: \n            res = 1\n        else: \n            res = 0\n        \n        return res + self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nCan someone help see why this is not correct? The log that I print looks wrong, but I had scratched my head for a long time, and don't know why this is wrong algo\n\n"
                    },
                    {
                        "username": "shubham3701",
                        "content": "You are checking from root to leaf node but it\\'s mentioned in the statement that the path can be from any node and end need not to be leaf node. Try this:\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.count=0\\n    def helper(self,root,s,S):\\n        if root==None:\\n            return\\n        s+=root.val\\n        if s==S:\\n            self.count+=1\\n            print(self.count,s,S)\\n        self.helper(root.left,s,S)\\n        self.helper(root.right,s,S)\\n        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        \\n        \\n        \\n        if root==None:\\n            return 0\\n        self.helper(root,0,targetSum)\\n        self.pathSum(root.left,targetSum)\\n        self.pathSum(root.right,targetSum)\\n        return self.count"
                    },
                    {
                        "username": "oscarbutt",
                        "content": "Have you found what\\'s wrong? I had the exactly same logic but couldn\\'t figure what\\'s wrong"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "Should be labeled Hard if you want to actually optimise time-complexity"
                    },
                    {
                        "username": "halfengineer",
                        "content": "For those who think why we have updated the map in last, for calculating the sum from other branch we have to remove the current path sum. Hope this helps.."
                    },
                    {
                        "username": "eddy66",
                        "content": "Just wonder if this problem is designed to force us to solve it by using `long` or `long long` type on purpose? or we actually have a different way to avoid integer overflow?"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "why does root=[1] have path=1? "
                    }
                ]
            },
            {
                "id": 1758972,
                "content": [
                    {
                        "username": "nitissssh",
                        "content": "try solving no of subarray of k sum first otherwise this is gonna be hard on you .\\nAlmost seems like problems of arrays keep repeating .\\n"
                    },
                    {
                        "username": "aftab0711",
                        "content": "If you solved \"subarray sum equal to k\" (Leetcode 560), then this question is a cake walk..\\nHere is my solution : https://leetcode.com/problems/path-sum-iii/solutions/3750494/easy-to-understand-java-solution-100-faster/"
                    },
                    {
                        "username": "HemantChoudhary",
                        "content": "please someone tell what is the problem with my code as an naive soln\\n\\n //PLEASE SOMEONE TELL WHAT IS PROBLEM WITH MY CODE\\nclass Solution {\\npublic:\\n    int checkforeverynode(TreeNode* node,int target){\\n        if(node==NULL) return 0;\\n        int l=target-node->val,ans=0;\\n        TreeNode* n=node;\\n        while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->left!=NULL){ l=l-(n->left->val);\\n            n=n->left;\\n        }\\n        else break;\\n    }\\n    n=node;\\n     l=target-node->val;\\n    while(n!=NULL){\\n            if(l==0) ans++;\\n            if(n->right!=NULL){ l=l-(n->right->val);\\n            n=n->right;\\n        }\\n        else break;\\n    }\\n\\n    return ans;\\n    }\\n    \\n\\n    int pathSum(TreeNode* root, int targetSum) {\\n        if(root==NULL) return 0;\\n     return checkforeverynode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right,targetSum);\\n       \\n    \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "tejasX",
                        "content": "Any ideas on What if the path is allowed from left to right and right to left subtrees as well? What can be the approach and complexity in that case>"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Brute force will work only need to change int to long long int"
                    },
                    {
                        "username": "hofutsai",
                        "content": " ```class Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        if root is None: \n            return 0\n        print('target: {}'.format(targetSum))\n        print('value: {}'.format(root.val))\n        print('---')\n        if root.val == targetSum: \n            res = 1\n        else: \n            res = 0\n        \n        return res + self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val) + self.pathSum(root.left, targetSum) + self.pathSum(root.right, targetSum)\n```\n\nCan someone help see why this is not correct? The log that I print looks wrong, but I had scratched my head for a long time, and don't know why this is wrong algo\n\n"
                    },
                    {
                        "username": "shubham3701",
                        "content": "You are checking from root to leaf node but it\\'s mentioned in the statement that the path can be from any node and end need not to be leaf node. Try this:\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.count=0\\n    def helper(self,root,s,S):\\n        if root==None:\\n            return\\n        s+=root.val\\n        if s==S:\\n            self.count+=1\\n            print(self.count,s,S)\\n        self.helper(root.left,s,S)\\n        self.helper(root.right,s,S)\\n        \\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        \\n        \\n        \\n        if root==None:\\n            return 0\\n        self.helper(root,0,targetSum)\\n        self.pathSum(root.left,targetSum)\\n        self.pathSum(root.right,targetSum)\\n        return self.count"
                    },
                    {
                        "username": "oscarbutt",
                        "content": "Have you found what\\'s wrong? I had the exactly same logic but couldn\\'t figure what\\'s wrong"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "Should be labeled Hard if you want to actually optimise time-complexity"
                    },
                    {
                        "username": "halfengineer",
                        "content": "For those who think why we have updated the map in last, for calculating the sum from other branch we have to remove the current path sum. Hope this helps.."
                    },
                    {
                        "username": "eddy66",
                        "content": "Just wonder if this problem is designed to force us to solve it by using `long` or `long long` type on purpose? or we actually have a different way to avoid integer overflow?"
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "why does root=[1] have path=1? "
                    }
                ]
            }
        ]
    }
]