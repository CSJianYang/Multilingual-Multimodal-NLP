[
    {
        "title": "Guess Number Higher or Lower",
        "question_content": "We are playing the Guess Game. The game is as follows:\nI pick a number from 1 to n. You have to guess which number I picked.\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\nYou call a pre-defined API int guess(int num), which returns three possible results:\n\n\t-1: Your guess is higher than the number I picked (i.e. num > pick).\n\t1: Your guess is lower than the number I picked (i.e. num < pick).\n\t0: your guess is equal to the number I picked (i.e. num == pick).\n\nReturn the number that I picked.\n&nbsp;\nExample 1:\n\nInput: n = 10, pick = 6\nOutput: 6\n\nExample 2:\n\nInput: n = 1, pick = 1\nOutput: 1\n\nExample 3:\n\nInput: n = 2, pick = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 231 - 1\n\t1 <= pick <= n",
        "solutions": [
            {
                "id": 84677,
                "title": "2-lines-as-usual-1-line-in-2022",
                "content": "Update April 2022, now that we have the `key` parameter:\\n\\n    def guessNumber(self, n: int) -> int:\\n        return bisect_left(range(n), 0, key=lambda num: -guess(num))\\n\\t\\t\\nUsing binary search to find the smallest number that\\'s not too small.\\n\\n```\\n    def guessNumber(self, n):\\n        class C: __getitem__ = lambda _, i: -guess(i)\\n        return bisect.bisect(C(), -1, 1, n)\\n```\\n\\nAlternatively, without using the library:\\n\\n```\\n    def guessNumber(self, n):\\n        lo, hi = 1, n\\n        while lo < hi:\\n            mid = (lo + hi) / 2\\n            if guess(mid) == 1:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n```\\n\\nFunny variation:\\n\\n```\\n    def guessNumber(self, n):\\n        lo, hi = 1, n\\n        while lo < hi:\\n            mid = (lo + hi) / 2\\n            lo, hi = ((mid, mid), (mid+1, hi), (lo, mid-1))[guess(mid)]\\n        return lo\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n    def guessNumber(self, n):\\n        class C: __getitem__ = lambda _, i: -guess(i)\\n        return bisect.bisect(C(), -1, 1, n)\\n```\n```\\n    def guessNumber(self, n):\\n        lo, hi = 1, n\\n        while lo < hi:\\n            mid = (lo + hi) / 2\\n            if guess(mid) == 1:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n```\n```\\n    def guessNumber(self, n):\\n        lo, hi = 1, n\\n        while lo < hi:\\n            mid = (lo + hi) / 2\\n            lo, hi = ((mid, mid), (mid+1, hi), (lo, mid-1))[guess(mid)]\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818874,
                "title": "python-c-java-rust-binary-search-to-halve-your-ignorance-bonus-o-0-one-liner-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs binary search to halve the interval of ignorance on each iteration. Time complexity is logarithmic: **O(logN)**. Space complexity is constant: **O(1)**.\\n****\\n**Comment.** Brute-force solution (i.e., guessing each number from `1` to `n` iteratively) is highly inefficient. Conveniently, the `guess` function provides us a way to query ranges, i.e., by calling `guess(m)` we are basically asking 3 questions simultaneously:\\n1. Is `m` the unknown number?\\n2. Does the unknown number lie on the interval `[1, m)`?\\n3. Does the unknown number lie on the interval `(m, n]`?\\n\\nOne of them will return a positive answer, thus, allowing us to either return the unknown number or update the interval of ignorance. It is known from the theory that halving the interval of ignorance is the best way to go, thus, we take a middle point on each iteration.\\n\\n**Python #1.** The full iterative algorithm. In Python, there is no overflow, so `(n + s) // 2` is safe.\\n```\\nclass Solution:\\n    def guessNumber(self, n, s=1):\\n        \\n        while s <= n:\\n            m = (n + s) // 2          # [1] Take the middle point...\\n            g = guess(m)              # [2] ...and guess!\\n            if g == 0 : return m      # [3] Yay, we found the number!\\n            if g < 0  : n = m - 1     # [4] Nope, it\\'s smaller...\\n            if g > 0  : s = m + 1     # [5] ...or larger.\\n```\\n\\n**Python #2.** There is also a recursive version of this solution. Note the math way to update the interval `[s,n]`. \\n```\\nclass Solution:\\n    def guessNumber(self, n, s=1):\\n        m = (s + n) // 2\\n        g = guess(m)\\n        n -= (n - m + 1)*g*(g-1)//2     # in these two lines, g-1 and g+1 act as binary flags\\n        s += (m - s + 1)*g*(g+1)//2     # for performing or not performing the change\\n        return m if not g else self.guessNumber(n, s)\\n```\\n\\n**Python #3.** We can kindly ask Python to peform binary search for us with a built-in *bisect_left* function. Note that `range(n)` is a generator, thus, uses **O(1)** space. (And no, it\\'s not the mentioned **BONUS** one-liner, see below)\\n```\\nclass Solution:\\n    def guessNumber(self, n):\\n        \\n        return bisect_left(range(n), 0, key=lambda m: -guess(m))\\n```\\n\\nI also provide the iterative solution in other languages. Note the `long` trick to account for possible `int` overflow. One can also use `m = s + (n-s) / 2`.\\n\\n<iframe src=\"https://leetcode.com/playground/CCrSc4QQ/shared\" frameBorder=\"0\" width=\"800\" height=\"350\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python #X.** Ok, now it\\'s time for a highly classified X-files secret solution, namely, for an **O(1)** (or should I call it **O(0)**???) one-liner.\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        return __pick__\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n, s=1):\\n        \\n        while s <= n:\\n            m = (n + s) // 2          # [1] Take the middle point...\\n            g = guess(m)              # [2] ...and guess!\\n            if g == 0 : return m      # [3] Yay, we found the number!\\n            if g < 0  : n = m - 1     # [4] Nope, it\\'s smaller...\\n            if g > 0  : s = m + 1     # [5] ...or larger.\\n```\n```\\nclass Solution:\\n    def guessNumber(self, n, s=1):\\n        m = (s + n) // 2\\n        g = guess(m)\\n        n -= (n - m + 1)*g*(g-1)//2     # in these two lines, g-1 and g+1 act as binary flags\\n        s += (m - s + 1)*g*(g+1)//2     # for performing or not performing the change\\n        return m if not g else self.guessNumber(n, s)\\n```\n```\\nclass Solution:\\n    def guessNumber(self, n):\\n        \\n        return bisect_left(range(n), 0, key=lambda m: -guess(m))\\n```\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        return __pick__\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84664,
                "title": "0ms-c-binary-search",
                "content": "```\\nint guessNumber(int n) {\\n        int maxNumber = n, minNumber = 1;\\n        while (true) {\\n            int meanNumber = (maxNumber - minNumber) / 2 + minNumber;\\n            // Do NOT use (maxNumber+minNumber)/2 in case of over flow\\n            int res = guess(meanNumber);\\n            if (res == 0) { \\n                return meanNumber;\\n            } else if (res == 1) {\\n                minNumber = meanNumber + 1;\\n            } else {\\n                maxNumber = meanNumber - 1;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint guessNumber(int n) {\\n        int maxNumber = n, minNumber = 1;\\n        while (true) {\\n            int meanNumber = (maxNumber - minNumber) / 2 + minNumber;\\n            // Do NOT use (maxNumber+minNumber)/2 in case of over flow\\n            int res = guess(meanNumber);\\n            if (res == 0) { \\n                return meanNumber;\\n            } else if (res == 1) {\\n                minNumber = meanNumber + 1;\\n            } else {\\n                maxNumber = meanNumber - 1;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 84662,
                "title": "what-is-the-difference-between-low-high-2-and-low-high-low-2",
                "content": "To do binary search, sometimes I see people use\\n```\\nmid = (low + high) / 2;\\n```\\nSometimes I see\\n```\\nmid = low + (high - low) / 2;\\n```\\n\\n*mid* will at most diff 1. What is the difference between these two approaches?\\n\\nHere is my code, it works with \"low + (high - low)\" but TLE with (low + high) / 2.\\n\\n```\\n    public int guessNumber(int n) {\\n        int low = 1, high = n;\\n        int result = low + (high - low) / 2;\\n        int guess = 0;\\n        while ((guess = (guess(result))) != 0) {\\n            if (guess > 0) {\\n                low = result + 1;\\n            } else {\\n                high = result - 1;\\n            }\\n            result = low + (high - low) / 2;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nmid = (low + high) / 2;\\n```\n```\\nmid = low + (high - low) / 2;\\n```\n```\\n    public int guessNumber(int n) {\\n        int low = 1, high = n;\\n        int result = low + (high - low) / 2;\\n        int guess = 0;\\n        while ((guess = (guess(result))) != 0) {\\n            if (guess > 0) {\\n                low = result + 1;\\n            } else {\\n                high = result - 1;\\n            }\\n            result = low + (high - low) / 2;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1001510,
                "title": "python-beats-99-solutions-o-log-n-w-comments-and-using-walrus-operator",
                "content": "```\\ndef guessNumber(self, n: int) -> int:\\n\\tlowerBound, upperBound = 1, n\\n\\t# Binary division faster than (lowerBound + upperBound) //2\\n\\tmyGuess = (lowerBound+upperBound) >> 1\\n\\t# walrus operator \\':=\\' - assigns value of the function to the variable \\'res\\'\\n\\t# and then compare res with 0\\n\\twhile (res := guess(myGuess)) != 0:\\n\\t\\tif res == 1:\\n\\t\\t\\tlowerBound = myGuess+1\\n\\t\\telse:\\n\\t\\t\\tupperBound = myGuess-1\\n\\t\\tmyGuess = (lowerBound+upperBound) >> 1\\n\\n\\treturn myGuess\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef guessNumber(self, n: int) -> int:\\n\\tlowerBound, upperBound = 1, n\\n\\t# Binary division faster than (lowerBound + upperBound) //2\\n\\tmyGuess = (lowerBound+upperBound) >> 1\\n\\t# walrus operator \\':=\\' - assigns value of the function to the variable \\'res\\'\\n\\t# and then compare res with 0\\n\\twhile (res := guess(myGuess)) != 0:\\n\\t\\tif res == 1:\\n\\t\\t\\tlowerBound = myGuess+1\\n\\t\\telse:\\n\\t\\t\\tupperBound = myGuess-1\\n\\t\\tmyGuess = (lowerBound+upperBound) >> 1\\n\\n\\treturn myGuess\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2818868,
                "title": "python3-ultimate-binary-search-template-works-for-many-problems",
                "content": "This is a classical binary search problem with the checking function given named \"guess\".\\n\\n**Solution to the problem** O(log n)\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        s = 1\\n        e = n+1\\n        while s+1<e:\\n            mid = (s+e)//2\\n            if guess(mid)>=0:\\n                s = mid\\n            else:\\n                e = mid\\n        return s\\n```\\n\\n**Binary Search Template with explanations**\\n\\nI was looking for an **intuitive binary search template** for a while and eventually found the following one that I really like. With this template, you won\\'t be confused with which index to return (start or end).\\nLet\\'s reformat the problem to use array and index for better understanding. **Problem**: Given an sorted array and a number target, return the index of target in the array. If target is not in array, return -1.\\n```python\\n\\ndef check(mid, target):\\n\\treturn target >= arr[mid]\\n\\ndef binarySearch(arr, target):\\n    start = 0               ### The smallest valid index\\n    end = len(arr)  \\t\\t### The largest valid index +1 (an invalid index, because 0-indexed)\\n    \\n    while start+1 < end:\\n\\n    \\t### the middle point between start and end\\n        mid = (start+end)//2\\n        \\n        ### In a binary search problem, we will need a check fundtion\\n        ### to check if mid is meeting the condition or not.\\n        ### In this case, we check if arr[mid] >= target.\\n        ### In the original problem, this function is given named \"guess\"\\n        \\n        ### when we check mid, there are three conditions:\\n        #   (1) target > mid, \\tmove start to mid\\n        #   (2) target < mid,\\tmove end to mid\\n        #   (3) target == mid, \\twe found it!\\n        ### let\\'s merge (1) and (3) together, then we have the following:\\n        \\n        ### The reason I have a check function here even though it just comparing two numbers\\n        ### is that in many other problems, the check function can go though an entire array or tree or other things.\\n        ### With this template, designing the correct check function is critical in solving other questions.\\n        if check(mid, target):\\n            start = mid\\n        else:\\n            end = mid\\n\\t\\t\\n\\t\\t### Note that, since (1) and (3) are merged, if there is a solution, it has to be start!\\n\\t\\t### Also remember start is a valid index at the beginning where end is an invalid index,\\n\\t\\t### and we make sure start is always valid during the process, so again if there is a \\n\\t\\t### solution, it has to be start\\n\\n\\t### Finally, remember to check if start meets the condition or not.\\n    return start if check(start) else -1\\n```\\n\\nThe advantage of this template is that we don\\'t need to think too much about the indices (e.g., +1, -1, odd, even, etc.) because we know that ```start``` will always be valid and meets the condition, so it should be the result at the end (if result exists). Note that, sometimes, depending on the problem, we may want to make ```end``` to be the result, and in that case, we will assign ```start``` to -1 (0-indexed) and let ```end``` be len(something)-1 at the beginning, and make sure ```end``` is always valid and meets the condition during the search.\\n\\n**Template with out comments:**\\n```python\\n\\ndef check(mid, target):\\n\\treturn target >= arr[mid]\\n\\ndef binarySearch(arr, target):\\n    start = 0\\n    end = len(arr)\\n    while start+1 < end:\\n        mid = (start+end)//2\\n        if check(mid, target):\\n            start = mid\\n        else:\\n            end = mid\\n    return start if check(start) else -1\\n```\\n\\n**Try this template on some medium questions!** remember to think about the check function!\\n[Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n[Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n[Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n[Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        s = 1\\n        e = n+1\\n        while s+1<e:\\n            mid = (s+e)//2\\n            if guess(mid)>=0:\\n                s = mid\\n            else:\\n                e = mid\\n        return s\\n```\n```python\\n\\ndef check(mid, target):\\n\\treturn target >= arr[mid]\\n\\ndef binarySearch(arr, target):\\n    start = 0               ### The smallest valid index\\n    end = len(arr)  \\t\\t### The largest valid index +1 (an invalid index, because 0-indexed)\\n    \\n    while start+1 < end:\\n\\n    \\t### the middle point between start and end\\n        mid = (start+end)//2\\n        \\n        ### In a binary search problem, we will need a check fundtion\\n        ### to check if mid is meeting the condition or not.\\n        ### In this case, we check if arr[mid] >= target.\\n        ### In the original problem, this function is given named \"guess\"\\n        \\n        ### when we check mid, there are three conditions:\\n        #   (1) target > mid, \\tmove start to mid\\n        #   (2) target < mid,\\tmove end to mid\\n        #   (3) target == mid, \\twe found it!\\n        ### let\\'s merge (1) and (3) together, then we have the following:\\n        \\n        ### The reason I have a check function here even though it just comparing two numbers\\n        ### is that in many other problems, the check function can go though an entire array or tree or other things.\\n        ### With this template, designing the correct check function is critical in solving other questions.\\n        if check(mid, target):\\n            start = mid\\n        else:\\n            end = mid\\n\\t\\t\\n\\t\\t### Note that, since (1) and (3) are merged, if there is a solution, it has to be start!\\n\\t\\t### Also remember start is a valid index at the beginning where end is an invalid index,\\n\\t\\t### and we make sure start is always valid during the process, so again if there is a \\n\\t\\t### solution, it has to be start\\n\\n\\t### Finally, remember to check if start meets the condition or not.\\n    return start if check(start) else -1\\n```\n```start```\n```end```\n```start```\n```end```\n```end```\n```python\\n\\ndef check(mid, target):\\n\\treturn target >= arr[mid]\\n\\ndef binarySearch(arr, target):\\n    start = 0\\n    end = len(arr)\\n    while start+1 < end:\\n        mid = (start+end)//2\\n        if check(mid, target):\\n            start = mid\\n        else:\\n            end = mid\\n    return start if check(start) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84668,
                "title": "short-java-code-using-binary-search",
                "content": "This problem is a binary search problem has an O(logn) complexity.\\n\\n    public int guessNumber(int n) {\\n        int i = 1, j = n;\\n        while(i < j) {\\n            int mid = i + (j - i) / 2;\\n            if(guess(mid) == 0) {\\n                return mid;\\n            } else if(guess(mid) == 1) {\\n                i = mid + 1;\\n            } else {\\n                j = mid;\\n            }\\n        }\\n        return i;\\n    }",
                "solutionTags": [],
                "code": "This problem is a binary search problem has an O(logn) complexity.\\n\\n    public int guessNumber(int n) {\\n        int i = 1, j = n;\\n        while(i < j) {\\n            int mid = i + (j - i) / 2;\\n            if(guess(mid) == 0) {\\n                return mid;\\n            } else if(guess(mid) == 1) {\\n                i = mid + 1;\\n            } else {\\n                j = mid;\\n            }\\n        }\\n        return i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2819657,
                "title": "c-faster-than-binary-search-repost",
                "content": "# Approach 1: just know the answer ;)\\n\\nWhy use binary search if you can just know the answer? This is just for your entertainmaint. :) I hope this doesn\\'t violate any LC ToS.\\n\\n```cpp\\n// USE AT YOUR OWN RISK.\\n//\\n// We need this stub so the code compiles.\\nclass Solution {\\npublic:\\n    static int guessNumber(const int n) {\\n        assert(false);        \\n        return -1;\\n    }\\n};\\n\\n// Our own main() replacing the one provided by leetcode.\\nint main(int argc, char* argv[]) {\\n    // For faster IO.\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n  \\n    // \"user.out\" is where the leetcode framework expects the result.\\n    ofstream fuserout(\"user.out\");\\n    \\n    // Reading STDIN and write out the answer.\\n    int n;\\n    int a;\\n    while (cin >> n >> a) {\\n        fuserout << a << \"\\\\n\";\\n    }\\n    \\n    return 0;\\n}\\n\\n// Move the leetcode standard main() out of the way.\\n#define main old_main\\n```\\n\\n**Complexity Analsysis**\\n  * Time Complexity: $$O(1)$$\\n  * Space Complexity: $$O(1)$$\\n\\n# Approach 2: binary search\\nI assume that\\'s the approach we are expected to use.\\n\\n```cpp\\n    static int guessNumber(const int n) {\\n        int lo = 1;\\n        int hi = n;\\n        while (lo <= hi) {\\n            const int mid = lo + (hi - lo) / 2;\\n            const int g = guess(mid);\\n            if (g == 0) {\\n                return mid;\\n            } else if (g == -1) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        // unreachable\\n        assert(false);\\n        return -1;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(\\\\log n)$$\\n  * Space Complexity: $$O(1)$$\\n\\nI am not sure why [my original post](https://leetcode.com/problems/guess-number-higher-or-lower/solutions/2818891/C++-oror-mind-reading:-just-know-the-answer-in-O(1)-time/) isn\\'t accesssible any more, but I reposted it.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n// USE AT YOUR OWN RISK.\\n//\\n// We need this stub so the code compiles.\\nclass Solution {\\npublic:\\n    static int guessNumber(const int n) {\\n        assert(false);        \\n        return -1;\\n    }\\n};\\n\\n// Our own main() replacing the one provided by leetcode.\\nint main(int argc, char* argv[]) {\\n    // For faster IO.\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n  \\n    // \"user.out\" is where the leetcode framework expects the result.\\n    ofstream fuserout(\"user.out\");\\n    \\n    // Reading STDIN and write out the answer.\\n    int n;\\n    int a;\\n    while (cin >> n >> a) {\\n        fuserout << a << \"\\\\n\";\\n    }\\n    \\n    return 0;\\n}\\n\\n// Move the leetcode standard main() out of the way.\\n#define main old_main\\n```\n```cpp\\n    static int guessNumber(const int n) {\\n        int lo = 1;\\n        int hi = n;\\n        while (lo <= hi) {\\n            const int mid = lo + (hi - lo) / 2;\\n            const int g = guess(mid);\\n            if (g == 0) {\\n                return mid;\\n            } else if (g == -1) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        // unreachable\\n        assert(false);\\n        return -1;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1518509,
                "title": "python-binary-search-solution",
                "content": "**Python :**\\n\\n```\\ndef guessNumber(self, n: int) -> int:\\n\\tlow = 0\\n\\thigh = n\\n\\twhile low <= high:\\n\\t\\tmid = (low + high ) // 2\\n\\t\\tres = guess(mid)\\n\\t\\tif res < 0:\\n\\t\\t\\thigh = mid - 1\\n\\n\\t\\telif res > 0:\\n\\t\\t\\tlow = mid + 1\\n\\n\\t\\telse:\\n\\t\\t\\treturn mid\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef guessNumber(self, n: int) -> int:\\n\\tlow = 0\\n\\thigh = n\\n\\twhile low <= high:\\n\\t\\tmid = (low + high ) // 2\\n\\t\\tres = guess(mid)\\n\\t\\tif res < 0:\\n\\t\\t\\thigh = mid - 1\\n\\n\\t\\telif res > 0:\\n\\t\\t\\tlow = mid + 1\\n\\n\\t\\telse:\\n\\t\\t\\treturn mid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2818894,
                "title": "will-never-ever-use-mid-start-end-2",
                "content": "using (start + end)/2 instead of mid= start+(end-start)/2 will lead to overflows(beg + end > Integer.MAX_VALUE) or change all the int variable to the long variables \\n\\n\\n\\n**Extended Explanation**\\nthe variable mid exceeds the limit and becomes negative:- int can take values upto -2^31 to (2^31)-1\\nie, 01111111111111111111111111111111 to 10000000000000000000000000000000\\nso if we add 1 to 01111111111111111111111111111111 we get 010000000000000000000000000000000 but since our int can\\'t store all the bits\\nit just stores 10000000000000000000000000000000 and that is negative so our binary search just keeps oscillating and ends up in an infinite loop\\n\\n# Code\\n```\\n\\n    public int guessNumber(int n) {\\n\\n\\n        int start=1, end=n, mid;\\n\\n        while( start<=end){\\n            \\n            mid= start+(end- start)/2;\\n\\n            if( guess(mid)==0) return mid;\\n            else if( guess(mid)==1) start=mid+1;\\n            else end=mid-1; \\n        }\\n\\n        return -1;\\n}\\n```\\n\\nchanging all the int variable to the long type variables\\n\\n```\\n\\n    public int guessNumber(int n) {\\n\\n\\n        long start=1, end=n, mid;\\n        while( start<=end){\\n            \\n            mid= (start+end)/2;\\n\\n            if( guess((int)mid)==0) return (int)mid;\\n            else if( guess((int)mid)==1) start=mid+1;\\n            else end=mid-1; \\n        }\\n\\n        return -1;\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public int guessNumber(int n) {\\n\\n\\n        int start=1, end=n, mid;\\n\\n        while( start<=end){\\n            \\n            mid= start+(end- start)/2;\\n\\n            if( guess(mid)==0) return mid;\\n            else if( guess(mid)==1) start=mid+1;\\n            else end=mid-1; \\n        }\\n\\n        return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212562,
                "title": "c-binary-search-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize first to 1 and last to n.\\n2. While first is less than or equal to last, do the following:\\n    a. Compute mid as first + (last - first) / 2.\\n    b. If guess(mid) returns 0, return mid.\\n    c. If guess(mid) returns -1, update last to mid - 1.\\n    d. If guess(mid) returns 1, update first to mid + 1.\\n3. Return -1.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int first = 1, last = n;\\n        while (first <= last) {\\n            int mid = first + (last - first) / 2;\\n            if (guess(mid) == 0)\\n                return mid;\\n            else if (guess(mid) == -1)\\n                last = mid - 1;\\n            else\\n                first = mid + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int first = 1, last = n;\\n        while (first <= last) {\\n            int mid = first + (last - first) / 2;\\n            int res = guess(mid);\\n            if (res == 0) {\\n                return mid;\\n            } else if (res == -1) {\\n                last = mid - 1;\\n            } else {\\n                first = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution(GuessGame):\\n    def guessNumber(self, n: int) -> int:\\n        first, last = 1, n\\n        while first <= last:\\n            mid = first + (last - first) // 2\\n            res = self.guess(mid)\\n            if res == 0:\\n                return mid\\n            elif res == -1:\\n                last = mid - 1\\n            else:\\n                first = mid + 1\\n        return -1\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(logn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```C++ []\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int first = 1, last = n;\\n        while (first <= last) {\\n            int mid = first + (last - first) / 2;\\n            if (guess(mid) == 0)\\n                return mid;\\n            else if (guess(mid) == -1)\\n                last = mid - 1;\\n            else\\n                first = mid + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```Java []\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int first = 1, last = n;\\n        while (first <= last) {\\n            int mid = first + (last - first) / 2;\\n            int res = guess(mid);\\n            if (res == 0) {\\n                return mid;\\n            } else if (res == -1) {\\n                last = mid - 1;\\n            } else {\\n                first = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution(GuessGame):\\n    def guessNumber(self, n: int) -> int:\\n        first, last = 1, n\\n        while first <= last:\\n            mid = first + (last - first) // 2\\n            res = self.guess(mid)\\n            if res == 0:\\n                return mid\\n            elif res == -1:\\n                last = mid - 1\\n            else:\\n                first = mid + 1\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804814,
                "title": "c-0-ms-binary-search-easy-to-understand",
                "content": "\\t\\t//using binary search\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint guessNumber(int n) \\n\\t\\t\\t{\\n\\t\\t\\t\\tlong l=1;   //low\\n\\t\\t\\t\\tlong h=n;   //high\\n\\t\\t\\t\\tlong mid;\\n\\t\\t\\t\\twhile(l<=h)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmid= (l+h)/2;\\n\\t\\t\\t\\t\\tif(guess(mid)==1)           //guess API\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tl=mid+1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(guess(mid)==-1)         //guess API\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\th=mid-1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn l;\\n\\t\\t\\t}\\n\\t\\t}; \\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint guessNumber(int n) \\n\\t\\t\\t{\\n\\t\\t\\t\\tlong l=1;   //low\\n\\t\\t\\t\\tlong h=n;   //high\\n\\t\\t\\t\\tlong mid;\\n\\t\\t\\t\\twhile(l<=h)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmid= (l+h)/2;\\n\\t\\t\\t\\t\\tif(guess(mid)==1)           //guess API\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tl=mid+1;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1593834,
                "title": "log-n-java-solution-0ms-100-faster",
                "content": "**Upvote if you LIKE** \\uD83D\\uDE42\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n\\n        int l = 1, r = n;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(guess(mid) == 0)\\n                return mid;\\n            else if(guess(mid) == 1)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        \\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n\\n        int l = 1, r = n;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(guess(mid) == 0)\\n                return mid;\\n            else if(guess(mid) == 1)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 84719,
                "title": "python-solution-using-binary-search",
                "content": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\\n# def guess(num):\\n\\nclass Solution(object):\\n    def guessNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        low = 1\\n        high = n\\n        while low <= high:\\n            mid = (low + high)//2\\n            res =  guess(mid)\\n            if res == 0 :\\n                return mid\\n            elif res == -1:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n                \\n```",
                "solutionTags": [],
                "code": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\\n# def guess(num):\\n\\nclass Solution(object):\\n    def guessNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        low = 1\\n        high = n\\n        while low <= high:\\n            mid = (low + high)//2\\n            res =  guess(mid)\\n            if res == 0 :\\n                return mid\\n            elif res == -1:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820550,
                "title": "java-faster-than-100-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int start=0,end=n;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)==-1)\\n                end=mid-1;\\n            else\\n                start=mid+1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int start=0,end=n;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)==-1)\\n                end=mid-1;\\n            else\\n                start=mid+1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717871,
                "title": "dont-try-this-code-one-line-python-code",
                "content": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        return __pick__\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        return __pick__\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975666,
                "title": "binary-search-100-faster-solution",
                "content": "Binary Search\\n```\\n    private static int guessNumber(int n) {\\n        return guess(n) == 0 ? n : guessNumberSearch(0, n);\\n    }\\n\\t\\n\\tprivate static int guessNumberSearch(int l, int r) {\\n        int mid = l + (r - l) / 2;\\n        if (guess(mid) == 0) {\\n            return mid;\\n        }\\n        if (guess(mid) == -1) {\\n            return guessNumberSearch(l, mid - 1);\\n        }else {\\n            return guessNumberSearch(mid + 1, r);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n    private static int guessNumber(int n) {\\n        return guess(n) == 0 ? n : guessNumberSearch(0, n);\\n    }\\n\\t\\n\\tprivate static int guessNumberSearch(int l, int r) {\\n        int mid = l + (r - l) / 2;\\n        if (guess(mid) == 0) {\\n            return mid;\\n        }\\n        if (guess(mid) == -1) {\\n            return guessNumberSearch(l, mid - 1);\\n        }else {\\n            return guessNumberSearch(mid + 1, r);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517483,
                "title": "python-binary-search-explained",
                "content": "If you ever played this game in real life like I did, it is pretty straightforward: you need to use binary search. Imagine that our range is `[1, 100]`. Then in the first question you ask information about number `50`. Depending on answer you either win or have interavals `[1, 49]` or `[51, 100]` and you continue in the same manner.\\n\\n####  Complexity\\nIt is `O(log n)` for time and `O(1)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def guessNumber(self, n):\\n        beg, end = 1, n\\n        while beg <= end:\\n            mid = (beg + end)//2\\n            t = guess(mid)\\n            if t == 0: return mid\\n            if t == -1: end = mid - 1\\n            if t == 1:  beg = mid + 1\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def guessNumber(self, n):\\n        beg, end = 1, n\\n        while beg <= end:\\n            mid = (beg + end)//2\\n            t = guess(mid)\\n            if t == 0: return mid\\n            if t == -1: end = mid - 1\\n            if t == 1:  beg = mid + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250471,
                "title": "374-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We initialize two variables left and right with 1 and n respectively, which represent the start and end points of our search range.\\n\\n2. We use a while loop to perform the binary search until we guess the correct number.\\n\\n3. In each iteration, we calculate the middle point of the search range using (left + right) // 2.\\n\\n4. We then use the guess function to check if the middle point is the correct number or not. If it is the correct number, we return it.\\n\\n5. If the guess is greater than the picked number, we update our search range to the left half by setting right = mid - 1.\\n\\n6. If the guess is smaller than the picked number, we update our search range to the right half by setting left = mid + 1.\\n\\n7. If we exhaust our search range and still haven\\'t found the correct number, we return -1.\\n\\nNote: The guess function is not defined in the solution code because it is a pre-defined API function provided by the question prompt. We can assume that it takes an integer as input and returns 0 if the integer is the correct number, 1 if it is lower than the correct number, and -1 if it is greater than the correct number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        left, right = 1, n\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = guess(mid)\\n            \\n            if res == 0:\\n                return mid\\n            elif res < 0:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        left, right = 1, n\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            res = guess(mid)\\n            \\n            if res == 0:\\n                return mid\\n            elif res < 0:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819865,
                "title": "c-ternary-search-modification-of-binary-search",
                "content": "# Intuition\\nDivide the RANGE INTO 3 PARTS INSTEAD OF 2\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of doing Binary search we are dividing the range into 3 parts , which will minimise the fuction calls . \\nwe have two mid points m1 and m2 . and we obtain the result by using them (See the code) .\\n\\n\\n# Complexity\\n- Time complexity: log(N) base 3 \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l=1,r=n ;\\n        while(l<=r)\\n        {\\n            int m= l+ (r-l)/2;\\n            int m1= l+(m-l)/2 , m2=m+(r-m)/2;\\n            int k1=guess(m1) , k2=guess(m2);\\n            if(k1==0) return m1;\\n            else if(k2==0) return m2;\\n            else if(k1==-1) r=m1-1;\\n            else if(k2==1) l=m2+1;\\n            else \\n            {\\n                l=m1+1;\\n                r=m2-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l=1,r=n ;\\n        while(l<=r)\\n        {\\n            int m= l+ (r-l)/2;\\n            int m1= l+(m-l)/2 , m2=m+(r-m)/2;\\n            int k1=guess(m1) , k2=guess(m2);\\n            if(k1==0) return m1;\\n            else if(k2==0) return m2;\\n            else if(k1==-1) r=m1-1;\\n            else if(k2==1) l=m2+1;\\n            else \\n            {\\n                l=m1+1;\\n                r=m2-1;\\n            }\\n\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819126,
                "title": "python-3-7-lines-binary-search-w-explanation-and-example-t-m-99-8-42",
                "content": "The problem is a binary search, in which \" m < target\" is equivalent to guess(m) == 1 and \" m > target\" is equivalent to guess(m) == -1.\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n\\n        l, r= 1, n                          #     Ex: n = 20  pick = 8\\n                                            #\\n        while r >= l:                       #       l     r     m   guess(m)  \\n                                            #      \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\n            m = (l + r)//2                  #       1     20    10     -1\\n            query =  guess(m)\\t\\t        #       1     10     5     -1\\n                                            #       6     10     8      0\\n            if query ==  1: l = m+1         #                    |       \\n            elif query == -1: r = m         #                  answer\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \\n            else: return m\\n```\\n[https://leetcode.com/submissions/detail/595048857/](http://)",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n\\n        l, r= 1, n                          #     Ex: n = 20  pick = 8\\n                                            #\\n        while r >= l:                       #       l     r     m   guess(m)  \\n                                            #      \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\n            m = (l + r)//2                  #       1     20    10     -1\\n            query =  guess(m)\\t\\t        #       1     10     5     -1\\n                                            #       6     10     8      0\\n            if query ==  1: l = m+1         #                    |       \\n            elif query == -1: r = m         #                  answer\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    \\n            else: return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818891,
                "title": "c-faster-than-binary-search",
                "content": "[ looks like this post is visible again, in the meantime I [reposted](https://leetcode.com/problems/guess-number-higher-or-lower/discuss/2819657/C%2B%2B-oror-faster-than-binary-search-(repost)) it. ]\\n\\n# Approach 1: just know the answer ;)\\n\\nWhy use binary search if you can just know the answer? This is just for your entertainmaint. :)\\n\\n```cpp\\n// USE AT YOUR OWN RISK.\\n//\\n// We need this stub so the code compiles.\\nclass Solution {\\npublic:\\n    static int guessNumber(const int n) {\\n        assert(false);        \\n        return -1;\\n    }\\n};\\n\\n// Our own main() replacing the one provided by leetcode.\\nint main(int argc, char* argv[]) {\\n    // For faster IO.\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n  \\n    // \"user.out\" is where the leetcode framework expects the result.\\n    ofstream fuserout(\"user.out\");\\n    \\n    // Reading STDIN and write out the answer.\\n    int n;\\n    int a;\\n    while (cin >> n >> a) {\\n        fuserout << a << \"\\\\n\";\\n    }\\n    \\n    return 0;\\n}\\n\\n// Move the leetcode standard main() out of the way.\\n#define main old_main\\n```\\n\\n**Complexity Analsysis**\\n  * Time Complexity: $$O(1)$$\\n  * Space Complexity: $$O(1)$$\\n\\n\\n# Approach 2: binary search\\nI assume that\\'s the approach we are expected to use.\\n\\n```cpp\\n    static int guessNumber(const int n) {\\n        int lo = 1;\\n        int hi = n;\\n        while (lo <= hi) {\\n            const int mid = lo + (hi - lo) / 2;\\n            const int g = guess(mid);\\n            if (g == 0) {\\n                return mid;\\n            } else if (g == -1) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        // unreachable\\n        assert(false);\\n        return -1;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(\\\\log n)$$\\n  * Space Complexity: $$O(1)$$\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n// USE AT YOUR OWN RISK.\\n//\\n// We need this stub so the code compiles.\\nclass Solution {\\npublic:\\n    static int guessNumber(const int n) {\\n        assert(false);        \\n        return -1;\\n    }\\n};\\n\\n// Our own main() replacing the one provided by leetcode.\\nint main(int argc, char* argv[]) {\\n    // For faster IO.\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n  \\n    // \"user.out\" is where the leetcode framework expects the result.\\n    ofstream fuserout(\"user.out\");\\n    \\n    // Reading STDIN and write out the answer.\\n    int n;\\n    int a;\\n    while (cin >> n >> a) {\\n        fuserout << a << \"\\\\n\";\\n    }\\n    \\n    return 0;\\n}\\n\\n// Move the leetcode standard main() out of the way.\\n#define main old_main\\n```\n```cpp\\n    static int guessNumber(const int n) {\\n        int lo = 1;\\n        int hi = n;\\n        while (lo <= hi) {\\n            const int mid = lo + (hi - lo) / 2;\\n            const int g = guess(mid);\\n            if (g == 0) {\\n                return mid;\\n            } else if (g == -1) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        // unreachable\\n        assert(false);\\n        return -1;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1517494,
                "title": "c-super-simple-and-short-binary-search-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int lo = 1, hi = n, mid, result;\\n        \\n        while (lo <= hi) {\\n            mid = lo + (hi - lo) / 2;\\n            result = guess(mid);\\n            \\n            if (result == 0) return mid;\\n            if (result < 0) hi = mid - 1;\\n            else lo = mid + 1;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int lo = 1, hi = n, mid, result;\\n        \\n        while (lo <= hi) {\\n            mid = lo + (hi - lo) / 2;\\n            result = guess(mid);\\n            \\n            if (result == 0) return mid;\\n            if (result < 0) hi = mid - 1;\\n            else lo = mid + 1;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84687,
                "title": "2ms-java",
                "content": "A typical binary search problem. `(l & r) + ((l ^ r) >> 1)` avoids the overflow (a much easier alternative is `l + (r - l) / 2`).\\n```\\n/* The guess API is defined in the parent class GuessGame.\\n   @param num, your guess\\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\\n      int guess(int num); */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 0, r = n;\\n        while (l < r) {\\n            int m = (l & r) + ((l ^ r) >> 1);\\n            if (guess(m) == 0) return m;\\n            else if (guess(m) == 1) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* The guess API is defined in the parent class GuessGame.\\n   @param num, your guess\\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\\n      int guess(int num); */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 0, r = n;\\n        while (l < r) {\\n            int m = (l & r) + ((l ^ r) >> 1);\\n            if (guess(m) == 0) return m;\\n            else if (guess(m) == 1) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973625,
                "title": "java-1000-beats-easy-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUPVOTE ME\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --!>\\n\\n Time complexity:0(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n      int low = 1 , high = n;\\n      while(low < high){\\n        int mid = low +(high - low)/2;\\n        if(guess(mid)==0) return mid;   \\n        else if(guess(mid)==1) low=mid+1;\\n        else high=mid;  \\n      }\\n    return low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n      int low = 1 , high = n;\\n      while(low < high){\\n        int mid = low +(high - low)/2;\\n        if(guess(mid)==0) return mid;   \\n        else if(guess(mid)==1) low=mid+1;\\n        else high=mid;  \\n      }\\n    return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820236,
                "title": "c-binary-search-saves-the-day-see-how",
                "content": "# Thought Process:\\nHint for binary search: - We have a sorted array of numbers *(From 1 to n)*.\\n\\nSo fellas, we have been provided with a sorted array and we have to decide which number is being picked by the test case.\\n\\nBut How binary search saves the day?\\n\\nFor example:-\\n```\\nn = 10, pick = 7\\n```\\n\\nSay, ```i = 1``` and ```j = n```.\\n\\n**1st iteration**\\n```\\nmid = (10+1)/2 = 11/2 = 5\\nguess(5) = 1\\n\\nThis proves that the answer lies in range [6,10]. Therefore i = 6, j = 10.\\n```\\n\\n**2nd iteration**\\n```\\nmid = (6+10)/2 = 16/2 = 8\\nguess (8) = -1\\n\\nThis proves that the answer lies in the range [6,7]. Therefore i = 6, j = 7.\\n```\\n\\n**3rd iteration**\\n```\\nmid = (6+7) = 13/2 = 6\\nguess(6) = 1\\n\\nThis proves that the answer lies in the range [7,7]. Therefore i = 7, j = 7.\\n```\\n\\n**4th iteration**\\n```\\nmid = (7+7)/2 = 14/2 = 7\\nguess(7) = 0\\n\\nSince guess(7) = 0, return 7.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        \\n        int front = 1, end = n;\\n        \\n        while (front <= end){\\n            int mid = ((unsigned int)front + (unsigned int)end) >> 1;\\n            if (guess (mid) == -1){\\n                end = mid - 1;\\n            }\\n            \\n            else if (guess (mid) == 1){\\n                front = mid + 1;\\n            }\\n            \\n            else {\\n                return mid;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n# Complexities:\\n**TC:** O(logn)\\n**SC:** O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nn = 10, pick = 7\\n```\n```i = 1```\n```j = n```\n```\\nmid = (10+1)/2 = 11/2 = 5\\nguess(5) = 1\\n\\nThis proves that the answer lies in range [6,10]. Therefore i = 6, j = 10.\\n```\n```\\nmid = (6+10)/2 = 16/2 = 8\\nguess (8) = -1\\n\\nThis proves that the answer lies in the range [6,7]. Therefore i = 6, j = 7.\\n```\n```\\nmid = (6+7) = 13/2 = 6\\nguess(6) = 1\\n\\nThis proves that the answer lies in the range [7,7]. Therefore i = 7, j = 7.\\n```\n```\\nmid = (7+7)/2 = 14/2 = 7\\nguess(7) = 0\\n\\nSince guess(7) = 0, return 7.\\n```\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        \\n        int front = 1, end = n;\\n        \\n        while (front <= end){\\n            int mid = ((unsigned int)front + (unsigned int)end) >> 1;\\n            if (guess (mid) == -1){\\n                end = mid - 1;\\n            }\\n            \\n            else if (guess (mid) == 1){\\n                front = mid + 1;\\n            }\\n            \\n            else {\\n                return mid;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819364,
                "title": "100-faster-java-solution-using-both-recursion-and-iteration",
                "content": "# Recursive Approach\\n```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n\\t  return binarySearch(1,n);\\n    }\\n    public int binarySearch(int low,int high){\\n        int mid=low+(high-low)/2;\\n        if(guess(mid)==0){\\n            return mid;\\n        }\\n        if(guess(mid)==1){\\n            return binarySearch(mid+1,high);\\n        }\\n        else{\\n            return binarySearch(low,mid-1);\\n        }\\n    }\\n    \\n}\\n```\\n# Iterative Approach\\n```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low=1,high=n,mid=n;\\n      while(guess(mid)!=0){\\n          mid=low+(high-low)/2;\\n          if(guess(mid)==1){\\n             low=mid+1;\\n          }\\n          else{\\n              high=mid-1;\\n          }\\n      }\\n      return mid;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n\\t  return binarySearch(1,n);\\n    }\\n    public int binarySearch(int low,int high){\\n        int mid=low+(high-low)/2;\\n        if(guess(mid)==0){\\n            return mid;\\n        }\\n        if(guess(mid)==1){\\n            return binarySearch(mid+1,high);\\n        }\\n        else{\\n            return binarySearch(low,mid-1);\\n        }\\n    }\\n    \\n}\\n```\n```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low=1,high=n,mid=n;\\n      while(guess(mid)!=0){\\n          mid=low+(high-low)/2;\\n          if(guess(mid)==1){\\n             low=mid+1;\\n          }\\n          else{\\n              high=mid-1;\\n          }\\n      }\\n      return mid;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517333,
                "title": "c-java-easy-binary-search-faster-than-100",
                "content": "**[Github Repo Link](https://github.com/bhaumikmaan/Competitve-Programming-Solutions/tree/main/LeetCode)** - *Do star the repo :)*\\n**IDEA**\\nIf your output from `guess()` is: \\n```\\n-1 : Your number is lower -> Change Right = mid - 1.\\n1 : Your number is higher. -> Change Left = mid + 1.\\n0 : Number Found! -> Return that number\\n```\\nSo we use binary search for this problem!\\n**NOTE:** Use `mid = l + (r - l)/2` so integer does not overflow\\n\\n**SOLUTION**\\n`IN C++`\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l = 1 , r = n ;\\n        while(l <= r) \\n        {\\n            int m = l + (r-l)/2 ;\\n            if(guess(m) == 0) \\n                return m ;\\n            if(guess(m) < 0) \\n                r = m - 1 ;\\n            else \\n                l = m + 1 ;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n`IN JAVA`\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1 , r = n ;\\n        while(l <= r) \\n        {\\n            int m = l + (r-l)/2 ;\\n            if(guess(m) == 0) \\n                return m ;\\n            if(guess(m) < 0) \\n                r = m - 1 ;\\n            else \\n                l = m + 1 ;\\n        }\\n        return 0;\\n    }\\n}\\n```\\nIf you liked it, don\\'t forget to upvote :)",
                "solutionTags": [],
                "code": "```\\n-1 : Your number is lower -> Change Right = mid - 1.\\n1 : Your number is higher. -> Change Left = mid + 1.\\n0 : Number Found! -> Return that number\\n```\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l = 1 , r = n ;\\n        while(l <= r) \\n        {\\n            int m = l + (r-l)/2 ;\\n            if(guess(m) == 0) \\n                return m ;\\n            if(guess(m) < 0) \\n                r = m - 1 ;\\n            else \\n                l = m + 1 ;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1 , r = n ;\\n        while(l <= r) \\n        {\\n            int m = l + (r-l)/2 ;\\n            if(guess(m) == 0) \\n                return m ;\\n            if(guess(m) < 0) \\n                r = m - 1 ;\\n            else \\n                l = m + 1 ;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517295,
                "title": "javascript-solution-beats-99",
                "content": "```\\nvar guessNumber = function(n) {\\n    let l = 0, r = n-1;\\n    while(l  <= r ){\\n        let mid = Math.floor((l+r)/2);\\n        let res = guess(mid);\\n        if(res == 0) return mid;\\n        else if (res == 1) l = mid+1;\\n        else r = mid-1;\\n    }\\n    return l;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar guessNumber = function(n) {\\n    let l = 0, r = n-1;\\n    while(l  <= r ){\\n        let mid = Math.floor((l+r)/2);\\n        let res = guess(mid);\\n        if(res == 0) return mid;\\n        else if (res == 1) l = mid+1;\\n        else r = mid-1;\\n    }\\n    return l;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819307,
                "title": "c-easy-understanding-binary-search-video-solution",
                "content": "**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/XSwfObGK_g0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n\\n        int left = 1;\\n        int right = n;\\n\\n        while(left<=right){\\n            // calculate mid .\\n            int mid = left + (right-left)/2;\\n\\n            // get result for mid.\\n            int val = guess(mid);\\n\\n            if(val == 0) return mid;\\n            else if(val == -1 ) right = mid-1;\\n            else left = mid+1;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n\\n        int left = 1;\\n        int right = n;\\n\\n        while(left<=right){\\n            // calculate mid .\\n            int mid = left + (right-left)/2;\\n\\n            // get result for mid.\\n            int val = guess(mid);\\n\\n            if(val == 0) return mid;\\n            else if(val == -1 ) right = mid-1;\\n            else left = mid+1;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819274,
                "title": "most-easy-c-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n       int i=1, mid=n/2, k, l=0;\\n       if(guess(mid)==0)\\n       return mid;\\n       else if(guess(mid)==-1)\\n       k=mid, l=0;\\n       else\\n       k=n, l=mid;\\n       for(i=l;i<k;i++)\\n       {\\n           if(guess(i)==0)\\n           break;\\n         \\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n       int i=1, mid=n/2, k, l=0;\\n       if(guess(mid)==0)\\n       return mid;\\n       else if(guess(mid)==-1)\\n       k=mid, l=0;\\n       else\\n       k=n, l=mid;\\n       for(i=l;i<k;i++)\\n       {\\n           if(guess(i)==0)\\n           break;\\n         \\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593798,
                "title": "python-o-1-cheese",
                "content": "Don\\'t try this at home kids haha!\\n\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        return __pick__\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        return __pick__\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955883,
                "title": "easy-to-understand-java",
                "content": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int start = 1, end = n;\\n        while(start <= end){\\n            int mid = start+(end-start)/2;     \\n            if(guess(mid) == 0) return mid;\\n            else if(guess(mid) == -1) end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**NOTE**\\nif you write **mid = (start+end)/2** will give **TLE** for\\n2126753390\\n1702766719\\n\\ndue to **Integer Overflow**\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote**\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int start = 1, end = n;\\n        while(start <= end){\\n            int mid = start+(end-start)/2;     \\n            if(guess(mid) == 0) return mid;\\n            else if(guess(mid) == -1) end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517535,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    unsafe fn guessNumber(n: i32) -> i32 {\\n        let (mut low, mut high) = (1, n);\\n        loop {\\n            let mid = low + (high - low) / 2;\\n            match guess(mid) {\\n                0 => break mid,\\n                -1 => high = mid - 1,\\n                _ => low = mid + 1,\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nimpl Solution {\\n    unsafe fn guessNumber(n: i32) -> i32 {\\n        let (mut low, mut high) = (1, n);\\n        loop {\\n            let mid = low + (high - low) / 2;\\n            match guess(mid) {\\n                0 => break mid,\\n                -1 => high = mid - 1,\\n                _ => low = mid + 1,\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517080,
                "title": "javascript-easy-to-understand-loop-or-recursive",
                "content": "It\\'s a standard binary search problem. So, we just write the code.\\n\\n# LOOP\\n\\n```js\\nconst guessNumber = (right) => {\\n  let left = 1;\\n  while (true) {\\n    const mid = ((left + right) / 2) << 0;\\n    const result = guess(mid);\\n    if (result === 0) return mid;\\n    result === 1 ? left = mid + 1 : right = mid - 1;\\n  }\\n};\\n```\\n\\n# RECURSIVE\\n\\n```js\\nconst guessNumber = (right, left = 1) => {\\n  const mid = ((left + right) / 2) << 0;\\n  switch(guess(mid)) {\\n    case 0:\\n      return mid;\\n    case -1:\\n      return guessNumber(mid - 1, left);\\n    case 1:\\n      return guessNumber(right, mid + 1);\\n  }\\n};\\n```\\n\\nor maybe you\\'d like to put all situations in a map:\\n\\n```js\\nconst next = {\\n  0: (mid, left, right) => mid,\\n  \"-1\": (mid, left, right) => guessNumber(mid - 1, left),\\n  1: (mid, left, right) => guessNumber(right, mid + 1),\\n};\\nconst guessNumber = (right, left = 1, mid = ((left + right) / 2) << 0) => next[guess(mid)](mid, left, right);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst guessNumber = (right) => {\\n  let left = 1;\\n  while (true) {\\n    const mid = ((left + right) / 2) << 0;\\n    const result = guess(mid);\\n    if (result === 0) return mid;\\n    result === 1 ? left = mid + 1 : right = mid - 1;\\n  }\\n};\\n```\n```js\\nconst guessNumber = (right, left = 1) => {\\n  const mid = ((left + right) / 2) << 0;\\n  switch(guess(mid)) {\\n    case 0:\\n      return mid;\\n    case -1:\\n      return guessNumber(mid - 1, left);\\n    case 1:\\n      return guessNumber(right, mid + 1);\\n  }\\n};\\n```\n```js\\nconst next = {\\n  0: (mid, left, right) => mid,\\n  \"-1\": (mid, left, right) => guessNumber(mid - 1, left),\\n  1: (mid, left, right) => guessNumber(right, mid + 1),\\n};\\nconst guessNumber = (right, left = 1, mid = ((left + right) / 2) << 0) => next[guess(mid)](mid, left, right);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 542169,
                "title": "classic-binary-and-some-pitfalls",
                "content": "mid = low + (high - low) / 2; right side is inclusive, say high = n, does not handle overflow, say high = Integer.MAX_VALUE;\\nmid = (high + low) / 2; right side is exclusive, say high = n + 1, handles overflow.\\n\\n```\\n    public int guessNumber(int n) {\\n        int l = 1, r = n;\\n        while( l < r) {\\n            int mid = l + (r - l) / 2;\\n            int g = guess(mid);\\n            if (g == 0) return mid;\\n            else if (g == -1) r = mid - 1;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int guessNumber(int n) {\\n        int l = 1, r = n;\\n        while( l < r) {\\n            int mid = l + (r - l) / 2;\\n            int g = guess(mid);\\n            if (g == 0) return mid;\\n            else if (g == -1) r = mid - 1;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3227308,
                "title": "c-using-binary-search",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int start = 0 ; \\n        int end = n ; \\n        while (start <= end)\\n        {\\n            int mid = start + (end - start)/2 ;\\n            int g = guess(mid) ;\\n            if (g == 0)\\n            {\\n                return mid ;\\n            }\\n            else if (g < 0)\\n            {\\n                end = mid - 1 ;\\n            }\\n            else\\n            {\\n                start = mid + 1 ; \\n            }\\n        }\\n        return -1 ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/1d986e16-1e5e-4f2e-bd07-98377d89f29c_1677299708.3109589.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int start = 0 ; \\n        int end = n ; \\n        while (start <= end)\\n        {\\n            int mid = start + (end - start)/2 ;\\n            int g = guess(mid) ;\\n            if (g == 0)\\n            {\\n                return mid ;\\n            }\\n            else if (g < 0)\\n            {\\n                end = mid - 1 ;\\n            }\\n            else\\n            {\\n                start = mid + 1 ; \\n            }\\n        }\\n        return -1 ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819740,
                "title": "python-easy-binary-search-solution-o-log-n",
                "content": "def guessNumber(self, n: int) -> int:\\n        r=n+1\\n        l=1\\n        while(r>=l):\\n            mid=l+(r-l)//2\\n            if guess(mid)==0:\\n                return mid\\n            elif guess(mid)==-1:\\n                r=mid-1\\n            else:\\n                l=mid+1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "def guessNumber(self, n: int) -> int:\\n        r=n+1\\n        l=1\\n        while(r>=l):\\n            mid=l+(r-l)//2\\n            if guess(mid)==0:\\n                return mid\\n            elif guess(mid)==-1:\\n                r=mid-1\\n            else:\\n                l=mid+1",
                "codeTag": "Python3"
            },
            {
                "id": 2164730,
                "title": "python3-extension-of-binary-search",
                "content": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            gussed = guess(mid)\\n            \\n            if gussed == 0:\\n                return mid\\n            if gussed<0:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n        \\n        return low\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            gussed = guess(mid)\\n            \\n            if gussed == 0:\\n                return mid\\n            if gussed<0:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n        \\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585096,
                "title": "java-binary-search-explained-with-comments-100-fast",
                "content": "\\'\\'\\'\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        \\n        //As we are talking about a range 1 to n and have comparisons in regard with\\n        //greater than target, less than target, or equal to target\\n        \\n        //Using BINARY SEARCH\\n        \\n        int start = 1;\\n        int end = n;\\n        \\n        while(start<=end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(guess(mid) == -1)        //greater then picked number\\n            {\\n                end = mid - 1;\\n            }\\n            else if(guess(mid) == 1)    //lesser than picked number\\n            {\\n                start = mid + 1;\\n            }\\n            else if(guess(mid) == 0)    //equal to the picked number\\n            {\\n                return mid;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        \\n        //As we are talking about a range 1 to n and have comparisons in regard with\\n        //greater than target, less than target, or equal to target\\n        \\n        //Using BINARY SEARCH\\n        \\n        int start = 1;\\n        int end = n;\\n        \\n        while(start<=end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(guess(mid) == -1)        //greater then picked number\\n            {\\n                end = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1579071,
                "title": "python3-cheating-solution",
                "content": "```\\nclass Solution:\\n    def guessNumber(self,n):\\n        return __pick__\\n```\\npick is where the variable is stored (found with inspect.getsource), so simply return pick!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def guessNumber(self,n):\\n        return __pick__\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477950,
                "title": "java-clean-100-faster-easy-to-understand-binary-search-solution",
                "content": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        \\n       int start = 1, end = n;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            \\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)==1){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nPlease do upvote if you find the solution useful.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        \\n       int start = 1, end = n;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            \\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)==1){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84739,
                "title": "c-binary-search",
                "content": "Declare res to equal the API call to only have 1 API call/iteration\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        //simple binary search : low = 1; high = n\\n        int low = 1;\\n        while(low <= n){\\n            int mid = low + (n-low) / 2;\\n            int res = guess(mid);\\n            if(res == 0)\\n                return mid;\\n            else if(res == -1)\\n                n = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int guessNumber(int n) {\\n        //simple binary search : low = 1; high = n\\n        int low = 1;\\n        while(low <= n){\\n            int mid = low + (n-low) / 2;\\n            int res = guess(mid);\\n            if(res == 0)\\n                return mid;\\n            else if(res == -1)\\n                n = mid - 1;\\n            else\\n                low = mid + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3065767,
                "title": "easiest-solution-c-with-0ms-beats-100-of-solutions",
                "content": "# Intuition\\nI had never done a binary search alogirthem before, and I noticed it looked like I could easily do it with one.\\nThat\\'s about it.\\n\\n# Complexity\\n- Time complexity\\nO(Log(N))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        return recursiveFunction(1,n);\\n    }\\n    int recursiveFunction(unsigned int low, unsigned int high){\\n        unsigned int mid {((low+high)/2)};\\n        int help {guess(mid)};\\n        if(help==0) return mid;\\n        if(help==1) return recursiveFunction(mid+1,high);\\n        else return recursiveFunction(low,mid-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        return recursiveFunction(1,n);\\n    }\\n    int recursiveFunction(unsigned int low, unsigned int high){\\n        unsigned int mid {((low+high)/2)};\\n        int help {guess(mid)};\\n        if(help==0) return mid;\\n        if(help==1) return recursiveFunction(mid+1,high);\\n        else return recursiveFunction(low,mid-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819430,
                "title": "simple-java-solution-using-binary-search",
                "content": "```\\n// will use the binary search\\n\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r=n;\\n        while(r>=l){\\n            int mid = l+(r-l)/2;\\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)==-1){\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n// will use the binary search\\n\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r=n;\\n        while(r>=l){\\n            int mid = l+(r-l)/2;\\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)==-1){\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819396,
                "title": "c-binary-search-faster-easy-to-understand",
                "content": "* ***Using Binary Search***\\n\\n* ***Time Complexity :- O(logN)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        \\n        // apply binary search\\n        \\n        int low = 1;\\n        \\n        int high = n;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            int mid_val = guess(mid);\\n            \\n            if(mid_val == 0)\\n            {\\n                return mid;\\n            }\\n            else if(mid_val == -1)\\n            {\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        \\n        // apply binary search\\n        \\n        int low = 1;\\n        \\n        int high = n;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            int mid_val = guess(mid);\\n            \\n            if(mid_val == 0)\\n            {\\n                return mid;\\n            }\\n            else if(mid_val == -1)\\n            {\\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819214,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while low <= high:\\n            mid = (low + high)//2\\n            res =  guess(mid)\\n            if res == 0 :\\n                return mid\\n            elif res == -1:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while low <= high:\\n            mid = (low + high)//2\\n            res =  guess(mid)\\n            if res == 0 :\\n                return mid\\n            elif res == -1:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818922,
                "title": "javascript-solution-49ms-99-71-faster-binary-search",
                "content": "```\\nconst guessNumber = function(n) {\\n    let l = 1;\\n    let r = n;\\n    let pick = Math.floor((r+l)/2);\\n    let g = guess(pick);\\n    while(l <= r) {\\n        if(g > 0) {\\n            l = pick+1;\\n            pick = Math.floor((r+l)/2);\\n            g = guess(pick);\\n        }\\n        else if(g < 0) {\\n            r = pick-1;\\n            pick = Math.floor((r+l)/2);\\n            g = guess(pick);\\n        }\\n        else {\\n            return pick;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nconst guessNumber = function(n) {\\n    let l = 1;\\n    let r = n;\\n    let pick = Math.floor((r+l)/2);\\n    let g = guess(pick);\\n    while(l <= r) {\\n        if(g > 0) {\\n            l = pick+1;\\n            pick = Math.floor((r+l)/2);\\n            g = guess(pick);\\n        }\\n        else if(g < 0) {\\n            r = pick-1;\\n            pick = Math.floor((r+l)/2);\\n            g = guess(pick);\\n        }\\n        else {\\n            return pick;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426200,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-100-faster-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q374. Guess Number Higher or Lower***\\n\\nWe are playing the Guess Game. The game is as follows:\\n\\nI pick a number from `1` to `n`. You have to guess which number I picked.\\n\\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\\n\\nYou call a pre-defined API `int guess(int num)`, which returns three possible results:\\nYou call a pre-defined API int guess(int num), which returns three possible results:\\n\\n```\\n-1: Your guess is higher than the number I picked (i.e. num > pick).\\n1: Your guess is lower than the number I picked (i.e. num < pick).\\n0: your guess is equal to the number I picked (i.e. num == pick).\\n```\\nReturn the number that I picked.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Java Code** :\\n**Runtime**: 0 ms, faster than 100.00% of Java online submissions for Guess Number Higher or Lower.\\n```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int left=1,right=n;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            int guess=guess(mid);\\n            if(guess==0)\\n                return mid;\\n            else if(guess==-1)\\n                right=mid-1;\\n            else \\n                left=mid+1;\\n        }\\n            return -1; \\n    }\\n}\\n```\\n**Runtime:**  0ms\\n**Memory Usage:**  41.2 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        lowerBound, upperBound = 1, n\\n        myGuess= (lowerBound+upperBound)>>1\\n        while (res := guess(myGuess)) != 0:\\n            if res == 1:\\n                lowerBound = myGuess+1\\n            else:\\n                upperBound = myGuess-1\\n            myGuess = (lowerBound+upperBound) >> 1\\n\\n        return myGuess\\n```\\n**Runtime:**  47ms\\n**Memory Usage:**  13.7 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l=1,r=n;\\n        int mid;\\n        while(r>=l)\\n        {\\n            mid=l+(r-l)/2;\\n            if(guess(mid)==-1)\\n                r=mid-1;\\n            if(guess(mid)==1)\\n                l=mid+1;\\n            if(guess(mid)==0)\\n                break;\\n        }\\n        return mid;\\n    }\\n};\\n```\\n**Runtime:**  4s\\n**Memory Usage:**  5.9MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n-1: Your guess is higher than the number I picked (i.e. num > pick).\\n1: Your guess is lower than the number I picked (i.e. num < pick).\\n0: your guess is equal to the number I picked (i.e. num == pick).\\n```\n```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int left=1,right=n;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            int guess=guess(mid);\\n            if(guess==0)\\n                return mid;\\n            else if(guess==-1)\\n                right=mid-1;\\n            else \\n                left=mid+1;\\n        }\\n            return -1; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        lowerBound, upperBound = 1, n\\n        myGuess= (lowerBound+upperBound)>>1\\n        while (res := guess(myGuess)) != 0:\\n            if res == 1:\\n                lowerBound = myGuess+1\\n            else:\\n                upperBound = myGuess-1\\n            myGuess = (lowerBound+upperBound) >> 1\\n\\n        return myGuess\\n```\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l=1,r=n;\\n        int mid;\\n        while(r>=l)\\n        {\\n            mid=l+(r-l)/2;\\n            if(guess(mid)==-1)\\n                r=mid-1;\\n            if(guess(mid)==1)\\n                l=mid+1;\\n            if(guess(mid)==0)\\n                break;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938166,
                "title": "python-8ms-beats-99-39-binary-search-solution",
                "content": "We use an algorithm called [binary search](https://www.programiz.com/dsa/binary-search#:~:text=Binary%20Search%20is%20a%20searching,need%20to%20sort%20them%20first): this way, instead of having linear time, we can decrease the time complexity to O(log n). Why is this? Binary search only searches the part of the list/range that inside of the range that we search for. In guess the number, it will tell you if your guess was high or low. If your guess was too high, you won\\'t guess anything that\\'s higher than your original guess, right? If you use linear for/while loop, the given information is tossed aside and the program continues to search the entire list/range. Binary search each times makes a smaller and smaller range of numbers for the program to search, making it a lot faster.\\n\\nTime complextiy: O(log n)\\nSpace complexity: O(1)\\n\\n```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num):\\n\\nclass Solution(object):\\n    def guessNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left = 0\\n        right = n\\n       \\n        while left <= right:\\n            mid = left+(right-left)//2\\n            if guess(mid) == -1:\\n                right = mid-1\\n            elif guess(mid) == 1:\\n                left = mid + 1\\n            elif guess(mid) == 0:\\n                return mid\\n```\\n\\t   \\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num):\\n\\nclass Solution(object):\\n    def guessNumber(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left = 0\\n        right = n\\n       \\n        while left <= right:\\n            mid = left+(right-left)//2\\n            if guess(mid) == -1:\\n                right = mid-1\\n            elif guess(mid) == 1:\\n                left = mid + 1\\n            elif guess(mid) == 0:\\n                return mid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518554,
                "title": "c-iterative-vs-recursive-bs-solution-explained-100-time-50-space",
                "content": "Handbook example of binary search, here.\\n\\nTo solve this problem, we would just proceed as we would with a phonebook or a dictionary, adjusting our search to the left (`l`) or to the right (`r`) of where we stand currently (the middle, `m`).\\n\\n`r` is already provided as our input and we know from the specs that we will always start from `1`, so we can set our support variables to be:\\n* `l`, initialised to `1` as mentioned above;\\n* `m`, where we will store our middle at each loop;\\n* `g` is where we will store the result of our call to the hidden helper function.\\n\\nWe will then loop as long as `l <= r` and:\\n* compute `m` as the average of `l` and `r` (notice that I use a formula that will prevent overflows);\\n* compute `g` as the result of calling `guess` with the freshly calculated `m`;\\n* then we will have 3 choices:\\n\\t* if `g == -1`, then we are going too high and need to reduce `r` to be `m - 1`;\\n\\t* if `g == 1`, then we are going too low, so we need to raise `l` to be `m + 1`;\\n\\t* if `g == 0`, we are done and can break out of the loop.\\n\\nOnce done, we can just `return` `m` and be done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int guessNumber(int r) {\\n        // support variables\\n        int l = 0, m, g;\\n        while (l <= r) {\\n            // updating loop variables\\n            m = l + ((r - l) >> 1), g = guess(m);\\n            // first case: m < answer\\n            if (g == -1) r = m - 1;\\n            // second case: m < answer\\n            else if (g) l = m + 1;\\n            // third case: m == answer\\n            else break;\\n        }\\n        return m;\\n    }\\n};\\n```\\n\\nSame idea, patched together as a recursive solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int guessNumber(int r, int l = 1) {\\n        // support variables\\n        int m, g;\\n        // updating recursive calls variables\\n        m = l + ((r - l) >> 1), g = guess(m);\\n        return \\n            // first case: m < answer\\n            g == -1 ? guessNumber(m - 1, l) :\\n            // second case: m < answer\\n            g ? guessNumber(r, m + 1) :\\n            // third case: m == answer\\n            m;\\n    }\\n};\\n```\\n\\nOr, even better, turned into a one-liner for the sake of LOLZ:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int guessNumber(int r, int l = 1, int m = 0, int g = 0) {\\n        return (m = l + ((r - l) >> 1), g = guess(m)) == -1 ? guessNumber(m - 1, l) : g ? guessNumber(r, m + 1) : m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int guessNumber(int r) {\\n        // support variables\\n        int l = 0, m, g;\\n        while (l <= r) {\\n            // updating loop variables\\n            m = l + ((r - l) >> 1), g = guess(m);\\n            // first case: m < answer\\n            if (g == -1) r = m - 1;\\n            // second case: m < answer\\n            else if (g) l = m + 1;\\n            // third case: m == answer\\n            else break;\\n        }\\n        return m;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int guessNumber(int r, int l = 1) {\\n        // support variables\\n        int m, g;\\n        // updating recursive calls variables\\n        m = l + ((r - l) >> 1), g = guess(m);\\n        return \\n            // first case: m < answer\\n            g == -1 ? guessNumber(m - 1, l) :\\n            // second case: m < answer\\n            g ? guessNumber(r, m + 1) :\\n            // third case: m == answer\\n            m;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int guessNumber(int r, int l = 1, int m = 0, int g = 0) {\\n        return (m = l + ((r - l) >> 1), g = guess(m)) == -1 ? guessNumber(m - 1, l) : g ? guessNumber(r, m + 1) : m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427746,
                "title": "c-binary-search-easy-solution",
                "content": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int start = 1 , end = n;\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            int ans = guess(mid);\\n            if(ans == 0)\\n                return mid;\\n            else if( ans == 1)\\n                start = mid + 1;\\n            else \\n                end = mid ;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int start = 1 , end = n;\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            int ans = guess(mid);\\n            if(ans == 0)\\n                return mid;\\n            else if( ans == 1)\\n                start = mid + 1;\\n            else \\n                end = mid ;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765436,
                "title": "c-direct-bruteforce-intuitive-approach-faster-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple and very easy approach by applying Binary Search, calculating middle element, guessing the number, comparing it and returning the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. mark the flag called left and right\\n2. left = 1 // first integer\\n3. right = n //end integer\\n4. by using binary approach calculate middle\\n5. pass it to the function guess(int middle ) which will calculate on the basis of following:- -1: Your guess is higher than the number you picked (i.e. num > pick).\\n1: Your guess is lower than the number you picked (i.e. num < pick).\\n0: Your guess is equal to the number you picked (i.e. num == pick). \\n6. then simply compare and use the approach of binary which will return mid at last or -1 if loops end without returning middle.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int left = 1;\\n        int right = n;\\n\\n        // int middle = right + (left - right)/2;\\n        while(left <= right)\\n        {\\n            int middle = left + (right - left)/2;\\n            int guessing = guess(middle);\\n            if(guessing == 0){\\n                return middle;\\n            }\\n            else if(guessing == -1){\\n                right = middle - 1;\\n            }\\n            else{\\n                left = middle + 1;\\n            }\\n            \\n\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int left = 1;\\n        int right = n;\\n\\n        // int middle = right + (left - right)/2;\\n        while(left <= right)\\n        {\\n            int middle = left + (right - left)/2;\\n            int guessing = guess(middle);\\n            if(guessing == 0){\\n                return middle;\\n            }\\n            else if(guessing == -1){\\n                right = middle - 1;\\n            }\\n            else{\\n                left = middle + 1;\\n            }\\n            \\n\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762560,
                "title": "java-solution-beats-100-0ms-tc-o-log-n",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe problem asks us to guess a target number within a range using the guess API, which tells us if our guess is higher, lower, or equal to the target. We want to minimize the number of guesses to find the target.\\n\\n# Approach\\nTo solve the problem efficiently, we\\'ll use a technique called binary search. Here\\'s how it works:\\n\\n1. We start with the entire range of numbers, from 0 to n-1, where n is the maximum possible target number.\\n1. First, we check if the largest number in the range, n, is the target by calling guess(n). If it returns 0, we found the target, so we return n as the answer.\\n1. If the target is not n, we proceed with a binary search.\\n1. In each iteration of the binary search, we calculate the middle number between the current range\\'s start and end. This middle number is obtained by adding the start and end and then dividing by 2.\\n1. We then call guess(mid) to get feedback on whether the target is higher, lower, or equal to the middle number.\\n1. If guess(mid) returns 1, it means the target is higher than our guess. So, we update our search range by moving the start to mid + 1. This is because the target cannot be in the lower half of the range anymore.\\n1. If guess(mid) returns 0, it means we found the target, and we return the middle number as the answer.\\n1. If guess(mid) returns -1, it means the target is lower than our guess. So, we update our search range by moving the end to mid - 1. This is because the target cannot be in the upper half of the range anymore.\\n1. We repeat steps 4-8 until we find the target or the search range becomes invalid (start > end). If we exit the loop without finding the target, we return the last middle number as our best guess.\\n\\n# Complexity\\n\\n- Time complexity:\\nThe binary search algorithm has a time complexity of $$O(log n)$$. It quickly reduces the search space by half at each step. In this problem, the search space decreases by half until we find the target or the search range becomes invalid. As a result, the time it takes to find the target is logarithmic to the maximum possible target number.\\n\\n- Space complexity:\\nThe space complexity of our solution is $$O(1)$$, which means it uses a constant amount of extra space. Regardless of the size of the input, we only need a few variables to keep track of the search range and the middle number. Therefore, the space used remains constant.\\n\\n# Code\\n```java []\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n\\n        int start = 0; // Initialize the start of the search range to 0\\n        int end = n - 1; // Initialize the end of the search range to n-1\\n\\n        int mid = -1; // Variable to store the middle number\\n\\n        if (guess(n) == 0)\\n            return n; // Check if the largest number is the target, return it if true\\n\\n        while (start <= end) {\\n            mid = start + (end - start) / 2; // Calculate the middle number using start and end\\n\\n            if (guess(mid) == 1) {\\n                start = mid + 1; // If the target is higher than the middle number, update the start to search in the higher half\\n            } else if (guess(mid) == 0) {\\n                return mid; // If the middle number is the target, return it as the answer\\n            } else {\\n                end = mid - 1; // If the target is lower than the middle number, update the end to search in the lower half\\n            }\\n        }\\n\\n        return mid; // Return the best guess if the target was not found\\n    }\\n}\\n\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/75e07d52-3f8e-497b-8169-993d5b4840d6_1689275854.8740258.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```java []\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n\\n        int start = 0; // Initialize the start of the search range to 0\\n        int end = n - 1; // Initialize the end of the search range to n-1\\n\\n        int mid = -1; // Variable to store the middle number\\n\\n        if (guess(n) == 0)\\n            return n; // Check if the largest number is the target, return it if true\\n\\n        while (start <= end) {\\n            mid = start + (end - start) / 2; // Calculate the middle number using start and end\\n\\n            if (guess(mid) == 1) {\\n                start = mid + 1; // If the target is higher than the middle number, update the start to search in the higher half\\n            } else if (guess(mid) == 0) {\\n                return mid; // If the middle number is the target, return it as the answer\\n            } else {\\n                end = mid - 1; // If the target is lower than the middle number, update the end to search in the lower half\\n            }\\n        }\\n\\n        return mid; // Return the best guess if the target was not found\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689587,
                "title": "easy-cpp-solution-along-with-explanation-stepwise-binary-search",
                "content": "# Intuition\\nBy looking at numbers in continuous ascending order, I thought for binary search and it worked.\\n\\n# Approach\\n- Apply binary search\\n- make a start variable initiate with 1 and end variable initiate with n\\n- iterate till start<=end\\n  - inside the loop make a mid variable start+(end-start)/2;\\n  - now save the guess(mid) in x\\n  - check if x==-1, means the mid is higher hence end=mid-1\\n  - check if x==1, means the mid is lower hence start=mid+1 \\n  - else return mid;\\n  - outside the loop return -1(if not found) \\n\\n# Complexity\\n- Time complexity:\\n O(log n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n         int start=1;\\n         int end=n;\\n           while(start<=end)\\n            {\\n                int mid=start+(end-start)/2;\\n                int x=guess(mid);\\n                if(x==-1){end=mid-1;}\\n                else if(x==1){start=mid+1;}\\n                else return mid; \\n            }\\n        return -1;\\n    }\\n};\\n```\\n\\n# Please Upvote for better reach.",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n         int start=1;\\n         int end=n;\\n           while(start<=end)\\n            {\\n                int mid=start+(end-start)/2;\\n                int x=guess(mid);\\n                if(x==-1){end=mid-1;}\\n                else if(x==1){start=mid+1;}\\n                else return mid; \\n            }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303132,
                "title": "binary-search-o-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        left,right=0,n+1\\n        while left<=right:\\n            mid=left+(right-left)//2\\n            if guess(mid)==0:\\n                return mid\\n            if guess(mid)==1:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n    //please upvote me it would encourage me alot\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        left,right=0,n+1\\n        while left<=right:\\n            mid=left+(right-left)//2\\n            if guess(mid)==0:\\n                return mid\\n            if guess(mid)==1:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n    //please upvote me it would encourage me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103631,
                "title": "javascript-solution-with-explanation-o-log-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nit has O(log n) time complexity \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nit has O(1) space complexity\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param {number} num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * var guess = function(num) {}\\n */\\n\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar guessNumber = function(n) {\\n    let lo = 0,\\n        hi = n;\\n        //Initializes \"lo\" and \"hi\" to 0 and n respectively\\n    while(lo<=hi){\\n        //Within a while loop that runs as long as \"lo\" <= \"hi\"\\n\\n       let mid = Math.floor(lo + (hi - lo) / 2);\\n       //It defines a variable \"mid\" as floor value of average of \"lo\" and \"hi\"\\n\\n       let result = guess(mid);\\n       //It calls the function \"guess\" with the value of mid\\n        \\n        if(result == 0){\\n            return mid;\\n        }\\n        //If the result of the \"guess\" function is 0, returns mid\\n\\n        else if (result < 0){\\n          hi = mid-1; \\n        }\\n        //If the result of the \"guess\" function is less than 0, sets hi = mid - 1\\n\\n        else{\\n            lo = mid+1; \\n        }\\n        //If the result of the \"guess\" function is greater than 0, sets lo = mid + 1\\n        \\n      }\\n    return -1;\\n    //If the while loop ends and no number is found, returns -1\\n    \\n};\\n```\\n# heading\\nIf it is helpfull, Please Upvote...\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param {number} num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * var guess = function(num) {}\\n */\\n\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar guessNumber = function(n) {\\n    let lo = 0,\\n        hi = n;\\n        //Initializes \"lo\" and \"hi\" to 0 and n respectively\\n    while(lo<=hi){\\n        //Within a while loop that runs as long as \"lo\" <= \"hi\"\\n\\n       let mid = Math.floor(lo + (hi - lo) / 2);\\n       //It defines a variable \"mid\" as floor value of average of \"lo\" and \"hi\"\\n\\n       let result = guess(mid);\\n       //It calls the function \"guess\" with the value of mid\\n        \\n        if(result == 0){\\n            return mid;\\n        }\\n        //If the result of the \"guess\" function is 0, returns mid\\n\\n        else if (result < 0){\\n          hi = mid-1; \\n        }\\n        //If the result of the \"guess\" function is less than 0, sets hi = mid - 1\\n\\n        else{\\n            lo = mid+1; \\n        }\\n        //If the result of the \"guess\" function is greater than 0, sets lo = mid + 1\\n        \\n      }\\n    return -1;\\n    //If the while loop ends and no number is found, returns -1\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930761,
                "title": "simple-brute-force-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int start=0;\\n        int end=n;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int num = guess(mid);\\n            if(num == 0){\\n                return mid;\\n            }else if(num == -1){\\n                end = mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }   \\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int start=0;\\n        int end=n;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int num = guess(mid);\\n            if(num == 0){\\n                return mid;\\n            }else if(num == -1){\\n                end = mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }   \\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930735,
                "title": "best-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int start=0;\\n        int end=n;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int num = guess(mid);\\n            if(num == 0){\\n                return mid;\\n            }else if(num == -1){\\n                end = mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }   \\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int start=0;\\n        int end=n;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            int num = guess(mid);\\n            if(num == 0){\\n                return mid;\\n            }else if(num == -1){\\n                end = mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }   \\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821597,
                "title": "c-100-faster-easy-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int s = 1;\\n        int e = n;\\n        while(s <= e) {\\n            int mid = s + (e-s)/2;\\n            if(guess(mid) == 0) return mid;\\n            if(guess(mid) == -1) e = mid - 1;\\n            else s = mid + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int s = 1;\\n        int e = n;\\n        while(s <= e) {\\n            int mid = s + (e-s)/2;\\n            if(guess(mid) == 0) return mid;\\n            if(guess(mid) == -1) e = mid - 1;\\n            else s = mid + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819986,
                "title": "python-log-n-simple-solution",
                "content": "# Intuition\\n\\nIt is a very basic `binary search` case. The only trick we need to do in order to eliminate redundant search is check whether or not initial borders (i.e. `1` and `n`) are not an answer.\\n\\n# Approach\\n\\n1. Check left border\\n2. Check right border\\n3. Do binary search\\n\\n# Complexity\\n\\n- Time complexity: log(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n    def guessNumber(self, n: int) -> int:\\n\\n        l = 1\\n        res = guess(l)\\n        if res == 0: return l\\n        \\n        r = n\\n        res = guess(r)\\n        if res == 0: return r\\n\\n        for _ in range(int(math.sqrt(n))):\\n            rn = (r+l) // 2\\n            res = guess(rn)\\n            if res == 0:\\n                return rn\\n            elif res < 0:\\n                r = rn\\n            else:\\n                l = rn\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n    def guessNumber(self, n: int) -> int:\\n\\n        l = 1\\n        res = guess(l)\\n        if res == 0: return l\\n        \\n        r = n\\n        res = guess(r)\\n        if res == 0: return r\\n\\n        for _ in range(int(math.sqrt(n))):\\n            rn = (r+l) // 2\\n            res = guess(rn)\\n            if res == 0:\\n                return rn\\n            elif res < 0:\\n                r = rn\\n            else:\\n                l = rn\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2819936,
                "title": "java-easiest-solution-possible",
                "content": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int left = 1, right = n;\\n        while (left < right) {\\n            int mid = (left + right) >>> 1;\\n            if (guess(mid) <= 0) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int left = 1, right = n;\\n        while (left < right) {\\n            int mid = (left + right) >>> 1;\\n            if (guess(mid) <= 0) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819839,
                "title": "simple-and-easy-java-code-100-faster-binary-search",
                "content": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int s= 1;\\n        int e = n;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(guess(mid)==0) return mid;\\n            else if(guess(mid)==1){\\n                s= mid+1;\\n            }else {\\n                e = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int s= 1;\\n        int e = n;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(guess(mid)==0) return mid;\\n            else if(guess(mid)==1){\\n                s= mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2819215,
                "title": "c-100-faster-solution-w-explanation",
                "content": "# Intuition\\nAs per given 3 conditions we can, return 1, -1, or the guessed number.\\n\\n# Approach\\n1. We will have l (lower / left side number) and r (right side / higher number), by default l =1, r = n (as per given constraint: 1 <= pick <= n).\\n2. Loop through while l <= 2.\\n3. Take m = l + (r-1)/2.\\n4. if(guess(m) == 0), return m; if(guess(m) < 0>), return r = m-1; else l = m+1;\\n5. Return 0 at the end.\\n\\n# Complexity\\n- Time complexity:\\n**Beats 100%**\\n\\n**Please upvote** if you like the solution.\\nComments to improve the solution are welcome.\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n, long p = 1) {\\n        int l = 1, r = n;\\n        while(l <= r)\\n        {\\n            int m = l + (r-l)/2;\\n            if(guess(m) == 0)\\n                return m;\\n            if(guess(m) < 0)\\n                r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n, long p = 1) {\\n        int l = 1, r = n;\\n        while(l <= r)\\n        {\\n            int m = l + (r-l)/2;\\n            if(guess(m) == 0)\\n                return m;\\n            if(guess(m) < 0)\\n                r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819150,
                "title": "leetcode-the-hard-way-binary-search-in-rust",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\nJust a standard binary search\\n\\n```rs\\nimpl Solution {\\n    unsafe fn guessNumber(n: i32) -> i32 {\\n        let mut l = 1;\\n        let mut r = n;\\n        while l < r {\\n            let m = l + (r - l) / 2;\\n            let x = guess(m);\\n            if x == 1 {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        l\\n    }\\n}\\n```\\n\\n\\n```rs\\nimpl Solution {\\n    unsafe fn guessNumber(n: i32) -> i32 {\\n        let mut l = 1;\\n        let mut r = n;\\n        loop {\\n            let m = l + (r - l) / 2;\\n            match guess(m) {\\n                -1 => r = m - 1,\\n                1 => l = m + 1,\\n                _ => return m\\n                \\n            };\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```rs\\nimpl Solution {\\n    unsafe fn guessNumber(n: i32) -> i32 {\\n        let mut l = 1;\\n        let mut r = n;\\n        while l < r {\\n            let m = l + (r - l) / 2;\\n            let x = guess(m);\\n            if x == 1 {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        l\\n    }\\n}\\n```\n```rs\\nimpl Solution {\\n    unsafe fn guessNumber(n: i32) -> i32 {\\n        let mut l = 1;\\n        let mut r = n;\\n        loop {\\n            let m = l + (r - l) / 2;\\n            match guess(m) {\\n                -1 => r = m - 1,\\n                1 => l = m + 1,\\n                _ => return m\\n                \\n            };\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2818972,
                "title": "easy-c-solution-binary-search",
                "content": "\\tint guessNumber(int n) \\n\\t{\\n        int start = 1;\\n        int end = n;\\n        \\n        int mid = start+(end-start)/2; \\n        int num;\\n        while(start<=end)\\n        {\\n            num = guess(mid);\\n            if(num == 0)\\n            {\\n                num = mid;\\n                break;\\n            }\\n            else if(num==-1) end = mid - 1;\\n            else if(num==1)  start = mid + 1;\\n                \\n            mid = start+(end-start)/2; \\n        }\\n        return num;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "\\tint guessNumber(int n) \\n\\t{\\n        int start = 1;\\n        int end = n;\\n        \\n        int mid = start+(end-start)/2; \\n        int num;\\n        while(start<=end)\\n        {\\n            num = guess(mid);\\n            if(num == 0)\\n            {\\n                num = mid;\\n                break;\\n            }\\n            else if(num==-1) end = mid - 1;\\n            else if(num==1)  start = mid + 1;\\n                \\n            mid = start+(end-start)/2; \\n        }\\n        return num;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2818879,
                "title": "python-and-golang",
                "content": "```python\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l, r, m = 1, n, 0\\n        while l <= r:\\n            g = guess(m := (l + r) >> 1)\\n            if g == -1: r = m - 1\\n            elif g == 1: l = m + 1\\n            else: break\\n        return m\\n```\\n```go\\nfunc guessNumber(n int) int {\\n    l, r, m := 1, n, 0\\n    for l <= r {\\n        m = (l + r) >> 1\\n        if g := guess(m); g == -1 {\\n            r = m - 1\\n        } else if g == 1 {\\n            l = m + 1\\n        } else {\\n            break\\n        }\\n    }\\n    return m\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Go"
                ],
                "code": "```python\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l, r, m = 1, n, 0\\n        while l <= r:\\n            g = guess(m := (l + r) >> 1)\\n            if g == -1: r = m - 1\\n            elif g == 1: l = m + 1\\n            else: break\\n        return m\\n```\n```go\\nfunc guessNumber(n int) int {\\n    l, r, m := 1, n, 0\\n    for l <= r {\\n        m = (l + r) >> 1\\n        if g := guess(m); g == -1 {\\n            r = m - 1\\n        } else if g == 1 {\\n            l = m + 1\\n        } else {\\n            break\\n        }\\n    }\\n    return m\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818861,
                "title": "daily-leetcoding-challenge-november-day-16",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/guess-number-higher-or-lower/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Binary Search\n\n  \n**Approach 3:** Ternary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/guess-number-higher-or-lower/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2738121,
                "title": "binary-search-c-solution",
                "content": "Solution using binary search in C++\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int left{1}, right{n};\\n\\n        while (left<=right) {\\n            int middle = left+(right-left)/2;\\n            int soln = guess(middle);\\n            if (!soln) return middle;\\n            if (soln<0) {\\n                right = middle-1;\\n            } else {\\n                left = middle+1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n\\n*Upvote solution if it helped you!*",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int left{1}, right{n};\\n\\n        while (left<=right) {\\n            int middle = left+(right-left)/2;\\n            int soln = guess(middle);\\n            if (!soln) return middle;\\n            if (soln<0) {\\n                right = middle-1;\\n            } else {\\n                left = middle+1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628468,
                "title": "c-0ms-binary-search-with-comments",
                "content": "C++ Solution :\\nTime Complexity : O(log n)\\nSpace Complexity : O(1)\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) \\n    {\\n        int lo=1,hi=n;\\n        while(true)\\n        {\\n            int mid=lo+(hi-lo)/2;  // Do NOT use (maxNumber+minNumber)/2 in case of over flow\\n            int res=guess(mid);\\n            if(res==0) \\n                return mid;\\n            else if(res==1)\\n                lo=mid+1;\\n            else\\n                hi=mid-1;\\n        }\\n    }\\n};\\n```\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) \\n    {\\n        int lo=1,hi=n;\\n        while(true)\\n        {\\n            int mid=lo+(hi-lo)/2;  // Do NOT use (maxNumber+minNumber)/2 in case of over flow\\n            int res=guess(mid);\\n            if(res==0) \\n                return mid;\\n            else if(res==1)\\n                lo=mid+1;\\n            else\\n                hi=mid-1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562529,
                "title": "javascript-binary-search",
                "content": "```\\nvar guessNumber = function(n) {\\n    let left=1,right=n\\n    while(left<right){\\n        let mid=left+Math.floor((right-left)/2)\\n        if(guess(mid)<=0) right=mid\\n        else left=mid+1\\n    }\\n    return left\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar guessNumber = function(n) {\\n    let left=1,right=n\\n    while(left<right){\\n        let mid=left+Math.floor((right-left)/2)\\n        if(guess(mid)<=0) right=mid\\n        else left=mid+1\\n    }\\n    return left\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447230,
                "title": "javascript-simple-solution-with-recursion-100",
                "content": "```\\nvar guessNumber = function(n) {\\n    const findNumber = (start, end) => {\\n        const mid = Math.floor((end + start)/2);\\n        \\n        if (guess(mid) === 0) return mid;\\n        if (guess(mid) === -1) return findNumber(start, mid - 1);\\n        if (guess(mid) === 1) return findNumber(mid + 1, end);\\n    }\\n    \\n    return findNumber(0, n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar guessNumber = function(n) {\\n    const findNumber = (start, end) => {\\n        const mid = Math.floor((end + start)/2);\\n        \\n        if (guess(mid) === 0) return mid;\\n        if (guess(mid) === -1) return findNumber(start, mid - 1);\\n        if (guess(mid) === 1) return findNumber(mid + 1, end);\\n    }\\n    \\n    return findNumber(0, n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067280,
                "title": "c-just-a-simple-binary-search-100-faster",
                "content": "\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\t\\tint guessNumber(int n) {\\n\\t\\t\\t\\t\\tlong long  l=1 ;  // use long long for avoiding runtime error\\n\\t\\t\\t\\t\\tlong long  h=n;\\n\\t\\t\\t\\t\\tint mid=1;\\n\\t\\t\\t\\t\\twhile(l<=h)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmid=(l+h)/2;\\n\\t\\t\\t\\t\\t\\tif(guess(mid) == -1)h=mid-1;\\n\\t\\t\\t\\t\\t\\telse if(guess(mid) == 1)l=mid+1;\\n\\t\\t\\t\\t\\t\\telse if(guess(mid) == 0)return mid;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t};",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\t\\tint guessNumber(int n) {\\n\\t\\t\\t\\t\\tlong long  l=1 ;  // use long long for avoiding runtime error\\n\\t\\t\\t\\t\\tlong long  h=n;\\n\\t\\t\\t\\t\\tint mid=1;\\n\\t\\t\\t\\t\\twhile(l<=h)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmid=(l+h)/2;\\n\\t\\t\\t\\t\\t\\tif(guess(mid) == -1)h=mid-1;\\n\\t\\t\\t\\t\\t\\telse if(guess(mid) == 1)l=mid+1;\\n\\t\\t\\t\\t\\t\\telse if(guess(mid) == 0)return mid;\\n\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2031175,
                "title": "hint-wanna-do-it-yourself-any-language",
                "content": "**Hint 1:**\\nint guessNumber(int n) --->*here, n is the upper limit, i.e. from 1 to n*\\nint guess(int num);--------->*another pre-defined function provided to you, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t where num is your guess no. from 1-n.*\\nExample:\\nn=10, ok......so I have to guess from 1 to 10\\nLet User pick no.=8\\n\\nTRY1 : num=6, *and let me guess....is it 6 ???*\\n           NO...*my bad, I\\'ve recieved 1, that means maybe I\\'ve guessed a lower no.*\\n\\t\\t   \\nTRY2 : num=9, *and let me guess....is it 9 ???*\\n           NO...*my bad, I\\'ve recieved -1, that means maybe I\\'ve guessed a bigger no.*\\n\\t\\t   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n**Hint 2:** \\nYou can use guess(int num) within your function guessNumber(int n)\\n\\n**Hint 3:**\\nO(n) or O(log n) ??\\n1)Should I use guess(int num) function hint (-1,0,1) to my benefit\\n2)Or should I go by random guess like a child, 1,2,3,4.........\\n**Lets check out both.................................................................................................................**",
                "solutionTags": [],
                "code": "**Hint 1:**\\nint guessNumber(int n) --->*here, n is the upper limit, i.e. from 1 to n*\\nint guess(int num);--------->*another pre-defined function provided to you, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t where num is your guess no. from 1-n.*\\nExample:\\nn=10, ok......so I have to guess from 1 to 10\\nLet User pick no.=8\\n\\nTRY1 : num=6, *and let me guess....is it 6 ???*\\n           NO...*my bad, I\\'ve recieved 1, that means maybe I\\'ve guessed a lower no.*\\n\\t\\t   \\nTRY2 : num=9, *and let me guess....is it 9 ???*\\n           NO...*my bad, I\\'ve recieved -1, that means maybe I\\'ve guessed a bigger no.*\\n\\t\\t   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n**Hint 2:** \\nYou can use guess(int num) within your function guessNumber(int n)\\n\\n**Hint 3:**\\nO(n) or O(log n) ??\\n1)Should I use guess(int num) function hint (-1,0,1) to my benefit\\n2)Or should I go by random guess like a child, 1,2,3,4.........\\n**Lets check out both.................................................................................................................**",
                "codeTag": "Unknown"
            },
            {
                "id": 1934823,
                "title": "my-java-o-n-code-better-than-100-submissions",
                "content": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int first = 1;\\n        int last = n;\\n        while (first <= last) {\\n            int mid = first + (last - first) / 2;\\n            int guess = guess(mid);\\n            if (guess == 0) {\\n                return mid;\\n            } else if (guess == 1) {\\n                first = mid + 1;\\n            } else {\\n                last = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int first = 1;\\n        int last = n;\\n        while (first <= last) {\\n            int mid = first + (last - first) / 2;\\n            int guess = guess(mid);\\n            if (guess == 0) {\\n                return mid;\\n            } else if (guess == 1) {\\n                first = mid + 1;\\n            } else {\\n                last = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912729,
                "title": "c-100-easy-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n       int left=0;\\n        int right=n;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)==1){\\n                left=mid+1;\\n            }\\n            else if(guess(mid)==-1){\\n                right=mid-1;\\n            }\\n        }\\n        return 0;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n       int left=0;\\n        int right=n;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)==1){\\n                left=mid+1;\\n            }\\n            else if(guess(mid)==-1){\\n                right=mid-1;\\n            }\\n        }\\n        return 0;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750774,
                "title": "c-o-log-n-100-faster-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        long long int beg,last,middle;\\n        beg = 1 , last = n;\\n        long int pos = 1;\\n        while(beg<=last){\\n            middle = beg + (last-beg)/2;\\n            int x = guess(middle);\\n            pos = middle;\\n            if(x == -1){\\n                last = middle-1;\\n            }\\n            else if(x == 1)\\n                beg = middle+1;\\n            else if(x == 0)\\n                break;\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        long long int beg,last,middle;\\n        beg = 1 , last = n;\\n        long int pos = 1;\\n        while(beg<=last){\\n            middle = beg + (last-beg)/2;\\n            int x = guess(middle);\\n            pos = middle;\\n            if(x == -1){\\n                last = middle-1;\\n            }\\n            else if(x == 1)\\n                beg = middle+1;\\n            else if(x == 0)\\n                break;\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518432,
                "title": "2-go-solutions-using-builtin-and-custom-binary-search",
                "content": "Using builtin `sort.Search` function\\n```\\nfunc guessNumber(n int) int {\\n\\treturn sort.Search(n, func(i int) bool {\\n\\t\\treturn guess(i+1) == -1\\n\\t})\\n}\\n```\\n\\nCustom binary search:\\n```\\nfunc guessNumber(n int) int {\\n\\tstart, end := 1, n\\n\\tfor start <= end {\\n\\t\\tmid := (start + end) / 2\\n\\t\\tswitch guess(mid) {\\n\\t\\tcase -1:\\n\\t\\t\\tend = mid - 1\\n\\t\\tcase 1:\\n\\t\\t\\tstart = mid + 1\\n\\t\\tdefault:\\n\\t\\t\\treturn mid\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\nfunc guessNumber(n int) int {\\n\\treturn sort.Search(n, func(i int) bool {\\n\\t\\treturn guess(i+1) == -1\\n\\t})\\n}\\n```\n```\\nfunc guessNumber(n int) int {\\n\\tstart, end := 1, n\\n\\tfor start <= end {\\n\\t\\tmid := (start + end) / 2\\n\\t\\tswitch guess(mid) {\\n\\t\\tcase -1:\\n\\t\\t\\tend = mid - 1\\n\\t\\tcase 1:\\n\\t\\t\\tstart = mid + 1\\n\\t\\tdefault:\\n\\t\\t\\treturn mid\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448931,
                "title": "c-solution-100-faster-use-less-than-90-memory-easy-binary-search-solution",
                "content": "class Solution {\\npublic:\\n    int guessNumber(int n) \\n    {\\n        long long low = 1 , high = n , mid;\\n        while(low <= high)\\n        {\\n            mid = (low+high)/2;\\n            if(guess(mid) == 0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid) == -1)\\n            {******\\n                high = mid -1;\\n            }\\n            else\\n            {\\n                low = mid +1;\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int guessNumber(int n) \\n    {\\n        long long low = 1 , high = n , mid;\\n        while(low <= high)\\n        {\\n            mid = (low+high)/2;\\n            if(guess(mid) == 0)\\n            {\\n                return mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1324464,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int low = 1;\\n        long int high = n;\\n        while(high>=low){\\n            int mid = (low+high)/2;\\n            if(guess(mid)==-1) high = mid-1;\\n            else if(guess(mid)==0) return mid;\\n            else low = mid+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int low = 1;\\n        long int high = n;\\n        while(high>=low){\\n            int mid = (low+high)/2;\\n            if(guess(mid)==-1) high = mid-1;\\n            else if(guess(mid)==0) return mid;\\n            else low = mid+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990593,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        pick_range = [1, n]\\n        while True:\\n            pick = sum(pick_range) // 2\\n            result = guess(pick)\\n            if result > 0:\\n                pick_range[0] = pick + 1\\n            elif result < 0:\\n                pick_range[1] = pick - 1\\n            else:\\n                return pick\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        pick_range = [1, n]\\n        while True:\\n            pick = sum(pick_range) // 2\\n            result = guess(pick)\\n            if result > 0:\\n                pick_range[0] = pick + 1\\n            elif result < 0:\\n                pick_range[1] = pick - 1\\n            else:\\n                return pick\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603953,
                "title": "clean-solution-in-rust",
                "content": "Don\\'t know why guess() function is considered \"unsafe\", would be interesting to know.\\n```rust\\nunsafe fn guessNumber(n: i32) -> i32 {\\n    let (mut left, mut right) = (1, n);\\n    loop {\\n        let mid = left + (right - left) / 2;\\n        match guess(mid) {\\n           -1 => { right = mid - 1; },\\n            1 => { left  = mid + 1; },\\n            _ => { return mid; },\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nunsafe fn guessNumber(n: i32) -> i32 {\\n    let (mut left, mut right) = (1, n);\\n    loop {\\n        let mid = left + (right - left) / 2;\\n        match guess(mid) {\\n           -1 => { right = mid - 1; },\\n            1 => { left  = mid + 1; },\\n            _ => { return mid; },\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205658,
                "title": "swift-o-1-what-are-you-doing-leetcode",
                "content": "```Swift\\nclass Solution {\\n    func guessNumber(_ n: Int, _ pick: Int) -> Int {\\n        return pick\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Swift\\nclass Solution {\\n    func guessNumber(_ n: Int, _ pick: Int) -> Int {\\n        return pick\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84681,
                "title": "my-c-solution-using-result-of-guess",
                "content": "    int guessNumber(int n) {\\n        int cur = (1 + n) >> 1;\\n        int t;\\n        int step = cur;\\n        do{\\n            t = guess(cur);\\n            step = step >> 1 ? step  >> 1 : 1;\\n            cur += t*step;\\n        } while(t != 0);\\n        \\n        return cur;\\n    }",
                "solutionTags": [],
                "code": "    int guessNumber(int n) {\\n        int cur = (1 + n) >> 1;\\n        int t;\\n        int step = cur;\\n        do{\\n            t = guess(cur);\\n            step = step >> 1 ? step  >> 1 : 1;\\n            cur += t*step;\\n        } while(t != 0);\\n        \\n        return cur;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 84730,
                "title": "one-binarysearch-template-to-ac-all-the-related-problem",
                "content": "I used to use the following template to solve the binary search problem, but failed many problems. It is a little bit hard to cover all the corner cases with the below binary search template !\\n\\nHere is the template I used to post, I will keep [left, right)  **left close right open field and keep this property always**\\n\\n```\\n        int start=-1, end=n-1;\\n        while(end-start>1){\\n            int mid=(start+end)/2;\\n            if(nums[mid]>=target) end=mid;\\n            else start=mid;\\n        }\\n```\\nBut I do find this template is not good enough to pass all the problem related to binary search !!! So where is the general template ?\\n\\nWith the help from my classmates, we finish it !\\n\\nIt should be like this, there are 3 key points to remember !!!\\n\\n\\n* **[left, right]** left close right close , so your left = left_most_possible value so with right\\n\\n* **while (left < right)**  the loop should end when left == right\\n\\n*  **mid = left + (right - left) /2**  in this case the middle value is closer to left, so we need to move the left one step while keeping the right = mid in other case. So We can infer the conditions when the left will move one step !!! **This is the most import parts, you should ensure that once the condition is satisfied, the left can move one step.** \\n\\n***In summary, I have use this template to solve all the binary search problem set in leetcode !***\\n\\n```\\n    int guessNumber(int n) {\\n        int left = 1, right = n;\\n        while (right > left) {\\n            int mid = left + (right - left) / 2;\\n            int ans = guess(mid);\\n            if (ans == 1) {\\n                left = mid + 1;\\n            }\\n            else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n\\n ```\\n\\nFor the purpose you can understand it better, I post the solution to 2 other typical problem :aerial_tramway: \\n\\n**Problem Find Minimum in Rotated Sorted Array II**\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (nums[mid] > nums[right]) left = mid + 1;\\n            else if (nums[mid] < nums[right]) right = mid;\\n            else right--;\\n        }\\n        return nums[left];\\n    }\\n};\\n\\n```\\n\\n**Problem 34. Search for a Range**\\nFor this problem, you should deal with the right cases differently as you want your value always closer to right, so you need to ensure your right variable updating !!!\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = searchLeft(nums, target);\\n        int right = searchRight(nums, target);\\n        vector<int> result;\\n        result.push_back(left);\\n        result.push_back(right);\\n        return result;\\n    }\\n    \\n    int searchLeft(vector<int>& nums, int target) {\\n        int start = 0, end = nums.size() - 1;\\n        while (end > start) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < target) start = mid + 1;\\n            else end = mid;\\n        }\\n        if (nums[start] == target)\\n            return start;\\n        else \\n            return -1;\\n    }\\n    \\n    int searchRight(vector<int>& nums, int target) {\\n        int start = 0, end = nums.size() - 1;\\n        while (end > start) {\\n            int mid = start + (end - start) / 2 + 1;\\n            if (nums[mid] > target) end = mid - 1;\\n            else start = mid;\\n        }\\n        if (nums[start] == target)\\n            return start;\\n        else\\n            return -1;\\n    }\\n};\\n```\\n\\nMay the power with you !!!",
                "solutionTags": [],
                "code": "```\\n        int start=-1, end=n-1;\\n        while(end-start>1){\\n            int mid=(start+end)/2;\\n            if(nums[mid]>=target) end=mid;\\n            else start=mid;\\n        }\\n```\n```\\n    int guessNumber(int n) {\\n        int left = 1, right = n;\\n        while (right > left) {\\n            int mid = left + (right - left) / 2;\\n            int ans = guess(mid);\\n            if (ans == 1) {\\n                left = mid + 1;\\n            }\\n            else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n\\n ```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (nums[mid] > nums[right]) left = mid + 1;\\n            else if (nums[mid] < nums[right]) right = mid;\\n            else right--;\\n        }\\n        return nums[left];\\n    }\\n};\\n\\n```\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = searchLeft(nums, target);\\n        int right = searchRight(nums, target);\\n        vector<int> result;\\n        result.push_back(left);\\n        result.push_back(right);\\n        return result;\\n    }\\n    \\n    int searchLeft(vector<int>& nums, int target) {\\n        int start = 0, end = nums.size() - 1;\\n        while (end > start) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < target) start = mid + 1;\\n            else end = mid;\\n        }\\n        if (nums[start] == target)\\n            return start;\\n        else \\n            return -1;\\n    }\\n    \\n    int searchRight(vector<int>& nums, int target) {\\n        int start = 0, end = nums.size() - 1;\\n        while (end > start) {\\n            int mid = start + (end - start) / 2 + 1;\\n            if (nums[mid] > target) end = mid - 1;\\n            else start = mid;\\n        }\\n        if (nums[start] == target)\\n            return start;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007031,
                "title": "guess-number-higher-or-lower",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int low=0;\\n        int high=n;\\n        while (low<=high)\\n        {\\n            int m=low+(high-low)/2;\\n            int x=guess(m);\\n            if (x==0) return m;\\n            else if (x==-1) high=m-1;\\n            else low=m+1; \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int low=0;\\n        int high=n;\\n        while (low<=high)\\n        {\\n            int m=low+(high-low)/2;\\n            int x=guess(m);\\n            if (x==0) return m;\\n            else if (x==-1) high=m-1;\\n            else low=m+1; \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924190,
                "title": "easy-c-solution-binary-search-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int low=0;\\n        int high=n;\\n        while(low<=high)\\n        {\\n            int mid=low + (high - low) / 2;\\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n           if(guess(mid)==-1)\\n            {\\n                high=mid-1;\\n            } \\n            if(guess(mid)==1)\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int low=0;\\n        int high=n;\\n        while(low<=high)\\n        {\\n            int mid=low + (high - low) / 2;\\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n           if(guess(mid)==-1)\\n            {\\n                high=mid-1;\\n            } \\n            if(guess(mid)==1)\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886052,
                "title": "python-easy-solution-100-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l=0\\n        r=n\\n        while l<=r:\\n            m=(l+r)>>1\\n            if guess(m)==0:\\n                return m\\n            elif guess(m)==-1:\\n                r=m-1\\n            else:\\n                l=m+1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l=0\\n        r=n\\n        while l<=r:\\n            m=(l+r)>>1\\n            if guess(m)==0:\\n                return m\\n            elif guess(m)==-1:\\n                r=m-1\\n            else:\\n                l=m+1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872930,
                "title": "easy-java-solution-beats-100-using-binary-search-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe are going till 1 to n so its sorted we can apply binary search\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust use the binary search and replace target part with \\nthe guesss value and one more thing if you think\\n why mid is not (s+e)/2 take the lcm of the formula\\ni have written it is it is just handling large number\\nif you use s+e/2 it will give you tle\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    o(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    o(1)\\n\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n       int start=0;\\n       int end=n;\\n       while(start<=end)\\n       {\\n           int mid=start+(end-start)/2;\\n           int target=guess(mid);\\n           if (target==0)\\n           {\\n                return mid;\\n           }\\n           else  if (target==1)\\n           {\\n               start=mid+1;\\n           }\\n           else{\\n               end=mid-1;\\n           }\\n       }\\n       return -1; \\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n       int start=0;\\n       int end=n;\\n       while(start<=end)\\n       {\\n           int mid=start+(end-start)/2;\\n           int target=guess(mid);\\n           if (target==0)\\n           {\\n                return mid;\\n           }\\n           else  if (target==1)\\n           {\\n               start=mid+1;\\n           }\\n           else{\\n               end=mid-1;\\n           }\\n       }\\n       return -1; \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798089,
                "title": "easiest-approach-for-all-languages-beats-100-runtime-in-java",
                "content": "# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low=0,high=n;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int x= guess(mid);\\n            if(x==0) \\n            {\\n                return mid;\\n            }\\n            else if(x==-1)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low=0,high=n;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int x= guess(mid);\\n            if(x==0) \\n            {\\n                return mid;\\n            }\\n            else if(x==-1)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686427,
                "title": "binary-search-o-logn-simple",
                "content": "# Intuition\\nJust use the given API function *guess*() and using the return values do a regular binary search in the initial range of 1-n\\n\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l = 1, r = n;\\n        int md = 0;\\n\\n        while(l <= r){\\n            md = l + (r-l)/2;\\n            if(guess(md) == 0){\\n                return md;\\n            }\\n            else if(guess(md) > 0){\\n                l = md + 1;\\n            }\\n            else{\\n                r = md - 1;\\n            }\\n        }\\n\\n        return 1;\\n    }\\n};\\n```\\n\\n\\nIF YOU LIKED THIS APPROACH PLEASE PLEASE UPVOTE, IT REALLY MOTIVATES A LOT :)\\n\\n\\n![bird2.gif](https://assets.leetcode.com/users/images/2e427c6d-958a-4d6c-9af5-f10685977961_1687806046.1965888.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l = 1, r = n;\\n        int md = 0;\\n\\n        while(l <= r){\\n            md = l + (r-l)/2;\\n            if(guess(md) == 0){\\n                return md;\\n            }\\n            else if(guess(md) > 0){\\n                l = md + 1;\\n            }\\n            else{\\n                r = md - 1;\\n            }\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645749,
                "title": "easiest-c-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code is implementing the \"Guess Number Higher or Lower\" problem, where the task is to guess a target number between a given range using the guess() API. The API provides feedback on whether the guessed number is higher, lower, or equal to the target number. The code aims to find the target number by performing a binary search within the given range.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code initializes the search range using two variables, k and l. Initially, k is set to n, the upper bound of the range, and l is set to 0, the lower bound of the range. The variable mid is set to n/2 as the initial guess.\\n\\nIf the initial guess mid returns 0 (equal to the target number), it directly returns mid as the result. If the guess returns -1 (higher than the target number), k is updated to mid, indicating that the target number is within the lower half of the range. Otherwise, if the guess returns 1 (lower than the target number), l is updated to mid, indicating that the target number is within the upper half of the range.\\n\\nNext, a loop is executed from l to k to perform a linear search within the narrowed range. For each iteration, the guess() API is called with the current number i. If the guess returns 0, indicating that i is equal to the target number, the loop is broken. Finally, the result is returned as i, which represents the guessed target number.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code has a time complexity of O(n) in the worst case because it performs a linear search within the range from l to k. However, if the guess() API provides accurate feedback, the number of iterations can be reduced significantly, leading to an improved average case time complexity.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code has a space complexity of O(1) as it uses a fixed amount of extra space to store variables and intermediate results.\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n       int i=1, mid=n/2, k, l=0;\\n       if(guess(mid)==0)\\n       return mid;\\n       else if(guess(mid)==-1)\\n       k=mid, l=0;\\n       else\\n       k=n, l=mid;\\n       for(i=l;i<k;i++)\\n       {\\n           if(guess(i)==0)\\n           break;\\n         \\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n       int i=1, mid=n/2, k, l=0;\\n       if(guess(mid)==0)\\n       return mid;\\n       else if(guess(mid)==-1)\\n       k=mid, l=0;\\n       else\\n       k=n, l=mid;\\n       for(i=l;i<k;i++)\\n       {\\n           if(guess(i)==0)\\n           break;\\n         \\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453805,
                "title": "solve-using-bs-according-to-question-100-easy",
                "content": "# Intuition\\nguess(num) will tell whether the number u have sent is match or not\\naccording to that u will binary search in your number\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int s = 0 ; \\n        int e = n ; \\n        while(s <= e){\\n            int mid = s + (e-s)/2;\\n            int g = guess(mid);\\n            if(g == 0){\\n                return mid ;\\n            }\\n            else if ( g  == -1 ){\\n                e = mid - 1 ;  \\n            }\\n            else if (g == 1) {\\n                s = mid + 1; \\n            }\\n        }\\n        return -1 ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int s = 0 ; \\n        int e = n ; \\n        while(s <= e){\\n            int mid = s + (e-s)/2;\\n            int g = guess(mid);\\n            if(g == 0){\\n                return mid ;\\n            }\\n            else if ( g  == -1 ){\\n                e = mid - 1 ;  \\n            }\\n            else if (g == 1) {\\n                s = mid + 1; \\n            }\\n        }\\n        return -1 ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453026,
                "title": "binary-search-approach-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low =1;\\n        int high=n;\\n        int ans=0;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)==-1){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low =1;\\n        int high=n;\\n        int ans=0;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)==-1){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392689,
                "title": "easy-c-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\nlong long int l=1;\\n    int guessNumber(int n) {\\n        while(l<=n)\\n        {\\n            int mid=(l+n)/2;\\n            int k=guess(mid);\\n            if(k==0) return mid;\\n            if(k==-1) n=mid-1;\\n            if(k==1) l=mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\nlong long int l=1;\\n    int guessNumber(int n) {\\n        while(l<=n)\\n        {\\n            int mid=(l+n)/2;\\n            int k=guess(mid);\\n            if(k==0) return mid;\\n            if(k==-1) n=mid-1;\\n            if(k==1) l=mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391036,
                "title": "python3-easy-understanding-binary-search",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if guess(mid) < 1: right = mid\\n            else: left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if guess(mid) < 1: right = mid\\n            else: left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382507,
                "title": "java-binary-search-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSet low to 0; high to n,then calculate mid .\\nNow , if guess(mid)==0,means we found the target ,so return ans.\\nIf guess(mid)==-1,then high = mid-1.(element at mid is greater than pick)\\nIf guess(mid)==1,then low=mid+1;(element at mid is lesser than pick)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApply binary search.\\n\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low =1;\\n        int high =n;\\n        int ans=0;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)==-1){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low =1;\\n        int high =n;\\n        int ans=0;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)==-1){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334726,
                "title": "simple-c-code-using-binary-search-with-good-explanation",
                "content": "# Intuition\\n<!-- Initially it was difficult for me as well to understand the question, but then I realised after reading it around twice, that the guess api would already be returning values such as -1, 0 and 1 based on the guesses. Therefore, the binary search would need to be performed taking the results of guess api as an indicator towards the target, because we don\\'t know the target. -->\\n\\n# Approach\\n<!-- If the guess api is returning value ==1, it means the number is lower than the picked number. So, we would perform the binary search on the right side of the mid element. Similarly it would happen for others as well. -->\\n\\n# Complexity \\n- Time complexity:\\n<!-- Since performing Binary Search===O(log n) -->\\n\\n- Space complexity:\\n<!--  Space complexity of Binary Search===O(1)-->\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        \\n       long long int l = 1;\\n        long long int h = n;\\n\\n        while(l<=h){\\n            long long int mid = (l+h)>>1;\\n\\n            if(guess(mid)==1) l = mid+1;\\n\\n            else if(guess(mid)==-1) h = mid-1;\\n\\n            else return mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        \\n       long long int l = 1;\\n        long long int h = n;\\n\\n        while(l<=h){\\n            long long int mid = (l+h)>>1;\\n\\n            if(guess(mid)==1) l = mid+1;\\n\\n            else if(guess(mid)==-1) h = mid-1;\\n\\n            else return mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326668,
                "title": "binary-search-most-efficient-solution-beats-100",
                "content": "# Intuition\\nsince the value are in the range of 1 to n we can easily apply binary search in this solution \\n\\n# Approach\\nGiven API retuns if the choosen no is greater,smaller or equal to the required no. .We can use Binary Search and search in the range.If the number is greater than the required no then reduce the upper bound of the search to mid-1.If the required is greater than the picked no then increase the lower bound to mid+1.\\n# Complexity\\n- Time complexity:\\nO(log N)\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int s=1,e=n,m,result;\\n        while(s<=e){\\n            m=s+((e-s)/2);\\n            \\n            if(guess(m)==0)\\n                  return m;\\n            else if(guess(m)== -1)\\n                  e=m-1;\\n            else\\n                  s=m+1;\\n        }\\n        return -1;\\n    }\\n}\\nPlease upvote :\\n![plsupvote.jpg](https://assets.leetcode.com/users/images/1f319a1c-2b89-4600-ae03-cfd42aa6f020_1679446380.6596467.jpeg)\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int s=1,e=n,m,result;\\n        while(s<=e){\\n            m=s+((e-s)/2);\\n            \\n            if(guess(m)==0)\\n                  return m;\\n            else if(guess(m)== -1)\\n                  e=m-1;\\n            else\\n                  s=m+1;\\n        }\\n        return -1;\\n    }\\n}\\nPlease upvote :\\n![plsupvote.jpg](https://assets.leetcode.com/users/images/1f319a1c-2b89-4600-ae03-cfd42aa6f020_1679446380.6596467.jpeg)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312816,
                "title": "c-python-o-logn-easy-solution",
                "content": "\\n# Approach: Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# c++\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int s = 1, e = n;\\n        while (s <= e) {\\n            int mid = s + (e-s)/2;\\n            if(guess(mid) == 0) return mid;\\n            else if (guess(mid) == -1) e = mid - 1;\\n            else s = mid + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n# Python/Python3\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        s, e = 0, n\\n        while s <= e:\\n            mid = s + (e-s)//2\\n            if guess(mid) == 0:\\n                return mid\\n            elif guess(mid) == -1:\\n                e = mid - 1\\n            else:\\n                s = mid + 1\\n        return -1\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int s = 1, e = n;\\n        while (s <= e) {\\n            int mid = s + (e-s)/2;\\n            if(guess(mid) == 0) return mid;\\n            else if (guess(mid) == -1) e = mid - 1;\\n            else s = mid + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        s, e = 0, n\\n        while s <= e:\\n            mid = s + (e-s)//2\\n            if guess(mid) == 0:\\n                return mid\\n            elif guess(mid) == -1:\\n                e = mid - 1\\n            else:\\n                s = mid + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256724,
                "title": "cpp-beats-100-o-log-n-binary-search",
                "content": "\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int lo = 1;\\n        int hi = n;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo) / 2;\\n            if(guess(mid) == -1){\\n                hi = mid - 1;\\n            }else if(guess(mid) == 1){\\n                lo = mid + 1;\\n            }else{\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int lo = 1;\\n        int hi = n;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo) / 2;\\n            if(guess(mid) == -1){\\n                hi = mid - 1;\\n            }else if(guess(mid) == 1){\\n                lo = mid + 1;\\n            }else{\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092088,
                "title": "kotlin-binary-search-without-low-and-high",
                "content": "\\n# Code\\n```\\nclass Solution:GuessGame() {\\n     override fun guessNumber(n:Int):Int {\\n        var step = n / 2\\n        var num = step\\n\\n        while (true) {\\n            var result = guess(num)\\n\\n            step = step / 2\\n            if (step == 0) step = 1\\n\\n            if (result == 0)\\n                return num\\n            else if (result == 1)\\n                num = num + step\\n            else\\n               num = num - step\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution:GuessGame() {\\n     override fun guessNumber(n:Int):Int {\\n        var step = n / 2\\n        var num = step\\n\\n        while (true) {\\n            var result = guess(num)\\n\\n            step = step / 2\\n            if (step == 0) step = 1\\n\\n            if (result == 0)\\n                return num\\n            else if (result == 1)\\n                num = num + step\\n            else\\n               num = num - step\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051193,
                "title": "binary-search-solution-on-swift",
                "content": "\\n# Code\\n```\\nfunc guessNumber(_ n: Int) -> Int {\\n    var low = 0\\n    var high = n\\n    while low <= high {\\n        let mid = (low+high) / 2\\n        if guess(mid) == 0 {\\n            return mid\\n        }\\n        if guess(mid) == 1 {\\n            low = mid + 1                \\n        } else if guess(mid) == -1 {\\n            high = mid - 1\\n        }\\n    }\\n    return -1\\n}\\n```\\n### Please upvote if the solution was useful!",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nfunc guessNumber(_ n: Int) -> Int {\\n    var low = 0\\n    var high = n\\n    while low <= high {\\n        let mid = (low+high) / 2\\n        if guess(mid) == 0 {\\n            return mid\\n        }\\n        if guess(mid) == 1 {\\n            low = mid + 1                \\n        } else if guess(mid) == -1 {\\n            high = mid - 1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2880728,
                "title": "java-easy-0-ms-fast-solution",
                "content": "\\n        int l = 1, h = n, m;\\n        \\n        while (l <= h) {\\n            m = l + (h - l) / 2;\\n            if (guess(m) == 0)  return m;\\n            else if (guess(m) == 1) l = m + 1;\\n            else h = m - 1;\\n       }\\n        return - 1;      // Just for warnings for this solution\\n    \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n        int l = 1, h = n, m;\\n        \\n        while (l <= h) {\\n            m = l + (h - l) / 2;\\n            if (guess(m) == 0)  return m;\\n            else if (guess(m) == 1) l = m + 1;\\n            else h = m - 1;\\n       }\\n        return - 1;      // Just for warnings for this solution\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2830207,
                "title": "python-pen-n-paper-explanation-easy-solution",
                "content": "# Let\\'s Dry Run a example:\\n\\n# Where n=4 ,Picked item=1\\n\\n\\n![tempImageA6yNbn.jpg](https://assets.leetcode.com/users/images/5f94c1ed-6de3-41ee-a4b2-b74e6374b921_1668865191.623506.jpeg)\\n\\n![tempImageR5cKvU.jpg](https://assets.leetcode.com/users/images/dc514a1c-c280-499d-94ed-a1e04f8715c6_1668865291.6340785.jpeg)\\n\\n\\n\\n# Code\\n```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        low=1\\n        while low<=n:\\n            mid=(low+n)//2\\n            if guess(mid)==-1:\\n                n=mid-1\\n            elif guess(mid)==1:\\n                low=mid+1\\n            else:\\n                return mid\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        low=1\\n        while low<=n:\\n            mid=(low+n)//2\\n            if guess(mid)==-1:\\n                n=mid-1\\n            elif guess(mid)==1:\\n                low=mid+1\\n            else:\\n                return mid\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822925,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\t/** \\n\\t * Forward declaration of guess API.\\n\\t * @param  num   your guess\\n\\t * @return \\t     -1 if num is higher than the picked number\\n\\t *\\t\\t\\t      1 if num is lower than the picked number\\n\\t *               otherwise return 0\\n\\t * int guess(int num);\\n\\t */\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint guessNumber(int n) {\\n\\t\\t\\tint i=1, j=n; \\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\tif(guess(mid)==0){return mid;}\\n\\t\\t\\t\\telse if(guess(mid)==1){i=mid+1;}\\n\\t\\t\\t\\telse if(guess(mid)==-1){j=mid-1;}\\n\\t\\t\\t}\\n\\t\\t\\treturn i;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint guessNumber(int n) {\\n\\t\\t\\tint i=1, j=n; \\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tint mid=i+(j-i)/2;\\n\\t\\t\\t\\tif(guess(mid)==0){return mid;}",
                "codeTag": "Java"
            },
            {
                "id": 2822141,
                "title": "java-easy-o-log-n-approach",
                "content": "***Please do upvote, if you find it helpful***\\uD83D\\uDE0A\\n\\n```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int lo = 1, hi = n;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(guess(mid) == 0)\\n                return mid;\\n            else if(guess(mid) == 1) \\n                lo = mid+1;\\n            else            // if(guess(mid)==-1)\\n                hi = mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int lo = 1, hi = n;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(guess(mid) == 0)\\n                return mid;\\n            else if(guess(mid) == 1) \\n                lo = mid+1;\\n            else            // if(guess(mid)==-1)\\n                hi = mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821911,
                "title": "0ms-solution-beats-100-time-complexity-beats-99-34-space-complexity-c",
                "content": "# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) \\n    {  \\n        // 1 to n \\n        unsigned int i = 1;\\n        unsigned int j = n;\\n        //binary search\\n        while (i <= j)\\n        {\\n            int mid = (i + j) >> 1;\\n            if (guess (mid) == -1)\\n            {\\n                j = mid - 1;\\n            }\\n            \\n            else if (guess (mid) == 1)\\n            {\\n                i = mid + 1;\\n            }\\n            else \\n            {\\n                return mid;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) \\n    {  \\n        // 1 to n \\n        unsigned int i = 1;\\n        unsigned int j = n;\\n        //binary search\\n        while (i <= j)\\n        {\\n            int mid = (i + j) >> 1;\\n            if (guess (mid) == -1)\\n            {\\n                j = mid - 1;\\n            }\\n            \\n            else if (guess (mid) == 1)\\n            {\\n                i = mid + 1;\\n            }\\n            else \\n            {\\n                return mid;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820874,
                "title": "easy-c-solution-binary-search-o-log-n",
                "content": "\\n\\n**Solution:**\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n\\n        // As the guessed number is between 1 to n\\n        int low = 1;\\n        int high = n;\\n\\n        while(low <= high)\\n        {\\n            \\n            // find the mid\\n\\n            int mid = low + (high - low)/2;\\n\\n            int test = guess(mid);\\n\\n            // Move the low and high pointer based on the condition.\\n            if(test == 0)\\n                return mid;\\n            else if(test == -1)\\n                high = mid-1;\\n            else\\n                low = mid +1;    \\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n---\\n\\nNote : We considered guess() function takes O(1)  ---> time\\n\\n**Analysis:**\\n\\n**Time Complexity**: ```O(log n)```  ---> As we apply the binary search\\n\\n**Space Complexity**: ```O(1)```   \\u2014> constant Space\\n\\n----\\n\\n\\nIf this solution helps you, then please ```upvote```.\\n**Till then keep Learning, keep Growing!!!!**\\n\\n\\n$$Thank YOU !$$",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n\\n        // As the guessed number is between 1 to n\\n        int low = 1;\\n        int high = n;\\n\\n        while(low <= high)\\n        {\\n            \\n            // find the mid\\n\\n            int mid = low + (high - low)/2;\\n\\n            int test = guess(mid);\\n\\n            // Move the low and high pointer based on the condition.\\n            if(test == 0)\\n                return mid;\\n            else if(test == -1)\\n                high = mid-1;\\n            else\\n                low = mid +1;    \\n        }\\n        return -1;\\n    }\\n};\\n```\n```O(log n)```\n```O(1)```\n```upvote```",
                "codeTag": "Java"
            },
            {
                "id": 2820807,
                "title": "c-python-java-videos-of-binary-search-by-experts-easy-to-understand-binary-search",
                "content": "If you don\\'t know binary search checkout a video you can checkout videos of experts like:\\n1. Abdul Bari ~ https://www.youtube.com/watch?v=C2apEw9pgtw \\n2. Kunal Kushwaha ~ https://youtube.com/watch?v=W9QJ8HaRvJQ\\n\\nHere binary-search is used it has time complexity of **O(log n)** and space complexity of **O(1)**.\\nGuess is an inbuilt function(*Given by Leetcode*) so it\\'s time complexity **O(1)**. \\nThat\\'s it Enjoy\\uD83D\\uDE4C\\u270C\\uFE0F\\n\\nCPP\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int low=0,high=n;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            int guessed = guess(mid);\\n            if(guessed == 0) return mid;\\n            if(guessed == -1) high=mid-1;\\n            else low = mid+1;\\n        } \\n        return -1;\\n    }\\n};\\n```\\n\\nJAVA\\n```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low=0, high=n, mid;\\n        while(low<=high){\\n            mid=low+(high-low)/2;\\n            if(guess((int)mid)==0) return (int)mid;\\n            else if(guess((int)mid)==1) low=mid+1;\\n            else high=mid-1; \\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nPython3\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        low = 0\\n        high = n\\n\\t\\t\\n        while low<=high:\\n\\t\\t\\n            mid = low+(high-low)//2\\n            num = guess(mid)\\n\\t\\t\\t\\n            if num == 0:\\n                return mid\\n            elif num == -1:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int low=0,high=n;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            int guessed = guess(mid);\\n            if(guessed == 0) return mid;\\n            if(guessed == -1) high=mid-1;\\n            else low = mid+1;\\n        } \\n        return -1;\\n    }\\n};\\n```\n```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low=0, high=n, mid;\\n        while(low<=high){\\n            mid=low+(high-low)/2;\\n            if(guess((int)mid)==0) return (int)mid;\\n            else if(guess((int)mid)==1) low=mid+1;\\n            else high=mid-1; \\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        low = 0\\n        high = n\\n\\t\\t\\n        while low<=high:\\n\\t\\t\\n            mid = low+(high-low)//2\\n            num = guess(mid)\\n\\t\\t\\t\\n            if num == 0:\\n                return mid\\n            elif num == -1:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820483,
                "title": "java-runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int leftValue = 1;\\n        while (leftValue <= n) {\\n            int midValue = leftValue + (n - leftValue) / 2;\\n            int g = guess(midValue);\\n            if (g == 0) return midValue; \\n            else if (g == 1) \\n                leftValue = midValue + 1;\\n            else \\n                n = midValue - 1;\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int leftValue = 1;\\n        while (leftValue <= n) {\\n            int midValue = leftValue + (n - leftValue) / 2;\\n            int g = guess(midValue);\\n            if (g == 0) return midValue; \\n            else if (g == 1) \\n                leftValue = midValue + 1;\\n            else \\n                n = midValue - 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2820365,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  Binary Search\\n\\n# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l = 1, r = n;\\n        while(l <= r) {\\n            int mid = (r - l) / 2 + l;\\n            int ans = guess(mid);\\n            if(ans == 0) return mid;\\n            else if(ans > 0) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l = 1, r = n;\\n        while(l <= r) {\\n            int mid = (r - l) / 2 + l;\\n            int ans = guess(mid);\\n            if(ans == 0) return mid;\\n            else if(ans > 0) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820202,
                "title": "golang-solution-with-link-on-go-playground",
                "content": "playground https://go.dev/play/p/lSnWB9mV7tj\\n\\nTime Complexity - O(log(n))\\nSpace Complexity - O(1)\\n\\nSolution:\\n```\\nfunc guessNumber(n int) int {\\n\\treturn binarySearch(0, n)\\n}\\n\\nfunc binarySearch(start, finish int) int {\\n\\tif start > finish {\\n\\t\\treturn -1\\n\\t}\\n\\tdot := (finish-start)/2 + start\\n\\n\\tswitch guess(dot) {\\n\\tcase -1:\\n\\t\\treturn binarySearch(start, dot-1)\\n\\tcase 1:\\n\\t\\treturn binarySearch(dot+1, finish)\\n\\tdefault:\\n\\t\\treturn dot\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc guessNumber(n int) int {\\n\\treturn binarySearch(0, n)\\n}\\n\\nfunc binarySearch(start, finish int) int {\\n\\tif start > finish {\\n\\t\\treturn -1\\n\\t}\\n\\tdot := (finish-start)/2 + start\\n\\n\\tswitch guess(dot) {\\n\\tcase -1:\\n\\t\\treturn binarySearch(start, dot-1)\\n\\tcase 1:\\n\\t\\treturn binarySearch(dot+1, finish)\\n\\tdefault:\\n\\t\\treturn dot\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2820174,
                "title": "simple-java-solution-0ms-complexity",
                "content": "\\n```\\n\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n            long s=0;\\n            long e=n;\\n            long mid=(s+e)/2;\\n            while(s<=e){\\n                  mid=(s+e)/2;\\n                  int temp=guess((int)mid);\\n                  if(temp==0)\\n                    return (int)mid;\\n                  else if(temp==1)\\n                     s=mid+1;\\n                  else \\n                     e =mid-1;             \\n            }  \\n            return (int)mid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n            long s=0;\\n            long e=n;\\n            long mid=(s+e)/2;\\n            while(s<=e){\\n                  mid=(s+e)/2;\\n                  int temp=guess((int)mid);\\n                  if(temp==0)\\n                    return (int)mid;\\n                  else if(temp==1)\\n                     s=mid+1;\\n                  else \\n                     e =mid-1;             \\n            }  \\n            return (int)mid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819776,
                "title": "binary-search-javascript-solution",
                "content": "\\n```\\nvar guessNumber = function(n) {\\n    var low = 1;\\n    var high = n;\\n    while (low <= high) {\\n        var mid = Math.ceil(low + (high - low) / 2);\\n        var res = guess(mid)\\n        if (res == 0) return mid;\\n        else if (res < 0) high = mid - 1;\\n        else low = mid + 1;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar guessNumber = function(n) {\\n    var low = 1;\\n    var high = n;\\n    while (low <= high) {\\n        var mid = Math.ceil(low + (high - low) / 2);\\n        var res = guess(mid)\\n        if (res == 0) return mid;\\n        else if (res < 0) high = mid - 1;\\n        else low = mid + 1;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819717,
                "title": "c-1-line-pure-recursion-without-binary-search",
                "content": "\\n# Code \\n\\uD83D\\uDE4FPlease do upvote if solution is helpful\\uD83D\\uDE4F\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n    return (guess(n) == 0) ? n : (guess(n) == -1) ? guessNumber(n-1) : guessNumber(n+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n    return (guess(n) == 0) ? n : (guess(n) == -1) ? guessNumber(n-1) : guessNumber(n+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819629,
                "title": "python-classic-binary-search-problem-with-explaination-99-faster-fastest-solution",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        left, right = 0, n\\n\\t\\t\\n        while left<=right:\\n\\t\\t\\n            mid = (left+right)//2\\n            num = guess(mid)\\n\\t\\t\\t\\n            if num == 0:\\n                return mid\\n            elif num == -1:\\n                right = mid-1\\n            else:\\n                left = mid+1\\n```\\n**For Detail Explaination Refer this Blog:\\nhttps://www.python-techs.com/2022/11/program-to-guess-number-higher-or-lower.html\\n(Please open this link in new tab)**\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        left, right = 0, n\\n\\t\\t\\n        while left<=right:\\n\\t\\t\\n            mid = (left+right)//2\\n            num = guess(mid)\\n\\t\\t\\t\\n            if num == 0:\\n                return mid\\n            elif num == -1:\\n                right = mid-1\\n            else:\\n                left = mid+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819624,
                "title": "99-04-faster-python-binary-search-easiest-approach-o-log-n",
                "content": "You can drop your apporach or suggestions :)\\n\\n![image](https://assets.leetcode.com/users/images/e7b344f0-c6bc-450d-a580-1037d15e1c02_1668578875.88876.png)\\n\\n\\n```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l = 1\\n        r = n\\n        while l<=r:\\n            mid = l + (r-l)//2\\n            result = guess(mid)\\n            if result == 0:\\n                return mid\\n            elif result == -1:\\n                r = mid -1\\n            elif result == 1:\\n                l = mid + 1\\n        return mid\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l = 1\\n        r = n\\n        while l<=r:\\n            mid = l + (r-l)//2\\n            result = guess(mid)\\n            if result == 0:\\n                return mid\\n            elif result == -1:\\n                r = mid -1\\n            elif result == 1:\\n                l = mid + 1\\n        return mid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819548,
                "title": "python-97-15-faster-binary-search-o-log-n-solution",
                "content": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l,h=1,n\\n        m=(l+h)>>1\\n        while l<=h:\\n            x=guess(m)\\n            if x==0:\\n                return m\\n            elif x<0:\\n                h=m-1\\n            else:\\n                l=m+1\\n            m=(l+h)>>1    \\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l,h=1,n\\n        m=(l+h)>>1\\n        while l<=h:\\n            x=guess(m)\\n            if x==0:\\n                return m\\n            elif x<0:\\n                h=m-1\\n            else:\\n                l=m+1\\n            m=(l+h)>>1    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819506,
                "title": "100-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int m=n/2;\\n        int start=0,end=n;\\n        while(start<=end)\\n        {\\n            m=  start+(end-start)/2;\\n            if(guess(m)==0)\\n            {\\n                return m;\\n                break;\\n            }\\n            else if(guess(m)==-1)\\n                end=m-1;\\n            else if(guess(m)==1)\\n                start=m+1;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int m=n/2;\\n        int start=0,end=n;\\n        while(start<=end)\\n        {\\n            m=  start+(end-start)/2;\\n            if(guess(m)==0)\\n            {\\n                return m;\\n                break;\\n            }\\n            else if(guess(m)==-1)\\n                end=m-1;\\n            else if(guess(m)==1)\\n                start=m+1;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818945,
                "title": "python-using-binary-search-faster-than-90",
                "content": "\\n```\\n        left=0\\n        right=n\\n        while left<=right:\\n            mid=(left+right)//2\\n            g=guess(mid)\\n            if g==0:return mid\\n            elif g==1:left=mid+1\\n            elif g==-1:right=mid-1\\n        return -1\\n```\\n\\n![image](https://assets.leetcode.com/users/images/1fca9d4f-5c3f-44f8-bc5d-382161be469e_1668560738.9396384.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n        left=0\\n        right=n\\n        while left<=right:\\n            mid=(left+right)//2\\n            g=guess(mid)\\n            if g==0:return mid\\n            elif g==1:left=mid+1\\n            elif g==-1:right=mid-1\\n        return -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2730640,
                "title": "c-solution-100-time-99-31-space-binary-search",
                "content": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n);\\n};\\n/*****************************************************************************/\\nint Solution::guessNumber(int n) {\\n    int left{1}, right{n}, middle=n/2, ret;\\n    while ((ret=guess(middle)) != 0) { \\n        (ret == -1) ? right = middle-1 : left = middle+1;\\n        middle = left + (right-left)/2;\\n    }\\n    return middle;\\n}\\n/*****************************************************************************/\\n```",
                "solutionTags": [],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n);\\n};\\n/*****************************************************************************/\\nint Solution::guessNumber(int n) {\\n    int left{1}, right{n}, middle=n/2, ret;\\n    while ((ret=guess(middle)) != 0) { \\n        (ret == -1) ? right = middle-1 : left = middle+1;\\n        middle = left + (right-left)/2;\\n    }\\n    return middle;\\n}\\n/*****************************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730042,
                "title": "java-binary-search-100-faster-easy-to-understand",
                "content": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low = 1;\\n        int high = n;\\n        \\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            \\n            int g = guess(mid);\\n            if(g == 1) low = mid + 1;\\n            else if(g == -1) high = mid - 1;\\n            else return mid;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low = 1;\\n        int high = n;\\n        \\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            \\n            int g = guess(mid);\\n            if(g == 1) low = mid + 1;\\n            else if(g == -1) high = mid - 1;\\n            else return mid;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662608,
                "title": "easy-solution-for-beginner-o-log-n-binary-search-c-java-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Simple Binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    First do Binary search if the guess of mid is 0 then mid is the guess number if guess of mid is equal to 1 then the guess number is greater than the mid number so we change the starting pointer to mid+1 and if the guess of mid is equla to -1 then the guess number is less than the mid number in that case we have to set the last pointer(j) as mid-1.\\nNow repeat this step till then last pointer is equal to the first pointer and if this condition is failed and we haven\\'t got our guessed number then in that case we would return -1 (which would indicate that the guess number is not present).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\nSolution in Java\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(long long n) {\\n        long long i=0, j=n;\\n        while(i<=j){\\n            long long mid=(i+j)/2;\\n            if(guess(mid)==0)\\n            return mid;\\n            else if(guess(mid)==1)\\n            i=mid+1;\\n            else \\n            j=mid-1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nSolution in C++\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int i=0;int j=nums.length-1;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else \\n                i=mid+1;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(long long n) {\\n        long long i=0, j=n;\\n        while(i<=j){\\n            long long mid=(i+j)/2;\\n            if(guess(mid)==0)\\n            return mid;\\n            else if(guess(mid)==1)\\n            i=mid+1;\\n            else \\n            j=mid-1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int i=0;int j=nums.length-1;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(nums[mid]==target)\\n            return mid;\\n            else if(nums[mid]>target)\\n                j=mid-1;\\n            else \\n                i=mid+1;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579627,
                "title": "java-100-faster-solution-100-less-memory-usage",
                "content": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n       int start = 1;\\n        int end = n;\\n        while(start<=end){\\n           int mid = start + (end-start)/2;\\n            int picked = guess(mid);\\n            if (picked==-1){\\n                end = mid-1;\\n            }\\n            else if(picked==1){\\n                start = mid+1;\\n            }\\n            else\\n                return mid;\\n        }\\n        return -1; \\n    }\\n}\\n```\\n\\nPlease give an upvote if you find this helpful",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n       int start = 1;\\n        int end = n;\\n        while(start<=end){\\n           int mid = start + (end-start)/2;\\n            int picked = guess(mid);\\n            if (picked==-1){\\n                end = mid-1;\\n            }\\n            else if(picked==1){\\n                start = mid+1;\\n            }\\n            else\\n                return mid;\\n        }\\n        return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379593,
                "title": "python-fast-solution",
                "content": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        beg = 1 \\n        end = n\\n        while beg <= end:\\n            num = (beg+end)//2\\n            pick = guess(num)\\n            if pick == 0:\\n                return num\\n            elif pick == 1:\\n                beg = num+1\\n            else:\\n                end = num\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        beg = 1 \\n        end = n\\n        while beg <= end:\\n            num = (beg+end)//2\\n            pick = guess(num)\\n            if pick == 0:\\n                return num\\n            elif pick == 1:\\n                beg = num+1\\n            else:\\n                end = num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016276,
                "title": "0-ms-simple-implementation-using-binary-search-in-c-with-detailed-explanation",
                "content": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        //store the minimum number first into a variable \"minNumber\"\\n        int minNumber = 1;\\n        //store the maximum number into a variable \"maxNumber\" \\n        int maxNumber = n;\\n        \\n        //now the value picked should be between maxNumber and minNumber\\n        \\n        while(true){\\n            //making our guess and storing into a variable \"midNumber\"\\n            int midNumber = (maxNumber - minNumber) / 2 + minNumber;\\n            \\n            //putting our guess into a variable \"result\" by using the predefined API given above already\\n            int result = guess(midNumber);\\n            \\n            //after that use three possible results returned by predefined API and apply binary search simply \\n            if(result == 0)\\n                return midNumber;\\n            else if(result==1)\\n                minNumber = midNumber+1;\\n            else\\n                maxNumber = midNumber-1;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    int guessNumber(int n) {\\n        //store the minimum number first into a variable \"minNumber\"\\n        int minNumber = 1;\\n        //store the maximum number into a variable \"maxNumber\" \\n        int maxNumber = n;\\n        \\n        //now the value picked should be between maxNumber and minNumber\\n        \\n        while(true){\\n            //making our guess and storing into a variable \"midNumber\"\\n            int midNumber = (maxNumber - minNumber) / 2 + minNumber;\\n            \\n            //putting our guess into a variable \"result\" by using the predefined API given above already\\n            int result = guess(midNumber);\\n            \\n            //after that use three possible results returned by predefined API and apply binary search simply \\n            if(result == 0)\\n                return midNumber;\\n            else if(result==1)\\n                minNumber = midNumber+1;\\n            else\\n                maxNumber = midNumber-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1982833,
                "title": "java-faster-than-100-solutions",
                "content": "Make sure you use mid = low +(hi -low)/2 else it will throw TLE\\n```\\npublic class Solution extends GuessGame {\\n  public int guessNumber(int n) {\\n        int low= 0;\\n        int hi = n;\\n        \\n        while (low < hi) {\\n            int mid = low + (hi-low)/2;\\n            \\n            if (guess(mid) == 1) {\\n                low = mid + 1;\\n            } else if (guess(mid) ==-1) {\\n                hi = mid - 1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        \\n        return hi;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution extends GuessGame {\\n  public int guessNumber(int n) {\\n        int low= 0;\\n        int hi = n;\\n        \\n        while (low < hi) {\\n            int mid = low + (hi-low)/2;\\n            \\n            if (guess(mid) == 1) {\\n                low = mid + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1937950,
                "title": "c-faster-than-100-binary-search-easy-to-understand",
                "content": "**//PLEASE UPVOTE IF IT IS HELPFUL**\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int end=n;\\n        int start=1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)==-1)\\n                end = mid-1;\\n            else\\n                start = mid +1;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int end=n;\\n        int start=1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)==-1)\\n                end = mid-1;\\n            else\\n                start = mid +1;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916772,
                "title": "easy-100-runtime-c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        long long int l = 1, r = n, m = 0;\\n        while(l <= r){\\n            m = (l+r)/2;\\n            if (guess(m) == 0) return m;\\n            else if(guess(m) == 1) l = m+1;\\n            else r = m-1;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n*If you found this helpful, please upvote* :)\\n**Thanks!**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        long long int l = 1, r = n, m = 0;\\n        while(l <= r){\\n            m = (l+r)/2;\\n            if (guess(m) == 0) return m;\\n            else if(guess(m) == 1) l = m+1;\\n            else r = m-1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902494,
                "title": "c-binary-search-simple",
                "content": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n         int low = 1;\\n        int high = n;\\n        while(low<=high)\\n        {\\n            // int mid = (low + high)>>1;\\n            int mid = low + (high - low)/2;\\n            int res = guess(mid);\\n            if(res == 0)\\n                return mid;\\n            else if(res < 0)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int guessNumber(int n) {\\n         int low = 1;\\n        int high = n;\\n        while(low<=high)\\n        {\\n            // int mid = (low + high)>>1;\\n            int mid = low + (high - low)/2;\\n            int res = guess(mid);\\n            if(res == 0)\\n                return mid;\\n            else if(res < 0)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1901719,
                "title": "python-binary-search-faster-than-85",
                "content": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if guess(mid) == 0:\\n                return mid\\n            elif guess(mid) == 1:\\n                low = mid + 1\\n            else:\\n                high = mid - 1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# The guess API is already defined for you.\\n# @param num, your guess\\n# @return -1 if num is higher than the picked number\\n#          1 if num is lower than the picked number\\n#          otherwise return 0\\n# def guess(num: int) -> int:\\n\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if guess(mid) == 0:\\n                return mid\\n            elif guess(mid) == 1:\\n                low = mid + 1\\n            else:\\n                high = mid - 1",
                "codeTag": "Java"
            },
            {
                "id": 1791134,
                "title": "guess-number-higher-or-lower-solution-java",
                "content": "/**\\n * Forward declaration of guess API.\\n * (The problem description is not clear, so I translate it into follows.)\\n *\\n * @param traget num\\n *        guess num\\n *\\n * @return -1 if guess num >  target num\\n *          0 if guess num == target num\\n *          1 if guess num <  target num\\n */\\n\\npublic class Solution extends GuessGame {\\n  public int guessNumber(int n) {\\n    int l = 1;\\n    int r = n;\\n\\n    // find the first guess num that >= target num\\n    while (l < r) {\\n      final int m = l + (r - l) / 2;\\n      if (guess(m) <= 0) // -1, 0\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return l;\\n  }\\n}\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution extends GuessGame {\\n  public int guessNumber(int n) {\\n    int l = 1;\\n    int r = n;\\n\\n    // find the first guess num that >= target num\\n    while (l < r) {\\n      final int m = l + (r - l) / 2;\\n      if (guess(m) <= 0) // -1, 0\\n        r = m;\\n      else\\n        l = m + 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1755462,
                "title": "java-solution-beats-100",
                "content": "public class Solution extends GuessGame {\\n    int result;\\n    public int guessNumber(int n) { \\n      if(guess(n) == 0) return n;  \\n      checkGuess(n, 1, n);  \\n      return this.result;\\n    }\\n    public void checkGuess(int guessed, int low, int high) {\\n        int value = Math.abs((high/2)+(low/2)+((high%2)+(low%2))/2);\\n        int guess = guess(value);\\n        if(guess == 0) {\\n           this.result = value;\\n           return; \\n        }\\n        else if(guess == -1) {\\n            high = value;\\n            checkGuess(value, low, high);\\n        } else if(guess == 1) {\\n            low = value;\\n            checkGuess(value, low, high);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution extends GuessGame {\\n    int result;\\n    public int guessNumber(int n) { \\n      if(guess(n) == 0) return n;  \\n      checkGuess(n, 1, n);  \\n      return this.result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1687735,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     long long search(long f,long l)\\n    {\\n         if(l>=f) \\n          {\\n             long long mid=(l+f)/2;\\n             int ans=guess(mid);\\n             if(ans==0) return mid;\\n        \\n             if(ans==1) return search(mid+1,l);\\n      \\n            return search(f,mid-1);\\n         }\\n         return -1;   \\n            \\n    }\\n    int guessNumber(int n) {\\n        return search(0,n);\\n         \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     long long search(long f,long l)\\n    {\\n         if(l>=f) \\n          {\\n             long long mid=(l+f)/2;\\n             int ans=guess(mid);\\n             if(ans==0) return mid;\\n        \\n             if(ans==1) return search(mid+1,l);\\n      \\n            return search(f,mid-1);\\n         }\\n         return -1;   \\n            \\n    }\\n    int guessNumber(int n) {\\n        return search(0,n);\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687273,
                "title": "easiest-way-to-solve-this-problem-using-c",
                "content": "class Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l = 1 , h = n ; \\n        \\n        while(l <= h)\\n        {\\n            int m = l + (h-l)/2;\\n            int ans = guess(m);\\n            if(ans == 0 )\\n                return m;\\n            else if(ans == 1)\\n                l = m+1;\\n            else \\n                h= m-1;\\n        }\\n        \\n        return l;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l = 1 , h = n ; \\n        \\n        while(l <= h)\\n        {\\n            int m = l + (h-l)/2;\\n            int ans = guess(m);\\n            if(ans == 0 )\\n                return m;\\n            else if(ans == 1)\\n                l = m+1;\\n            else \\n                h= m-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1687111,
                "title": "binary-search-just-understand-api-carefully",
                "content": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int start = 1 ;\\n        int end = n ;                     \\n        while(start<=end){\\n            int mid = start + (end-start)/2 ;  \\n            if(guess(mid)==0)return mid ;\\n            else if(guess(mid)==-1){\\n                end = mid - 1 ;   \\n            }\\n            else start = mid+1 ;   \\n        }\\n        return -1 ;\\n    }\\n    // public int guessNumber(int n) {\\n    //     int start = 1 ;\\n    //     int end = n ;                      //10\\n    //     while(start<=end){\\n    //         int mid = (start+end)/2 ;  //5\\n    //         if(guess(mid)==0)return mid ;\\n    //         else if(guess(mid)==-1){\\n    //             start = mid + 1 ;   //6\\n    //         }\\n    //         else end = mid-1 ;   //7\\n    //     }\\n    //     return -1 ;\\n    // }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int start = 1 ;\\n        int end = n ;                     \\n        while(start<=end){\\n            int mid = start + (end-start)/2 ;  \\n            if(guess(mid)==0)return mid ;\\n            else if(guess(mid)==-1){\\n                end = mid - 1 ;   \\n            }\\n            else start = mid+1 ;   \\n        }\\n        return -1 ;\\n    }\\n    // public int guessNumber(int n) {\\n    //     int start = 1 ;\\n    //     int end = n ;                      //10\\n    //     while(start<=end){\\n    //         int mid = (start+end)/2 ;  //5\\n    //         if(guess(mid)==0)return mid ;\\n    //         else if(guess(mid)==-1){\\n    //             start = mid + 1 ;   //6\\n    //         }\\n    //         else end = mid-1 ;   //7\\n    //     }\\n    //     return -1 ;\\n    // }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653166,
                "title": "3-lines-easy-and-clean-c-solutions",
                "content": "**Recursion:**\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n){\\n        if(guess(n)==-1)n-=2;\\n        else if(guess(n)==1)n++;\\n        else return n;\\n        return guessNumber(n);\\n    }\\n};\\n```\\n**If you like this solutions please upvote for me \\nany doubt---> comment\\nThank you.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n){\\n        if(guess(n)==-1)n-=2;\\n        else if(guess(n)==1)n++;\\n        else return n;\\n        return guessNumber(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518387,
                "title": "c-faster-than-100-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int low = 1, high = n;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            int res = guess(mid);\\n            if(res < 0) {\\n                high = mid - 1;\\n            } else if(res > 0) {\\n                low = mid + 1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int low = 1, high = n;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            int res = guess(mid);\\n            if(res < 0) {\\n                high = mid - 1;\\n            } else if(res > 0) {\\n                low = mid + 1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518096,
                "title": "java-binary-search",
                "content": "\\t/** \\n\\t * Forward declaration of guess API.\\n\\t * @param  num   your guess\\n\\t * @return \\t     -1 if num is lower than the guess number\\n\\t *\\t\\t\\t      1 if num is higher than the guess number\\n\\t *               otherwise return 0\\n\\t * int guess(int num);\\n\\t */\\n\\n\\tpublic class Solution extends GuessGame {\\n\\t\\tpublic int guessNumber(int n) {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = n;\\n\\t\\t\\twhile (left <= right) {\\n\\t\\t\\t\\tint c = right - ((right - left) >> 1); // we would never get overflow\\n\\t\\t\\t\\tint val = guess(c);\\n\\t\\t\\t\\tif (0 == val) return c;\\n\\t\\t\\t\\tif (1 == val) left = c + 1;\\n\\t\\t\\t\\telse right = c - 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution extends GuessGame {\\n\\t\\tpublic int guessNumber(int n) {\\n\\t\\t\\tint left = 0;\\n\\t\\t\\tint right = n;\\n\\t\\t\\twhile (left <= right) {\\n\\t\\t\\t\\tint c = right - ((right - left) >> 1); // we would never get overflow\\n\\t\\t\\t\\tint val = guess(c);\\n\\t\\t\\t\\tif (0 == val) return c;\\n\\t\\t\\t\\tif (1 == val) left = c + 1;\\n\\t\\t\\t\\telse right = c - 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1517617,
                "title": "c-simple-binary-search-faster-than-100",
                "content": "We do a simple binary search.\\nFirst we create two variables:-\\n- high\\n- low\\n\\nThen do a simple binary search, where we calculate the middle element of our range from high to low. And then we pass this middle to the guess API which is pre-implemented in the code. Then there are three possibilities:\\n\\n**1st Possibility:** guess(mid)==0\\nThis is the case when our mid is the choosen number. So, we directly return the mid.\\n\\n**2nd Possibility:** guess(mid)<0\\nThis is the case when our mid is greater than the choosen number. So, we change our high to mid-1.\\n\\n**3rd Possibility:** guess(mid)>0\\nThis is the case when our mid is smaller than the choosen number. So, we change our low to mid+1.\\n\\n```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int high=n, low=1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)<0){\\n                high= mid-1;\\n            }\\n            else{\\n                low= mid+1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int high=n, low=1;\\n        while(low<=high){\\n            int mid= low+(high-low)/2;\\n            if(guess(mid)==0){\\n                return mid;\\n            }\\n            else if(guess(mid)<0){\\n                high= mid-1;\\n            }\\n            else{\\n                low= mid+1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517505,
                "title": "c-binary-search-100-faster",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int guessNumber(int n)\\n    {\\n        int low = 1;\\n        int high = n;\\n        while (low <= high)\\n        {\\n            int mid = (high - low) / 2 + low;\\n            int gus = guess(mid);\\n            if (gus == 0)\\n            {\\n                return mid;\\n            }\\n            else if (gus == 1)\\n            {\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int guessNumber(int n)\\n    {\\n        int low = 1;\\n        int high = n;\\n        while (low <= high)\\n        {\\n            int mid = (high - low) / 2 + low;\\n            int gus = guess(mid);\\n            if (gus == 0)\\n            {\\n                return mid;\\n            }\\n            else if (gus == 1)\\n            {\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517117,
                "title": "easy-java-solution-0ms-binary-search",
                "content": "```\\n// Space Complexity: O(1)\\n// Time Complexity: O(log(n))\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int left = 1, right = n;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int guess = guess(mid);\\n            if(guess == 0) return mid;\\n            else if(guess == -1) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n// Space Complexity: O(1)\\n// Time Complexity: O(log(n))\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int left = 1, right = n;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int guess = guess(mid);\\n            if(guess == 0) return mid;\\n            else if(guess == -1) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481984,
                "title": "unreadable-solution-in-rust",
                "content": "```\\nunsafe fn guessNumber(n: i32) -> i32 {\\n    let (mut v, c) = ([1, 0, n], |[l, _, r]: [_; 3]| (r - l >> 1) + l);\\n    while v[1] == 0 { v[(1 - guess(c(v))) as usize] = c(v) + guess(c(v)); }\\n    v[1]\\n}\\n```\\nim sorry",
                "solutionTags": [],
                "code": "```\\nunsafe fn guessNumber(n: i32) -> i32 {\\n    let (mut v, c) = ([1, 0, n], |[l, _, r]: [_; 3]| (r - l >> 1) + l);\\n    while v[1] == 0 { v[(1 - guess(c(v))) as usize] = c(v) + guess(c(v)); }\\n    v[1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259722,
                "title": "python3-olution-memory-99-87",
                "content": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l, h = 1, n+1\\n        while True:\\n            m = int((l+h)/2)\\n            if guess(m) == 0:\\n                return m\\n            elif guess(m) == -1:\\n                h = m\\n            else:\\n                l = m\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l, h = 1, n+1\\n        while True:\\n            m = int((l+h)/2)\\n            if guess(m) == 0:\\n                return m\\n            elif guess(m) == -1:\\n                h = m\\n            else:\\n                l = m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241261,
                "title": "python3-simple-solution-using-binary-search",
                "content": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l,h = 1,n\\n        mid = (l + h)//2\\n        while True:\\n            if guess(mid) < 0:\\n                h = mid-1\\n                mid = (l + h)//2\\n            elif guess(mid) > 0:\\n                l = mid+1\\n                mid = (l + h)//2\\n            else:\\n                return mid\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l,h = 1,n\\n        mid = (l + h)//2\\n        while True:\\n            if guess(mid) < 0:\\n                h = mid-1\\n                mid = (l + h)//2\\n            elif guess(mid) > 0:\\n                l = mid+1\\n                mid = (l + h)//2\\n            else:\\n                return mid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184931,
                "title": "c-binary-search-easy-approach-100-faster-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l = 1;\\n        int r = n;\\n        while (l < r) {\\n            int num = l + (r-l)/2;\\n            if (guess(num) == 0) return num;\\n            if (guess(num) == 1) {\\n                l = num + 1;\\n            } else {\\n                r = num - 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```\\nTime: O(logn)\\nSpace: O(1)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l = 1;\\n        int r = n;\\n        while (l < r) {\\n            int num = l + (r-l)/2;\\n            if (guess(num) == 0) return num;\\n            if (guess(num) == 1) {\\n                l = num + 1;\\n            } else {\\n                r = num - 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092080,
                "title": "simple-c-solution-using-binary-search-100-fast",
                "content": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l=1;\\n        int r=n;\\n        int mid;\\n        while(r>=l)\\n        {\\n            mid=l+(r-l)/2;\\n            if(guess(mid)==-1)\\n                r=mid-1;\\n            if(guess(mid)==1)\\n                l=mid+1;\\n            if(guess(mid)==0)\\n                break;\\n        }\\n        return mid;\\n    }\\n};\\n```\\nPlease consider upvoting.",
                "solutionTags": [],
                "code": "```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is lower than the guess number\\n *\\t\\t\\t      1 if num is higher than the guess number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\nclass Solution {\\npublic:\\n    int guessNumber(int n) {\\n        int l=1;\\n        int r=n;\\n        int mid;\\n        while(r>=l)\\n        {\\n            mid=l+(r-l)/2;\\n            if(guess(mid)==-1)\\n                r=mid-1;\\n            if(guess(mid)==1)\\n                l=mid+1;\\n            if(guess(mid)==0)\\n                break;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077988,
                "title": "easy-python-o-logn-solution",
                "content": "\\n        l=1\\n        r=n\\n        while l<=r:\\n            mid=(l+r)//2 \\n            if guess(mid)==-1:\\n                r=mid-1\\n            elif  guess(mid)==1:\\n                l=mid+1\\n            else:\\n                return mid",
                "solutionTags": [],
                "code": "\\n        l=1\\n        r=n\\n        while l<=r:\\n            mid=(l+r)//2 \\n            if guess(mid)==-1:\\n                r=mid-1\\n            elif  guess(mid)==1:\\n                l=mid+1\\n            else:\\n                return mid",
                "codeTag": "Unknown"
            },
            {
                "id": 860449,
                "title": "python-binary-search-clean-easy",
                "content": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l, r = 0, n\\n        while l <= r:\\n            m = (l + r)//2\\n            if guess(m) == 0: return m\\n            elif guess(m) == -1:\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def guessNumber(self, n: int) -> int:\\n        l, r = 0, n\\n        while l <= r:\\n            m = (l + r)//2\\n            if guess(m) == 0: return m\\n            elif guess(m) == -1:\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return l\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1686138,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1564585,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1686003,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1685699,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1976455,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1571646,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1686052,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1574842,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1809409,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1639664,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1686138,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1564585,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1686003,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1685699,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1976455,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1571646,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1686052,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1574842,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1809409,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1639664,
                "content": [
                    {
                        "username": "Mridulcse",
                        "content": " i did not understand the question properly,can any one help to understand this question?\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "The question asks you to find the value of a number x. But the only information you have is 1 <= x <= n, and you can choose a parameter y yourself, and call another function guess(y), and get told whether x > y,  x < y or x == y."
                    },
                    {
                        "username": "Nakanu",
                        "content": "-1 : My number is lower\\n 1 : My number is higher\\n 0 : Congrats! You got it!\\n\\nHere \"My\" means the number which is given for you to guess not the number you put into      **guess(int num).**"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believer the phrasing of the problem description could be better. It feels exactly the opposite of what the problem intends actually."
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "In case its confusing, as it was for me intially :-\\n\\nYou are given a function ```guessNumber()``` that you are to complete. Given  a upper bound ```n``` this function should guess the correct number picked between ```1``` and ```n```.\\n\\nTo help you with the guessing you are provided with an API ```guess()```. You pass in the value that you have <i>guessed</i> and this function will return 3 values depending upon whether the guess is right or wrong :\\n```-1``` if the number guessed is higher than the picked number\\n```1``` if the number guessed is lower than the picked number\\notherwise return ```0``` when the number guessed  is equal to picked number.\\n\\nBased upon this you\\'re to formulate  a strategy so that you can zero in on the picked number.\\n\\nHappy leetcoding :)\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nHint :- try binary search maybe?"
                    },
                    {
                        "username": "kanbme",
                        "content": "Thank you. In the way they described it, the question is harder to understand that it is to solve it."
                    },
                    {
                        "username": "skatkar",
                        "content": "Thanks for explaining it nicely."
                    },
                    {
                        "username": "sopheary",
                        "content": "This question is difficult to understand than solving. \\uD83D\\uDE02"
                    },
                    {
                        "username": "martian0x80",
                        "content": "fr\\n"
                    },
                    {
                        "username": "jichmi",
                        "content": "It must be said , there is a trap in the question. A description used is difficult to understand. It said: <h6>'return -1 if my number is lower, 1 if my number is higher, otherwise return 0'</h6>\\nAt frist ,I thought it means if the target num is 10 ,guess(3) would return -1 \\uff0cbut it got wrong result ,then I found it return 1 actually.<br/>So the description is said by the dealer ,we are players.<br/><del>It almost  wasted half of this night.I hope I can help somebody to save a little time</del>"
                    },
                    {
                        "username": "zouzax",
                        "content": "thank you for this - I had made the same mistake."
                    },
                    {
                        "username": "gnaaruag",
                        "content": "[@vdas53073](/vdas53073) it happens mate, when you skim read the question you miss some intricacies"
                    },
                    {
                        "username": "vdas53073",
                        "content": "It is already written clearly in bracket if (num < pick) then 1 and pick here means the number he choosed which is mentioned in the que itself."
                    },
                    {
                        "username": "Be__Happy",
                        "content": "I was calling `guessNumber` intead of `guess` function so please do not repeate same mistake again "
                    },
                    {
                        "username": "hengzhou",
                        "content": "Any body feel the guess() function logic is reversed?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Yes. Took me a while to understand that \"my\" means Leetcode\\'s guess \\uD83D\\uDE05"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "i tried to understand the question again and again but feels like something is missing , plss help me to understand the question\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "u have to search target number by using Given Function which return ur guess is exact higher or lower than ans\\n"
                    },
                    {
                        "username": "akashthemosh",
                        "content": "I realized I was using unnecessary space O(n) by creating a list for the number when all I had to do was return the mid which is calculated from the binary search, since the index on the list is same as mid."
                    },
                    {
                        "username": "coreyshort",
                        "content": "Thanks. Believe I am doing something similar to get memory exceeded when submitting code"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1686406,
                "content": [
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=mrarZFTe4BE\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "L1999N",
                        "content": "why isn\\'t this working for n = 2147483647\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r = n + 1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2 ;\\n            int result = guess(mid);\\n            if (result == 0){\\n                return mid;\\n            }\\n            else if (result == -1){\\n                r = mid;\\n            }\\n            else if (result == 1){\\n                l = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "muskan23",
                        "content": "2 mistakes\\nwhile(l<h) //while(l<=h)\\n.\\n.\\nh=mid //h=mid-1"
                    },
                    {
                        "username": "stridemann",
                        "content": "I\\'m getting time limit exceeded on 2126753390 using binary search, wtf.\\n\\npublic int GuessNumber(int n)\\n{\\n    var left = 1;\\n    var right = n;\\n    while (left <= right)\\n    {\\n        var middle = (left + right) / 2;\\n        var num = guess(middle);\\n        if (num > 0)\\n            left = middle + 1;\\n        else if (num < 0)\\n            right = middle - 1;\\n        else\\n            return middle;\\n    }\\n    return left;\\n}"
                    },
                    {
                        "username": "ShrivastavVinit",
                        "content": "\\n first mistake\\nelse if (result == -1){\\nr = mid;        // r==mid-1;  \\n\\nsecond mistake\\nreturn -1;   //return l;\\n\\nhope this works"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "what the hell is this question...\\n"
                    },
                    {
                        "username": "NatureSage",
                        "content": "Exactly"
                    },
                    {
                        "username": "zhangyan985211",
                        "content": "use `mid = (h + l ) >>> 1` `mid = (l+h)/2`"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem in binary search approach?\\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \\nys .\\n\\nTo be more clear \\'>>>\\' (called unsigned right shift operator in java) in java is used to right shifting for +ve integers & \\'>>\\'(called signed right shift operator in java) used to right shifting -ve integers to preserve sign.\\n\\n\\'>>\\' in c++ is used for right shifting for +ve integers. \\ni think it cannot be used with -ve number (limited knowlege in c++) \\n\\n"
                    },
                    {
                        "username": "sandeeprawat4",
                        "content": "[@spell_bound](/spell_bound) That\\'s right"
                    },
                    {
                        "username": "spell_bound",
                        "content": "[@jithinbp](/jithinbp)  I think this('>>>') called right shift operator .\nin C++ we can use it like '>>'  \nam i right?\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \nWays to reduce overflow when using  mid = (start + end) / 2\noverflow occurs if start and end are of higher values that can be stored as integer.\n1:\n \">>>\" is shifting operator (performs in bit) it essentially divides the left part of the operator with power of 2, the power is determined by the right part of the operator.\n\neg;\n5 >>> 1 means  5 / (2^1)  ie, 5/2\n6 >>> 3  means 6 /(2 ^ 3) ie, 6/8\n\nThis operation is performed bitwise.\n2:\n\nmid = start + (end - start) / 2;\n\n(end - start) reduces the size of the value and we divide it by 2\nso we are adding a smaller value to start.\ninstead a big size end directly added with a big size start.\n\nin this way we can avoid overflow.\n\nHope this helps "
                    },
                    {
                        "username": "spell_bound",
                        "content": "can you explain it"
                    },
                    {
                        "username": "rahuldoc98",
                        "content": "My approach is correct in that I am searching half the space by rejecting the other half, but doing it recursively. Not sure why the compiler is giving a time limit exceeded error."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Here every time we call a api guess and inside guess we pass mid value every time."
                    },
                    {
                        "username": "i_am_guts",
                        "content": "yes, thanks for the idea, it actually worked"
                    },
                    {
                        "username": "_aavash_",
                        "content": "Misleading problem statement. Needs to be fixed asap!"
                    },
                    {
                        "username": "kaushalkishoresharma07",
                        "content": "THE general mistake of this question is to use mid formula correctly .\\nmid =left+(right-left)/2;\\nThank you . and have a wonderfull coding journey."
                    },
                    {
                        "username": "mylo_ms",
                        "content": "it seems so. Could you explain to me why (l+r)/ 2 returns TLE though the vales are equal? Thanks!!"
                    },
                    {
                        "username": "Aldino1997",
                        "content": "The problem is poor explained. "
                    },
                    {
                        "username": "rajender7",
                        "content": "This question should be marked HARD considering the phrasing of the problem description."
                    }
                ]
            },
            {
                "id": 1865105,
                "content": [
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=mrarZFTe4BE\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "L1999N",
                        "content": "why isn\\'t this working for n = 2147483647\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r = n + 1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2 ;\\n            int result = guess(mid);\\n            if (result == 0){\\n                return mid;\\n            }\\n            else if (result == -1){\\n                r = mid;\\n            }\\n            else if (result == 1){\\n                l = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "muskan23",
                        "content": "2 mistakes\\nwhile(l<h) //while(l<=h)\\n.\\n.\\nh=mid //h=mid-1"
                    },
                    {
                        "username": "stridemann",
                        "content": "I\\'m getting time limit exceeded on 2126753390 using binary search, wtf.\\n\\npublic int GuessNumber(int n)\\n{\\n    var left = 1;\\n    var right = n;\\n    while (left <= right)\\n    {\\n        var middle = (left + right) / 2;\\n        var num = guess(middle);\\n        if (num > 0)\\n            left = middle + 1;\\n        else if (num < 0)\\n            right = middle - 1;\\n        else\\n            return middle;\\n    }\\n    return left;\\n}"
                    },
                    {
                        "username": "ShrivastavVinit",
                        "content": "\\n first mistake\\nelse if (result == -1){\\nr = mid;        // r==mid-1;  \\n\\nsecond mistake\\nreturn -1;   //return l;\\n\\nhope this works"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "what the hell is this question...\\n"
                    },
                    {
                        "username": "NatureSage",
                        "content": "Exactly"
                    },
                    {
                        "username": "zhangyan985211",
                        "content": "use `mid = (h + l ) >>> 1` `mid = (l+h)/2`"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem in binary search approach?\\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \\nys .\\n\\nTo be more clear \\'>>>\\' (called unsigned right shift operator in java) in java is used to right shifting for +ve integers & \\'>>\\'(called signed right shift operator in java) used to right shifting -ve integers to preserve sign.\\n\\n\\'>>\\' in c++ is used for right shifting for +ve integers. \\ni think it cannot be used with -ve number (limited knowlege in c++) \\n\\n"
                    },
                    {
                        "username": "sandeeprawat4",
                        "content": "[@spell_bound](/spell_bound) That\\'s right"
                    },
                    {
                        "username": "spell_bound",
                        "content": "[@jithinbp](/jithinbp)  I think this('>>>') called right shift operator .\nin C++ we can use it like '>>'  \nam i right?\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \nWays to reduce overflow when using  mid = (start + end) / 2\noverflow occurs if start and end are of higher values that can be stored as integer.\n1:\n \">>>\" is shifting operator (performs in bit) it essentially divides the left part of the operator with power of 2, the power is determined by the right part of the operator.\n\neg;\n5 >>> 1 means  5 / (2^1)  ie, 5/2\n6 >>> 3  means 6 /(2 ^ 3) ie, 6/8\n\nThis operation is performed bitwise.\n2:\n\nmid = start + (end - start) / 2;\n\n(end - start) reduces the size of the value and we divide it by 2\nso we are adding a smaller value to start.\ninstead a big size end directly added with a big size start.\n\nin this way we can avoid overflow.\n\nHope this helps "
                    },
                    {
                        "username": "spell_bound",
                        "content": "can you explain it"
                    },
                    {
                        "username": "rahuldoc98",
                        "content": "My approach is correct in that I am searching half the space by rejecting the other half, but doing it recursively. Not sure why the compiler is giving a time limit exceeded error."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Here every time we call a api guess and inside guess we pass mid value every time."
                    },
                    {
                        "username": "i_am_guts",
                        "content": "yes, thanks for the idea, it actually worked"
                    },
                    {
                        "username": "_aavash_",
                        "content": "Misleading problem statement. Needs to be fixed asap!"
                    },
                    {
                        "username": "kaushalkishoresharma07",
                        "content": "THE general mistake of this question is to use mid formula correctly .\\nmid =left+(right-left)/2;\\nThank you . and have a wonderfull coding journey."
                    },
                    {
                        "username": "mylo_ms",
                        "content": "it seems so. Could you explain to me why (l+r)/ 2 returns TLE though the vales are equal? Thanks!!"
                    },
                    {
                        "username": "Aldino1997",
                        "content": "The problem is poor explained. "
                    },
                    {
                        "username": "rajender7",
                        "content": "This question should be marked HARD considering the phrasing of the problem description."
                    }
                ]
            },
            {
                "id": 1849838,
                "content": [
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=mrarZFTe4BE\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "L1999N",
                        "content": "why isn\\'t this working for n = 2147483647\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r = n + 1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2 ;\\n            int result = guess(mid);\\n            if (result == 0){\\n                return mid;\\n            }\\n            else if (result == -1){\\n                r = mid;\\n            }\\n            else if (result == 1){\\n                l = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "muskan23",
                        "content": "2 mistakes\\nwhile(l<h) //while(l<=h)\\n.\\n.\\nh=mid //h=mid-1"
                    },
                    {
                        "username": "stridemann",
                        "content": "I\\'m getting time limit exceeded on 2126753390 using binary search, wtf.\\n\\npublic int GuessNumber(int n)\\n{\\n    var left = 1;\\n    var right = n;\\n    while (left <= right)\\n    {\\n        var middle = (left + right) / 2;\\n        var num = guess(middle);\\n        if (num > 0)\\n            left = middle + 1;\\n        else if (num < 0)\\n            right = middle - 1;\\n        else\\n            return middle;\\n    }\\n    return left;\\n}"
                    },
                    {
                        "username": "ShrivastavVinit",
                        "content": "\\n first mistake\\nelse if (result == -1){\\nr = mid;        // r==mid-1;  \\n\\nsecond mistake\\nreturn -1;   //return l;\\n\\nhope this works"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "what the hell is this question...\\n"
                    },
                    {
                        "username": "NatureSage",
                        "content": "Exactly"
                    },
                    {
                        "username": "zhangyan985211",
                        "content": "use `mid = (h + l ) >>> 1` `mid = (l+h)/2`"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem in binary search approach?\\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \\nys .\\n\\nTo be more clear \\'>>>\\' (called unsigned right shift operator in java) in java is used to right shifting for +ve integers & \\'>>\\'(called signed right shift operator in java) used to right shifting -ve integers to preserve sign.\\n\\n\\'>>\\' in c++ is used for right shifting for +ve integers. \\ni think it cannot be used with -ve number (limited knowlege in c++) \\n\\n"
                    },
                    {
                        "username": "sandeeprawat4",
                        "content": "[@spell_bound](/spell_bound) That\\'s right"
                    },
                    {
                        "username": "spell_bound",
                        "content": "[@jithinbp](/jithinbp)  I think this('>>>') called right shift operator .\nin C++ we can use it like '>>'  \nam i right?\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \nWays to reduce overflow when using  mid = (start + end) / 2\noverflow occurs if start and end are of higher values that can be stored as integer.\n1:\n \">>>\" is shifting operator (performs in bit) it essentially divides the left part of the operator with power of 2, the power is determined by the right part of the operator.\n\neg;\n5 >>> 1 means  5 / (2^1)  ie, 5/2\n6 >>> 3  means 6 /(2 ^ 3) ie, 6/8\n\nThis operation is performed bitwise.\n2:\n\nmid = start + (end - start) / 2;\n\n(end - start) reduces the size of the value and we divide it by 2\nso we are adding a smaller value to start.\ninstead a big size end directly added with a big size start.\n\nin this way we can avoid overflow.\n\nHope this helps "
                    },
                    {
                        "username": "spell_bound",
                        "content": "can you explain it"
                    },
                    {
                        "username": "rahuldoc98",
                        "content": "My approach is correct in that I am searching half the space by rejecting the other half, but doing it recursively. Not sure why the compiler is giving a time limit exceeded error."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Here every time we call a api guess and inside guess we pass mid value every time."
                    },
                    {
                        "username": "i_am_guts",
                        "content": "yes, thanks for the idea, it actually worked"
                    },
                    {
                        "username": "_aavash_",
                        "content": "Misleading problem statement. Needs to be fixed asap!"
                    },
                    {
                        "username": "kaushalkishoresharma07",
                        "content": "THE general mistake of this question is to use mid formula correctly .\\nmid =left+(right-left)/2;\\nThank you . and have a wonderfull coding journey."
                    },
                    {
                        "username": "mylo_ms",
                        "content": "it seems so. Could you explain to me why (l+r)/ 2 returns TLE though the vales are equal? Thanks!!"
                    },
                    {
                        "username": "Aldino1997",
                        "content": "The problem is poor explained. "
                    },
                    {
                        "username": "rajender7",
                        "content": "This question should be marked HARD considering the phrasing of the problem description."
                    }
                ]
            },
            {
                "id": 1571909,
                "content": [
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=mrarZFTe4BE\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "L1999N",
                        "content": "why isn\\'t this working for n = 2147483647\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r = n + 1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2 ;\\n            int result = guess(mid);\\n            if (result == 0){\\n                return mid;\\n            }\\n            else if (result == -1){\\n                r = mid;\\n            }\\n            else if (result == 1){\\n                l = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "muskan23",
                        "content": "2 mistakes\\nwhile(l<h) //while(l<=h)\\n.\\n.\\nh=mid //h=mid-1"
                    },
                    {
                        "username": "stridemann",
                        "content": "I\\'m getting time limit exceeded on 2126753390 using binary search, wtf.\\n\\npublic int GuessNumber(int n)\\n{\\n    var left = 1;\\n    var right = n;\\n    while (left <= right)\\n    {\\n        var middle = (left + right) / 2;\\n        var num = guess(middle);\\n        if (num > 0)\\n            left = middle + 1;\\n        else if (num < 0)\\n            right = middle - 1;\\n        else\\n            return middle;\\n    }\\n    return left;\\n}"
                    },
                    {
                        "username": "ShrivastavVinit",
                        "content": "\\n first mistake\\nelse if (result == -1){\\nr = mid;        // r==mid-1;  \\n\\nsecond mistake\\nreturn -1;   //return l;\\n\\nhope this works"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "what the hell is this question...\\n"
                    },
                    {
                        "username": "NatureSage",
                        "content": "Exactly"
                    },
                    {
                        "username": "zhangyan985211",
                        "content": "use `mid = (h + l ) >>> 1` `mid = (l+h)/2`"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem in binary search approach?\\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \\nys .\\n\\nTo be more clear \\'>>>\\' (called unsigned right shift operator in java) in java is used to right shifting for +ve integers & \\'>>\\'(called signed right shift operator in java) used to right shifting -ve integers to preserve sign.\\n\\n\\'>>\\' in c++ is used for right shifting for +ve integers. \\ni think it cannot be used with -ve number (limited knowlege in c++) \\n\\n"
                    },
                    {
                        "username": "sandeeprawat4",
                        "content": "[@spell_bound](/spell_bound) That\\'s right"
                    },
                    {
                        "username": "spell_bound",
                        "content": "[@jithinbp](/jithinbp)  I think this('>>>') called right shift operator .\nin C++ we can use it like '>>'  \nam i right?\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \nWays to reduce overflow when using  mid = (start + end) / 2\noverflow occurs if start and end are of higher values that can be stored as integer.\n1:\n \">>>\" is shifting operator (performs in bit) it essentially divides the left part of the operator with power of 2, the power is determined by the right part of the operator.\n\neg;\n5 >>> 1 means  5 / (2^1)  ie, 5/2\n6 >>> 3  means 6 /(2 ^ 3) ie, 6/8\n\nThis operation is performed bitwise.\n2:\n\nmid = start + (end - start) / 2;\n\n(end - start) reduces the size of the value and we divide it by 2\nso we are adding a smaller value to start.\ninstead a big size end directly added with a big size start.\n\nin this way we can avoid overflow.\n\nHope this helps "
                    },
                    {
                        "username": "spell_bound",
                        "content": "can you explain it"
                    },
                    {
                        "username": "rahuldoc98",
                        "content": "My approach is correct in that I am searching half the space by rejecting the other half, but doing it recursively. Not sure why the compiler is giving a time limit exceeded error."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Here every time we call a api guess and inside guess we pass mid value every time."
                    },
                    {
                        "username": "i_am_guts",
                        "content": "yes, thanks for the idea, it actually worked"
                    },
                    {
                        "username": "_aavash_",
                        "content": "Misleading problem statement. Needs to be fixed asap!"
                    },
                    {
                        "username": "kaushalkishoresharma07",
                        "content": "THE general mistake of this question is to use mid formula correctly .\\nmid =left+(right-left)/2;\\nThank you . and have a wonderfull coding journey."
                    },
                    {
                        "username": "mylo_ms",
                        "content": "it seems so. Could you explain to me why (l+r)/ 2 returns TLE though the vales are equal? Thanks!!"
                    },
                    {
                        "username": "Aldino1997",
                        "content": "The problem is poor explained. "
                    },
                    {
                        "username": "rajender7",
                        "content": "This question should be marked HARD considering the phrasing of the problem description."
                    }
                ]
            },
            {
                "id": 2048825,
                "content": [
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=mrarZFTe4BE\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "L1999N",
                        "content": "why isn\\'t this working for n = 2147483647\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r = n + 1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2 ;\\n            int result = guess(mid);\\n            if (result == 0){\\n                return mid;\\n            }\\n            else if (result == -1){\\n                r = mid;\\n            }\\n            else if (result == 1){\\n                l = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "muskan23",
                        "content": "2 mistakes\\nwhile(l<h) //while(l<=h)\\n.\\n.\\nh=mid //h=mid-1"
                    },
                    {
                        "username": "stridemann",
                        "content": "I\\'m getting time limit exceeded on 2126753390 using binary search, wtf.\\n\\npublic int GuessNumber(int n)\\n{\\n    var left = 1;\\n    var right = n;\\n    while (left <= right)\\n    {\\n        var middle = (left + right) / 2;\\n        var num = guess(middle);\\n        if (num > 0)\\n            left = middle + 1;\\n        else if (num < 0)\\n            right = middle - 1;\\n        else\\n            return middle;\\n    }\\n    return left;\\n}"
                    },
                    {
                        "username": "ShrivastavVinit",
                        "content": "\\n first mistake\\nelse if (result == -1){\\nr = mid;        // r==mid-1;  \\n\\nsecond mistake\\nreturn -1;   //return l;\\n\\nhope this works"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "what the hell is this question...\\n"
                    },
                    {
                        "username": "NatureSage",
                        "content": "Exactly"
                    },
                    {
                        "username": "zhangyan985211",
                        "content": "use `mid = (h + l ) >>> 1` `mid = (l+h)/2`"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem in binary search approach?\\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \\nys .\\n\\nTo be more clear \\'>>>\\' (called unsigned right shift operator in java) in java is used to right shifting for +ve integers & \\'>>\\'(called signed right shift operator in java) used to right shifting -ve integers to preserve sign.\\n\\n\\'>>\\' in c++ is used for right shifting for +ve integers. \\ni think it cannot be used with -ve number (limited knowlege in c++) \\n\\n"
                    },
                    {
                        "username": "sandeeprawat4",
                        "content": "[@spell_bound](/spell_bound) That\\'s right"
                    },
                    {
                        "username": "spell_bound",
                        "content": "[@jithinbp](/jithinbp)  I think this('>>>') called right shift operator .\nin C++ we can use it like '>>'  \nam i right?\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \nWays to reduce overflow when using  mid = (start + end) / 2\noverflow occurs if start and end are of higher values that can be stored as integer.\n1:\n \">>>\" is shifting operator (performs in bit) it essentially divides the left part of the operator with power of 2, the power is determined by the right part of the operator.\n\neg;\n5 >>> 1 means  5 / (2^1)  ie, 5/2\n6 >>> 3  means 6 /(2 ^ 3) ie, 6/8\n\nThis operation is performed bitwise.\n2:\n\nmid = start + (end - start) / 2;\n\n(end - start) reduces the size of the value and we divide it by 2\nso we are adding a smaller value to start.\ninstead a big size end directly added with a big size start.\n\nin this way we can avoid overflow.\n\nHope this helps "
                    },
                    {
                        "username": "spell_bound",
                        "content": "can you explain it"
                    },
                    {
                        "username": "rahuldoc98",
                        "content": "My approach is correct in that I am searching half the space by rejecting the other half, but doing it recursively. Not sure why the compiler is giving a time limit exceeded error."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Here every time we call a api guess and inside guess we pass mid value every time."
                    },
                    {
                        "username": "i_am_guts",
                        "content": "yes, thanks for the idea, it actually worked"
                    },
                    {
                        "username": "_aavash_",
                        "content": "Misleading problem statement. Needs to be fixed asap!"
                    },
                    {
                        "username": "kaushalkishoresharma07",
                        "content": "THE general mistake of this question is to use mid formula correctly .\\nmid =left+(right-left)/2;\\nThank you . and have a wonderfull coding journey."
                    },
                    {
                        "username": "mylo_ms",
                        "content": "it seems so. Could you explain to me why (l+r)/ 2 returns TLE though the vales are equal? Thanks!!"
                    },
                    {
                        "username": "Aldino1997",
                        "content": "The problem is poor explained. "
                    },
                    {
                        "username": "rajender7",
                        "content": "This question should be marked HARD considering the phrasing of the problem description."
                    }
                ]
            },
            {
                "id": 1983327,
                "content": [
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=mrarZFTe4BE\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "L1999N",
                        "content": "why isn\\'t this working for n = 2147483647\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r = n + 1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2 ;\\n            int result = guess(mid);\\n            if (result == 0){\\n                return mid;\\n            }\\n            else if (result == -1){\\n                r = mid;\\n            }\\n            else if (result == 1){\\n                l = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "muskan23",
                        "content": "2 mistakes\\nwhile(l<h) //while(l<=h)\\n.\\n.\\nh=mid //h=mid-1"
                    },
                    {
                        "username": "stridemann",
                        "content": "I\\'m getting time limit exceeded on 2126753390 using binary search, wtf.\\n\\npublic int GuessNumber(int n)\\n{\\n    var left = 1;\\n    var right = n;\\n    while (left <= right)\\n    {\\n        var middle = (left + right) / 2;\\n        var num = guess(middle);\\n        if (num > 0)\\n            left = middle + 1;\\n        else if (num < 0)\\n            right = middle - 1;\\n        else\\n            return middle;\\n    }\\n    return left;\\n}"
                    },
                    {
                        "username": "ShrivastavVinit",
                        "content": "\\n first mistake\\nelse if (result == -1){\\nr = mid;        // r==mid-1;  \\n\\nsecond mistake\\nreturn -1;   //return l;\\n\\nhope this works"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "what the hell is this question...\\n"
                    },
                    {
                        "username": "NatureSage",
                        "content": "Exactly"
                    },
                    {
                        "username": "zhangyan985211",
                        "content": "use `mid = (h + l ) >>> 1` `mid = (l+h)/2`"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem in binary search approach?\\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \\nys .\\n\\nTo be more clear \\'>>>\\' (called unsigned right shift operator in java) in java is used to right shifting for +ve integers & \\'>>\\'(called signed right shift operator in java) used to right shifting -ve integers to preserve sign.\\n\\n\\'>>\\' in c++ is used for right shifting for +ve integers. \\ni think it cannot be used with -ve number (limited knowlege in c++) \\n\\n"
                    },
                    {
                        "username": "sandeeprawat4",
                        "content": "[@spell_bound](/spell_bound) That\\'s right"
                    },
                    {
                        "username": "spell_bound",
                        "content": "[@jithinbp](/jithinbp)  I think this('>>>') called right shift operator .\nin C++ we can use it like '>>'  \nam i right?\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \nWays to reduce overflow when using  mid = (start + end) / 2\noverflow occurs if start and end are of higher values that can be stored as integer.\n1:\n \">>>\" is shifting operator (performs in bit) it essentially divides the left part of the operator with power of 2, the power is determined by the right part of the operator.\n\neg;\n5 >>> 1 means  5 / (2^1)  ie, 5/2\n6 >>> 3  means 6 /(2 ^ 3) ie, 6/8\n\nThis operation is performed bitwise.\n2:\n\nmid = start + (end - start) / 2;\n\n(end - start) reduces the size of the value and we divide it by 2\nso we are adding a smaller value to start.\ninstead a big size end directly added with a big size start.\n\nin this way we can avoid overflow.\n\nHope this helps "
                    },
                    {
                        "username": "spell_bound",
                        "content": "can you explain it"
                    },
                    {
                        "username": "rahuldoc98",
                        "content": "My approach is correct in that I am searching half the space by rejecting the other half, but doing it recursively. Not sure why the compiler is giving a time limit exceeded error."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Here every time we call a api guess and inside guess we pass mid value every time."
                    },
                    {
                        "username": "i_am_guts",
                        "content": "yes, thanks for the idea, it actually worked"
                    },
                    {
                        "username": "_aavash_",
                        "content": "Misleading problem statement. Needs to be fixed asap!"
                    },
                    {
                        "username": "kaushalkishoresharma07",
                        "content": "THE general mistake of this question is to use mid formula correctly .\\nmid =left+(right-left)/2;\\nThank you . and have a wonderfull coding journey."
                    },
                    {
                        "username": "mylo_ms",
                        "content": "it seems so. Could you explain to me why (l+r)/ 2 returns TLE though the vales are equal? Thanks!!"
                    },
                    {
                        "username": "Aldino1997",
                        "content": "The problem is poor explained. "
                    },
                    {
                        "username": "rajender7",
                        "content": "This question should be marked HARD considering the phrasing of the problem description."
                    }
                ]
            },
            {
                "id": 1935175,
                "content": [
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=mrarZFTe4BE\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "L1999N",
                        "content": "why isn\\'t this working for n = 2147483647\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r = n + 1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2 ;\\n            int result = guess(mid);\\n            if (result == 0){\\n                return mid;\\n            }\\n            else if (result == -1){\\n                r = mid;\\n            }\\n            else if (result == 1){\\n                l = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "muskan23",
                        "content": "2 mistakes\\nwhile(l<h) //while(l<=h)\\n.\\n.\\nh=mid //h=mid-1"
                    },
                    {
                        "username": "stridemann",
                        "content": "I\\'m getting time limit exceeded on 2126753390 using binary search, wtf.\\n\\npublic int GuessNumber(int n)\\n{\\n    var left = 1;\\n    var right = n;\\n    while (left <= right)\\n    {\\n        var middle = (left + right) / 2;\\n        var num = guess(middle);\\n        if (num > 0)\\n            left = middle + 1;\\n        else if (num < 0)\\n            right = middle - 1;\\n        else\\n            return middle;\\n    }\\n    return left;\\n}"
                    },
                    {
                        "username": "ShrivastavVinit",
                        "content": "\\n first mistake\\nelse if (result == -1){\\nr = mid;        // r==mid-1;  \\n\\nsecond mistake\\nreturn -1;   //return l;\\n\\nhope this works"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "what the hell is this question...\\n"
                    },
                    {
                        "username": "NatureSage",
                        "content": "Exactly"
                    },
                    {
                        "username": "zhangyan985211",
                        "content": "use `mid = (h + l ) >>> 1` `mid = (l+h)/2`"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem in binary search approach?\\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \\nys .\\n\\nTo be more clear \\'>>>\\' (called unsigned right shift operator in java) in java is used to right shifting for +ve integers & \\'>>\\'(called signed right shift operator in java) used to right shifting -ve integers to preserve sign.\\n\\n\\'>>\\' in c++ is used for right shifting for +ve integers. \\ni think it cannot be used with -ve number (limited knowlege in c++) \\n\\n"
                    },
                    {
                        "username": "sandeeprawat4",
                        "content": "[@spell_bound](/spell_bound) That\\'s right"
                    },
                    {
                        "username": "spell_bound",
                        "content": "[@jithinbp](/jithinbp)  I think this('>>>') called right shift operator .\nin C++ we can use it like '>>'  \nam i right?\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \nWays to reduce overflow when using  mid = (start + end) / 2\noverflow occurs if start and end are of higher values that can be stored as integer.\n1:\n \">>>\" is shifting operator (performs in bit) it essentially divides the left part of the operator with power of 2, the power is determined by the right part of the operator.\n\neg;\n5 >>> 1 means  5 / (2^1)  ie, 5/2\n6 >>> 3  means 6 /(2 ^ 3) ie, 6/8\n\nThis operation is performed bitwise.\n2:\n\nmid = start + (end - start) / 2;\n\n(end - start) reduces the size of the value and we divide it by 2\nso we are adding a smaller value to start.\ninstead a big size end directly added with a big size start.\n\nin this way we can avoid overflow.\n\nHope this helps "
                    },
                    {
                        "username": "spell_bound",
                        "content": "can you explain it"
                    },
                    {
                        "username": "rahuldoc98",
                        "content": "My approach is correct in that I am searching half the space by rejecting the other half, but doing it recursively. Not sure why the compiler is giving a time limit exceeded error."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Here every time we call a api guess and inside guess we pass mid value every time."
                    },
                    {
                        "username": "i_am_guts",
                        "content": "yes, thanks for the idea, it actually worked"
                    },
                    {
                        "username": "_aavash_",
                        "content": "Misleading problem statement. Needs to be fixed asap!"
                    },
                    {
                        "username": "kaushalkishoresharma07",
                        "content": "THE general mistake of this question is to use mid formula correctly .\\nmid =left+(right-left)/2;\\nThank you . and have a wonderfull coding journey."
                    },
                    {
                        "username": "mylo_ms",
                        "content": "it seems so. Could you explain to me why (l+r)/ 2 returns TLE though the vales are equal? Thanks!!"
                    },
                    {
                        "username": "Aldino1997",
                        "content": "The problem is poor explained. "
                    },
                    {
                        "username": "rajender7",
                        "content": "This question should be marked HARD considering the phrasing of the problem description."
                    }
                ]
            },
            {
                "id": 1827506,
                "content": [
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=mrarZFTe4BE\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "L1999N",
                        "content": "why isn\\'t this working for n = 2147483647\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r = n + 1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2 ;\\n            int result = guess(mid);\\n            if (result == 0){\\n                return mid;\\n            }\\n            else if (result == -1){\\n                r = mid;\\n            }\\n            else if (result == 1){\\n                l = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "muskan23",
                        "content": "2 mistakes\\nwhile(l<h) //while(l<=h)\\n.\\n.\\nh=mid //h=mid-1"
                    },
                    {
                        "username": "stridemann",
                        "content": "I\\'m getting time limit exceeded on 2126753390 using binary search, wtf.\\n\\npublic int GuessNumber(int n)\\n{\\n    var left = 1;\\n    var right = n;\\n    while (left <= right)\\n    {\\n        var middle = (left + right) / 2;\\n        var num = guess(middle);\\n        if (num > 0)\\n            left = middle + 1;\\n        else if (num < 0)\\n            right = middle - 1;\\n        else\\n            return middle;\\n    }\\n    return left;\\n}"
                    },
                    {
                        "username": "ShrivastavVinit",
                        "content": "\\n first mistake\\nelse if (result == -1){\\nr = mid;        // r==mid-1;  \\n\\nsecond mistake\\nreturn -1;   //return l;\\n\\nhope this works"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "what the hell is this question...\\n"
                    },
                    {
                        "username": "NatureSage",
                        "content": "Exactly"
                    },
                    {
                        "username": "zhangyan985211",
                        "content": "use `mid = (h + l ) >>> 1` `mid = (l+h)/2`"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem in binary search approach?\\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \\nys .\\n\\nTo be more clear \\'>>>\\' (called unsigned right shift operator in java) in java is used to right shifting for +ve integers & \\'>>\\'(called signed right shift operator in java) used to right shifting -ve integers to preserve sign.\\n\\n\\'>>\\' in c++ is used for right shifting for +ve integers. \\ni think it cannot be used with -ve number (limited knowlege in c++) \\n\\n"
                    },
                    {
                        "username": "sandeeprawat4",
                        "content": "[@spell_bound](/spell_bound) That\\'s right"
                    },
                    {
                        "username": "spell_bound",
                        "content": "[@jithinbp](/jithinbp)  I think this('>>>') called right shift operator .\nin C++ we can use it like '>>'  \nam i right?\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \nWays to reduce overflow when using  mid = (start + end) / 2\noverflow occurs if start and end are of higher values that can be stored as integer.\n1:\n \">>>\" is shifting operator (performs in bit) it essentially divides the left part of the operator with power of 2, the power is determined by the right part of the operator.\n\neg;\n5 >>> 1 means  5 / (2^1)  ie, 5/2\n6 >>> 3  means 6 /(2 ^ 3) ie, 6/8\n\nThis operation is performed bitwise.\n2:\n\nmid = start + (end - start) / 2;\n\n(end - start) reduces the size of the value and we divide it by 2\nso we are adding a smaller value to start.\ninstead a big size end directly added with a big size start.\n\nin this way we can avoid overflow.\n\nHope this helps "
                    },
                    {
                        "username": "spell_bound",
                        "content": "can you explain it"
                    },
                    {
                        "username": "rahuldoc98",
                        "content": "My approach is correct in that I am searching half the space by rejecting the other half, but doing it recursively. Not sure why the compiler is giving a time limit exceeded error."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Here every time we call a api guess and inside guess we pass mid value every time."
                    },
                    {
                        "username": "i_am_guts",
                        "content": "yes, thanks for the idea, it actually worked"
                    },
                    {
                        "username": "_aavash_",
                        "content": "Misleading problem statement. Needs to be fixed asap!"
                    },
                    {
                        "username": "kaushalkishoresharma07",
                        "content": "THE general mistake of this question is to use mid formula correctly .\\nmid =left+(right-left)/2;\\nThank you . and have a wonderfull coding journey."
                    },
                    {
                        "username": "mylo_ms",
                        "content": "it seems so. Could you explain to me why (l+r)/ 2 returns TLE though the vales are equal? Thanks!!"
                    },
                    {
                        "username": "Aldino1997",
                        "content": "The problem is poor explained. "
                    },
                    {
                        "username": "rajender7",
                        "content": "This question should be marked HARD considering the phrasing of the problem description."
                    }
                ]
            },
            {
                "id": 2065674,
                "content": [
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=mrarZFTe4BE\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "L1999N",
                        "content": "why isn\\'t this working for n = 2147483647\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r = n + 1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2 ;\\n            int result = guess(mid);\\n            if (result == 0){\\n                return mid;\\n            }\\n            else if (result == -1){\\n                r = mid;\\n            }\\n            else if (result == 1){\\n                l = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "muskan23",
                        "content": "2 mistakes\\nwhile(l<h) //while(l<=h)\\n.\\n.\\nh=mid //h=mid-1"
                    },
                    {
                        "username": "stridemann",
                        "content": "I\\'m getting time limit exceeded on 2126753390 using binary search, wtf.\\n\\npublic int GuessNumber(int n)\\n{\\n    var left = 1;\\n    var right = n;\\n    while (left <= right)\\n    {\\n        var middle = (left + right) / 2;\\n        var num = guess(middle);\\n        if (num > 0)\\n            left = middle + 1;\\n        else if (num < 0)\\n            right = middle - 1;\\n        else\\n            return middle;\\n    }\\n    return left;\\n}"
                    },
                    {
                        "username": "ShrivastavVinit",
                        "content": "\\n first mistake\\nelse if (result == -1){\\nr = mid;        // r==mid-1;  \\n\\nsecond mistake\\nreturn -1;   //return l;\\n\\nhope this works"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "what the hell is this question...\\n"
                    },
                    {
                        "username": "NatureSage",
                        "content": "Exactly"
                    },
                    {
                        "username": "zhangyan985211",
                        "content": "use `mid = (h + l ) >>> 1` `mid = (l+h)/2`"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem in binary search approach?\\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \\nys .\\n\\nTo be more clear \\'>>>\\' (called unsigned right shift operator in java) in java is used to right shifting for +ve integers & \\'>>\\'(called signed right shift operator in java) used to right shifting -ve integers to preserve sign.\\n\\n\\'>>\\' in c++ is used for right shifting for +ve integers. \\ni think it cannot be used with -ve number (limited knowlege in c++) \\n\\n"
                    },
                    {
                        "username": "sandeeprawat4",
                        "content": "[@spell_bound](/spell_bound) That\\'s right"
                    },
                    {
                        "username": "spell_bound",
                        "content": "[@jithinbp](/jithinbp)  I think this('>>>') called right shift operator .\nin C++ we can use it like '>>'  \nam i right?\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \nWays to reduce overflow when using  mid = (start + end) / 2\noverflow occurs if start and end are of higher values that can be stored as integer.\n1:\n \">>>\" is shifting operator (performs in bit) it essentially divides the left part of the operator with power of 2, the power is determined by the right part of the operator.\n\neg;\n5 >>> 1 means  5 / (2^1)  ie, 5/2\n6 >>> 3  means 6 /(2 ^ 3) ie, 6/8\n\nThis operation is performed bitwise.\n2:\n\nmid = start + (end - start) / 2;\n\n(end - start) reduces the size of the value and we divide it by 2\nso we are adding a smaller value to start.\ninstead a big size end directly added with a big size start.\n\nin this way we can avoid overflow.\n\nHope this helps "
                    },
                    {
                        "username": "spell_bound",
                        "content": "can you explain it"
                    },
                    {
                        "username": "rahuldoc98",
                        "content": "My approach is correct in that I am searching half the space by rejecting the other half, but doing it recursively. Not sure why the compiler is giving a time limit exceeded error."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Here every time we call a api guess and inside guess we pass mid value every time."
                    },
                    {
                        "username": "i_am_guts",
                        "content": "yes, thanks for the idea, it actually worked"
                    },
                    {
                        "username": "_aavash_",
                        "content": "Misleading problem statement. Needs to be fixed asap!"
                    },
                    {
                        "username": "kaushalkishoresharma07",
                        "content": "THE general mistake of this question is to use mid formula correctly .\\nmid =left+(right-left)/2;\\nThank you . and have a wonderfull coding journey."
                    },
                    {
                        "username": "mylo_ms",
                        "content": "it seems so. Could you explain to me why (l+r)/ 2 returns TLE though the vales are equal? Thanks!!"
                    },
                    {
                        "username": "Aldino1997",
                        "content": "The problem is poor explained. "
                    },
                    {
                        "username": "rajender7",
                        "content": "This question should be marked HARD considering the phrasing of the problem description."
                    }
                ]
            },
            {
                "id": 2058289,
                "content": [
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=mrarZFTe4BE\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "L1999N",
                        "content": "why isn\\'t this working for n = 2147483647\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int l = 1;\\n        int r = n + 1;\\n        while(l < r){\\n            int mid = l + (r - l) / 2 ;\\n            int result = guess(mid);\\n            if (result == 0){\\n                return mid;\\n            }\\n            else if (result == -1){\\n                r = mid;\\n            }\\n            else if (result == 1){\\n                l = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "muskan23",
                        "content": "2 mistakes\\nwhile(l<h) //while(l<=h)\\n.\\n.\\nh=mid //h=mid-1"
                    },
                    {
                        "username": "stridemann",
                        "content": "I\\'m getting time limit exceeded on 2126753390 using binary search, wtf.\\n\\npublic int GuessNumber(int n)\\n{\\n    var left = 1;\\n    var right = n;\\n    while (left <= right)\\n    {\\n        var middle = (left + right) / 2;\\n        var num = guess(middle);\\n        if (num > 0)\\n            left = middle + 1;\\n        else if (num < 0)\\n            right = middle - 1;\\n        else\\n            return middle;\\n    }\\n    return left;\\n}"
                    },
                    {
                        "username": "ShrivastavVinit",
                        "content": "\\n first mistake\\nelse if (result == -1){\\nr = mid;        // r==mid-1;  \\n\\nsecond mistake\\nreturn -1;   //return l;\\n\\nhope this works"
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "what the hell is this question...\\n"
                    },
                    {
                        "username": "NatureSage",
                        "content": "Exactly"
                    },
                    {
                        "username": "zhangyan985211",
                        "content": "use `mid = (h + l ) >>> 1` `mid = (l+h)/2`"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem in binary search approach?\\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \\nys .\\n\\nTo be more clear \\'>>>\\' (called unsigned right shift operator in java) in java is used to right shifting for +ve integers & \\'>>\\'(called signed right shift operator in java) used to right shifting -ve integers to preserve sign.\\n\\n\\'>>\\' in c++ is used for right shifting for +ve integers. \\ni think it cannot be used with -ve number (limited knowlege in c++) \\n\\n"
                    },
                    {
                        "username": "sandeeprawat4",
                        "content": "[@spell_bound](/spell_bound) That\\'s right"
                    },
                    {
                        "username": "spell_bound",
                        "content": "[@jithinbp](/jithinbp)  I think this('>>>') called right shift operator .\nin C++ we can use it like '>>'  \nam i right?\n"
                    },
                    {
                        "username": "jithinbp",
                        "content": "[@spell_bound](/spell_bound)  \nWays to reduce overflow when using  mid = (start + end) / 2\noverflow occurs if start and end are of higher values that can be stored as integer.\n1:\n \">>>\" is shifting operator (performs in bit) it essentially divides the left part of the operator with power of 2, the power is determined by the right part of the operator.\n\neg;\n5 >>> 1 means  5 / (2^1)  ie, 5/2\n6 >>> 3  means 6 /(2 ^ 3) ie, 6/8\n\nThis operation is performed bitwise.\n2:\n\nmid = start + (end - start) / 2;\n\n(end - start) reduces the size of the value and we divide it by 2\nso we are adding a smaller value to start.\ninstead a big size end directly added with a big size start.\n\nin this way we can avoid overflow.\n\nHope this helps "
                    },
                    {
                        "username": "spell_bound",
                        "content": "can you explain it"
                    },
                    {
                        "username": "rahuldoc98",
                        "content": "My approach is correct in that I am searching half the space by rejecting the other half, but doing it recursively. Not sure why the compiler is giving a time limit exceeded error."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Here every time we call a api guess and inside guess we pass mid value every time."
                    },
                    {
                        "username": "i_am_guts",
                        "content": "yes, thanks for the idea, it actually worked"
                    },
                    {
                        "username": "_aavash_",
                        "content": "Misleading problem statement. Needs to be fixed asap!"
                    },
                    {
                        "username": "kaushalkishoresharma07",
                        "content": "THE general mistake of this question is to use mid formula correctly .\\nmid =left+(right-left)/2;\\nThank you . and have a wonderfull coding journey."
                    },
                    {
                        "username": "mylo_ms",
                        "content": "it seems so. Could you explain to me why (l+r)/ 2 returns TLE though the vales are equal? Thanks!!"
                    },
                    {
                        "username": "Aldino1997",
                        "content": "The problem is poor explained. "
                    },
                    {
                        "username": "rajender7",
                        "content": "This question should be marked HARD considering the phrasing of the problem description."
                    }
                ]
            },
            {
                "id": 2041477,
                "content": [
                    {
                        "username": "towardsbackwards",
                        "content": "I wrote the code that implements a binary search, BUT. It NEVER can find a pick if the guess is smaller. For example: the pick number is 6, my first guess is 5 - guessNumber will return \"-1\". Same for pick number 33 and first guess in range 1-32. Has anyone else encountered this problem? I think this is not entirely normal (or am I wrong?)"
                    },
                    {
                        "username": "ercanK",
                        "content": "If `your guess` < `pick`, then the provided `guess` function (not the `guessNumber` function that we have to implement) returns 1. In that case, you have to increase lower bound by 1. If `your guess` > `pick`, then `guess` function returns -1 and you have decrease upper bound by 1."
                    },
                    {
                        "username": "arkasusue099",
                        "content": "The question is confusing lol"
                    },
                    {
                        "username": "shivx_444",
                        "content": "same as binary approach but in if-else condition use guess(num)==0 or -1 or 1\\n0 -> pick number found \\n1 -> pick is greater than num \\n-1 -> pick is lower than num"
                    },
                    {
                        "username": "shivansh5551",
                        "content": "As a begineer how to start solve these types of problem ? "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "friend you can check out the related topics that are demanded by the problem setter to solve the problem. You can learn those topics, and then start to implement them in actual questions, from easy ones, and slowly progressing towards the hard ones."
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "# What\\'s wrong with int overflow\\n\\n```cpp\\n    int guessNumber(int n) {\\n        int s=1, end =n;\\n        // binary search\\n\\n        while(s<=end){\\n            long long  mid = (s+end)/2;\\n            int res = guess(mid);\\n            if(res == 0){ return mid;}\\n            else if (res == -1){ end = mid-1;}\\n            else{ s = mid+1;}\\n        }\\n        return 0 ;\\n\\n```"
                    },
                    {
                        "username": "ewiltshi",
                        "content": "I think you want to use `mid = s + (end - s)/2;` instead, to avoid overflow."
                    },
                    {
                        "username": "pyush98",
                        "content": "this is a really easy problem but why on earth does -1 mean that the guess is too high and +1 that the guess is too low? Rofl."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "Anyone want to leetcode together EST time zone. Please comment.\\nI have done 100 questions + Aditya Verma Series for some topics.\\nSo anyone interested to join?"
                    },
                    {
                        "username": "code_voyager",
                        "content": "Aditya verma series ! Ca you share link of that playlist"
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "Why isn't this working?\n`     def guessNumber(self, n: int) -> int:\n        y = n//2\n        answer = guess(y)\n        while answer != 0:\n            # guess was higher\n            if answer == -1:\n                y = y//2\n                answer = guess(y)\n            elif answer == 1:\n                y = y+(y//2)\n                answer = guess(y)\n        return y\n`"
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Once you understand that what we\\'ll pass into guess function it is just simple binary search algorithm after that."
                    },
                    {
                        "username": "Akhilesh_132",
                        "content": "here is the solution for c++  `your inline code...your inline code...` int guessNumber(int n) {\\n        int picked_ans = 0;\\n\\n        for(int i=n;i>0;i--){\\n            int ans = guess(i);\\n            if(ans==0) {picked_ans =  i;\\n            break;\\n            }\\n        };\\n        return picked_ans;\\n    }"
                    }
                ]
            },
            {
                "id": 2022290,
                "content": [
                    {
                        "username": "towardsbackwards",
                        "content": "I wrote the code that implements a binary search, BUT. It NEVER can find a pick if the guess is smaller. For example: the pick number is 6, my first guess is 5 - guessNumber will return \"-1\". Same for pick number 33 and first guess in range 1-32. Has anyone else encountered this problem? I think this is not entirely normal (or am I wrong?)"
                    },
                    {
                        "username": "ercanK",
                        "content": "If `your guess` < `pick`, then the provided `guess` function (not the `guessNumber` function that we have to implement) returns 1. In that case, you have to increase lower bound by 1. If `your guess` > `pick`, then `guess` function returns -1 and you have decrease upper bound by 1."
                    },
                    {
                        "username": "arkasusue099",
                        "content": "The question is confusing lol"
                    },
                    {
                        "username": "shivx_444",
                        "content": "same as binary approach but in if-else condition use guess(num)==0 or -1 or 1\\n0 -> pick number found \\n1 -> pick is greater than num \\n-1 -> pick is lower than num"
                    },
                    {
                        "username": "shivansh5551",
                        "content": "As a begineer how to start solve these types of problem ? "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "friend you can check out the related topics that are demanded by the problem setter to solve the problem. You can learn those topics, and then start to implement them in actual questions, from easy ones, and slowly progressing towards the hard ones."
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "# What\\'s wrong with int overflow\\n\\n```cpp\\n    int guessNumber(int n) {\\n        int s=1, end =n;\\n        // binary search\\n\\n        while(s<=end){\\n            long long  mid = (s+end)/2;\\n            int res = guess(mid);\\n            if(res == 0){ return mid;}\\n            else if (res == -1){ end = mid-1;}\\n            else{ s = mid+1;}\\n        }\\n        return 0 ;\\n\\n```"
                    },
                    {
                        "username": "ewiltshi",
                        "content": "I think you want to use `mid = s + (end - s)/2;` instead, to avoid overflow."
                    },
                    {
                        "username": "pyush98",
                        "content": "this is a really easy problem but why on earth does -1 mean that the guess is too high and +1 that the guess is too low? Rofl."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "Anyone want to leetcode together EST time zone. Please comment.\\nI have done 100 questions + Aditya Verma Series for some topics.\\nSo anyone interested to join?"
                    },
                    {
                        "username": "code_voyager",
                        "content": "Aditya verma series ! Ca you share link of that playlist"
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "Why isn't this working?\n`     def guessNumber(self, n: int) -> int:\n        y = n//2\n        answer = guess(y)\n        while answer != 0:\n            # guess was higher\n            if answer == -1:\n                y = y//2\n                answer = guess(y)\n            elif answer == 1:\n                y = y+(y//2)\n                answer = guess(y)\n        return y\n`"
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Once you understand that what we\\'ll pass into guess function it is just simple binary search algorithm after that."
                    },
                    {
                        "username": "Akhilesh_132",
                        "content": "here is the solution for c++  `your inline code...your inline code...` int guessNumber(int n) {\\n        int picked_ans = 0;\\n\\n        for(int i=n;i>0;i--){\\n            int ans = guess(i);\\n            if(ans==0) {picked_ans =  i;\\n            break;\\n            }\\n        };\\n        return picked_ans;\\n    }"
                    }
                ]
            },
            {
                "id": 2015692,
                "content": [
                    {
                        "username": "towardsbackwards",
                        "content": "I wrote the code that implements a binary search, BUT. It NEVER can find a pick if the guess is smaller. For example: the pick number is 6, my first guess is 5 - guessNumber will return \"-1\". Same for pick number 33 and first guess in range 1-32. Has anyone else encountered this problem? I think this is not entirely normal (or am I wrong?)"
                    },
                    {
                        "username": "ercanK",
                        "content": "If `your guess` < `pick`, then the provided `guess` function (not the `guessNumber` function that we have to implement) returns 1. In that case, you have to increase lower bound by 1. If `your guess` > `pick`, then `guess` function returns -1 and you have decrease upper bound by 1."
                    },
                    {
                        "username": "arkasusue099",
                        "content": "The question is confusing lol"
                    },
                    {
                        "username": "shivx_444",
                        "content": "same as binary approach but in if-else condition use guess(num)==0 or -1 or 1\\n0 -> pick number found \\n1 -> pick is greater than num \\n-1 -> pick is lower than num"
                    },
                    {
                        "username": "shivansh5551",
                        "content": "As a begineer how to start solve these types of problem ? "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "friend you can check out the related topics that are demanded by the problem setter to solve the problem. You can learn those topics, and then start to implement them in actual questions, from easy ones, and slowly progressing towards the hard ones."
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "# What\\'s wrong with int overflow\\n\\n```cpp\\n    int guessNumber(int n) {\\n        int s=1, end =n;\\n        // binary search\\n\\n        while(s<=end){\\n            long long  mid = (s+end)/2;\\n            int res = guess(mid);\\n            if(res == 0){ return mid;}\\n            else if (res == -1){ end = mid-1;}\\n            else{ s = mid+1;}\\n        }\\n        return 0 ;\\n\\n```"
                    },
                    {
                        "username": "ewiltshi",
                        "content": "I think you want to use `mid = s + (end - s)/2;` instead, to avoid overflow."
                    },
                    {
                        "username": "pyush98",
                        "content": "this is a really easy problem but why on earth does -1 mean that the guess is too high and +1 that the guess is too low? Rofl."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "Anyone want to leetcode together EST time zone. Please comment.\\nI have done 100 questions + Aditya Verma Series for some topics.\\nSo anyone interested to join?"
                    },
                    {
                        "username": "code_voyager",
                        "content": "Aditya verma series ! Ca you share link of that playlist"
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "Why isn't this working?\n`     def guessNumber(self, n: int) -> int:\n        y = n//2\n        answer = guess(y)\n        while answer != 0:\n            # guess was higher\n            if answer == -1:\n                y = y//2\n                answer = guess(y)\n            elif answer == 1:\n                y = y+(y//2)\n                answer = guess(y)\n        return y\n`"
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Once you understand that what we\\'ll pass into guess function it is just simple binary search algorithm after that."
                    },
                    {
                        "username": "Akhilesh_132",
                        "content": "here is the solution for c++  `your inline code...your inline code...` int guessNumber(int n) {\\n        int picked_ans = 0;\\n\\n        for(int i=n;i>0;i--){\\n            int ans = guess(i);\\n            if(ans==0) {picked_ans =  i;\\n            break;\\n            }\\n        };\\n        return picked_ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1951307,
                "content": [
                    {
                        "username": "towardsbackwards",
                        "content": "I wrote the code that implements a binary search, BUT. It NEVER can find a pick if the guess is smaller. For example: the pick number is 6, my first guess is 5 - guessNumber will return \"-1\". Same for pick number 33 and first guess in range 1-32. Has anyone else encountered this problem? I think this is not entirely normal (or am I wrong?)"
                    },
                    {
                        "username": "ercanK",
                        "content": "If `your guess` < `pick`, then the provided `guess` function (not the `guessNumber` function that we have to implement) returns 1. In that case, you have to increase lower bound by 1. If `your guess` > `pick`, then `guess` function returns -1 and you have decrease upper bound by 1."
                    },
                    {
                        "username": "arkasusue099",
                        "content": "The question is confusing lol"
                    },
                    {
                        "username": "shivx_444",
                        "content": "same as binary approach but in if-else condition use guess(num)==0 or -1 or 1\\n0 -> pick number found \\n1 -> pick is greater than num \\n-1 -> pick is lower than num"
                    },
                    {
                        "username": "shivansh5551",
                        "content": "As a begineer how to start solve these types of problem ? "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "friend you can check out the related topics that are demanded by the problem setter to solve the problem. You can learn those topics, and then start to implement them in actual questions, from easy ones, and slowly progressing towards the hard ones."
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "# What\\'s wrong with int overflow\\n\\n```cpp\\n    int guessNumber(int n) {\\n        int s=1, end =n;\\n        // binary search\\n\\n        while(s<=end){\\n            long long  mid = (s+end)/2;\\n            int res = guess(mid);\\n            if(res == 0){ return mid;}\\n            else if (res == -1){ end = mid-1;}\\n            else{ s = mid+1;}\\n        }\\n        return 0 ;\\n\\n```"
                    },
                    {
                        "username": "ewiltshi",
                        "content": "I think you want to use `mid = s + (end - s)/2;` instead, to avoid overflow."
                    },
                    {
                        "username": "pyush98",
                        "content": "this is a really easy problem but why on earth does -1 mean that the guess is too high and +1 that the guess is too low? Rofl."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "Anyone want to leetcode together EST time zone. Please comment.\\nI have done 100 questions + Aditya Verma Series for some topics.\\nSo anyone interested to join?"
                    },
                    {
                        "username": "code_voyager",
                        "content": "Aditya verma series ! Ca you share link of that playlist"
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "Why isn't this working?\n`     def guessNumber(self, n: int) -> int:\n        y = n//2\n        answer = guess(y)\n        while answer != 0:\n            # guess was higher\n            if answer == -1:\n                y = y//2\n                answer = guess(y)\n            elif answer == 1:\n                y = y+(y//2)\n                answer = guess(y)\n        return y\n`"
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Once you understand that what we\\'ll pass into guess function it is just simple binary search algorithm after that."
                    },
                    {
                        "username": "Akhilesh_132",
                        "content": "here is the solution for c++  `your inline code...your inline code...` int guessNumber(int n) {\\n        int picked_ans = 0;\\n\\n        for(int i=n;i>0;i--){\\n            int ans = guess(i);\\n            if(ans==0) {picked_ans =  i;\\n            break;\\n            }\\n        };\\n        return picked_ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1941594,
                "content": [
                    {
                        "username": "towardsbackwards",
                        "content": "I wrote the code that implements a binary search, BUT. It NEVER can find a pick if the guess is smaller. For example: the pick number is 6, my first guess is 5 - guessNumber will return \"-1\". Same for pick number 33 and first guess in range 1-32. Has anyone else encountered this problem? I think this is not entirely normal (or am I wrong?)"
                    },
                    {
                        "username": "ercanK",
                        "content": "If `your guess` < `pick`, then the provided `guess` function (not the `guessNumber` function that we have to implement) returns 1. In that case, you have to increase lower bound by 1. If `your guess` > `pick`, then `guess` function returns -1 and you have decrease upper bound by 1."
                    },
                    {
                        "username": "arkasusue099",
                        "content": "The question is confusing lol"
                    },
                    {
                        "username": "shivx_444",
                        "content": "same as binary approach but in if-else condition use guess(num)==0 or -1 or 1\\n0 -> pick number found \\n1 -> pick is greater than num \\n-1 -> pick is lower than num"
                    },
                    {
                        "username": "shivansh5551",
                        "content": "As a begineer how to start solve these types of problem ? "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "friend you can check out the related topics that are demanded by the problem setter to solve the problem. You can learn those topics, and then start to implement them in actual questions, from easy ones, and slowly progressing towards the hard ones."
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "# What\\'s wrong with int overflow\\n\\n```cpp\\n    int guessNumber(int n) {\\n        int s=1, end =n;\\n        // binary search\\n\\n        while(s<=end){\\n            long long  mid = (s+end)/2;\\n            int res = guess(mid);\\n            if(res == 0){ return mid;}\\n            else if (res == -1){ end = mid-1;}\\n            else{ s = mid+1;}\\n        }\\n        return 0 ;\\n\\n```"
                    },
                    {
                        "username": "ewiltshi",
                        "content": "I think you want to use `mid = s + (end - s)/2;` instead, to avoid overflow."
                    },
                    {
                        "username": "pyush98",
                        "content": "this is a really easy problem but why on earth does -1 mean that the guess is too high and +1 that the guess is too low? Rofl."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "Anyone want to leetcode together EST time zone. Please comment.\\nI have done 100 questions + Aditya Verma Series for some topics.\\nSo anyone interested to join?"
                    },
                    {
                        "username": "code_voyager",
                        "content": "Aditya verma series ! Ca you share link of that playlist"
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "Why isn't this working?\n`     def guessNumber(self, n: int) -> int:\n        y = n//2\n        answer = guess(y)\n        while answer != 0:\n            # guess was higher\n            if answer == -1:\n                y = y//2\n                answer = guess(y)\n            elif answer == 1:\n                y = y+(y//2)\n                answer = guess(y)\n        return y\n`"
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Once you understand that what we\\'ll pass into guess function it is just simple binary search algorithm after that."
                    },
                    {
                        "username": "Akhilesh_132",
                        "content": "here is the solution for c++  `your inline code...your inline code...` int guessNumber(int n) {\\n        int picked_ans = 0;\\n\\n        for(int i=n;i>0;i--){\\n            int ans = guess(i);\\n            if(ans==0) {picked_ans =  i;\\n            break;\\n            }\\n        };\\n        return picked_ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1935640,
                "content": [
                    {
                        "username": "towardsbackwards",
                        "content": "I wrote the code that implements a binary search, BUT. It NEVER can find a pick if the guess is smaller. For example: the pick number is 6, my first guess is 5 - guessNumber will return \"-1\". Same for pick number 33 and first guess in range 1-32. Has anyone else encountered this problem? I think this is not entirely normal (or am I wrong?)"
                    },
                    {
                        "username": "ercanK",
                        "content": "If `your guess` < `pick`, then the provided `guess` function (not the `guessNumber` function that we have to implement) returns 1. In that case, you have to increase lower bound by 1. If `your guess` > `pick`, then `guess` function returns -1 and you have decrease upper bound by 1."
                    },
                    {
                        "username": "arkasusue099",
                        "content": "The question is confusing lol"
                    },
                    {
                        "username": "shivx_444",
                        "content": "same as binary approach but in if-else condition use guess(num)==0 or -1 or 1\\n0 -> pick number found \\n1 -> pick is greater than num \\n-1 -> pick is lower than num"
                    },
                    {
                        "username": "shivansh5551",
                        "content": "As a begineer how to start solve these types of problem ? "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "friend you can check out the related topics that are demanded by the problem setter to solve the problem. You can learn those topics, and then start to implement them in actual questions, from easy ones, and slowly progressing towards the hard ones."
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "# What\\'s wrong with int overflow\\n\\n```cpp\\n    int guessNumber(int n) {\\n        int s=1, end =n;\\n        // binary search\\n\\n        while(s<=end){\\n            long long  mid = (s+end)/2;\\n            int res = guess(mid);\\n            if(res == 0){ return mid;}\\n            else if (res == -1){ end = mid-1;}\\n            else{ s = mid+1;}\\n        }\\n        return 0 ;\\n\\n```"
                    },
                    {
                        "username": "ewiltshi",
                        "content": "I think you want to use `mid = s + (end - s)/2;` instead, to avoid overflow."
                    },
                    {
                        "username": "pyush98",
                        "content": "this is a really easy problem but why on earth does -1 mean that the guess is too high and +1 that the guess is too low? Rofl."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "Anyone want to leetcode together EST time zone. Please comment.\\nI have done 100 questions + Aditya Verma Series for some topics.\\nSo anyone interested to join?"
                    },
                    {
                        "username": "code_voyager",
                        "content": "Aditya verma series ! Ca you share link of that playlist"
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "Why isn't this working?\n`     def guessNumber(self, n: int) -> int:\n        y = n//2\n        answer = guess(y)\n        while answer != 0:\n            # guess was higher\n            if answer == -1:\n                y = y//2\n                answer = guess(y)\n            elif answer == 1:\n                y = y+(y//2)\n                answer = guess(y)\n        return y\n`"
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Once you understand that what we\\'ll pass into guess function it is just simple binary search algorithm after that."
                    },
                    {
                        "username": "Akhilesh_132",
                        "content": "here is the solution for c++  `your inline code...your inline code...` int guessNumber(int n) {\\n        int picked_ans = 0;\\n\\n        for(int i=n;i>0;i--){\\n            int ans = guess(i);\\n            if(ans==0) {picked_ans =  i;\\n            break;\\n            }\\n        };\\n        return picked_ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1929813,
                "content": [
                    {
                        "username": "towardsbackwards",
                        "content": "I wrote the code that implements a binary search, BUT. It NEVER can find a pick if the guess is smaller. For example: the pick number is 6, my first guess is 5 - guessNumber will return \"-1\". Same for pick number 33 and first guess in range 1-32. Has anyone else encountered this problem? I think this is not entirely normal (or am I wrong?)"
                    },
                    {
                        "username": "ercanK",
                        "content": "If `your guess` < `pick`, then the provided `guess` function (not the `guessNumber` function that we have to implement) returns 1. In that case, you have to increase lower bound by 1. If `your guess` > `pick`, then `guess` function returns -1 and you have decrease upper bound by 1."
                    },
                    {
                        "username": "arkasusue099",
                        "content": "The question is confusing lol"
                    },
                    {
                        "username": "shivx_444",
                        "content": "same as binary approach but in if-else condition use guess(num)==0 or -1 or 1\\n0 -> pick number found \\n1 -> pick is greater than num \\n-1 -> pick is lower than num"
                    },
                    {
                        "username": "shivansh5551",
                        "content": "As a begineer how to start solve these types of problem ? "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "friend you can check out the related topics that are demanded by the problem setter to solve the problem. You can learn those topics, and then start to implement them in actual questions, from easy ones, and slowly progressing towards the hard ones."
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "# What\\'s wrong with int overflow\\n\\n```cpp\\n    int guessNumber(int n) {\\n        int s=1, end =n;\\n        // binary search\\n\\n        while(s<=end){\\n            long long  mid = (s+end)/2;\\n            int res = guess(mid);\\n            if(res == 0){ return mid;}\\n            else if (res == -1){ end = mid-1;}\\n            else{ s = mid+1;}\\n        }\\n        return 0 ;\\n\\n```"
                    },
                    {
                        "username": "ewiltshi",
                        "content": "I think you want to use `mid = s + (end - s)/2;` instead, to avoid overflow."
                    },
                    {
                        "username": "pyush98",
                        "content": "this is a really easy problem but why on earth does -1 mean that the guess is too high and +1 that the guess is too low? Rofl."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "Anyone want to leetcode together EST time zone. Please comment.\\nI have done 100 questions + Aditya Verma Series for some topics.\\nSo anyone interested to join?"
                    },
                    {
                        "username": "code_voyager",
                        "content": "Aditya verma series ! Ca you share link of that playlist"
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "Why isn't this working?\n`     def guessNumber(self, n: int) -> int:\n        y = n//2\n        answer = guess(y)\n        while answer != 0:\n            # guess was higher\n            if answer == -1:\n                y = y//2\n                answer = guess(y)\n            elif answer == 1:\n                y = y+(y//2)\n                answer = guess(y)\n        return y\n`"
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Once you understand that what we\\'ll pass into guess function it is just simple binary search algorithm after that."
                    },
                    {
                        "username": "Akhilesh_132",
                        "content": "here is the solution for c++  `your inline code...your inline code...` int guessNumber(int n) {\\n        int picked_ans = 0;\\n\\n        for(int i=n;i>0;i--){\\n            int ans = guess(i);\\n            if(ans==0) {picked_ans =  i;\\n            break;\\n            }\\n        };\\n        return picked_ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1926956,
                "content": [
                    {
                        "username": "towardsbackwards",
                        "content": "I wrote the code that implements a binary search, BUT. It NEVER can find a pick if the guess is smaller. For example: the pick number is 6, my first guess is 5 - guessNumber will return \"-1\". Same for pick number 33 and first guess in range 1-32. Has anyone else encountered this problem? I think this is not entirely normal (or am I wrong?)"
                    },
                    {
                        "username": "ercanK",
                        "content": "If `your guess` < `pick`, then the provided `guess` function (not the `guessNumber` function that we have to implement) returns 1. In that case, you have to increase lower bound by 1. If `your guess` > `pick`, then `guess` function returns -1 and you have decrease upper bound by 1."
                    },
                    {
                        "username": "arkasusue099",
                        "content": "The question is confusing lol"
                    },
                    {
                        "username": "shivx_444",
                        "content": "same as binary approach but in if-else condition use guess(num)==0 or -1 or 1\\n0 -> pick number found \\n1 -> pick is greater than num \\n-1 -> pick is lower than num"
                    },
                    {
                        "username": "shivansh5551",
                        "content": "As a begineer how to start solve these types of problem ? "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "friend you can check out the related topics that are demanded by the problem setter to solve the problem. You can learn those topics, and then start to implement them in actual questions, from easy ones, and slowly progressing towards the hard ones."
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "# What\\'s wrong with int overflow\\n\\n```cpp\\n    int guessNumber(int n) {\\n        int s=1, end =n;\\n        // binary search\\n\\n        while(s<=end){\\n            long long  mid = (s+end)/2;\\n            int res = guess(mid);\\n            if(res == 0){ return mid;}\\n            else if (res == -1){ end = mid-1;}\\n            else{ s = mid+1;}\\n        }\\n        return 0 ;\\n\\n```"
                    },
                    {
                        "username": "ewiltshi",
                        "content": "I think you want to use `mid = s + (end - s)/2;` instead, to avoid overflow."
                    },
                    {
                        "username": "pyush98",
                        "content": "this is a really easy problem but why on earth does -1 mean that the guess is too high and +1 that the guess is too low? Rofl."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "Anyone want to leetcode together EST time zone. Please comment.\\nI have done 100 questions + Aditya Verma Series for some topics.\\nSo anyone interested to join?"
                    },
                    {
                        "username": "code_voyager",
                        "content": "Aditya verma series ! Ca you share link of that playlist"
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "Why isn't this working?\n`     def guessNumber(self, n: int) -> int:\n        y = n//2\n        answer = guess(y)\n        while answer != 0:\n            # guess was higher\n            if answer == -1:\n                y = y//2\n                answer = guess(y)\n            elif answer == 1:\n                y = y+(y//2)\n                answer = guess(y)\n        return y\n`"
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Once you understand that what we\\'ll pass into guess function it is just simple binary search algorithm after that."
                    },
                    {
                        "username": "Akhilesh_132",
                        "content": "here is the solution for c++  `your inline code...your inline code...` int guessNumber(int n) {\\n        int picked_ans = 0;\\n\\n        for(int i=n;i>0;i--){\\n            int ans = guess(i);\\n            if(ans==0) {picked_ans =  i;\\n            break;\\n            }\\n        };\\n        return picked_ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1899423,
                "content": [
                    {
                        "username": "towardsbackwards",
                        "content": "I wrote the code that implements a binary search, BUT. It NEVER can find a pick if the guess is smaller. For example: the pick number is 6, my first guess is 5 - guessNumber will return \"-1\". Same for pick number 33 and first guess in range 1-32. Has anyone else encountered this problem? I think this is not entirely normal (or am I wrong?)"
                    },
                    {
                        "username": "ercanK",
                        "content": "If `your guess` < `pick`, then the provided `guess` function (not the `guessNumber` function that we have to implement) returns 1. In that case, you have to increase lower bound by 1. If `your guess` > `pick`, then `guess` function returns -1 and you have decrease upper bound by 1."
                    },
                    {
                        "username": "arkasusue099",
                        "content": "The question is confusing lol"
                    },
                    {
                        "username": "shivx_444",
                        "content": "same as binary approach but in if-else condition use guess(num)==0 or -1 or 1\\n0 -> pick number found \\n1 -> pick is greater than num \\n-1 -> pick is lower than num"
                    },
                    {
                        "username": "shivansh5551",
                        "content": "As a begineer how to start solve these types of problem ? "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "friend you can check out the related topics that are demanded by the problem setter to solve the problem. You can learn those topics, and then start to implement them in actual questions, from easy ones, and slowly progressing towards the hard ones."
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "# What\\'s wrong with int overflow\\n\\n```cpp\\n    int guessNumber(int n) {\\n        int s=1, end =n;\\n        // binary search\\n\\n        while(s<=end){\\n            long long  mid = (s+end)/2;\\n            int res = guess(mid);\\n            if(res == 0){ return mid;}\\n            else if (res == -1){ end = mid-1;}\\n            else{ s = mid+1;}\\n        }\\n        return 0 ;\\n\\n```"
                    },
                    {
                        "username": "ewiltshi",
                        "content": "I think you want to use `mid = s + (end - s)/2;` instead, to avoid overflow."
                    },
                    {
                        "username": "pyush98",
                        "content": "this is a really easy problem but why on earth does -1 mean that the guess is too high and +1 that the guess is too low? Rofl."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "Anyone want to leetcode together EST time zone. Please comment.\\nI have done 100 questions + Aditya Verma Series for some topics.\\nSo anyone interested to join?"
                    },
                    {
                        "username": "code_voyager",
                        "content": "Aditya verma series ! Ca you share link of that playlist"
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "Why isn't this working?\n`     def guessNumber(self, n: int) -> int:\n        y = n//2\n        answer = guess(y)\n        while answer != 0:\n            # guess was higher\n            if answer == -1:\n                y = y//2\n                answer = guess(y)\n            elif answer == 1:\n                y = y+(y//2)\n                answer = guess(y)\n        return y\n`"
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Once you understand that what we\\'ll pass into guess function it is just simple binary search algorithm after that."
                    },
                    {
                        "username": "Akhilesh_132",
                        "content": "here is the solution for c++  `your inline code...your inline code...` int guessNumber(int n) {\\n        int picked_ans = 0;\\n\\n        for(int i=n;i>0;i--){\\n            int ans = guess(i);\\n            if(ans==0) {picked_ans =  i;\\n            break;\\n            }\\n        };\\n        return picked_ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1893028,
                "content": [
                    {
                        "username": "towardsbackwards",
                        "content": "I wrote the code that implements a binary search, BUT. It NEVER can find a pick if the guess is smaller. For example: the pick number is 6, my first guess is 5 - guessNumber will return \"-1\". Same for pick number 33 and first guess in range 1-32. Has anyone else encountered this problem? I think this is not entirely normal (or am I wrong?)"
                    },
                    {
                        "username": "ercanK",
                        "content": "If `your guess` < `pick`, then the provided `guess` function (not the `guessNumber` function that we have to implement) returns 1. In that case, you have to increase lower bound by 1. If `your guess` > `pick`, then `guess` function returns -1 and you have decrease upper bound by 1."
                    },
                    {
                        "username": "arkasusue099",
                        "content": "The question is confusing lol"
                    },
                    {
                        "username": "shivx_444",
                        "content": "same as binary approach but in if-else condition use guess(num)==0 or -1 or 1\\n0 -> pick number found \\n1 -> pick is greater than num \\n-1 -> pick is lower than num"
                    },
                    {
                        "username": "shivansh5551",
                        "content": "As a begineer how to start solve these types of problem ? "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "friend you can check out the related topics that are demanded by the problem setter to solve the problem. You can learn those topics, and then start to implement them in actual questions, from easy ones, and slowly progressing towards the hard ones."
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "# What\\'s wrong with int overflow\\n\\n```cpp\\n    int guessNumber(int n) {\\n        int s=1, end =n;\\n        // binary search\\n\\n        while(s<=end){\\n            long long  mid = (s+end)/2;\\n            int res = guess(mid);\\n            if(res == 0){ return mid;}\\n            else if (res == -1){ end = mid-1;}\\n            else{ s = mid+1;}\\n        }\\n        return 0 ;\\n\\n```"
                    },
                    {
                        "username": "ewiltshi",
                        "content": "I think you want to use `mid = s + (end - s)/2;` instead, to avoid overflow."
                    },
                    {
                        "username": "pyush98",
                        "content": "this is a really easy problem but why on earth does -1 mean that the guess is too high and +1 that the guess is too low? Rofl."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "Anyone want to leetcode together EST time zone. Please comment.\\nI have done 100 questions + Aditya Verma Series for some topics.\\nSo anyone interested to join?"
                    },
                    {
                        "username": "code_voyager",
                        "content": "Aditya verma series ! Ca you share link of that playlist"
                    },
                    {
                        "username": "gabrielrosendo",
                        "content": "Why isn't this working?\n`     def guessNumber(self, n: int) -> int:\n        y = n//2\n        answer = guess(y)\n        while answer != 0:\n            # guess was higher\n            if answer == -1:\n                y = y//2\n                answer = guess(y)\n            elif answer == 1:\n                y = y+(y//2)\n                answer = guess(y)\n        return y\n`"
                    },
                    {
                        "username": "sarthaksharma465",
                        "content": "Once you understand that what we\\'ll pass into guess function it is just simple binary search algorithm after that."
                    },
                    {
                        "username": "Akhilesh_132",
                        "content": "here is the solution for c++  `your inline code...your inline code...` int guessNumber(int n) {\\n        int picked_ans = 0;\\n\\n        for(int i=n;i>0;i--){\\n            int ans = guess(i);\\n            if(ans==0) {picked_ans =  i;\\n            break;\\n            }\\n        };\\n        return picked_ans;\\n    }"
                    }
                ]
            },
            {
                "id": 1865804,
                "content": [
                    {
                        "username": "tokeeffe9",
                        "content": "Am I right in saying the n can never be higher than pick? "
                    },
                    {
                        "username": "_dakshinraja_",
                        "content": "This is a guess game:\\n where a pre-defined function guess is already declared for us. which will guess the number for us.\\n when the function return 0 it means we\\'ve found the number,\\n when the function returns -1 it means we\\'ve guessed a value higher than the number,\\n when the function return 1 it means we\\'ve guessed a value lower than the number.\\n\\nNow using binary search we have to guess and find the number.\\n\\n"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem is in binary search concept?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "In a nutshell, you binary-search the number that I picked in the range of [1,n]. In action, let your min to be 1, and your max to be n. You begin with the midpoint (max+min)/2 rounded to the nearest integer. If the midpoint is greater than the number I picked, you know you should reduce your max to midpoint - 1, etc. This is the typical process of binary search."
                    },
                    {
                        "username": "stacksagar",
                        "content": "### Behind the scenes, guess() function:\\n \\n```\\nfunction guess(num) {\\n  let pick = 3;\\n  if (pick === num) return 0;\\n  else if (pick > num) return 1;\\n  else return -1;\\n}\\n```"
                    },
                    {
                        "username": "stacksagar",
                        "content": "Did not understand the question properly,\\nCan any one explain me shortly?"
                    },
                    {
                        "username": "le-chat",
                        "content": "Hello!\nI don't understand, why this solution doesn't work?\n\n    public int guessNumber(int n) {\n        if (n == 1)\n            return 1;\n        int pick = n / 2;\n        int sol = guess(pick);\n        int i = 3;\n        while (sol != 0) {\n            if (sol < 0)\n                pick = pick + n / i;\n            if (sol > 0)\n                pick = pick - n / i;\n            sol = guess(pick);\n            i++;\n        }\n        return pick;\n    }\n\nError: \"Time Limit Exceeded\""
                    },
                    {
                        "username": "code_voyager",
                        "content": "Simple java solution using Binary search\\npublic int guessNumber(int n) {\\n        int high=n;\\n        int low=1;\\n        while(high>=low){\\n            int mid=low+(high-low)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)<0)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "btw this is a google question.\n\nUnder the company tag it's showing Google."
                    },
                    {
                        "username": "qiushile",
                        "content": "error: cannot find symbol\\n            guess(mid);\\n            ^\\n  symbol:   method guess(int)\\n  location: class Solution"
                    },
                    {
                        "username": "gulfaraj18",
                        "content": "guess have a return value!"
                    },
                    {
                        "username": "fishbody0418",
                        "content": "Hello, I am new coding. Can i ask why my solution is \"Time Limit Exceeded\"? I uses binary search method.\n\nclass Solution:\n\n            \n       def guessNumber(self, n: int) -> int:\n        start = 1\n        end = n\n        while start + 1 < end:\n            mid = start + (end-start)//2\n            res = guess(mid)\n            if res<0:\n                end = mid\n            elif res>0:\n                start == mid\n        if guess(start)==0:\n            return start\n        if guess(end)==0:\n            return end"
                    }
                ]
            },
            {
                "id": 1844034,
                "content": [
                    {
                        "username": "tokeeffe9",
                        "content": "Am I right in saying the n can never be higher than pick? "
                    },
                    {
                        "username": "_dakshinraja_",
                        "content": "This is a guess game:\\n where a pre-defined function guess is already declared for us. which will guess the number for us.\\n when the function return 0 it means we\\'ve found the number,\\n when the function returns -1 it means we\\'ve guessed a value higher than the number,\\n when the function return 1 it means we\\'ve guessed a value lower than the number.\\n\\nNow using binary search we have to guess and find the number.\\n\\n"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem is in binary search concept?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "In a nutshell, you binary-search the number that I picked in the range of [1,n]. In action, let your min to be 1, and your max to be n. You begin with the midpoint (max+min)/2 rounded to the nearest integer. If the midpoint is greater than the number I picked, you know you should reduce your max to midpoint - 1, etc. This is the typical process of binary search."
                    },
                    {
                        "username": "stacksagar",
                        "content": "### Behind the scenes, guess() function:\\n \\n```\\nfunction guess(num) {\\n  let pick = 3;\\n  if (pick === num) return 0;\\n  else if (pick > num) return 1;\\n  else return -1;\\n}\\n```"
                    },
                    {
                        "username": "stacksagar",
                        "content": "Did not understand the question properly,\\nCan any one explain me shortly?"
                    },
                    {
                        "username": "le-chat",
                        "content": "Hello!\nI don't understand, why this solution doesn't work?\n\n    public int guessNumber(int n) {\n        if (n == 1)\n            return 1;\n        int pick = n / 2;\n        int sol = guess(pick);\n        int i = 3;\n        while (sol != 0) {\n            if (sol < 0)\n                pick = pick + n / i;\n            if (sol > 0)\n                pick = pick - n / i;\n            sol = guess(pick);\n            i++;\n        }\n        return pick;\n    }\n\nError: \"Time Limit Exceeded\""
                    },
                    {
                        "username": "code_voyager",
                        "content": "Simple java solution using Binary search\\npublic int guessNumber(int n) {\\n        int high=n;\\n        int low=1;\\n        while(high>=low){\\n            int mid=low+(high-low)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)<0)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "btw this is a google question.\n\nUnder the company tag it's showing Google."
                    },
                    {
                        "username": "qiushile",
                        "content": "error: cannot find symbol\\n            guess(mid);\\n            ^\\n  symbol:   method guess(int)\\n  location: class Solution"
                    },
                    {
                        "username": "gulfaraj18",
                        "content": "guess have a return value!"
                    },
                    {
                        "username": "fishbody0418",
                        "content": "Hello, I am new coding. Can i ask why my solution is \"Time Limit Exceeded\"? I uses binary search method.\n\nclass Solution:\n\n            \n       def guessNumber(self, n: int) -> int:\n        start = 1\n        end = n\n        while start + 1 < end:\n            mid = start + (end-start)//2\n            res = guess(mid)\n            if res<0:\n                end = mid\n            elif res>0:\n                start == mid\n        if guess(start)==0:\n            return start\n        if guess(end)==0:\n            return end"
                    }
                ]
            },
            {
                "id": 1834311,
                "content": [
                    {
                        "username": "tokeeffe9",
                        "content": "Am I right in saying the n can never be higher than pick? "
                    },
                    {
                        "username": "_dakshinraja_",
                        "content": "This is a guess game:\\n where a pre-defined function guess is already declared for us. which will guess the number for us.\\n when the function return 0 it means we\\'ve found the number,\\n when the function returns -1 it means we\\'ve guessed a value higher than the number,\\n when the function return 1 it means we\\'ve guessed a value lower than the number.\\n\\nNow using binary search we have to guess and find the number.\\n\\n"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem is in binary search concept?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "In a nutshell, you binary-search the number that I picked in the range of [1,n]. In action, let your min to be 1, and your max to be n. You begin with the midpoint (max+min)/2 rounded to the nearest integer. If the midpoint is greater than the number I picked, you know you should reduce your max to midpoint - 1, etc. This is the typical process of binary search."
                    },
                    {
                        "username": "stacksagar",
                        "content": "### Behind the scenes, guess() function:\\n \\n```\\nfunction guess(num) {\\n  let pick = 3;\\n  if (pick === num) return 0;\\n  else if (pick > num) return 1;\\n  else return -1;\\n}\\n```"
                    },
                    {
                        "username": "stacksagar",
                        "content": "Did not understand the question properly,\\nCan any one explain me shortly?"
                    },
                    {
                        "username": "le-chat",
                        "content": "Hello!\nI don't understand, why this solution doesn't work?\n\n    public int guessNumber(int n) {\n        if (n == 1)\n            return 1;\n        int pick = n / 2;\n        int sol = guess(pick);\n        int i = 3;\n        while (sol != 0) {\n            if (sol < 0)\n                pick = pick + n / i;\n            if (sol > 0)\n                pick = pick - n / i;\n            sol = guess(pick);\n            i++;\n        }\n        return pick;\n    }\n\nError: \"Time Limit Exceeded\""
                    },
                    {
                        "username": "code_voyager",
                        "content": "Simple java solution using Binary search\\npublic int guessNumber(int n) {\\n        int high=n;\\n        int low=1;\\n        while(high>=low){\\n            int mid=low+(high-low)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)<0)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "btw this is a google question.\n\nUnder the company tag it's showing Google."
                    },
                    {
                        "username": "qiushile",
                        "content": "error: cannot find symbol\\n            guess(mid);\\n            ^\\n  symbol:   method guess(int)\\n  location: class Solution"
                    },
                    {
                        "username": "gulfaraj18",
                        "content": "guess have a return value!"
                    },
                    {
                        "username": "fishbody0418",
                        "content": "Hello, I am new coding. Can i ask why my solution is \"Time Limit Exceeded\"? I uses binary search method.\n\nclass Solution:\n\n            \n       def guessNumber(self, n: int) -> int:\n        start = 1\n        end = n\n        while start + 1 < end:\n            mid = start + (end-start)//2\n            res = guess(mid)\n            if res<0:\n                end = mid\n            elif res>0:\n                start == mid\n        if guess(start)==0:\n            return start\n        if guess(end)==0:\n            return end"
                    }
                ]
            },
            {
                "id": 1823703,
                "content": [
                    {
                        "username": "tokeeffe9",
                        "content": "Am I right in saying the n can never be higher than pick? "
                    },
                    {
                        "username": "_dakshinraja_",
                        "content": "This is a guess game:\\n where a pre-defined function guess is already declared for us. which will guess the number for us.\\n when the function return 0 it means we\\'ve found the number,\\n when the function returns -1 it means we\\'ve guessed a value higher than the number,\\n when the function return 1 it means we\\'ve guessed a value lower than the number.\\n\\nNow using binary search we have to guess and find the number.\\n\\n"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem is in binary search concept?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "In a nutshell, you binary-search the number that I picked in the range of [1,n]. In action, let your min to be 1, and your max to be n. You begin with the midpoint (max+min)/2 rounded to the nearest integer. If the midpoint is greater than the number I picked, you know you should reduce your max to midpoint - 1, etc. This is the typical process of binary search."
                    },
                    {
                        "username": "stacksagar",
                        "content": "### Behind the scenes, guess() function:\\n \\n```\\nfunction guess(num) {\\n  let pick = 3;\\n  if (pick === num) return 0;\\n  else if (pick > num) return 1;\\n  else return -1;\\n}\\n```"
                    },
                    {
                        "username": "stacksagar",
                        "content": "Did not understand the question properly,\\nCan any one explain me shortly?"
                    },
                    {
                        "username": "le-chat",
                        "content": "Hello!\nI don't understand, why this solution doesn't work?\n\n    public int guessNumber(int n) {\n        if (n == 1)\n            return 1;\n        int pick = n / 2;\n        int sol = guess(pick);\n        int i = 3;\n        while (sol != 0) {\n            if (sol < 0)\n                pick = pick + n / i;\n            if (sol > 0)\n                pick = pick - n / i;\n            sol = guess(pick);\n            i++;\n        }\n        return pick;\n    }\n\nError: \"Time Limit Exceeded\""
                    },
                    {
                        "username": "code_voyager",
                        "content": "Simple java solution using Binary search\\npublic int guessNumber(int n) {\\n        int high=n;\\n        int low=1;\\n        while(high>=low){\\n            int mid=low+(high-low)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)<0)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "btw this is a google question.\n\nUnder the company tag it's showing Google."
                    },
                    {
                        "username": "qiushile",
                        "content": "error: cannot find symbol\\n            guess(mid);\\n            ^\\n  symbol:   method guess(int)\\n  location: class Solution"
                    },
                    {
                        "username": "gulfaraj18",
                        "content": "guess have a return value!"
                    },
                    {
                        "username": "fishbody0418",
                        "content": "Hello, I am new coding. Can i ask why my solution is \"Time Limit Exceeded\"? I uses binary search method.\n\nclass Solution:\n\n            \n       def guessNumber(self, n: int) -> int:\n        start = 1\n        end = n\n        while start + 1 < end:\n            mid = start + (end-start)//2\n            res = guess(mid)\n            if res<0:\n                end = mid\n            elif res>0:\n                start == mid\n        if guess(start)==0:\n            return start\n        if guess(end)==0:\n            return end"
                    }
                ]
            },
            {
                "id": 1823642,
                "content": [
                    {
                        "username": "tokeeffe9",
                        "content": "Am I right in saying the n can never be higher than pick? "
                    },
                    {
                        "username": "_dakshinraja_",
                        "content": "This is a guess game:\\n where a pre-defined function guess is already declared for us. which will guess the number for us.\\n when the function return 0 it means we\\'ve found the number,\\n when the function returns -1 it means we\\'ve guessed a value higher than the number,\\n when the function return 1 it means we\\'ve guessed a value lower than the number.\\n\\nNow using binary search we have to guess and find the number.\\n\\n"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem is in binary search concept?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "In a nutshell, you binary-search the number that I picked in the range of [1,n]. In action, let your min to be 1, and your max to be n. You begin with the midpoint (max+min)/2 rounded to the nearest integer. If the midpoint is greater than the number I picked, you know you should reduce your max to midpoint - 1, etc. This is the typical process of binary search."
                    },
                    {
                        "username": "stacksagar",
                        "content": "### Behind the scenes, guess() function:\\n \\n```\\nfunction guess(num) {\\n  let pick = 3;\\n  if (pick === num) return 0;\\n  else if (pick > num) return 1;\\n  else return -1;\\n}\\n```"
                    },
                    {
                        "username": "stacksagar",
                        "content": "Did not understand the question properly,\\nCan any one explain me shortly?"
                    },
                    {
                        "username": "le-chat",
                        "content": "Hello!\nI don't understand, why this solution doesn't work?\n\n    public int guessNumber(int n) {\n        if (n == 1)\n            return 1;\n        int pick = n / 2;\n        int sol = guess(pick);\n        int i = 3;\n        while (sol != 0) {\n            if (sol < 0)\n                pick = pick + n / i;\n            if (sol > 0)\n                pick = pick - n / i;\n            sol = guess(pick);\n            i++;\n        }\n        return pick;\n    }\n\nError: \"Time Limit Exceeded\""
                    },
                    {
                        "username": "code_voyager",
                        "content": "Simple java solution using Binary search\\npublic int guessNumber(int n) {\\n        int high=n;\\n        int low=1;\\n        while(high>=low){\\n            int mid=low+(high-low)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)<0)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "btw this is a google question.\n\nUnder the company tag it's showing Google."
                    },
                    {
                        "username": "qiushile",
                        "content": "error: cannot find symbol\\n            guess(mid);\\n            ^\\n  symbol:   method guess(int)\\n  location: class Solution"
                    },
                    {
                        "username": "gulfaraj18",
                        "content": "guess have a return value!"
                    },
                    {
                        "username": "fishbody0418",
                        "content": "Hello, I am new coding. Can i ask why my solution is \"Time Limit Exceeded\"? I uses binary search method.\n\nclass Solution:\n\n            \n       def guessNumber(self, n: int) -> int:\n        start = 1\n        end = n\n        while start + 1 < end:\n            mid = start + (end-start)//2\n            res = guess(mid)\n            if res<0:\n                end = mid\n            elif res>0:\n                start == mid\n        if guess(start)==0:\n            return start\n        if guess(end)==0:\n            return end"
                    }
                ]
            },
            {
                "id": 1795539,
                "content": [
                    {
                        "username": "tokeeffe9",
                        "content": "Am I right in saying the n can never be higher than pick? "
                    },
                    {
                        "username": "_dakshinraja_",
                        "content": "This is a guess game:\\n where a pre-defined function guess is already declared for us. which will guess the number for us.\\n when the function return 0 it means we\\'ve found the number,\\n when the function returns -1 it means we\\'ve guessed a value higher than the number,\\n when the function return 1 it means we\\'ve guessed a value lower than the number.\\n\\nNow using binary search we have to guess and find the number.\\n\\n"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem is in binary search concept?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "In a nutshell, you binary-search the number that I picked in the range of [1,n]. In action, let your min to be 1, and your max to be n. You begin with the midpoint (max+min)/2 rounded to the nearest integer. If the midpoint is greater than the number I picked, you know you should reduce your max to midpoint - 1, etc. This is the typical process of binary search."
                    },
                    {
                        "username": "stacksagar",
                        "content": "### Behind the scenes, guess() function:\\n \\n```\\nfunction guess(num) {\\n  let pick = 3;\\n  if (pick === num) return 0;\\n  else if (pick > num) return 1;\\n  else return -1;\\n}\\n```"
                    },
                    {
                        "username": "stacksagar",
                        "content": "Did not understand the question properly,\\nCan any one explain me shortly?"
                    },
                    {
                        "username": "le-chat",
                        "content": "Hello!\nI don't understand, why this solution doesn't work?\n\n    public int guessNumber(int n) {\n        if (n == 1)\n            return 1;\n        int pick = n / 2;\n        int sol = guess(pick);\n        int i = 3;\n        while (sol != 0) {\n            if (sol < 0)\n                pick = pick + n / i;\n            if (sol > 0)\n                pick = pick - n / i;\n            sol = guess(pick);\n            i++;\n        }\n        return pick;\n    }\n\nError: \"Time Limit Exceeded\""
                    },
                    {
                        "username": "code_voyager",
                        "content": "Simple java solution using Binary search\\npublic int guessNumber(int n) {\\n        int high=n;\\n        int low=1;\\n        while(high>=low){\\n            int mid=low+(high-low)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)<0)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "btw this is a google question.\n\nUnder the company tag it's showing Google."
                    },
                    {
                        "username": "qiushile",
                        "content": "error: cannot find symbol\\n            guess(mid);\\n            ^\\n  symbol:   method guess(int)\\n  location: class Solution"
                    },
                    {
                        "username": "gulfaraj18",
                        "content": "guess have a return value!"
                    },
                    {
                        "username": "fishbody0418",
                        "content": "Hello, I am new coding. Can i ask why my solution is \"Time Limit Exceeded\"? I uses binary search method.\n\nclass Solution:\n\n            \n       def guessNumber(self, n: int) -> int:\n        start = 1\n        end = n\n        while start + 1 < end:\n            mid = start + (end-start)//2\n            res = guess(mid)\n            if res<0:\n                end = mid\n            elif res>0:\n                start == mid\n        if guess(start)==0:\n            return start\n        if guess(end)==0:\n            return end"
                    }
                ]
            },
            {
                "id": 1791479,
                "content": [
                    {
                        "username": "tokeeffe9",
                        "content": "Am I right in saying the n can never be higher than pick? "
                    },
                    {
                        "username": "_dakshinraja_",
                        "content": "This is a guess game:\\n where a pre-defined function guess is already declared for us. which will guess the number for us.\\n when the function return 0 it means we\\'ve found the number,\\n when the function returns -1 it means we\\'ve guessed a value higher than the number,\\n when the function return 1 it means we\\'ve guessed a value lower than the number.\\n\\nNow using binary search we have to guess and find the number.\\n\\n"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem is in binary search concept?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "In a nutshell, you binary-search the number that I picked in the range of [1,n]. In action, let your min to be 1, and your max to be n. You begin with the midpoint (max+min)/2 rounded to the nearest integer. If the midpoint is greater than the number I picked, you know you should reduce your max to midpoint - 1, etc. This is the typical process of binary search."
                    },
                    {
                        "username": "stacksagar",
                        "content": "### Behind the scenes, guess() function:\\n \\n```\\nfunction guess(num) {\\n  let pick = 3;\\n  if (pick === num) return 0;\\n  else if (pick > num) return 1;\\n  else return -1;\\n}\\n```"
                    },
                    {
                        "username": "stacksagar",
                        "content": "Did not understand the question properly,\\nCan any one explain me shortly?"
                    },
                    {
                        "username": "le-chat",
                        "content": "Hello!\nI don't understand, why this solution doesn't work?\n\n    public int guessNumber(int n) {\n        if (n == 1)\n            return 1;\n        int pick = n / 2;\n        int sol = guess(pick);\n        int i = 3;\n        while (sol != 0) {\n            if (sol < 0)\n                pick = pick + n / i;\n            if (sol > 0)\n                pick = pick - n / i;\n            sol = guess(pick);\n            i++;\n        }\n        return pick;\n    }\n\nError: \"Time Limit Exceeded\""
                    },
                    {
                        "username": "code_voyager",
                        "content": "Simple java solution using Binary search\\npublic int guessNumber(int n) {\\n        int high=n;\\n        int low=1;\\n        while(high>=low){\\n            int mid=low+(high-low)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)<0)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "btw this is a google question.\n\nUnder the company tag it's showing Google."
                    },
                    {
                        "username": "qiushile",
                        "content": "error: cannot find symbol\\n            guess(mid);\\n            ^\\n  symbol:   method guess(int)\\n  location: class Solution"
                    },
                    {
                        "username": "gulfaraj18",
                        "content": "guess have a return value!"
                    },
                    {
                        "username": "fishbody0418",
                        "content": "Hello, I am new coding. Can i ask why my solution is \"Time Limit Exceeded\"? I uses binary search method.\n\nclass Solution:\n\n            \n       def guessNumber(self, n: int) -> int:\n        start = 1\n        end = n\n        while start + 1 < end:\n            mid = start + (end-start)//2\n            res = guess(mid)\n            if res<0:\n                end = mid\n            elif res>0:\n                start == mid\n        if guess(start)==0:\n            return start\n        if guess(end)==0:\n            return end"
                    }
                ]
            },
            {
                "id": 1787193,
                "content": [
                    {
                        "username": "tokeeffe9",
                        "content": "Am I right in saying the n can never be higher than pick? "
                    },
                    {
                        "username": "_dakshinraja_",
                        "content": "This is a guess game:\\n where a pre-defined function guess is already declared for us. which will guess the number for us.\\n when the function return 0 it means we\\'ve found the number,\\n when the function returns -1 it means we\\'ve guessed a value higher than the number,\\n when the function return 1 it means we\\'ve guessed a value lower than the number.\\n\\nNow using binary search we have to guess and find the number.\\n\\n"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem is in binary search concept?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "In a nutshell, you binary-search the number that I picked in the range of [1,n]. In action, let your min to be 1, and your max to be n. You begin with the midpoint (max+min)/2 rounded to the nearest integer. If the midpoint is greater than the number I picked, you know you should reduce your max to midpoint - 1, etc. This is the typical process of binary search."
                    },
                    {
                        "username": "stacksagar",
                        "content": "### Behind the scenes, guess() function:\\n \\n```\\nfunction guess(num) {\\n  let pick = 3;\\n  if (pick === num) return 0;\\n  else if (pick > num) return 1;\\n  else return -1;\\n}\\n```"
                    },
                    {
                        "username": "stacksagar",
                        "content": "Did not understand the question properly,\\nCan any one explain me shortly?"
                    },
                    {
                        "username": "le-chat",
                        "content": "Hello!\nI don't understand, why this solution doesn't work?\n\n    public int guessNumber(int n) {\n        if (n == 1)\n            return 1;\n        int pick = n / 2;\n        int sol = guess(pick);\n        int i = 3;\n        while (sol != 0) {\n            if (sol < 0)\n                pick = pick + n / i;\n            if (sol > 0)\n                pick = pick - n / i;\n            sol = guess(pick);\n            i++;\n        }\n        return pick;\n    }\n\nError: \"Time Limit Exceeded\""
                    },
                    {
                        "username": "code_voyager",
                        "content": "Simple java solution using Binary search\\npublic int guessNumber(int n) {\\n        int high=n;\\n        int low=1;\\n        while(high>=low){\\n            int mid=low+(high-low)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)<0)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "btw this is a google question.\n\nUnder the company tag it's showing Google."
                    },
                    {
                        "username": "qiushile",
                        "content": "error: cannot find symbol\\n            guess(mid);\\n            ^\\n  symbol:   method guess(int)\\n  location: class Solution"
                    },
                    {
                        "username": "gulfaraj18",
                        "content": "guess have a return value!"
                    },
                    {
                        "username": "fishbody0418",
                        "content": "Hello, I am new coding. Can i ask why my solution is \"Time Limit Exceeded\"? I uses binary search method.\n\nclass Solution:\n\n            \n       def guessNumber(self, n: int) -> int:\n        start = 1\n        end = n\n        while start + 1 < end:\n            mid = start + (end-start)//2\n            res = guess(mid)\n            if res<0:\n                end = mid\n            elif res>0:\n                start == mid\n        if guess(start)==0:\n            return start\n        if guess(end)==0:\n            return end"
                    }
                ]
            },
            {
                "id": 1775449,
                "content": [
                    {
                        "username": "tokeeffe9",
                        "content": "Am I right in saying the n can never be higher than pick? "
                    },
                    {
                        "username": "_dakshinraja_",
                        "content": "This is a guess game:\\n where a pre-defined function guess is already declared for us. which will guess the number for us.\\n when the function return 0 it means we\\'ve found the number,\\n when the function returns -1 it means we\\'ve guessed a value higher than the number,\\n when the function return 1 it means we\\'ve guessed a value lower than the number.\\n\\nNow using binary search we have to guess and find the number.\\n\\n"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem is in binary search concept?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "In a nutshell, you binary-search the number that I picked in the range of [1,n]. In action, let your min to be 1, and your max to be n. You begin with the midpoint (max+min)/2 rounded to the nearest integer. If the midpoint is greater than the number I picked, you know you should reduce your max to midpoint - 1, etc. This is the typical process of binary search."
                    },
                    {
                        "username": "stacksagar",
                        "content": "### Behind the scenes, guess() function:\\n \\n```\\nfunction guess(num) {\\n  let pick = 3;\\n  if (pick === num) return 0;\\n  else if (pick > num) return 1;\\n  else return -1;\\n}\\n```"
                    },
                    {
                        "username": "stacksagar",
                        "content": "Did not understand the question properly,\\nCan any one explain me shortly?"
                    },
                    {
                        "username": "le-chat",
                        "content": "Hello!\nI don't understand, why this solution doesn't work?\n\n    public int guessNumber(int n) {\n        if (n == 1)\n            return 1;\n        int pick = n / 2;\n        int sol = guess(pick);\n        int i = 3;\n        while (sol != 0) {\n            if (sol < 0)\n                pick = pick + n / i;\n            if (sol > 0)\n                pick = pick - n / i;\n            sol = guess(pick);\n            i++;\n        }\n        return pick;\n    }\n\nError: \"Time Limit Exceeded\""
                    },
                    {
                        "username": "code_voyager",
                        "content": "Simple java solution using Binary search\\npublic int guessNumber(int n) {\\n        int high=n;\\n        int low=1;\\n        while(high>=low){\\n            int mid=low+(high-low)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)<0)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "btw this is a google question.\n\nUnder the company tag it's showing Google."
                    },
                    {
                        "username": "qiushile",
                        "content": "error: cannot find symbol\\n            guess(mid);\\n            ^\\n  symbol:   method guess(int)\\n  location: class Solution"
                    },
                    {
                        "username": "gulfaraj18",
                        "content": "guess have a return value!"
                    },
                    {
                        "username": "fishbody0418",
                        "content": "Hello, I am new coding. Can i ask why my solution is \"Time Limit Exceeded\"? I uses binary search method.\n\nclass Solution:\n\n            \n       def guessNumber(self, n: int) -> int:\n        start = 1\n        end = n\n        while start + 1 < end:\n            mid = start + (end-start)//2\n            res = guess(mid)\n            if res<0:\n                end = mid\n            elif res>0:\n                start == mid\n        if guess(start)==0:\n            return start\n        if guess(end)==0:\n            return end"
                    }
                ]
            },
            {
                "id": 1774457,
                "content": [
                    {
                        "username": "tokeeffe9",
                        "content": "Am I right in saying the n can never be higher than pick? "
                    },
                    {
                        "username": "_dakshinraja_",
                        "content": "This is a guess game:\\n where a pre-defined function guess is already declared for us. which will guess the number for us.\\n when the function return 0 it means we\\'ve found the number,\\n when the function returns -1 it means we\\'ve guessed a value higher than the number,\\n when the function return 1 it means we\\'ve guessed a value lower than the number.\\n\\nNow using binary search we have to guess and find the number.\\n\\n"
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "How to find this problem is in binary search concept?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "In a nutshell, you binary-search the number that I picked in the range of [1,n]. In action, let your min to be 1, and your max to be n. You begin with the midpoint (max+min)/2 rounded to the nearest integer. If the midpoint is greater than the number I picked, you know you should reduce your max to midpoint - 1, etc. This is the typical process of binary search."
                    },
                    {
                        "username": "stacksagar",
                        "content": "### Behind the scenes, guess() function:\\n \\n```\\nfunction guess(num) {\\n  let pick = 3;\\n  if (pick === num) return 0;\\n  else if (pick > num) return 1;\\n  else return -1;\\n}\\n```"
                    },
                    {
                        "username": "stacksagar",
                        "content": "Did not understand the question properly,\\nCan any one explain me shortly?"
                    },
                    {
                        "username": "le-chat",
                        "content": "Hello!\nI don't understand, why this solution doesn't work?\n\n    public int guessNumber(int n) {\n        if (n == 1)\n            return 1;\n        int pick = n / 2;\n        int sol = guess(pick);\n        int i = 3;\n        while (sol != 0) {\n            if (sol < 0)\n                pick = pick + n / i;\n            if (sol > 0)\n                pick = pick - n / i;\n            sol = guess(pick);\n            i++;\n        }\n        return pick;\n    }\n\nError: \"Time Limit Exceeded\""
                    },
                    {
                        "username": "code_voyager",
                        "content": "Simple java solution using Binary search\\npublic int guessNumber(int n) {\\n        int high=n;\\n        int low=1;\\n        while(high>=low){\\n            int mid=low+(high-low)/2;\\n            if(guess(mid)==0)\\n                return mid;\\n            else if(guess(mid)<0)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "Jishnu_69",
                        "content": "btw this is a google question.\n\nUnder the company tag it's showing Google."
                    },
                    {
                        "username": "qiushile",
                        "content": "error: cannot find symbol\\n            guess(mid);\\n            ^\\n  symbol:   method guess(int)\\n  location: class Solution"
                    },
                    {
                        "username": "gulfaraj18",
                        "content": "guess have a return value!"
                    },
                    {
                        "username": "fishbody0418",
                        "content": "Hello, I am new coding. Can i ask why my solution is \"Time Limit Exceeded\"? I uses binary search method.\n\nclass Solution:\n\n            \n       def guessNumber(self, n: int) -> int:\n        start = 1\n        end = n\n        while start + 1 < end:\n            mid = start + (end-start)//2\n            res = guess(mid)\n            if res<0:\n                end = mid\n            elif res>0:\n                start == mid\n        if guess(start)==0:\n            return start\n        if guess(end)==0:\n            return end"
                    }
                ]
            },
            {
                "id": 1772357,
                "content": [
                    {
                        "username": "Lucky_Dev",
                        "content": "The problem is not described clearly"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "class Solution:\\n    def guessNumber(self, n: int) -> int:\\n        # return a num btw 1,..,n\\n        \\n        low = 1\\n        high = n\\n        \\n        while True:\\n            mid = low + (high - low) // 2\\n            myGuess = guess(mid)\\n            if myGuess == 1:\\n                low = mid + 1\\n            elif myGuess == -1:\\n                high = mid - 1\\n            else:\\n                return mid\\n"
                    },
                    {
                        "username": "Abhay0901",
                        "content": "i don\\'t understand this question properly. the problem should be more intuitive as this is a simple problem from binary search."
                    },
                    {
                        "username": "sharkzz",
                        "content": "\\n\\n\\n int guessNumber(int n) {\\n        int s=1;\\n        int e=n;\\n        while(s<=e)\\n        {\\n            int mid=(e+s)/2;\\n\\n            // int v=guess(mid);\\n            \\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid)==-1)\\n            {\\n                s=mid+1;\\n            }\\n            else \\n            {\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\nwhat is the mistake here first test case isn\\'t getting passed `your inline code...your inline code...`"
                    },
                    {
                        "username": "osalinasv",
                        "content": "The function `guess(int num`  might return the opposite of what you\\'d intuitively expect:\\n- It returns -1 when the number you guessed is **LARGER** than the expected answer, be careful to not think to guess lower because of the minus\\n\\nHint: Depending on your language\\'s max value for `n`\\'s data type you could run into an overflow while trying to choose a new guess number. Think of a way to avoid this, otherwise your range bounds could go to the negatives."
                    },
                    {
                        "username": "deleted_user",
                        "content": "i dont understand. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i am getting this type of error ,can someone please resolve it >>>>... \\n#this is the error for a test case 2126753390\\nand pick is 1702766719\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffcc09d1b58 (pc 0x000000343ae5 bp 0x7ffebbabd5d0 sp 0x7ffcc09d1b60 T0)\\n    #2 0x7f47de4db0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==ABORTING\\n\\n\\n\\n"
                    },
                    {
                        "username": "sakshi0806",
                        "content": "you should use int mid=start+(end-start)/2 if not using\\n"
                    },
                    {
                        "username": "nkb02",
                        "content": "question statement isn\\'t that clear. it is a simple question but they made it confusing "
                    },
                    {
                        "username": "noneal",
                        "content": "I think something is wrong with the website. My solution gets the right answer, but keeps running instead of returning. Where should I go to report this? EDIT: nevermind, found the feedback section"
                    }
                ]
            },
            {
                "id": 1756881,
                "content": [
                    {
                        "username": "Lucky_Dev",
                        "content": "The problem is not described clearly"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "class Solution:\\n    def guessNumber(self, n: int) -> int:\\n        # return a num btw 1,..,n\\n        \\n        low = 1\\n        high = n\\n        \\n        while True:\\n            mid = low + (high - low) // 2\\n            myGuess = guess(mid)\\n            if myGuess == 1:\\n                low = mid + 1\\n            elif myGuess == -1:\\n                high = mid - 1\\n            else:\\n                return mid\\n"
                    },
                    {
                        "username": "Abhay0901",
                        "content": "i don\\'t understand this question properly. the problem should be more intuitive as this is a simple problem from binary search."
                    },
                    {
                        "username": "sharkzz",
                        "content": "\\n\\n\\n int guessNumber(int n) {\\n        int s=1;\\n        int e=n;\\n        while(s<=e)\\n        {\\n            int mid=(e+s)/2;\\n\\n            // int v=guess(mid);\\n            \\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid)==-1)\\n            {\\n                s=mid+1;\\n            }\\n            else \\n            {\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\nwhat is the mistake here first test case isn\\'t getting passed `your inline code...your inline code...`"
                    },
                    {
                        "username": "osalinasv",
                        "content": "The function `guess(int num`  might return the opposite of what you\\'d intuitively expect:\\n- It returns -1 when the number you guessed is **LARGER** than the expected answer, be careful to not think to guess lower because of the minus\\n\\nHint: Depending on your language\\'s max value for `n`\\'s data type you could run into an overflow while trying to choose a new guess number. Think of a way to avoid this, otherwise your range bounds could go to the negatives."
                    },
                    {
                        "username": "deleted_user",
                        "content": "i dont understand. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i am getting this type of error ,can someone please resolve it >>>>... \\n#this is the error for a test case 2126753390\\nand pick is 1702766719\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffcc09d1b58 (pc 0x000000343ae5 bp 0x7ffebbabd5d0 sp 0x7ffcc09d1b60 T0)\\n    #2 0x7f47de4db0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==ABORTING\\n\\n\\n\\n"
                    },
                    {
                        "username": "sakshi0806",
                        "content": "you should use int mid=start+(end-start)/2 if not using\\n"
                    },
                    {
                        "username": "nkb02",
                        "content": "question statement isn\\'t that clear. it is a simple question but they made it confusing "
                    },
                    {
                        "username": "noneal",
                        "content": "I think something is wrong with the website. My solution gets the right answer, but keeps running instead of returning. Where should I go to report this? EDIT: nevermind, found the feedback section"
                    }
                ]
            },
            {
                "id": 1755841,
                "content": [
                    {
                        "username": "Lucky_Dev",
                        "content": "The problem is not described clearly"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "class Solution:\\n    def guessNumber(self, n: int) -> int:\\n        # return a num btw 1,..,n\\n        \\n        low = 1\\n        high = n\\n        \\n        while True:\\n            mid = low + (high - low) // 2\\n            myGuess = guess(mid)\\n            if myGuess == 1:\\n                low = mid + 1\\n            elif myGuess == -1:\\n                high = mid - 1\\n            else:\\n                return mid\\n"
                    },
                    {
                        "username": "Abhay0901",
                        "content": "i don\\'t understand this question properly. the problem should be more intuitive as this is a simple problem from binary search."
                    },
                    {
                        "username": "sharkzz",
                        "content": "\\n\\n\\n int guessNumber(int n) {\\n        int s=1;\\n        int e=n;\\n        while(s<=e)\\n        {\\n            int mid=(e+s)/2;\\n\\n            // int v=guess(mid);\\n            \\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid)==-1)\\n            {\\n                s=mid+1;\\n            }\\n            else \\n            {\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\nwhat is the mistake here first test case isn\\'t getting passed `your inline code...your inline code...`"
                    },
                    {
                        "username": "osalinasv",
                        "content": "The function `guess(int num`  might return the opposite of what you\\'d intuitively expect:\\n- It returns -1 when the number you guessed is **LARGER** than the expected answer, be careful to not think to guess lower because of the minus\\n\\nHint: Depending on your language\\'s max value for `n`\\'s data type you could run into an overflow while trying to choose a new guess number. Think of a way to avoid this, otherwise your range bounds could go to the negatives."
                    },
                    {
                        "username": "deleted_user",
                        "content": "i dont understand. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i am getting this type of error ,can someone please resolve it >>>>... \\n#this is the error for a test case 2126753390\\nand pick is 1702766719\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffcc09d1b58 (pc 0x000000343ae5 bp 0x7ffebbabd5d0 sp 0x7ffcc09d1b60 T0)\\n    #2 0x7f47de4db0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==ABORTING\\n\\n\\n\\n"
                    },
                    {
                        "username": "sakshi0806",
                        "content": "you should use int mid=start+(end-start)/2 if not using\\n"
                    },
                    {
                        "username": "nkb02",
                        "content": "question statement isn\\'t that clear. it is a simple question but they made it confusing "
                    },
                    {
                        "username": "noneal",
                        "content": "I think something is wrong with the website. My solution gets the right answer, but keeps running instead of returning. Where should I go to report this? EDIT: nevermind, found the feedback section"
                    }
                ]
            },
            {
                "id": 1753542,
                "content": [
                    {
                        "username": "Lucky_Dev",
                        "content": "The problem is not described clearly"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "class Solution:\\n    def guessNumber(self, n: int) -> int:\\n        # return a num btw 1,..,n\\n        \\n        low = 1\\n        high = n\\n        \\n        while True:\\n            mid = low + (high - low) // 2\\n            myGuess = guess(mid)\\n            if myGuess == 1:\\n                low = mid + 1\\n            elif myGuess == -1:\\n                high = mid - 1\\n            else:\\n                return mid\\n"
                    },
                    {
                        "username": "Abhay0901",
                        "content": "i don\\'t understand this question properly. the problem should be more intuitive as this is a simple problem from binary search."
                    },
                    {
                        "username": "sharkzz",
                        "content": "\\n\\n\\n int guessNumber(int n) {\\n        int s=1;\\n        int e=n;\\n        while(s<=e)\\n        {\\n            int mid=(e+s)/2;\\n\\n            // int v=guess(mid);\\n            \\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid)==-1)\\n            {\\n                s=mid+1;\\n            }\\n            else \\n            {\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\nwhat is the mistake here first test case isn\\'t getting passed `your inline code...your inline code...`"
                    },
                    {
                        "username": "osalinasv",
                        "content": "The function `guess(int num`  might return the opposite of what you\\'d intuitively expect:\\n- It returns -1 when the number you guessed is **LARGER** than the expected answer, be careful to not think to guess lower because of the minus\\n\\nHint: Depending on your language\\'s max value for `n`\\'s data type you could run into an overflow while trying to choose a new guess number. Think of a way to avoid this, otherwise your range bounds could go to the negatives."
                    },
                    {
                        "username": "deleted_user",
                        "content": "i dont understand. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i am getting this type of error ,can someone please resolve it >>>>... \\n#this is the error for a test case 2126753390\\nand pick is 1702766719\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffcc09d1b58 (pc 0x000000343ae5 bp 0x7ffebbabd5d0 sp 0x7ffcc09d1b60 T0)\\n    #2 0x7f47de4db0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==ABORTING\\n\\n\\n\\n"
                    },
                    {
                        "username": "sakshi0806",
                        "content": "you should use int mid=start+(end-start)/2 if not using\\n"
                    },
                    {
                        "username": "nkb02",
                        "content": "question statement isn\\'t that clear. it is a simple question but they made it confusing "
                    },
                    {
                        "username": "noneal",
                        "content": "I think something is wrong with the website. My solution gets the right answer, but keeps running instead of returning. Where should I go to report this? EDIT: nevermind, found the feedback section"
                    }
                ]
            },
            {
                "id": 1740669,
                "content": [
                    {
                        "username": "Lucky_Dev",
                        "content": "The problem is not described clearly"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "class Solution:\\n    def guessNumber(self, n: int) -> int:\\n        # return a num btw 1,..,n\\n        \\n        low = 1\\n        high = n\\n        \\n        while True:\\n            mid = low + (high - low) // 2\\n            myGuess = guess(mid)\\n            if myGuess == 1:\\n                low = mid + 1\\n            elif myGuess == -1:\\n                high = mid - 1\\n            else:\\n                return mid\\n"
                    },
                    {
                        "username": "Abhay0901",
                        "content": "i don\\'t understand this question properly. the problem should be more intuitive as this is a simple problem from binary search."
                    },
                    {
                        "username": "sharkzz",
                        "content": "\\n\\n\\n int guessNumber(int n) {\\n        int s=1;\\n        int e=n;\\n        while(s<=e)\\n        {\\n            int mid=(e+s)/2;\\n\\n            // int v=guess(mid);\\n            \\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid)==-1)\\n            {\\n                s=mid+1;\\n            }\\n            else \\n            {\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\nwhat is the mistake here first test case isn\\'t getting passed `your inline code...your inline code...`"
                    },
                    {
                        "username": "osalinasv",
                        "content": "The function `guess(int num`  might return the opposite of what you\\'d intuitively expect:\\n- It returns -1 when the number you guessed is **LARGER** than the expected answer, be careful to not think to guess lower because of the minus\\n\\nHint: Depending on your language\\'s max value for `n`\\'s data type you could run into an overflow while trying to choose a new guess number. Think of a way to avoid this, otherwise your range bounds could go to the negatives."
                    },
                    {
                        "username": "deleted_user",
                        "content": "i dont understand. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i am getting this type of error ,can someone please resolve it >>>>... \\n#this is the error for a test case 2126753390\\nand pick is 1702766719\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffcc09d1b58 (pc 0x000000343ae5 bp 0x7ffebbabd5d0 sp 0x7ffcc09d1b60 T0)\\n    #2 0x7f47de4db0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==ABORTING\\n\\n\\n\\n"
                    },
                    {
                        "username": "sakshi0806",
                        "content": "you should use int mid=start+(end-start)/2 if not using\\n"
                    },
                    {
                        "username": "nkb02",
                        "content": "question statement isn\\'t that clear. it is a simple question but they made it confusing "
                    },
                    {
                        "username": "noneal",
                        "content": "I think something is wrong with the website. My solution gets the right answer, but keeps running instead of returning. Where should I go to report this? EDIT: nevermind, found the feedback section"
                    }
                ]
            },
            {
                "id": 1733920,
                "content": [
                    {
                        "username": "Lucky_Dev",
                        "content": "The problem is not described clearly"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "class Solution:\\n    def guessNumber(self, n: int) -> int:\\n        # return a num btw 1,..,n\\n        \\n        low = 1\\n        high = n\\n        \\n        while True:\\n            mid = low + (high - low) // 2\\n            myGuess = guess(mid)\\n            if myGuess == 1:\\n                low = mid + 1\\n            elif myGuess == -1:\\n                high = mid - 1\\n            else:\\n                return mid\\n"
                    },
                    {
                        "username": "Abhay0901",
                        "content": "i don\\'t understand this question properly. the problem should be more intuitive as this is a simple problem from binary search."
                    },
                    {
                        "username": "sharkzz",
                        "content": "\\n\\n\\n int guessNumber(int n) {\\n        int s=1;\\n        int e=n;\\n        while(s<=e)\\n        {\\n            int mid=(e+s)/2;\\n\\n            // int v=guess(mid);\\n            \\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid)==-1)\\n            {\\n                s=mid+1;\\n            }\\n            else \\n            {\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\nwhat is the mistake here first test case isn\\'t getting passed `your inline code...your inline code...`"
                    },
                    {
                        "username": "osalinasv",
                        "content": "The function `guess(int num`  might return the opposite of what you\\'d intuitively expect:\\n- It returns -1 when the number you guessed is **LARGER** than the expected answer, be careful to not think to guess lower because of the minus\\n\\nHint: Depending on your language\\'s max value for `n`\\'s data type you could run into an overflow while trying to choose a new guess number. Think of a way to avoid this, otherwise your range bounds could go to the negatives."
                    },
                    {
                        "username": "deleted_user",
                        "content": "i dont understand. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i am getting this type of error ,can someone please resolve it >>>>... \\n#this is the error for a test case 2126753390\\nand pick is 1702766719\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffcc09d1b58 (pc 0x000000343ae5 bp 0x7ffebbabd5d0 sp 0x7ffcc09d1b60 T0)\\n    #2 0x7f47de4db0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==ABORTING\\n\\n\\n\\n"
                    },
                    {
                        "username": "sakshi0806",
                        "content": "you should use int mid=start+(end-start)/2 if not using\\n"
                    },
                    {
                        "username": "nkb02",
                        "content": "question statement isn\\'t that clear. it is a simple question but they made it confusing "
                    },
                    {
                        "username": "noneal",
                        "content": "I think something is wrong with the website. My solution gets the right answer, but keeps running instead of returning. Where should I go to report this? EDIT: nevermind, found the feedback section"
                    }
                ]
            },
            {
                "id": 1733566,
                "content": [
                    {
                        "username": "Lucky_Dev",
                        "content": "The problem is not described clearly"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "class Solution:\\n    def guessNumber(self, n: int) -> int:\\n        # return a num btw 1,..,n\\n        \\n        low = 1\\n        high = n\\n        \\n        while True:\\n            mid = low + (high - low) // 2\\n            myGuess = guess(mid)\\n            if myGuess == 1:\\n                low = mid + 1\\n            elif myGuess == -1:\\n                high = mid - 1\\n            else:\\n                return mid\\n"
                    },
                    {
                        "username": "Abhay0901",
                        "content": "i don\\'t understand this question properly. the problem should be more intuitive as this is a simple problem from binary search."
                    },
                    {
                        "username": "sharkzz",
                        "content": "\\n\\n\\n int guessNumber(int n) {\\n        int s=1;\\n        int e=n;\\n        while(s<=e)\\n        {\\n            int mid=(e+s)/2;\\n\\n            // int v=guess(mid);\\n            \\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid)==-1)\\n            {\\n                s=mid+1;\\n            }\\n            else \\n            {\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\nwhat is the mistake here first test case isn\\'t getting passed `your inline code...your inline code...`"
                    },
                    {
                        "username": "osalinasv",
                        "content": "The function `guess(int num`  might return the opposite of what you\\'d intuitively expect:\\n- It returns -1 when the number you guessed is **LARGER** than the expected answer, be careful to not think to guess lower because of the minus\\n\\nHint: Depending on your language\\'s max value for `n`\\'s data type you could run into an overflow while trying to choose a new guess number. Think of a way to avoid this, otherwise your range bounds could go to the negatives."
                    },
                    {
                        "username": "deleted_user",
                        "content": "i dont understand. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i am getting this type of error ,can someone please resolve it >>>>... \\n#this is the error for a test case 2126753390\\nand pick is 1702766719\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffcc09d1b58 (pc 0x000000343ae5 bp 0x7ffebbabd5d0 sp 0x7ffcc09d1b60 T0)\\n    #2 0x7f47de4db0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==ABORTING\\n\\n\\n\\n"
                    },
                    {
                        "username": "sakshi0806",
                        "content": "you should use int mid=start+(end-start)/2 if not using\\n"
                    },
                    {
                        "username": "nkb02",
                        "content": "question statement isn\\'t that clear. it is a simple question but they made it confusing "
                    },
                    {
                        "username": "noneal",
                        "content": "I think something is wrong with the website. My solution gets the right answer, but keeps running instead of returning. Where should I go to report this? EDIT: nevermind, found the feedback section"
                    }
                ]
            },
            {
                "id": 1725347,
                "content": [
                    {
                        "username": "Lucky_Dev",
                        "content": "The problem is not described clearly"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "class Solution:\\n    def guessNumber(self, n: int) -> int:\\n        # return a num btw 1,..,n\\n        \\n        low = 1\\n        high = n\\n        \\n        while True:\\n            mid = low + (high - low) // 2\\n            myGuess = guess(mid)\\n            if myGuess == 1:\\n                low = mid + 1\\n            elif myGuess == -1:\\n                high = mid - 1\\n            else:\\n                return mid\\n"
                    },
                    {
                        "username": "Abhay0901",
                        "content": "i don\\'t understand this question properly. the problem should be more intuitive as this is a simple problem from binary search."
                    },
                    {
                        "username": "sharkzz",
                        "content": "\\n\\n\\n int guessNumber(int n) {\\n        int s=1;\\n        int e=n;\\n        while(s<=e)\\n        {\\n            int mid=(e+s)/2;\\n\\n            // int v=guess(mid);\\n            \\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid)==-1)\\n            {\\n                s=mid+1;\\n            }\\n            else \\n            {\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\nwhat is the mistake here first test case isn\\'t getting passed `your inline code...your inline code...`"
                    },
                    {
                        "username": "osalinasv",
                        "content": "The function `guess(int num`  might return the opposite of what you\\'d intuitively expect:\\n- It returns -1 when the number you guessed is **LARGER** than the expected answer, be careful to not think to guess lower because of the minus\\n\\nHint: Depending on your language\\'s max value for `n`\\'s data type you could run into an overflow while trying to choose a new guess number. Think of a way to avoid this, otherwise your range bounds could go to the negatives."
                    },
                    {
                        "username": "deleted_user",
                        "content": "i dont understand. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i am getting this type of error ,can someone please resolve it >>>>... \\n#this is the error for a test case 2126753390\\nand pick is 1702766719\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffcc09d1b58 (pc 0x000000343ae5 bp 0x7ffebbabd5d0 sp 0x7ffcc09d1b60 T0)\\n    #2 0x7f47de4db0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==ABORTING\\n\\n\\n\\n"
                    },
                    {
                        "username": "sakshi0806",
                        "content": "you should use int mid=start+(end-start)/2 if not using\\n"
                    },
                    {
                        "username": "nkb02",
                        "content": "question statement isn\\'t that clear. it is a simple question but they made it confusing "
                    },
                    {
                        "username": "noneal",
                        "content": "I think something is wrong with the website. My solution gets the right answer, but keeps running instead of returning. Where should I go to report this? EDIT: nevermind, found the feedback section"
                    }
                ]
            },
            {
                "id": 1723370,
                "content": [
                    {
                        "username": "Lucky_Dev",
                        "content": "The problem is not described clearly"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "class Solution:\\n    def guessNumber(self, n: int) -> int:\\n        # return a num btw 1,..,n\\n        \\n        low = 1\\n        high = n\\n        \\n        while True:\\n            mid = low + (high - low) // 2\\n            myGuess = guess(mid)\\n            if myGuess == 1:\\n                low = mid + 1\\n            elif myGuess == -1:\\n                high = mid - 1\\n            else:\\n                return mid\\n"
                    },
                    {
                        "username": "Abhay0901",
                        "content": "i don\\'t understand this question properly. the problem should be more intuitive as this is a simple problem from binary search."
                    },
                    {
                        "username": "sharkzz",
                        "content": "\\n\\n\\n int guessNumber(int n) {\\n        int s=1;\\n        int e=n;\\n        while(s<=e)\\n        {\\n            int mid=(e+s)/2;\\n\\n            // int v=guess(mid);\\n            \\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid)==-1)\\n            {\\n                s=mid+1;\\n            }\\n            else \\n            {\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\nwhat is the mistake here first test case isn\\'t getting passed `your inline code...your inline code...`"
                    },
                    {
                        "username": "osalinasv",
                        "content": "The function `guess(int num`  might return the opposite of what you\\'d intuitively expect:\\n- It returns -1 when the number you guessed is **LARGER** than the expected answer, be careful to not think to guess lower because of the minus\\n\\nHint: Depending on your language\\'s max value for `n`\\'s data type you could run into an overflow while trying to choose a new guess number. Think of a way to avoid this, otherwise your range bounds could go to the negatives."
                    },
                    {
                        "username": "deleted_user",
                        "content": "i dont understand. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i am getting this type of error ,can someone please resolve it >>>>... \\n#this is the error for a test case 2126753390\\nand pick is 1702766719\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffcc09d1b58 (pc 0x000000343ae5 bp 0x7ffebbabd5d0 sp 0x7ffcc09d1b60 T0)\\n    #2 0x7f47de4db0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==ABORTING\\n\\n\\n\\n"
                    },
                    {
                        "username": "sakshi0806",
                        "content": "you should use int mid=start+(end-start)/2 if not using\\n"
                    },
                    {
                        "username": "nkb02",
                        "content": "question statement isn\\'t that clear. it is a simple question but they made it confusing "
                    },
                    {
                        "username": "noneal",
                        "content": "I think something is wrong with the website. My solution gets the right answer, but keeps running instead of returning. Where should I go to report this? EDIT: nevermind, found the feedback section"
                    }
                ]
            },
            {
                "id": 1697195,
                "content": [
                    {
                        "username": "Lucky_Dev",
                        "content": "The problem is not described clearly"
                    },
                    {
                        "username": "ADNAN56",
                        "content": "class Solution:\\n    def guessNumber(self, n: int) -> int:\\n        # return a num btw 1,..,n\\n        \\n        low = 1\\n        high = n\\n        \\n        while True:\\n            mid = low + (high - low) // 2\\n            myGuess = guess(mid)\\n            if myGuess == 1:\\n                low = mid + 1\\n            elif myGuess == -1:\\n                high = mid - 1\\n            else:\\n                return mid\\n"
                    },
                    {
                        "username": "Abhay0901",
                        "content": "i don\\'t understand this question properly. the problem should be more intuitive as this is a simple problem from binary search."
                    },
                    {
                        "username": "sharkzz",
                        "content": "\\n\\n\\n int guessNumber(int n) {\\n        int s=1;\\n        int e=n;\\n        while(s<=e)\\n        {\\n            int mid=(e+s)/2;\\n\\n            // int v=guess(mid);\\n            \\n            if(guess(mid)==0)\\n            {\\n                return mid;\\n            }\\n            else if(guess(mid)==-1)\\n            {\\n                s=mid+1;\\n            }\\n            else \\n            {\\n                e=mid-1;\\n            }\\n        }\\n        return -1;\\nwhat is the mistake here first test case isn\\'t getting passed `your inline code...your inline code...`"
                    },
                    {
                        "username": "osalinasv",
                        "content": "The function `guess(int num`  might return the opposite of what you\\'d intuitively expect:\\n- It returns -1 when the number you guessed is **LARGER** than the expected answer, be careful to not think to guess lower because of the minus\\n\\nHint: Depending on your language\\'s max value for `n`\\'s data type you could run into an overflow while trying to choose a new guess number. Think of a way to avoid this, otherwise your range bounds could go to the negatives."
                    },
                    {
                        "username": "deleted_user",
                        "content": "i dont understand. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Ultron03",
                        "content": "i am getting this type of error ,can someone please resolve it >>>>... \\n#this is the error for a test case 2126753390\\nand pick is 1702766719\\n\\n\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==34==ERROR: AddressSanitizer: stack-overflow on address 0x7ffcc09d1b58 (pc 0x000000343ae5 bp 0x7ffebbabd5d0 sp 0x7ffcc09d1b60 T0)\\n    #2 0x7f47de4db0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==ABORTING\\n\\n\\n\\n"
                    },
                    {
                        "username": "sakshi0806",
                        "content": "you should use int mid=start+(end-start)/2 if not using\\n"
                    },
                    {
                        "username": "nkb02",
                        "content": "question statement isn\\'t that clear. it is a simple question but they made it confusing "
                    },
                    {
                        "username": "noneal",
                        "content": "I think something is wrong with the website. My solution gets the right answer, but keeps running instead of returning. Where should I go to report this? EDIT: nevermind, found the feedback section"
                    }
                ]
            },
            {
                "id": 1686301,
                "content": [
                    {
                        "username": "akash102",
                        "content": "Can anyone help me explain the question with the help of first test case i.e., n = 10 and pick = 6 and o/p is 6. How???"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "n = 10 means you have a range from 1 to 10. And the computer chooses a number from this range. You have to guess it and then return it if it is the correct number that computer chose. Output of 6 means that the number computer chose was 6."
                    },
                    {
                        "username": "santosh_00",
                        "content": "Try thinking of binary search in an optimized way;\\nmid=l+(h-l)/2"
                    },
                    {
                        "username": "ercanK",
                        "content": "[@Saik77](/Saik77) \n`mid=(l+h)/2 ` may cause an overflow depending on the types and values of `l` and `h`. For example, if l = 1 and h = 2147483647, then `(l+h)/2 = -1073741824` (because in this case l + h != 2147483648 but it is -2147483648), whereas `l+(h-l)/2 = 1073741824`"
                    },
                    {
                        "username": "Saik77",
                        "content": "what is the difference between \\nmid=(l+h)/2 and mid=l+(h-l)/2;"
                    },
                    {
                        "username": "xsqkv",
                        "content": "The solution must be $$n(log$$ $$n)$$.\nInstead you will getting \"Time Limit Exceeded\" Error."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@Panda2397](/Panda2397) in case we use binary search\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "should be O(logn)? \\n"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Use binary search from 1 to n."
                    },
                    {
                        "username": "user0706D",
                        "content": "just a simple binary search will do the work!\\nif guess(mid)== -1(mid >key) then then your end becomes mid-1\\nif guess(mid)== 1(mid <key) then then your start becomes mid+ \\n"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "low=1 high=n\\nbinary search -\\nguess(mid)==0 return mid ,guess(mid)==1 low=mid+1 ,guess(mid)==-1 high=mid-1"
                    },
                    {
                        "username": "im3dabasia",
                        "content": "I was using `guessNumber` to make the API call. Don't the same mistake.\ninstead use `guess(num)`.\n"
                    },
                    {
                        "username": "euthiago",
                        "content": "Damn... I solved the solution for numbers between 1 and MAX_INTEGER haha\\nThey only want guesses from 1 to n..."
                    },
                    {
                        "username": "thakursaabhay",
                        "content": "A simple binary search program just don\\'t get confused with 1 and -1."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1686230,
                "content": [
                    {
                        "username": "akash102",
                        "content": "Can anyone help me explain the question with the help of first test case i.e., n = 10 and pick = 6 and o/p is 6. How???"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "n = 10 means you have a range from 1 to 10. And the computer chooses a number from this range. You have to guess it and then return it if it is the correct number that computer chose. Output of 6 means that the number computer chose was 6."
                    },
                    {
                        "username": "santosh_00",
                        "content": "Try thinking of binary search in an optimized way;\\nmid=l+(h-l)/2"
                    },
                    {
                        "username": "ercanK",
                        "content": "[@Saik77](/Saik77) \n`mid=(l+h)/2 ` may cause an overflow depending on the types and values of `l` and `h`. For example, if l = 1 and h = 2147483647, then `(l+h)/2 = -1073741824` (because in this case l + h != 2147483648 but it is -2147483648), whereas `l+(h-l)/2 = 1073741824`"
                    },
                    {
                        "username": "Saik77",
                        "content": "what is the difference between \\nmid=(l+h)/2 and mid=l+(h-l)/2;"
                    },
                    {
                        "username": "xsqkv",
                        "content": "The solution must be $$n(log$$ $$n)$$.\nInstead you will getting \"Time Limit Exceeded\" Error."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@Panda2397](/Panda2397) in case we use binary search\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "should be O(logn)? \\n"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Use binary search from 1 to n."
                    },
                    {
                        "username": "user0706D",
                        "content": "just a simple binary search will do the work!\\nif guess(mid)== -1(mid >key) then then your end becomes mid-1\\nif guess(mid)== 1(mid <key) then then your start becomes mid+ \\n"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "low=1 high=n\\nbinary search -\\nguess(mid)==0 return mid ,guess(mid)==1 low=mid+1 ,guess(mid)==-1 high=mid-1"
                    },
                    {
                        "username": "im3dabasia",
                        "content": "I was using `guessNumber` to make the API call. Don't the same mistake.\ninstead use `guess(num)`.\n"
                    },
                    {
                        "username": "euthiago",
                        "content": "Damn... I solved the solution for numbers between 1 and MAX_INTEGER haha\\nThey only want guesses from 1 to n..."
                    },
                    {
                        "username": "thakursaabhay",
                        "content": "A simple binary search program just don\\'t get confused with 1 and -1."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1686074,
                "content": [
                    {
                        "username": "akash102",
                        "content": "Can anyone help me explain the question with the help of first test case i.e., n = 10 and pick = 6 and o/p is 6. How???"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "n = 10 means you have a range from 1 to 10. And the computer chooses a number from this range. You have to guess it and then return it if it is the correct number that computer chose. Output of 6 means that the number computer chose was 6."
                    },
                    {
                        "username": "santosh_00",
                        "content": "Try thinking of binary search in an optimized way;\\nmid=l+(h-l)/2"
                    },
                    {
                        "username": "ercanK",
                        "content": "[@Saik77](/Saik77) \n`mid=(l+h)/2 ` may cause an overflow depending on the types and values of `l` and `h`. For example, if l = 1 and h = 2147483647, then `(l+h)/2 = -1073741824` (because in this case l + h != 2147483648 but it is -2147483648), whereas `l+(h-l)/2 = 1073741824`"
                    },
                    {
                        "username": "Saik77",
                        "content": "what is the difference between \\nmid=(l+h)/2 and mid=l+(h-l)/2;"
                    },
                    {
                        "username": "xsqkv",
                        "content": "The solution must be $$n(log$$ $$n)$$.\nInstead you will getting \"Time Limit Exceeded\" Error."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@Panda2397](/Panda2397) in case we use binary search\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "should be O(logn)? \\n"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Use binary search from 1 to n."
                    },
                    {
                        "username": "user0706D",
                        "content": "just a simple binary search will do the work!\\nif guess(mid)== -1(mid >key) then then your end becomes mid-1\\nif guess(mid)== 1(mid <key) then then your start becomes mid+ \\n"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "low=1 high=n\\nbinary search -\\nguess(mid)==0 return mid ,guess(mid)==1 low=mid+1 ,guess(mid)==-1 high=mid-1"
                    },
                    {
                        "username": "im3dabasia",
                        "content": "I was using `guessNumber` to make the API call. Don't the same mistake.\ninstead use `guess(num)`.\n"
                    },
                    {
                        "username": "euthiago",
                        "content": "Damn... I solved the solution for numbers between 1 and MAX_INTEGER haha\\nThey only want guesses from 1 to n..."
                    },
                    {
                        "username": "thakursaabhay",
                        "content": "A simple binary search program just don\\'t get confused with 1 and -1."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1685999,
                "content": [
                    {
                        "username": "akash102",
                        "content": "Can anyone help me explain the question with the help of first test case i.e., n = 10 and pick = 6 and o/p is 6. How???"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "n = 10 means you have a range from 1 to 10. And the computer chooses a number from this range. You have to guess it and then return it if it is the correct number that computer chose. Output of 6 means that the number computer chose was 6."
                    },
                    {
                        "username": "santosh_00",
                        "content": "Try thinking of binary search in an optimized way;\\nmid=l+(h-l)/2"
                    },
                    {
                        "username": "ercanK",
                        "content": "[@Saik77](/Saik77) \n`mid=(l+h)/2 ` may cause an overflow depending on the types and values of `l` and `h`. For example, if l = 1 and h = 2147483647, then `(l+h)/2 = -1073741824` (because in this case l + h != 2147483648 but it is -2147483648), whereas `l+(h-l)/2 = 1073741824`"
                    },
                    {
                        "username": "Saik77",
                        "content": "what is the difference between \\nmid=(l+h)/2 and mid=l+(h-l)/2;"
                    },
                    {
                        "username": "xsqkv",
                        "content": "The solution must be $$n(log$$ $$n)$$.\nInstead you will getting \"Time Limit Exceeded\" Error."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@Panda2397](/Panda2397) in case we use binary search\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "should be O(logn)? \\n"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Use binary search from 1 to n."
                    },
                    {
                        "username": "user0706D",
                        "content": "just a simple binary search will do the work!\\nif guess(mid)== -1(mid >key) then then your end becomes mid-1\\nif guess(mid)== 1(mid <key) then then your start becomes mid+ \\n"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "low=1 high=n\\nbinary search -\\nguess(mid)==0 return mid ,guess(mid)==1 low=mid+1 ,guess(mid)==-1 high=mid-1"
                    },
                    {
                        "username": "im3dabasia",
                        "content": "I was using `guessNumber` to make the API call. Don't the same mistake.\ninstead use `guess(num)`.\n"
                    },
                    {
                        "username": "euthiago",
                        "content": "Damn... I solved the solution for numbers between 1 and MAX_INTEGER haha\\nThey only want guesses from 1 to n..."
                    },
                    {
                        "username": "thakursaabhay",
                        "content": "A simple binary search program just don\\'t get confused with 1 and -1."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1685949,
                "content": [
                    {
                        "username": "akash102",
                        "content": "Can anyone help me explain the question with the help of first test case i.e., n = 10 and pick = 6 and o/p is 6. How???"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "n = 10 means you have a range from 1 to 10. And the computer chooses a number from this range. You have to guess it and then return it if it is the correct number that computer chose. Output of 6 means that the number computer chose was 6."
                    },
                    {
                        "username": "santosh_00",
                        "content": "Try thinking of binary search in an optimized way;\\nmid=l+(h-l)/2"
                    },
                    {
                        "username": "ercanK",
                        "content": "[@Saik77](/Saik77) \n`mid=(l+h)/2 ` may cause an overflow depending on the types and values of `l` and `h`. For example, if l = 1 and h = 2147483647, then `(l+h)/2 = -1073741824` (because in this case l + h != 2147483648 but it is -2147483648), whereas `l+(h-l)/2 = 1073741824`"
                    },
                    {
                        "username": "Saik77",
                        "content": "what is the difference between \\nmid=(l+h)/2 and mid=l+(h-l)/2;"
                    },
                    {
                        "username": "xsqkv",
                        "content": "The solution must be $$n(log$$ $$n)$$.\nInstead you will getting \"Time Limit Exceeded\" Error."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@Panda2397](/Panda2397) in case we use binary search\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "should be O(logn)? \\n"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Use binary search from 1 to n."
                    },
                    {
                        "username": "user0706D",
                        "content": "just a simple binary search will do the work!\\nif guess(mid)== -1(mid >key) then then your end becomes mid-1\\nif guess(mid)== 1(mid <key) then then your start becomes mid+ \\n"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "low=1 high=n\\nbinary search -\\nguess(mid)==0 return mid ,guess(mid)==1 low=mid+1 ,guess(mid)==-1 high=mid-1"
                    },
                    {
                        "username": "im3dabasia",
                        "content": "I was using `guessNumber` to make the API call. Don't the same mistake.\ninstead use `guess(num)`.\n"
                    },
                    {
                        "username": "euthiago",
                        "content": "Damn... I solved the solution for numbers between 1 and MAX_INTEGER haha\\nThey only want guesses from 1 to n..."
                    },
                    {
                        "username": "thakursaabhay",
                        "content": "A simple binary search program just don\\'t get confused with 1 and -1."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1685819,
                "content": [
                    {
                        "username": "akash102",
                        "content": "Can anyone help me explain the question with the help of first test case i.e., n = 10 and pick = 6 and o/p is 6. How???"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "n = 10 means you have a range from 1 to 10. And the computer chooses a number from this range. You have to guess it and then return it if it is the correct number that computer chose. Output of 6 means that the number computer chose was 6."
                    },
                    {
                        "username": "santosh_00",
                        "content": "Try thinking of binary search in an optimized way;\\nmid=l+(h-l)/2"
                    },
                    {
                        "username": "ercanK",
                        "content": "[@Saik77](/Saik77) \n`mid=(l+h)/2 ` may cause an overflow depending on the types and values of `l` and `h`. For example, if l = 1 and h = 2147483647, then `(l+h)/2 = -1073741824` (because in this case l + h != 2147483648 but it is -2147483648), whereas `l+(h-l)/2 = 1073741824`"
                    },
                    {
                        "username": "Saik77",
                        "content": "what is the difference between \\nmid=(l+h)/2 and mid=l+(h-l)/2;"
                    },
                    {
                        "username": "xsqkv",
                        "content": "The solution must be $$n(log$$ $$n)$$.\nInstead you will getting \"Time Limit Exceeded\" Error."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@Panda2397](/Panda2397) in case we use binary search\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "should be O(logn)? \\n"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Use binary search from 1 to n."
                    },
                    {
                        "username": "user0706D",
                        "content": "just a simple binary search will do the work!\\nif guess(mid)== -1(mid >key) then then your end becomes mid-1\\nif guess(mid)== 1(mid <key) then then your start becomes mid+ \\n"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "low=1 high=n\\nbinary search -\\nguess(mid)==0 return mid ,guess(mid)==1 low=mid+1 ,guess(mid)==-1 high=mid-1"
                    },
                    {
                        "username": "im3dabasia",
                        "content": "I was using `guessNumber` to make the API call. Don't the same mistake.\ninstead use `guess(num)`.\n"
                    },
                    {
                        "username": "euthiago",
                        "content": "Damn... I solved the solution for numbers between 1 and MAX_INTEGER haha\\nThey only want guesses from 1 to n..."
                    },
                    {
                        "username": "thakursaabhay",
                        "content": "A simple binary search program just don\\'t get confused with 1 and -1."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1685793,
                "content": [
                    {
                        "username": "akash102",
                        "content": "Can anyone help me explain the question with the help of first test case i.e., n = 10 and pick = 6 and o/p is 6. How???"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "n = 10 means you have a range from 1 to 10. And the computer chooses a number from this range. You have to guess it and then return it if it is the correct number that computer chose. Output of 6 means that the number computer chose was 6."
                    },
                    {
                        "username": "santosh_00",
                        "content": "Try thinking of binary search in an optimized way;\\nmid=l+(h-l)/2"
                    },
                    {
                        "username": "ercanK",
                        "content": "[@Saik77](/Saik77) \n`mid=(l+h)/2 ` may cause an overflow depending on the types and values of `l` and `h`. For example, if l = 1 and h = 2147483647, then `(l+h)/2 = -1073741824` (because in this case l + h != 2147483648 but it is -2147483648), whereas `l+(h-l)/2 = 1073741824`"
                    },
                    {
                        "username": "Saik77",
                        "content": "what is the difference between \\nmid=(l+h)/2 and mid=l+(h-l)/2;"
                    },
                    {
                        "username": "xsqkv",
                        "content": "The solution must be $$n(log$$ $$n)$$.\nInstead you will getting \"Time Limit Exceeded\" Error."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@Panda2397](/Panda2397) in case we use binary search\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "should be O(logn)? \\n"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Use binary search from 1 to n."
                    },
                    {
                        "username": "user0706D",
                        "content": "just a simple binary search will do the work!\\nif guess(mid)== -1(mid >key) then then your end becomes mid-1\\nif guess(mid)== 1(mid <key) then then your start becomes mid+ \\n"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "low=1 high=n\\nbinary search -\\nguess(mid)==0 return mid ,guess(mid)==1 low=mid+1 ,guess(mid)==-1 high=mid-1"
                    },
                    {
                        "username": "im3dabasia",
                        "content": "I was using `guessNumber` to make the API call. Don't the same mistake.\ninstead use `guess(num)`.\n"
                    },
                    {
                        "username": "euthiago",
                        "content": "Damn... I solved the solution for numbers between 1 and MAX_INTEGER haha\\nThey only want guesses from 1 to n..."
                    },
                    {
                        "username": "thakursaabhay",
                        "content": "A simple binary search program just don\\'t get confused with 1 and -1."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1685747,
                "content": [
                    {
                        "username": "akash102",
                        "content": "Can anyone help me explain the question with the help of first test case i.e., n = 10 and pick = 6 and o/p is 6. How???"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "n = 10 means you have a range from 1 to 10. And the computer chooses a number from this range. You have to guess it and then return it if it is the correct number that computer chose. Output of 6 means that the number computer chose was 6."
                    },
                    {
                        "username": "santosh_00",
                        "content": "Try thinking of binary search in an optimized way;\\nmid=l+(h-l)/2"
                    },
                    {
                        "username": "ercanK",
                        "content": "[@Saik77](/Saik77) \n`mid=(l+h)/2 ` may cause an overflow depending on the types and values of `l` and `h`. For example, if l = 1 and h = 2147483647, then `(l+h)/2 = -1073741824` (because in this case l + h != 2147483648 but it is -2147483648), whereas `l+(h-l)/2 = 1073741824`"
                    },
                    {
                        "username": "Saik77",
                        "content": "what is the difference between \\nmid=(l+h)/2 and mid=l+(h-l)/2;"
                    },
                    {
                        "username": "xsqkv",
                        "content": "The solution must be $$n(log$$ $$n)$$.\nInstead you will getting \"Time Limit Exceeded\" Error."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@Panda2397](/Panda2397) in case we use binary search\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "should be O(logn)? \\n"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Use binary search from 1 to n."
                    },
                    {
                        "username": "user0706D",
                        "content": "just a simple binary search will do the work!\\nif guess(mid)== -1(mid >key) then then your end becomes mid-1\\nif guess(mid)== 1(mid <key) then then your start becomes mid+ \\n"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "low=1 high=n\\nbinary search -\\nguess(mid)==0 return mid ,guess(mid)==1 low=mid+1 ,guess(mid)==-1 high=mid-1"
                    },
                    {
                        "username": "im3dabasia",
                        "content": "I was using `guessNumber` to make the API call. Don't the same mistake.\ninstead use `guess(num)`.\n"
                    },
                    {
                        "username": "euthiago",
                        "content": "Damn... I solved the solution for numbers between 1 and MAX_INTEGER haha\\nThey only want guesses from 1 to n..."
                    },
                    {
                        "username": "thakursaabhay",
                        "content": "A simple binary search program just don\\'t get confused with 1 and -1."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1685712,
                "content": [
                    {
                        "username": "akash102",
                        "content": "Can anyone help me explain the question with the help of first test case i.e., n = 10 and pick = 6 and o/p is 6. How???"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "n = 10 means you have a range from 1 to 10. And the computer chooses a number from this range. You have to guess it and then return it if it is the correct number that computer chose. Output of 6 means that the number computer chose was 6."
                    },
                    {
                        "username": "santosh_00",
                        "content": "Try thinking of binary search in an optimized way;\\nmid=l+(h-l)/2"
                    },
                    {
                        "username": "ercanK",
                        "content": "[@Saik77](/Saik77) \n`mid=(l+h)/2 ` may cause an overflow depending on the types and values of `l` and `h`. For example, if l = 1 and h = 2147483647, then `(l+h)/2 = -1073741824` (because in this case l + h != 2147483648 but it is -2147483648), whereas `l+(h-l)/2 = 1073741824`"
                    },
                    {
                        "username": "Saik77",
                        "content": "what is the difference between \\nmid=(l+h)/2 and mid=l+(h-l)/2;"
                    },
                    {
                        "username": "xsqkv",
                        "content": "The solution must be $$n(log$$ $$n)$$.\nInstead you will getting \"Time Limit Exceeded\" Error."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@Panda2397](/Panda2397) in case we use binary search\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "should be O(logn)? \\n"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Use binary search from 1 to n."
                    },
                    {
                        "username": "user0706D",
                        "content": "just a simple binary search will do the work!\\nif guess(mid)== -1(mid >key) then then your end becomes mid-1\\nif guess(mid)== 1(mid <key) then then your start becomes mid+ \\n"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "low=1 high=n\\nbinary search -\\nguess(mid)==0 return mid ,guess(mid)==1 low=mid+1 ,guess(mid)==-1 high=mid-1"
                    },
                    {
                        "username": "im3dabasia",
                        "content": "I was using `guessNumber` to make the API call. Don't the same mistake.\ninstead use `guess(num)`.\n"
                    },
                    {
                        "username": "euthiago",
                        "content": "Damn... I solved the solution for numbers between 1 and MAX_INTEGER haha\\nThey only want guesses from 1 to n..."
                    },
                    {
                        "username": "thakursaabhay",
                        "content": "A simple binary search program just don\\'t get confused with 1 and -1."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            },
            {
                "id": 1683464,
                "content": [
                    {
                        "username": "akash102",
                        "content": "Can anyone help me explain the question with the help of first test case i.e., n = 10 and pick = 6 and o/p is 6. How???"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "n = 10 means you have a range from 1 to 10. And the computer chooses a number from this range. You have to guess it and then return it if it is the correct number that computer chose. Output of 6 means that the number computer chose was 6."
                    },
                    {
                        "username": "santosh_00",
                        "content": "Try thinking of binary search in an optimized way;\\nmid=l+(h-l)/2"
                    },
                    {
                        "username": "ercanK",
                        "content": "[@Saik77](/Saik77) \n`mid=(l+h)/2 ` may cause an overflow depending on the types and values of `l` and `h`. For example, if l = 1 and h = 2147483647, then `(l+h)/2 = -1073741824` (because in this case l + h != 2147483648 but it is -2147483648), whereas `l+(h-l)/2 = 1073741824`"
                    },
                    {
                        "username": "Saik77",
                        "content": "what is the difference between \\nmid=(l+h)/2 and mid=l+(h-l)/2;"
                    },
                    {
                        "username": "xsqkv",
                        "content": "The solution must be $$n(log$$ $$n)$$.\nInstead you will getting \"Time Limit Exceeded\" Error."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "[@Panda2397](/Panda2397) in case we use binary search\\n"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "should be O(logn)? \\n"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Use binary search from 1 to n."
                    },
                    {
                        "username": "user0706D",
                        "content": "just a simple binary search will do the work!\\nif guess(mid)== -1(mid >key) then then your end becomes mid-1\\nif guess(mid)== 1(mid <key) then then your start becomes mid+ \\n"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "low=1 high=n\\nbinary search -\\nguess(mid)==0 return mid ,guess(mid)==1 low=mid+1 ,guess(mid)==-1 high=mid-1"
                    },
                    {
                        "username": "im3dabasia",
                        "content": "I was using `guessNumber` to make the API call. Don't the same mistake.\ninstead use `guess(num)`.\n"
                    },
                    {
                        "username": "euthiago",
                        "content": "Damn... I solved the solution for numbers between 1 and MAX_INTEGER haha\\nThey only want guesses from 1 to n..."
                    },
                    {
                        "username": "thakursaabhay",
                        "content": "A simple binary search program just don\\'t get confused with 1 and -1."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ SOLUTION EZ TO UNDERSTAND | CLEAN CODE | OPTIMAL\\uD83D\\uDCA5\\nhttps://leetcode.com/problems/guess-number-higher-or-lower/solutions/2248583/easiest-c-solution-ez-to-understand-clean-code-optimal/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Swim in Rising Water",
        "question_content": "<p>You are given an <code>n x n</code> integer matrix <code>grid</code> where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.</p>\n\n<p>The rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>\n\n<p>Return <em>the least time until you can reach the bottom right square </em><code>(n - 1, n - 1)</code><em> if you start at the top left square </em><code>(0, 0)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg\" style=\"width: 164px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,2],[1,3]]\n<strong>Output:</strong> 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg\" style=\"width: 404px; height: 405px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;&nbsp;n<sup>2</sup></code></li>\n\t<li>Each value <code>grid[i][j]</code> is <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 113770,
                "title": "c-python-priorityqueue",
                "content": "Python:\\n```\\n    def swimInWater(self, grid):\\n        N, pq, seen, res = len(grid), [(grid[0][0], 0, 0)], set([(0, 0)]), 0\\n        while True:\\n            T, x, y = heapq.heappop(pq)\\n            res = max(res, T)\\n            if x == y == N - 1:\\n                return res\\n            for i, j in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\\n                if 0 <= i < N and 0 <= j < N and (i, j) not in seen:\\n                    seen.add((i, j))\\n                    heapq.heappush(pq, (grid[i][j], i, j))\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n\\n    struct T {\\n        int t, x, y;\\n        T(int a, int b, int c) : t (a), x (b), y (c){}\\n        bool operator< (const T &d) const {return t > d.t;}\\n    };\\n\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int N = grid.size (), res = 0;\\n        priority_queue<T> pq;\\n        pq.push(T(grid[0][0], 0, 0));\\n        vector<vector<int>> seen(N, vector<int>(N, 0));\\n        seen[0][0] = 1;\\n        static int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n\\n        while (true) {\\n            auto p = pq.top ();\\n            pq.pop ();\\n            res = max(res, p.t);\\n            if (p.x == N - 1 && p.y == N - 1) return res;\\n            for (auto& d : dir) {\\n                int i = p.x + d[0], j = p.y + d[1];\\n                if (i >= 0 && i < N && j >= 0 && j < N && !seen[i][j]) {\\n                    seen[i][j] = 1;\\n                    pq.push (T(grid[i][j], i, j));\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    def swimInWater(self, grid):\\n        N, pq, seen, res = len(grid), [(grid[0][0], 0, 0)], set([(0, 0)]), 0\\n        while True:\\n            T, x, y = heapq.heappop(pq)\\n            res = max(res, T)\\n            if x == y == N - 1:\\n                return res\\n            for i, j in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\\n                if 0 <= i < N and 0 <= j < N and (i, j) not in seen:\\n                    seen.add((i, j))\\n                    heapq.heappush(pq, (grid[i][j], i, j))\\n```\n```\\nclass Solution {\\npublic:\\n\\n    struct T {\\n        int t, x, y;\\n        T(int a, int b, int c) : t (a), x (b), y (c){}\\n        bool operator< (const T &d) const {return t > d.t;}\\n    };\\n\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int N = grid.size (), res = 0;\\n        priority_queue<T> pq;\\n        pq.push(T(grid[0][0], 0, 0));\\n        vector<vector<int>> seen(N, vector<int>(N, 0));\\n        seen[0][0] = 1;\\n        static int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n\\n        while (true) {\\n            auto p = pq.top ();\\n            pq.pop ();\\n            res = max(res, p.t);\\n            if (p.x == N - 1 && p.y == N - 1) return res;\\n            for (auto& d : dir) {\\n                int i = p.x + d[0], j = p.y + d[1];\\n                if (i >= 0 && i < N && j >= 0 && j < N && !seen[i][j]) {\\n                    seen[i][j] = 1;\\n                    pq.push (T(grid[i][j], i, j));\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113758,
                "title": "c-two-solutions-binary-search-dfs-and-dijkstra-bfs-o-n-2logn-11ms",
                "content": "Binary Search + DFS, O(n^2logn), 14ms\\nBinary Search range [0, n*n-1] to find the minimum feasible water level. For each water level, verification using DFS or BFS is O(n^2). DFS is slightly faster in practice.\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int low = grid[0][0], hi = n*n-1;\\n        while (low < hi) {\\n            int mid = low + (hi-low)/2;\\n            if (valid(grid, mid)) \\n               hi = mid;\\n            else\\n               low = mid+1;\\n        }\\n        return low;\\n    }\\nprivate:\\n    bool valid(vector<vector<int>>& grid, int waterHeight) {\\n        int n = grid.size();\\n        vector<vector<int>> visited(n, vector<int>(n, 0));\\n        vector<int> dir({-1, 0, 1, 0, -1});\\n        return dfs(grid, visited, dir, waterHeight, 0, 0, n);\\n    }\\n    bool dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, vector<int>& dir, int waterHeight, int row, int col, int n) {\\n        visited[row][col] = 1;\\n        for (int i = 0; i < 4; ++i) {\\n            int r = row + dir[i], c = col + dir[i+1];\\n            if (r >= 0 && r < n && c >= 0 && c < n && visited[r][c] == 0 && grid[r][c] <= waterHeight) {\\n                if (r == n-1 && c == n-1) return true;\\n                if (dfs(grid, visited, dir, waterHeight, r, c, n)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nDijkstra using Priority Queue, O(n^2logn), 20 ms;\\nIn every step, find lowest water level to move forward, so using PQ rather than queue\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = max(grid[0][0], grid[n-1][n-1]);\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        vector<vector<int>> visited(n, vector<int>(n, 0));\\n        visited[0][0] = 1;\\n        vector<int> dir({-1, 0, 1, 0, -1});\\n        pq.push({ans, 0, 0});\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            pq.pop();\\n            ans = max(ans, cur[0]);\\n            for (int i = 0; i < 4; ++i) {\\n                int r = cur[1] + dir[i], c = cur[2] + dir[i+1];\\n                if (r >= 0 && r < n && c >= 0 && c < n && visited[r][c] == 0) {\\n                    if (r == n-1 && c == n-1) return ans;\\n                    pq.push({grid[r][c], r, c});\\n                    visited[r][c] = 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\nDijkstra with BFS optimization, O(n^2logn), 11 ms\\nSimilar to above solution, but we can use BFS, which is more efficient, to expand reachable region.\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = max(grid[0][0], grid[n-1][n-1]);\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        vector<vector<int>> visited(n, vector<int>(n, 0));\\n        visited[0][0] = 1;\\n        vector<int> dir({-1, 0, 1, 0, -1});\\n        pq.push({ans, 0, 0});\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            pq.pop();\\n            ans = max(ans, cur[0]);\\n            queue<pair<int, int>> myq;\\n            myq.push({cur[1], cur[2]});\\n            while (!myq.empty()) {\\n                auto p = myq.front();\\n                myq.pop();\\n                if (p.first == n-1 && p.second == n-1) return ans;\\n                for (int i = 0; i < 4; ++i) {\\n                    int r = p.first + dir[i], c = p.second + dir[i+1];\\n                    if (r >= 0 && r < n && c >= 0 && c < n && visited[r][c] == 0) {\\n                        visited[r][c] = 1;\\n                        if (grid[r][c] <= ans) \\n                           myq.push({r, c});\\n                        else\\n                           pq.push({grid[r][c], r, c});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int low = grid[0][0], hi = n*n-1;\\n        while (low < hi) {\\n            int mid = low + (hi-low)/2;\\n            if (valid(grid, mid)) \\n               hi = mid;\\n            else\\n               low = mid+1;\\n        }\\n        return low;\\n    }\\nprivate:\\n    bool valid(vector<vector<int>>& grid, int waterHeight) {\\n        int n = grid.size();\\n        vector<vector<int>> visited(n, vector<int>(n, 0));\\n        vector<int> dir({-1, 0, 1, 0, -1});\\n        return dfs(grid, visited, dir, waterHeight, 0, 0, n);\\n    }\\n    bool dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, vector<int>& dir, int waterHeight, int row, int col, int n) {\\n        visited[row][col] = 1;\\n        for (int i = 0; i < 4; ++i) {\\n            int r = row + dir[i], c = col + dir[i+1];\\n            if (r >= 0 && r < n && c >= 0 && c < n && visited[r][c] == 0 && grid[r][c] <= waterHeight) {\\n                if (r == n-1 && c == n-1) return true;\\n                if (dfs(grid, visited, dir, waterHeight, r, c, n)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = max(grid[0][0], grid[n-1][n-1]);\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        vector<vector<int>> visited(n, vector<int>(n, 0));\\n        visited[0][0] = 1;\\n        vector<int> dir({-1, 0, 1, 0, -1});\\n        pq.push({ans, 0, 0});\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            pq.pop();\\n            ans = max(ans, cur[0]);\\n            for (int i = 0; i < 4; ++i) {\\n                int r = cur[1] + dir[i], c = cur[2] + dir[i+1];\\n                if (r >= 0 && r < n && c >= 0 && c < n && visited[r][c] == 0) {\\n                    if (r == n-1 && c == n-1) return ans;\\n                    pq.push({grid[r][c], r, c});\\n                    visited[r][c] = 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = max(grid[0][0], grid[n-1][n-1]);\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        vector<vector<int>> visited(n, vector<int>(n, 0));\\n        visited[0][0] = 1;\\n        vector<int> dir({-1, 0, 1, 0, -1});\\n        pq.push({ans, 0, 0});\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            pq.pop();\\n            ans = max(ans, cur[0]);\\n            queue<pair<int, int>> myq;\\n            myq.push({cur[1], cur[2]});\\n            while (!myq.empty()) {\\n                auto p = myq.front();\\n                myq.pop();\\n                if (p.first == n-1 && p.second == n-1) return ans;\\n                for (int i = 0; i < 4; ++i) {\\n                    int r = p.first + dir[i], c = p.second + dir[i+1];\\n                    if (r >= 0 && r < n && c >= 0 && c < n && visited[r][c] == 0) {\\n                        visited[r][c] = 1;\\n                        if (grid[r][c] <= ans) \\n                           myq.push({r, c});\\n                        else\\n                           pq.push({grid[r][c], r, c});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285099,
                "title": "easy-solution-w-explanation-optimization-from-brute-force-to-binary-search-beats-100",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe can observe that the problem basically asks us to **find a path such that the maximum waterLevel *`w_lvl`* (value of a cell) of some intermediate cell of that path is minimized**. \\n\\nWe can start with the brute force approach and explore all the possible paths to reach the end of the *`grid`*. The path which minimizes the maximum value of some cell in a path will be chosen and that water level - *`w_lvl`* will be our answer.\\n\\n```\\nint n;\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tvector<vector<int> >vis(n, vector<int>(n));\\n\\treturn solve(grid, vis, 0, 0);\\n}\\nint solve(vector<vector<int>>& grid, vector<vector<int>> vis, int i, int j, int w_lvl = 0) {\\n\\tif(i < 0 || j < 0 || i >= n || j >= n || vis[i][j]) return 10000;  // out-of-bounds / already visited\\n\\tif(i == n - 1 && j == n - 1) return max(w_lvl, grid[i][j]);\\n\\tvis[i][j] = true;            // mark as visited so we don\\'t keep visiting back-and-forth\\n\\tw_lvl = max(w_lvl, grid[i][j]);  // update max intermediate value for current path\\n\\t// explore all 4 possible options from current cell and choose the path with minimum w_lvl -\\n\\treturn min({solve(grid, vis, i + 1, j, w_lvl), solve(grid, vis, i - 1, j, w_lvl), solve(grid, vis, i, j + 1, w_lvl), solve(grid, vis, i, j - 1, w_lvl)});\\n}\\n```\\n\\n<br />\\n\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u274C Brute-Force Variant -II (slightly optimized)</b></summary>\\n\\nSince the brute-force approach was just to establish a starting approach, I kept it simple and just passed the *`vis`* matrix in the above approach by value which makes copies of it for each recursive call. This prevents the need to mark a cell as un-visited for the next recursive call. \\n\\nBut making copies can be expensive. So here\\'s a slight optimization over it by passing it by reference. It still TLEs though...\\n\\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tvector<vector<int> >vis(n, vector<int>(n));\\n\\treturn solve(grid, vis, 0, 0);\\n}\\nint solve(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int w_lvl = 0) {\\n\\tif(i == n - 1 && j == n - 1) return max(w_lvl, grid[i][j]);\\n\\tvis[i][j] = true;            \\n\\tw_lvl = max(w_lvl, grid[i][j]);  \\n    int ans = 10000;\\n\\tfor(int k = 0; k < 4; k++) {\\n        int new_i = i + moves[k][0], new_j = j + moves[k][1];\\n        if(checkValid(new_i, new_j, vis)) {\\n            ans = min(ans, solve(grid, vis, new_i, new_j, w_lvl));    \\n            vis[new_i][new_j] = false;\\n        }\\n    }\\n    return ans;\\n}\\nbool checkValid (int i, int j, vector<vector<int>>& vis) {\\n    return !(i < 0 || j < 0 || i >= n || j >= n || vis[i][j]);\\n}\\n```\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** <b><code>O(4<sup>n<sup>2</sup></sup>)</code></b>, for each cell of the grid, we have 4 choices. So, in the worst case we may need <code>4`*`4`*`4`*`...n<sup>2</sup>times</code>\\n\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b> for the optimzed verison, <b><code>O(n<sup>4</sup>)</code></b> for the first version since copy for *`vis`* is made for each recursive call\\n\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Search lowest valid water-level)***\\n\\nExploring all the possible path options is very time-consuming. **Instead of exploring all the available paths** and then choosing the path with lowest maximum water level - *`w_lvl`* , **we can instead set an upper-limit to *`w_lvl`*  ourselves**, starting from 1 till `n*n-1`. The lowest water level required to reach the end will be our answer.\\n\\nHere, instead of exploring all paths, we have limited ourselves to only exploring a single path which has maximum intermediate cell value = *`w_lvl`* and returning as soon as we find the first path that takes us to the end. Thus, we have limited our search space to a great extent.\\n\\n\\nAnother small optimization is to start checking directly from max of `max( grid[0][0], grid[n-1][n-1], 2*(n-1) )` instead of `w_lvl=1` (Credits to @ud240 & @nicolattu). That\\'s because every path will contain *`grid[0][0]`* and *`grid[n-1][n-1]`*, and `2*(n-1)` because grid elements are always a permutation of `0...n*n-1` and thus there will always be a cell with `value >= 2*(n-1)`  in every path.\\n\\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n    n = size(grid);        \\n    vector<vector<int>>vis(n, vector<int>(n));\\n\\tint minReq = max({ 2*(n-1), grid[0][0], grid[n-1][n-1] });\\n    for(int w_lvl = minReq; w_lvl < n*n; w_lvl++) {\\n        if(dfs(grid, vis, 0, 0, w_lvl)) return w_lvl;\\n        for_each(begin(vis), end(vis), [](auto& v){fill(begin(v), end(v), 0);});  // reset the vis array back to not-visited\\n    }        \\n    return n*n;\\n}\\n\\nbool dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int w_lvl) {\\n    if(i < 0 || j < 0 || i >= n || j >= n || vis[i][j] || grid[i][j] > w_lvl) return false; // out-of-bound / already visited / cell value > max w_lvl allowed\\n    if(i == n - 1 && j == n - 1) return true;\\n    vis[i][j] = true;\\n    for(int k = 0; k < 4; k++) // search all available option till any of it leads us to the end\\n        if(dfs(grid, vis, i + moves[k][0], j + moves[k][1], w_lvl)) return true;\\n    return false;\\n}\\n```\\n\\n***Time Complexity :*** <b><code>O(n<sup>4</sup>)</code></b>, we are exploring all water-level values from `1` to `n*n`. For each water-level *`MAX`*, we call `dfs()` having <code>O(n<sup>2</sup>)</code> time complexity in the worst case. Thus, overall time complexity becomes <code>O(n*n) * O(n<sup>2</sup>) = O(n<sup>4</sup>)</code>\\n\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Binary-Search)***\\n\\nInstead of searching linearly as we did in the above approach, we can use binary search to find the lowest valid water-level. Our search space is sorted and it the range `[1...n*n-1]` and thus binary search can be applied here.\\n\\nIn previous approach, for the worst-case scenario we would have called `dfs()` for `n*n` times. \\nBinary search will reduce worst-case number of calls required to <code>O(logn<sup>2</sup>) = O(logn)</code>.\\n\\nAlso, I have replaced the *`vis`* below with a boolean C-style array (for faster runtime) of `50x50` which is the max *`grid`* dimensions. Since the constraints are small, I have opted for fixed size declaration intead dynamic allocation, the syntax of which is slightly messy.\\n\\n\\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tint l = max({ 2*(n-1), grid[0][0], grid[n-1][n-1] }), r = n*n-1, mid;\\n\\tbool vis[50][50]{};\\n\\twhile(l <= r) {            \\n\\t\\tmid = (l + r) / 2;\\n\\t\\tif(solve(grid, vis, 0, 0, mid)) r = mid - 1;  // we are able to reach end with MAX=mid   => try lower to minimze it\\n\\t\\telse l = mid + 1;                             // we fail to reach the end with MAX=mid   => try higher so we can reach the end\\n\\t\\tmemset(vis, false, sizeof vis);               // reset vis back to all false\\n\\t}\\n\\treturn l;\\n}\\n\\nbool solve(vector<vector<int>>& grid, bool vis[][50], int i, int j, int w_lvl) {\\n\\tif(i < 0 || j < 0 || i >= n || j >= n || vis[i][j] || grid[i][j] > w_lvl) return false;\\n\\tif(i == n - 1 && j == n - 1) return true;\\n\\tvis[i][j] = true;\\n\\tfor(int k = 0; k < 4; k++) \\n\\t\\tif(solve(grid, vis, i + moves[k][0], j + moves[k][1], w_lvl)) return true;\\n\\treturn false;\\n}\\n```\\n\\n\\n***Time Complexity :*** <b><code>O(n<sup>2</sup>logn)</code></b>, <code>O(n<sup>2</sup>)</code> for dfs call and `O(logn)` for binary search over `1...n*n`.\\n\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src =https://assets.leetcode.com/users/images/ccc9315f-7e1e-4679-b242-2112fcd74cd9_1624194042.2626312.png /></td></tr></table>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint n;\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tvector<vector<int> >vis(n, vector<int>(n));\\n\\treturn solve(grid, vis, 0, 0);\\n}\\nint solve(vector<vector<int>>& grid, vector<vector<int>> vis, int i, int j, int w_lvl = 0) {\\n\\tif(i < 0 || j < 0 || i >= n || j >= n || vis[i][j]) return 10000;  // out-of-bounds / already visited\\n\\tif(i == n - 1 && j == n - 1) return max(w_lvl, grid[i][j]);\\n\\tvis[i][j] = true;            // mark as visited so we don\\'t keep visiting back-and-forth\\n\\tw_lvl = max(w_lvl, grid[i][j]);  // update max intermediate value for current path\\n\\t// explore all 4 possible options from current cell and choose the path with minimum w_lvl -\\n\\treturn min({solve(grid, vis, i + 1, j, w_lvl), solve(grid, vis, i - 1, j, w_lvl), solve(grid, vis, i, j + 1, w_lvl), solve(grid, vis, i, j - 1, w_lvl)});\\n}\\n```\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tvector<vector<int> >vis(n, vector<int>(n));\\n\\treturn solve(grid, vis, 0, 0);\\n}\\nint solve(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int w_lvl = 0) {\\n\\tif(i == n - 1 && j == n - 1) return max(w_lvl, grid[i][j]);\\n\\tvis[i][j] = true;            \\n\\tw_lvl = max(w_lvl, grid[i][j]);  \\n    int ans = 10000;\\n\\tfor(int k = 0; k < 4; k++) {\\n        int new_i = i + moves[k][0], new_j = j + moves[k][1];\\n        if(checkValid(new_i, new_j, vis)) {\\n            ans = min(ans, solve(grid, vis, new_i, new_j, w_lvl));    \\n            vis[new_i][new_j] = false;\\n        }\\n    }\\n    return ans;\\n}\\nbool checkValid (int i, int j, vector<vector<int>>& vis) {\\n    return !(i < 0 || j < 0 || i >= n || j >= n || vis[i][j]);\\n}\\n```\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n    n = size(grid);        \\n    vector<vector<int>>vis(n, vector<int>(n));\\n\\tint minReq = max({ 2*(n-1), grid[0][0], grid[n-1][n-1] });\\n    for(int w_lvl = minReq; w_lvl < n*n; w_lvl++) {\\n        if(dfs(grid, vis, 0, 0, w_lvl)) return w_lvl;\\n        for_each(begin(vis), end(vis), [](auto& v){fill(begin(v), end(v), 0);});  // reset the vis array back to not-visited\\n    }        \\n    return n*n;\\n}\\n\\nbool dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int w_lvl) {\\n    if(i < 0 || j < 0 || i >= n || j >= n || vis[i][j] || grid[i][j] > w_lvl) return false; // out-of-bound / already visited / cell value > max w_lvl allowed\\n    if(i == n - 1 && j == n - 1) return true;\\n    vis[i][j] = true;\\n    for(int k = 0; k < 4; k++) // search all available option till any of it leads us to the end\\n        if(dfs(grid, vis, i + moves[k][0], j + moves[k][1], w_lvl)) return true;\\n    return false;\\n}\\n```\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tint l = max({ 2*(n-1), grid[0][0], grid[n-1][n-1] }), r = n*n-1, mid;\\n\\tbool vis[50][50]{};\\n\\twhile(l <= r) {            \\n\\t\\tmid = (l + r) / 2;\\n\\t\\tif(solve(grid, vis, 0, 0, mid)) r = mid - 1;  // we are able to reach end with MAX=mid   => try lower to minimze it\\n\\t\\telse l = mid + 1;                             // we fail to reach the end with MAX=mid   => try higher so we can reach the end\\n\\t\\tmemset(vis, false, sizeof vis);               // reset vis back to all false\\n\\t}\\n\\treturn l;\\n}\\n\\nbool solve(vector<vector<int>>& grid, bool vis[][50], int i, int j, int w_lvl) {\\n\\tif(i < 0 || j < 0 || i >= n || j >= n || vis[i][j] || grid[i][j] > w_lvl) return false;\\n\\tif(i == n - 1 && j == n - 1) return true;\\n\\tvis[i][j] = true;\\n\\tfor(int k = 0; k < 4; k++) \\n\\t\\tif(solve(grid, vis, i + moves[k][0], j + moves[k][1], w_lvl)) return true;\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 118204,
                "title": "java-dfs-and-union-find",
                "content": "DFS:\\n```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int time = 0;\\n        int N = grid.length;\\n        Set<Integer> visited = new HashSet<>();\\n        while(!visited.contains(N*N-1)) {\\n            visited.clear();\\n            dfs(grid, 0, 0, time, visited);\\n            time++;\\n        }\\n        return time - 1;\\n    }\\n    int[][] dirs = {{-1,0},{1,0},{0,1},{0,-1}};\\n    private void dfs(int[][] grid, int i, int j, int time, Set<Integer> visited) {\\n        if (i < 0 || i > grid.length - 1 || j < 0 || j > grid[0].length - 1 || grid[i][j] > time || visited.contains(i*grid.length+j)) return;\\n        visited.add(i*grid.length+j);\\n        for (int[] dir : dirs) {\\n            dfs(grid, i+dir[0], j+dir[1], time, visited);\\n        }\\n    }\\n}\\n```\\nUnion Find:\\n```\\nclass Solution {\\n    class UF {\\n        int[] id;\\n        public UF(int N) {\\n            id = new int[N];\\n            for (int i = 0; i < N; i++) {\\n                id[i] = i;\\n            }\\n        }\\n        public int root(int i) {\\n            while (i != id[i]) {\\n                id[i] = id[id[i]];\\n                i = id[i];\\n            }\\n            return i;\\n        }\\n        public boolean isConnected(int p, int q) {\\n            return root(p)==root(q);\\n        }\\n        public void union(int p, int q) {\\n            if (isConnected(p, q)) return;\\n            id[root(p)] = root(q);\\n        }\\n    }\\n    public int swimInWater(int[][] grid) {\\n        int N = grid.length;\\n        UF uf = new UF(N*N);\\n        int time = 0;\\n        while(!uf.isConnected(0, N*N-1)) {\\n            for (int i = 0; i < N; i++) {\\n                for (int j = 0; j < N; j++) {\\n                    if (grid[i][j] > time) continue;\\n                    if (i < N-1 && grid[i+1][j]<=time) uf.union(i*N+j, i*N+j+N);\\n                    if (j < N-1 && grid[i][j+1]<=time) uf.union(i*N+j, i*N+j+1);\\n                }\\n            }\\n            time++;\\n        }\\n        return time - 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int time = 0;\\n        int N = grid.length;\\n        Set<Integer> visited = new HashSet<>();\\n        while(!visited.contains(N*N-1)) {\\n            visited.clear();\\n            dfs(grid, 0, 0, time, visited);\\n            time++;\\n        }\\n        return time - 1;\\n    }\\n    int[][] dirs = {{-1,0},{1,0},{0,1},{0,-1}};\\n    private void dfs(int[][] grid, int i, int j, int time, Set<Integer> visited) {\\n        if (i < 0 || i > grid.length - 1 || j < 0 || j > grid[0].length - 1 || grid[i][j] > time || visited.contains(i*grid.length+j)) return;\\n        visited.add(i*grid.length+j);\\n        for (int[] dir : dirs) {\\n            dfs(grid, i+dir[0], j+dir[1], time, visited);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    class UF {\\n        int[] id;\\n        public UF(int N) {\\n            id = new int[N];\\n            for (int i = 0; i < N; i++) {\\n                id[i] = i;\\n            }\\n        }\\n        public int root(int i) {\\n            while (i != id[i]) {\\n                id[i] = id[id[i]];\\n                i = id[i];\\n            }\\n            return i;\\n        }\\n        public boolean isConnected(int p, int q) {\\n            return root(p)==root(q);\\n        }\\n        public void union(int p, int q) {\\n            if (isConnected(p, q)) return;\\n            id[root(p)] = root(q);\\n        }\\n    }\\n    public int swimInWater(int[][] grid) {\\n        int N = grid.length;\\n        UF uf = new UF(N*N);\\n        int time = 0;\\n        while(!uf.isConnected(0, N*N-1)) {\\n            for (int i = 0; i < N; i++) {\\n                for (int j = 0; j < N; j++) {\\n                    if (grid[i][j] > time) continue;\\n                    if (i < N-1 && grid[i+1][j]<=time) uf.union(i*N+j, i*N+j+N);\\n                    if (j < N-1 && grid[i][j+1]<=time) uf.union(i*N+j, i*N+j+1);\\n                }\\n            }\\n            time++;\\n        }\\n        return time - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113765,
                "title": "python-c-binary-search",
                "content": "I split this question to 2 questions:\\n1. one part of sub function ```reachable(int T)``` with ```T``` given\\n2. another part of binary search, which simply check if ```grid[N-1][N-1]``` is reachable.\\n\\n\\n\\nPython:\\n```\\ndef swimInWater(self, grid):\\n        N = len(grid)\\n        l, r = grid[0][0], N * N - 1\\n\\n        def reachable(T):\\n            bfs = [(0, 0)]\\n            seen = set((0, 0))\\n            for x, y in bfs:\\n                if grid[x][y] <= T:\\n                    if x == y == N - 1: return True\\n                    for i, j in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\\n                        if 0 <= x + i < N and 0 <= y + j < N and (x + i, y + j) not in seen:\\n                            seen.add((x + i, y + j))\\n                            bfs.append((x + i, y + j))\\n            return False\\n\\n        while l < r:\\n            m = (l + r) / 2\\n            if reachable(m): r = m\\n            else: l = m + 1\\n        return r\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int N = grid.size(), l = grid[0][0], r = N * N - 1, m;\\n        while (l < r) {\\n            m = (l + r) / 2;\\n            if (reachable(m, grid, N)) r = m;\\n            else l = m + 1;\\n        }\\n        return r;\\n    }\\n\\n    int reachable(int T, vector<vector<int>>& grid, int N) {\\n        queue<pair<int, int>> bfs;\\n        vector<vector<int>> seen(N, vector<int>(N, 0));\\n        static int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n        bfs.emplace(0, 0);\\n        seen[0][0] = 1;\\n        while (bfs.size()) {\\n            int x = bfs.front().first, y = bfs.front().second;\\n            bfs.pop();\\n            if (grid[x][y] <= T) {\\n                if (x == N - 1 && y == N - 1) return true;\\n                for (auto& d : dir) {\\n                    int i = x + d[0], j = y + d[1];\\n                    if (i >= 0 && i < N && j >= 0 && j < N && !seen[i][j]) {\\n                        seen[i][j] = 1;\\n                        bfs.emplace(i, j);\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```reachable(int T)```\n```T```\n```grid[N-1][N-1]```\n```\\ndef swimInWater(self, grid):\\n        N = len(grid)\\n        l, r = grid[0][0], N * N - 1\\n\\n        def reachable(T):\\n            bfs = [(0, 0)]\\n            seen = set((0, 0))\\n            for x, y in bfs:\\n                if grid[x][y] <= T:\\n                    if x == y == N - 1: return True\\n                    for i, j in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\\n                        if 0 <= x + i < N and 0 <= y + j < N and (x + i, y + j) not in seen:\\n                            seen.add((x + i, y + j))\\n                            bfs.append((x + i, y + j))\\n            return False\\n\\n        while l < r:\\n            m = (l + r) / 2\\n            if reachable(m): r = m\\n            else: l = m + 1\\n        return r\\n```\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int N = grid.size(), l = grid[0][0], r = N * N - 1, m;\\n        while (l < r) {\\n            m = (l + r) / 2;\\n            if (reachable(m, grid, N)) r = m;\\n            else l = m + 1;\\n        }\\n        return r;\\n    }\\n\\n    int reachable(int T, vector<vector<int>>& grid, int N) {\\n        queue<pair<int, int>> bfs;\\n        vector<vector<int>> seen(N, vector<int>(N, 0));\\n        static int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n        bfs.emplace(0, 0);\\n        seen[0][0] = 1;\\n        while (bfs.size()) {\\n            int x = bfs.front().first, y = bfs.front().second;\\n            bfs.pop();\\n            if (grid[x][y] <= T) {\\n                if (x == N - 1 && y == N - 1) return true;\\n                for (auto& d : dir) {\\n                    int i = x + d[0], j = y + d[1];\\n                    if (i >= 0 && i < N && j >= 0 && j < N && !seen[i][j]) {\\n                        seen[i][j] = 1;\\n                        bfs.emplace(i, j);\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115696,
                "title": "simple-java-solution-using-priority-queue",
                "content": "Idea is similar to Dijkstra's algorithm. Each iteration, we will select the neighbouring cell which is having least water level. Once we selected it, we will push all of its neighbours, that have not visited to the priority queue. Complexity will be O(N2 log N) \n\n```\n public int swimInWater(int[][] grid) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (grid[a[0]][a[1]] - grid[b[0]][b[1]]));\n        pq.add(new int[]{0, 0});\n        int level = 0;\n        int n = grid.length;\n        int[][] nexts = {{0 ,1}, {0, -1},{1, 0}, {-1, 0}};\n        boolean[][] isVisited = new boolean[n ][n];\n        while (!pq.isEmpty()){\n            int[] top = pq.poll();\n            level = Math.max(level, grid[top[0]][top[1]]);\n            if (top[0] == n - 1 && top[1] == n - 1){\n                break;\n            }\n            \n            for (int[] next : nexts){\n                int x = top[0] + next[0];\n                int y = top[1] + next[1];\n                if (!(x < 0|| x > n - 1 || y < 0 || y > n - 1)  && !isVisited[x][y]){\n                    isVisited[top[0]][top[1]] = true;\n                    pq.add(new int[]{x, y});\n                }\n            }\n        }\n        \n        return level;\n    }\n```",
                "solutionTags": [],
                "code": "```\n public int swimInWater(int[][] grid) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (grid[a[0]][a[1]] - grid[b[0]][b[1]]));\n        pq.add(new int[]{0, 0});\n        int level = 0;\n        int n = grid.length;\n        int[][] nexts = {{0 ,1}, {0, -1},{1, 0}, {-1, 0}};\n        boolean[][] isVisited = new boolean[n ][n];\n        while (!pq.isEmpty()){\n            int[] top = pq.poll();\n            level = Math.max(level, grid[top[0]][top[1]]);\n            if (top[0] == n - 1 && top[1] == n - 1){\n                break;\n            }\n            \n            for (int[] next : nexts){\n                int x = top[0] + next[0];\n                int y = top[1] + next[1];\n                if (!(x < 0|| x > n - 1 || y < 0 || y > n - 1)  && !isVisited[x][y]){\n                    isVisited[top[0]][top[1]] = true;\n                    pq.add(new int[]{x, y});\n                }\n            }\n        }\n        \n        return level;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1284843,
                "title": "python-2-solutions-union-find-heap-explained",
                "content": "#### Solution 1\\n\\nFirst solution is to use Union Find data structure: on each moment of time we can update connected component and wait for the moment when `0` and `N^2-1` are in the same component. \\n\\n#### Complexity\\nComplexity is `O(N^2 *log N)` if we use union find with ranks (in code above) and `O(N^2)` if we use it with ranks and paths compression. Space complexity is `O(N^2)`.\\n\\n#### Code\\n```python\\nclass DSU(object):\\n    def __init__(self, N):\\n        self.par = list(range(N))\\n        self.rnk = [0] * N\\n\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        elif self.rnk[xr] < self.rnk[yr]:\\n            self.par[xr] = yr\\n        elif self.rnk[xr] > self.rnk[yr]:\\n            self.par[yr] = xr\\n        else:\\n            self.par[yr] = xr\\n            self.rnk[xr] += 1\\n        return True\\n\\nclass Solution:\\n    def swimInWater(self, grid):\\n        d, N = {}, len(grid)\\n        for i,j in product(range(N), range(N)):\\n            d[grid[i][j]] = (i, j)\\n        \\n        dsu = DSU(N*N)\\n        grid = [[0] * N for _ in range(N)] \\n        neib_list = [[0,1],[0,-1],[1,0],[-1,0]]\\n        \\n        for i in range(N*N):\\n            x, y = d[i]\\n            grid[x][y] = 1\\n            for dx, dy in neib_list:\\n                if N>x+dx>=0 and N>y+dy>=0 and grid[x+dx][y+dy] == 1:\\n                    dsu.union((x+dx)*N + y + dy, x*N + y)\\n                    \\n            if dsu.find(0) == dsu.find(N*N-1): return i\\n```\\n\\n#### Solution 2\\nThere is also solution, using heaps: we perform usual dfs, start with `(0,0)` corner, but on each moment of time we choose node with smallest value to visit. In this way when we reached `(N-1, N-1)` corner, the answer will be the maximum of visited cells so far. \\n\\n#### Complexity\\nComplexity is again `O(N^2 *log N)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def swimInWater(self, grid):\\n        N, heap, visited, res = len(grid), [(grid[0][0], 0, 0)], set([(0, 0)]), 0\\n        \\n        for i in range(N*N):\\n            val, x, y = heappop(heap)\\n            res = max(res, val)\\n            if x == N-1 and y == N-1: return res\\n            neib_list = [[0,1],[0,-1],[1,0],[-1,0]]\\n            \\n            for dx, dy in neib_list:\\n                if (x + dx, y + dy) not in visited and 0<=x+dx<N and 0<=y+dy<N:\\n                    heappush(heap, (grid[x+dx][y+dy], x+dx, y+dy))\\n                    visited.add((x+dx, y+dy))\\n```\\n\\n#### Remark\\nFinally, there is Binary Search solution, where we ask question, given day `D` if we can reach end point or not. Time complexity is again `O(N^2 * log N)`.\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Union Find",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass DSU(object):\\n    def __init__(self, N):\\n        self.par = list(range(N))\\n        self.rnk = [0] * N\\n\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        elif self.rnk[xr] < self.rnk[yr]:\\n            self.par[xr] = yr\\n        elif self.rnk[xr] > self.rnk[yr]:\\n            self.par[yr] = xr\\n        else:\\n            self.par[yr] = xr\\n            self.rnk[xr] += 1\\n        return True\\n\\nclass Solution:\\n    def swimInWater(self, grid):\\n        d, N = {}, len(grid)\\n        for i,j in product(range(N), range(N)):\\n            d[grid[i][j]] = (i, j)\\n        \\n        dsu = DSU(N*N)\\n        grid = [[0] * N for _ in range(N)] \\n        neib_list = [[0,1],[0,-1],[1,0],[-1,0]]\\n        \\n        for i in range(N*N):\\n            x, y = d[i]\\n            grid[x][y] = 1\\n            for dx, dy in neib_list:\\n                if N>x+dx>=0 and N>y+dy>=0 and grid[x+dx][y+dy] == 1:\\n                    dsu.union((x+dx)*N + y + dy, x*N + y)\\n                    \\n            if dsu.find(0) == dsu.find(N*N-1): return i\\n```\n```python\\nclass Solution:\\n    def swimInWater(self, grid):\\n        N, heap, visited, res = len(grid), [(grid[0][0], 0, 0)], set([(0, 0)]), 0\\n        \\n        for i in range(N*N):\\n            val, x, y = heappop(heap)\\n            res = max(res, val)\\n            if x == N-1 and y == N-1: return res\\n            neib_list = [[0,1],[0,-1],[1,0],[-1,0]]\\n            \\n            for dx, dy in neib_list:\\n                if (x + dx, y + dy) not in visited and 0<=x+dx<N and 0<=y+dy<N:\\n                    heappush(heap, (grid[x+dx][y+dy], x+dx, y+dy))\\n                    visited.add((x+dx, y+dy))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965631,
                "title": "java-3-clean-codes-dijkstra-s-algo-priorityqueue-and-binary-search",
                "content": "**Approach 1: Dijkstra\\'s algorithm**\\nIt is easy to see the grid as a graph so we can apply Dijkstra\\'s algorithm to find the shortest path from start vertex to end vertex. When grid value at a vertex is higher than our current minimum distance path (which basically represents the current time), this edge can be seen as having a positive weight equal to grid value - current distance value otherwise we can treat this edge as 0 weight.\\n\\n```\\n// 14 ms. 41.35%\\nclass Solution {\\n    private static final int[][] dir = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n    public int swimInWater(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dist = new int[n][n];\\n        for(int i = 0; i < n; i++) Arrays.fill(dist[i], n * n);\\n        dist[0][0] = grid[0][0];\\n        TreeSet<int[]> set = new TreeSet<>((a, b) -> a[2] == b[2] ? (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]) : a[2] - b[2]);\\n        set.add(new int[] {0, 0, grid[0][0]});\\n        while(!set.isEmpty()) {\\n            int[] p = set.pollFirst();\\n            int i = p[0], j = p[1], time = p[2];\\n            if(i == n-1 && j == n-1) break;\\n            for(int[] d: dir) {\\n                int x = i + d[0], y = j + d[1];\\n                if(x < 0 || x >= n || y < 0 || y >= n) continue;\\n                int alt = time + Math.max(0, grid[x][y] - time);\\n                if(alt < dist[x][y]) {\\n                    int[] key = {x, y, dist[x][y]};\\n                    set.remove(key);\\n                    key[2] = dist[x][y] = alt;\\n                    set.add(key);\\n                }\\n            }\\n        }\\n        return dist[n-1][n-1];\\n    }\\n}\\n```\\n\\n**Approach 2: PriorityQueue based shortest path search**\\nThis is very similar to Dijkstra\\'s algorithm except we don\\'t maintain ```dist``` array and update ```dist``` for other vertices. We are just focused on finding the next closest vertex (the one that increases minimum time) and using it to reach towards target vertex.\\n\\nReason why we can get by without ```dist``` array and update ```dist``` step is because of the way problem is defined, specifically because a vertex\\'s ```dist``` value could become smaller than its grid value (if at all) **only once** i.e. at the time of exploring that vertex for the first time. After that, if we explore that vertex again through some other vertex, then time must be higher at that point and so the alternate path value (= time at that point) can not be better than what is already there. This is why we can get by without the \"relax\" step of Dijkstra\\'s.\\n\\n```\\n// 7 ms. 80.91%\\nclass Solution {\\n    private static final int[][] dir = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n    public int swimInWater(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        pq.add(new int[] {0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n        while(!pq.isEmpty()) {\\n            int[] a = pq.poll();\\n            for(int[] d: dir) {\\n                int x = a[0] + d[0], y = a[1] + d[1];\\n                if(x < 0 || x >= n || y < 0 || y >= n) continue;\\n                if(!visited[x][y]) {\\n                    visited[x][y] = true;\\n                    int t = Math.max(a[2], grid[x][y]);\\n                    if(x == n-1 && y == n-1) return t;\\n                    pq.add(new int[] {x, y, t});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n**Approach 3: Binary search**\\nNote that the answer (least time to reach) lies in a fixed range and that range is ```grid[0][0]``` to ```n*n-1```.\\n\\n**Minimum:** we need to wait atleast ```grid[0][0]``` time to be at ```0,0``` even if further path towards target takes 0 additional time\\n**Maximum:** since problem states that ```grid[i][j] is a permutation of [0, ..., N*N - 1]```, the time after which we can go from any point A to point B is the highest value in the grid i.e. ```n*n-1```\\n\\nImportant observation is that if we can reach from start vertex to end vertex within ```T``` time then we can also reach within ```T+1``` time. This means if we define a function ```F``` where ```F(T) = true/false depending on whether we can reach from start vertex to end vertex within T time```, then our ```F``` function would look something like this:\\n\\n```T: min -> max```\\n```F(T): [false false .... false true true ... true]```\\n\\nSo what we have to do is find the location of first ```T``` such that ```F(T)``` is true. This should be our answer or the minimum time.\\nWe can do this efficiently using binary search. In fact, we can apply binary search to a lot of similar problems where answer space is a fixed interval and feasibility results are monotonically non-increasing or non-decreasing.\\n\\nWe can do a DFS/BFS to test feasibility i.e. to check if we can reach from start vertex to end vertex within time ```T```.\\n\\n```\\n// 2 ms. 99.20%\\nclass Solution {\\n    int n;\\n    private boolean dfs(int[][] grid, int i, int j, int T, boolean[][] visited) {\\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j] || grid[i][j] > T) return false;\\n        visited[i][j] = true;\\n        if(i == n-1 && j == n-1) return true;\\n        return dfs(grid, i-1, j, T, visited) || dfs(grid, i+1, j, T, visited) || dfs(grid, i, j-1, T, visited) || dfs(grid, i, j+1, T, visited);\\n    }\\n    public int swimInWater(int[][] grid) {\\n        this.n = grid.length;\\n        int l = grid[0][0], r = n*n - 1;\\n        while(l < r) {\\n            int m = l + ((r-l) >> 1);\\n            if(dfs(grid, 0, 0, m, new boolean[n][n])) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// 14 ms. 41.35%\\nclass Solution {\\n    private static final int[][] dir = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n    public int swimInWater(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dist = new int[n][n];\\n        for(int i = 0; i < n; i++) Arrays.fill(dist[i], n * n);\\n        dist[0][0] = grid[0][0];\\n        TreeSet<int[]> set = new TreeSet<>((a, b) -> a[2] == b[2] ? (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]) : a[2] - b[2]);\\n        set.add(new int[] {0, 0, grid[0][0]});\\n        while(!set.isEmpty()) {\\n            int[] p = set.pollFirst();\\n            int i = p[0], j = p[1], time = p[2];\\n            if(i == n-1 && j == n-1) break;\\n            for(int[] d: dir) {\\n                int x = i + d[0], y = j + d[1];\\n                if(x < 0 || x >= n || y < 0 || y >= n) continue;\\n                int alt = time + Math.max(0, grid[x][y] - time);\\n                if(alt < dist[x][y]) {\\n                    int[] key = {x, y, dist[x][y]};\\n                    set.remove(key);\\n                    key[2] = dist[x][y] = alt;\\n                    set.add(key);\\n                }\\n            }\\n        }\\n        return dist[n-1][n-1];\\n    }\\n}\\n```\n```dist```\n```dist```\n```dist```\n```dist```\n```dist```\n```\\n// 7 ms. 80.91%\\nclass Solution {\\n    private static final int[][] dir = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };\\n    public int swimInWater(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][] visited = new boolean[n][n];\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        pq.add(new int[] {0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n        while(!pq.isEmpty()) {\\n            int[] a = pq.poll();\\n            for(int[] d: dir) {\\n                int x = a[0] + d[0], y = a[1] + d[1];\\n                if(x < 0 || x >= n || y < 0 || y >= n) continue;\\n                if(!visited[x][y]) {\\n                    visited[x][y] = true;\\n                    int t = Math.max(a[2], grid[x][y]);\\n                    if(x == n-1 && y == n-1) return t;\\n                    pq.add(new int[] {x, y, t});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\n```grid[0][0]```\n```n*n-1```\n```grid[0][0]```\n```0,0```\n```grid[i][j] is a permutation of [0, ..., N*N - 1]```\n```n*n-1```\n```T```\n```T+1```\n```F```\n```F(T) = true/false depending on whether we can reach from start vertex to end vertex within T time```\n```F```\n```T: min -> max```\n```F(T): [false false .... false true true ... true]```\n```T```\n```F(T)```\n```T```\n```\\n// 2 ms. 99.20%\\nclass Solution {\\n    int n;\\n    private boolean dfs(int[][] grid, int i, int j, int T, boolean[][] visited) {\\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j] || grid[i][j] > T) return false;\\n        visited[i][j] = true;\\n        if(i == n-1 && j == n-1) return true;\\n        return dfs(grid, i-1, j, T, visited) || dfs(grid, i+1, j, T, visited) || dfs(grid, i, j-1, T, visited) || dfs(grid, i, j+1, T, visited);\\n    }\\n    public int swimInWater(int[][] grid) {\\n        this.n = grid.length;\\n        int l = grid[0][0], r = n*n - 1;\\n        while(l < r) {\\n            int m = l + ((r-l) >> 1);\\n            if(dfs(grid, 0, 0, m, new boolean[n][n])) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284973,
                "title": "swim-in-rising-water-js-python-java-c-easy-dijkstra-s-minpq-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWhen a problem asks us to find the best path when there is something quantifiable making certain paths worse than others, one natural option would be a **Dijkstra\\'s algorithm** approach. Dijkstra\\'s algorithm uses a **breadth first search** (**BFS**) approach to a graph traversal, but it takes into account the weight/distance/difficulty of the different edges.\\n\\nIn this case, the weight will be the time required to move to a particular cell. To use Dijkstra\\'s, we\\'ll need to use a **min priority queue** (or **min heap**) data structure to store the possible moves at any point. These moves will be prioritized by how early they can be achieved (represented by the value in **grid[i][j]**).\\n\\nStarting at **(0,0)**, we can iterate through the surrounding squares and enter them into our priority queue (**pq**). After we\\'ve entered possible cell move into **pq**, we should mark it as seen so that we don\\'t enter the same cell into **pq** more than once.\\n\\n_(**Note**: The relative values for the grid coordinates and cell values are low enough that we can optionally store all three in one integer using **bit manipulation** to lower the memory footprint of the priority queue and make it a bit more responsive.)_\\n\\nWe would normally create a seen matrix of **N * N** dimensions to keep track of this, but we can also use an **in-place** approach to keep this information in **grid**. To do this, we can just bump the cell value of the target cell above an arbitrarily high value. The maximum cell value will be **N * N - 1**, and since **N** caps out at **50**, we can use any value of **2500** or more for our seen marker.\\n\\nAfter we store the new possible moves in **pq**, we then move to the next cell indicated by **pq**, remembering to keep track of the largest cell value (priority) seen so far (**ans**). We should repeat this process until we reach the end cell, and then we can **return ans**.\\n\\n - _**Time Complexity: O(N^2 * log N)** where **N** is the length of **grid**, for inserting/extracting up to **N^2** entries into the priority queue_\\n - _**Space Complexity: O(N^2)** for the priority queue / heap_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript\\'s **MinPriorityQueue()** npm is slower than a custom heap implementation, but it is decidedly easier to use.\\n\\nC++ defaults to a max priority queue, so we can just flip the signs on each of the insertions and extractions to convert to a min priority queue.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n***w/ MinPriorityQueue():***\\nThe best result for the code below is **96ms / 43.8MB** (beats 87% / 85%).\\n```javascript\\nconst moves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nvar swimInWater = function(grid) {\\n    let pq = new MinPriorityQueue(),\\n        N = grid.length - 1, ans = grid[0][0], i = 0, j = 0\\n    while (i < N || j < N) {\\n        for (let [a,b] of moves) {\\n            let ia = i + a, jb = j + b\\n            if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue\\n            pq.enqueue((grid[ia][jb] << 12) + (ia << 6) + jb)\\n            grid[ia][jb] = 3000\\n        }\\n        let next = pq.dequeue().element\\n        ans = Math.max(ans, next >> 12)\\n        i = (next >> 6) & ((1 << 6) - 1)\\n        j = next & ((1 << 6) - 1)\\n    }\\n    return ans\\n};\\n```\\n\\n***w/ Custom Min-Heap:***\\nThe best result for the code below is **76ms / 40.5MB** (beats 100% / 96%).\\n```javascript\\nconst moves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nvar swimInWater = function(grid) {\\n    let N = grid.length - 1, ans = grid[0][0], i = 0, j = 0, prio = 0\\n    \\n    // custom Min-Heap implementation\\n    let heap = [,]\\n    const hpush = val => {\\n        let i = heap.length, par = i >> 1, temp\\n        heap.push(val)\\n        while (heap[par] > heap[i]) {\\n            temp = heap[par], heap[par] = heap[i], heap[i] = temp\\n            i = par, par = i >> 1\\n        }\\n    }\\n    const hpop = () => {\\n        if (heap.length === 1) return null\\n        let top = heap[1], left, right, temp,\\n            i = 1, child = heap[3] < heap[2] ? 3 : 2\\n        if (heap.length > 2) heap[1] = heap.pop()\\n        else heap.pop()\\n        while (heap[i] > heap[child]) {\\n            temp = heap[child], heap[child] = heap[i], heap[i] = temp\\n            i = child, left = i << 1, right = left + 1\\n            child = heap[right] < heap[left] ? right : left\\n        }\\n        return top\\n    }\\n    \\n    while (i < N || j < N) {\\n        for (let [a,b] of moves) {\\n            let ia = i + a, jb = j + b\\n            if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue\\n            hpush((grid[ia][jb] << 12) + (ia << 6) + jb)\\n            grid[ia][jb] = 3000\\n        }\\n        let next = hpop()\\n        ans = Math.max(ans, next >> 12)\\n        i = (next >> 6) & ((1 << 6) - 1)\\n        j = next & ((1 << 6) - 1)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **84ms / 14.5MB** (beats 100% / 100%).\\n```python\\nmoves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        N, i, j, pq, ans = len(grid) - 1, 0, 0, [], grid[0][0]\\n        while i < N or j < N:\\n            for a,b in moves:\\n                ia, jb = i + a, j + b\\n                if ia < 0 or ia > N or jb < 0 or jb > N or grid[ia][jb] > 2500: continue\\n                heappush(pq, (grid[ia][jb] << 12) + (ia << 6) + jb)\\n                grid[ia][jb] = 3000\\n            nxt = heappop(pq)\\n            ans = max(ans, nxt >> 12)\\n            i = (nxt >> 6) & ((1 << 6) - 1)\\n            j = nxt & ((1 << 6) - 1)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **7ms / 38.3MB** (beats 83% / 97%).\\n```java\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        int N = grid.length - 1, ans = grid[0][0], i = 0, j = 0;\\n        while (i < N || j < N) {\\n            for (int[] m : moves) {\\n                int ia = i + m[0], jb = j + m[1];\\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\\n                pq.add((grid[ia][jb] << 12) + (ia << 6) + jb);\\n                grid[ia][jb] = 3000;\\n            }\\n            int next = pq.poll();\\n            ans = Math.max(ans, next >> 12);\\n            i = (next >> 6) & ((1 << 6) - 1);\\n            j = next & ((1 << 6) - 1);\\n        }\\n        return ans;\\n    }\\n    private int[][] moves = {{1,0},{0,1},{-1,0},{0,-1}};\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **8ms / 8.3MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        priority_queue<int> pq;\\n        int N = grid.size() - 1, ans = grid[0][0], i = 0, j = 0;\\n        while (i < N || j < N) {\\n            for (auto& m : moves) {\\n                int ia = i + m[0], jb = j + m[1];\\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\\n                pq.push(-(grid[ia][jb] << 12) - (ia << 6) - jb);\\n                grid[ia][jb] = 3000;\\n            }\\n            int next = -pq.top();\\n            pq.pop();\\n            ans = max(ans, next >> 12);\\n            i = (next >> 6) & ((1 << 6) - 1);\\n            j = next & ((1 << 6) - 1);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int moves[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst moves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nvar swimInWater = function(grid) {\\n    let pq = new MinPriorityQueue(),\\n        N = grid.length - 1, ans = grid[0][0], i = 0, j = 0\\n    while (i < N || j < N) {\\n        for (let [a,b] of moves) {\\n            let ia = i + a, jb = j + b\\n            if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue\\n            pq.enqueue((grid[ia][jb] << 12) + (ia << 6) + jb)\\n            grid[ia][jb] = 3000\\n        }\\n        let next = pq.dequeue().element\\n        ans = Math.max(ans, next >> 12)\\n        i = (next >> 6) & ((1 << 6) - 1)\\n        j = next & ((1 << 6) - 1)\\n    }\\n    return ans\\n};\\n```\n```javascript\\nconst moves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nvar swimInWater = function(grid) {\\n    let N = grid.length - 1, ans = grid[0][0], i = 0, j = 0, prio = 0\\n    \\n    // custom Min-Heap implementation\\n    let heap = [,]\\n    const hpush = val => {\\n        let i = heap.length, par = i >> 1, temp\\n        heap.push(val)\\n        while (heap[par] > heap[i]) {\\n            temp = heap[par], heap[par] = heap[i], heap[i] = temp\\n            i = par, par = i >> 1\\n        }\\n    }\\n    const hpop = () => {\\n        if (heap.length === 1) return null\\n        let top = heap[1], left, right, temp,\\n            i = 1, child = heap[3] < heap[2] ? 3 : 2\\n        if (heap.length > 2) heap[1] = heap.pop()\\n        else heap.pop()\\n        while (heap[i] > heap[child]) {\\n            temp = heap[child], heap[child] = heap[i], heap[i] = temp\\n            i = child, left = i << 1, right = left + 1\\n            child = heap[right] < heap[left] ? right : left\\n        }\\n        return top\\n    }\\n    \\n    while (i < N || j < N) {\\n        for (let [a,b] of moves) {\\n            let ia = i + a, jb = j + b\\n            if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue\\n            hpush((grid[ia][jb] << 12) + (ia << 6) + jb)\\n            grid[ia][jb] = 3000\\n        }\\n        let next = hpop()\\n        ans = Math.max(ans, next >> 12)\\n        i = (next >> 6) & ((1 << 6) - 1)\\n        j = next & ((1 << 6) - 1)\\n    }\\n    return ans\\n};\\n```\n```python\\nmoves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        N, i, j, pq, ans = len(grid) - 1, 0, 0, [], grid[0][0]\\n        while i < N or j < N:\\n            for a,b in moves:\\n                ia, jb = i + a, j + b\\n                if ia < 0 or ia > N or jb < 0 or jb > N or grid[ia][jb] > 2500: continue\\n                heappush(pq, (grid[ia][jb] << 12) + (ia << 6) + jb)\\n                grid[ia][jb] = 3000\\n            nxt = heappop(pq)\\n            ans = max(ans, nxt >> 12)\\n            i = (nxt >> 6) & ((1 << 6) - 1)\\n            j = nxt & ((1 << 6) - 1)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        int N = grid.length - 1, ans = grid[0][0], i = 0, j = 0;\\n        while (i < N || j < N) {\\n            for (int[] m : moves) {\\n                int ia = i + m[0], jb = j + m[1];\\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\\n                pq.add((grid[ia][jb] << 12) + (ia << 6) + jb);\\n                grid[ia][jb] = 3000;\\n            }\\n            int next = pq.poll();\\n            ans = Math.max(ans, next >> 12);\\n            i = (next >> 6) & ((1 << 6) - 1);\\n            j = next & ((1 << 6) - 1);\\n        }\\n        return ans;\\n    }\\n    private int[][] moves = {{1,0},{0,1},{-1,0},{0,-1}};\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        priority_queue<int> pq;\\n        int N = grid.size() - 1, ans = grid[0][0], i = 0, j = 0;\\n        while (i < N || j < N) {\\n            for (auto& m : moves) {\\n                int ia = i + m[0], jb = j + m[1];\\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\\n                pq.push(-(grid[ia][jb] << 12) - (ia << 6) - jb);\\n                grid[ia][jb] = 3000;\\n            }\\n            int next = -pq.top();\\n            pq.pop();\\n            ans = max(ans, next >> 12);\\n            i = (next >> 6) & ((1 << 6) - 1);\\n            j = next & ((1 << 6) - 1);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int moves[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284971,
                "title": "js-python-java-c-easy-dijkstra-s-minpq-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWhen a problem asks us to find the best path when there is something quantifiable making certain paths worse than others, one natural option would be a **Dijkstra\\'s algorithm** approach. Dijkstra\\'s algorithm uses a **breadth first search** (**BFS**) approach to a graph traversal, but it takes into account the weight/distance/difficulty of the different edges.\\n\\nIn this case, the weight will be the time required to move to a particular cell. To use Dijkstra\\'s, we\\'ll need to use a **min priority queue** (or **min heap**) data structure to store the possible moves at any point. These moves will be prioritized by how early they can be achieved (represented by the value in **grid[i][j]**).\\n\\nStarting at **(0,0)**, we can iterate through the surrounding squares and enter them into our priority queue (**pq**). After we\\'ve entered possible cell move into **pq**, we should mark it as seen so that we don\\'t enter the same cell into **pq** more than once.\\n\\n_(**Note**: The relative values for the grid coordinates and cell values are low enough that we can optionally store all three in one integer using **bit manipulation** to lower the memory footprint of the priority queue and make it a bit more responsive.)_\\n\\nWe would normally create a seen matrix of **N * N** dimensions to keep track of this, but we can also use an **in-place** approach to keep this information in **grid**. To do this, we can just bump the cell value of the target cell above an arbitrarily high value. The maximum cell value will be **N * N - 1**, and since **N** caps out at **50**, we can use any value of **2500** or more for our seen marker.\\n\\nAfter we store the new possible moves in **pq**, we then move to the next cell indicated by **pq**, remembering to keep track of the largest cell value (priority) seen so far (**ans**). We should repeat this process until we reach the end cell, and then we can **return ans**.\\n\\n - _**Time Complexity: O(N^2 * log N)** where **N** is the length of **grid**, for inserting/extracting up to **N^2** entries into the priority queue_\\n - _**Space Complexity: O(N^2)** for the priority queue / heap_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript\\'s **MinPriorityQueue()** npm is slower than a custom heap implementation, but it is decidedly easier to use.\\n\\nC++ defaults to a max priority queue, so we can just flip the signs on each of the insertions and extractions to convert to a min priority queue.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n***w/ MinPriorityQueue():***\\nThe best result for the code below is **96ms / 43.8MB** (beats 87% / 85%).\\n```javascript\\nconst moves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nvar swimInWater = function(grid) {\\n    let pq = new MinPriorityQueue(),\\n        N = grid.length - 1, ans = grid[0][0], i = 0, j = 0\\n    while (i < N || j < N) {\\n        for (let [a,b] of moves) {\\n            let ia = i + a, jb = j + b\\n            if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue\\n            pq.enqueue((grid[ia][jb] << 12) + (ia << 6) + jb)\\n            grid[ia][jb] = 3000\\n        }\\n        let next = pq.dequeue().element\\n        ans = Math.max(ans, next >> 12)\\n        i = (next >> 6) & ((1 << 6) - 1)\\n        j = next & ((1 << 6) - 1)\\n    }\\n    return ans\\n};\\n```\\n\\n***w/ Custom Min-Heap:***\\nThe best result for the code below is **76ms / 40.5MB** (beats 100% / 96%).\\n```javascript\\nconst moves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nvar swimInWater = function(grid) {\\n    let N = grid.length - 1, ans = grid[0][0], i = 0, j = 0, prio = 0\\n    \\n    // custom Min-Heap implementation\\n    let heap = [,]\\n    const hpush = val => {\\n        let i = heap.length, par = i >> 1, temp\\n        heap.push(val)\\n        while (heap[par] > heap[i]) {\\n            temp = heap[par], heap[par] = heap[i], heap[i] = temp\\n            i = par, par = i >> 1\\n        }\\n    }\\n    const hpop = () => {\\n        if (heap.length === 1) return null\\n        let top = heap[1], left, right, temp,\\n            i = 1, child = heap[3] < heap[2] ? 3 : 2\\n        if (heap.length > 2) heap[1] = heap.pop()\\n        else heap.pop()\\n        while (heap[i] > heap[child]) {\\n            temp = heap[child], heap[child] = heap[i], heap[i] = temp\\n            i = child, left = i << 1, right = left + 1\\n            child = heap[right] < heap[left] ? right : left\\n        }\\n        return top\\n    }\\n    \\n    while (i < N || j < N) {\\n        for (let [a,b] of moves) {\\n            let ia = i + a, jb = j + b\\n            if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue\\n            hpush((grid[ia][jb] << 12) + (ia << 6) + jb)\\n            grid[ia][jb] = 3000\\n        }\\n        let next = hpop()\\n        ans = Math.max(ans, next >> 12)\\n        i = (next >> 6) & ((1 << 6) - 1)\\n        j = next & ((1 << 6) - 1)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **84ms / 14.5MB** (beats 100% / 100%).\\n```python\\nmoves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        N, i, j, pq, ans = len(grid) - 1, 0, 0, [], grid[0][0]\\n        while i < N or j < N:\\n            for a,b in moves:\\n                ia, jb = i + a, j + b\\n                if ia < 0 or ia > N or jb < 0 or jb > N or grid[ia][jb] > 2500: continue\\n                heappush(pq, (grid[ia][jb] << 12) + (ia << 6) + jb)\\n                grid[ia][jb] = 3000\\n            nxt = heappop(pq)\\n            ans = max(ans, nxt >> 12)\\n            i = (nxt >> 6) & ((1 << 6) - 1)\\n            j = nxt & ((1 << 6) - 1)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **7ms / 38.3MB** (beats 83% / 97%).\\n```java\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        int N = grid.length - 1, ans = grid[0][0], i = 0, j = 0;\\n        while (i < N || j < N) {\\n            for (int[] m : moves) {\\n                int ia = i + m[0], jb = j + m[1];\\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\\n                pq.add((grid[ia][jb] << 12) + (ia << 6) + jb);\\n                grid[ia][jb] = 3000;\\n            }\\n            int next = pq.poll();\\n            ans = Math.max(ans, next >> 12);\\n            i = (next >> 6) & ((1 << 6) - 1);\\n            j = next & ((1 << 6) - 1);\\n        }\\n        return ans;\\n    }\\n    private int[][] moves = {{1,0},{0,1},{-1,0},{0,-1}};\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **8ms / 8.3MB** (beats 100% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        priority_queue<int> pq;\\n        int N = grid.size() - 1, ans = grid[0][0], i = 0, j = 0;\\n        while (i < N || j < N) {\\n            for (auto& m : moves) {\\n                int ia = i + m[0], jb = j + m[1];\\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\\n                pq.push(-(grid[ia][jb] << 12) - (ia << 6) - jb);\\n                grid[ia][jb] = 3000;\\n            }\\n            int next = -pq.top();\\n            pq.pop();\\n            ans = max(ans, next >> 12);\\n            i = (next >> 6) & ((1 << 6) - 1);\\n            j = next & ((1 << 6) - 1);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int moves[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nconst moves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nvar swimInWater = function(grid) {\\n    let pq = new MinPriorityQueue(),\\n        N = grid.length - 1, ans = grid[0][0], i = 0, j = 0\\n    while (i < N || j < N) {\\n        for (let [a,b] of moves) {\\n            let ia = i + a, jb = j + b\\n            if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue\\n            pq.enqueue((grid[ia][jb] << 12) + (ia << 6) + jb)\\n            grid[ia][jb] = 3000\\n        }\\n        let next = pq.dequeue().element\\n        ans = Math.max(ans, next >> 12)\\n        i = (next >> 6) & ((1 << 6) - 1)\\n        j = next & ((1 << 6) - 1)\\n    }\\n    return ans\\n};\\n```\n```javascript\\nconst moves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nvar swimInWater = function(grid) {\\n    let N = grid.length - 1, ans = grid[0][0], i = 0, j = 0, prio = 0\\n    \\n    // custom Min-Heap implementation\\n    let heap = [,]\\n    const hpush = val => {\\n        let i = heap.length, par = i >> 1, temp\\n        heap.push(val)\\n        while (heap[par] > heap[i]) {\\n            temp = heap[par], heap[par] = heap[i], heap[i] = temp\\n            i = par, par = i >> 1\\n        }\\n    }\\n    const hpop = () => {\\n        if (heap.length === 1) return null\\n        let top = heap[1], left, right, temp,\\n            i = 1, child = heap[3] < heap[2] ? 3 : 2\\n        if (heap.length > 2) heap[1] = heap.pop()\\n        else heap.pop()\\n        while (heap[i] > heap[child]) {\\n            temp = heap[child], heap[child] = heap[i], heap[i] = temp\\n            i = child, left = i << 1, right = left + 1\\n            child = heap[right] < heap[left] ? right : left\\n        }\\n        return top\\n    }\\n    \\n    while (i < N || j < N) {\\n        for (let [a,b] of moves) {\\n            let ia = i + a, jb = j + b\\n            if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue\\n            hpush((grid[ia][jb] << 12) + (ia << 6) + jb)\\n            grid[ia][jb] = 3000\\n        }\\n        let next = hpop()\\n        ans = Math.max(ans, next >> 12)\\n        i = (next >> 6) & ((1 << 6) - 1)\\n        j = next & ((1 << 6) - 1)\\n    }\\n    return ans\\n};\\n```\n```python\\nmoves = [[1,0],[0,1],[-1,0],[0,-1]]\\n\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        N, i, j, pq, ans = len(grid) - 1, 0, 0, [], grid[0][0]\\n        while i < N or j < N:\\n            for a,b in moves:\\n                ia, jb = i + a, j + b\\n                if ia < 0 or ia > N or jb < 0 or jb > N or grid[ia][jb] > 2500: continue\\n                heappush(pq, (grid[ia][jb] << 12) + (ia << 6) + jb)\\n                grid[ia][jb] = 3000\\n            nxt = heappop(pq)\\n            ans = max(ans, nxt >> 12)\\n            i = (nxt >> 6) & ((1 << 6) - 1)\\n            j = nxt & ((1 << 6) - 1)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        int N = grid.length - 1, ans = grid[0][0], i = 0, j = 0;\\n        while (i < N || j < N) {\\n            for (int[] m : moves) {\\n                int ia = i + m[0], jb = j + m[1];\\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\\n                pq.add((grid[ia][jb] << 12) + (ia << 6) + jb);\\n                grid[ia][jb] = 3000;\\n            }\\n            int next = pq.poll();\\n            ans = Math.max(ans, next >> 12);\\n            i = (next >> 6) & ((1 << 6) - 1);\\n            j = next & ((1 << 6) - 1);\\n        }\\n        return ans;\\n    }\\n    private int[][] moves = {{1,0},{0,1},{-1,0},{0,-1}};\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        priority_queue<int> pq;\\n        int N = grid.size() - 1, ans = grid[0][0], i = 0, j = 0;\\n        while (i < N || j < N) {\\n            for (auto& m : moves) {\\n                int ia = i + m[0], jb = j + m[1];\\n                if (ia < 0 || ia > N || jb < 0 || jb > N || grid[ia][jb] > 2500) continue;\\n                pq.push(-(grid[ia][jb] << 12) - (ia << 6) - jb);\\n                grid[ia][jb] = 3000;\\n            }\\n            int next = -pq.top();\\n            pq.pop();\\n            ans = max(ans, next >> 12);\\n            i = (next >> 6) & ((1 << 6) - 1);\\n            j = next & ((1 << 6) - 1);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    int moves[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285104,
                "title": "swim-in-rising-water-easy-solution-optimization-from-brute-force-to-binary-search-beats-100",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe can observe that the problem basically asks us to **find a path such that the maximum waterLevel *`w_lvl`* (value of a cell) of some intermediate cell of that path is minimized**. \\n\\nWe can start with the brute force approach and explore all the possible paths to reach the end of the *`grid`*. The path which minimizes the maximum value of some cell in a path will be chosen and that water level - *`w_lvl`* will be our answer.\\n\\n```\\nint n;\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tvector<vector<int> >vis(n, vector<int>(n));\\n\\treturn solve(grid, vis, 0, 0);\\n}\\nint solve(vector<vector<int>>& grid, vector<vector<int>> vis, int i, int j, int w_lvl = 0) {\\n\\tif(i < 0 || j < 0 || i >= n || j >= n || vis[i][j]) return 10000;  // out-of-bounds / already visited\\n\\tif(i == n - 1 && j == n - 1) return max(w_lvl, grid[i][j]);\\n\\tvis[i][j] = true;            // mark as visited so we don\\'t keep visiting back-and-forth\\n\\tw_lvl = max(w_lvl, grid[i][j]);  // update max intermediate value for current path\\n\\t// explore all 4 possible options from current cell and choose the path with minimum w_lvl -\\n\\treturn min({solve(grid, vis, i + 1, j, w_lvl), solve(grid, vis, i - 1, j, w_lvl), solve(grid, vis, i, j + 1, w_lvl), solve(grid, vis, i, j - 1, w_lvl)});\\n}\\n```\\n\\n<br />\\n\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u274C Brute-Force Variant -II (slightly optimized)</b></summary>\\n\\nSince the brute-force approach was just to establish a starting approach, I kept it simple and just passed the *`vis`* matrix in the above approach by value which makes copies of it for each recursive call. This prevents the need to mark a cell as un-visited for the next recursive call. \\n\\nBut making copies can be expensive. So here\\'s a slight optimization over it by passing it by reference. It still TLEs though...\\n\\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tvector<vector<int> >vis(n, vector<int>(n));\\n\\treturn solve(grid, vis, 0, 0);\\n}\\nint solve(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int w_lvl = 0) {\\n\\tif(i == n - 1 && j == n - 1) return max(w_lvl, grid[i][j]);\\n\\tvis[i][j] = true;            \\n\\tw_lvl = max(w_lvl, grid[i][j]);  \\n    int ans = 10000;\\n\\tfor(int k = 0; k < 4; k++) {\\n        int new_i = i + moves[k][0], new_j = j + moves[k][1];\\n        if(checkValid(new_i, new_j, vis)) {\\n            ans = min(ans, solve(grid, vis, new_i, new_j, w_lvl));    \\n            vis[new_i][new_j] = false;\\n        }\\n    }\\n    return ans;\\n}\\nbool checkValid (int i, int j, vector<vector<int>>& vis) {\\n    return !(i < 0 || j < 0 || i >= n || j >= n || vis[i][j]);\\n}\\n```\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** <b><code>O(4<sup>n<sup>2</sup></sup>)</code></b>, for each cell of the grid, we have 4 choices. So, in the worst case we may need <code>4`*`4`*`4`*`...n<sup>2</sup>times</code>\\n\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b> for the optimzed verison, <b><code>O(n<sup>4</sup>)</code></b> for the first version since copy for *`vis`* is made for each recursive call\\n\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Search lowest valid water-level)***\\n\\nExploring all the possible path options is very time-consuming. **Instead of exploring all the available paths** and then choosing the path with lowest maximum water level - *`w_lvl`* , **we can instead set an upper-limit to *`w_lvl`*  ourselves**, starting from 1 till `n*n-1`. The lowest water level required to reach the end will be our answer.\\n\\nHere, instead of exploring all paths, we have limited ourselves to only exploring a single path which has maximum intermediate cell value = *`w_lvl`* and returning as soon as we find the first path that takes us to the end. Thus, we have limited our search space to a great extent.\\n\\n\\nAnother small optimization is to start checking directly from max of `max( grid[0][0], grid[n-1][n-1], 2*(n-1) )` instead of `w_lvl=1` (Credits to @ud240 & @nicolattu). That\\'s because every path will contain *`grid[0][0]`* and *`grid[n-1][n-1]`*, and `2*(n-1)` because grid elements are always a permutation of `0...n*n-1` and thus there will always be a cell with `value >= 2*(n-1)`  in every path.\\n\\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n    n = size(grid);        \\n    vector<vector<int>>vis(n, vector<int>(n));\\n\\tint minReq = max({ 2*(n-1), grid[0][0], grid[n-1][n-1] });\\n    for(int w_lvl = minReq; w_lvl < n*n; w_lvl++) {\\n        if(dfs(grid, vis, 0, 0, w_lvl)) return w_lvl;\\n        for_each(begin(vis), end(vis), [](auto& v){fill(begin(v), end(v), 0);});  // reset the vis array back to not-visited\\n    }        \\n    return n*n;\\n}\\n\\nbool dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int w_lvl) {\\n    if(i < 0 || j < 0 || i >= n || j >= n || vis[i][j] || grid[i][j] > w_lvl) return false; // out-of-bound / already visited / cell value > max w_lvl allowed\\n    if(i == n - 1 && j == n - 1) return true;\\n    vis[i][j] = true;\\n    for(int k = 0; k < 4; k++) // search all available option till any of it leads us to the end\\n        if(dfs(grid, vis, i + moves[k][0], j + moves[k][1], w_lvl)) return true;\\n    return false;\\n}\\n```\\n\\n***Time Complexity :*** <b><code>O(n<sup>4</sup>)</code></b>, we are exploring all water-level values from `1` to `n*n`. For each water-level *`MAX`*, we call `dfs()` having <code>O(n<sup>2</sup>)</code> time complexity in the worst case. Thus, overall time complexity becomes <code>O(n*n) * O(n<sup>2</sup>) = O(n<sup>4</sup>)</code>\\n\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Binary-Search)***\\n\\nInstead of searching linearly as we did in the above approach, we can use binary search to find the lowest valid water-level. Our search space is sorted and it the range `[1...n*n-1]` and thus binary search can be applied here.\\n\\nIn previous approach, for the worst-case scenario we would have called `dfs()` for `n*n` times. \\nBinary search will reduce worst-case number of calls required to <code>O(logn<sup>2</sup>) = O(logn)</code>.\\n\\nAlso, I have replaced the *`vis`* below with a boolean C-style array (for faster runtime) of `50x50` which is the max *`grid`* dimensions. Since the constraints are small, I have opted for fixed size declaration intead dynamic allocation, the syntax of which is slightly messy.\\n\\n\\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tint l = max({ 2*(n-1), grid[0][0], grid[n-1][n-1] }), r = n*n-1, mid;\\n\\tbool vis[50][50]{};\\n\\twhile(l <= r) {            \\n\\t\\tmid = (l + r) / 2;\\n\\t\\tif(solve(grid, vis, 0, 0, mid)) r = mid - 1;  // we are able to reach end with MAX=mid   => try lower to minimze it\\n\\t\\telse l = mid + 1;                             // we fail to reach the end with MAX=mid   => try higher so we can reach the end\\n\\t\\tmemset(vis, false, sizeof vis);               // reset vis back to all false\\n\\t}\\n\\treturn l;\\n}\\n\\nbool solve(vector<vector<int>>& grid, bool vis[][50], int i, int j, int w_lvl) {\\n\\tif(i < 0 || j < 0 || i >= n || j >= n || vis[i][j] || grid[i][j] > w_lvl) return false;\\n\\tif(i == n - 1 && j == n - 1) return true;\\n\\tvis[i][j] = true;\\n\\tfor(int k = 0; k < 4; k++) \\n\\t\\tif(solve(grid, vis, i + moves[k][0], j + moves[k][1], w_lvl)) return true;\\n\\treturn false;\\n}\\n```\\n\\n\\n***Time Complexity :*** <b><code>O(n<sup>2</sup>logn)</code></b>, <code>O(n<sup>2</sup>)</code> for dfs call and `O(logn)` for binary search over `1...n*n`.\\n\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src =https://assets.leetcode.com/users/images/ccc9315f-7e1e-4679-b242-2112fcd74cd9_1624194042.2626312.png /></td></tr></table>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint n;\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tvector<vector<int> >vis(n, vector<int>(n));\\n\\treturn solve(grid, vis, 0, 0);\\n}\\nint solve(vector<vector<int>>& grid, vector<vector<int>> vis, int i, int j, int w_lvl = 0) {\\n\\tif(i < 0 || j < 0 || i >= n || j >= n || vis[i][j]) return 10000;  // out-of-bounds / already visited\\n\\tif(i == n - 1 && j == n - 1) return max(w_lvl, grid[i][j]);\\n\\tvis[i][j] = true;            // mark as visited so we don\\'t keep visiting back-and-forth\\n\\tw_lvl = max(w_lvl, grid[i][j]);  // update max intermediate value for current path\\n\\t// explore all 4 possible options from current cell and choose the path with minimum w_lvl -\\n\\treturn min({solve(grid, vis, i + 1, j, w_lvl), solve(grid, vis, i - 1, j, w_lvl), solve(grid, vis, i, j + 1, w_lvl), solve(grid, vis, i, j - 1, w_lvl)});\\n}\\n```\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tvector<vector<int> >vis(n, vector<int>(n));\\n\\treturn solve(grid, vis, 0, 0);\\n}\\nint solve(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int w_lvl = 0) {\\n\\tif(i == n - 1 && j == n - 1) return max(w_lvl, grid[i][j]);\\n\\tvis[i][j] = true;            \\n\\tw_lvl = max(w_lvl, grid[i][j]);  \\n    int ans = 10000;\\n\\tfor(int k = 0; k < 4; k++) {\\n        int new_i = i + moves[k][0], new_j = j + moves[k][1];\\n        if(checkValid(new_i, new_j, vis)) {\\n            ans = min(ans, solve(grid, vis, new_i, new_j, w_lvl));    \\n            vis[new_i][new_j] = false;\\n        }\\n    }\\n    return ans;\\n}\\nbool checkValid (int i, int j, vector<vector<int>>& vis) {\\n    return !(i < 0 || j < 0 || i >= n || j >= n || vis[i][j]);\\n}\\n```\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n    n = size(grid);        \\n    vector<vector<int>>vis(n, vector<int>(n));\\n\\tint minReq = max({ 2*(n-1), grid[0][0], grid[n-1][n-1] });\\n    for(int w_lvl = minReq; w_lvl < n*n; w_lvl++) {\\n        if(dfs(grid, vis, 0, 0, w_lvl)) return w_lvl;\\n        for_each(begin(vis), end(vis), [](auto& v){fill(begin(v), end(v), 0);});  // reset the vis array back to not-visited\\n    }        \\n    return n*n;\\n}\\n\\nbool dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int i, int j, int w_lvl) {\\n    if(i < 0 || j < 0 || i >= n || j >= n || vis[i][j] || grid[i][j] > w_lvl) return false; // out-of-bound / already visited / cell value > max w_lvl allowed\\n    if(i == n - 1 && j == n - 1) return true;\\n    vis[i][j] = true;\\n    for(int k = 0; k < 4; k++) // search all available option till any of it leads us to the end\\n        if(dfs(grid, vis, i + moves[k][0], j + moves[k][1], w_lvl)) return true;\\n    return false;\\n}\\n```\n```\\nint n, moves[4][2] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tn = size(grid);\\n\\tint l = max({ 2*(n-1), grid[0][0], grid[n-1][n-1] }), r = n*n-1, mid;\\n\\tbool vis[50][50]{};\\n\\twhile(l <= r) {            \\n\\t\\tmid = (l + r) / 2;\\n\\t\\tif(solve(grid, vis, 0, 0, mid)) r = mid - 1;  // we are able to reach end with MAX=mid   => try lower to minimze it\\n\\t\\telse l = mid + 1;                             // we fail to reach the end with MAX=mid   => try higher so we can reach the end\\n\\t\\tmemset(vis, false, sizeof vis);               // reset vis back to all false\\n\\t}\\n\\treturn l;\\n}\\n\\nbool solve(vector<vector<int>>& grid, bool vis[][50], int i, int j, int w_lvl) {\\n\\tif(i < 0 || j < 0 || i >= n || j >= n || vis[i][j] || grid[i][j] > w_lvl) return false;\\n\\tif(i == n - 1 && j == n - 1) return true;\\n\\tvis[i][j] = true;\\n\\tfor(int k = 0; k < 4; k++) \\n\\t\\tif(solve(grid, vis, i + moves[k][0], j + moves[k][1], w_lvl)) return true;\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1285182,
                "title": "easy-to-understand-java-solution-explanation-with-comments-with-dfs-binary-search",
                "content": "```\\n/*. Approach: DFS + Binary Search\\n        \\n    Observation: \\n            \\n        1. grid[i][j] values lies between 0 to n*n-1 (given in constraint).\\n           \\n           So, water rise will be in range (0, n*n-1). \\n           So, our result (minimum time to reach) will be in this fixed range (grid[0][0], n*n-1).\\n           (When we are at grid[0][0], we cannot move till Time T reaches grid[0][0] value, so it is min.)\\n               \\n        2. If we can reach from point a(i,j) to b(k,l) in time T, then we can reach in time T+1 also.\\n               \\n            eg: if we able to reach some point at 5th sec, then I can reach in 6,7,8... time also.\\n\\n             If I store this in some boolean array, it will be like below: \\n\\n              { false, false, false, ..., false, true, true, true, ..., true}\\n                                                        -     -     -          -\\n           Idea is to use Binary Search to check at any T, if my answer is possible.\\n            -> If its possible in time T, check for less time than T\\n            -> If its not possible in time T, check for more time than T\\n                \\n           Do this, until we are left out with only 1 element, and that would be the 1st \\'True\\'.\\n           \\n           ( Note: We can also do linear traversal like checking from time T = n*n-1 to 0 for the result.\\n             But Binary Search would be efficient as it is sorted based on false/true\\n           )\\n        \\n        \\n*/\\n\\n\\nclass Solution {\\n    \\n    public int swimInWater(int[][] grid) {\\n        \\n        int n = grid.length;\\n        \\n        int low = grid[0][0];   // min time needed is 1st square where we stand, we cannot move till T reaches grid[0][0]\\n        int high = n*n - 1;     // max time needed is the max value present in grid (provided in constraint)\\n        \\n        \\n        // Apply Binary Search for checking if possile result lies in the intervals.\\n        \\n        while (low < high) {\\n            \\n            int mid = low + ((high - low) >> 1);\\n            \\n            // Start search from grid[0][0] \\n            \\n            /* Note:\\n\\n               Create boolean visited array in while loop as we want new search everytime for particular time T.\\n               \\n                Otherwise, when we are searching for range (0,24) it will make some squares visited.\\n                So, next time for checking dfs for range (0,12) or (13,24) it will not check those squares.\\n                \\n                So, write code for creating a new boolean array in while loop, but not before while loop.\\n              \\n            */\\n            \\n            boolean visited[][] = new boolean[n][n];\\n            \\n            if (dfs(grid, 0, 0, mid, visited)) {\\n                \\n                high = mid;\\n                \\n            } else {\\n                \\n                low = mid + 1;\\n                \\n            }\\n            \\n        }\\n        \\n        return low;\\n        \\n    }\\n    \\n    \\n    // DFS function to check if solution exists for given time T\\n    \\n    private boolean dfs (int grid[][], int row, int col, int time, boolean visited[][]) {\\n        \\n        int n = grid.length;\\n        \\n        // Corner Cases / Exit Return cases / Solution not possible\\n        \\n        if (row < 0 || row >= n || col < 0 || col >= n || visited[row][col] || grid[row][col] > time) {\\n            \\n            return false;   // If current square elevation > T, then wait till time for that elevation.\\n            \\n        }\\n        \\n        visited[row][col] = true;         // Mark the square as visited\\n        \\n        if (row == n-1 && col == n-1) {\\n            return true;                  // Return true, as for some DFS, result is obtained.\\n        }\\n        \\n        // Check for other 4 directional scenarios and return true if Any of them is true.\\n        \\n        return dfs(grid, row - 1, col    , time, visited) || \\n               dfs(grid, row + 1, col    , time, visited) ||\\n               dfs(grid, row    , col - 1, time, visited) || \\n               dfs(grid, row    , col + 1, time, visited);\\n        \\n    }\\n    \\n    \\n    \\n}\\n```\\n\\n\\n**Please Upvote if you find it helpful. Happy Coding!**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/*. Approach: DFS + Binary Search\\n        \\n    Observation: \\n            \\n        1. grid[i][j] values lies between 0 to n*n-1 (given in constraint).\\n           \\n           So, water rise will be in range (0, n*n-1). \\n           So, our result (minimum time to reach) will be in this fixed range (grid[0][0], n*n-1).\\n           (When we are at grid[0][0], we cannot move till Time T reaches grid[0][0] value, so it is min.)\\n               \\n        2. If we can reach from point a(i,j) to b(k,l) in time T, then we can reach in time T+1 also.\\n               \\n            eg: if we able to reach some point at 5th sec, then I can reach in 6,7,8... time also.\\n\\n             If I store this in some boolean array, it will be like below: \\n\\n              { false, false, false, ..., false, true, true, true, ..., true}\\n                                                        -     -     -          -\\n           Idea is to use Binary Search to check at any T, if my answer is possible.\\n            -> If its possible in time T, check for less time than T\\n            -> If its not possible in time T, check for more time than T\\n                \\n           Do this, until we are left out with only 1 element, and that would be the 1st \\'True\\'.\\n           \\n           ( Note: We can also do linear traversal like checking from time T = n*n-1 to 0 for the result.\\n             But Binary Search would be efficient as it is sorted based on false/true\\n           )\\n        \\n        \\n*/\\n\\n\\nclass Solution {\\n    \\n    public int swimInWater(int[][] grid) {\\n        \\n        int n = grid.length;\\n        \\n        int low = grid[0][0];   // min time needed is 1st square where we stand, we cannot move till T reaches grid[0][0]\\n        int high = n*n - 1;     // max time needed is the max value present in grid (provided in constraint)\\n        \\n        \\n        // Apply Binary Search for checking if possile result lies in the intervals.\\n        \\n        while (low < high) {\\n            \\n            int mid = low + ((high - low) >> 1);\\n            \\n            // Start search from grid[0][0] \\n            \\n            /* Note:\\n\\n               Create boolean visited array in while loop as we want new search everytime for particular time T.\\n               \\n                Otherwise, when we are searching for range (0,24) it will make some squares visited.\\n                So, next time for checking dfs for range (0,12) or (13,24) it will not check those squares.\\n                \\n                So, write code for creating a new boolean array in while loop, but not before while loop.\\n              \\n            */\\n            \\n            boolean visited[][] = new boolean[n][n];\\n            \\n            if (dfs(grid, 0, 0, mid, visited)) {\\n                \\n                high = mid;\\n                \\n            } else {\\n                \\n                low = mid + 1;\\n                \\n            }\\n            \\n        }\\n        \\n        return low;\\n        \\n    }\\n    \\n    \\n    // DFS function to check if solution exists for given time T\\n    \\n    private boolean dfs (int grid[][], int row, int col, int time, boolean visited[][]) {\\n        \\n        int n = grid.length;\\n        \\n        // Corner Cases / Exit Return cases / Solution not possible\\n        \\n        if (row < 0 || row >= n || col < 0 || col >= n || visited[row][col] || grid[row][col] > time) {\\n            \\n            return false;   // If current square elevation > T, then wait till time for that elevation.\\n            \\n        }\\n        \\n        visited[row][col] = true;         // Mark the square as visited\\n        \\n        if (row == n-1 && col == n-1) {\\n            return true;                  // Return true, as for some DFS, result is obtained.\\n        }\\n        \\n        // Check for other 4 directional scenarios and return true if Any of them is true.\\n        \\n        return dfs(grid, row - 1, col    , time, visited) || \\n               dfs(grid, row + 1, col    , time, visited) ||\\n               dfs(grid, row    , col - 1, time, visited) || \\n               dfs(grid, row    , col + 1, time, visited);\\n        \\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113743,
                "title": "java-dp-dfs",
                "content": "    final static int[][] steps = {{0,1},{0,-1}, {1,0},{-1,0}};\\n    public int swimInWater(int[][] grid) {\\n        int n = grid.length;\\n        int[][] max = new int[n][n];\\n        for(int[] line : max)\\n            Arrays.fill(line, Integer.MAX_VALUE);\\n        dfs(grid, max, 0, 0, grid[0][0]);\\n        return max[n-1][n-1];\\n    }\\n    \\n    private void dfs(int[][] grid, int[][] max, int x, int y, int cur) {\\n        int n = grid.length;\\n        if (x < 0 || x >= n || y < 0 || y >= n || Math.max(cur, grid[x][y]) >= max[x][y])\\n            return;\\n        max[x][y] = Math.max(cur, grid[x][y]);\\n        for(int[] s : steps) {\\n            dfs(grid, max, x + s[0], y + s[1], max[x][y]);\\n        }\\n    }\\n\\n**Update**: since each item in **max** can be updated at most **N^2** times, the upper boundary of this solution is **O(n^4)**.",
                "solutionTags": [],
                "code": "    final static int[][] steps = {{0,1},{0,-1}, {1,0},{-1,0}};\\n    public int swimInWater(int[][] grid) {\\n        int n = grid.length;\\n        int[][] max = new int[n][n];\\n        for(int[] line : max)\\n            Arrays.fill(line, Integer.MAX_VALUE);\\n        dfs(grid, max, 0, 0, grid[0][0]);\\n        return max[n-1][n-1];\\n    }\\n    \\n    private void dfs(int[][] grid, int[][] max, int x, int y, int cur) {\\n        int n = grid.length;\\n        if (x < 0 || x >= n || y < 0 || y >= n || Math.max(cur, grid[x][y]) >= max[x][y])\\n            return;\\n        max[x][y] = Math.max(cur, grid[x][y]);\\n        for(int[] s : steps) {\\n            dfs(grid, max, x + s[0], y + s[1], max[x][y]);\\n        }\\n    }\\n\\n**Update**: since each item in **max** can be updated at most **N^2** times, the upper boundary of this solution is **O(n^4)**.",
                "codeTag": "Unknown"
            },
            {
                "id": 113750,
                "title": "o-n-2-solution-union-find-python",
                "content": "```\\nclass Solution:\\n    def swimInWater(self, grid):\\n        def zhaobaba(x, y):\\n            if baba[x][y] == (x, y):\\n                return baba[x][y]\\n            baba[x][y] = zhaobaba(baba[x][y][0], baba[x][y][1])\\n            return baba[x][y]\\n        \\n        def hebing(a, b):\\n            a = zhaobaba(a[0], a[1])\\n            b = zhaobaba(b[0], b[1])\\n            if size[a[0]][a[1]] < size[b[0]][b[1]]:\\n                baba[a[0]][a[1]] = b\\n                size[b[0]][b[1]] += size[a[0]][a[1]]\\n            else:\\n                baba[b[0]][b[1]] = a\\n                size[a[0]][a[1]] += size[b[0]][b[1]]\\n            \\n        WEI = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n        \\n        pos = {}\\n        m = len(grid)\\n        n = len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                pos[grid[i][j]] = (i, j)\\n                \\n        baba = []\\n        size = []\\n        for i in range(m):\\n            new_list = []\\n            for j in range(n):\\n                new_list.append((i, j))\\n            baba.append(new_list)\\n            size.append([1] * n)\\n        \\n        for i in range(m * n):\\n            x, y = pos[i]\\n            for wei in WEI:\\n                tx = x + wei[0]\\n                ty = y + wei[1]\\n                if tx >= 0 and tx < m and ty >= 0 and ty < n:\\n                    if grid[tx][ty] <= i:\\n                        hebing((x, y), (tx, ty))\\n                        if zhaobaba(0, 0) == zhaobaba(m - 1, n - 1):\\n                            return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def swimInWater(self, grid):\\n        def zhaobaba(x, y):\\n            if baba[x][y] == (x, y):\\n                return baba[x][y]\\n            baba[x][y] = zhaobaba(baba[x][y][0], baba[x][y][1])\\n            return baba[x][y]\\n        \\n        def hebing(a, b):\\n            a = zhaobaba(a[0], a[1])\\n            b = zhaobaba(b[0], b[1])\\n            if size[a[0]][a[1]] < size[b[0]][b[1]]:\\n                baba[a[0]][a[1]] = b\\n                size[b[0]][b[1]] += size[a[0]][a[1]]\\n            else:\\n                baba[b[0]][b[1]] = a\\n                size[a[0]][a[1]] += size[b[0]][b[1]]\\n            \\n        WEI = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n        \\n        pos = {}\\n        m = len(grid)\\n        n = len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                pos[grid[i][j]] = (i, j)\\n                \\n        baba = []\\n        size = []\\n        for i in range(m):\\n            new_list = []\\n            for j in range(n):\\n                new_list.append((i, j))\\n            baba.append(new_list)\\n            size.append([1] * n)\\n        \\n        for i in range(m * n):\\n            x, y = pos[i]\\n            for wei in WEI:\\n                tx = x + wei[0]\\n                ty = y + wei[1]\\n                if tx >= 0 and tx < m and ty >= 0 and ty < n:\\n                    if grid[tx][ty] <= i:\\n                        hebing((x, y), (tx, ty))\\n                        if zhaobaba(0, 0) == zhaobaba(m - 1, n - 1):\\n                            return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385647,
                "title": "best-explaination-union-and-find-swin-in-rising-water",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPS: we need to find at what time we will be able to reach the last location starting from the first location such that time taken is minimum.\\nobviously we can\\'t reach any lesser than the height of the last location and not any longer than the max height.\\n{Intuition for binary search on answer approach}\\nIntutively thinking about the union and find approach is hard.\\n\\n1. Would describe the approaches:\\n          Bascially if we could start from the very first and keep on increasing time and see if we can reach the last , if at any time we would be able to reach the last then that time would be minimum.\\n//DFS\\n2. Improved version of the prev approach {DFS+binary search}\\nwe know that our ans would always be in the range{last height,max heigh}\\nwe can apply binary search for the answer in this range, and pick the approapriate answer, rather than trying for all the possible times.\\n3. basically the third approach is pure dikstra,\\nwe keep on selecting the min, and have a priority queue for the min {rather than selecting all in dfs approach},\\nin dikstra we get a path which contains all the min possible nodes to reach the end.\\nsince the max of the nodes would be the least time required to visit this particular path given by the dikstra algorithm so we could be having the max of it as our time.\\n4. Now here we can see the connectivity, Union and find intution,\\n   all the elements got connected at last,\\n   see if we could be connecting all the elements in increasing time,\\n   and at a particular time we see that the first and the last element\\n   also got connected then since we are increasing the time linearly \\n   we must have got the min time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n     Union and find approach\\n     start from time 0,\\n     see the elements that can swim at this time.\\n     mark it as visited\\n     find it\\'s location {need a method to store the location of   elements which can be reached exactly at time t}\\n      \\n     start from the first location,\\n     mark this location as visited\\n     see its neighbours , if anoyone already visited that means they are in the path and should be connected to it.\\n     connect both the components\\n    if anytime you find that the first and last location got connected\\n    this particular time should be the min as we came here first time only.\\n     \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    n square * log(n)\\n   nsquare : for time traversal\\n   logn: max time to update the parents in find operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n square)\\n     visited array,disjoint array\\n     we can instead of visited array either use the grid array itself\\n     or since any element value less than time t will be already  visited.\\n\\n\\n# Code\\n```\\nclass Disjointset\\n{\\nprivate:\\n    vector<int> parent, size; // parent will store the parents \\'\\n                              // size will be taken to rank or compare the parent order while doing union.\\npublic:\\n    Disjointset(int n)\\n    {\\n        parent.resize(n + 1);\\n        size.resize(n, 1);\\n        for (int i = 0; i < n + 1; i++)\\n        {\\n            parent[i] = i; // element will be it\\'s parent only\\n        }\\n    }\\n    int find(int X)\\n    {\\n        if (parent[X] == X)\\n            return X;\\n\\n        return parent[X] = find(parent[X]); // path compression\\n    }\\n    void UNION(int X, int Y)\\n    {\\n        int parent1 = find(X);\\n        int parent2 = find(Y);\\n        if (parent1 == parent2)\\n            return; // CYCLE DETECTED.\\n        if (size[parent1] < size[parent2])\\n        {\\n            parent[parent1] = parent2;\\n            size[parent2] += size[parent1];\\n        }\\n        else\\n        {\\n            parent[parent2] = parent1;\\n            size[parent1] += size[parent2];\\n        }\\n    }\\n    void printArrays()\\n    {\\n        cout << \"PARENT\" << endl;\\n        for (auto it : parent)\\n        {\\n            cout << it << \" \";\\n        }\\n        cout << endl;\\n        cout << \"SIZE\" << endl;\\n        for (auto it : size)\\n        {\\n            cout << it << \" \";\\n        }\\n    }\\n    int SIZE(int vertex) // returns the size of the whole disjoint set of which the current vertex is a part of.\\n    {\\n        return size[find(vertex)]; // returns the size of disjoint set that it is a part of.\\n    }\\n\\n    int noOfdisjointSets(int n) // pass n as indexing. , gives all disjoint sets and not particular\\n    {\\n        // find the parent of all nodes.\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            parent[i] = find(i);\\n        }\\n\\n        int cnt = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (parent[i] == i)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n        /*\\n      //   METHOD 2\\n        set<int> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(parent[i]);\\n        }\\n        return s.size();\\n        */\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    int swimInWater(vector<vector<int>> &grid)\\n    {\\n        return UnionAndFind_swimInWater(grid);\\n    }\\n    int UnionAndFind_swimInWater(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        Disjointset ds(n * n);\\n        pair<int, int> locations[n * n];                // store the location of the element reachable exactly at time t.\\n        vector<vector<int>> vis(n, vector<int>(n, -1)); // can use grid for this purpose also.\\n        for (int i = 0; i < n; i++)                     // storing the locations of elements\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                locations[grid[i][j]] = {i, j};\\n            }\\n        }\\n\\n        int delRow[] = {0, 0, 1, -1};\\n        int delCol[] = {1, -1, 0, 0};\\n        // now the time will be in range from 0 to n*n -1\\n        for (int time = 0; time < n * n; time++)\\n        {\\n\\n            // find the loc of element reachable exactly at  this time {x,y}\\n            int x = locations[time].first;\\n            int y = locations[time].second;\\n            // mark the current as visited\\n            vis[x][y] = 1;\\n            // check if all it\\'s neighbours, if they have already been reached then merge with it.\\n            for (int k = 0; k < 4; k++)\\n            {\\n                int nrow = x + delRow[k];\\n                int ncol = y + delCol[k];\\n                if (underBoundaries(nrow, ncol, n, n) && vis[nrow][ncol] == 1)\\n                {\\n                    ds.UNION(x*n+y,nrow*n+ncol);//join the locations here and not the heights.\\n                }\\n            }\\n            if (ds.find(0) == ds.find(n*n-1)) // if last element location in the connected component\\n            {\\n                return time;\\n            }\\n        }\\n\\n        return n * n - 1; // since in max time it will be possible to reach the desired\\n        // the code will itself cover this situation and does not require it here only.\\n        /*\\n         some intutive improvements in the problem:\\n          since time is increasing linearly,\\n          so any element which has lesser value than current time is already visited\\n          so we can say element<time then already visited.\\n          we can save ourselves of vis extra n square space.\\n        */\\n    }\\n    bool underBoundaries(int nrow, int ncol, int n, int m)\\n    {\\n        if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Disjointset\\n{\\nprivate:\\n    vector<int> parent, size; // parent will store the parents \\'\\n                              // size will be taken to rank or compare the parent order while doing union.\\npublic:\\n    Disjointset(int n)\\n    {\\n        parent.resize(n + 1);\\n        size.resize(n, 1);\\n        for (int i = 0; i < n + 1; i++)\\n        {\\n            parent[i] = i; // element will be it\\'s parent only\\n        }\\n    }\\n    int find(int X)\\n    {\\n        if (parent[X] == X)\\n            return X;\\n\\n        return parent[X] = find(parent[X]); // path compression\\n    }\\n    void UNION(int X, int Y)\\n    {\\n        int parent1 = find(X);\\n        int parent2 = find(Y);\\n        if (parent1 == parent2)\\n            return; // CYCLE DETECTED.\\n        if (size[parent1] < size[parent2])\\n        {\\n            parent[parent1] = parent2;\\n            size[parent2] += size[parent1];\\n        }\\n        else\\n        {\\n            parent[parent2] = parent1;\\n            size[parent1] += size[parent2];\\n        }\\n    }\\n    void printArrays()\\n    {\\n        cout << \"PARENT\" << endl;\\n        for (auto it : parent)\\n        {\\n            cout << it << \" \";\\n        }\\n        cout << endl;\\n        cout << \"SIZE\" << endl;\\n        for (auto it : size)\\n        {\\n            cout << it << \" \";\\n        }\\n    }\\n    int SIZE(int vertex) // returns the size of the whole disjoint set of which the current vertex is a part of.\\n    {\\n        return size[find(vertex)]; // returns the size of disjoint set that it is a part of.\\n    }\\n\\n    int noOfdisjointSets(int n) // pass n as indexing. , gives all disjoint sets and not particular\\n    {\\n        // find the parent of all nodes.\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            parent[i] = find(i);\\n        }\\n\\n        int cnt = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (parent[i] == i)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n        /*\\n      //   METHOD 2\\n        set<int> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(parent[i]);\\n        }\\n        return s.size();\\n        */\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    int swimInWater(vector<vector<int>> &grid)\\n    {\\n        return UnionAndFind_swimInWater(grid);\\n    }\\n    int UnionAndFind_swimInWater(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        Disjointset ds(n * n);\\n        pair<int, int> locations[n * n];                // store the location of the element reachable exactly at time t.\\n        vector<vector<int>> vis(n, vector<int>(n, -1)); // can use grid for this purpose also.\\n        for (int i = 0; i < n; i++)                     // storing the locations of elements\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                locations[grid[i][j]] = {i, j};\\n            }\\n        }\\n\\n        int delRow[] = {0, 0, 1, -1};\\n        int delCol[] = {1, -1, 0, 0};\\n        // now the time will be in range from 0 to n*n -1\\n        for (int time = 0; time < n * n; time++)\\n        {\\n\\n            // find the loc of element reachable exactly at  this time {x,y}\\n            int x = locations[time].first;\\n            int y = locations[time].second;\\n            // mark the current as visited\\n            vis[x][y] = 1;\\n            // check if all it\\'s neighbours, if they have already been reached then merge with it.\\n            for (int k = 0; k < 4; k++)\\n            {\\n                int nrow = x + delRow[k];\\n                int ncol = y + delCol[k];\\n                if (underBoundaries(nrow, ncol, n, n) && vis[nrow][ncol] == 1)\\n                {\\n                    ds.UNION(x*n+y,nrow*n+ncol);//join the locations here and not the heights.\\n                }\\n            }\\n            if (ds.find(0) == ds.find(n*n-1)) // if last element location in the connected component\\n            {\\n                return time;\\n            }\\n        }\\n\\n        return n * n - 1; // since in max time it will be possible to reach the desired\\n        // the code will itself cover this situation and does not require it here only.\\n        /*\\n         some intutive improvements in the problem:\\n          since time is increasing linearly,\\n          so any element which has lesser value than current time is already visited\\n          so we can say element<time then already visited.\\n          we can save ourselves of vis extra n square space.\\n        */\\n    }\\n    bool underBoundaries(int nrow, int ncol, int n, int m)\\n    {\\n        if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2336999,
                "title": "very-easy-c-dynamic-programming-approach-using-3d-dp-array",
                "content": "```\\nclass Solution {\\n    int dp[51][51][2501];\\n    int vis[51][51];\\n    long long rec(vector<vector<int>> &grid,int i,int j,int time)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || vis[i][j])\\n            return INT_MAX;\\n        \\n        if(i==grid.size()-1 && j==grid[0].size()-1)\\n            return time+max(0,grid[i][j]-time);\\n        \\n        if(dp[i][j][time]!=-1)\\n            return dp[i][j][time];\\n        \\n        vis[i][j]=1;\\n        \\n        long long op1,op2,op3,op4;\\n        \\n        op1=rec(grid,i+1,j,time+max(0,grid[i][j]-time));\\n        op2=rec(grid,i-1,j,time+max(0,grid[i][j]-time));\\n        op3=rec(grid,i,j+1,time+max(0,grid[i][j]-time));\\n        op4=rec(grid,i,j-1,time+max(0,grid[i][j]-time));\\n        \\n        vis[i][j]=0;\\n        \\n        return dp[i][j][time]=min({op1,op2,op3,op4});\\n        \\n    }\\n    \\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        memset(vis,0,sizeof(vis));\\n        memset(dp,-1,sizeof(dp));\\n        return rec(grid,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int dp[51][51][2501];\\n    int vis[51][51];\\n    long long rec(vector<vector<int>> &grid,int i,int j,int time)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || vis[i][j])\\n            return INT_MAX;\\n        \\n        if(i==grid.size()-1 && j==grid[0].size()-1)\\n            return time+max(0,grid[i][j]-time);\\n        \\n        if(dp[i][j][time]!=-1)\\n            return dp[i][j][time];\\n        \\n        vis[i][j]=1;\\n        \\n        long long op1,op2,op3,op4;\\n        \\n        op1=rec(grid,i+1,j,time+max(0,grid[i][j]-time));\\n        op2=rec(grid,i-1,j,time+max(0,grid[i][j]-time));\\n        op3=rec(grid,i,j+1,time+max(0,grid[i][j]-time));\\n        op4=rec(grid,i,j-1,time+max(0,grid[i][j]-time));\\n        \\n        vis[i][j]=0;\\n        \\n        return dp[i][j][time]=min({op1,op2,op3,op4});\\n        \\n    }\\n    \\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        memset(vis,0,sizeof(vis));\\n        memset(dp,-1,sizeof(dp));\\n        return rec(grid,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253007,
                "title": "dfs-binary-search-dfs-is-not-a-regular-dfs-but-with-early-pruning",
                "content": "The question can be stated as follows: there are multiple paths from `(0, 0)` to `(n - 1, n - 1)`, each path has a max value from all of the steps . And what is smallest of that value `res` in the path among all of them?\\nSo we can check if there is a path where all the values in the path is smaller than the target time `time`.\\n1. `time` can be shrinked with **Binary Search**\\n2. Checking path can be done with **DFS**, but the magic behind the DFS is the **Early Pruning**, the reason we can use early pruning is that we can for each position they all follow the same rule: `grid[i][j] < time`, for example:\\n\\n\\t```\\n\\t1   5   3\\n\\t4   10  7\\n\\t2   9   8\\n\\t```\\n\\t\\n\\tFor the 4 directions, if we define the priorities as: `bottom > right > top > left`. And if `time = 8`, the `visited` matrix will be developed as:\\n\\n\\t\\tT  5   3\\n\\t\\tT  10  7\\n\\t\\tT  T   8\\n\\n\\t=> \\n\\n\\t\\tT  5  3\\n\\t\\tT  T  7\\n\\t\\tT  T  8\\n\\n\\t=>\\n\\n\\tThen we reach `5`, then move to bottom `10`, we found we have visited `10` before and *\"visited\"* proved that there is no way to reach `grid[n - 1][n - 1]` from `10`, so we do not need to choosing that way. So we can just keep going right, finally:\\n\\n\\t```\\n\\t1  5  3 \\n\\t\\t  7\\n\\t\\t  8\\n\\t```\\n\\n\\nCode:\\n```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        // corner case\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        \\n        int n = grid[0].length;\\n        int left = grid[0][0];\\n        int right = n*n - 1;\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            boolean[][] visited = new boolean[n][n];\\n            if(hasPath(grid, n, 0, 0, visited, mid)){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    // return if there is a path from grid[i][j] to grid[n - 1][n - 1]\\n    // with the max time <= time\\n    public boolean hasPath(int[][] grid, int n, int i, int j, boolean[][] visited, int time){\\n        // base case\\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j] || grid[i][j] > time) return false;\\n        if(i == n - 1 && j == n - 1) return true;\\n        \\n        int[][] DIRS = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        \\n        visited[i][j] = true;\\n        for(int[] dir : DIRS){\\n            int newX = i + dir[0];\\n            int newY = j + dir[1];\\n            if(hasPath(grid, n, newX, newY, visited, time)) return true;\\n        }\\n        // visited[i][j] = false; // no need to this for early pruning\\n        \\n        return false;\\n    }\\n}\\n```\\n\\ntime complexity: `O(n^2*logn)`\\nspace complexity: `O(n^2)`",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\t1   5   3\\n\\t4   10  7\\n\\t2   9   8\\n\\t```\n```\\n\\t1  5  3 \\n\\t\\t  7\\n\\t\\t  8\\n\\t```\n```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        // corner case\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n        \\n        int n = grid[0].length;\\n        int left = grid[0][0];\\n        int right = n*n - 1;\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            boolean[][] visited = new boolean[n][n];\\n            if(hasPath(grid, n, 0, 0, visited, mid)){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    // return if there is a path from grid[i][j] to grid[n - 1][n - 1]\\n    // with the max time <= time\\n    public boolean hasPath(int[][] grid, int n, int i, int j, boolean[][] visited, int time){\\n        // base case\\n        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j] || grid[i][j] > time) return false;\\n        if(i == n - 1 && j == n - 1) return true;\\n        \\n        int[][] DIRS = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        \\n        visited[i][j] = true;\\n        for(int[] dir : DIRS){\\n            int newX = i + dir[0];\\n            int newY = j + dir[1];\\n            if(hasPath(grid, n, newX, newY, visited, time)) return true;\\n        }\\n        // visited[i][j] = false; // no need to this for early pruning\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284969,
                "title": "c-solution-using-priority-queue-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    // checking the boundary conditions of a grid\\n    bool isSafe(int x, int y, int n){\\n        if(x>=0 && x<n && y>=0 && y<n){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        //take 1 visited vector of size n*n\\n        vector<int> visited(n*n, false); \\n        \\n        //declaring priority queue(min heap)\\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int, pair<int,int>>>, greater<pair<int, pair<int,int>>>> q;\\n        \\n        q.push(make_pair(grid[0][0], make_pair(0,0)));\\n        visited[grid[0][0]] = true;\\n        pair<int, pair<int,int>> temp;\\n        int ans = 0;\\n        \\n        while(q.empty()==false){\\n            temp = q.top();\\n            q.pop();\\n            \\n            ans = max(ans, temp.first);\\n            \\n            int x = temp.second.first;\\n            int y = temp.second.second;\\n            \\n            // if we reach at the bottom right square then return ans\\n            if(x==n-1 && y==n-1){\\n                return ans;\\n            }\\n            \\n            // move to next row\\n            if(isSafe(x+1,y,n) && visited[grid[x+1][y]]==false){\\n                visited[grid[x+1][y]] = true;\\n                q.push(make_pair(grid[x+1][y], make_pair(x+1,y)));\\n            }\\n            // move to previous row\\n            if(isSafe(x-1,y,n) && visited[grid[x-1][y]]==false){\\n                visited[grid[x-1][y]] = true;\\n                q.push(make_pair(grid[x-1][y], make_pair(x-1,y)));\\n            }\\n            // move to next column\\n            if(isSafe(x,y+1,n) && visited[grid[x][y+1]]==false){\\n                visited[grid[x][y+1]] = true;\\n                q.push(make_pair(grid[x][y+1], make_pair(x,y+1)));\\n            }\\n            // move to previous column\\n            if(isSafe(x,y-1,n) && visited[grid[x][y-1]]==false){\\n                visited[grid[x][y-1]] = true;\\n                q.push(make_pair(grid[x][y-1], make_pair(x,y-1)));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    // checking the boundary conditions of a grid\\n    bool isSafe(int x, int y, int n){\\n        if(x>=0 && x<n && y>=0 && y<n){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 556125,
                "title": "java-dijkstra-solution-with-explanation",
                "content": "This problem is to find shortest path, the only thing we need to pay attention to is the weight of edge from grid[0][0] to grid[n-1][n-1].\\n\\nWe can take grid [[0, 1], [2, 3]] as an example:\\n\\tWe can treat this as a graph with 4 vertices 0,1,2,3 and there are 4 edges. {0, 1} with weight 1, {0, 2} with weight 2, {1, 3} with weight 3 and {2, 3} with weight 3 respectively. Each time we choose the smallest edge {m, n} to simulate at time max(m, n) and rain falls. So we first take edge {0, 1} then {0, 2}.  When we are processing edge {1, 3}, the original result is 2(getting from {0, 2}), but since original time is less than we currently need, we need time 3 to reach vertice 3.\\n\\nFor another case like grid [[3, 2], [1, 0]], the first part is the same. To reach from vertice 3 to vertice 1, we need time 3. Then to reach from vertice 1 to vertice 0, we also only need time 3, since we can move infinite distance in one move. We can see this like at time 3, water can move from vertice 3 to vertice 1 then vertice 0 directly.\\n\\nFrom 2 cases above, we can get the most important thing in this problem that the time needs to reach grid[i][j] is max(grid[i][j], grid[i\\'][j\\']), where grid[i\\'][j\\'] is the cell to get to grid[i][j].\\n\\nTime complexity: O(n^2 log n)\\n\\n```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        //find the shortest path from (0,0) to (n-1,n-1)\\n        //the total time is the max element on the path\\n        \\n        int n = grid.length;\\n        int res = 0;\\n        boolean[][] visited = new boolean[n][n];\\n        //each time we choose a smallest cell, representing currently reachable cell at time grid[i][j]\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((k1, k2) ->\\n                grid[k1 / n][k1 % n] - grid[k2 / n][k2 % n]);\\n        pq.offer(0);\\n        \\n        \\n        int[][] dir = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        while (!pq.isEmpty()){\\n            int pos = pq.poll();\\n            int curX = pos / n;\\n            int curY = pos % n;\\n            //the time to reach to this cell grid[curX][curY] is max(original time, current time)\\n            res = Math.max(res, grid[curX][curY]);\\n            \\n            if(curX == n - 1 && curY == n - 1){\\n                return res;\\n            }\\n            \\n            //do BFS to search all possible cells\\n            for(int i = 0; i < 4; i++){\\n                int X = curX + dir[i][0];\\n                int Y = curY + dir[i][1];\\n                if(X < 0 || X >= n || Y < 0 || Y >= n || visited[X][Y] == true){\\n                    continue;\\n                }\\n                visited[X][Y] = true;\\n                pq.offer(X * n + Y);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        //find the shortest path from (0,0) to (n-1,n-1)\\n        //the total time is the max element on the path\\n        \\n        int n = grid.length;\\n        int res = 0;\\n        boolean[][] visited = new boolean[n][n];\\n        //each time we choose a smallest cell, representing currently reachable cell at time grid[i][j]\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((k1, k2) ->\\n                grid[k1 / n][k1 % n] - grid[k2 / n][k2 % n]);\\n        pq.offer(0);\\n        \\n        \\n        int[][] dir = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        while (!pq.isEmpty()){\\n            int pos = pq.poll();\\n            int curX = pos / n;\\n            int curY = pos % n;\\n            //the time to reach to this cell grid[curX][curY] is max(original time, current time)\\n            res = Math.max(res, grid[curX][curY]);\\n            \\n            if(curX == n - 1 && curY == n - 1){\\n                return res;\\n            }\\n            \\n            //do BFS to search all possible cells\\n            for(int i = 0; i < 4; i++){\\n                int X = curX + dir[i][0];\\n                int Y = curY + dir[i][1];\\n                if(X < 0 || X >= n || Y < 0 || Y >= n || visited[X][Y] == true){\\n                    continue;\\n                }\\n                visited[X][Y] = true;\\n                pq.offer(X * n + Y);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679863,
                "title": "c-dijkstra-algorithm-priority-queue-easy-solution-min-heap",
                "content": "Thank you  ```Striver``` for teaching us graphs so deeply.\\n\\n# It takes a lot of effort to form solutions , please do upvote.\\n\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>time(n, vector<int>(m, 1e9));\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> pq;\\n        time[0][0] = grid[0][0];\\n        int ans = 1e9;\\n     \\n        pq.push({time[0][0], {0,0}});\\n        \\n        int dr[] = {-1, 0, 1, 0};\\n        int dc[] = {0, 1, 0, -1};\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int diff = it.first;\\n            int r = it.second.first;\\n            int c = it.second.second;\\n           \\n            \\n            for(int i = 0; i<4; i++)\\n            {\\n                int nrow = dr[i] + r;\\n                int ncol = dc[i] + c;\\n                \\n                if(nrow>=0 && nrow<n && ncol >=0 && ncol <m && grid[nrow][ncol] < time[nrow][ncol])\\n                {\\n                    if(diff <  grid[nrow][ncol])\\n                    {\\n                        time[nrow][ncol] = grid[nrow][ncol];\\n                        pq.push({time[nrow][ncol], {nrow, ncol}});\\n                         \\n                    }\\n                    else if(diff < time[nrow][ncol])\\n                    {\\n                        time[nrow][ncol] = diff;\\n                        pq.push({time[nrow][ncol], {nrow, ncol}});\\n                    }  \\n                }\\n            }\\n            \\n        }\\n        return time[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```Striver```\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>time(n, vector<int>(m, 1e9));\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> pq;\\n        time[0][0] = grid[0][0];\\n        int ans = 1e9;\\n     \\n        pq.push({time[0][0], {0,0}});\\n        \\n        int dr[] = {-1, 0, 1, 0};\\n        int dc[] = {0, 1, 0, -1};\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int diff = it.first;\\n            int r = it.second.first;\\n            int c = it.second.second;\\n           \\n            \\n            for(int i = 0; i<4; i++)\\n            {\\n                int nrow = dr[i] + r;\\n                int ncol = dc[i] + c;\\n                \\n                if(nrow>=0 && nrow<n && ncol >=0 && ncol <m && grid[nrow][ncol] < time[nrow][ncol])\\n                {\\n                    if(diff <  grid[nrow][ncol])\\n                    {\\n                        time[nrow][ncol] = grid[nrow][ncol];\\n                        pq.push({time[nrow][ncol], {nrow, ncol}});\\n                         \\n                    }\\n                    else if(diff < time[nrow][ncol])\\n                    {\\n                        time[nrow][ncol] = diff;\\n                        pq.push({time[nrow][ncol], {nrow, ncol}});\\n                    }  \\n                }\\n            }\\n            \\n        }\\n        return time[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285459,
                "title": "easy-clean-c-binary-search-on-answer-dfs-with-explaination",
                "content": "We can do a binary search for the value of t. i.e. for what value of t a path exists from 0,0 to n-1,n-1.\\nIf a path exist for this value of t then we need to check for a smaller value of t but if path does not exist for a particular t then its clear that path will not exist for any value greater than t.\\n\\n```\\nclass Solution {\\npublic:\\n    void pathExist(int row, int col,vector<vector<int>>& a,int n , int t, vector<vector<bool>>& vis){\\n        if(row <0 || col < 0 || row>=n || col >=n || vis[row][col] || a[row][col]>t)return;\\n        vis[row][col] = 1;\\n        if(row==n-1 && col==n-1)return; \\n        pathExist(row-1,col,a,n,t,vis);\\n        pathExist(row+1,col,a,n,t,vis);\\n        pathExist(row,col-1,a,n,t,vis);\\n        pathExist(row,col+1,a,n,t,vis);\\n    }\\n    int swimInWater(vector<vector<int>>& a) {\\n        int n  = a.size(),lo = 0 , hi = INT_MAX, ans;\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n            vector<vector<bool>> vis(n,vector<bool>(n));\\n            pathExist(0,0,a,n,mid,vis);\\n            if(vis[n-1][n-1]){\\n                ans = mid;\\n                hi = mid-1;\\n            } else lo = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void pathExist(int row, int col,vector<vector<int>>& a,int n , int t, vector<vector<bool>>& vis){\\n        if(row <0 || col < 0 || row>=n || col >=n || vis[row][col] || a[row][col]>t)return;\\n        vis[row][col] = 1;\\n        if(row==n-1 && col==n-1)return; \\n        pathExist(row-1,col,a,n,t,vis);\\n        pathExist(row+1,col,a,n,t,vis);\\n        pathExist(row,col-1,a,n,t,vis);\\n        pathExist(row,col+1,a,n,t,vis);\\n    }\\n    int swimInWater(vector<vector<int>>& a) {\\n        int n  = a.size(),lo = 0 , hi = INT_MAX, ans;\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n            vector<vector<bool>> vis(n,vector<bool>(n));\\n            pathExist(0,0,a,n,mid,vis);\\n            if(vis[n-1][n-1]){\\n                ans = mid;\\n                hi = mid-1;\\n            } else lo = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350822,
                "title": "c-simple-c-code-97-time-92-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        int n = grid.size(), m = grid[0].size();\\n        int dirx[4] = {1, -1, 0, 0};\\n        int diry[4] = {0, 0, -1, 1};\\n        int val = 0;\\n        pq.push({grid[0][0],{0,0}});\\n        grid[0][0] = -1;\\n        while(!pq.empty())\\n        {\\n            int sz = pq.size();\\n            while(sz--)\\n            {\\n                pair<int, pair<int, int>> tp = pq.top();\\n                int x = tp.second.first, y = tp.second.second;\\n                pq.pop();\\n                val = max(val, tp.first);\\n                if(x == n-1 && y == m-1) return val;\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int nxtx = x + dirx[i];\\n                    int nxty = y + diry[i];\\n                    if(nxtx < 0 || nxtx >= n || nxty < 0 || nxty >= m) continue;\\n                    if(grid[nxtx][nxty] == -1) continue;\\n                    pq.push({grid[nxtx][nxty],{nxtx, nxty}});\\n                    grid[nxtx][nxty] = -1;\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        int n = grid.size(), m = grid[0].size();\\n        int dirx[4] = {1, -1, 0, 0};\\n        int diry[4] = {0, 0, -1, 1};\\n        int val = 0;\\n        pq.push({grid[0][0],{0,0}});\\n        grid[0][0] = -1;\\n        while(!pq.empty())\\n        {\\n            int sz = pq.size();\\n            while(sz--)\\n            {\\n                pair<int, pair<int, int>> tp = pq.top();\\n                int x = tp.second.first, y = tp.second.second;\\n                pq.pop();\\n                val = max(val, tp.first);\\n                if(x == n-1 && y == m-1) return val;\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int nxtx = x + dirx[i];\\n                    int nxty = y + diry[i];\\n                    if(nxtx < 0 || nxtx >= n || nxty < 0 || nxty >= m) continue;\\n                    if(grid[nxtx][nxty] == -1) continue;\\n                    pq.push({grid[nxtx][nxty],{nxtx, nxty}});\\n                    grid[nxtx][nxty] = -1;\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284991,
                "title": "python-explained-binary-searching-on-time-height-with-time-and-space-complexity",
                "content": "At time \\'t\\', there are t units/height of water, i.e.., each building will have a minimum height of \\'t\\' due to rain water. In other words, we will be able to reach a height \\'t\\' only at \\'t\\' hours, not before that.\\n\\nAlso, it is given that if we have a path with height <= t at time \\'t\\' from [0,0] to [n-1,m-1], we can reach from start to end in neglible amount of time.\\n\\nSo, basically for this problem time is not an issue for travelling, but we need to wait for a certain time to reach a building of height h > t.\\n\\nThus, we can perform a binary search on the minimum amount of time we need to wait, such that a path is available between [0,0] and [n-1,m-1] and all the building in the path are of height <= t.\\n\\nNow, What should be the range of our Binary Search?\\nInitially we are at time 0, so **left bound is 0**. And max amount of time we need to wait can be the max height of the given buildings in the grid (in worst case), so **max height of the buildings in the grid is our right bound** for binary search.\\n\\n![image](https://assets.leetcode.com/users/images/6999eb37-429c-4448-85c7-3932ec389a54_1624175852.6539888.png)\\n\\nNow, we need to perform binary search, for minimum height for which there is a path from [0,0] to [n-1,m-1].\\n**How do we know that a path exists?**-> Simply by performing Depth First Traversal.\\nHere, we will  travel in all the four directions (up, down, left, right) by not visiting the node we have visited earlier. And in this traversal we start from [0,0] and if we happen to touch [n-1,m-1], then we can say that a path exists.\\nThis is general Depth First Traversal, but we have another constraint that we cannot move to a height > t, so we include a constraint that we can move in any of the four directions, if and only if, the height of the building in that direction is less than \\'t\\'.\\n\\n**Binary Search Idea:**\\nIf at time \\'t\\', we found a path, it means there is a possibility that a path may exist at time < t. So, we again search in the boundary [0, t].\\nIf at time \\'t\\', we did not find a path, it means definitely there is no path in time <= t. So, we need to search in the boundary [t+1, max height of buildings in grid].\\n\\n\\nHere is the full code.\\n\\n```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        \\n        def PathSearch(height, i, j, visited):\\n            if not visited[i][j] and grid[i][j] <= height:\\n                visited[i][j] = 1\\n                if i-1 >= 0:\\n                    PathSearch(height, i-1, j, visited)\\n                if i+1 < n:\\n                    PathSearch(height, i+1, j, visited)\\n                if j-1 >= 0:\\n                    PathSearch(height, i, j-1, visited)\\n                if j+1 < n:\\n                    PathSearch(height, i, j+1, visited)\\n        \\n        def BinarySearch(l, r):\\n            while l < r:\\n                mid = (l+r)//2\\n                visited = [[0]*m for _ in range(n)]\\n                PathSearch(mid, 0, 0, visited)\\n                if visited[n-1][m-1]:\\n                    r = mid\\n                else:\\n                    l = mid + 1\\n            return l\\n        \\n        \\n        n, m = len(grid), len(grid[0])\\n        l, r = 0, max(max(x) for x in grid)\\n        return BinarySearch(l, r)\\n```\\n\\nFor this Case, we have a square grid, so N == M.\\n\\n**Time =** O(N * N) for Depth First Traversal and O(log (50 * 50 -1)) for Binary Search which is constant **= O(N^2)**\\nWhy 50 * 50 -1 ? -> As N = 50 and the 0<=grid[i][j]<=N * N - 1. So, instead of calculating the right bound = max height of the buildings in grid, we can also make the right bound as 50 * 50 - 1.\\n\\n*For some people, they would not like to consider N * N - 1 as constant. As even though it is small, but it is still variable. (It is a debatable topic).*\\nSo for them, **Time  =** O(N^2) * O(log(N^2)) = O(N^2) * 2 * O(logN) **= O(N^2 log N).**\\n\\n\\n**Space =** O(4 * N * N) owing to the Depth First Traversal Recurssion Tree + O(N * M) for the visisted array = **O (N^2) overall.**\\n\\nHope this helps!\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        \\n        def PathSearch(height, i, j, visited):\\n            if not visited[i][j] and grid[i][j] <= height:\\n                visited[i][j] = 1\\n                if i-1 >= 0:\\n                    PathSearch(height, i-1, j, visited)\\n                if i+1 < n:\\n                    PathSearch(height, i+1, j, visited)\\n                if j-1 >= 0:\\n                    PathSearch(height, i, j-1, visited)\\n                if j+1 < n:\\n                    PathSearch(height, i, j+1, visited)\\n        \\n        def BinarySearch(l, r):\\n            while l < r:\\n                mid = (l+r)//2\\n                visited = [[0]*m for _ in range(n)]\\n                PathSearch(mid, 0, 0, visited)\\n                if visited[n-1][m-1]:\\n                    r = mid\\n                else:\\n                    l = mid + 1\\n            return l\\n        \\n        \\n        n, m = len(grid), len(grid[0])\\n        l, r = 0, max(max(x) for x in grid)\\n        return BinarySearch(l, r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746362,
                "title": "javascript-dfs-solution",
                "content": "```\\nvar swimInWater = function(grid) {\\n    let visited = new Set(), time = 0, N = grid.length;\\n    let dirs = [[-1,0], [0,-1], [0,1],[1,0]];\\n    \\n    const dfs = (r, c) => {\\n        if(r < 0 || r > N -1 || c < 0 || c > N -1 || time < grid[r][c] || visited.has(r*N + c)) return;\\n        visited.add(r * N + c);\\n        for(let [rr, cc] of dirs) \\n            dfs(r + rr, c + cc);\\n    };\\n    \\n    while(!visited.has(N * N-1)) {\\n        visited.clear();\\n        dfs(0,0);\\n        time++;\\n    }\\n    \\n    return time - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar swimInWater = function(grid) {\\n    let visited = new Set(), time = 0, N = grid.length;\\n    let dirs = [[-1,0], [0,-1], [0,1],[1,0]];\\n    \\n    const dfs = (r, c) => {\\n        if(r < 0 || r > N -1 || c < 0 || c > N -1 || time < grid[r][c] || visited.has(r*N + c)) return;\\n        visited.add(r * N + c);\\n        for(let [rr, cc] of dirs) \\n            dfs(r + rr, c + cc);\\n    };\\n    \\n    while(!visited.has(N * N-1)) {\\n        visited.clear();\\n        dfs(0,0);\\n        time++;\\n    }\\n    \\n    return time - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 211324,
                "title": "python-three-methods-heap-binary-search-dfs-union-find",
                "content": "Heap O(N^2 log N)\\n```\\nclass Solution:\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        N = len(grid)\\n        seen = {(0, 0)}\\n        hp = [(grid[0][0], 0, 0)]\\n        ans = 0\\n        while hp:\\n            ele, r, c = heapq.heappop(hp)\\n            ans = max(ans, ele)\\n            if r == c == N-1:\\n                return ans\\n            for di in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                n_r, n_c = r + di[0], c + di[1]\\n                if 0 <= n_r < N and 0 <= n_c < N and (n_r, n_c) not in seen:\\n                    seen.add((n_r, n_c))\\n                    heapq.heappush(hp, (grid[n_r][n_c], n_r, n_c))\\n```\\n\\nBinary Search + DFS  O(N^2 log N)\\n```\\nclass Solution:\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.N = len(grid)\\n        self.grid = grid\\n        left, right = grid[0][0], self.N * self.N\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if self.check(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n        \\n    def check(self, ele):\\n        stack = [(0, 0)]\\n        seen = {(0, 0)}\\n        while stack:\\n            r, c = stack.pop()\\n            if r == c == self.N-1:\\n                return True\\n            for di in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                n_r, n_c = r + di[0], c + di[1]\\n                if 0 <= n_r < self.N and 0 <= n_c < self.N and (n_r, n_c) not in seen and self.grid[n_r][n_c] <= ele:\\n                    seen.add((n_r, n_c))\\n                    stack.append((n_r, n_c))\\n        return False\\n```\\n\\nUnion-find O(N^3)\\n```\\nclass DSU:\\n    def __init__(self, N):\\n        self.parents = list(range(N**2))\\n        self.rank = [1] * (N ** 2)\\n        \\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        if self.rank[root_x] < self.rank[root_y]:\\n            root_x, root_y = root_y, root_x\\n        self.parents[root_y] = root_x\\n        self.rank[root_x] += self.rank[root_y]\\n\\nclass Solution:\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        N = len(grid)\\n        location = {grid[i][j]: (i, j) for i in range(N) for j in range(N)}\\n        dsu = DSU(N)\\n        \\n        for t in range(N**2):\\n            r, c = location[t]\\n            for di in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                n_r, n_c = r + di[0], c + di[1]\\n                if 0 <= n_r < N and 0 <= n_c < N and grid[n_r][n_c] <= t:\\n                    dsu.union(r * N + c, n_r * N + n_c)\\n                    if dsu.find(0) == dsu.find(N**2-1):\\n                        return t\\n       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        N = len(grid)\\n        seen = {(0, 0)}\\n        hp = [(grid[0][0], 0, 0)]\\n        ans = 0\\n        while hp:\\n            ele, r, c = heapq.heappop(hp)\\n            ans = max(ans, ele)\\n            if r == c == N-1:\\n                return ans\\n            for di in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                n_r, n_c = r + di[0], c + di[1]\\n                if 0 <= n_r < N and 0 <= n_c < N and (n_r, n_c) not in seen:\\n                    seen.add((n_r, n_c))\\n                    heapq.heappush(hp, (grid[n_r][n_c], n_r, n_c))\\n```\n```\\nclass Solution:\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.N = len(grid)\\n        self.grid = grid\\n        left, right = grid[0][0], self.N * self.N\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if self.check(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n        \\n    def check(self, ele):\\n        stack = [(0, 0)]\\n        seen = {(0, 0)}\\n        while stack:\\n            r, c = stack.pop()\\n            if r == c == self.N-1:\\n                return True\\n            for di in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                n_r, n_c = r + di[0], c + di[1]\\n                if 0 <= n_r < self.N and 0 <= n_c < self.N and (n_r, n_c) not in seen and self.grid[n_r][n_c] <= ele:\\n                    seen.add((n_r, n_c))\\n                    stack.append((n_r, n_c))\\n        return False\\n```\n```\\nclass DSU:\\n    def __init__(self, N):\\n        self.parents = list(range(N**2))\\n        self.rank = [1] * (N ** 2)\\n        \\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        if self.rank[root_x] < self.rank[root_y]:\\n            root_x, root_y = root_y, root_x\\n        self.parents[root_y] = root_x\\n        self.rank[root_x] += self.rank[root_y]\\n\\nclass Solution:\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        N = len(grid)\\n        location = {grid[i][j]: (i, j) for i in range(N) for j in range(N)}\\n        dsu = DSU(N)\\n        \\n        for t in range(N**2):\\n            r, c = location[t]\\n            for di in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                n_r, n_c = r + di[0], c + di[1]\\n                if 0 <= n_r < N and 0 <= n_c < N and grid[n_r][n_c] <= t:\\n                    dsu.union(r * N + c, n_r * N + n_c)\\n                    if dsu.find(0) == dsu.find(N**2-1):\\n                        return t\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 348238,
                "title": "c-concise-beats-90-time-and-98-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int N = grid.size();\\n        bool vis[N*N+1];\\n        for(int i = 0; i <= N*N; i++) vis[i] = false;\\n        int r[] = {1,-1,0,0};\\n        int c[] = {0,0,1,-1};\\n        priority_queue< pair<int, int> >pq;\\n        pq.push({-grid[0][0], 0});\\n        while(!pq.empty()) {\\n            pair<int, int> t = pq.top();\\n            pq.pop();\\n            int i = t.second/N;\\n            int j = t.second%N;\\n            ans = max(ans, grid[i][j]);\\n            if(i == N-1 && j == N-1) break;\\n            for(int k = 0; k < 4; k++) {\\n                int ni = i + r[k];\\n                int nj = j + c[k];\\n                if(ni >= 0 && ni < N && nj >= 0 && nj < N && !vis[ni*N + nj]) {\\n                    vis[ni*N + nj] = true;\\n                    pq.push({-grid[ni][nj], ni*N + nj});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int N = grid.size();\\n        bool vis[N*N+1];\\n        for(int i = 0; i <= N*N; i++) vis[i] = false;\\n        int r[] = {1,-1,0,0};\\n        int c[] = {0,0,1,-1};\\n        priority_queue< pair<int, int> >pq;\\n        pq.push({-grid[0][0], 0});\\n        while(!pq.empty()) {\\n            pair<int, int> t = pq.top();\\n            pq.pop();\\n            int i = t.second/N;\\n            int j = t.second%N;\\n            ans = max(ans, grid[i][j]);\\n            if(i == N-1 && j == N-1) break;\\n            for(int k = 0; k < 4; k++) {\\n                int ni = i + r[k];\\n                int nj = j + c[k];\\n                if(ni >= 0 && ni < N && nj >= 0 && nj < N && !vis[ni*N + nj]) {\\n                    vis[ni*N + nj] = true;\\n                    pq.push({-grid[ni][nj], ni*N + nj});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676303,
                "title": "easy-c-solution-using-disjoint-sets-beats-80-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### Since we have to connect the first and last element, and connections keep happening dynamically, we come up with the possibility of Union Operation in Disjoint Sets. This is the intuition we use.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First use an unordered_map<int,pair<int,int>> and iterate through the grid. For each value grid[i][j], map it to its coordinates {i,j} and store in the map.\\n2. Dont forget the edge case : n=1 for which u return 0\\n3. Now set time = 0 and run a loop until grid[0][0] and grid[n-1][n-1] have the same parent.\\n4. For each time t, find the coordinates of the element having t as value using the map.\\n5. Now check in all 4 directions of that cell and if u get any other cell with value <= t, u perform Union Operation b/w the sets.\\n6. In this way, u keep chaining from first cell to last cell and break out when they have the same parent i.e. are connected.\\n7. The time hence found minus one is our required answer.\\n# Complexity\\n## - Time complexity: O(2n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. O(n^2) for the first traversal through the grid and mapping operation.\\n2. O(time * 4 alpha) for the while loop where time,in worst case can be = O(n^2). O(4 alpha) is for the Disjoint Set operations. So in worst case, while loop takes O(n^2 *4 alpha) time.\\n\\nHence TOTAL TIME COMPLEXITY, approximately = O(2n^2)\\n\\n\\n## - Space complexity: O(3n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. Since there are n^2 nodes, the size and parent vectors of Disjoint Sets will have O(n^2) space each.\\n2. Unordered_map will store all cells, so it will also occupy O(n^2) space.\\n\\nHence TOTAL SPACE COMPLEXITY, approximately = O(3n^2)\\n\\n# Code\\n```\\nclass DisjointSet\\n{\\n    vector<int> size;\\n    vector<int> parent;\\n\\npublic:\\n    DisjointSet(int n)\\n    {\\n        size.resize(n + 1, 1); // to take care of 1-based indexing as well\\n        parent.resize(n + 1);  // to take care of 1-based indexing as well\\n        for (int i = 1; i <= n; i++)\\n            parent[i] = i;\\n    }\\n\\n    int findParent(int u)\\n    {\\n        if (u == parent[u])\\n            return u;\\n        return parent[u] = findParent(parent[u]);\\n    }\\n\\n    void unionBySize(int u, int v)\\n    {\\n        int up_u = findParent(u);\\n        int up_v = findParent(v);\\n        if (up_u == up_v)\\n            return;\\n        if (size[up_u] > size[up_v])\\n        {\\n            parent[up_v] = up_u;\\n            size[up_u] += size[up_v];\\n        }\\n        else\\n        {\\n            parent[up_u] = up_v;\\n            size[up_v] += size[up_u];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        unordered_map<int,pair<int,int>> ump;\\n        int n = grid.size();\\n        if(n==1) return 0;\\n        DisjointSet ds(n*n);\\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<n; j++)\\n                ump[grid[i][j]]={i,j};\\n        int time = 0;\\n        while(ds.findParent(0)!=ds.findParent(n*n - 1))\\n        {\\n            auto node = ump[time];\\n            int x = node.first;\\n            int y = node.second;\\n            int dx[] = {-1,0,1,0};\\n            int dy[] = {0,-1,0,1};\\n            for(int i = 0; i<4; i++)\\n            {\\n                int nrow = x + dx[i];\\n                int ncol = y + dy[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<n && grid[nrow][ncol]<=time)\\n                    ds.unionBySize(nrow*n + ncol,x*n + y);\\n            }\\n            time++;\\n        }\\n        return time-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet\\n{\\n    vector<int> size;\\n    vector<int> parent;\\n\\npublic:\\n    DisjointSet(int n)\\n    {\\n        size.resize(n + 1, 1); // to take care of 1-based indexing as well\\n        parent.resize(n + 1);  // to take care of 1-based indexing as well\\n        for (int i = 1; i <= n; i++)\\n            parent[i] = i;\\n    }\\n\\n    int findParent(int u)\\n    {\\n        if (u == parent[u])\\n            return u;\\n        return parent[u] = findParent(parent[u]);\\n    }\\n\\n    void unionBySize(int u, int v)\\n    {\\n        int up_u = findParent(u);\\n        int up_v = findParent(v);\\n        if (up_u == up_v)\\n            return;\\n        if (size[up_u] > size[up_v])\\n        {\\n            parent[up_v] = up_u;\\n            size[up_u] += size[up_v];\\n        }\\n        else\\n        {\\n            parent[up_u] = up_v;\\n            size[up_v] += size[up_u];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        unordered_map<int,pair<int,int>> ump;\\n        int n = grid.size();\\n        if(n==1) return 0;\\n        DisjointSet ds(n*n);\\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<n; j++)\\n                ump[grid[i][j]]={i,j};\\n        int time = 0;\\n        while(ds.findParent(0)!=ds.findParent(n*n - 1))\\n        {\\n            auto node = ump[time];\\n            int x = node.first;\\n            int y = node.second;\\n            int dx[] = {-1,0,1,0};\\n            int dy[] = {0,-1,0,1};\\n            for(int i = 0; i<4; i++)\\n            {\\n                int nrow = x + dx[i];\\n                int ncol = y + dy[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<n && grid[nrow][ncol]<=time)\\n                    ds.unionBySize(nrow*n + ncol,x*n + y);\\n            }\\n            time++;\\n        }\\n        return time-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991823,
                "title": "dfs-binary-search-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    bool dfs(int x, int y, vector<vector<int>> &heights, int diff, vector<vector<bool>> &vis)\\n    {\\n        if (x < 0 || y < 0 || x >= heights.size() || y >= heights[0].size() || vis[x][y] == true)\\n            return false;\\n        vis[x][y] = true;\\n        if (heights[x][y] > diff)\\n            return false;\\n        if (x == heights.size() - 1 && y == heights[0].size() - 1)\\n            return true;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (dfs(x + dir[i][0], y + dir[i][1], heights, diff, vis))\\n                return true;\\n        }\\n        return false;\\n    }\\n    int swimInWater(vector<vector<int>> &heights)\\n    {\\n\\t/* *NOTE* RANGE =[0,2600] THESE CAN BE THE VALUES OF TIME(ans)\\n\\tDON\\'T GET CONFUSED THAT THERE IS NO SORTED ARRAY, THEN HOW CAN WE APPLY BINARY SEARCH.\\n\\tWE ARE APPLYING BINARY SEARCH ON RANGE*/\\n        {\\n            int left = 0, right = 2600, ans = 0, mid;\\n            while (left <= right)\\n            {\\n                mid = left + (right - left) / 2;\\n                vector<vector<bool>> vis(heights.size(), vector<bool>(heights[0].size(), false));\\n\\t\\t\\t\\t\\tif (dfs(0, 0, heights, mid, vis)) //WE ONLY NEED TO FIND IF THERE EXISTS A PATH IN WHICH ALL THE HEIGHTS ARE <= MID\\n                {\\n\\t\\t\\t\\t// IF SUCH PATH IS FOUND, THEN UPDATE THE ans, AND CHECK IF THERE EXISTS SOME SMALLER VALUE OF MID FOR WHICH THERE IS A PATH WITH ALL HEIGHTS <= NEW_MID.\\n\\t\\t\\t\\t// TO GET SAMLLER VALUE OF MID, REDUCE THE VALUE OF RIGHT, AND APPLY BINARY SEARCH ON LEFT SIDE OF RANGE.\\n                    right = mid - 1;\\n                    ans = mid;\\n                }\\n                else\\n                    left = mid + 1;\\n\\t\\t\\t\\t\\t// IF NO SUCH PATH FOUND, THEN WE NEED TO INCREASE THE TIME,\\n\\t\\t\\t\\t\\t// AND NOW THE TIME MUST BE > MID.\\n\\t\\t\\t\\t\\t// HENCE MOVE LEFT TO AHEAD OF MID AS LEFT=MID+1.\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    bool dfs(int x, int y, vector<vector<int>> &heights, int diff, vector<vector<bool>> &vis)\\n    {\\n        if (x < 0 || y < 0 || x >= heights.size() || y >= heights[0].size() || vis[x][y] == true)\\n            return false;\\n        vis[x][y] = true;\\n        if (heights[x][y] > diff)\\n            return false;\\n        if (x == heights.size() - 1 && y == heights[0].size() - 1)\\n            return true;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (dfs(x + dir[i][0], y + dir[i][1], heights, diff, vis))\\n                return true;\\n        }\\n        return false;\\n    }\\n    int swimInWater(vector<vector<int>> &heights)\\n    {\\n\\t/* *NOTE* RANGE =[0,2600] THESE CAN BE THE VALUES OF TIME(ans)\\n\\tDON\\'T GET CONFUSED THAT THERE IS NO SORTED ARRAY, THEN HOW CAN WE APPLY BINARY SEARCH.\\n\\tWE ARE APPLYING BINARY SEARCH ON RANGE*/\\n        {\\n            int left = 0, right = 2600, ans = 0, mid;\\n            while (left <= right)\\n            {\\n                mid = left + (right - left) / 2;\\n                vector<vector<bool>> vis(heights.size(), vector<bool>(heights[0].size(), false));\\n\\t\\t\\t\\t\\tif (dfs(0, 0, heights, mid, vis)) //WE ONLY NEED TO FIND IF THERE EXISTS A PATH IN WHICH ALL THE HEIGHTS ARE <= MID\\n                {\\n\\t\\t\\t\\t// IF SUCH PATH IS FOUND, THEN UPDATE THE ans, AND CHECK IF THERE EXISTS SOME SMALLER VALUE OF MID FOR WHICH THERE IS A PATH WITH ALL HEIGHTS <= NEW_MID.\\n\\t\\t\\t\\t// TO GET SAMLLER VALUE OF MID, REDUCE THE VALUE OF RIGHT, AND APPLY BINARY SEARCH ON LEFT SIDE OF RANGE.\\n                    right = mid - 1;\\n                    ans = mid;\\n                }\\n                else\\n                    left = mid + 1;\\n\\t\\t\\t\\t\\t// IF NO SUCH PATH FOUND, THEN WE NEED TO INCREASE THE TIME,\\n\\t\\t\\t\\t\\t// AND NOW THE TIME MUST BE > MID.\\n\\t\\t\\t\\t\\t// HENCE MOVE LEFT TO AHEAD OF MID AS LEFT=MID+1.\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712996,
                "title": "c-soln-using-priority-queue-commented",
                "content": "Time Complexity: O(n*m* log(n*m))\\n```\\nclass Solution {\\n    int N, M;\\n    int INF = 1e6;\\n    int xDir[4] = {-1, 1, 0, 0};\\n    int yDir[4] = {0, 0 , -1, 1};\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        N = grid.size(); M = grid[0].size();\\n        priority_queue<pair<int, pair<int,int>>> pq; //push {time, {row, col}}\\n        vector<vector<int>> time(N, vector<int> (M, INF)); //stores time for each cell\\n        \\n        time[0][0] = grid[0][0];\\n        pq.push({ (-1) * time[0][0], {0,0}}); //multiply with (-1) to use maxHeap as minHeap\\n        \\n        while(!pq.empty()) {\\n            int t = (-1) * pq.top().first;\\n            int r = pq.top().second.first;\\n            int c = pq.top().second.second;\\n            pq.pop();\\n            \\n\\t\\t\\t//Check all directions\\n            for(int i=0;i<4;i++) {\\n                int x = r + xDir[i], y = c + yDir[i];\\n                if(isValid(x, y) && grid[x][y] < time[x][y]) { // If the time can be further reduced? (Min value of time can be grid[x][y])\\n\\t\\t\\t\\t//Push in priority queue if we\\'re able to reduce the time.\\n                    if(t < grid[x][y]) { //If we\\'re coming from a cell, which has lesser time?\\n                        time[x][y] = grid[x][y];\\n                        pq.push({(-1) * time[x][y], {x, y}});\\n                    }    \\n                    else if(t < time[x][y]) { // If we\\'re coming from a cell which has greater time, time value of current cell will also be t.\\n                        time[x][y] = t;\\n                        pq.push({(-1) * time[x][y], {x, y}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n\\t\\t//Finally, we\\'ll have the least times for each cell\\n        return time[N-1][M-1];\\n    }\\n    \\n    bool isValid(int x, int y) {\\n        return x >= 0 && x < N && y >= 0 && y < M;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int N, M;\\n    int INF = 1e6;\\n    int xDir[4] = {-1, 1, 0, 0};\\n    int yDir[4] = {0, 0 , -1, 1};\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        N = grid.size(); M = grid[0].size();\\n        priority_queue<pair<int, pair<int,int>>> pq; //push {time, {row, col}}\\n        vector<vector<int>> time(N, vector<int> (M, INF)); //stores time for each cell\\n        \\n        time[0][0] = grid[0][0];\\n        pq.push({ (-1) * time[0][0], {0,0}}); //multiply with (-1) to use maxHeap as minHeap\\n        \\n        while(!pq.empty()) {\\n            int t = (-1) * pq.top().first;\\n            int r = pq.top().second.first;\\n            int c = pq.top().second.second;\\n            pq.pop();\\n            \\n\\t\\t\\t//Check all directions\\n            for(int i=0;i<4;i++) {\\n                int x = r + xDir[i], y = c + yDir[i];\\n                if(isValid(x, y) && grid[x][y] < time[x][y]) { // If the time can be further reduced? (Min value of time can be grid[x][y])\\n\\t\\t\\t\\t//Push in priority queue if we\\'re able to reduce the time.\\n                    if(t < grid[x][y]) { //If we\\'re coming from a cell, which has lesser time?\\n                        time[x][y] = grid[x][y];\\n                        pq.push({(-1) * time[x][y], {x, y}});\\n                    }    \\n                    else if(t < time[x][y]) { // If we\\'re coming from a cell which has greater time, time value of current cell will also be t.\\n                        time[x][y] = t;\\n                        pq.push({(-1) * time[x][y], {x, y}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n\\t\\t//Finally, we\\'ll have the least times for each cell\\n        return time[N-1][M-1];\\n    }\\n    \\n    bool isValid(int x, int y) {\\n        return x >= 0 && x < N && y >= 0 && y < M;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151038,
                "title": "2-approach-priority-queue-and-dfs-binary-search",
                "content": "``` \\nint swimInWater(vector<vector<int>>& grid){\\n        int n=grid.size();\\n        vector<vector<int>>v(n,vector<int>(n,INT_MAX));\\n        v[0][0]=grid[0][0];\\n        \\n        int R[4]={-1,0,0,1};\\n        int C[4]={0,-1,1,0};\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>q;\\n        q.push({v[0][0],{0,0}});\\n        \\n        while(!q.empty()){\\n            auto p=q.top();\\n            q.pop();\\n            int x=p.second.first;\\n            int y=p.second.second;\\n            int t=p.first;\\n            \\n            if(x==n-1 && y==n-1)\\n                return t;\\n            for(int k=0;k<4;k++){\\n                int a=x+R[k];\\n                int b=y+C[k];\\n                if(a>=0 && b>=0 && a<n && b<n){\\n                    int mx=max(t,grid[a][b]);\\n                    \\n                    if(mx<v[a][b]){\\n                        v[a][b]=mx;\\n                        q.push({v[a][b],{a,b}});\\n                        \\n                    }\\n                        \\n                }\\n            }\\n        }\\n        return n*n-1;\\n    }\\n\\t```\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t```\\n\\tvoid helper(vector<vector<int>>&grid,vector<vector<bool>>&vis,int mid,int i,int j,bool &ans)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid.size() || vis[i][j] || grid[i][j]>mid)\\n            return;\\n        \\n        if(i==grid.size()-1 && j==grid.size()-1)\\n            ans=true;\\n        \\n        vis[i][j]=true;\\n        helper(grid,vis,mid,i-1,j,ans);\\n        helper(grid,vis,mid,i,j-1,ans);\\n        helper(grid,vis,mid,i+1,j,ans);\\n        helper(grid,vis,mid,i,j+1,ans);\\n    }\\n    int swimInWater(vector<vector<int>>& grid) \\n    {\\n        int n=grid.size();\\n        int l=0,r=grid.size()*grid.size()-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            vector<vector<bool>>vis(n,vector<bool>(n,false));\\n            bool ans=false;\\n            helper(grid,vis,mid,0,0,ans);\\n            if(ans)\\n                r=mid-1;\\n            else\\n             l=mid+1;\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\nint swimInWater(vector<vector<int>>& grid){\\n        int n=grid.size();\\n        vector<vector<int>>v(n,vector<int>(n,INT_MAX));\\n        v[0][0]=grid[0][0];\\n        \\n        int R[4]={-1,0,0,1};\\n        int C[4]={0,-1,1,0};\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>>q;\\n        q.push({v[0][0],{0,0}});\\n        \\n        while(!q.empty()){\\n            auto p=q.top();\\n            q.pop();\\n            int x=p.second.first;\\n            int y=p.second.second;\\n            int t=p.first;\\n            \\n            if(x==n-1 && y==n-1)\\n                return t;\\n            for(int k=0;k<4;k++){\\n                int a=x+R[k];\\n                int b=y+C[k];\\n                if(a>=0 && b>=0 && a<n && b<n){\\n                    int mx=max(t,grid[a][b]);\\n                    \\n                    if(mx<v[a][b]){\\n                        v[a][b]=mx;\\n                        q.push({v[a][b],{a,b}});\\n                        \\n                    }\\n                        \\n                }\\n            }\\n        }\\n        return n*n-1;\\n    }\\n\\t```\n```\\n\\tvoid helper(vector<vector<int>>&grid,vector<vector<bool>>&vis,int mid,int i,int j,bool &ans)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid.size() || vis[i][j] || grid[i][j]>mid)\\n            return;\\n        \\n        if(i==grid.size()-1 && j==grid.size()-1)\\n            ans=true;\\n        \\n        vis[i][j]=true;\\n        helper(grid,vis,mid,i-1,j,ans);\\n        helper(grid,vis,mid,i,j-1,ans);\\n        helper(grid,vis,mid,i+1,j,ans);\\n        helper(grid,vis,mid,i,j+1,ans);\\n    }\\n    int swimInWater(vector<vector<int>>& grid) \\n    {\\n        int n=grid.size();\\n        int l=0,r=grid.size()*grid.size()-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            vector<vector<bool>>vis(n,vector<bool>(n,false));\\n            bool ans=false;\\n            helper(grid,vis,mid,0,0,ans);\\n            if(ans)\\n                r=mid-1;\\n            else\\n             l=mid+1;\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1892316,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    int vis[51][51] = {};\\n    int n;\\n    \\n    bool ok(vector<vector<int>>& grid, int mid, int i, int j){\\n        \\n        if(i<0 or i == n or j<0 or j == n or vis[i][j] or grid[i][j] > mid)\\n            return 0;\\n        \\n        if(i == n-1 and j == n-1) return 1;\\n        \\n        vis[i][j] = 1;\\n        \\n        for(auto& k: dirs){\\n            int ni = i+k[0], nj = j+k[1];\\n            \\n            if(ok(grid, mid, ni, nj)) return 1;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        \\n        n = grid.size();\\n        \\n        int lo = 0, hi = n*n-1, ans = -1;\\n        \\n        \\n        while(lo <= hi){\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(ok(grid, mid, 0, 0)){\\n                \\n                ans = mid;\\n                hi = mid-1;\\n                \\n            }\\n            else lo = mid+1;\\n            \\n            memset(vis,false,sizeof(vis));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    int vis[51][51] = {};\\n    int n;\\n    \\n    bool ok(vector<vector<int>>& grid, int mid, int i, int j){\\n        \\n        if(i<0 or i == n or j<0 or j == n or vis[i][j] or grid[i][j] > mid)\\n            return 0;\\n        \\n        if(i == n-1 and j == n-1) return 1;\\n        \\n        vis[i][j] = 1;\\n        \\n        for(auto& k: dirs){\\n            int ni = i+k[0], nj = j+k[1];\\n            \\n            if(ok(grid, mid, ni, nj)) return 1;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        \\n        n = grid.size();\\n        \\n        int lo = 0, hi = n*n-1, ans = -1;\\n        \\n        \\n        while(lo <= hi){\\n            int mid = lo+(hi-lo)/2;\\n            \\n            if(ok(grid, mid, 0, 0)){\\n                \\n                ans = mid;\\n                hi = mid-1;\\n                \\n            }\\n            else lo = mid+1;\\n            \\n            memset(vis,false,sizeof(vis));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286553,
                "title": "very-simple-c-solution",
                "content": "**Dijkstra\\'s algorithm**\\nHere the grid values correspond  to the edge values we consider during the a Dijkstra\\'s algorithm\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& grid,vector<vector<int>>&R,int n )\\n    {\\n        int dx[] = {0,-1,0,1};\\n        int dy[] = {-1,0,1,0};\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        pq.push({grid[0][0],0,0});\\n        while(!pq.empty())\\n        {\\n            vector<int>node = pq.top();\\n            pq.pop();\\n            if(R[node[1]][node[2]])\\n                continue;\\n            if(node[1] == n - 1 && node[2] == n - 1)\\n                return node[0];\\n            R[node[1]][node[2]] = 1;\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int x = node[1] + dx[i];\\n                int y = node[2] + dy[i];\\n                if(x >= 0 && x < n && y >= 0 && y < n)\\n                {\\n                    vector<int>next_node = {max(node[0],grid[x][y]),x,y};\\n                    pq.push(next_node);\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n        \\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>>R(n,vector<int>(n,0));\\n        return fun(grid,R,n);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& grid,vector<vector<int>>&R,int n )\\n    {\\n        int dx[] = {0,-1,0,1};\\n        int dy[] = {-1,0,1,0};\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        pq.push({grid[0][0],0,0});\\n        while(!pq.empty())\\n        {\\n            vector<int>node = pq.top();\\n            pq.pop();\\n            if(R[node[1]][node[2]])\\n                continue;\\n            if(node[1] == n - 1 && node[2] == n - 1)\\n                return node[0];\\n            R[node[1]][node[2]] = 1;\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int x = node[1] + dx[i];\\n                int y = node[2] + dy[i];\\n                if(x >= 0 && x < n && y >= 0 && y < n)\\n                {\\n                    vector<int>next_node = {max(node[0],grid[x][y]),x,y};\\n                    pq.push(next_node);\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n        \\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>>R(n,vector<int>(n,0));\\n        return fun(grid,R,n);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492413,
                "title": "python-simple-160ms",
                "content": "```\\nimport heapq\\nclass Solution(object):\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        r = len(grid)\\n        pq = [(0,(0,0))]\\n        visited = set()\\n        res = grid[0][0]\\n        while pq:\\n          currTime,currIndex = heapq.heappop(pq)\\n          if currIndex in visited:\\n            continue\\n          visited.add(currIndex)\\n          res = max(res,currTime)\\n          if currIndex == (r-1,r-1):\\n            return res\\n          for item in [(-1,0),(0,-1),(1,0),(0,1)]:\\n            newX = currIndex[0]+item[0]\\n            newY = currIndex[1]+item[1]\\n            if 0<=newX<r and 0<=newY<r:\\n              heapq.heappush(pq,(grid[newX][newY],(newX,newY)))\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution(object):\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        r = len(grid)\\n        pq = [(0,(0,0))]\\n        visited = set()\\n        res = grid[0][0]\\n        while pq:\\n          currTime,currIndex = heapq.heappop(pq)\\n          if currIndex in visited:\\n            continue\\n          visited.add(currIndex)\\n          res = max(res,currTime)\\n          if currIndex == (r-1,r-1):\\n            return res\\n          for item in [(-1,0),(0,-1),(1,0),(0,1)]:\\n            newX = currIndex[0]+item[0]\\n            newY = currIndex[1]+item[1]\\n            if 0<=newX<r and 0<=newY<r:\\n              heapq.heappush(pq,(grid[newX][newY],(newX,newY)))\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 151865,
                "title": "javascript-heap-solution",
                "content": "JS heap implementation here\\nhttps://gist.github.com/linfongi/9ead2e09e2f1330624a0514242285dbc\\nminified \\nhttps://gist.github.com/linfongi/643681694d027f7afea689d864cdc242\\n\\n```js\\nfunction swimInWater(grid) {\\n  const H = grid.length;\\n  const W = H && grid[0].length;\\n  const pq = new Heap((a, b) => grid[a[0]][a[1]]-grid[b[0]][b[1]]);\\n  const seen = [...Array(H)].map(r => Array(W).fill(false));\\n  let max = 0;\\n  \\n  pq.push([0, 0]);\\n  seen[0][0] = true;\\n  while (true) {\\n    const [r, c] = pq.pop();\\n    max = Math.max(max, grid[r][c]);\\n    if (r === H-1 && c === W-1) {\\n      return max;\\n    }\\n    \\n    for (let [dr, dc] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\\n      const rr = r+dr;\\n      const cc = c+dc;\\n      if (rr < 0 || cc < 0 || rr >= H || cc >= W || seen[rr][cc]) continue;\\n      seen[rr][cc] = true;\\n      pq.push([rr, cc]);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction swimInWater(grid) {\\n  const H = grid.length;\\n  const W = H && grid[0].length;\\n  const pq = new Heap((a, b) => grid[a[0]][a[1]]-grid[b[0]][b[1]]);\\n  const seen = [...Array(H)].map(r => Array(W).fill(false));\\n  let max = 0;\\n  \\n  pq.push([0, 0]);\\n  seen[0][0] = true;\\n  while (true) {\\n    const [r, c] = pq.pop();\\n    max = Math.max(max, grid[r][c]);\\n    if (r === H-1 && c === W-1) {\\n      return max;\\n    }\\n    \\n    for (let [dr, dc] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\\n      const rr = r+dr;\\n      const cc = c+dc;\\n      if (rr < 0 || cc < 0 || rr >= H || cc >= W || seen[rr][cc]) continue;\\n      seen[rr][cc] = true;\\n      pq.push([rr, cc]);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052062,
                "title": "c-dijkstra-s-algorithm-vs-greedy-unionfind-beats-98-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo wonder this is also a problem for finding the shortest path! Use Dijkstra\\'s algorithm.\\n\\n2nd approach uses union find & greedy. Then sort the edges wrt. weights. Take union until the cell (0, 0) connecting with the cell (n-1, n-1), and return the weight on the last edge!\\n\\n[Please turn on English subtitles if necessary]\\n[https://youtu.be/IkpRzCICL_g?si=B4CSph1_mygXYB2w](https://youtu.be/IkpRzCICL_g?si=B4CSph1_mygXYB2w)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAll methods solving  [1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/solutions/4049711/c-dijkstras-algorithm-vs-dfs-binary-search-vs-union-findpseudo-metric91-ms-beats-9893/) can be applied with slight modification.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2\\\\log n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using int2=array<int, 2>;\\n    int n;\\n    int to1D(int i, int j){\\n        return i*n+j;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        if (n==1) return 0;// edge case\\n        vector<int> dist(n*n, INT_MAX);\\n        dist[0]=0;\\n        vector<bool> visited(n*n, 0);\\n        int dir[][2]={{-1, 0},{1, 0},{0, -1},{0, 1}};\\n        priority_queue<int2, vector<int2>, greater<int2>> pq;\\n        pq.push({0, 0});// (dist, to1D(i, j))\\n\\n        while (!pq.empty()) {\\n            auto [d, idx] = pq.top();\\n            auto [i, j]=div(idx, n);\\n            pq.pop();\\n            if (d>dist[idx]) continue;\\n            if (idx==n*n-1) return d;\\n            visited[idx]=1;\\n            int d2;\\n            for (auto& dd: dir){\\n                int r=i+dd[0], s=j+dd[1];\\n                int&& idx2=to1D(r, s);\\n                if(r<0||r>=n||s<0||s>=n||visited[idx2]) continue;\\n                int w=max(grid[i][j], grid[r][s]);\\n                d2=max(d, w);\\n                if (d2 < dist[idx2]) {\\n                    dist[idx2] = d2;\\n                    pq.push({d2, idx2});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n# Code using UnionFind\\n\\n```\\n//Greedy & Union Find\\nclass UnionFind {    \\n    vector<int> root, rank;\\npublic:\\n    UnionFind(int n) : root(n), rank(n) {\\n        rank.assign(n, 1);\\n        iota(root.begin(), root.end(), 0);\\n    }\\n\\n    int Find(int x) {\\n        if (x == root[x]) return x;\\n        else return root[x] = Find(root[x]);\\n    }\\n\\n    void Union(int x, int y) {\\n        int rX = Find(x), rY = Find(y);\\n        if (rX == rY)  return;\\n        if (rank[rX] > rank[rY]) swap(rX, rY);   \\n        root[rX] = rY;\\n        if (rank[rX]==rank[rY]) rank[rY]++;\\n    }\\n};\\nclass Solution {\\npublic:\\n    using int3=tuple<int, int, int>; // (wt, v, w)\\n    int n;\\n    int to1D(int i, int j){\\n        return i*n+j;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        if (n==1) return 0;// edge case\\n        //Build edges (wt, v, w)\\n        vector<int3> edges;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if (i<n-1){\\n                    int wt=max(grid[i][j], grid[i+1][j]);\\n                    edges.emplace_back(wt, to1D(i, j), to1D(i+1, j));\\n                }\\n                if (j<n-1){\\n                    int wt=max(grid[i][j], grid[i][j+1]);\\n                    edges.emplace_back(wt, to1D(i, j), to1D(i, j+1));\\n                }\\n            }\\n        }\\n        sort(edges.begin(), edges.end());\\n        int V=n*n;\\n        UnionFind uf(V);\\n        for(auto& [wt, v, w]: edges){\\n            if (uf.Find(v)!=uf.Find(w))\\n                uf.Union(v, w);\\n            if (uf.Find(0)==uf.Find(V-1))\\n                return wt;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using int2=array<int, 2>;\\n    int n;\\n    int to1D(int i, int j){\\n        return i*n+j;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        if (n==1) return 0;// edge case\\n        vector<int> dist(n*n, INT_MAX);\\n        dist[0]=0;\\n        vector<bool> visited(n*n, 0);\\n        int dir[][2]={{-1, 0},{1, 0},{0, -1},{0, 1}};\\n        priority_queue<int2, vector<int2>, greater<int2>> pq;\\n        pq.push({0, 0});// (dist, to1D(i, j))\\n\\n        while (!pq.empty()) {\\n            auto [d, idx] = pq.top();\\n            auto [i, j]=div(idx, n);\\n            pq.pop();\\n            if (d>dist[idx]) continue;\\n            if (idx==n*n-1) return d;\\n            visited[idx]=1;\\n            int d2;\\n            for (auto& dd: dir){\\n                int r=i+dd[0], s=j+dd[1];\\n                int&& idx2=to1D(r, s);\\n                if(r<0||r>=n||s<0||s>=n||visited[idx2]) continue;\\n                int w=max(grid[i][j], grid[r][s]);\\n                d2=max(d, w);\\n                if (d2 < dist[idx2]) {\\n                    dist[idx2] = d2;\\n                    pq.push({d2, idx2});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n//Greedy & Union Find\\nclass UnionFind {    \\n    vector<int> root, rank;\\npublic:\\n    UnionFind(int n) : root(n), rank(n) {\\n        rank.assign(n, 1);\\n        iota(root.begin(), root.end(), 0);\\n    }\\n\\n    int Find(int x) {\\n        if (x == root[x]) return x;\\n        else return root[x] = Find(root[x]);\\n    }\\n\\n    void Union(int x, int y) {\\n        int rX = Find(x), rY = Find(y);\\n        if (rX == rY)  return;\\n        if (rank[rX] > rank[rY]) swap(rX, rY);   \\n        root[rX] = rY;\\n        if (rank[rX]==rank[rY]) rank[rY]++;\\n    }\\n};\\nclass Solution {\\npublic:\\n    using int3=tuple<int, int, int>; // (wt, v, w)\\n    int n;\\n    int to1D(int i, int j){\\n        return i*n+j;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        if (n==1) return 0;// edge case\\n        //Build edges (wt, v, w)\\n        vector<int3> edges;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if (i<n-1){\\n                    int wt=max(grid[i][j], grid[i+1][j]);\\n                    edges.emplace_back(wt, to1D(i, j), to1D(i+1, j));\\n                }\\n                if (j<n-1){\\n                    int wt=max(grid[i][j], grid[i][j+1]);\\n                    edges.emplace_back(wt, to1D(i, j), to1D(i, j+1));\\n                }\\n            }\\n        }\\n        sort(edges.begin(), edges.end());\\n        int V=n*n;\\n        UnionFind uf(V);\\n        for(auto& [wt, v, w]: edges){\\n            if (uf.Find(v)!=uf.Find(w))\\n                uf.Union(v, w);\\n            if (uf.Find(0)==uf.Find(V-1))\\n                return wt;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603996,
                "title": "binary-search-1-to-n-n-c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int check(vector<vector<int>> &g,int i,int j,int &n,int &mid,vector<vector<int>> &dp){\\n        if(i<0||j<0||i>=n||j>=n||g[i][j]<0||g[i][j]>mid)return 0;\\n        if(i==n-1&&j==n-1){\\n            return 1;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        g[i][j] *= -1;\\n        int  a = check(g,i+1,j,n,mid,dp)|check(g,i,j+1,n,mid,dp)|check(g,i-1,j,n,mid,dp)|check(g,i,j-1,n,mid,dp);\\n        g[i][j] *= -1;\\n        return dp[i][j] = a;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int mn = 0, mx = n*n,mid,ans;\\n        while(mn <= mx){\\n            vector<vector<int>> dp(n,vector<int>(n,-1));\\n            mid = (mx-mn)/2+mn;\\n            if(check(grid,0,0,n,mid,dp)){//if mid is possible and than try to minimize it\\n                ans = mid;\\n                mx = mid-1;\\n            }else{//if mid not ans than iniatilize mn to mid+1\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<vector<int>> &g,int i,int j,int &n,int &mid,vector<vector<int>> &dp){\\n        if(i<0||j<0||i>=n||j>=n||g[i][j]<0||g[i][j]>mid)return 0;\\n        if(i==n-1&&j==n-1){\\n            return 1;\\n        }\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        g[i][j] *= -1;\\n        int  a = check(g,i+1,j,n,mid,dp)|check(g,i,j+1,n,mid,dp)|check(g,i-1,j,n,mid,dp)|check(g,i,j-1,n,mid,dp);\\n        g[i][j] *= -1;\\n        return dp[i][j] = a;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int mn = 0, mx = n*n,mid,ans;\\n        while(mn <= mx){\\n            vector<vector<int>> dp(n,vector<int>(n,-1));\\n            mid = (mx-mn)/2+mn;\\n            if(check(grid,0,0,n,mid,dp)){//if mid is possible and than try to minimize it\\n                ans = mid;\\n                mx = mid-1;\\n            }else{//if mid not ans than iniatilize mn to mid+1\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961309,
                "title": "c-solution-using-disjoint-set-explained",
                "content": "# Intuition\\n\\nIntituitively, we can think of this problem as a graph problem. We can think of each cell as a node and the edges between two nodes as the time it takes to swim from one cell to another. \\n\\n# Approach\\n\\nIn this approach, you can represent each square in the grid as a separate element in a disjoint set. Initially, each element is in its own set. Then, you can iterate through the elements in the grid in ascending order of their elevation. For each element (i, j), you can check if any of its 4-directionally adjacent squares (i\\', j\\') have an elevation at most equal to the elevation of (i, j). If this is the case, you can union the sets that contain (i, j) and (i\\', j\\').\\n\\nYou can stop the iteration when the set containing the bottom right square (n - 1, n - 1) is also the set containing the top left square (0, 0). This means that there is a path from the top left square to the bottom right square with an elevation at most equal to the current elevation.\\n\\n# Complexity\\n- Time complexity: $$O(n^2 log(n^2))$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\nclass DisjointSet{\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n){\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1, 1);\\n        for(int i = 0; i < n; i++)\\n            parent[i] = i;\\n    }\\n    \\n    int find(int node){\\n        if(node == parent[node])\\n            return node;\\n        // path compression\\n        return parent[node] = find(parent[node]); \\n    }\\n    void unionByRank(int x, int y){\\n        // find ultimate parents\\n        int u = find(x);\\n        int v = find(y);\\n        \\n        if(u == v)\\n            return ;\\n        if(rank[v] < rank[u])\\n            parent[v] = u;\\n        else if(rank[u] < rank[v])\\n            parent[u] = v;\\n        else{\\n            parent[v] = u;\\n            rank[u]++;\\n        }\\n            \\n    }\\n    \\n    void unionBySize(int x, int y){\\n       // find ultimate parents of x and y\\n        int u = find(x);\\n        int v = find(y);\\n        // belong to same component\\n        if(u == v) return ;\\n        // size of u > v => u is the parent of v \\n        if(size[u] > size[v])\\n        {\\n            parent[v] = u;\\n            size[u] += size[v];\\n        }\\n        else\\n        {\\n            parent[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n      \\n};\\n\\nclass Solution {\\nprivate:\\n    bool isValid(int nrow, int ncol, int n){\\n        return nrow >= 0 && nrow < n && ncol >= 0 && ncol < n;\\n    }\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n * n);\\n\\n        int start = grid[0][0], end = grid[n - 1][n - 1];\\n\\n        int time[n*n];\\n        // (row, col) = row * n + col\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                time[grid[i][j]] = i*n + j;\\n        \\n        int dx[] = {-1, 0, 1, 0};\\n        int dy[] = {0, 1, 0, -1};\\n\\n        for(int t = 0; t < n * n; t++)\\n        {\\n            int row = time[t]/n;\\n            int col = time[t] % n;\\n\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + dx[i];\\n                int ncol = col + dy[i];\\n\\n                if(isValid(nrow, ncol, n) &&  grid[nrow][ncol] <= t) \\n                    ds.unionBySize(t, grid[nrow][ncol]);\\n            }\\n            if(ds.find(start) == ds.find(end)) return t;\\n        }\\n        return (n*n) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet{\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n){\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1, 1);\\n        for(int i = 0; i < n; i++)\\n            parent[i] = i;\\n    }\\n    \\n    int find(int node){\\n        if(node == parent[node])\\n            return node;\\n        // path compression\\n        return parent[node] = find(parent[node]); \\n    }\\n    void unionByRank(int x, int y){\\n        // find ultimate parents\\n        int u = find(x);\\n        int v = find(y);\\n        \\n        if(u == v)\\n            return ;\\n        if(rank[v] < rank[u])\\n            parent[v] = u;\\n        else if(rank[u] < rank[v])\\n            parent[u] = v;\\n        else{\\n            parent[v] = u;\\n            rank[u]++;\\n        }\\n            \\n    }\\n    \\n    void unionBySize(int x, int y){\\n       // find ultimate parents of x and y\\n        int u = find(x);\\n        int v = find(y);\\n        // belong to same component\\n        if(u == v) return ;\\n        // size of u > v => u is the parent of v \\n        if(size[u] > size[v])\\n        {\\n            parent[v] = u;\\n            size[u] += size[v];\\n        }\\n        else\\n        {\\n            parent[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n      \\n};\\n\\nclass Solution {\\nprivate:\\n    bool isValid(int nrow, int ncol, int n){\\n        return nrow >= 0 && nrow < n && ncol >= 0 && ncol < n;\\n    }\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n * n);\\n\\n        int start = grid[0][0], end = grid[n - 1][n - 1];\\n\\n        int time[n*n];\\n        // (row, col) = row * n + col\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                time[grid[i][j]] = i*n + j;\\n        \\n        int dx[] = {-1, 0, 1, 0};\\n        int dy[] = {0, 1, 0, -1};\\n\\n        for(int t = 0; t < n * n; t++)\\n        {\\n            int row = time[t]/n;\\n            int col = time[t] % n;\\n\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nrow = row + dx[i];\\n                int ncol = col + dy[i];\\n\\n                if(isValid(nrow, ncol, n) &&  grid[nrow][ncol] <= t) \\n                    ds.unionBySize(t, grid[nrow][ncol]);\\n            }\\n            if(ds.find(start) == ds.find(end)) return t;\\n        }\\n        return (n*n) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440920,
                "title": "c-priority-queue-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int directions[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> visited(n,vector<int>(n,0));\\n        int ans = 0;\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({grid[0][0],{0,0}});\\n        \\n        while(!pq.empty()){\\n            int i = pq.top().second.first;\\n            int j = pq.top().second.second;\\n            \\n            visited[i][j] = 1;\\n            \\n            ans = max(ans, pq.top().first);\\n            pq.pop();\\n            \\n            if(i == n-1 and j == n-1)               // Destination\\n                return ans;\\n            \\n            for(auto dir : directions){\\n                int newX = dir[0] + i;\\n                int newY = dir[1] + j;\\n                \\n                if(newX >= 0 and newX < n and newY >= 0 and newY < n and visited[newX][newY] == 0){\\n                    pq.push({grid[newX][newY],{newX, newY}});\\n                    visited[newX][newY] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int directions[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> visited(n,vector<int>(n,0));\\n        int ans = 0;\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({grid[0][0],{0,0}});\\n        \\n        while(!pq.empty()){\\n            int i = pq.top().second.first;\\n            int j = pq.top().second.second;\\n            \\n            visited[i][j] = 1;\\n            \\n            ans = max(ans, pq.top().first);\\n            pq.pop();\\n            \\n            if(i == n-1 and j == n-1)               // Destination\\n                return ans;\\n            \\n            for(auto dir : directions){\\n                int newX = dir[0] + i;\\n                int newY = dir[1] + j;\\n                \\n                if(newX >= 0 and newX < n and newY >= 0 and newY < n and visited[newX][newY] == 0){\\n                    pq.push({grid[newX][newY],{newX, newY}});\\n                    visited[newX][newY] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309086,
                "title": "js-simple-explained-dijkstra-s-heap",
                "content": "# 778. Swim in Rising Water \\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n## The Question\\nFor this article we will be covering Leetcode\\'s \\'[778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/)\\' question. An Advanced Graph question. \\n\\nQuestion:\\n\\n> You are given an `n x n` integer matrix `grid` where each value grid[i][j] represents the elevation at that point (i, j).\\n> The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\\n> Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\\n\\n![Example](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)\\n\\n![Example](https://assets.leetcode.com/users/images/a6d0e23a-316e-44b5-8ff9-0107698dd8a4_1658324375.6277692.gif)\\n\\n\\n```\\nInput: grid = [[0,2],[1,3]]\\nOutput: 3\\nExplanation:\\nAt time 0, you are in grid location (0, 0).\\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\\nYou cannot reach point (1, 1) until time 3.\\nWhen the depth of water is 3, we can swim anywhere inside the grid.\\n```\\n\\n## Explaining The Question\\nThis Question is rated **Hard**. Which is I would say is **inaccurate** if you\\'re familiar with [Dijkstra\\'s Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) or [Bellman-Ford\\'s Algorithm](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) or any other path finding algorithm, this question should be a **Medium**. If you\\'ve never encounters these algorithm, this will be impossible for the most part.\\n\\nMost people will study this algorithm in Higher Education. But if you\\'re like me, not having attending higher education mean\\'t I hadn\\'t the slightest clue about [Path Finding Algorithms](https://en.wikipedia.org/wiki/Path_finding_algorithm) in a Graph. For me I found this question impossible to solve until I read up that it was solved by [Dijkstra\\'s Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm).\\n\\nWe\\'re given a graph and we\\'re asked to to traverse the entire graph and hit all nodes using the shortest path. Which sounds a lot like [Kruskal\\'s Algorithm](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm), except we\\'re not creating a [Minimum Spanning Tree](https://en.wikipedia.org/wiki/Minimum_spanning_tree) but a [Shortest Path](https://en.wikipedia.org/wiki/Shortest_path) between `k` and all the other nodes.\\n\\nHow do you think [Google Maps](https://www.google.com/maps) knows the shortest distance between your house and your friend\\'s house? [Shortest Path](https://en.wikipedia.org/wiki/Shortest_path) algorithms like [Dijkstra\\'s Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) or [Bellman-Ford\\'s Algorithm](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) are used to find the shortest path between two locations. \\n\\nWhich is exactly what we\\'re going to do. Finding the shortest path between [0][0] and the bottom right of the board in the least amount of time. Where time is represented by the depth of water, which is the value of the item on the board. Meaning, at the depth of 10, we can travel all nodes that are <= 10. \\n\\n***\\n\\n##  Recommended Knowledge\\n1. [Graph Theory](https://en.wikipedia.org/wiki/Graph_theory#:~:text=In%20mathematics%2C%20graph%20theory%20is,also%20called%20links%20or%20lines)\\n2. [Dijkstra\\'s Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\\n4. [Path Finding Algorithms](https://en.wikipedia.org/wiki/Path_finding_algorithm)\\n5. [Matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics))\\n6. [Matrix Traversal](https://en.wikipedia.org/wiki/Matrix_traversal)\\n7. [Priority Queue](https://en.wikipedia.org/wiki/Priority_queue)\\n8. [Heap](https://en.wikipedia.org/wiki/Heap_(data_structure))\\n\\n## What do we know?\\n1. We\\'re given a `M x N` matrix.\\n2. We need to start at [0][0] and end at [M][N].\\n3. We need to find the shortest path between [0][0] and [M][N] as defined by the depth of water.\\n4. The depth of water is defined by the [x][y] value of the matrix.\\n5. We can only traverse to adjacent nodes if the depth of water is <= the depth of the node.\\n6. [M][N] is unique and always unique, never duplicating. \\n\\n## How we\\'re going to do it:\\n\\nWe\\'re going to use [Dijkstra\\'s Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) to find the shortest path between [0][0] and [M][N]. The shortest path is defined as the least amount of **time** it takes to travel from [0][0] to [M][N]. Where time is represented by the depth of water, which is the value of the item on the board.\\n\\nSo we\\'re going to re-frame the question, we\\'re instead going to traverse all the nodes in the matrix that requires the least amount of time until we reach [M][N]. So long as they\\'re in connection of where we currently can go, we\\'re going to keep traversing until we reach [M][N].\\n\\n1. We\\'re going to create a `Priority Queue` to hold all the nodes that we need to traverse. As in [Dijkstra\\'s Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm), we\\'re going to use a `Priority Queue` to hold the nodes that we need to traverse first. (Cheapest node first)\\n2. We\\'re also going to keep note of a global `time_passed` variable. What this value will be, is the highest value of depth of water we visited. \\n3. As we know we\\'re starting with [0][0], we\\'re going to add it to the `Priority Queue` with a value of whatever is at that location (Normally 0, but don\\'t make that assumption).\\n4. We will then begin performing [Dijkstra\\'s Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm), where we remove the \\'cheapest\\' item from the [Min-Heap](https://en.wikipedia.org/wiki/Min-heap) and set the `time_passed` to the value of the item. We\\'re also going to add the coordinates of the item to a `visited` Set().\\n5. We will also attempt to add the node above, left, right and below to the Min-Heap if they are within the bounds of the matrix and un-visited. Where we set the priority as the nodes value. Being the value of the item on the board. Thus, we\\'ve achieved the effect by only ever travelling the least amount of time. \\n6. We repeat this until we reach [M][N]. At this point, we know what was the highest value of depth of water we visited and so that is our answer.\\n7. \\n## Big O Notation:\\n* Time Complexity:   *O(**E * (log V)**)* | Right so this is a little confusing. [Dijkstra\\'s Algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) is a **O(ElogV)** algorithm. Where **E** is the number of edges in the graph and **V** is the number of vertices in the graph. Which is represented by *O(**V^2**)*, as in the worst case, every node and it\\'s neighbors will be added and removed from the [Min-Heap](https://en.wikipedia.org/wiki/Min-heap) multiple times. I believe, the real time complexity of this algorithm is **O( (M x N) * (Log V))**. Where **M** is the number of rows and **N** is the number of columns and the **Log V** is the number of nodes that will be inserted and removed from the heap in logarithmic time. Thus we can reduce this to **O(n (log n))**.\\n* Space Complexity: *O(**M x N**)* | As in the worst case, we\\'re going to store the entire matrix within our Min-Heap or our visited set. \\n\\nIs my analysis wrong? Potentially, feel free to correct me. \\uD83D\\uDE01\\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/751415785/)\\n\\n\\n***\\n<iframe src=\"https://leetcode.com/playground/8NQd4XgG/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe> \\n\\n# The Solution\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n var swimInWater = function (grid) {\\n\\n    // We\\'re going to use Dijkstra\\'s algorithm to complete\\n    // to get from 0,0 to the end of the grid (Bottom Right).\\n    // We need to get from top left to bottom right \\n    // in the shortest path. (Shortest in terms of the [i][x] value)\\n\\n    // What this mean\\'s is we will travel to the cheapest possible\\n    // operation relative the time passed. So at time 0, we can \\n    // only travel to other 0 nodes that are in connection. Once it\\'s 1, \\n    // we can travel to other 1 nodes that are in connection. And so on and so on.\\n\\n    // So instead of us manually passing time, we can use the value of the grid\\n    // to determine the time and the place within the queue. \\n\\n    // So, we add to a min-heap the [x,y] coordinates of the item in the grid\\n    // by the [x][y] value. So a grid item that is within reach and has a value\\n    // of 0, will be added to the top of the min-heap.\\n\\n\\n    let   time_passed = 0;                       // Max Priority of [Node] Visited\\n    const visit_set   = new Set();               // Don\\'t want to visit the same node twice\\n    const min_heap    = new MinPriorityQueue();  // [i][x] = Priority / Time Passed\\n\\n    // Min Maxes of grid and directions we can travel to.\\n    // Don\\'t want to go out of bounds do we. \\n    const max_rows   = grid.length - 1;\\n    const max_cols   = grid[0].length - 1;\\n    const directions = [\\n        [1, 0],\\n        [-1, 0],\\n        [0, 1],\\n        [0, -1],\\n    ];\\n\\n    // So we firstly start off with the item in the top left corner.\\n    // Which could be any value. So we enqueue it as the first place to visit.\\n    min_heap.enqueue([0, 0], grid[0][0]); // Go to 0,0 at the cost of 0\\n\\n    // While the heap is not empty and we have not reached the end of the grid.\\n    // Keep adding to the min-heap. \\n    while (min_heap.size()) {\\n\\n        // Pop node of our min heap.\\n        const node   = min_heap.dequeue();\\n        const cost   = node.priority;       // Time required to reach this node.\\n        const [x, y] = node.element;        // Coordinates of this node.\\n\\n        // So we have not been here yet, mark it\\n        // We know this because, we never visit the same node twice. \\n        visit_set.add(grid[x][y]);\\n\\n        // So we\\'re not at the target,\\n        // increment our result if we have increased.\\n        // As this mean\\'s our shortest path time has increased and\\n        // thus so is the time passed. \\n        time_passed = Math.max(cost, time_passed);\\n\\n        // Are we at the target (Bottom Right of Grid)?\\n        // Meaning, we have found the shortest path?\\n        if (x === max_rows && y === max_cols) return time_passed;\\n\\n        // Add the directions to the queue\\n        // if we have not already been there.\\n        //   ^\\n        // < x >\\n        //   v\\n        for (const direction of directions) {\\n            let [new_x, new_y]  = direction;\\n            new_x               += x; // Update x\\n            new_y               += y; // Update y\\n\\n            // Is it out of bounds? Or we have visited it before?\\n            // If so, skip over this direction.\\n            if (new_x > max_rows || new_y > max_cols || new_x < 0 || new_y < 0 || visit_set.has(grid[new_x][new_y])) continue;\\n\\n            // Enqueue the new node. Where the priority is the cost of the path.\\n            // Meaning, that once the time has become {x} we can visit it next. \\n            min_heap.enqueue([new_x, new_y], grid[new_x][new_y]);\\n        }\\n    }    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nInput: grid = [[0,2],[1,3]]\\nOutput: 3\\nExplanation:\\nAt time 0, you are in grid location (0, 0).\\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\\nYou cannot reach point (1, 1) until time 3.\\nWhen the depth of water is 3, we can swim anywhere inside the grid.\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\n var swimInWater = function (grid) {\\n\\n    // We\\'re going to use Dijkstra\\'s algorithm to complete\\n    // to get from 0,0 to the end of the grid (Bottom Right).\\n    // We need to get from top left to bottom right \\n    // in the shortest path. (Shortest in terms of the [i][x] value)\\n\\n    // What this mean\\'s is we will travel to the cheapest possible\\n    // operation relative the time passed. So at time 0, we can \\n    // only travel to other 0 nodes that are in connection. Once it\\'s 1, \\n    // we can travel to other 1 nodes that are in connection. And so on and so on.\\n\\n    // So instead of us manually passing time, we can use the value of the grid\\n    // to determine the time and the place within the queue. \\n\\n    // So, we add to a min-heap the [x,y] coordinates of the item in the grid\\n    // by the [x][y] value. So a grid item that is within reach and has a value\\n    // of 0, will be added to the top of the min-heap.\\n\\n\\n    let   time_passed = 0;                       // Max Priority of [Node] Visited\\n    const visit_set   = new Set();               // Don\\'t want to visit the same node twice\\n    const min_heap    = new MinPriorityQueue();  // [i][x] = Priority / Time Passed\\n\\n    // Min Maxes of grid and directions we can travel to.\\n    // Don\\'t want to go out of bounds do we. \\n    const max_rows   = grid.length - 1;\\n    const max_cols   = grid[0].length - 1;\\n    const directions = [\\n        [1, 0],\\n        [-1, 0],\\n        [0, 1],\\n        [0, -1],\\n    ];\\n\\n    // So we firstly start off with the item in the top left corner.\\n    // Which could be any value. So we enqueue it as the first place to visit.\\n    min_heap.enqueue([0, 0], grid[0][0]); // Go to 0,0 at the cost of 0\\n\\n    // While the heap is not empty and we have not reached the end of the grid.\\n    // Keep adding to the min-heap. \\n    while (min_heap.size()) {\\n\\n        // Pop node of our min heap.\\n        const node   = min_heap.dequeue();\\n        const cost   = node.priority;       // Time required to reach this node.\\n        const [x, y] = node.element;        // Coordinates of this node.\\n\\n        // So we have not been here yet, mark it\\n        // We know this because, we never visit the same node twice. \\n        visit_set.add(grid[x][y]);\\n\\n        // So we\\'re not at the target,\\n        // increment our result if we have increased.\\n        // As this mean\\'s our shortest path time has increased and\\n        // thus so is the time passed. \\n        time_passed = Math.max(cost, time_passed);\\n\\n        // Are we at the target (Bottom Right of Grid)?\\n        // Meaning, we have found the shortest path?\\n        if (x === max_rows && y === max_cols) return time_passed;\\n\\n        // Add the directions to the queue\\n        // if we have not already been there.\\n        //   ^\\n        // < x >\\n        //   v\\n        for (const direction of directions) {\\n            let [new_x, new_y]  = direction;\\n            new_x               += x; // Update x\\n            new_y               += y; // Update y\\n\\n            // Is it out of bounds? Or we have visited it before?\\n            // If so, skip over this direction.\\n            if (new_x > max_rows || new_y > max_cols || new_x < 0 || new_y < 0 || visit_set.has(grid[new_x][new_y])) continue;\\n\\n            // Enqueue the new node. Where the priority is the cost of the path.\\n            // Meaning, that once the time has become {x} we can visit it next. \\n            min_heap.enqueue([new_x, new_y], grid[new_x][new_y]);\\n        }\\n    }    \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2209191,
                "title": "easy-c-code-bfs-with-min-heap-simple-to-understand",
                "content": "int swimInWater(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        priority_queue<pair<int, pair<int, int>>, vector< pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        vector<vector<bool>>vis(n,vector<bool>(n,false));\\n        \\n        pq.push({grid[0][0],{0,0}});\\n        \\n        vis[0][0]=true;\\n        \\n        int ans=grid[0][0];\\n        \\n        while(!pq.empty())\\n        {\\n            int value=pq.top().first;\\n            int i=pq.top().second.first;\\n            int j=pq.top().second.second;\\n            pq.pop();\\n            \\n            ans=max(ans,value);\\n            \\n            //base case\\n            if(i==n-1 and j==n-1)\\n            {\\n                break;\\n            }\\n            int dx[4]={0,1,0,-1};\\n            int dy[4]={1,0,-1,0};\\n            \\n            for(int idx=0;idx<4;idx++)\\n            {\\n                int newi=i+dx[idx];\\n                int newj=j+dy[idx];\\n                \\n                if(newi>=0 and newi<n and newj>=0 and newj<n and !vis[newi][newj])\\n                {\\n                    \\n                    vis[newi][newj]=true;\\n                    \\n                    pq.push({grid[newi][newj],{newi,newj}});\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "int swimInWater(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        priority_queue<pair<int, pair<int, int>>, vector< pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        vector<vector<bool>>vis(n,vector<bool>(n,false));\\n        \\n        pq.push({grid[0][0],{0,0}});\\n        \\n        vis[0][0]=true;\\n        \\n        int ans=grid[0][0];\\n        \\n        while(!pq.empty())\\n        {\\n            int value=pq.top().first;\\n            int i=pq.top().second.first;\\n            int j=pq.top().second.second;\\n            pq.pop();\\n            \\n            ans=max(ans,value);\\n            \\n            //base case\\n            if(i==n-1 and j==n-1)\\n            {\\n                break;\\n            }\\n            int dx[4]={0,1,0,-1};\\n            int dy[4]={1,0,-1,0};\\n            \\n            for(int idx=0;idx<4;idx++)\\n            {\\n                int newi=i+dx[idx];\\n                int newj=j+dy[idx];\\n                \\n                if(newi>=0 and newi<n and newj>=0 and newj<n and !vis[newi][newj])\\n                {\\n                    \\n                    vis[newi][newj]=true;\\n                    \\n                    pq.push({grid[newi][newj],{newi,newj}});\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1880824,
                "title": "java-priority-queue-based-modified-dijkstra-solution",
                "content": "```\\nclass Solution {\\n    class Node {\\n\\t\\tprivate int row;\\n\\t\\tprivate int col;\\n\\t\\tprivate int height;\\n\\n\\t\\tNode(int row, int col, int height) {\\n\\t\\t\\tthis.row = row;\\n\\t\\t\\tthis.col = col;\\n\\t\\t\\tthis.height = height;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int dijkstra(int graph[][]) {\\n\\t\\tboolean[][] visited = new boolean[graph.length][graph[0].length];\\n\\t\\tPriorityQueue<Node> priorityQueue = new PriorityQueue<>((v1, v2) -> v1.height - v2.height);\\n\\t\\tpriorityQueue.add(new Node(0, 0, graph[0][0]));\\n\\t\\tvisited[0][0] = true;\\n\\t\\tint[][] direction = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n\\t\\tint minHeight = 0;\\n\\t\\twhile (!priorityQueue.isEmpty()) {\\n\\t\\t\\tNode node = priorityQueue.poll();\\n\\t\\t\\tif (node.row == graph.length - 1 && node.col == graph[0].length - 1) {\\n\\t\\t\\t\\tminHeight = node.height;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int[] next : direction) {\\n\\t\\t\\t\\tint nextRow = node.row + next[0];\\n\\t\\t\\t\\tint nextCol = node.col + next[1];\\n\\t\\t\\t\\tif (nextRow < 0 || nextRow == graph.length || nextCol < 0 || nextCol == graph.length\\n\\t\\t\\t\\t\\t\\t|| visited[nextRow][nextCol]) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited[nextRow][nextCol] = true;\\n\\t\\t\\t\\tpriorityQueue.add(new Node(nextRow, nextCol, Math.max(node.height, graph[nextRow][nextCol])));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn minHeight;\\n\\t}\\n    public int swimInWater(int[][] grid) {\\n        return dijkstra(grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class Node {\\n\\t\\tprivate int row;\\n\\t\\tprivate int col;\\n\\t\\tprivate int height;\\n\\n\\t\\tNode(int row, int col, int height) {\\n\\t\\t\\tthis.row = row;\\n\\t\\t\\tthis.col = col;\\n\\t\\t\\tthis.height = height;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int dijkstra(int graph[][]) {\\n\\t\\tboolean[][] visited = new boolean[graph.length][graph[0].length];\\n\\t\\tPriorityQueue<Node> priorityQueue = new PriorityQueue<>((v1, v2) -> v1.height - v2.height);\\n\\t\\tpriorityQueue.add(new Node(0, 0, graph[0][0]));\\n\\t\\tvisited[0][0] = true;\\n\\t\\tint[][] direction = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n\\t\\tint minHeight = 0;\\n\\t\\twhile (!priorityQueue.isEmpty()) {\\n\\t\\t\\tNode node = priorityQueue.poll();\\n\\t\\t\\tif (node.row == graph.length - 1 && node.col == graph[0].length - 1) {\\n\\t\\t\\t\\tminHeight = node.height;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int[] next : direction) {\\n\\t\\t\\t\\tint nextRow = node.row + next[0];\\n\\t\\t\\t\\tint nextCol = node.col + next[1];\\n\\t\\t\\t\\tif (nextRow < 0 || nextRow == graph.length || nextCol < 0 || nextCol == graph.length\\n\\t\\t\\t\\t\\t\\t|| visited[nextRow][nextCol]) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited[nextRow][nextCol] = true;\\n\\t\\t\\t\\tpriorityQueue.add(new Node(nextRow, nextCol, Math.max(node.height, graph[nextRow][nextCol])));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn minHeight;\\n\\t}\\n    public int swimInWater(int[][] grid) {\\n        return dijkstra(grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401529,
                "title": "python-dijkstra-a-hybrid-explained-100-97",
                "content": "The basis for my solution is traditional Dijkstra (bfs + priority queue). Where things get different is that I used Manhattan distance to the finish as a heuristic to sort between paths of equal cost. Using this heuristic prioritizes expanding nodes which are closer to the finish, which means the on average fewer nodes need to be expanded to find the solution. Only using this heuristic to differentiate between equal costs paths means that I retain the property that the solution is found the first time the finish is removed from the queue. Because the heuristic isn\\'t used all the time though, this algorithm is a hybrid of Dijkstra and A*.\\n\\nThe reason using a heuristic this way is effective is that the cost function for a path often doesn\\'t change when a node is added to a path. Furthermore, every time a node is expanded up to 3 neighbor nodes are added to the queue. This means that it is very easy for there to be several nodes in the queue with equal cost. Using a heuristic to differentiate between these paths allows the algorithm to expand nodes in a smarter order. The heuristic I used was very fast/easy to calculate, but primarily helps after the max cost vertex is already included in the path. Because of this I think it extremely likely that there is a more effective heuristic out there.\\n\\nThe other optimization I want to note is that I used the original grid to store which nodes were visited. Had I wanted to I could have stored the negative path cost to reach each square in the grid and actually found the least-effort path to each square from (0, 0), but that wasn\\'t necessary for this problem. (This works because grid[i][j] is guaranteed to be non-negative)\\n\\nVertices: V = n^2\\nEdges: E = 4(n - 2)^2 + 12n - 4 ~= 4n^2\\nTime Complexity: O((V + E) logV) = O(n^2 log(n))\\nSpace Complexity: O(V) = O(n^2)\\nFirst Run: 56 ms/14.5 MB : 100%/97%\\n\\n\\'\\'\\'\\n\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        #Djikstra/A* (note that there is always a solution, so \"while True\" is acceptable)\\n        n = len(grid) - 1\\n        queue = [(grid[n][n], 2*n, 0, 0)] # (time, distance from finish, row, col)\\n        while True:\\n            #Get the Next Item From the Queue\\n            t, d, i, j = heappop(queue)\\n            \\n            #Check if the Finish Was Reached\\n            if d == 0:\\n                #Return the Time\\n                return t\\n            \\n            #Check if the Square is Still Unvisited\\n            if grid[i][j] > -1:\\n                #Update the Time for the Current Path\\n                t = max(t, grid[i][j])\\n\\t\\t\\t\\t\\n                #Mark the Square as Visited\\n                grid[i][j] = -1\\n                \\n                #Visit the Currently Unvisited Neighbors\\n                if i > 0 and grid[i - 1][j] > -1:\\n                    #Move Up\\n                    heappush(queue, (t, d + 1, i - 1, j))\\n                if j > 0 and grid[i][j - 1] > -1:\\n                    #Move Left\\n                    heappush(queue, (t, d + 1, i, j - 1))\\n                if i < n and grid[i + 1][j] > -1:\\n                    #Move Down\\n                    heappush(queue, (t, d - 1, i + 1, j))\\n                if j < n and grid[i][j + 1] > -1:\\n                    #Move Right\\n                    heappush(queue, (t, d - 1, i, j + 1))\\n\\'\\'\\'\\n\\nMy code for this solution is essentially identical to my code for 1632: Path with Minimum Effort. So much so that I copy/tweaked the code itself, and then reused the explanation I gave for that puzzle in this post:\\nhttps://leetcode.com/problems/path-with-minimum-effort/discuss/1400904/python-djikstraa-hybrid-explained-100-faster\\n\\n![image](https://assets.leetcode.com/users/images/d6d95f93-5f2c-40d7-9b31-736570ce9074_1628871140.149151.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "The basis for my solution is traditional Dijkstra (bfs + priority queue). Where things get different is that I used Manhattan distance to the finish as a heuristic to sort between paths of equal cost. Using this heuristic prioritizes expanding nodes which are closer to the finish, which means the on average fewer nodes need to be expanded to find the solution. Only using this heuristic to differentiate between equal costs paths means that I retain the property that the solution is found the first time the finish is removed from the queue. Because the heuristic isn\\'t used all the time though, this algorithm is a hybrid of Dijkstra and A*.\\n\\nThe reason using a heuristic this way is effective is that the cost function for a path often doesn\\'t change when a node is added to a path. Furthermore, every time a node is expanded up to 3 neighbor nodes are added to the queue. This means that it is very easy for there to be several nodes in the queue with equal cost. Using a heuristic to differentiate between these paths allows the algorithm to expand nodes in a smarter order. The heuristic I used was very fast/easy to calculate, but primarily helps after the max cost vertex is already included in the path. Because of this I think it extremely likely that there is a more effective heuristic out there.\\n\\nThe other optimization I want to note is that I used the original grid to store which nodes were visited. Had I wanted to I could have stored the negative path cost to reach each square in the grid and actually found the least-effort path to each square from (0, 0), but that wasn\\'t necessary for this problem. (This works because grid[i][j] is guaranteed to be non-negative)\\n\\nVertices: V = n^2\\nEdges: E = 4(n - 2)^2 + 12n - 4 ~= 4n^2\\nTime Complexity: O((V + E) logV) = O(n^2 log(n))\\nSpace Complexity: O(V) = O(n^2)\\nFirst Run: 56 ms/14.5 MB : 100%/97%\\n\\n\\'\\'\\'\\n\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        #Djikstra/A* (note that there is always a solution, so \"while True\" is acceptable)\\n        n = len(grid) - 1\\n        queue = [(grid[n][n], 2*n, 0, 0)] # (time, distance from finish, row, col)\\n        while True:\\n            #Get the Next Item From the Queue\\n            t, d, i, j = heappop(queue)\\n            \\n            #Check if the Finish Was Reached\\n            if d == 0:\\n                #Return the Time\\n                return t\\n            \\n            #Check if the Square is Still Unvisited\\n            if grid[i][j] > -1:\\n                #Update the Time for the Current Path\\n                t = max(t, grid[i][j])\\n\\t\\t\\t\\t\\n                #Mark the Square as Visited\\n                grid[i][j] = -1\\n                \\n                #Visit the Currently Unvisited Neighbors\\n                if i > 0 and grid[i - 1][j] > -1:\\n                    #Move Up\\n                    heappush(queue, (t, d + 1, i - 1, j))\\n                if j > 0 and grid[i][j - 1] > -1:\\n                    #Move Left\\n                    heappush(queue, (t, d + 1, i, j - 1))\\n                if i < n and grid[i + 1][j] > -1:\\n                    #Move Down\\n                    heappush(queue, (t, d - 1, i + 1, j))\\n                if j < n and grid[i][j + 1] > -1:\\n                    #Move Right\\n                    heappush(queue, (t, d - 1, i, j + 1))\\n\\'\\'\\'\\n\\nMy code for this solution is essentially identical to my code for 1632: Path with Minimum Effort. So much so that I copy/tweaked the code itself, and then reused the explanation I gave for that puzzle in this post:\\nhttps://leetcode.com/problems/path-with-minimum-effort/discuss/1400904/python-djikstraa-hybrid-explained-100-faster\\n\\n![image](https://assets.leetcode.com/users/images/d6d95f93-5f2c-40d7-9b31-736570ce9074_1628871140.149151.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1340640,
                "title": "javascript-easy-bfs-92ms-85-45",
                "content": "```\\nconst dx = [-1, 1, 0, 0], dy = [0, 0, -1, 1];\\nconst swimInWater = (g) => {\\n    let n = g.length;\\n    let dis = initialize2DArrayNew(n, n); // save min distance from (0, 0) -> (i, j)\\n    dis[0][0] = g[0][0];\\n\\t// only need to find a path from (0, 0) -> (n - 1, n - 1); no need find a path for each i, j, so no need two for loop\\n    let q = [[0, 0]];\\n    while (q.length) {\\n        let cur = q.shift();\\n        let [x, y] = cur;\\n        for (let k = 0; k < 4; k++) {\\n            let xx = x + dx[k];\\n            let yy = y + dy[k];\\n            if (xx < 0 || xx >= n || yy < 0 || yy >= n) continue;\\n            if (Math.max(g[xx][yy], dis[x][y]) < dis[xx][yy]) { // bfs update min for each i/xx, j/yy\\n                dis[xx][yy] = Math.max(g[xx][yy], dis[x][y]);\\n                q.push([xx, yy]);\\n            }\\n        }\\n    }\\n    return dis[n - 1][n - 1];\\n};\\n\\nconst initialize2DArrayNew = (m, n) => {\\n    let data = [];\\n    for (let i = 0; i < m; i++) {\\n        let tmp = new Array(n).fill(Number.MAX_SAFE_INTEGER);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst dx = [-1, 1, 0, 0], dy = [0, 0, -1, 1];\\nconst swimInWater = (g) => {\\n    let n = g.length;\\n    let dis = initialize2DArrayNew(n, n); // save min distance from (0, 0) -> (i, j)\\n    dis[0][0] = g[0][0];\\n\\t// only need to find a path from (0, 0) -> (n - 1, n - 1); no need find a path for each i, j, so no need two for loop\\n    let q = [[0, 0]];\\n    while (q.length) {\\n        let cur = q.shift();\\n        let [x, y] = cur;\\n        for (let k = 0; k < 4; k++) {\\n            let xx = x + dx[k];\\n            let yy = y + dy[k];\\n            if (xx < 0 || xx >= n || yy < 0 || yy >= n) continue;\\n            if (Math.max(g[xx][yy], dis[x][y]) < dis[xx][yy]) { // bfs update min for each i/xx, j/yy\\n                dis[xx][yy] = Math.max(g[xx][yy], dis[x][y]);\\n                q.push([xx, yy]);\\n            }\\n        }\\n    }\\n    return dis[n - 1][n - 1];\\n};\\n\\nconst initialize2DArrayNew = (m, n) => {\\n    let data = [];\\n    for (let i = 0; i < m; i++) {\\n        let tmp = new Array(n).fill(Number.MAX_SAFE_INTEGER);\\n        data.push(tmp);\\n    }\\n    return data;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1286488,
                "title": "c-heap-based-solution-explained-100-time-75-space",
                "content": "Nice problem that we can solve in multiple ways; I preferred to follow a Dijsktra-like approach, keeping track of our current frontier as we \"unlock\" new cells as neighbours.\\n\\nWe might have used a queue for a more BFS-ish approach, but I preferred (and found more efficient) to proceed with a min heap.\\n\\nTo do so, I created a number of support variables at class level:\\n* `frontier` is our aforementioned heap;\\n* `xs` and `ys` is where we will store the column and row position of each specific value (remember that all cells have unique, non negative values);\\n* `len` will store the size of the sides of the grid.\\n\\nWe will then first of all give a value to `len` in our main function, then proceed to declare some more variables:\\n* `res` is our accumulator variable, used to keep track of the highest level we passed in order to reach the target, initialised with the value of `grid[0][0]`;\\n* `squareLen` is, as the name implies, the square of `len`;\\n* `curr` is the currently accessible node we will parse later;\\n* `target` is the value of the cell we want to reach.\\n\\nWe will at this point assign empty arrays of the proper size to be the space in memory pointed by both `xs` and `ys`, then  decrease `len` by `1` - having already created our arrays and computed `squareLen`, this will just make things easier later, like now, when we want to assign `grid[len][len]` (the value of the last cell) to `target`.\\n\\nWe can now indulge in trivially populating `xs` and `ys`: each cell slot will receive the coordinate of the matching column and row, respectively, so that, say, if you wish to know where the value of `3` is located, you will have to just to read `xs[3]` and `ys[3]` to know those coordinates.\\n\\nNow, time to start our exploration - first of all marking the initial cell as explored (remember we just set above `res` to its value, so we know we have to wait at least `grid[0][0]` ticks before starting) and push its original value into `frontier`.\\n\\nNow, we will have a main loop that will:\\n* extract the minimum value in the heap and put it into `curr`;\\n* pop the minimum out of the heap;\\n* update `res`, to be the maximim between its current value and `curr`;\\n* call `addNeighbours`;\\n* `break` as soon as we can reach `target`.\\n\\n`addNeighbours` is a very simple helper that, passed the current value to check and the `grid`, will get the coordinates of that value from `xs` and `ys`, then proceed to check if the valid (ie: in the grid) neighbours are still unvisited (ie: not negative) and, in case, add them to the `frontier` and mark them.\\n\\nOnce done, we can return the maximim between `res` and `target` (in case this was the highest value found so far) :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    // support variables\\n    priority_queue<int, vector<int>, greater<int>> frontier;\\n    int *xs, *ys, len;\\n    void addNeighbours(int curr, vector<vector<int>>& grid) {\\n        // getting the curernt coordinates\\n        int cx = xs[curr], cy = ys[curr];\\n        // adding the on board neighbours if previously unmarked\\n        if (cx && grid[cy][cx - 1] >= 0) {\\n            frontier.push(grid[cy][cx - 1]);\\n            grid[cy][cx - 1] = -1;\\n        } \\n        if (cy && grid[cy - 1][cx] >= 0) {\\n            frontier.push(grid[cy - 1][cx]);\\n            grid[cy - 1][cx] = -1;\\n        } \\n        if (cx < len && grid[cy][cx + 1] >= 0) {\\n            frontier.push(grid[cy][cx + 1]);\\n            grid[cy][cx + 1] = -1;\\n        } \\n        if (cy < len && grid[cy + 1][cx] >= 0) {\\n            frontier.push(grid[cy + 1][cx]);\\n            grid[cy + 1][cx] = -1;\\n        } \\n    }\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        len = grid[0].size();\\n        // support variables\\n        int res = grid[0][0], squareLen = len * len, curr, target;\\n        xs =  new int[squareLen], ys = new int[squareLen];\\n        len--;\\n        target = grid[len][len];\\n        // populating xs and ys\\n        for (int cy = 0; cy <= len; cy++) {\\n            for (int cx = 0, n; cx <= len; cx++) {\\n                n = grid[cy][cx], xs[n] = cx, ys[n] = cy;\\n            }\\n        }\\n        // marking the beginning as used and initialising the frontier\\n        grid[0][0] = -1;\\n        frontier.push(res);\\n        // expanding the frontier\\n        while (true) {\\n            // getting the currently new visitable node\\n            curr = frontier.top();\\n            frontier.pop();\\n            // updating res\\n            res = max(res, curr);\\n            // adding the current neighbours\\n            addNeighbours(curr, grid);\\n            // quitting when we reach the target\\n            if (frontier.top() == target) break;\\n        }\\n        return max(res, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nclass Solution {\\n    // support variables\\n    priority_queue<int, vector<int>, greater<int>> frontier;\\n    int *xs, *ys, len;\\n    void addNeighbours(int curr, vector<vector<int>>& grid) {\\n        // getting the curernt coordinates\\n        int cx = xs[curr], cy = ys[curr];\\n        // adding the on board neighbours if previously unmarked\\n        if (cx && grid[cy][cx - 1] >= 0) {\\n            frontier.push(grid[cy][cx - 1]);\\n            grid[cy][cx - 1] = -1;\\n        } \\n        if (cy && grid[cy - 1][cx] >= 0) {\\n            frontier.push(grid[cy - 1][cx]);\\n            grid[cy - 1][cx] = -1;\\n        } \\n        if (cx < len && grid[cy][cx + 1] >= 0) {\\n            frontier.push(grid[cy][cx + 1]);\\n            grid[cy][cx + 1] = -1;\\n        } \\n        if (cy < len && grid[cy + 1][cx] >= 0) {\\n            frontier.push(grid[cy + 1][cx]);\\n            grid[cy + 1][cx] = -1;\\n        } \\n    }\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        len = grid[0].size();\\n        // support variables\\n        int res = grid[0][0], squareLen = len * len, curr, target;\\n        xs =  new int[squareLen], ys = new int[squareLen];\\n        len--;\\n        target = grid[len][len];\\n        // populating xs and ys\\n        for (int cy = 0; cy <= len; cy++) {\\n            for (int cx = 0, n; cx <= len; cx++) {\\n                n = grid[cy][cx], xs[n] = cx, ys[n] = cy;\\n            }\\n        }\\n        // marking the beginning as used and initialising the frontier\\n        grid[0][0] = -1;\\n        frontier.push(res);\\n        // expanding the frontier\\n        while (true) {\\n            // getting the currently new visitable node\\n            curr = frontier.top();\\n            frontier.pop();\\n            // updating res\\n            res = max(res, curr);\\n            // adding the current neighbours\\n            addNeighbours(curr, grid);\\n            // quitting when we reach the target\\n            if (frontier.top() == target) break;\\n        }\\n        return max(res, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285430,
                "title": "swim-in-rising-water-dijkstra-algorithm",
                "content": "This problem is about finding the shortest path from top-left point i.e, index (0,0) to bottom-right point i.e, index (n-1, n-1). [**Dijkstra\\u2019s algorithm**](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) can be used to solve the single-source shortest-paths problem on a weighted, directed graph G = (V,E) for the case in which all edge weights are positive.\\n\\nIn our case the weight between two nodes is the max of cell value of both nodes. For example if Node1 has a value of 3 and Node2 has a value of 2, then weight between those will be max(3,2) = 3. Also when moving from one vertex/Node to another, instead of adding their weights we will take only the maximum one because travel time is given as 0.\\n\\nWe will use Min Heap to implement Dijkstra algorithm. For Min Heap we will use **heapq** module. We will also create a class to represent a Node.\\n```\\nimport heapq\\n\\nclass Node:\\n    def __init__(self, x, y, val):\\n\\t\\t# (x,y) position of node in grid\\n        self.x = x\\n        self.y = y\\n\\t\\t\\n\\t\\t# value of node. Will represent its weight\\n        self.val = val\\n\\t\\t\\n\\t# We need this so that we can push Node object into out heap\\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\n# Just a wrapper to use heapq in Object Oriented Programming way\\nclass MinHeap:\\n    def __init__(self):\\n        self.heap = []\\n    def push(self, node):\\n        heapq.heappush(self.heap, node)\\n    def pop(self) -> Node:\\n        return heapq.heappop(self.heap)\\n```\\n\\nNow to start solving we will push the Node at index (0,0) to Min Heap and start our loop.\\nWe will also keep a 2D List to track which Nodes we have already visited. You can instead make this a property of Node if you want instead of creating a new List.\\nWe will loop until we have not visited the Node at (n-1, n-1).\\nWe will first pop out the minimum Node from Min Heap; update our time taken and push all its **unvisited** neighbors into the heap.\\nFinally our time taken will be the result\\n```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\t\\t\\n\\t\\t# Our 2D List to track which Nodes have been visited\\n        visited = [[False]*n for _ in range(n)]\\n\\t\\t\\n\\t\\t# Time taken. Initialised to grid[0][0] because we can\\'t move from\\n\\t\\t# there unless time taken is atleast same as this\\n\\t\\t# Suppose grid[0][0] is 3, then we cannot move unless t = 3\\n        t = grid[0][0]\\n\\t\\t\\n\\t\\t# Our MinHeap with initial element as Node at index (0,0)\\n        minHeap = MinHeap()\\n        minHeap.push(Node(0, 0, grid[0][0]))\\n\\t\\t\\n\\t\\t# Loop until we haven\\'t visited the Node at (n-1, n-1)\\n        while not visited[n-1][n-1] and minHeap:\\n\\t\\t\\t# Get the Node with smallest value\\n            node = minHeap.pop()\\n\\t\\t\\t\\n\\t\\t\\t# Update its visited status\\n            visited[node.x][node.y] = True\\n\\t\\t\\t\\n\\t\\t\\t# Update the time taken\\n            t = max(t, node.val)\\n\\t\\t\\t\\n\\t\\t\\t# Push the neighbors of current node into the heap\\n\\t\\t\\t# Make sure to check their visited status first\\n            if node.y > 0 and not visited[node.x][node.y-1]: # Above Node\\n                minHeap.push(Node(node.x, node.y-1, grid[node.x][node.y-1]))\\n\\t\\t\\t\\t\\n            if node.x > 0 and not visited[node.x-1][node.y]: # Left Node\\n                minHeap.push(Node(node.x-1, node.y, grid[node.x-1][node.y]))\\n\\t\\t\\t\\t\\n            if node.y < n-1 and not visited[node.x][node.y+1]: # Below Node\\n                minHeap.push(Node(node.x, node.y+1, grid[node.x][node.y+1]))\\n\\t\\t\\t\\t\\n            if node.x < n-1 and not visited[node.x+1][node.y]: # Right Node\\n                minHeap.push(Node(node.x+1, node.y, grid[node.x+1][node.y]))\\n\\t\\t\\t\\t\\n        return t\\n```\\n\\nThis is my First post in Leetcode, if you think I made some mistakes, do let me know.\\nThanks",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nclass Node:\\n    def __init__(self, x, y, val):\\n\\t\\t# (x,y) position of node in grid\\n        self.x = x\\n        self.y = y\\n\\t\\t\\n\\t\\t# value of node. Will represent its weight\\n        self.val = val\\n\\t\\t\\n\\t# We need this so that we can push Node object into out heap\\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\n# Just a wrapper to use heapq in Object Oriented Programming way\\nclass MinHeap:\\n    def __init__(self):\\n        self.heap = []\\n    def push(self, node):\\n        heapq.heappush(self.heap, node)\\n    def pop(self) -> Node:\\n        return heapq.heappop(self.heap)\\n```\n```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\t\\t\\n\\t\\t# Our 2D List to track which Nodes have been visited\\n        visited = [[False]*n for _ in range(n)]\\n\\t\\t\\n\\t\\t# Time taken. Initialised to grid[0][0] because we can\\'t move from\\n\\t\\t# there unless time taken is atleast same as this\\n\\t\\t# Suppose grid[0][0] is 3, then we cannot move unless t = 3\\n        t = grid[0][0]\\n\\t\\t\\n\\t\\t# Our MinHeap with initial element as Node at index (0,0)\\n        minHeap = MinHeap()\\n        minHeap.push(Node(0, 0, grid[0][0]))\\n\\t\\t\\n\\t\\t# Loop until we haven\\'t visited the Node at (n-1, n-1)\\n        while not visited[n-1][n-1] and minHeap:\\n\\t\\t\\t# Get the Node with smallest value\\n            node = minHeap.pop()\\n\\t\\t\\t\\n\\t\\t\\t# Update its visited status\\n            visited[node.x][node.y] = True\\n\\t\\t\\t\\n\\t\\t\\t# Update the time taken\\n            t = max(t, node.val)\\n\\t\\t\\t\\n\\t\\t\\t# Push the neighbors of current node into the heap\\n\\t\\t\\t# Make sure to check their visited status first\\n            if node.y > 0 and not visited[node.x][node.y-1]: # Above Node\\n                minHeap.push(Node(node.x, node.y-1, grid[node.x][node.y-1]))\\n\\t\\t\\t\\t\\n            if node.x > 0 and not visited[node.x-1][node.y]: # Left Node\\n                minHeap.push(Node(node.x-1, node.y, grid[node.x-1][node.y]))\\n\\t\\t\\t\\t\\n            if node.y < n-1 and not visited[node.x][node.y+1]: # Below Node\\n                minHeap.push(Node(node.x, node.y+1, grid[node.x][node.y+1]))\\n\\t\\t\\t\\t\\n            if node.x < n-1 and not visited[node.x+1][node.y]: # Right Node\\n                minHeap.push(Node(node.x+1, node.y, grid[node.x+1][node.y]))\\n\\t\\t\\t\\t\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285158,
                "title": "java-priorityqueue",
                "content": "```\\nclass Solution {\\n    private int[][] directions = {{-1,0}, {1,0}, {0,-1}, {0,1}};\\n    public int swimInWater(int[][] grid) {\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a,b) -> (a[2] - b[2]));\\n        boolean visited[][] = new boolean[grid.length][grid.length];\\n        visited[0][0] = true;\\n        minHeap.add(new int[]{0, 0, grid[0][0]});\\n        while(!minHeap.isEmpty()){\\n            int currentNode[] = minHeap.poll();\\n            for(int direction[] : directions){\\n                int X = currentNode[0] + direction[0];\\n                int Y = currentNode[1] + direction[1]; \\n                if(X<0 || Y<0 || X>=grid.length || Y>=grid.length){\\n                    continue;\\n                }\\n                if(!visited[X][Y]){\\n                    visited[X][Y] = true;\\n                    int time = Math.max(currentNode[2], grid[X][Y]);\\n                    if(X==grid.length-1 && Y==grid.length-1){\\n                        return time;\\n                    }else {\\n                        minHeap.add(new int[]{X,Y, time});\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private int[][] directions = {{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 1285061,
                "title": "c-simple-and-clean-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(int x, int y) {\\n        return x >= 0 && x < n && y >= 0 && y < m;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> values(n, vector<int>(m, INT_MAX));\\n        queue<pair<int, int>> q;\\n        \\n        values[0][0] = grid[0][0];\\n        q.push({0, 0});\\n        \\n        while (!q.empty()) {\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n            \\n            for (int i = 0; i < 4; i++) {\\n                int curr_x = x + x_points[i], curr_y = y + y_points[i];\\n                \\n                if (!isValid(curr_x, curr_y)) \\n                    continue;\\n                \\n                int next = max(values[x][y], grid[curr_x][curr_y]);\\n                \\n                if (next < values[curr_x][curr_y]) {\\n                    q.push({curr_x, curr_y});\\n                    values[curr_x][curr_y] = next;\\n                }\\n            }\\n        }\\n        return values[n-1][m-1];\\n    }\\n    \\nprivate:\\n    vector<int> x_points = {-1, 1, 0, 0}, y_points = {0, 0, 1, -1};\\n    int n, m;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int x, int y) {\\n        return x >= 0 && x < n && y >= 0 && y < m;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> values(n, vector<int>(m, INT_MAX));\\n        queue<pair<int, int>> q;\\n        \\n        values[0][0] = grid[0][0];\\n        q.push({0, 0});\\n        \\n        while (!q.empty()) {\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n            \\n            for (int i = 0; i < 4; i++) {\\n                int curr_x = x + x_points[i], curr_y = y + y_points[i];\\n                \\n                if (!isValid(curr_x, curr_y)) \\n                    continue;\\n                \\n                int next = max(values[x][y], grid[curr_x][curr_y]);\\n                \\n                if (next < values[curr_x][curr_y]) {\\n                    q.push({curr_x, curr_y});\\n                    values[curr_x][curr_y] = next;\\n                }\\n            }\\n        }\\n        return values[n-1][m-1];\\n    }\\n    \\nprivate:\\n    vector<int> x_points = {-1, 1, 0, 0}, y_points = {0, 0, 1, -1};\\n    int n, m;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023071,
                "title": "my-java-solution-using-1-dfs-2-unionfind-3-dijkstra",
                "content": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        \\n        //  1. dfs\\n        int time = 0;\\n        int length = grid.length;\\n        Set<Integer> set = new HashSet<>();\\n        while (!set.contains(length * length - 1)) {\\n            set.clear();\\n            dfs(grid, 0, 0, time, set);\\n            time += 1;\\n        }\\n        return time - 1;\\n    }\\n    \\n    public void dfs(int [][] grid, int i, int j, int time, Set<Integer> set) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] > time || set.contains(i * grid.length + j))\\n            return;\\n        set.add(i * grid.length + j);\\n        dfs(grid, i+1, j, time, set);\\n        dfs(grid, i-1, j, time, set);\\n        dfs(grid, i, j+1, time, set);\\n        dfs(grid, i, j-1, time, set);\\n        */\\n        \\n        // 2. union find\\n        int time = 0;\\n        int n = grid.length;\\n        UnionFind uf = new UnionFind(n * n);\\n        while (!uf.isConnected(0, n*n - 1)) {\\n            for (int i=0; i<n; i++) {\\n                for (int j=0; j<n; j++) {\\n                    if (grid[i][j] > time)\\n                        continue;\\n                    if (i < n - 1 && grid[i+1][j] <= time)\\n                        uf.union(i * n + j, i * n + j + n);\\n                    if (j < n - 1 && grid[i][j+1] <= time)\\n                        uf.union(i * n + j, i * n + j + 1);\\n                }\\n            }\\n            time += 1;\\n        }\\n        return time -1;\\n    }\\n}\\n\\nclass UnionFind {\\n    int size;\\n    int component;\\n    int [] parent;\\n    int [] rank;\\n    public UnionFind(int n) {\\n        if (n <= 0)\\n            throw new IllegalArgumentException(\"Cannot be less than or equal to 0\");\\n        size = n;\\n        component = n;\\n        parent = new int [n];\\n        rank = new int [n];\\n        for (int i=0; i<n; i++)\\n            parent[i] = i;\\n    }\\n    \\n    public int find(int p) {\\n        while (p != parent[p]) {\\n            parent[p] = parent[parent[p]];\\n            p = parent[p];\\n        }\\n        return p;\\n    }\\n    \\n    public void union(int p, int q) {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if (rootP == rootQ)\\n            return;\\n        if (rank[rootP] < rank[rootQ]) {\\n            parent[rootP] = rootQ;\\n        }\\n        else {\\n            parent[rootQ] = rootP;\\n            if (rank[rootP] == rank[rootQ])\\n                rank[rootP] += 1;\\n        }\\n        component -= 1;\\n    }\\n    \\n    public boolean isConnected(int p, int q) {\\n        return find(p) == find(q);\\n    }\\n    \\n        \\n        // 3 .djikstras algorithm\\n        int n = grid.length;\\n        int time = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> grid[a/n][a%n] - grid[b/n][b%n]);\\n        pq.add(0);\\n        boolean [][] visited = new boolean [n][n];\\n        int [][] directions = new int [][] {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n        while (!pq.isEmpty()) {\\n            int pos = pq.remove();\\n            int row = pos / n;\\n            int col = pos % n;\\n            time = Math.max(time, grid[row][col]);\\n            if (row == n - 1 && col == n - 1)\\n                return time;\\n            for (int [] dir : directions) {\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if (newRow < 0 || newRow >= n || newCol < 0 || newCol >= n || visited[newRow][newCol])\\n                    continue;\\n                visited[newRow][newCol] = true;\\n                pq.add(newRow * n + newCol);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        \\n        //  1. dfs\\n        int time = 0;\\n        int length = grid.length;\\n        Set<Integer> set = new HashSet<>();\\n        while (!set.contains(length * length - 1)) {\\n            set.clear();\\n            dfs(grid, 0, 0, time, set);\\n            time += 1;\\n        }\\n        return time - 1;\\n    }\\n    \\n    public void dfs(int [][] grid, int i, int j, int time, Set<Integer> set) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] > time || set.contains(i * grid.length + j))\\n            return;\\n        set.add(i * grid.length + j);\\n        dfs(grid, i+1, j, time, set);\\n        dfs(grid, i-1, j, time, set);\\n        dfs(grid, i, j+1, time, set);\\n        dfs(grid, i, j-1, time, set);\\n        */\\n        \\n        // 2. union find\\n        int time = 0;\\n        int n = grid.length;\\n        UnionFind uf = new UnionFind(n * n);\\n        while (!uf.isConnected(0, n*n - 1)) {\\n            for (int i=0; i<n; i++) {\\n                for (int j=0; j<n; j++) {\\n                    if (grid[i][j] > time)\\n                        continue;\\n                    if (i < n - 1 && grid[i+1][j] <= time)\\n                        uf.union(i * n + j, i * n + j + n);\\n                    if (j < n - 1 && grid[i][j+1] <= time)\\n                        uf.union(i * n + j, i * n + j + 1);\\n                }\\n            }\\n            time += 1;\\n        }\\n        return time -1;\\n    }\\n}\\n\\nclass UnionFind {\\n    int size;\\n    int component;\\n    int [] parent;\\n    int [] rank;\\n    public UnionFind(int n) {\\n        if (n <= 0)\\n            throw new IllegalArgumentException(\"Cannot be less than or equal to 0\");\\n        size = n;\\n        component = n;\\n        parent = new int [n];\\n        rank = new int [n];\\n        for (int i=0; i<n; i++)\\n            parent[i] = i;\\n    }\\n    \\n    public int find(int p) {\\n        while (p != parent[p]) {\\n            parent[p] = parent[parent[p]];\\n            p = parent[p];\\n        }\\n        return p;\\n    }\\n    \\n    public void union(int p, int q) {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if (rootP == rootQ)\\n            return;\\n        if (rank[rootP] < rank[rootQ]) {\\n            parent[rootP] = rootQ;\\n        }\\n        else {\\n            parent[rootQ] = rootP;\\n            if (rank[rootP] == rank[rootQ])\\n                rank[rootP] += 1;\\n        }\\n        component -= 1;\\n    }\\n    \\n    public boolean isConnected(int p, int q) {\\n        return find(p) == find(q);\\n    }\\n    \\n        \\n        // 3 .djikstras algorithm\\n        int n = grid.length;\\n        int time = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> grid[a/n][a%n] - grid[b/n][b%n]);\\n        pq.add(0);\\n        boolean [][] visited = new boolean [n][n];\\n        int [][] directions = new int [][] {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n        while (!pq.isEmpty()) {\\n            int pos = pq.remove();\\n            int row = pos / n;\\n            int col = pos % n;\\n            time = Math.max(time, grid[row][col]);\\n            if (row == n - 1 && col == n - 1)\\n                return time;\\n            for (int [] dir : directions) {\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if (newRow < 0 || newRow >= n || newCol < 0 || newCol >= n || visited[newRow][newCol])\\n                    continue;\\n                visited[newRow][newCol] = true;\\n                pq.add(newRow * n + newCol);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616178,
                "title": "c-super-clean-code-priority-queue-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    #define t tuple<int,int,int> \\n    int maxx=0;\\n    int swimInWater(vector<vector<int>>& a) {\\n      int n=a.size();\\n      priority_queue<t,vector<t>,greater<t>>q;\\n      q.push(make_tuple(a[0][0],0,0));\\n        int i=0,j=0;\\n        while(!q.empty())\\n        {\\n            t top=q.top();\\n            q.pop();\\n            int e=get<0>(top);\\n            int i=get<1>(top);\\n            int j=get<2>(top);\\n            maxx=max(maxx,e);\\n            if(i==n-1 && j==n-1)break;\\n            a[i][j]=-1;\\n            if(i-1>=0 && a[i-1][j]!=-1 )q.push(make_tuple(a[i-1][j],i-1,j));\\n            if(i+1<n && a[i+1][j]!=-1)q.push(make_tuple(a[i+1][j],i+1,j));\\n            if(j-1>=0 && a[i][j-1]!=-1)q.push(make_tuple(a[i][j-1],i,j-1));\\n            if(j+1<n && a[i][j+1]!=-1)q.push(make_tuple(a[i][j+1],i,j+1));\\n            \\n        }\\n      \\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define t tuple<int,int,int> \\n    int maxx=0;\\n    int swimInWater(vector<vector<int>>& a) {\\n      int n=a.size();\\n      priority_queue<t,vector<t>,greater<t>>q;\\n      q.push(make_tuple(a[0][0],0,0));\\n        int i=0,j=0;\\n        while(!q.empty())\\n        {\\n            t top=q.top();\\n            q.pop();\\n            int e=get<0>(top);\\n            int i=get<1>(top);\\n            int j=get<2>(top);\\n            maxx=max(maxx,e);\\n            if(i==n-1 && j==n-1)break;\\n            a[i][j]=-1;\\n            if(i-1>=0 && a[i-1][j]!=-1 )q.push(make_tuple(a[i-1][j],i-1,j));\\n            if(i+1<n && a[i+1][j]!=-1)q.push(make_tuple(a[i+1][j],i+1,j));\\n            if(j-1>=0 && a[i][j-1]!=-1)q.push(make_tuple(a[i][j-1],i,j-1));\\n            if(j+1<n && a[i][j+1]!=-1)q.push(make_tuple(a[i][j+1],i,j+1));\\n            \\n        }\\n      \\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395255,
                "title": "c-binary-search-dfs-beats-100-100",
                "content": "```\\npublic class Solution \\n{\\n    public int SwimInWater(int[][] grid) \\n    {\\n        var low = grid[0][0];\\n        var high = low;\\n        for (var r = 0; r < grid.Length; r++)\\n        {\\n            var row = grid[r];\\n            for (var c = 0; c < row.Length; c++)\\n            {\\n                high = Math.Max(row[c], high);\\n            }\\n        }\\n        \\n        while (low < high)\\n        {\\n            var mid = low + (high - low) / 2;\\n            \\n            if (PathExists(grid, mid, 0, 0, new bool[grid.Length, grid[0].Length]))\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return low;\\n    }\\n    \\n    private bool PathExists(int[][] grid, int waterLevel, int r, int c, bool[,] visited)\\n    {   \\n        if (r > grid.Length - 1 || r < 0 || c > grid[0].Length - 1 || c < 0)\\n            return false;\\n        \\n        if (grid[r][c] > waterLevel || visited[r, c] == true)\\n            return false;\\n        \\n        if (r == grid.Length - 1 && c == grid[0].Length - 1)\\n            return true;\\n        \\n        visited[r, c] = true;\\n        \\n        var directions = new (int x, int y)[] { (1, 0), (0, 1), (-1, 0), (0, -1) };\\n        \\n        foreach (var dir in directions)\\n        {\\n            if (PathExists(grid, waterLevel, r + dir.x, c + dir.y, visited))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int SwimInWater(int[][] grid) \\n    {\\n        var low = grid[0][0];\\n        var high = low;\\n        for (var r = 0; r < grid.Length; r++)\\n        {\\n            var row = grid[r];\\n            for (var c = 0; c < row.Length; c++)\\n            {\\n                high = Math.Max(row[c], high);\\n            }\\n        }\\n        \\n        while (low < high)\\n        {\\n            var mid = low + (high - low) / 2;\\n            \\n            if (PathExists(grid, mid, 0, 0, new bool[grid.Length, grid[0].Length]))\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return low;\\n    }\\n    \\n    private bool PathExists(int[][] grid, int waterLevel, int r, int c, bool[,] visited)\\n    {   \\n        if (r > grid.Length - 1 || r < 0 || c > grid[0].Length - 1 || c < 0)\\n            return false;\\n        \\n        if (grid[r][c] > waterLevel || visited[r, c] == true)\\n            return false;\\n        \\n        if (r == grid.Length - 1 && c == grid[0].Length - 1)\\n            return true;\\n        \\n        visited[r, c] = true;\\n        \\n        var directions = new (int x, int y)[] { (1, 0), (0, 1), (-1, 0), (0, -1) };\\n        \\n        foreach (var dir in directions)\\n        {\\n            if (PathExists(grid, waterLevel, r + dir.x, c + dir.y, visited))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325135,
                "title": "python-dfs-with-binary-search",
                "content": "### Intuition\\n\\nWe ned to find the path from point `(0,0)` to `(N -1, N - 1)`. We can move to another 4-directionally adjacent square `(up, down, right and left)`. However, we can only move to the next adjacent square if the value inside that square is less than or equal to t.\\n\\n### Brute Force\\nWe\\'ll do a DFS where we\\'ll traverse all adjacent squares that satisify the requirement `value of the next grid <= t`. If we cannot move else where from the current `grid[row][col]`, we increase the time `t`. Below is the implementation:\\n```\\nclass Solution(object):\\n    def dfs(self, grid, t, row, col, visited):\\n       if row < 0 or row > len(grid) - 1 or col < 0 or col > len(grid[0]) - 1:\\n            return 0\\n        \\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\\n            return 1\\n        \\n        visited.add((row, col))\\n        \\n        down = up = right = left = 0\\n        \\n        if row + 1 < len(grid) and grid[row + 1][col] <= t and (row + 1, col) not in visited:\\n            down = self.dfs(grid, t, row + 1, col, visited)\\n            \\n        if row - 1 >= 0 and grid[row - 1][col] <= t and (row - 1, col) not in visited:\\n            up = self.dfs(grid, t, row - 1, col, visited)\\n            \\n        if col + 1 < len(grid[0]) and grid[row][col + 1] <= t and (row, col + 1) not in visited:\\n            right = self.dfs(grid, t, row, col + 1, visited)\\n            \\n        if col - 1 >= 0 and grid[row][col - 1] <= t and (row, col - 1) not in visited:\\n            left = self.dfs(grid, t, row, col - 1, visited)\\n            \\n        return down or up or right or left\\n    \\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not len(grid) or not len(grid[0]):\\n            return 0\\n        \\n        t = grid[0][0]\\n        visited = set()\\n        while self.dfs(grid, t, 0, 0, visited) == 0:\\n            t += 1\\n            visited = set()\\n        \\n        return t\\n```\\n\\nAt the begining of the program, I initialised `t = grid[0][0]` and increament it by `1` until I found a path that lead to `(N-1, N-1)`. However, this approach will lead to TLE since in the worst-case, `t` can be very big and total time complexity become `O(N2 * t)`.\\nTo optimise this, we can use binary search to find the minimum feasible water level. The range of our search will be `[0, n*n-1]`.\\nbelow is the DFS + Binary Search approach.\\n```\\nclass Solution(object):\\n    def dfs(self, grid, t, row, col, visited):\\n        if row < 0 or row > len(grid) - 1 or col < 0 or col > len(grid[0]) - 1 or grid[row][col] > t:\\n            return 0\\n        \\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\\n            return 1\\n        \\n        visited.add((row, col))\\n        \\n        down = up = right = left = 0\\n        \\n        if row + 1 < len(grid) and grid[row + 1][col] <= t and (row + 1, col) not in visited:\\n            down = self.dfs(grid, t, row + 1, col, visited)\\n            \\n        if row - 1 >= 0 and grid[row - 1][col] <= t and (row - 1, col) not in visited:\\n            up = self.dfs(grid, t, row - 1, col, visited)\\n            \\n        if col + 1 < len(grid[0]) and grid[row][col + 1] <= t and (row, col + 1) not in visited:\\n            right = self.dfs(grid, t, row, col + 1, visited)\\n            \\n        if col - 1 >= 0 and grid[row][col - 1] <= t and (row, col - 1) not in visited:\\n            left = self.dfs(grid, t, row, col - 1, visited)\\n            \\n        return down or up or right or left\\n    \\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not len(grid) or not len(grid[0]):\\n            return 0\\n        \\n        N = len(grid)\\n        t_left = grid[0][0]\\n        t_right = N * N - 1\\n        \\n        while t_left < t_right:\\n            t_mid = t_left + (t_right - t_left) // 2\\n            \\n            visited = set()\\n            if self.dfs(grid, t_mid, 0, 0, visited):\\n                t_right = t_mid\\n            else:\\n                t_left = t_mid + 1\\n           \\n        \\n        return t_left\\n```\\n\\nTime complexity: `O(N2 log N)`.\\n\\nHope this can be insightful, and happy learning!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def dfs(self, grid, t, row, col, visited):\\n       if row < 0 or row > len(grid) - 1 or col < 0 or col > len(grid[0]) - 1:\\n            return 0\\n        \\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\\n            return 1\\n        \\n        visited.add((row, col))\\n        \\n        down = up = right = left = 0\\n        \\n        if row + 1 < len(grid) and grid[row + 1][col] <= t and (row + 1, col) not in visited:\\n            down = self.dfs(grid, t, row + 1, col, visited)\\n            \\n        if row - 1 >= 0 and grid[row - 1][col] <= t and (row - 1, col) not in visited:\\n            up = self.dfs(grid, t, row - 1, col, visited)\\n            \\n        if col + 1 < len(grid[0]) and grid[row][col + 1] <= t and (row, col + 1) not in visited:\\n            right = self.dfs(grid, t, row, col + 1, visited)\\n            \\n        if col - 1 >= 0 and grid[row][col - 1] <= t and (row, col - 1) not in visited:\\n            left = self.dfs(grid, t, row, col - 1, visited)\\n            \\n        return down or up or right or left\\n    \\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not len(grid) or not len(grid[0]):\\n            return 0\\n        \\n        t = grid[0][0]\\n        visited = set()\\n        while self.dfs(grid, t, 0, 0, visited) == 0:\\n            t += 1\\n            visited = set()\\n        \\n        return t\\n```\n```\\nclass Solution(object):\\n    def dfs(self, grid, t, row, col, visited):\\n        if row < 0 or row > len(grid) - 1 or col < 0 or col > len(grid[0]) - 1 or grid[row][col] > t:\\n            return 0\\n        \\n        if row == len(grid) - 1 and col == len(grid[0]) - 1:\\n            return 1\\n        \\n        visited.add((row, col))\\n        \\n        down = up = right = left = 0\\n        \\n        if row + 1 < len(grid) and grid[row + 1][col] <= t and (row + 1, col) not in visited:\\n            down = self.dfs(grid, t, row + 1, col, visited)\\n            \\n        if row - 1 >= 0 and grid[row - 1][col] <= t and (row - 1, col) not in visited:\\n            up = self.dfs(grid, t, row - 1, col, visited)\\n            \\n        if col + 1 < len(grid[0]) and grid[row][col + 1] <= t and (row, col + 1) not in visited:\\n            right = self.dfs(grid, t, row, col + 1, visited)\\n            \\n        if col - 1 >= 0 and grid[row][col - 1] <= t and (row, col - 1) not in visited:\\n            left = self.dfs(grid, t, row, col - 1, visited)\\n            \\n        return down or up or right or left\\n    \\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not len(grid) or not len(grid[0]):\\n            return 0\\n        \\n        N = len(grid)\\n        t_left = grid[0][0]\\n        t_right = N * N - 1\\n        \\n        while t_left < t_right:\\n            t_mid = t_left + (t_right - t_left) // 2\\n            \\n            visited = set()\\n            if self.dfs(grid, t_mid, 0, 0, visited):\\n                t_right = t_mid\\n            else:\\n                t_left = t_mid + 1\\n           \\n        \\n        return t_left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182670,
                "title": "python3-bfs-heap",
                "content": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        N = len(grid)\\n        \\n        queue = [(grid[0][0], 0, 0)]  # min heap\\n        visited = set()\\n        res = 0\\n        while True:\\n            height, r, c = heappop(queue)\\n            res = max(res, height)\\n            if r == N-1 and c == N-1: return res\\n            visited.add((r, c))\\n            for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\\n                if 0 <= i < N and 0 <= j < N and (i, j) not in visited:\\n                    heappush(queue, (grid[i][j], i, j))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        N = len(grid)\\n        \\n        queue = [(grid[0][0], 0, 0)]  # min heap\\n        visited = set()\\n        res = 0\\n        while True:\\n            height, r, c = heappop(queue)\\n            res = max(res, height)\\n            if r == N-1 and c == N-1: return res\\n            visited.add((r, c))\\n            for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\\n                if 0 <= i < N and 0 <= j < N and (i, j) not in visited:\\n                    heappush(queue, (grid[i][j], i, j))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113753,
                "title": "c-concise-true-o-n-2-flood-fill",
                "content": "*UPDATE*: itsleo pointed out that each height has only 1 cell. So code has been updated accordingly.\\n\\nWhen the water reaches height h, process the cell of height h if and only if this cell is adjacent to the set of currently reachable cells.\\n\\nWhat do I mean by true O(n^2)? Well, the other O(n^2) posts so far use union-find, and that isn't *really* O(n^2).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    vector<pair<int,int>> hToCell, dir {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    const pair<int, int> NOT_ADJACENT = {-1, -1};\\n    int n;\\n    \\n    int swimInWater(vector<vector<int>>& g0) {\\n        g = g0;\\n        n = g.size();\\n        hToCell = decltype(hToCell)(n*n, NOT_ADJACENT);\\n        hToCell[g[0][0]] = {0, 0};\\n        \\n        for(int h=0; h<n*n; h++){\\n            auto cell = hToCell[h];\\n            if(cell != NOT_ADJACENT && fill(cell.first, cell.second, h)) return h;\\n        }\\n    }\\n\\n    bool fill(int i, int j, int h){\\n        if(i < 0 || i >= n || j < 0 || j >= n || g[i][j] == INT_MAX) return false;\\n        hToCell[g[i][j]] = {i, j};\\n        if(g[i][j] > h) return false;\\n        g[i][j] = INT_MAX;\\n\\n        bool ret = false;\\n        for(auto& d : dir) ret |= fill(i+d.first, j+d.second, h);\\n        return ret || (i == n-1 && j == n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    vector<pair<int,int>> hToCell, dir {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    const pair<int, int> NOT_ADJACENT = {-1, -1};\\n    int n;\\n    \\n    int swimInWater(vector<vector<int>>& g0) {\\n        g = g0;\\n        n = g.size();\\n        hToCell = decltype(hToCell)(n*n, NOT_ADJACENT);\\n        hToCell[g[0][0]] = {0, 0};\\n        \\n        for(int h=0; h<n*n; h++){\\n            auto cell = hToCell[h];\\n            if(cell != NOT_ADJACENT && fill(cell.first, cell.second, h)) return h;\\n        }\\n    }\\n\\n    bool fill(int i, int j, int h){\\n        if(i < 0 || i >= n || j < 0 || j >= n || g[i][j] == INT_MAX) return false;\\n        hToCell[g[i][j]] = {i, j};\\n        if(g[i][j] > h) return false;\\n        g[i][j] = INT_MAX;\\n\\n        bool ret = false;\\n        for(auto& d : dir) ret |= fill(i+d.first, j+d.second, h);\\n        return ret || (i == n-1 && j == n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064713,
                "title": "python-3-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Question similar to \"Path with Minimum Effort\" \\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n\\n        # Getting rows and cols\\n        r=len(grid)\\n        c=len(grid[0])\\n\\n        # 2D array to store minimum elevation to reach there\\n        cache=[[math.inf for _ in range(c)] for _ in range(r)]\\n\\n        # Directions to traverse\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\n        # Minheap storing (elevation,x co-ordinat, y co-ordinate)\\n        minheap=[(grid[0][0],0,0)]\\n\\n        # Remains same, as this is start postion\\n        cache[0][0] = grid[0][0]\\n\\n        while minheap:\\n            # Popping position with miniumm elevation\\n            elevation,i,j=heapq.heappop(minheap)\\n\\n            # Base case to reach end\\n            if i==(r-1) and j==(c-1):\\n                return elevation\\n            \\n            # Traversing 4 directions\\n            for dx, dy in directions:\\n                nx, ny = i + dx, j + dy\\n                \\n                if 0 <= nx < r and 0 <= ny < c:\\n\\n                    # \"new_elevation\" keeping track of max encountered till now\\n                    new_elevation=max(grid[nx][ny],elevation)\\n\\n                    # Update it in cache as well as add in heap if \"new_elevation\" is less\\n                    # than one in cache\\n                    if new_elevation < cache[nx][ny]:\\n                        cache[nx][ny] = new_elevation\\n                        heappush(minheap, (new_elevation, nx, ny))\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Question similar to \"Path with Minimum Effort\" \\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n\\n        # Getting rows and cols\\n        r=len(grid)\\n        c=len(grid[0])\\n\\n        # 2D array to store minimum elevation to reach there\\n        cache=[[math.inf for _ in range(c)] for _ in range(r)]\\n\\n        # Directions to traverse\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\n        # Minheap storing (elevation,x co-ordinat, y co-ordinate)\\n        minheap=[(grid[0][0],0,0)]\\n\\n        # Remains same, as this is start postion\\n        cache[0][0] = grid[0][0]\\n\\n        while minheap:\\n            # Popping position with miniumm elevation\\n            elevation,i,j=heapq.heappop(minheap)\\n\\n            # Base case to reach end\\n            if i==(r-1) and j==(c-1):\\n                return elevation\\n            \\n            # Traversing 4 directions\\n            for dx, dy in directions:\\n                nx, ny = i + dx, j + dy\\n                \\n                if 0 <= nx < r and 0 <= ny < c:\\n\\n                    # \"new_elevation\" keeping track of max encountered till now\\n                    new_elevation=max(grid[nx][ny],elevation)\\n\\n                    # Update it in cache as well as add in heap if \"new_elevation\" is less\\n                    # than one in cache\\n                    if new_elevation < cache[nx][ny]:\\n                        cache[nx][ny] = new_elevation\\n                        heappush(minheap, (new_elevation, nx, ny))\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648900,
                "title": "c-easily-understandable-binary-search-on-answer",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    // Binary search on answer\\n    \\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    int n;\\n\\n    bool dfs(int x,int y, int t,vector<vector<int>> &grid, vector<vector<int>> &visit){\\n        visit[x][y]=1;\\n\\n        if(t< grid[x][y]) return false;\\n        \\n        if(x== n-1 && y== n-1){\\n            return true;\\n        }\\n\\n        bool an=false;\\n\\n        for(int i=0;i<4;i+=1){\\n            int nx= x + dx[i];\\n            int ny= y + dy[i];\\n\\n            if(nx>=0 && ny>=0 && nx<n && ny<n && grid[nx][ny]<=t && !visit[nx][ny]){\\n                if(nx== n-1 && ny == n-1){\\n                    an=true;\\n                }else{\\n                    an = an | dfs(nx,ny,t,grid, visit);\\n                }\\n            }\\n        }\\n        return an;\\n    }\\n\\n    int swimInWater(vector<vector<int>>& grid) {\\n        n= grid.size();\\n        \\n        int lo=0,hi=1e5;\\n        while(lo<hi){\\n            int mid= lo + (hi-lo)/2;\\n            vector<vector<int>> visit(n+1, vector<int> (n+1,0));\\n            if(dfs(0,0,mid,grid,visit)){\\n                hi=mid;\\n            }else{\\n                lo=mid+1;\\n            }\\n\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Binary search on answer\\n    \\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    int n;\\n\\n    bool dfs(int x,int y, int t,vector<vector<int>> &grid, vector<vector<int>> &visit){\\n        visit[x][y]=1;\\n\\n        if(t< grid[x][y]) return false;\\n        \\n        if(x== n-1 && y== n-1){\\n            return true;\\n        }\\n\\n        bool an=false;\\n\\n        for(int i=0;i<4;i+=1){\\n            int nx= x + dx[i];\\n            int ny= y + dy[i];\\n\\n            if(nx>=0 && ny>=0 && nx<n && ny<n && grid[nx][ny]<=t && !visit[nx][ny]){\\n                if(nx== n-1 && ny == n-1){\\n                    an=true;\\n                }else{\\n                    an = an | dfs(nx,ny,t,grid, visit);\\n                }\\n            }\\n        }\\n        return an;\\n    }\\n\\n    int swimInWater(vector<vector<int>>& grid) {\\n        n= grid.size();\\n        \\n        int lo=0,hi=1e5;\\n        while(lo<hi){\\n            int mid= lo + (hi-lo)/2;\\n            vector<vector<int>> visit(n+1, vector<int> (n+1,0));\\n            if(dfs(0,0,mid,grid,visit)){\\n                hi=mid;\\n            }else{\\n                lo=mid+1;\\n            }\\n\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585319,
                "title": "easy-solution-using-binary-search-and-dfs",
                "content": "**Algorithm**\\n1. since grid traversal possible or not is a monotonic function (if possible for a value, possible for all values greater than this)\\n2. Using Binary Search find the minimum possible value for which we can the reach the bottom right cell startin from top left\\n3. in dfs traversal possible if node value is less-equal-to maximum possible.\\n```\\nclass Solution {\\npublic:\\n    int delx[4]={-1,1,0,0};\\n    int dely[4]={0,0,-1,1};\\n    bool dfs(int i,int j,vector<vector<int>>& grid,int mx,vector<vector<bool>> &vis){\\n        int n=grid.size();\\n        if(i<0 or j<0 or i>=n or j>=n or grid[i][j]>mx or vis[i][j])return false;\\n        if(i==n-1 and j==n-1)return true;\\n        vis[i][j]=true;\\n        for(int k=0;k<4;k++){\\n            int x=i+delx[k];\\n            int y=j+dely[k];\\n            if(dfs(x,y,grid,mx,vis)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int start=0,end=1e5;\\n        int ans=INT_MAX;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            vector<vector<bool>> vis(n,vector<bool>( n,0));\\n            if(dfs(0,0,grid,mid,vis)){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int delx[4]={-1,1,0,0};\\n    int dely[4]={0,0,-1,1};\\n    bool dfs(int i,int j,vector<vector<int>>& grid,int mx,vector<vector<bool>> &vis){\\n        int n=grid.size();\\n        if(i<0 or j<0 or i>=n or j>=n or grid[i][j]>mx or vis[i][j])return false;\\n        if(i==n-1 and j==n-1)return true;\\n        vis[i][j]=true;\\n        for(int k=0;k<4;k++){\\n            int x=i+delx[k];\\n            int y=j+dely[k];\\n            if(dfs(x,y,grid,mx,vis)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int start=0,end=1e5;\\n        int ans=INT_MAX;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            vector<vector<bool>> vis(n,vector<bool>( n,0));\\n            if(dfs(0,0,grid,mid,vis)){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585074,
                "title": "easy-python-solution-using-heapsort-and-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        vis=[[0]*n for _ in range(m)]\\n        queue=[(grid[0][0],0,0)]\\n        heapq.heapify(queue)\\n        vis[0][0]=1\\n        while queue:\\n            mx,x,y=heapq.heappop(queue)\\n            if x==m-1 and y==n-1:\\n                return mx\\n            row=[0,0,-1,1]\\n            col=[1,-1,0,0]\\n            for i in range(4):\\n                if 0<=x+row[i]<m and 0<=y+col[i]<n:\\n                    if vis[x+row[i]][y+col[i]]==0:\\n                        heapq.heappush(queue,(max(mx,grid[x+row[i]][y+col[i]]),x+row[i],y+col[i]))\\n                        vis[x+row[i]][y+col[i]]=1\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        vis=[[0]*n for _ in range(m)]\\n        queue=[(grid[0][0],0,0)]\\n        heapq.heapify(queue)\\n        vis[0][0]=1\\n        while queue:\\n            mx,x,y=heapq.heappop(queue)\\n            if x==m-1 and y==n-1:\\n                return mx\\n            row=[0,0,-1,1]\\n            col=[1,-1,0,0]\\n            for i in range(4):\\n                if 0<=x+row[i]<m and 0<=y+col[i]<n:\\n                    if vis[x+row[i]][y+col[i]]==0:\\n                        heapq.heappush(queue,(max(mx,grid[x+row[i]][y+col[i]]),x+row[i],y+col[i]))\\n                        vis[x+row[i]][y+col[i]]=1\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570758,
                "title": "c-easy-solution-with-stepwise-explanation-min-heap-priority-queue",
                "content": "Here is the code with stepwise explaination.\\n\\nI hope you find it helpful. If you do please upvote \\u2B06\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int opt[]={0,1,0,-1,0}; // to travel in all four direction\\n        //min-heap to get to n-1,m-1 in minimum time\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        // {time,{row,col}}\\n        pq.push({grid[0][0],{0,0}});\\n        //starting with {0,0}\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        vis[0][0]=1;\\n        while(!pq.empty())\\n        {\\n            int time=pq.top().first;\\n            int rr=pq.top().second.first;\\n            int cc=pq.top().second.second;\\n            pq.pop();\\n            // whenever we first reach at n-1,m-1 return the time as it will be minimum of all other paths \\n            if(rr==n-1&&cc==m-1)\\n             return time;\\n            for(int i=0;i<4;i++) // travelling in 4 direction\\n            {\\n                int r=rr+opt[i];\\n                int c=cc+opt[i+1];\\n                if(r>=0&&c>=0&&r<n&&c<m&&!vis[r][c]) // if valid cell and not visited yet\\n                {\\n                    // if the adjacent cell value is <= the time we took on the current cell \\n                    //we can take it\\'s time to be same \\n                    //as we can travel as much as cells we want to if the cell value is <= the current time\\n                    if(grid[r][c]<=time) \\n                    {\\n                        pq.push({time,{r,c}});\\n                    }\\n                    //if the value is greater we take it\\'s time to be equal of the value\\n                    else\\n                    {\\n                        pq.push({grid[r][c],{r,c}});\\n                    }\\n                    vis[r][c]=1; // mark as visited\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int opt[]={0,1,0,-1,0}; // to travel in all four direction\\n        //min-heap to get to n-1,m-1 in minimum time\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        // {time,{row,col}}\\n        pq.push({grid[0][0],{0,0}});\\n        //starting with {0,0}\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        vis[0][0]=1;\\n        while(!pq.empty())\\n        {\\n            int time=pq.top().first;\\n            int rr=pq.top().second.first;\\n            int cc=pq.top().second.second;\\n            pq.pop();\\n            // whenever we first reach at n-1,m-1 return the time as it will be minimum of all other paths \\n            if(rr==n-1&&cc==m-1)\\n             return time;\\n            for(int i=0;i<4;i++) // travelling in 4 direction\\n            {\\n                int r=rr+opt[i];\\n                int c=cc+opt[i+1];\\n                if(r>=0&&c>=0&&r<n&&c<m&&!vis[r][c]) // if valid cell and not visited yet\\n                {\\n                    // if the adjacent cell value is <= the time we took on the current cell \\n                    //we can take it\\'s time to be same \\n                    //as we can travel as much as cells we want to if the cell value is <= the current time\\n                    if(grid[r][c]<=time) \\n                    {\\n                        pq.push({time,{r,c}});\\n                    }\\n                    //if the value is greater we take it\\'s time to be equal of the value\\n                    else\\n                    {\\n                        pq.push({grid[r][c],{r,c}});\\n                    }\\n                    vis[r][c]=1; // mark as visited\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058187,
                "title": "easy-c-recursion-dfs-memoization",
                "content": "PLS UPVOTE!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][51][2501];\\n    bool vis[51][51];\\n    int fun(int i, int j, int maxi, vector<vector<int>>&grid){\\n        int n = grid.size(), m = grid[0].size();\\n\\n        if(i<0 || j<0 || i>=n || j>=m || vis[i][j]==true)\\n            return INT_MAX;\\n        \\n        maxi = max(maxi, grid[i][j]);\\n\\n        if(i==n-1 && j==m-1)\\n            return maxi;\\n\\n        if(dp[i][j][maxi] != -1)\\n            return dp[i][j][maxi];\\n        \\n        vis[i][j] = true;\\n\\n        int l = fun(i, j-1, maxi, grid);\\n        int r = fun(i, j+1, maxi, grid);\\n        int u = fun(i-1, j, maxi, grid);\\n        int d = fun(i+1, j, maxi, grid);\\n\\n        vis[i][j] = false;\\n\\n        return dp[i][j][maxi] = min({l,r,u,d});\\n    }\\n\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        memset(vis, false, sizeof(vis));\\n        return fun(0,0,-1, grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][51][2501];\\n    bool vis[51][51];\\n    int fun(int i, int j, int maxi, vector<vector<int>>&grid){\\n        int n = grid.size(), m = grid[0].size();\\n\\n        if(i<0 || j<0 || i>=n || j>=m || vis[i][j]==true)\\n            return INT_MAX;\\n        \\n        maxi = max(maxi, grid[i][j]);\\n\\n        if(i==n-1 && j==m-1)\\n            return maxi;\\n\\n        if(dp[i][j][maxi] != -1)\\n            return dp[i][j][maxi];\\n        \\n        vis[i][j] = true;\\n\\n        int l = fun(i, j-1, maxi, grid);\\n        int r = fun(i, j+1, maxi, grid);\\n        int u = fun(i-1, j, maxi, grid);\\n        int d = fun(i+1, j, maxi, grid);\\n\\n        vis[i][j] = false;\\n\\n        return dp[i][j][maxi] = min({l,r,u,d});\\n    }\\n\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        memset(vis, false, sizeof(vis));\\n        return fun(0,0,-1, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917431,
                "title": "c-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(2*n)\\n\\n- Space complexity:O(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool chk(int i, int j, int n){\\n        return i>=0 && i<n && j>=0 && j<n;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>>v(n, vector<int>(n, 1e9));\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\\n        q.push({grid[0][0], {0, 0}});\\n        v[0][0]=grid[0][0];\\n        while(!q.empty()){\\n            int cnt=q.top().first, x=q.top().second.first, y=q.top().second.second;\\n            q.pop();\\n            int c[4]={-1, 0, 1, 0};\\n            int r[4]={0, -1, 0, 1};\\n            for(int i=0 ;i<4; i++){\\n                int row=r[i]+x, col=c[i]+y;\\n                if(chk(row, col, n)){\\n                    if(cnt<grid[row][col]){\\n                        v[row][col]=grid[row][col];\\n                        q.push({v[row][col], {row, col}});\\n                    }\\n                    else if(cnt<v[row][col]){\\n                        v[row][col]=cnt;\\n                        q.push({v[row][col], {row, col}});\\n                    }\\n                }\\n            }\\n        }\\n        return v[n-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool chk(int i, int j, int n){\\n        return i>=0 && i<n && j>=0 && j<n;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>>v(n, vector<int>(n, 1e9));\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\\n        q.push({grid[0][0], {0, 0}});\\n        v[0][0]=grid[0][0];\\n        while(!q.empty()){\\n            int cnt=q.top().first, x=q.top().second.first, y=q.top().second.second;\\n            q.pop();\\n            int c[4]={-1, 0, 1, 0};\\n            int r[4]={0, -1, 0, 1};\\n            for(int i=0 ;i<4; i++){\\n                int row=r[i]+x, col=c[i]+y;\\n                if(chk(row, col, n)){\\n                    if(cnt<grid[row][col]){\\n                        v[row][col]=grid[row][col];\\n                        q.push({v[row][col], {row, col}});\\n                    }\\n                    else if(cnt<v[row][col]){\\n                        v[row][col]=cnt;\\n                        q.push({v[row][col], {row, col}});\\n                    }\\n                }\\n            }\\n        }\\n        return v[n-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826076,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>time(n, vector<int>(m, 1e9));\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> pq;\\n        time[0][0] = grid[0][0];\\n        int ans = 1e9;\\n     \\n        pq.push({time[0][0], {0,0}});\\n        \\n        int dr[] = {-1, 0, 1, 0};\\n        int dc[] = {0, 1, 0, -1};\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int diff = it.first;\\n            int r = it.second.first;\\n            int c = it.second.second;\\n           \\n            \\n            for(int i = 0; i<4; i++)\\n            {\\n                int nrow = dr[i] + r;\\n                int ncol = dc[i] + c;\\n                \\n                if(nrow>=0 && nrow<n && ncol >=0 && ncol <m && grid[nrow][ncol] < time[nrow][ncol])\\n                {\\n                    if(diff <  grid[nrow][ncol])\\n                    {\\n                        time[nrow][ncol] = grid[nrow][ncol];\\n                        pq.push({time[nrow][ncol], {nrow, ncol}});\\n                         \\n                    }\\n                    else if(diff < time[nrow][ncol])\\n                    {\\n                        time[nrow][ncol] = diff;\\n                        pq.push({time[nrow][ncol], {nrow, ncol}});\\n                    }  \\n                }\\n            }\\n            \\n        }\\n        return time[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>time(n, vector<int>(m, 1e9));\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> pq;\\n        time[0][0] = grid[0][0];\\n        int ans = 1e9;\\n     \\n        pq.push({time[0][0], {0,0}});\\n        \\n        int dr[] = {-1, 0, 1, 0};\\n        int dc[] = {0, 1, 0, -1};\\n        while(!pq.empty())\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int diff = it.first;\\n            int r = it.second.first;\\n            int c = it.second.second;\\n           \\n            \\n            for(int i = 0; i<4; i++)\\n            {\\n                int nrow = dr[i] + r;\\n                int ncol = dc[i] + c;\\n                \\n                if(nrow>=0 && nrow<n && ncol >=0 && ncol <m && grid[nrow][ncol] < time[nrow][ncol])\\n                {\\n                    if(diff <  grid[nrow][ncol])\\n                    {\\n                        time[nrow][ncol] = grid[nrow][ncol];\\n                        pq.push({time[nrow][ncol], {nrow, ncol}});\\n                         \\n                    }\\n                    else if(diff < time[nrow][ncol])\\n                    {\\n                        time[nrow][ncol] = diff;\\n                        pq.push({time[nrow][ncol], {nrow, ncol}});\\n                    }  \\n                }\\n            }\\n            \\n        }\\n        return time[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817802,
                "title": "c-min-heap-bfs",
                "content": "```cpp\\nclass Node {\\npublic:    \\n    int time;\\n    int x;\\n    int y;\\n    \\n};\\n\\n//min heap comparator\\nbool operator< (const Node &a, const Node &b) {\\n    return a.time > b.time;\\n}\\n\\nstruct pair_hash {\\n    inline std::size_t operator() (const std::pair<int,int> & v) const {\\n        return v.first * 31 + v.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        unordered_set<pair<int, int>, pair_hash> seen;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<Node> q;\\n        auto isValidCell = [&] (int a, int b) {\\n            return a >= 0 && a < n && b >= 0 && b < m;    \\n        };\\n        q.push({grid[0][0], 0, 0});\\n        seen.insert({0, 0});\\n        int res = 0;\\n        while (q.size() > 0) {\\n            Node node = q.top();\\n            q.pop();\\n            res = max(res, node.time);\\n            if (node.x == n - 1 && node.y == m - 1) return res;\\n            int dir[] = {-1, 0, 1, 0, -1};\\n            for (int k = 0; k < 4; ++k) {\\n                int u = node.x + dir[k];\\n                int v = node.y + dir[k + 1];\\n                if (isValidCell(u, v) && seen.count({u, v}) <= 0) {\\n                    q.push({grid[u][v], u, v});\\n                    seen.insert({u, v});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Node {\\npublic:    \\n    int time;\\n    int x;\\n    int y;\\n    \\n};\\n\\n//min heap comparator\\nbool operator< (const Node &a, const Node &b) {\\n    return a.time > b.time;\\n}\\n\\nstruct pair_hash {\\n    inline std::size_t operator() (const std::pair<int,int> & v) const {\\n        return v.first * 31 + v.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        unordered_set<pair<int, int>, pair_hash> seen;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<Node> q;\\n        auto isValidCell = [&] (int a, int b) {\\n            return a >= 0 && a < n && b >= 0 && b < m;    \\n        };\\n        q.push({grid[0][0], 0, 0});\\n        seen.insert({0, 0});\\n        int res = 0;\\n        while (q.size() > 0) {\\n            Node node = q.top();\\n            q.pop();\\n            res = max(res, node.time);\\n            if (node.x == n - 1 && node.y == m - 1) return res;\\n            int dir[] = {-1, 0, 1, 0, -1};\\n            for (int k = 0; k < 4; ++k) {\\n                int u = node.x + dir[k];\\n                int v = node.y + dir[k + 1];\\n                if (isValidCell(u, v) && seen.count({u, v}) <= 0) {\\n                    q.push({grid[u][v], u, v});\\n                    seen.insert({u, v});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654617,
                "title": "c-solution-binary-search-dfs-short-easy",
                "content": "```\\nclass Solution {    \\npublic:\\n    int n;\\n    int vis[50][50];\\n    vector<vector<int>> moves = {{1,0},{0,1},{-1,0},{0,-1}};\\n    void dfs(vector<vector<int>>& grid, int i, int j, int &time) {\\n        if (i<0 || i>=n || j<0 || j>=n || grid[i][j]>time || vis[i][j]) \\n            return;\\n        \\n        vis[i][j] = 1;\\n        for (auto m : moves)\\n            dfs(grid, i+m[0], j+m[1], time);\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        int time = 2500;\\n        int low = 0, high = 2500;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            dfs(grid,0,0,mid);\\n            if(vis[n-1][n-1]){\\n                time = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n            \\n            memset(vis,0,sizeof(vis));\\n        }\\n        \\n        return time;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {    \\npublic:\\n    int n;\\n    int vis[50][50];\\n    vector<vector<int>> moves = {{1,0},{0,1},{-1,0},{0,-1}};\\n    void dfs(vector<vector<int>>& grid, int i, int j, int &time) {\\n        if (i<0 || i>=n || j<0 || j>=n || grid[i][j]>time || vis[i][j]) \\n            return;\\n        \\n        vis[i][j] = 1;\\n        for (auto m : moves)\\n            dfs(grid, i+m[0], j+m[1], time);\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        int time = 2500;\\n        int low = 0, high = 2500;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            dfs(grid,0,0,mid);\\n            if(vis[n-1][n-1]){\\n                time = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n            \\n            memset(vis,0,sizeof(vis));\\n        }\\n        \\n        return time;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514246,
                "title": "c-hint-2-used-binary-search-dfs-9-ms",
                "content": "The following code uses the second hint given in the question, it\\'s a pretty straight forward implementation of DFS. Since the constraints are very relaxed, I didn\\'t go ahead and optimise this further (although there\\'s a scope of improvement). Hope you are able to follow the code, please let me know in case of any doubts. \\nSince we can swim infinite distance in a single go, we just need to wait till the highest elevation in the path is covered by rainwater - this is basically the maximum value in the path from top left corner to bottom right corner. The answers for any path could only lie in the range [min, max] of all elements of the matrix, so just binary search on that. If there\\'s a path possible with a given maximum value, I will try searching for a path with smaller value, else I will search in the higher half of values. \\n```class Solution {\\npublic:\\n    bool possible(vector<vector<int>>& grid, vector<vector<bool>>& vis, int target, int mid, int i, int j)\\n    {\\n        if(target > mid) return false;\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || vis[i][j] || grid[i][j] > mid)\\n        {\\n            return false;\\n        }\\n        if(grid[i][j] == target) return true;\\n         \\n        vis[i][j] = true;\\n        \\n        return possible(grid, vis, target, mid, i + 1, j) ||\\n             possible(grid, vis, target, mid, i, j+1) ||\\n             possible(grid, vis, target, mid, i - 1, j) ||\\n             possible(grid, vis, target, mid, i, j-1);\\n            \\n        \\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int m = INT_MAX, M = INT_MIN;\\n        for(int i = 0;i < grid.size(); i++)\\n        {\\n            for(int j = 0;j < grid[0].size(); j++)\\n            {\\n                m = min(m, grid[i][j]);\\n                M = max(M, grid[i][j]);\\n            }\\n        }\\n        int target = grid.back().back();\\n        int ans = M;\\n        vector<vector<bool>> vis(grid.size(), vector<bool> (grid[0].size(),false));\\n        \\n        while(m <= M)\\n        {\\n            int mid = m + (M-m)/2;\\n            vis = vector<vector<bool>>(grid.size(), vector<bool> (grid[0].size(),false));\\n     \\n            if(possible(grid, vis, target, mid, 0, 0))\\n            {\\n                ans = mid;\\n                M = mid-1;\\n            }\\n            else m = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Depth-First Search"
                ],
                "code": "```class Solution {\\npublic:\\n    bool possible(vector<vector<int>>& grid, vector<vector<bool>>& vis, int target, int mid, int i, int j)\\n    {\\n        if(target > mid) return false;\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || vis[i][j] || grid[i][j] > mid)\\n        {\\n            return false;\\n        }\\n        if(grid[i][j] == target) return true;\\n         \\n        vis[i][j] = true;\\n        \\n        return possible(grid, vis, target, mid, i + 1, j) ||\\n             possible(grid, vis, target, mid, i, j+1) ||\\n             possible(grid, vis, target, mid, i - 1, j) ||\\n             possible(grid, vis, target, mid, i, j-1);\\n            \\n        \\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int m = INT_MAX, M = INT_MIN;\\n        for(int i = 0;i < grid.size(); i++)\\n        {\\n            for(int j = 0;j < grid[0].size(); j++)\\n            {\\n                m = min(m, grid[i][j]);\\n                M = max(M, grid[i][j]);\\n            }\\n        }\\n        int target = grid.back().back();\\n        int ans = M;\\n        vector<vector<bool>> vis(grid.size(), vector<bool> (grid[0].size(),false));\\n        \\n        while(m <= M)\\n        {\\n            int mid = m + (M-m)/2;\\n            vis = vector<vector<bool>>(grid.size(), vector<bool> (grid[0].size(),false));\\n     \\n            if(possible(grid, vis, target, mid, 0, 0))\\n            {\\n                ans = mid;\\n                M = mid-1;\\n            }\\n            else m = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074356,
                "title": "js-solution-using-bfs-and-dijkstra-minpriorityqueue",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar swimInWater = function(grid) {\\n    let n = grid.length;\\n    \\n    if (n === 1) return grid[0][0];\\n    \\n    let visited = Array(n).fill(false).map(() => Array(n).fill(false));\\n    \\n    let minH = new MinPriorityQueue({priority: x => x.time});\\n    \\n    minH.enqueue({time: grid[0][0], row: 0, col: 0});\\n    \\n    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\\n    \\n    while(!minH.isEmpty()) {\\n        let {time, row, col} = minH.dequeue().element;\\n        \\n        if (row === n - 1 && col === n - 1) return time;\\n        \\n        for (let [dx, dy] of directions) {\\n            dx += row;\\n            dy += col;\\n            if (dx < 0 || dy < 0 || dx >= n || dy >= n || visited[dx][dy]) continue;\\n            visited[dx][dy] = true;\\n            minH.enqueue({time: Math.max(time, grid[dx][dy]), row: dx, col: dy});\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar swimInWater = function(grid) {\\n    let n = grid.length;\\n    \\n    if (n === 1) return grid[0][0];\\n    \\n    let visited = Array(n).fill(false).map(() => Array(n).fill(false));\\n    \\n    let minH = new MinPriorityQueue({priority: x => x.time});\\n    \\n    minH.enqueue({time: grid[0][0], row: 0, col: 0});\\n    \\n    let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\\n    \\n    while(!minH.isEmpty()) {\\n        let {time, row, col} = minH.dequeue().element;\\n        \\n        if (row === n - 1 && col === n - 1) return time;\\n        \\n        for (let [dx, dy] of directions) {\\n            dx += row;\\n            dy += col;\\n            if (dx < 0 || dy < 0 || dx >= n || dy >= n || visited[dx][dy]) continue;\\n            visited[dx][dy] = true;\\n            minH.enqueue({time: Math.max(time, grid[dx][dy]), row: dx, col: dy});\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035061,
                "title": "easy-c-solution-using-dijkstra-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n       int n = grid.size();\\n       priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq; \\n       pq.push({grid[0][0], 0, 0});\\n       vector<vector<bool>> visited(n, vector<bool>(n, false));\\n       int dir[5] = {-1, 0, 1, 0, -1};\\n       int  time = 0;\\n       while(!pq.empty()){\\n          vector<int> t = pq.top();\\n          pq.pop();\\n          int waitTime = t[0];\\n          int x = t[1];\\n          int y = t[2];\\n          time = max(time, waitTime);\\n          if(x == n-1 && y == n-1) return time;\\n          if(!visited[x][y]){\\n              visited[x][y] = true;\\n              for(int k = 0; k<4; k++){\\n                  int i = x + dir[k];\\n                  int j = y + dir[k+1];\\n                  if(i>=0 && i<n && j>=0 && j < n && !visited[i][j]){\\n                      pq.push({grid[i][j], i, j});\\n                  }\\n              }\\n          }\\n       }\\n       return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n       int n = grid.size();\\n       priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq; \\n       pq.push({grid[0][0], 0, 0});\\n       vector<vector<bool>> visited(n, vector<bool>(n, false));\\n       int dir[5] = {-1, 0, 1, 0, -1};\\n       int  time = 0;\\n       while(!pq.empty()){\\n          vector<int> t = pq.top();\\n          pq.pop();\\n          int waitTime = t[0];\\n          int x = t[1];\\n          int y = t[2];\\n          time = max(time, waitTime);\\n          if(x == n-1 && y == n-1) return time;\\n          if(!visited[x][y]){\\n              visited[x][y] = true;\\n              for(int k = 0; k<4; k++){\\n                  int i = x + dir[k];\\n                  int j = y + dir[k+1];\\n                  if(i>=0 && i<n && j>=0 && j < n && !visited[i][j]){\\n                      pq.push({grid[i][j], i, j});\\n                  }\\n              }\\n          }\\n       }\\n       return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004190,
                "title": "java-simple-dijkstra-s-implementation",
                "content": "```\\nclass Solution {\\n    int dir[][] =  {{-1,0},{1,0},{0,1},{0,-1}};\\n    public int swimInWater(int[][] grid) {\\n        int n =  grid.length;\\n        PriorityQueue<int[]> q =  new PriorityQueue<>((o1,o2)->o1[2]-o2[2]  );\\n        boolean visited[][] =  new boolean[n][n];\\n        q.offer(new int[]{0,0,grid[0][0]});// x,y,time \\n\\t\\t\\n        \\n        while(q.size()>0 ){\\n            int peek[] =  q.remove();\\n            int x =  peek[0],y =  peek[1],t = peek[2];\\n            if(visited[x][y]) continue;            \\n            if(x==n-1 && y==n-1){\\n                return t;\\n            }\\n            visited[x][y]  =  true;                        \\n            for(int d[]:dir){\\n                int nx  =  x+d[0] , ny =  y+d[1];\\n                if(nx>=0 && ny>=0 && nx<n && ny<n && !visited[nx][ny] ){\\n                    \\n/*\\nAlways insert neighbour, don\\'t wait to raise our level\\nwe can only move through neighbour right?\\ntwo cases -  our level less than neighbour or neighbour level less than our level\\nin both cases, we have to wait for the same amount of time, so their level become equal\\nand neighbour level will be Max of both currentNode level and neighbour level, at least one of them has to\\nraise to the same level so the wait will be the max of both of their level.\\n */\\n                        q.offer(new int[]{nx,ny,Math.max(grid[nx][ny],t) }); \\n                    \\n                }                \\n            }                        \\n            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int dir[][] =  {{-1,0},{1,0},{0,1},{0,-1}};\\n    public int swimInWater(int[][] grid) {\\n        int n =  grid.length;\\n        PriorityQueue<int[]> q =  new PriorityQueue<>((o1,o2)->o1[2]-o2[2]  );\\n        boolean visited[][] =  new boolean[n][n];\\n        q.offer(new int[]{0,0,grid[0][0]});// x,y,time \\n\\t\\t\\n        \\n        while(q.size()>0 ){\\n            int peek[] =  q.remove();\\n            int x =  peek[0],y =  peek[1],t = peek[2];\\n            if(visited[x][y]) continue;            \\n            if(x==n-1 && y==n-1){\\n                return t;\\n            }\\n            visited[x][y]  =  true;                        \\n            for(int d[]:dir){\\n                int nx  =  x+d[0] , ny =  y+d[1];\\n                if(nx>=0 && ny>=0 && nx<n && ny<n && !visited[nx][ny] ){\\n                    \\n/*\\nAlways insert neighbour, don\\'t wait to raise our level\\nwe can only move through neighbour right?\\ntwo cases -  our level less than neighbour or neighbour level less than our level\\nin both cases, we have to wait for the same amount of time, so their level become equal\\nand neighbour level will be Max of both currentNode level and neighbour level, at least one of them has to\\nraise to the same level so the wait will be the max of both of their level.\\n */\\n                        q.offer(new int[]{nx,ny,Math.max(grid[nx][ny],t) }); \\n                    \\n                }                \\n            }                        \\n            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651183,
                "title": "python-bfs-dfs-a-priority-queue-heaps",
                "content": "https://github.com/midnightbot/AI_Search_Agent/blob/master/solution.py contains a demo of how different search algorithms works\\n## **Solution 1 (Using BFS/DFS) (Time Limit Exceeded)**\\n\\n```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        ##just find paths and max of the path will be the time \\n        ##return the path with min max time\\n        ##using bfs/dfs\\n        ans = []\\n        mins = []\\n        mins.append(float(\\'inf\\'))\\n        self.expand(grid,0,0,ans,grid[0][0],[],mins)\\n        return min(ans)\\n        \\n    def expand(self,grid,x,y,ans,time,visited,mins):\\n        #print(x,y,visited,mins)\\n        \\n        if x == len(grid)-1 and y == len(grid[0])-1:\\n            #print(\"inisde\")\\n            mins[0] = min(mins[0], time)\\n            ans.append(time)\\n            \\n            \\n        if x-1 >=0 and (x-1,y) not in visited and grid[x-1][y] < mins[0] and time < mins[0]:\\n            l = copy.deepcopy(visited)\\n            l.append((x-1,y))\\n            temp1 = max(time,grid[x-1][y])\\n            self.expand(grid,x-1,y,ans,temp1,l,mins)\\n            \\n            \\n        if x+1 < len(grid) and (x+1,y) not in visited and grid[x+1][y] < mins[0] and time < mins[0]:\\n            l = copy.deepcopy(visited)\\n            l.append((x+1,y))\\n            temp2 = max(time,grid[x+1][y])\\n            self.expand(grid,x+1,y,ans,temp2,l,mins)\\n            \\n            \\n        if y-1 >=0 and (x,y-1) not in visited and grid[x][y-1] < mins[0] and time < mins[0]:\\n            l = copy.deepcopy(visited)\\n            l.append((x,y-1))\\n            temp3 = max(time,grid[x][y-1])\\n            self.expand(grid,x,y-1,ans,temp3,l,mins)\\n            \\n            \\n        if y + 1 < len(grid[0]) and (x,y+1) not in visited and grid[x][y+1] < mins[0] and time < mins[0]:\\n            l = copy.copy(visited)\\n            l.append((x,y+1))\\n            temp4 = max(time,grid[x][y+1])\\n            self.expand(grid,x,y+1,ans,temp4,l,mins)\\n```\\n\\n## **Solution 2 (Using A* algorithm with priority queue) (Time Limit Exceeded) Heuristic considered : expanding points that have minimum time to reach from start **\\n\\n\\n```\\nimport queue\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        \\n        ##bfs/dfs TLE\\n        ## now will try A* algorithm\\n        \\n        frontier = queue.PriorityQueue()\\n        visited = set()\\n        \\n        frontier.put((grid[0][0],(0,0)))\\n        \\n        while len(frontier.queue)!=0:\\n            curr = frontier.get()\\n            time = curr[0]\\n            x = curr[1][0]\\n            y = curr[1][1]\\n            \\n            if x == len(grid)-1 and y == len(grid)-1:\\n                return time\\n            \\n            visited.add(tuple((x,y)))\\n            \\n            if x-1>=0 and (x-1,y) not in visited:\\n                frontier.put((max(time,grid[x-1][y]),(x-1,y)))\\n                \\n            if x+1 < len(grid) and (x+1,y) not in visited:\\n                frontier.put((max(time,grid[x+1][y]),(x+1,y)))\\n                \\n            if y-1>=0 and (x,y-1) not in visited:\\n                frontier.put((max(time,grid[x][y-1]),(x,y-1)))\\n                \\n            if y+1 < len(grid) and (x,y+1) not in visited:\\n                frontier.put((max(time,grid[x][y+1]),(x,y+1)))\\n```\\n## **Solution 3 (Using A* Algorithm with priority Queues) (Accepted) Heuristic considered : expanding neighbour of any point in visited set that has min time to reach**\\n```\\nimport queue\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        \\n        ##bfs/dfs TLE\\n        ## now will try A* algorithm\\n        \\n        frontier = queue.PriorityQueue()\\n        visited = set()\\n        \\n        frontier.put((grid[0][0],(0,0)))\\n        ans = 0\\n        \\n        while len(frontier.queue)!=0:\\n            curr = frontier.get()\\n            time = curr[0]\\n            x = curr[1][0]\\n            y = curr[1][1]\\n            ans = max(ans,time)\\n            if x == len(grid)-1 and y == len(grid)-1:\\n                return ans\\n            \\n            visited.add(tuple((x,y)))\\n            \\n            if x-1>=0 and (x-1,y) not in visited:\\n                frontier.put((grid[x-1][y],(x-1,y)))\\n                \\n            if x+1 < len(grid) and (x+1,y) not in visited:\\n                frontier.put((grid[x+1][y],(x+1,y)))\\n                \\n            if y-1>=0 and (x,y-1) not in visited:\\n                frontier.put((grid[x][y-1],(x,y-1)))\\n                \\n            if y+1 < len(grid) and (x,y+1) not in visited:\\n                frontier.put((grid[x][y+1],(x,y+1)))\\n```\\n## **Solution 4 (Using A* algorithm with heaps) (Accepted)**\\n```\\nimport queue\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        \\n        ##bfs/dfs TLE\\n        ## now will try A* algorithm\\n        \\n        frontier = [(grid[0][0],0,0)]\\n        visited = {(-1,-1)}\\n        \\n        #frontier.append()\\n        ans = 0\\n        while len(frontier)!=0:\\n            time,x,y = heapq.heappop(frontier)\\n            ans = max(ans,time)\\n            \\n            if x == len(grid)-1 and y == len(grid)-1:\\n                return ans\\n            \\n            visited.add((x,y))\\n            \\n            if x-1>=0 and (x-1,y) not in visited:\\n                heapq.heappush(frontier, (grid[x-1][y],x-1,y))\\n                #frontier.put((max(time,grid[x-1][y]),(x-1,y)))\\n                \\n            if x+1 < len(grid) and (x+1,y) not in visited:\\n                heapq.heappush(frontier, (grid[x+1][y],x+1,y))\\n                #frontier.put((max(time,grid[x+1][y]),(x+1,y)))\\n                \\n            if y-1>=0 and (x,y-1) not in visited:\\n                heapq.heappush(frontier, (grid[x][y-1],x,y-1))\\n                #frontier.put((max(time,grid[x][y-1]),(x,y-1))\\n                \\n            if y+1 < len(grid) and (x,y+1) not in visited:\\n                heapq.heappush(frontier, (grid[x][y+1],x,y+1))\\n                #frontier.put((max(time,grid[x][y+1]),(x,y+1)))\\n```\\n\\nAlso https://github.com/midnightbot/AI_Search_Agent/blob/master/solution.py contains a demo of how different search algorithms works",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        ##just find paths and max of the path will be the time \\n        ##return the path with min max time\\n        ##using bfs/dfs\\n        ans = []\\n        mins = []\\n        mins.append(float(\\'inf\\'))\\n        self.expand(grid,0,0,ans,grid[0][0],[],mins)\\n        return min(ans)\\n        \\n    def expand(self,grid,x,y,ans,time,visited,mins):\\n        #print(x,y,visited,mins)\\n        \\n        if x == len(grid)-1 and y == len(grid[0])-1:\\n            #print(\"inisde\")\\n            mins[0] = min(mins[0], time)\\n            ans.append(time)\\n            \\n            \\n        if x-1 >=0 and (x-1,y) not in visited and grid[x-1][y] < mins[0] and time < mins[0]:\\n            l = copy.deepcopy(visited)\\n            l.append((x-1,y))\\n            temp1 = max(time,grid[x-1][y])\\n            self.expand(grid,x-1,y,ans,temp1,l,mins)\\n            \\n            \\n        if x+1 < len(grid) and (x+1,y) not in visited and grid[x+1][y] < mins[0] and time < mins[0]:\\n            l = copy.deepcopy(visited)\\n            l.append((x+1,y))\\n            temp2 = max(time,grid[x+1][y])\\n            self.expand(grid,x+1,y,ans,temp2,l,mins)\\n            \\n            \\n        if y-1 >=0 and (x,y-1) not in visited and grid[x][y-1] < mins[0] and time < mins[0]:\\n            l = copy.deepcopy(visited)\\n            l.append((x,y-1))\\n            temp3 = max(time,grid[x][y-1])\\n            self.expand(grid,x,y-1,ans,temp3,l,mins)\\n            \\n            \\n        if y + 1 < len(grid[0]) and (x,y+1) not in visited and grid[x][y+1] < mins[0] and time < mins[0]:\\n            l = copy.copy(visited)\\n            l.append((x,y+1))\\n            temp4 = max(time,grid[x][y+1])\\n            self.expand(grid,x,y+1,ans,temp4,l,mins)\\n```\n```\\nimport queue\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        \\n        ##bfs/dfs TLE\\n        ## now will try A* algorithm\\n        \\n        frontier = queue.PriorityQueue()\\n        visited = set()\\n        \\n        frontier.put((grid[0][0],(0,0)))\\n        \\n        while len(frontier.queue)!=0:\\n            curr = frontier.get()\\n            time = curr[0]\\n            x = curr[1][0]\\n            y = curr[1][1]\\n            \\n            if x == len(grid)-1 and y == len(grid)-1:\\n                return time\\n            \\n            visited.add(tuple((x,y)))\\n            \\n            if x-1>=0 and (x-1,y) not in visited:\\n                frontier.put((max(time,grid[x-1][y]),(x-1,y)))\\n                \\n            if x+1 < len(grid) and (x+1,y) not in visited:\\n                frontier.put((max(time,grid[x+1][y]),(x+1,y)))\\n                \\n            if y-1>=0 and (x,y-1) not in visited:\\n                frontier.put((max(time,grid[x][y-1]),(x,y-1)))\\n                \\n            if y+1 < len(grid) and (x,y+1) not in visited:\\n                frontier.put((max(time,grid[x][y+1]),(x,y+1)))\\n```\n```\\nimport queue\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        \\n        ##bfs/dfs TLE\\n        ## now will try A* algorithm\\n        \\n        frontier = queue.PriorityQueue()\\n        visited = set()\\n        \\n        frontier.put((grid[0][0],(0,0)))\\n        ans = 0\\n        \\n        while len(frontier.queue)!=0:\\n            curr = frontier.get()\\n            time = curr[0]\\n            x = curr[1][0]\\n            y = curr[1][1]\\n            ans = max(ans,time)\\n            if x == len(grid)-1 and y == len(grid)-1:\\n                return ans\\n            \\n            visited.add(tuple((x,y)))\\n            \\n            if x-1>=0 and (x-1,y) not in visited:\\n                frontier.put((grid[x-1][y],(x-1,y)))\\n                \\n            if x+1 < len(grid) and (x+1,y) not in visited:\\n                frontier.put((grid[x+1][y],(x+1,y)))\\n                \\n            if y-1>=0 and (x,y-1) not in visited:\\n                frontier.put((grid[x][y-1],(x,y-1)))\\n                \\n            if y+1 < len(grid) and (x,y+1) not in visited:\\n                frontier.put((grid[x][y+1],(x,y+1)))\\n```\n```\\nimport queue\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        \\n        ##bfs/dfs TLE\\n        ## now will try A* algorithm\\n        \\n        frontier = [(grid[0][0],0,0)]\\n        visited = {(-1,-1)}\\n        \\n        #frontier.append()\\n        ans = 0\\n        while len(frontier)!=0:\\n            time,x,y = heapq.heappop(frontier)\\n            ans = max(ans,time)\\n            \\n            if x == len(grid)-1 and y == len(grid)-1:\\n                return ans\\n            \\n            visited.add((x,y))\\n            \\n            if x-1>=0 and (x-1,y) not in visited:\\n                heapq.heappush(frontier, (grid[x-1][y],x-1,y))\\n                #frontier.put((max(time,grid[x-1][y]),(x-1,y)))\\n                \\n            if x+1 < len(grid) and (x+1,y) not in visited:\\n                heapq.heappush(frontier, (grid[x+1][y],x+1,y))\\n                #frontier.put((max(time,grid[x+1][y]),(x+1,y)))\\n                \\n            if y-1>=0 and (x,y-1) not in visited:\\n                heapq.heappush(frontier, (grid[x][y-1],x,y-1))\\n                #frontier.put((max(time,grid[x][y-1]),(x,y-1))\\n                \\n            if y+1 < len(grid) and (x,y+1) not in visited:\\n                heapq.heappush(frontier, (grid[x][y+1],x,y+1))\\n                #frontier.put((max(time,grid[x][y+1]),(x,y+1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645062,
                "title": "lessons-learned",
                "content": "**Similar**:\\nhttps://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/\\nhttps://leetcode.com/problems/swim-in-rising-water/\\nhttps://leetcode.com/problems/path-with-minimum-effort/\\nhttps://leetcode.com/problems/path-with-maximum-minimum-value/\\nhttps://leetcode.com/problems/minimum-path-sum/\\nhttps://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/\\n\\n\\n**Updaed code:**\\n```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Queue<int[]> pq = new PriorityQueue<>((a,b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);\\n        boolean[][] visited = new boolean[m][n];    // can\\'t a second path visit already visited node? not needed, since the node was already visited in best priority time\\n        \\n        pq.add(new int[]{0,0});\\n        visited[0][0] = true;\\n        int max = grid[0][0];\\n        while (!pq.isEmpty()) {\\n            int[] cell = pq.poll();\\n            int i = cell[0];\\n            int j = cell[1];\\n            max = Math.max(max, grid[i][j]);\\n            if (i == m - 1 && j == n - 1) break;\\n            if (isValid(i + 1, j, grid, visited)) {\\n                pq.add(new int[]{i + 1, j});\\n                visited[i + 1][j] = true;\\n            }\\n            if (isValid(i - 1, j, grid, visited)) {\\n                pq.add(new int[]{i - 1, j});\\n                visited[i - 1][j] = true;\\n            }\\n            if (isValid(i, j + 1, grid, visited)) {\\n                pq.add(new int[]{i, j + 1});\\n                visited[i][j + 1] = true;\\n            }\\n            if (isValid(i, j - 1, grid, visited)) {\\n                pq.add(new int[]{i, j - 1});\\n                visited[i][j - 1] = true;\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private boolean isValid(int i, int j, int[][] grid, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) return false;\\n        if (visited[i][j]) return false;\\n        return true;\\n    }\\n}\\n```\\n\\n**Code**:\\n```\\n// Dijkistra\\'s\\nclass Solution {\\n    int[] DIR = new int[]{0, 1, 0, -1, 0};\\n    \\n    public int swimInWater(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        for (int i = 0; i < m; i++) Arrays.fill(dist[i], Integer.MAX_VALUE);\\n        \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        minHeap.offer(new int[]{grid[0][0], 0, 0}); // distance, row, col\\n        while (!minHeap.isEmpty()) {\\n            int[] top = minHeap.poll();\\n            int d = top[0], r = top[1], c = top[2];\\n            if (d > dist[r][c]) continue;\\n            if (r == m - 1 && c == n - 1) return d; // Reach to bottom right\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + DIR[i], nc = c + DIR[i + 1];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n) {\\n                    int newDist = Math.max(d, grid[nr][nc]);    // CRUX: NODE WEIGHT DEFINITION\\n                    if (dist[nr][nc] > newDist) {\\n                        dist[nr][nc] = newDist;\\n                        minHeap.offer(new int[]{dist[nr][nc], nr, nc});\\n                    }\\n                }\\n            }\\n        }\\n        return 0; // Unreachable code, Java require to return interger value.\\n    }\\n}\\n\\n\\n\\n/*\\n\\ndfs: possible\\nundirected: no dp\\n\\nbfs/dijkistra\\'s:\\nneighbour selection: min of adjacent\\nmaintain variable: max(max, neighbour)\\n\\nmin pq on time: row, column, time\\ntime = max(time, neighbour elevation)\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Queue<int[]> pq = new PriorityQueue<>((a,b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);\\n        boolean[][] visited = new boolean[m][n];    // can\\'t a second path visit already visited node? not needed, since the node was already visited in best priority time\\n        \\n        pq.add(new int[]{0,0});\\n        visited[0][0] = true;\\n        int max = grid[0][0];\\n        while (!pq.isEmpty()) {\\n            int[] cell = pq.poll();\\n            int i = cell[0];\\n            int j = cell[1];\\n            max = Math.max(max, grid[i][j]);\\n            if (i == m - 1 && j == n - 1) break;\\n            if (isValid(i + 1, j, grid, visited)) {\\n                pq.add(new int[]{i + 1, j});\\n                visited[i + 1][j] = true;\\n            }\\n            if (isValid(i - 1, j, grid, visited)) {\\n                pq.add(new int[]{i - 1, j});\\n                visited[i - 1][j] = true;\\n            }\\n            if (isValid(i, j + 1, grid, visited)) {\\n                pq.add(new int[]{i, j + 1});\\n                visited[i][j + 1] = true;\\n            }\\n            if (isValid(i, j - 1, grid, visited)) {\\n                pq.add(new int[]{i, j - 1});\\n                visited[i][j - 1] = true;\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private boolean isValid(int i, int j, int[][] grid, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) return false;\\n        if (visited[i][j]) return false;\\n        return true;\\n    }\\n}\\n```\n```\\n// Dijkistra\\'s\\nclass Solution {\\n    int[] DIR = new int[]{0, 1, 0, -1, 0};\\n    \\n    public int swimInWater(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        for (int i = 0; i < m; i++) Arrays.fill(dist[i], Integer.MAX_VALUE);\\n        \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        minHeap.offer(new int[]{grid[0][0], 0, 0}); // distance, row, col\\n        while (!minHeap.isEmpty()) {\\n            int[] top = minHeap.poll();\\n            int d = top[0], r = top[1], c = top[2];\\n            if (d > dist[r][c]) continue;\\n            if (r == m - 1 && c == n - 1) return d; // Reach to bottom right\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + DIR[i], nc = c + DIR[i + 1];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n) {\\n                    int newDist = Math.max(d, grid[nr][nc]);    // CRUX: NODE WEIGHT DEFINITION\\n                    if (dist[nr][nc] > newDist) {\\n                        dist[nr][nc] = newDist;\\n                        minHeap.offer(new int[]{dist[nr][nc], nr, nc});\\n                    }\\n                }\\n            }\\n        }\\n        return 0; // Unreachable code, Java require to return interger value.\\n    }\\n}\\n\\n\\n\\n/*\\n\\ndfs: possible\\nundirected: no dp\\n\\nbfs/dijkistra\\'s:\\nneighbour selection: min of adjacent\\nmaintain variable: max(max, neighbour)\\n\\nmin pq on time: row, column, time\\ntime = max(time, neighbour elevation)\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606530,
                "title": "bfs-union-find",
                "content": "The BFS here needs to consider two points:\\n1. neighboring blocks\\n2. block elevation level <= water level (flooded)\\n\\nYou guys familiar with BFS must know usually we will use a queue to store the possible candidates. \\nThen we pop the front element from the queue and find this element\\'s valid neighbors and push the neighbors into the `queue`.\\n\\nHere is a little different, because the validity depends on `t`, meaning we cannot just add any neighbors to `queue`. Instead, a block only becomes valid when the water level >= the elevation level.\\n\\nThat\\'s where the Union Find comes into play. At every `t`, we union all valid blocks (i.e. neighboring and flooded). After each round, we check if the first block and the last block are in the same group. If yes, we already reached the last block at time `t`; otherwise, we keep stepping up `t` until we reach the last block.\\n\\n```\\nclass Solution {\\nprivate:\\n\\xA0 \\xA0 vector<int> ds;\\n\\xA0 \\xA0 int m, n;\\npublic:\\n\\xA0 \\xA0 int Find(int x) {\\n\\xA0 \\xA0 \\xA0 \\xA0 return ds[x]==-1?x:ds[x] = Find(ds[x]);\\n\\xA0 \\xA0 }\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 void Union(vector<vector<int>>& grid, int i, int j, int ni, int nj, int t) {\\n\\xA0 \\xA0 \\xA0 \\xA0 if(i<0 || i>=m) return;\\n\\xA0 \\xA0 \\xA0 \\xA0 if(ni<0 || ni>=m) return;\\n\\xA0 \\xA0 \\xA0 \\xA0 if(j<0 || j>=n) return;\\n\\xA0 \\xA0 \\xA0 \\xA0 if(nj<0 || nj>=n) return ;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 if(grid[i][j]<=t && grid[ni][nj]<=t) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int parent_i = Find(i*n+j);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int parent_ni = Find(ni*n+nj);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(parent_i != parent_ni) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ds[parent_ni] = parent_i;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 }\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 int swimInWater(vector<vector<int>>& grid) {\\n\\xA0 \\xA0 \\xA0 \\xA0 m = grid.size();\\n\\xA0 \\xA0 \\xA0 \\xA0 n = grid[0].size();\\n\\xA0 \\xA0 \\xA0 \\xA0 ds = vector<int>(m*n, -1);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 // elevation to array(pos1, pos2...)\\n\\xA0 \\xA0 \\xA0 \\xA0 unordered_map<int, vector<pair<int,int>>> s;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=0; i<m; i++) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 for(int j=0; j<n; j++) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 s[grid[i][j]].push_back({i,j});\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 int t = 0;\\n\\xA0 \\xA0 \\xA0 \\xA0 while(true) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // connect all blocks with water level = t\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 vector<pair<int,int>>& blocks = s[t];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(blocks.size()>0) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 for(auto &it : blocks) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // union neighbor\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int i = it.first, j = it.second;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Union(grid, i, j, i+1, j, t);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Union(grid, i, j, i-1, j, t);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Union(grid, i, j, i, j+1, t);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Union(grid, i, j, i, j-1, t);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // check if we have reached final pos\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int ps = Find(0);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int pe = Find(m*n-1);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(ps==pe)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 break;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ++t;\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 return t;\\n\\xA0 \\xA0 }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n\\xA0 \\xA0 vector<int> ds;\\n\\xA0 \\xA0 int m, n;\\npublic:\\n\\xA0 \\xA0 int Find(int x) {\\n\\xA0 \\xA0 \\xA0 \\xA0 return ds[x]==-1?x:ds[x] = Find(ds[x]);\\n\\xA0 \\xA0 }\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 void Union(vector<vector<int>>& grid, int i, int j, int ni, int nj, int t) {\\n\\xA0 \\xA0 \\xA0 \\xA0 if(i<0 || i>=m) return;\\n\\xA0 \\xA0 \\xA0 \\xA0 if(ni<0 || ni>=m) return;\\n\\xA0 \\xA0 \\xA0 \\xA0 if(j<0 || j>=n) return;\\n\\xA0 \\xA0 \\xA0 \\xA0 if(nj<0 || nj>=n) return ;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 if(grid[i][j]<=t && grid[ni][nj]<=t) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int parent_i = Find(i*n+j);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int parent_ni = Find(ni*n+nj);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(parent_i != parent_ni) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ds[parent_ni] = parent_i;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 }\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 int swimInWater(vector<vector<int>>& grid) {\\n\\xA0 \\xA0 \\xA0 \\xA0 m = grid.size();\\n\\xA0 \\xA0 \\xA0 \\xA0 n = grid[0].size();\\n\\xA0 \\xA0 \\xA0 \\xA0 ds = vector<int>(m*n, -1);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 // elevation to array(pos1, pos2...)\\n\\xA0 \\xA0 \\xA0 \\xA0 unordered_map<int, vector<pair<int,int>>> s;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=0; i<m; i++) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 for(int j=0; j<n; j++) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 s[grid[i][j]].push_back({i,j});\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 int t = 0;\\n\\xA0 \\xA0 \\xA0 \\xA0 while(true) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // connect all blocks with water level = t\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 vector<pair<int,int>>& blocks = s[t];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(blocks.size()>0) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 for(auto &it : blocks) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // union neighbor\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int i = it.first, j = it.second;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Union(grid, i, j, i+1, j, t);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Union(grid, i, j, i-1, j, t);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Union(grid, i, j, i, j+1, t);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 Union(grid, i, j, i, j-1, t);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // check if we have reached final pos\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int ps = Find(0);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int pe = Find(m*n-1);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(ps==pe)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 break;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ++t;\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 return t;\\n\\xA0 \\xA0 }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574271,
                "title": "golang-priority-queue-dijkstra-s",
                "content": "Time complexity = O(n<sup>2</sup>log(n))\\n* n<sup>2</sup> is for looping through all the elements in `grid` where `n == len(grid)`. Note that it is n<sup>2</sup> instead of `n * m` because `len(grid) == len(grid[0])`.\\n* log(n) is for the priority queue. Note that this is a computer science log(n) when log(n) == log<sub>2</sub>(n) instead of math where log(n) == log<sub>10</sub>(n).\\n\\n``` go\\ntype key struct {\\n    max int\\n    r, c int\\n}\\n\\ntype RowAndCol struct {\\n    r, c int\\n}\\n\\ntype KeyHeap []key\\n\\nfunc (h KeyHeap) Len() int           { return len(h) }\\nfunc (h KeyHeap) Less(i, j int) bool { return h[i].max < h[j].max }\\nfunc (h KeyHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *KeyHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(key))\\n}\\n\\nfunc (h *KeyHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc swimInWater(grid [][]int) int {\\n    h := &KeyHeap{}\\n\\theap.Init(h)\\n    heap.Push(h, key{ grid[0][0], 0, 0 })\\n    \\n    visited := make(map[RowAndCol] bool)\\n    n := len(grid) // The grid is a square, so len(grid) == len(grid[0])\\n    \\n    addToHeap := func(r, c, max int) {\\n        if r >= 0 && r < n && c >= 0 && c < n && !visited[RowAndCol{ r, c }] {\\n            heap.Push(h, key{ int(math.Max(float64(grid[r][c]), float64(max))), r, c })\\n        }\\n    }\\n    \\n    for h.Len() != 0 {\\n        pop := heap.Pop(h).(key)\\n        r, c := pop.r, pop.c\\n        \\n        if r == n - 1 && c == n - 1 { // if the bottom right most square\\n            return pop.max\\n        }\\n        \\n        visited[ RowAndCol{ r, c } ] = true\\n        \\n        addToHeap(r - 1, c, pop.max)\\n        addToHeap(r + 1, c, pop.max)\\n        addToHeap(r, c - 1, pop.max)\\n        addToHeap(r, c + 1, pop.max)\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\ntype key struct {\\n    max int\\n    r, c int\\n}\\n\\ntype RowAndCol struct {\\n    r, c int\\n}\\n\\ntype KeyHeap []key\\n\\nfunc (h KeyHeap) Len() int           { return len(h) }\\nfunc (h KeyHeap) Less(i, j int) bool { return h[i].max < h[j].max }\\nfunc (h KeyHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *KeyHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(key))\\n}\\n\\nfunc (h *KeyHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc swimInWater(grid [][]int) int {\\n    h := &KeyHeap{}\\n\\theap.Init(h)\\n    heap.Push(h, key{ grid[0][0], 0, 0 })\\n    \\n    visited := make(map[RowAndCol] bool)\\n    n := len(grid) // The grid is a square, so len(grid) == len(grid[0])\\n    \\n    addToHeap := func(r, c, max int) {\\n        if r >= 0 && r < n && c >= 0 && c < n && !visited[RowAndCol{ r, c }] {\\n            heap.Push(h, key{ int(math.Max(float64(grid[r][c]), float64(max))), r, c })\\n        }\\n    }\\n    \\n    for h.Len() != 0 {\\n        pop := heap.Pop(h).(key)\\n        r, c := pop.r, pop.c\\n        \\n        if r == n - 1 && c == n - 1 { // if the bottom right most square\\n            return pop.max\\n        }\\n        \\n        visited[ RowAndCol{ r, c } ] = true\\n        \\n        addToHeap(r - 1, c, pop.max)\\n        addToHeap(r + 1, c, pop.max)\\n        addToHeap(r, c - 1, pop.max)\\n        addToHeap(r, c + 1, pop.max)\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524058,
                "title": "c-dijkstra-algo-priority-queue-10-ms-8-9-mb-beats-96-75",
                "content": "**1.**  Dijkstra algo is used with priority queue containing next smallest possible elevated cell and its x and y co-ordinate on the grid.\\n**2.**  a visited vector (vis) is also maintained to avoid overlap of the path.\\n**3.**  we are also maintaing a maxans variable which contain the maximum elevated cell height which is in its path found during travelsal.\\n**4.**  just one change in this dijkstra algo instead of aiming for minimum cost for the traveling, we are aiming for minimum height difference possible between the cells encountered during traversing the grid.\\n```\\nclass Solution {\\npublic:\\n    //dijakstra algo\\n      #define pii pair<int, pair<int,int>>\\n    \\n   int dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}; \\n    int swimInWater(vector<vector<int>>& v) {\\n        \\n        int n = v.size();\\n       \\n        int maxans = v[0][0];\\n        \\n          vector<vector<bool>> vis(n,vector<bool>(n,false));\\n         priority_queue <pii, vector<pii>, greater<pii>> pq;\\n       pq.push({v[0][0],{0,0}});\\n        \\n        while(!pq.empty()){\\n            pii curr = pq.top();\\n            pq.pop();\\n          \\n            int x = curr.second.first;\\n            int y = curr.second.second;\\n            int t = curr.first;\\n            maxans = max(maxans,v[x][y]);\\n            \\n         //cout<<v[x][y]<<endl;\\n             vis[x][y] = true;\\n            if(x==n-1 && y==n-1){\\n                return maxans;\\n            }\\n            \\n            for(int k =0;k<4;k++){\\n                int newi = x+dir[k][0];\\n                int newj = y+dir[k][1];\\n                \\n                if(newi>=n||newj>=n||newi<0||newj<0||vis[newi][newj]){\\n                    continue;\\n                }\\n                else{\\n                   \\n                    vis[newi][newj] = true;\\n                    pq.push({v[newi][newj],{newi,newj}});\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n       return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //dijakstra algo\\n      #define pii pair<int, pair<int,int>>\\n    \\n   int dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}; \\n    int swimInWater(vector<vector<int>>& v) {\\n        \\n        int n = v.size();\\n       \\n        int maxans = v[0][0];\\n        \\n          vector<vector<bool>> vis(n,vector<bool>(n,false));\\n         priority_queue <pii, vector<pii>, greater<pii>> pq;\\n       pq.push({v[0][0],{0,0}});\\n        \\n        while(!pq.empty()){\\n            pii curr = pq.top();\\n            pq.pop();\\n          \\n            int x = curr.second.first;\\n            int y = curr.second.second;\\n            int t = curr.first;\\n            maxans = max(maxans,v[x][y]);\\n            \\n         //cout<<v[x][y]<<endl;\\n             vis[x][y] = true;\\n            if(x==n-1 && y==n-1){\\n                return maxans;\\n            }\\n            \\n            for(int k =0;k<4;k++){\\n                int newi = x+dir[k][0];\\n                int newj = y+dir[k][1];\\n                \\n                if(newi>=n||newj>=n||newi<0||newj<0||vis[newi][newj]){\\n                    continue;\\n                }\\n                else{\\n                   \\n                    vis[newi][newj] = true;\\n                    pq.push({v[newi][newj],{newi,newj}});\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n       return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1409580,
                "title": "c-binary-search-dfs-solution",
                "content": "```\\nclass Solution {\\n    bool canGo(int i, int j, vector<vector<int>>& grid, int& t, vector<vector<bool>>& vis, int& n) {\\n        if(i < 0 || j < 0 || i >= n || j >= n || grid[i][j] > t || vis[i][j]) {\\n            return false;\\n        }\\n        vis[i][j] = true;\\n        if(i == n-1 && j == n-1) {\\n            return true;\\n        }\\n        return canGo(i+1, j, grid, t, vis, n) || \\n            canGo(i, j+1, grid, t, vis, n) ||\\n            canGo(i-1, j, grid, t, vis, n) ||\\n            canGo(i, j-1, grid, t, vis, n);\\n    }\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = INT_MAX;\\n        int left = 0;\\n        int right = n*n;\\n        while(left <= right) {\\n            vector<vector<bool>> vis(n, vector<bool> (n, false));\\n            int mid = left + (right - left)/2;\\n            if(canGo(0, 0, grid, mid, vis, n)) {\\n                ans = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool canGo(int i, int j, vector<vector<int>>& grid, int& t, vector<vector<bool>>& vis, int& n) {\\n        if(i < 0 || j < 0 || i >= n || j >= n || grid[i][j] > t || vis[i][j]) {\\n            return false;\\n        }\\n        vis[i][j] = true;\\n        if(i == n-1 && j == n-1) {\\n            return true;\\n        }\\n        return canGo(i+1, j, grid, t, vis, n) || \\n            canGo(i, j+1, grid, t, vis, n) ||\\n            canGo(i-1, j, grid, t, vis, n) ||\\n            canGo(i, j-1, grid, t, vis, n);\\n    }\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = INT_MAX;\\n        int left = 0;\\n        int right = n*n;\\n        while(left <= right) {\\n            vector<vector<bool>> vis(n, vector<bool> (n, false));\\n            int mid = left + (right - left)/2;\\n            if(canGo(0, 0, grid, mid, vis, n)) {\\n                ans = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363108,
                "title": "java-dijkstra",
                "content": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        \\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n        int n = grid.length;\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        \\n        queue.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n                \\n        int max = grid[n - 1][n - 1];\\n        \\n        while (!queue.isEmpty()) {\\n            int[] cell = queue.poll();\\n            max = Math.max(max, grid[cell[0]][cell[1]]);\\n            if (cell[0] == n - 1 && cell[1] == n - 1) {\\n                return max;\\n            }\\n            for (int[] dir : directions) {\\n                int i = cell[0] + dir[0];\\n                int j = cell[1] + dir[1];\\n                if (i >= 0 && i < n && j >= 0 && j < n && !visited[i][j]) {\\n                    visited[i][j] = true;\\n                    queue.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        \\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return 0;\\n        }\\n        int n = grid.length;\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        \\n        queue.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n                \\n        int max = grid[n - 1][n - 1];\\n        \\n        while (!queue.isEmpty()) {\\n            int[] cell = queue.poll();\\n            max = Math.max(max, grid[cell[0]][cell[1]]);\\n            if (cell[0] == n - 1 && cell[1] == n - 1) {\\n                return max;\\n            }\\n            for (int[] dir : directions) {\\n                int i = cell[0] + dir[0];\\n                int j = cell[1] + dir[1];\\n                if (i >= 0 && i < n && j >= 0 && j < n && !visited[i][j]) {\\n                    visited[i][j] = true;\\n                    queue.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358415,
                "title": "python-solution-using-heap",
                "content": "import heapq\\nclass Solution:\\n\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        h = [(grid[0][0],(0,0))]\\n        # avoid visiting the same index more than once\\n        visited = set()\\n\\n        # every time, we traverse the path and find the global minimum \\n        while(h):\\n            curr_max, (i, j) = heapq.heappop(h)\\n            if (i,j) in visited:\\n                continue\\n            visited.add((i, j))\\n            if i == n-1 and j == n-1:\\n                return curr_max\\n            for dx, dy in ((1,0),(0,1),(-1,0),(0,-1)):\\n                if 0<=i+dx<n and 0<=j+dy<n:\\n                    heapq.heappush(h, (max(curr_max, grid[i+dx][j+dy]), (i+dx, j+dy)))",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "import heapq\\nclass Solution:\\n\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        h = [(grid[0][0],(0,0))]\\n        # avoid visiting the same index more than once\\n        visited = set()\\n\\n        # every time, we traverse the path and find the global minimum \\n        while(h):\\n            curr_max, (i, j) = heapq.heappop(h)\\n            if (i,j) in visited:\\n                continue\\n            visited.add((i, j))\\n            if i == n-1 and j == n-1:\\n                return curr_max\\n            for dx, dy in ((1,0),(0,1),(-1,0),(0,-1)):\\n                if 0<=i+dx<n and 0<=j+dy<n:\\n                    heapq.heappush(h, (max(curr_max, grid[i+dx][j+dy]), (i+dx, j+dy)))",
                "codeTag": "Java"
            },
            {
                "id": 1328680,
                "title": "clean-priority-queue-solution-java-c",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n = grid.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        pq.offer(new int[]{grid[0][0], 0, 0});\\n        boolean[][] vis = new boolean[n][n];\\n        vis[0][0] = true;\\n        int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int ans = 0;\\n        while (!pq.isEmpty()) {\\n            int val = pq.peek()[0], i = pq.peek()[1], j = pq.peek()[2];\\n            pq.poll();\\n            ans = Math.max(ans, grid[i][j]);\\n            if (i == n - 1 && j == n - 1) break;\\n            for (int d = 0; d < dir.length; ++d) {\\n                int nr = i + dir[d][0];\\n                int nc = j + dir[d][1];\\n                if (nr >= 0 && nc >= 0 && nr < n && nc < n && !vis[nr][nc]) {\\n                    vis[nr][nc] = true;\\n                    pq.offer(new int[]{grid[nr][nc], nr, nc});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> que;\\n        que.push({grid[0][0], 0, 0});\\n        vector<vector<int>> dir {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        vector<vector<bool>> vis(n, vector<bool> (n, false));\\n        vis[0][0] = true;\\n        int level = 0;\\n        while (!que.empty()) {\\n            vector<int> temp = que.top();\\n            que.pop();\\n            int val = temp[0], i = temp[1], j = temp[2];\\n            level = max(level, grid[i][j]);\\n            if (i == n - 1 and j == n - 1) break;\\n            for (int d = 0; d < dir.size(); ++d) {\\n                int r = i + dir[d][0];\\n                int c = j + dir[d][1];\\n                if (r >= 0 and c >= 0 and r < n and j < n and !vis[r][c]) {\\n                    vis[r][c] = true;\\n                    que.push({grid[r][c], r, c});\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n = grid.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        pq.offer(new int[]{grid[0][0], 0, 0});\\n        boolean[][] vis = new boolean[n][n];\\n        vis[0][0] = true;\\n        int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        int ans = 0;\\n        while (!pq.isEmpty()) {\\n            int val = pq.peek()[0], i = pq.peek()[1], j = pq.peek()[2];\\n            pq.poll();\\n            ans = Math.max(ans, grid[i][j]);\\n            if (i == n - 1 && j == n - 1) break;\\n            for (int d = 0; d < dir.length; ++d) {\\n                int nr = i + dir[d][0];\\n                int nc = j + dir[d][1];\\n                if (nr >= 0 && nc >= 0 && nr < n && nc < n && !vis[nr][nc]) {\\n                    vis[nr][nc] = true;\\n                    pq.offer(new int[]{grid[nr][nc], nr, nc});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> que;\\n        que.push({grid[0][0], 0, 0});\\n        vector<vector<int>> dir {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        vector<vector<bool>> vis(n, vector<bool> (n, false));\\n        vis[0][0] = true;\\n        int level = 0;\\n        while (!que.empty()) {\\n            vector<int> temp = que.top();\\n            que.pop();\\n            int val = temp[0], i = temp[1], j = temp[2];\\n            level = max(level, grid[i][j]);\\n            if (i == n - 1 and j == n - 1) break;\\n            for (int d = 0; d < dir.size(); ++d) {\\n                int r = i + dir[d][0];\\n                int c = j + dir[d][1];\\n                if (r >= 0 and c >= 0 and r < n and j < n and !vis[r][c]) {\\n                    vis[r][c] = true;\\n                    que.push({grid[r][c], r, c});\\n                }\\n            }\\n        }\\n        return level;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285547,
                "title": "c-solution-using-binary-search-and-dfs-commented",
                "content": "***Idea***\\nWe need to find the lowest possible value for T such that the the bottom right of the matrix is reachable. \\n\\n***Solution***\\nDo a binary search on the interval [0, N\\\\*N-1] and choose the lowest value so that we can still traverse the matrix to the cell (N-1,N-1) (to check this property, we can do a DFS, BFS, etc starting from the top left. I chose DFS because it\\'s shorter)\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    // Fill every possible cell which can be visited\\n    void fillPath(vector<vector<int>> & grid, vector<vector<bool>> & visited, int row, int col, int t)\\n    {\\n        // Check for being in-boundary\\n        if(row < 0 || col < 0 || row >= grid.size() || col >= grid.size())\\n            return;\\n        // Check if the cell can be swimmed through or was visited\\n        if(grid[row][col] > t || visited[row][col])\\n            return;\\n        // Visit the cell and try every neighbour (down, up, left, right)\\n        visited[row][col] = true;\\n        fillPath(grid, visited, row + 1, col, t);\\n        fillPath(grid, visited, row - 1, col, t);\\n        fillPath(grid, visited, row, col - 1, t);\\n        fillPath(grid, visited, row, col + 1, t);\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int left = 0;\\n        int right = n * n - 1;\\n        int mid, bestT;\\n        // Binary search for a minimum T value such that it is possible to arrive at (N-1, N-1)\\n        // Left is the lower limit and right is the higher limit of T\\n        while(left <= right)\\n        {\\n            mid = left + (right - left) / 2;\\n            vector<vector<bool>> visited (n, vector<bool>(n));\\n            \\n            fillPath(grid, visited, 0, 0, mid);\\n            \\n            // If (N-1, N-1) is reacheable, bestT is updated and we can try to lower the right limit. \\n            // Else, we increase the left limit and try again\\n            if(visited[n - 1][n - 1])\\n            {\\n                bestT = mid;\\n                right = mid - 1;\\n            }\\n            else\\n                left = mid + 1;\\n        }\\n        return bestT;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Fill every possible cell which can be visited\\n    void fillPath(vector<vector<int>> & grid, vector<vector<bool>> & visited, int row, int col, int t)\\n    {\\n        // Check for being in-boundary\\n        if(row < 0 || col < 0 || row >= grid.size() || col >= grid.size())\\n            return;\\n        // Check if the cell can be swimmed through or was visited\\n        if(grid[row][col] > t || visited[row][col])\\n            return;\\n        // Visit the cell and try every neighbour (down, up, left, right)\\n        visited[row][col] = true;\\n        fillPath(grid, visited, row + 1, col, t);\\n        fillPath(grid, visited, row - 1, col, t);\\n        fillPath(grid, visited, row, col - 1, t);\\n        fillPath(grid, visited, row, col + 1, t);\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int left = 0;\\n        int right = n * n - 1;\\n        int mid, bestT;\\n        // Binary search for a minimum T value such that it is possible to arrive at (N-1, N-1)\\n        // Left is the lower limit and right is the higher limit of T\\n        while(left <= right)\\n        {\\n            mid = left + (right - left) / 2;\\n            vector<vector<bool>> visited (n, vector<bool>(n));\\n            \\n            fillPath(grid, visited, 0, 0, mid);\\n            \\n            // If (N-1, N-1) is reacheable, bestT is updated and we can try to lower the right limit. \\n            // Else, we increase the left limit and try again\\n            if(visited[n - 1][n - 1])\\n            {\\n                bestT = mid;\\n                right = mid - 1;\\n            }\\n            else\\n                left = mid + 1;\\n        }\\n        return bestT;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285278,
                "title": "swim-in-rising-water-c-binary-search-dfs",
                "content": "### Swim in Rising Water with BS and DFS Code\\n#### clean code and the explains in the comment\\n\\n[The Problem](https://leetcode.com/explore/challenge/card/june-leetcoding-challenge-2021/605/week-3-june-15th-june-21st/3785/)\\n```\\nclass Solution {\\npublic:\\n    \\n    bool _ = []{ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);return false;}();    \\n    \\n\\t// Check the boundry of the grid and make sure that this cell didn\\'t visit before\\n    \\n\\tstatic bool is_valid(int r, int c, int n, vector < vector < int > >& vis){\\n        return (r >= 0 && r < n && c >= 0 && c < n && !vis[r][c]);\\n    }\\n    \\n    static bool DFS(vector < vector < int > >& grid, vector < vector < int > >& vis, int r, int c, int n, int T){\\n        if(grid[r][c] > T) return false;\\n        if(r == n - 1 && c == n - 1) return true;\\n        vis[r][c] = true;\\n\\t   //  Make a vector with the 4 adjacent directory\\n\\t   vector < pair < int, int > > dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n       // Check all the adjacent cells of the current cell if one reach the goal will return true\\n\\t\\tfor(auto& [x, y] : dir){\\n            if(is_valid(r + x, c + y, n, vis))\\n                if(DFS(grid, vis, r + x, c + y, n, T)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        // Make a binary search for the smallest T that acheive our goal\\n\\t\\t// the boundry of the binary search is the Min and the Max elemet in the grid \\n\\t\\tint n = grid.size();\\n        int l = 0, r = n * n, best = -1;\\n        while(l <= r){\\n            int m = l + (r - l) / 2;\\n            vector < vector < int > > vis(n + 1, vector < int > (n + 1));\\n            (DFS(grid, vis, 0, 0, n, m) ? r = m - 1, best = m : l = m + 1);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool _ = []{ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);return false;}();    \\n    \\n\\t// Check the boundry of the grid and make sure that this cell didn\\'t visit before\\n    \\n\\tstatic bool is_valid(int r, int c, int n, vector < vector < int > >& vis){\\n        return (r >= 0 && r < n && c >= 0 && c < n && !vis[r][c]);\\n    }\\n    \\n    static bool DFS(vector < vector < int > >& grid, vector < vector < int > >& vis, int r, int c, int n, int T){\\n        if(grid[r][c] > T) return false;\\n        if(r == n - 1 && c == n - 1) return true;\\n        vis[r][c] = true;\\n\\t   //  Make a vector with the 4 adjacent directory\\n\\t   vector < pair < int, int > > dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n       // Check all the adjacent cells of the current cell if one reach the goal will return true\\n\\t\\tfor(auto& [x, y] : dir){\\n            if(is_valid(r + x, c + y, n, vis))\\n                if(DFS(grid, vis, r + x, c + y, n, T)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        // Make a binary search for the smallest T that acheive our goal\\n\\t\\t// the boundry of the binary search is the Min and the Max elemet in the grid \\n\\t\\tint n = grid.size();\\n        int l = 0, r = n * n, best = -1;\\n        while(l <= r){\\n            int m = l + (r - l) / 2;\\n            vector < vector < int > > vis(n + 1, vector < int > (n + 1));\\n            (DFS(grid, vis, 0, 0, n, m) ? r = m - 1, best = m : l = m + 1);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1284949,
                "title": "swim-in-rising-water-c-explained",
                "content": "This problem is similar to find min cost path or shortest path (in a weighted graph), So we will ue Diakstra algo;\\n\\n1. We need a (min-heap) priority queue that contains -> cost, row, col\\n2. Every time we find a valid (r, c), we push it with its cost in the queue\\n3. As the que asked, we can go with the same cost till the curr cost is max and whenever we find a point which is min of all neighbouring point then we will greedily proceed towards the min elements of all the neighbours (min heap) \\n\\n```\\n#define tp tuple<int,int,int>\\nclass Solution {\\npublic:\\n    vector<int> dx{1,0,0,-1}, dy{0,1,-1,0};\\n    bool isSafe(int i, int j, int x, int y){\\n        return i>=0 && j>=0 && i<x && j<y;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        priority_queue< tp, vector<tp>, greater<tp>> pq;\\n        int n = grid.size();\\n        pq.push({grid[0][0],0,0});\\n        vector<vector<bool>> vis(n, vector<bool> (n, 0));\\n        vis[0][0]=true;\\n        int ans = -1;\\n        while(!pq.empty()){\\n            auto [cost, r, c] = pq.top();\\n            pq.pop();\\n            ans = max(ans, cost);\\n            vis[r][c] = true;\\n            if(vis[n-1][n-1])return ans;\\n            for(int i=0; i<4; i++){\\n                int nx = r+dx[i], ny = c+dy[i];\\n                if(isSafe(nx, ny, grid.size(), grid[0].size()) && !vis[nx][ny]){\\n                    pq.push({(grid[nx][ny]),nx,ny});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# If you find it helpful, plz upvote",
                "solutionTags": [],
                "code": "```\\n#define tp tuple<int,int,int>\\nclass Solution {\\npublic:\\n    vector<int> dx{1,0,0,-1}, dy{0,1,-1,0};\\n    bool isSafe(int i, int j, int x, int y){\\n        return i>=0 && j>=0 && i<x && j<y;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        priority_queue< tp, vector<tp>, greater<tp>> pq;\\n        int n = grid.size();\\n        pq.push({grid[0][0],0,0});\\n        vector<vector<bool>> vis(n, vector<bool> (n, 0));\\n        vis[0][0]=true;\\n        int ans = -1;\\n        while(!pq.empty()){\\n            auto [cost, r, c] = pq.top();\\n            pq.pop();\\n            ans = max(ans, cost);\\n            vis[r][c] = true;\\n            if(vis[n-1][n-1])return ans;\\n            for(int i=0; i<4; i++){\\n                int nx = r+dx[i], ny = c+dy[i];\\n                if(isSafe(nx, ny, grid.size(), grid[0].size()) && !vis[nx][ny]){\\n                    pq.push({(grid[nx][ny]),nx,ny});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262146,
                "title": "binary-search-dfs-beats-99-63-of-java-solution",
                "content": "Binary Search over N*N-1, and for each value check if we can reach the (n-1,n-1) cell with that value.\\n```class Solution {\\n    int N;\\n    boolean[][] visited;\\n    int dx[] = {1, -1, 0, 0};\\n    int dy[] = {0, 0, 1, -1};\\n    int m;\\n    \\n    public boolean isValid(int x, int y){\\n        if(x==N || x<0 || y==N || y<0)\\n            return false;\\n        if(visited[x][y])\\n            return false;\\n        return true;\\n    }\\n    \\n    public boolean dfs(int x, int y, int[][] grid, int time){\\n        visited[x][y] = true;\\n        if(x==N-1 && y==N-1 && time<=m)\\n            return true;\\n        if(time > m)\\n            return false;\\n        for(int i=0; i<4; i++){\\n            if(isValid(x+dx[i], y+dy[i])){\\n                int now = Math.max(time, grid[x+dx[i]][y+dy[i]]);\\n                if(dfs(x+dx[i], y+dy[i], grid, now))\\n                    return true;\\n            }\\n                \\n        }\\n        return false;\\n    }\\n    \\n    public int swimInWater(int[][] grid) {\\n        N = grid.length;\\n        int l = -1, r = N*N;\\n        while(l+1 < r){\\n            m = (l+r)/2;\\n            visited = new boolean[N][N];\\n            if(dfs(0, 0, grid, grid[0][0]))\\n                r = m;\\n            else\\n                l = m;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    int N;\\n    boolean[][] visited;\\n    int dx[] = {1, -1, 0, 0};\\n    int dy[] = {0, 0, 1, -1};\\n    int m;\\n    \\n    public boolean isValid(int x, int y){\\n        if(x==N || x<0 || y==N || y<0)\\n            return false;\\n        if(visited[x][y])\\n            return false;\\n        return true;\\n    }\\n    \\n    public boolean dfs(int x, int y, int[][] grid, int time){\\n        visited[x][y] = true;\\n        if(x==N-1 && y==N-1 && time<=m)\\n            return true;\\n        if(time > m)\\n            return false;\\n        for(int i=0; i<4; i++){\\n            if(isValid(x+dx[i], y+dy[i])){\\n                int now = Math.max(time, grid[x+dx[i]][y+dy[i]]);\\n                if(dfs(x+dx[i], y+dy[i], grid, now))\\n                    return true;\\n            }\\n                \\n        }\\n        return false;\\n    }\\n    \\n    public int swimInWater(int[][] grid) {\\n        N = grid.length;\\n        int l = -1, r = N*N;\\n        while(l+1 < r){\\n            m = (l+r)/2;\\n            visited = new boolean[N][N];\\n            if(dfs(0, 0, grid, grid[0][0]))\\n                r = m;\\n            else\\n                l = m;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257806,
                "title": "python3-dijkstra-s-algo",
                "content": "\\n```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        n = len(grid) # dimension\\n        pq = [(grid[0][0], 0, 0)]\\n        seen = {(0, 0)}\\n        while pq: \\n            k, i, j = heappop(pq)\\n            if i == j == n-1: return k\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < n and 0 <= jj < n and (ii, jj) not in seen:\\n                    heappush(pq, (max(k, grid[ii][jj]), ii, jj))\\n                    seen.add((ii, jj))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        n = len(grid) # dimension\\n        pq = [(grid[0][0], 0, 0)]\\n        seen = {(0, 0)}\\n        while pq: \\n            k, i, j = heappop(pq)\\n            if i == j == n-1: return k\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < n and 0 <= jj < n and (ii, jj) not in seen:\\n                    heappush(pq, (max(k, grid[ii][jj]), ii, jj))\\n                    seen.add((ii, jj))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244565,
                "title": "c-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int parent[2505], size[2505];\\n    \\n    // function to find the parent of node v\\n    int findSet(int v) \\n    {\\n        if (v == parent[v])\\n            return v;\\n        return parent[v] = findSet(parent[v]);\\n    }\\n    \\n    // function to make a node v in dsu\\n    void makeSet(int v) \\n    {\\n        parent[v] = v;\\n        size[v] = 1;\\n    }\\n\\n    // function to union the trees of node a and b\\n    void unionSets(int a, int b) \\n    {\\n        a = findSet(a);\\n        b = findSet(b);\\n        \\n        if (a != b) \\n        {\\n            if (size[a] < size[b])\\n                swap(a, b);\\n            \\n            parent[b] = a;\\n            size[a] += size[b];\\n        }\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        map<int, pair<int, int>> pos;\\n        \\n        // storing the position of each value in pos and initialising dsu\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                pos[grid[i][j]] = {i, j};\\n                makeSet(grid[i][j]);\\n            }\\n        }\\n        \\n        // at ith iteration, we connect node i to its neighbours if possible \\n        // and if the parent of grid[0][0] and grid[n-1][n-1] is same that means \\n        // they belong to one connected component so i is our answer\\n        for(int i=0; i<n*n; i++)\\n        {\\n            auto ele = pos[i];\\n            \\n            if(ele.first - 1 >= 0 && grid[ele.first-1][ele.second] <= i)\\n                unionSets(i, grid[ele.first-1][ele.second]);\\n            \\n            if(ele.first + 1 < n && grid[ele.first+1][ele.second] <= i)\\n                unionSets(i, grid[ele.first+1][ele.second]);\\n            \\n            if(ele.second - 1 >= 0 && grid[ele.first][ele.second-1] <= i)\\n                unionSets(i, grid[ele.first][ele.second-1]);\\n            \\n            if(ele.second + 1 < n && grid[ele.first][ele.second+1] <= i)\\n                unionSets(i, grid[ele.first][ele.second+1]);\\n            \\n            if(findSet(grid[0][0]) == findSet(grid[n-1][n-1]))\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int parent[2505], size[2505];\\n    \\n    // function to find the parent of node v\\n    int findSet(int v) \\n    {\\n        if (v == parent[v])\\n            return v;\\n        return parent[v] = findSet(parent[v]);\\n    }\\n    \\n    // function to make a node v in dsu\\n    void makeSet(int v) \\n    {\\n        parent[v] = v;\\n        size[v] = 1;\\n    }\\n\\n    // function to union the trees of node a and b\\n    void unionSets(int a, int b) \\n    {\\n        a = findSet(a);\\n        b = findSet(b);\\n        \\n        if (a != b) \\n        {\\n            if (size[a] < size[b])\\n                swap(a, b);\\n            \\n            parent[b] = a;\\n            size[a] += size[b];\\n        }\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        map<int, pair<int, int>> pos;\\n        \\n        // storing the position of each value in pos and initialising dsu\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                pos[grid[i][j]] = {i, j};\\n                makeSet(grid[i][j]);\\n            }\\n        }\\n        \\n        // at ith iteration, we connect node i to its neighbours if possible \\n        // and if the parent of grid[0][0] and grid[n-1][n-1] is same that means \\n        // they belong to one connected component so i is our answer\\n        for(int i=0; i<n*n; i++)\\n        {\\n            auto ele = pos[i];\\n            \\n            if(ele.first - 1 >= 0 && grid[ele.first-1][ele.second] <= i)\\n                unionSets(i, grid[ele.first-1][ele.second]);\\n            \\n            if(ele.first + 1 < n && grid[ele.first+1][ele.second] <= i)\\n                unionSets(i, grid[ele.first+1][ele.second]);\\n            \\n            if(ele.second - 1 >= 0 && grid[ele.first][ele.second-1] <= i)\\n                unionSets(i, grid[ele.first][ele.second-1]);\\n            \\n            if(ele.second + 1 < n && grid[ele.first][ele.second+1] <= i)\\n                unionSets(i, grid[ele.first][ele.second+1]);\\n            \\n            if(findSet(grid[0][0]) == findSet(grid[n-1][n-1]))\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206447,
                "title": "c-binary-search-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dx[4]={1,0,0,-1};\\n    int dy[4]={0,1,-1,0};\\n    bool possible(int i,int j,vector<vector<int>>& grid,int time,vector<vector<bool>>&vis)  //DFS\\n    {\\n        if(i<0 || j<0 || i>=n || j>=n || grid[i][j]>time || vis[i][j])\\n            return false;\\n        vis[i][j]=true;\\n        if(i==n-1 && j==n-1)\\n            return true;\\n        int x=grid[i][j];\\n        bool res=false;\\n        for(int k=0;k<4;k++)\\n        {\\n            res=res || possible(i+dx[k],j+dy[k],grid,time,vis);\\n        }\\n        return res;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) \\n    {\\n        n=grid.size();\\n        int l=grid[0][0],h=(n*n)-1;\\n        int res=h;\\n        while(l<=h)                                            //Binary Search\\n        {\\n            int mid=(l+h)/2;\\n            vector<vector<bool>>vis(n,vector<bool>(n));\\n            if(possible(0,0,grid,mid,vis))\\n            {\\n                res=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dx[4]={1,0,0,-1};\\n    int dy[4]={0,1,-1,0};\\n    bool possible(int i,int j,vector<vector<int>>& grid,int time,vector<vector<bool>>&vis)  //DFS\\n    {\\n        if(i<0 || j<0 || i>=n || j>=n || grid[i][j]>time || vis[i][j])\\n            return false;\\n        vis[i][j]=true;\\n        if(i==n-1 && j==n-1)\\n            return true;\\n        int x=grid[i][j];\\n        bool res=false;\\n        for(int k=0;k<4;k++)\\n        {\\n            res=res || possible(i+dx[k],j+dy[k],grid,time,vis);\\n        }\\n        return res;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) \\n    {\\n        n=grid.size();\\n        int l=grid[0][0],h=(n*n)-1;\\n        int res=h;\\n        while(l<=h)                                            //Binary Search\\n        {\\n            int mid=(l+h)/2;\\n            vector<vector<bool>>vis(n,vector<bool>(n));\\n            if(possible(0,0,grid,mid,vis))\\n            {\\n                res=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035134,
                "title": "java-solution-union-find-o-m-n-log-m-n",
                "content": "\\n    static int[] parent;\\n\\tstatic int[] rank;\\n    \\n\\tpublic static int swimInWater(int[][] grid) {\\n\\n\\t\\tint r = grid.length;\\n\\t\\tint c = grid[0].length;\\n\\t\\tint prod = r * c;\\n\\n\\t\\tint low = grid[0][0];\\n\\t\\tint high = prod - 1;\\n\\t\\tint ans = 0;\\n\\t\\tint[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n\\t\\twhile (low <= high) {\\n\\n            parent = new int[prod];\\n\\t\\t    rank = new int[prod];\\n            for (int i = 0; i < prod; i++)\\n\\t\\t\\t    parent[i] = i;\\n\\t\\t\\tint mid = (low + high) >> 1;\\n\\t\\t\\tif (canSwim(grid, mid, r, c, dirs)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic static boolean canSwim(int[][] grid, int time, int er, int ec, int[][] dirs) {\\n\\n\\t\\tfor (int i = 0; i < er; i++) {\\n\\t\\t\\tfor (int j = 0; j < ec; j++) {\\n\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\tint row = i + dir[0];\\n\\t\\t\\t\\t\\tint col = j + dir[1];\\n\\t\\t\\t\\t\\tif (isSafe(grid, row, col, er, ec) && grid[i][j] <= time && grid[row][col] <= time)\\n\\t\\t\\t\\t\\t\\tunion(grid[i][j], grid[row][col]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn find(grid[0][0]) == find(grid[er - 1][ec - 1]);\\n\\t}\\n    \\n\\tpublic static boolean isSafe(int[][] grid, int r, int c, int er, int ec) {\\n\\t\\tif (r < 0 || c < 0 || r >= er || c >= ec)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n    \\n    public static int find(int x) {\\n\\n\\t\\tif (parent[x] == x)\\n\\t\\t\\treturn x;\\n\\n\\t\\tint temp = find(parent[x]);\\n\\t\\tparent[x] = temp; // path by compression step\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tpublic static void union(int x, int y) {\\n\\n\\t\\tint parentx = find(x);\\n\\t\\tint parenty = find(y);\\n\\n\\t\\tif (parentx == parenty)\\n\\t\\t\\treturn;\\n\\n\\t\\tint rankx = rank[parentx];\\n\\t\\tint ranky = rank[parenty];\\n\\n\\t\\t// union by rank step\\n\\n\\t\\tif (rankx < ranky)\\n\\t\\t\\tparent[parentx] = parenty;\\n\\t\\telse if (rankx > ranky)\\n\\t\\t\\tparent[parenty] = parentx;\\n\\t\\telse {\\n\\t\\t\\tparent[parentx] = parenty;\\n\\t\\t\\trank[parenty]++;\\n\\t\\t}\\n\\n\\t}\\n    \\n",
                "solutionTags": [],
                "code": "\\n    static int[] parent;\\n\\tstatic int[] rank;\\n    \\n\\tpublic static int swimInWater(int[][] grid) {\\n\\n\\t\\tint r = grid.length;\\n\\t\\tint c = grid[0].length;\\n\\t\\tint prod = r * c;\\n\\n\\t\\tint low = grid[0][0];\\n\\t\\tint high = prod - 1;\\n\\t\\tint ans = 0;\\n\\t\\tint[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n\\t\\twhile (low <= high) {\\n\\n            parent = new int[prod];\\n\\t\\t    rank = new int[prod];\\n            for (int i = 0; i < prod; i++)\\n\\t\\t\\t    parent[i] = i;\\n\\t\\t\\tint mid = (low + high) >> 1;\\n\\t\\t\\tif (canSwim(grid, mid, r, c, dirs)) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic static boolean canSwim(int[][] grid, int time, int er, int ec, int[][] dirs) {\\n\\n\\t\\tfor (int i = 0; i < er; i++) {\\n\\t\\t\\tfor (int j = 0; j < ec; j++) {\\n\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\tint row = i + dir[0];\\n\\t\\t\\t\\t\\tint col = j + dir[1];\\n\\t\\t\\t\\t\\tif (isSafe(grid, row, col, er, ec) && grid[i][j] <= time && grid[row][col] <= time)\\n\\t\\t\\t\\t\\t\\tunion(grid[i][j], grid[row][col]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn find(grid[0][0]) == find(grid[er - 1][ec - 1]);\\n\\t}\\n    \\n\\tpublic static boolean isSafe(int[][] grid, int r, int c, int er, int ec) {\\n\\t\\tif (r < 0 || c < 0 || r >= er || c >= ec)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}\\n    \\n    public static int find(int x) {\\n\\n\\t\\tif (parent[x] == x)\\n\\t\\t\\treturn x;\\n\\n\\t\\tint temp = find(parent[x]);\\n\\t\\tparent[x] = temp; // path by compression step\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tpublic static void union(int x, int y) {\\n\\n\\t\\tint parentx = find(x);\\n\\t\\tint parenty = find(y);\\n\\n\\t\\tif (parentx == parenty)\\n\\t\\t\\treturn;\\n\\n\\t\\tint rankx = rank[parentx];\\n\\t\\tint ranky = rank[parenty];\\n\\n\\t\\t// union by rank step\\n\\n\\t\\tif (rankx < ranky)\\n\\t\\t\\tparent[parentx] = parenty;\\n\\t\\telse if (rankx > ranky)\\n\\t\\t\\tparent[parenty] = parentx;\\n\\t\\telse {\\n\\t\\t\\tparent[parentx] = parenty;\\n\\t\\t\\trank[parenty]++;\\n\\t\\t}\\n\\n\\t}\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 543862,
                "title": "c-sortedset",
                "content": "```\\npublic class Solution {\\n    private class Location\\n    {\\n        public int x;\\n        public int y;\\n        public int time;\\n        \\n        public Location(int t, int x, int y)\\n        {\\n            this.time = t;\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    public int SwimInWater(int[][] grid) {\\n        int n = grid.Length;\\n        var sortedSet = new SortedSet<Location>(\\n            Comparer<Location>.Create((a,b) => {\\n                return a.time == b.time ? a.x - b.x : a.time - b.time;\\n            }));\\n        \\n        sortedSet.Add(new Location(grid[0][0], 0, 0));\\n        \\n        var visited = new int[n, n];\\n        visited[0, 0] = 1;\\n        int res = 0;\\n        \\n        int[] dirs = new int[] {0, 1, 0, -1, 0};\\n        \\n        while (sortedSet.Any())\\n        {\\n            var location = sortedSet.Min;\\n            sortedSet.Remove(location);\\n            \\n            res = Math.Max(res, location.time);\\n            if (location.x == n-1 && location.y == n-1) return res;\\n            \\n            for (int i = 0; i < 4; i++)\\n            {\\n                int x = location.x + dirs[i];\\n                int y = location.y + dirs[i+1];\\n                \\n                if (x >= 0 && y >= 0 && x < n && y < n && visited[x, y] == 0)\\n                {\\n                    visited[x, y] = 1;\\n                    sortedSet.Add(new Location(grid[x][y], x, y));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private class Location\\n    {\\n        public int x;\\n        public int y;\\n        public int time;\\n        \\n        public Location(int t, int x, int y)\\n        {\\n            this.time = t;\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    public int SwimInWater(int[][] grid) {\\n        int n = grid.Length;\\n        var sortedSet = new SortedSet<Location>(\\n            Comparer<Location>.Create((a,b) => {\\n                return a.time == b.time ? a.x - b.x : a.time - b.time;\\n            }));\\n        \\n        sortedSet.Add(new Location(grid[0][0], 0, 0));\\n        \\n        var visited = new int[n, n];\\n        visited[0, 0] = 1;\\n        int res = 0;\\n        \\n        int[] dirs = new int[] {0, 1, 0, -1, 0};\\n        \\n        while (sortedSet.Any())\\n        {\\n            var location = sortedSet.Min;\\n            sortedSet.Remove(location);\\n            \\n            res = Math.Max(res, location.time);\\n            if (location.x == n-1 && location.y == n-1) return res;\\n            \\n            for (int i = 0; i < 4; i++)\\n            {\\n                int x = location.x + dirs[i];\\n                int y = location.y + dirs[i+1];\\n                \\n                if (x >= 0 && y >= 0 && x < n && y < n && visited[x, y] == 0)\\n                {\\n                    visited[x, y] = 1;\\n                    sortedSet.Add(new Location(grid[x][y], x, y));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533507,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        // bfs\\n        const vector<pair<int, int>> dirs{{-1,0},{1,0},{0,-1},{0,1}};\\n        int n = grid.size();\\n        vector<vector<int>> v(n, vector<int>(n, INT_MAX));\\n        v[0][0] = grid[0][0];\\n        queue<pair<int, int>> q;\\n        q.emplace(0, 0);\\n        \\n        while(!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            for(const auto& d : dirs)\\n            {\\n                int i = x + d.first, j = y + d.second;\\n                if(i < 0 || i >= n || j < 0 || j >= n) continue;\\n                int tmp = max(v[x][y], grid[i][j]);\\n                if(tmp < v[i][j])\\n                {\\n                    q.emplace(i,j);\\n                    v[i][j] = tmp;\\n                }\\n            }\\n        }\\n        \\n        return v[n-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        // bfs\\n        const vector<pair<int, int>> dirs{{-1,0},{1,0},{0,-1},{0,1}};\\n        int n = grid.size();\\n        vector<vector<int>> v(n, vector<int>(n, INT_MAX));\\n        v[0][0] = grid[0][0];\\n        queue<pair<int, int>> q;\\n        q.emplace(0, 0);\\n        \\n        while(!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            for(const auto& d : dirs)\\n            {\\n                int i = x + d.first, j = y + d.second;\\n                if(i < 0 || i >= n || j < 0 || j >= n) continue;\\n                int tmp = max(v[x][y], grid[i][j]);\\n                if(tmp < v[i][j])\\n                {\\n                    q.emplace(i,j);\\n                    v[i][j] = tmp;\\n                }\\n            }\\n        }\\n        \\n        return v[n-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515037,
                "title": "python-time-o-n-2-union-find-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        table = {grid[i][j]: (i, j) for i in range(len(grid)) for j in range(len(grid))}\\n        parents = {(i, j): (i, j) for i in range(len(grid)) for j in range(len(grid))}\\n        ranks = {(i, j): 0 for i in range(len(grid)) for j in range(len(grid))}\\n        \\n        def find(pos):\\n            if pos != parents[pos]:\\n                parents[pos] = find(parents[pos])\\n            return parents[pos]\\n        \\n        def union(pos1, pos2):\\n            p1, p2 = find(pos1), find(pos2)\\n            if ranks[p1] > ranks[p2]:\\n                parents[p2] = p1\\n            elif ranks[p2] > ranks[p1]:\\n                parents[p1] = p2\\n            else:\\n                parents[p2] = p1\\n                ranks[p1] += 1\\n        \\n        for t in range(len(grid)*len(grid)):\\n            r, c = table[t]\\n            for r_next, c_next in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\\n                if 0 <= r_next < len(grid) and 0 <= c_next < len(grid) and grid[r_next][c_next] <= t:\\n                    union((r, c), (r_next, c_next))\\n            if find((0, 0)) == find((len(grid)-1, len(grid)-1)):\\n                return t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        table = {grid[i][j]: (i, j) for i in range(len(grid)) for j in range(len(grid))}\\n        parents = {(i, j): (i, j) for i in range(len(grid)) for j in range(len(grid))}\\n        ranks = {(i, j): 0 for i in range(len(grid)) for j in range(len(grid))}\\n        \\n        def find(pos):\\n            if pos != parents[pos]:\\n                parents[pos] = find(parents[pos])\\n            return parents[pos]\\n        \\n        def union(pos1, pos2):\\n            p1, p2 = find(pos1), find(pos2)\\n            if ranks[p1] > ranks[p2]:\\n                parents[p2] = p1\\n            elif ranks[p2] > ranks[p1]:\\n                parents[p1] = p2\\n            else:\\n                parents[p2] = p1\\n                ranks[p1] += 1\\n        \\n        for t in range(len(grid)*len(grid)):\\n            r, c = table[t]\\n            for r_next, c_next in [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]:\\n                if 0 <= r_next < len(grid) and 0 <= c_next < len(grid) and grid[r_next][c_next] <= t:\\n                    union((r, c), (r_next, c_next))\\n            if find((0, 0)) == find((len(grid)-1, len(grid)-1)):\\n                return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509880,
                "title": "java-clean-code-bfs-by-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int time=grid[0][0];\\n        PriorityQueue<List<Integer>>pq=new PriorityQueue<>((l1,l2)->{\\n            return l1.get(2)-l2.get(2);\\n        });\\n        List<Integer>start=new ArrayList<>();\\n        Set<Integer>set=new HashSet<>();\\n        set.add(0);\\n        start.add(0);start.add(0);start.add(grid[0][0]);\\n        pq.add(start);\\n        while(pq.size()!=0){\\n            List<Integer>parent=pq.poll();\\n            int row=parent.get(0);\\n            int col=parent.get(1);\\n            int t=parent.get(2);\\n            if(time<t){\\n                time=t;\\n            }\\n            if(row==grid.length-1&&col==grid[0].length-1)break;\\n            add(grid,row+1,col,set,pq);\\n            add(grid,row-1,col,set,pq);\\n            add(grid,row,col+1,set,pq);\\n            add(grid,row,col-1,set,pq);\\n        }\\n        return time;\\n    }\\n    public void add(int grid[][],int row,int col,Set<Integer>set,PriorityQueue<List<Integer>>pq){\\n        if(row<0||col<0||row>=grid.length||col>=grid[0].length){\\n            return;\\n        }\\n        int id=row*grid[0].length+col;\\n        if(set.contains(id)){\\n            return;\\n        }\\n        set.add(id);\\n        List<Integer>next=new ArrayList<>();\\n        next.add(row);next.add(col);next.add(grid[row][col]);\\n        pq.add(next);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int time=grid[0][0];\\n        PriorityQueue<List<Integer>>pq=new PriorityQueue<>((l1,l2)->{\\n            return l1.get(2)-l2.get(2);\\n        });\\n        List<Integer>start=new ArrayList<>();\\n        Set<Integer>set=new HashSet<>();\\n        set.add(0);\\n        start.add(0);start.add(0);start.add(grid[0][0]);\\n        pq.add(start);\\n        while(pq.size()!=0){\\n            List<Integer>parent=pq.poll();\\n            int row=parent.get(0);\\n            int col=parent.get(1);\\n            int t=parent.get(2);\\n            if(time<t){\\n                time=t;\\n            }\\n            if(row==grid.length-1&&col==grid[0].length-1)break;\\n            add(grid,row+1,col,set,pq);\\n            add(grid,row-1,col,set,pq);\\n            add(grid,row,col+1,set,pq);\\n            add(grid,row,col-1,set,pq);\\n        }\\n        return time;\\n    }\\n    public void add(int grid[][],int row,int col,Set<Integer>set,PriorityQueue<List<Integer>>pq){\\n        if(row<0||col<0||row>=grid.length||col>=grid[0].length){\\n            return;\\n        }\\n        int id=row*grid[0].length+col;\\n        if(set.contains(id)){\\n            return;\\n        }\\n        set.add(id);\\n        List<Integer>next=new ArrayList<>();\\n        next.add(row);next.add(col);next.add(grid[row][col]);\\n        pq.add(next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494777,
                "title": "three-different-solutions-with-explanation",
                "content": "### Binary search + DFS\\nThis is quite easy to understand. For given `time`, we just figure out if one can swim from topleft to bottomright using dfs. To accelerate this process, cuz `time` ranges from 0 to N\\\\*N-1, we can apply binary search to narrow it.\\n```cpp\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        int lower = 0;\\n        int upper = N * N - 1;\\n        while (lower < upper) {\\n            int time = lower + (upper - lower) / 2;\\n            vector<vector<bool>> visited(N, vector<bool>(N, false));\\n            if (dfs(visited, 0, 0, time, grid)) {\\n                upper = time;\\n            }\\n            else {\\n                lower = time + 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    bool dfs(vector<vector<bool>>& visited, int i, int j, int time, vector<vector<int>>& grid) {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid.size() || visited[i][j] || grid[i][j] > time) return false;\\n        if (i == grid.size() - 1 && j == grid.size() - 1) return true;\\n        visited[i][j] = true;\\n        return dfs(visited, i + 1, j, time, grid) ||\\n            dfs(visited, i, j + 1, time, grid) ||\\n            dfs(visited, i - 1, j, time, grid) ||\\n            dfs(visited, i, j - 1, time, grid);\\n    }\\n};\\n```\\n\\n### UnionFindSet\\n\\nSimilar to above solution, we can use union-find set algorithm to figure out whether top-left grid and bottom-right are connected. Because the height of each grid is unique, each time when `time` grows, only the very grid whose elevation equals `time` can be connected to its neighbours. We can use `union` to connect two grid, namely putting them in the same set, and use `find` to check.\\n\\n```cpp\\nclass UnionFindSet {\\n\\tvector<int> father;\\n\\tvector<int> rank;\\npublic:\\n\\tUnionFindSet(int size): father(size, 0), rank(size, 0) {\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tfather[i] = i;\\n\\t\\t}\\n\\t}\\n\\tint Find(int x) {\\n\\t\\tif (x != father[x]) {\\n\\t\\t\\tfather[x] = Find(father[x]);\\n\\t\\t}\\n\\t\\treturn father[x];\\n\\t}\\n\\n\\tvoid Union(int x, int y) {\\n\\t\\tint xroot = Find(x);\\n\\t\\tint yroot = Find(y);\\n\\t\\tif (xroot == yroot) return;\\n\\t\\tif (rank[xroot] < rank[yroot]) {\\n\\t\\t\\tfather[xroot] = yroot;\\n\\t\\t}\\n\\t\\telse if (rank[xroot] > rank[yroot]) {\\n\\t\\t\\tfather[yroot] = xroot;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tfather[xroot] = yroot;\\n\\t\\t\\trank[yroot]++;\\n\\t\\t}\\n\\t}\\n};\\n\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tint N = grid.size();\\n\\tint time = 0;\\n\\tUnionFindSet s(N * N);\\n\\tunordered_map<int, int> m;\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tfor (int j = 0; j < N; j++)\\n\\t\\t\\tm[grid[i][j]] = i * N + j;\\n\\t}\\n\\tvector<vector<int>> dr({ {1,0},{0,1},{-1,0},{0,-1} });\\n\\twhile (time < N * N) {\\n\\t\\tint cur = m[time];\\n\\t\\tint i = cur / N;\\n\\t\\tint j = cur % N;\\n\\t\\tfor (auto d : dr) {\\n\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\tint nj = j + d[1];\\n\\t\\t\\tif (ni >= 0 && ni < N && nj >= 0 && nj < N && grid[ni][nj] <= time) {\\n\\t\\t\\t\\ts.Union(cur, ni * N + nj);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (s.Find(0) == s.Find(N * N - 1)) break;\\n\\t\\ttime++;\\n\\t}\\n\\treturn time;\\n}\\n```\\n\\n### Priority Queue\\n\\nDefine the weight of a path as the largest elevation of grids in this path. The key point is to find a least-weight path from top-left to bottom-right. `dist[i]` array is to store the minimum weight of path from 0 to i, and `prev[i]` means its previous point in this path. \\n\\nSimilar to Dijkstra\\'s, we use a priority queue to find a lowest neighbour `t` to extend. \\n\\nBut a slight difference is that we don\\'t need to relax its adjacent grids after extension, because if that neighbour is lower than `dist[t]`, it don\\'t change the path weight, else if it\\'s higher, then its elevation is the new weight of this path, which means its elevation is exact the right weight in the priority queue.\\n\\n```cpp\\nint swimInWater_dij(vector<vector<int>>& grid) {\\n\\tint N = grid.size();\\n\\tauto cmp = [&](int a, int b) -> bool {\\n\\t\\treturn grid[a / N][a % N] > grid[b / N][b % N];\\n\\t};\\n\\tpriority_queue<int, vector<int>, decltype(cmp)> q(cmp);\\n\\tq.push(0);\\n\\tvector<int> dist(N * N, -1);\\n\\tvector<int> prev(N * N, 0);\\n\\tvector<vector<int>> dr({ {1,0},{0,1},{-1,0},{0,-1} });\\n\\twhile (!q.empty()) {\\n\\t\\tint cur = q.top();\\n\\t\\tq.pop();\\n\\t\\tint i = cur / N;\\n\\t\\tint j = cur % N;\\n\\t\\tdist[cur] = grid[i][j] > dist[prev[cur]] ? grid[i][j] : dist[prev[cur]];\\n\\t\\tif (cur == N * N - 1) break;\\n\\t\\tfor (auto d : dr) {\\n\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\tint nj = j + d[1];\\n\\t\\t\\tint next = ni * N + nj;\\n\\t\\t\\tif (ni >= 0 && ni < N && nj >= 0 && nj < N && dist[next] == -1) {\\n\\t\\t\\t\\tq.push(next);\\n\\t\\t\\t\\tprev[next] = cur;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dist[N * N - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        int lower = 0;\\n        int upper = N * N - 1;\\n        while (lower < upper) {\\n            int time = lower + (upper - lower) / 2;\\n            vector<vector<bool>> visited(N, vector<bool>(N, false));\\n            if (dfs(visited, 0, 0, time, grid)) {\\n                upper = time;\\n            }\\n            else {\\n                lower = time + 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    bool dfs(vector<vector<bool>>& visited, int i, int j, int time, vector<vector<int>>& grid) {\\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid.size() || visited[i][j] || grid[i][j] > time) return false;\\n        if (i == grid.size() - 1 && j == grid.size() - 1) return true;\\n        visited[i][j] = true;\\n        return dfs(visited, i + 1, j, time, grid) ||\\n            dfs(visited, i, j + 1, time, grid) ||\\n            dfs(visited, i - 1, j, time, grid) ||\\n            dfs(visited, i, j - 1, time, grid);\\n    }\\n};\\n```\n```cpp\\nclass UnionFindSet {\\n\\tvector<int> father;\\n\\tvector<int> rank;\\npublic:\\n\\tUnionFindSet(int size): father(size, 0), rank(size, 0) {\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tfather[i] = i;\\n\\t\\t}\\n\\t}\\n\\tint Find(int x) {\\n\\t\\tif (x != father[x]) {\\n\\t\\t\\tfather[x] = Find(father[x]);\\n\\t\\t}\\n\\t\\treturn father[x];\\n\\t}\\n\\n\\tvoid Union(int x, int y) {\\n\\t\\tint xroot = Find(x);\\n\\t\\tint yroot = Find(y);\\n\\t\\tif (xroot == yroot) return;\\n\\t\\tif (rank[xroot] < rank[yroot]) {\\n\\t\\t\\tfather[xroot] = yroot;\\n\\t\\t}\\n\\t\\telse if (rank[xroot] > rank[yroot]) {\\n\\t\\t\\tfather[yroot] = xroot;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tfather[xroot] = yroot;\\n\\t\\t\\trank[yroot]++;\\n\\t\\t}\\n\\t}\\n};\\n\\nint swimInWater(vector<vector<int>>& grid) {\\n\\tint N = grid.size();\\n\\tint time = 0;\\n\\tUnionFindSet s(N * N);\\n\\tunordered_map<int, int> m;\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tfor (int j = 0; j < N; j++)\\n\\t\\t\\tm[grid[i][j]] = i * N + j;\\n\\t}\\n\\tvector<vector<int>> dr({ {1,0},{0,1},{-1,0},{0,-1} });\\n\\twhile (time < N * N) {\\n\\t\\tint cur = m[time];\\n\\t\\tint i = cur / N;\\n\\t\\tint j = cur % N;\\n\\t\\tfor (auto d : dr) {\\n\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\tint nj = j + d[1];\\n\\t\\t\\tif (ni >= 0 && ni < N && nj >= 0 && nj < N && grid[ni][nj] <= time) {\\n\\t\\t\\t\\ts.Union(cur, ni * N + nj);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (s.Find(0) == s.Find(N * N - 1)) break;\\n\\t\\ttime++;\\n\\t}\\n\\treturn time;\\n}\\n```\n```cpp\\nint swimInWater_dij(vector<vector<int>>& grid) {\\n\\tint N = grid.size();\\n\\tauto cmp = [&](int a, int b) -> bool {\\n\\t\\treturn grid[a / N][a % N] > grid[b / N][b % N];\\n\\t};\\n\\tpriority_queue<int, vector<int>, decltype(cmp)> q(cmp);\\n\\tq.push(0);\\n\\tvector<int> dist(N * N, -1);\\n\\tvector<int> prev(N * N, 0);\\n\\tvector<vector<int>> dr({ {1,0},{0,1},{-1,0},{0,-1} });\\n\\twhile (!q.empty()) {\\n\\t\\tint cur = q.top();\\n\\t\\tq.pop();\\n\\t\\tint i = cur / N;\\n\\t\\tint j = cur % N;\\n\\t\\tdist[cur] = grid[i][j] > dist[prev[cur]] ? grid[i][j] : dist[prev[cur]];\\n\\t\\tif (cur == N * N - 1) break;\\n\\t\\tfor (auto d : dr) {\\n\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\tint nj = j + d[1];\\n\\t\\t\\tint next = ni * N + nj;\\n\\t\\t\\tif (ni >= 0 && ni < N && nj >= 0 && nj < N && dist[next] == -1) {\\n\\t\\t\\t\\tq.push(next);\\n\\t\\t\\t\\tprev[next] = cur;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dist[N * N - 1];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492148,
                "title": "java-binary-search-solution-with-1-ms-and-beats-100",
                "content": "```java\\nclass Solution {\\n  public int swimInWater(int[][] grid) {\\n    int m = grid.length;\\n    int n = grid[0].length;\\n    int lo = 0, hi = m*n - 1;\\n    while (lo < hi) {\\n      int mid = (hi + lo) >> 1;\\n      if (hasPathToTheEnd(grid, mid)) {\\n        hi = mid;\\n      } else {\\n        lo = mid + 1;\\n      }\\n    }\\n    return hi;\\n  }\\n  private boolean hasPathToTheEnd(int[][] grid, int mid) {\\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\\n    return find(grid, visited, 0, 0, mid);\\n  }\\n  private boolean find(int[][] grid, boolean[][] visited, int i, int j, int mid) {\\n    if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j])\\n      return false;\\n\\n    visited[i][j] = true;\\n\\n    if (grid[i][j] > mid) return false;\\n    if (i == grid.length - 1 && j == grid[0].length - 1) return true;\\n\\n    return find(grid, visited, i+1, j, mid)\\n        || find(grid, visited, i-1, j, mid)\\n        || find(grid, visited, i, j+1, mid)\\n        || find(grid, visited, i, j-1, mid);\\n  }\\n}\\n`````",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n  public int swimInWater(int[][] grid) {\\n    int m = grid.length;\\n    int n = grid[0].length;\\n    int lo = 0, hi = m*n - 1;\\n    while (lo < hi) {\\n      int mid = (hi + lo) >> 1;\\n      if (hasPathToTheEnd(grid, mid)) {\\n        hi = mid;\\n      } else {\\n        lo = mid + 1;\\n      }\\n    }\\n    return hi;\\n  }\\n  private boolean hasPathToTheEnd(int[][] grid, int mid) {\\n    boolean[][] visited = new boolean[grid.length][grid[0].length];\\n    return find(grid, visited, 0, 0, mid);\\n  }\\n  private boolean find(int[][] grid, boolean[][] visited, int i, int j, int mid) {\\n    if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j])\\n      return false;\\n\\n    visited[i][j] = true;\\n\\n    if (grid[i][j] > mid) return false;\\n    if (i == grid.length - 1 && j == grid[0].length - 1) return true;\\n\\n    return find(grid, visited, i+1, j, mid)\\n        || find(grid, visited, i-1, j, mid)\\n        || find(grid, visited, i, j+1, mid)\\n        || find(grid, visited, i, j-1, mid);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365109,
                "title": "c-faster-than-100-solution",
                "content": "```\\npublic class Solution {\\n    public int SwimInWater(int[][] grid) {\\n         if (grid == null) return 0;\\n            int len = grid.Length;\\n\\n            int[][] dp = new int[len][];\\n\\n            for (int i = 0; i < len; i++)\\n                dp[i] = new int[len];\\n\\n            for (int i = len - 1; i >= 0; i--)\\n            {\\n                if (i + 1 == len)\\n                    dp[len - 1][i] = grid[len - 1][i];\\n                else\\n                    dp[len - 1][i] = Math.Max(grid[len - 1][i], dp[len - 1][i + 1]);\\n            }\\n\\n            for (int i = len - 2; i >= 0; i--)\\n            {\\n               for (int j = 0; j < len; j++)\\n                    dp[i][j] = Math.Max(grid[i][j], dp[i + 1][j]);\\n                for (int j = 0; j < len; j++)\\n                    ChangeOther(i, j, grid, dp);\\n            }\\n\\n            return dp[0][0];\\n        }\\n\\n        private void ChangeOther(int i, int j, int[][] grid, int[][] dp)\\n        {\\n            if (i > 0 && dp[i - 1][j] > dp[i][j])\\n            {\\n                dp[i - 1][j] = Math.Max(dp[i][j], grid[i - 1][j]);\\n                ChangeOther(i - 1, j, grid, dp);\\n            }\\n\\n            if (i < grid.Length - 1 && dp[i + 1][j] > dp[i][j])\\n            {\\n                dp[i + 1][j] = Math.Max(dp[i][j], grid[i + 1][j]);\\n                ChangeOther(i + 1, j, grid, dp);\\n            }\\n\\n            if (j > 0 && dp[i][j - 1] > dp[i][j])\\n            {\\n                dp[i][j - 1] = Math.Max(dp[i][j], grid[i][j - 1]);\\n                ChangeOther(i, j - 1, grid, dp);\\n            }\\n\\n            if (j < grid.Length - 1 && dp[i][j + 1] > dp[i][j])\\n            {\\n                dp[i][j + 1] = Math.Max(dp[i][j], grid[i][j + 1]);\\n                ChangeOther(i, j + 1, grid, dp);\\n            }\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SwimInWater(int[][] grid) {\\n         if (grid == null) return 0;\\n            int len = grid.Length;\\n\\n            int[][] dp = new int[len][];\\n\\n            for (int i = 0; i < len; i++)\\n                dp[i] = new int[len];\\n\\n            for (int i = len - 1; i >= 0; i--)\\n            {\\n                if (i + 1 == len)\\n                    dp[len - 1][i] = grid[len - 1][i];\\n                else\\n                    dp[len - 1][i] = Math.Max(grid[len - 1][i], dp[len - 1][i + 1]);\\n            }\\n\\n            for (int i = len - 2; i >= 0; i--)\\n            {\\n               for (int j = 0; j < len; j++)\\n                    dp[i][j] = Math.Max(grid[i][j], dp[i + 1][j]);\\n                for (int j = 0; j < len; j++)\\n                    ChangeOther(i, j, grid, dp);\\n            }\\n\\n            return dp[0][0];\\n        }\\n\\n        private void ChangeOther(int i, int j, int[][] grid, int[][] dp)\\n        {\\n            if (i > 0 && dp[i - 1][j] > dp[i][j])\\n            {\\n                dp[i - 1][j] = Math.Max(dp[i][j], grid[i - 1][j]);\\n                ChangeOther(i - 1, j, grid, dp);\\n            }\\n\\n            if (i < grid.Length - 1 && dp[i + 1][j] > dp[i][j])\\n            {\\n                dp[i + 1][j] = Math.Max(dp[i][j], grid[i + 1][j]);\\n                ChangeOther(i + 1, j, grid, dp);\\n            }\\n\\n            if (j > 0 && dp[i][j - 1] > dp[i][j])\\n            {\\n                dp[i][j - 1] = Math.Max(dp[i][j], grid[i][j - 1]);\\n                ChangeOther(i, j - 1, grid, dp);\\n            }\\n\\n            if (j < grid.Length - 1 && dp[i][j + 1] > dp[i][j])\\n            {\\n                dp[i][j + 1] = Math.Max(dp[i][j], grid[i][j + 1]);\\n                ChangeOther(i, j + 1, grid, dp);\\n            }\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 335022,
                "title": "ruby-binary-search-solution",
                "content": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef swim_in_water(grid)\\n    min = [grid.first.first,grid.last.last].max\\n    max = grid.map{|row| row.max}.max\\n    p [min,max]\\n    return min if bfs_check(min,grid)\\n    # return min if check(min,[0,0],grid,[])\\n    \\n    while min<max\\n        m = (min+max)/2\\n        case [bfs_check(m,grid),bfs_check(m+1,grid)]\\n            when [false,true] then return m+1\\n            when [false,false] then min = m+1\\n            when [true,true] then max = m\\n            end            \\n    end\\n    return min\\nend\\n            \\ndef bfs_check(t,grid)\\n    n = grid.size \\n    bfs = [[0,0]]\\n    \\n    seen = Set[[0,0]]\\n    \\n    while !bfs.empty?\\n        x,y = bfs.shift\\n        if grid[x][y] <= t\\n            return true if x==n-1 && y==n-1\\n            \\n\\n            if x+1<=n-1 && grid[x+1][y] <=t && !seen.include?([x+1,y])\\n                seen << [x+1,y]\\n                bfs << [x+1,y]\\n            end\\n            \\n            if y+1<=n-1 && grid[x][y+1] <=t && !seen.include?([x,y+1]) \\n                seen << [x,y+1]\\n                bfs << [x,y+1]\\n            end\\n            \\n            if x-1>=0 && grid[x-1][y] <=t && !seen.include?([x-1,y]) \\n                seen << [x-1,y]\\n                bfs << [x-1,y]\\n            end\\n            \\n            if y-1>=0 && grid[x][y-1] <=t && !seen.include?([x,y-1])\\n                seen << [x,y-1]\\n                bfs << [x,y-1]                      \\n            end\\n            \\n        end\\n    end\\n                    \\n    return false \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef swim_in_water(grid)\\n    min = [grid.first.first,grid.last.last].max\\n    max = grid.map{|row| row.max}.max\\n    p [min,max]\\n    return min if bfs_check(min,grid)\\n    # return min if check(min,[0,0],grid,[])\\n    \\n    while min<max\\n        m = (min+max)/2\\n        case [bfs_check(m,grid),bfs_check(m+1,grid)]\\n            when [false,true] then return m+1\\n            when [false,false] then min = m+1\\n            when [true,true] then max = m\\n            end            \\n    end\\n    return min\\nend\\n            \\ndef bfs_check(t,grid)\\n    n = grid.size \\n    bfs = [[0,0]]\\n    \\n    seen = Set[[0,0]]\\n    \\n    while !bfs.empty?\\n        x,y = bfs.shift\\n        if grid[x][y] <= t\\n            return true if x==n-1 && y==n-1\\n            \\n\\n            if x+1<=n-1 && grid[x+1][y] <=t && !seen.include?([x+1,y])\\n                seen << [x+1,y]\\n                bfs << [x+1,y]\\n            end\\n            \\n            if y+1<=n-1 && grid[x][y+1] <=t && !seen.include?([x,y+1]) \\n                seen << [x,y+1]\\n                bfs << [x,y+1]\\n            end\\n            \\n            if x-1>=0 && grid[x-1][y] <=t && !seen.include?([x-1,y]) \\n                seen << [x-1,y]\\n                bfs << [x-1,y]\\n            end\\n            \\n            if y-1>=0 && grid[x][y-1] <=t && !seen.include?([x,y-1])\\n                seen << [x,y-1]\\n                bfs << [x,y-1]                      \\n            end\\n            \\n        end\\n    end\\n                    \\n    return false \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 263371,
                "title": "python-min-heap",
                "content": "As you can swim infinite distance in zero time, the problem actually doesn\\'t count time, but the minimum of the largest value in any path from (0,0) to (n-1,n-1).\\n```ans = min(max(point for point in path))```\\n\\nThus, we can use something like Dijkstra to expand our path by choosing the minimal reachable node. And we can use a minimal heap to acquire that minimal reachable node.\\n\\nStarting from (0,0), each time we pop the smallest node from the heap and then push neighboring and unvisited nodes into the heap. Once our popped node is at (n-1,n-1), we finished our path. Each time we update our ans as ```t = max(t, node\\'s depth)```.\\n\\n```\\ndef swimInWater(grid):\\n\\tpq, t, n, seen = [(grid[0][0], 0, 0)], 0, len(grid), set()\\n\\twhile pq:\\n\\t\\td, i, j = heapq.heappop(pq)\\n\\t\\tt = max(t, d)\\n\\t\\tif i == j == n-1: return t\\n\\t\\tseen.add((i, j))\\n\\t\\tfor x, y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\\n\\t\\t\\tif 0 <= x < n and 0 <= y < n and (x,y) not in seen:\\n\\t\\t\\t\\theapq.heappush(pq, (grid[x][y], x, y))\\n```\\nTime complexity is O(n^2logn). In worst case, we have to walk all the points in the grid.",
                "solutionTags": [],
                "code": "```ans = min(max(point for point in path))```\n```t = max(t, node\\'s depth)```\n```\\ndef swimInWater(grid):\\n\\tpq, t, n, seen = [(grid[0][0], 0, 0)], 0, len(grid), set()\\n\\twhile pq:\\n\\t\\td, i, j = heapq.heappop(pq)\\n\\t\\tt = max(t, d)\\n\\t\\tif i == j == n-1: return t\\n\\t\\tseen.add((i, j))\\n\\t\\tfor x, y in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)):\\n\\t\\t\\tif 0 <= x < n and 0 <= y < n and (x,y) not in seen:\\n\\t\\t\\t\\theapq.heappush(pq, (grid[x][y], x, y))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 246169,
                "title": "java-beats-100-binary-search-with-commenting-explanation-step-by-step",
                "content": "Direct DFS might cause TLE(at least unfortunately in my situation), so the idea is to combine DFS with Binary Search.\\n\\n```\\nclass Solution {\\n    \\n    private int[][] moves = {\\n        {-1,0}, // move left\\n        {0,1}, // move down\\n        {1,0}, // move right\\n        {0, -1}}; // move up\\n\\n    public int swimInWater(int[][] spots) {\\n        int len = spots.length;\\n        int lo = spots[0][0];\\n        int hi = len * len - 1;\\n        while(lo <= hi) {\\n            int guessTime = lo + ((hi - lo) >> 1);\\n            boolean[][] visited = new boolean[len][len];\\n            boolean canReachEnd = hasPath(guessTime, 0, 0, spots, visited);\\n            if(canReachEnd) { \\n                // if we can reach to the end under guesstime, \\n                // then we check if there is a faster path\\n                hi = guessTime - 1;\\n            }\\n            else { \\n                // if there is no path to the end under guesstime, \\n\\t\\t\\t\\t// we increment the guesstime till we actually find one\\n                lo = guessTime + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n\\n    public boolean hasPath(int curTime, int x, int y, int[][] spots, boolean[][] visited) {\\n        visited[x][y] = true;\\n        int len = visited.length;\\n        if(x == len - 1 && y == len - 1) {\\n            // already arrived the destination, which means we have a possible path within the guesstime\\n            return true;\\n        }\\n        // now check if it can move left, right, up, or down.\\n        for(int i = 0; i < 4; i++) {\\n            int nextX = x + moves[i][0], nextY = y + moves[i][1];\\n            if(nextX < 0 || nextX >= len || nextY < 0 || nextY >= len\\n               || visited[nextX][nextY] || spots[nextX][nextY] > curTime) {\\n                // if the current next possible move won\\'t work, check another next possible move\\n                continue;\\n            }\\n            // if current move works, then check the next possible path\\n            if(hasPath(curTime, nextX, nextY, spots, visited)) {\\n                return true;   \\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int[][] moves = {\\n        {-1,0}, // move left\\n        {0,1}, // move down\\n        {1,0}, // move right\\n        {0, -1}}; // move up\\n\\n    public int swimInWater(int[][] spots) {\\n        int len = spots.length;\\n        int lo = spots[0][0];\\n        int hi = len * len - 1;\\n        while(lo <= hi) {\\n            int guessTime = lo + ((hi - lo) >> 1);\\n            boolean[][] visited = new boolean[len][len];\\n            boolean canReachEnd = hasPath(guessTime, 0, 0, spots, visited);\\n            if(canReachEnd) { \\n                // if we can reach to the end under guesstime, \\n                // then we check if there is a faster path\\n                hi = guessTime - 1;\\n            }\\n            else { \\n                // if there is no path to the end under guesstime, \\n\\t\\t\\t\\t// we increment the guesstime till we actually find one\\n                lo = guessTime + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n\\n    public boolean hasPath(int curTime, int x, int y, int[][] spots, boolean[][] visited) {\\n        visited[x][y] = true;\\n        int len = visited.length;\\n        if(x == len - 1 && y == len - 1) {\\n            // already arrived the destination, which means we have a possible path within the guesstime\\n            return true;\\n        }\\n        // now check if it can move left, right, up, or down.\\n        for(int i = 0; i < 4; i++) {\\n            int nextX = x + moves[i][0], nextY = y + moves[i][1];\\n            if(nextX < 0 || nextX >= len || nextY < 0 || nextY >= len\\n               || visited[nextX][nextY] || spots[nextX][nextY] > curTime) {\\n                // if the current next possible move won\\'t work, check another next possible move\\n                continue;\\n            }\\n            // if current move works, then check the next possible path\\n            if(hasPath(curTime, nextX, nextY, spots, visited)) {\\n                return true;   \\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224667,
                "title": "dfs-thinking-process-in-java",
                "content": "> Intuitively, we are to find a path from (0, 0) to (n -1, n - 1) with the minimum maximum cell.\\n> That causes TLE.\\n\\n> To optimize,\\n> we observe that the minimum value of `maxInPath` for each path is `grid[0][0]`\\n> we try fanning out with this minimum `maxInPath` \\n> if we cannot reach (n-1, n-1), we increase `maxInPath` by one and try fanning out...\\n> we don\\'t stop until we can reach (n-1, n-1) with current `maxInPath` \\n\\n\\n****\\n```\\n    private int[][] grid;\\n    private int n;\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    \\n    public int swimInWater(int[][] grid) {\\n        this.grid = grid;\\n        n = grid.length;\\n        \\n        int maxInPath = grid[0][0];\\n        boolean[][] visited = new boolean[n][n];\\n        \\n        while (!visited[n - 1][n - 1]) {\\n            visited = new boolean[n][n];\\n            dfs(0, 0, visited, maxInPath);\\n            maxInPath++;\\n        }\\n        \\n        return maxInPath - 1;\\n    }\\n    \\n    private void dfs(int x, int y, boolean[][] visited, int maxInPath) {\\n        for (int[] direction: directions) {\\n            int nx = x + direction[0];\\n            int ny = y + direction[1];\\n            if (nx >= n || nx < 0 || ny >= n || ny < 0 || visited[nx][ny] || grid[nx][ny] > maxInPath) continue;\\n            visited[nx][ny] = true;\\n            dfs(nx, ny, visited, maxInPath);\\n        } \\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    private int[][] grid;\\n    private int n;\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    \\n    public int swimInWater(int[][] grid) {\\n        this.grid = grid;\\n        n = grid.length;\\n        \\n        int maxInPath = grid[0][0];\\n        boolean[][] visited = new boolean[n][n];\\n        \\n        while (!visited[n - 1][n - 1]) {\\n            visited = new boolean[n][n];\\n            dfs(0, 0, visited, maxInPath);\\n            maxInPath++;\\n        }\\n        \\n        return maxInPath - 1;\\n    }\\n    \\n    private void dfs(int x, int y, boolean[][] visited, int maxInPath) {\\n        for (int[] direction: directions) {\\n            int nx = x + direction[0];\\n            int ny = y + direction[1];\\n            if (nx >= n || nx < 0 || ny >= n || ny < 0 || visited[nx][ny] || grid[nx][ny] > maxInPath) continue;\\n            visited[nx][ny] = true;\\n            dfs(nx, ny, visited, maxInPath);\\n        } \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150490,
                "title": "python-with-heapq",
                "content": "\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        maxH = 0\\n        q = []\\n        heapq.heappush(q, (grid[0][0], (0, 0)))\\n        while True:\\n            h, (x, y) = heapq.heappop(q)\\n            maxH = max(maxH, h)\\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\\n                return maxH\\n            grid[x][y] *= -1\\n            if x > 0 and grid[x - 1][y] >= 0:\\n                heapq.heappush(q, (grid[x - 1][y], (x - 1, y)))\\n            if x < len(grid) - 1 and grid[x + 1][y] >= 0:\\n                heapq.heappush(q, (grid[x + 1][y], (x + 1, y)))\\n            if y > 0 and grid[x][y - 1] >= 0:\\n                heapq.heappush(q, (grid[x][y - 1], (x, y - 1)))\\n            if y < len(grid[0]) - 1 and grid[x][y + 1] >= 0:\\n                heapq.heappush(q, (grid[x][y + 1], (x, y + 1)))",
                "solutionTags": [],
                "code": "\\n    def swimInWater(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        maxH = 0\\n        q = []\\n        heapq.heappush(q, (grid[0][0], (0, 0)))\\n        while True:\\n            h, (x, y) = heapq.heappop(q)\\n            maxH = max(maxH, h)\\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\\n                return maxH\\n            grid[x][y] *= -1\\n            if x > 0 and grid[x - 1][y] >= 0:\\n                heapq.heappush(q, (grid[x - 1][y], (x - 1, y)))\\n            if x < len(grid) - 1 and grid[x + 1][y] >= 0:\\n                heapq.heappush(q, (grid[x + 1][y], (x + 1, y)))\\n            if y > 0 and grid[x][y - 1] >= 0:\\n                heapq.heappush(q, (grid[x][y - 1], (x, y - 1)))\\n            if y < len(grid[0]) - 1 and grid[x][y + 1] >= 0:\\n                heapq.heappush(q, (grid[x][y + 1], (x, y + 1)))",
                "codeTag": "Python3"
            },
            {
                "id": 148511,
                "title": "easy-java-priorityqueue",
                "content": "```\\n    public int swimInWater(int[][] grid) {\\n        int N = grid.length, res = Integer.MIN_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) ->(a[0] - b[0]));\\n        pq.offer(new int[]{grid[0][0], 0, 0});\\n        boolean[][] visited = new boolean[N][N];\\n        visited[0][0] = true;\\n        int[][] neibor = {{-1,0},{1,0},{0,-1},{0,1}};\\n        while (true) {\\n            int[] temp = pq.poll();\\n            res = Math.max(res,temp[0]);\\n            if (temp[1] == N-1 && temp[2] == N-1) return res;\\n            for (int i = 0; i < 4; i++){\\n                int row = neibor[i][0] + temp[1];\\n                int col = neibor[i][1] + temp[2];\\n                if (row < N && col < N && row >=0 && col >=0 && !visited[row][col]) {\\n                    visited[row][col] = true;\\n                    pq.offer(new int[]{grid[row][col], row, col});\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int swimInWater(int[][] grid) {\\n        int N = grid.length, res = Integer.MIN_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) ->(a[0] - b[0]));\\n        pq.offer(new int[]{grid[0][0], 0, 0});\\n        boolean[][] visited = new boolean[N][N];\\n        visited[0][0] = true;\\n        int[][] neibor = {{-1,0},{1,0},{0,-1},{0,1}};\\n        while (true) {\\n            int[] temp = pq.poll();\\n            res = Math.max(res,temp[0]);\\n            if (temp[1] == N-1 && temp[2] == N-1) return res;\\n            for (int i = 0; i < 4; i++){\\n                int row = neibor[i][0] + temp[1];\\n                int col = neibor[i][1] + temp[2];\\n                if (row < N && col < N && row >=0 && col >=0 && !visited[row][col]) {\\n                    visited[row][col] = true;\\n                    pq.offer(new int[]{grid[row][col], row, col});\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113761,
                "title": "dp-python-443ms",
                "content": "I am new to the algrithom. My first try to post for the hard. \\nBasically, my thought is finding the minimum steps to reach the right bottom first. It would be at least max(2N-2, grid[-1][-1]). Then use dfs to check if it is possible to reach the end. \\nFeel free to leave any comments. I am sure there is a better solution. \\n```\\nclass Solution(object):\\n    def swimInWater(self, grid):\\n        m = len(grid)\\n        l, r = 2*m-2, m*m \\n        \\n        def search(i,j):\\n            if ele[i][j]:\\n                return False\\n            ele[i][j] = 1\\n            if grid[i][j] <= ans:\\n                if i == j == m-1:\\n                    return True\\n                return any([search(a,b) for a, b in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] \\n                                                     if 0 <= a < m and 0 <= b < m])\\n                               \\n        for ans in range(max(l,grid[-1][-1]), r):\\n            ele = [[0] * m for _ in range(m)]\\n            if search(0, 0):\\n                return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def swimInWater(self, grid):\\n        m = len(grid)\\n        l, r = 2*m-2, m*m \\n        \\n        def search(i,j):\\n            if ele[i][j]:\\n                return False\\n            ele[i][j] = 1\\n            if grid[i][j] <= ans:\\n                if i == j == m-1:\\n                    return True\\n                return any([search(a,b) for a, b in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] \\n                                                     if 0 <= a < m and 0 <= b < m])\\n                               \\n        for ans in range(max(l,grid[-1][-1]), r):\\n            ele = [[0] * m for _ in range(m)]\\n            if search(0, 0):\\n                return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113742,
                "title": "c-solution-using-priority-queue",
                "content": "```\\n    struct pos {\\n\\tpos (int a, int b, int c) : val (a), x (b), y (c) {}\\n\\tbool operator< (const pos &d) const { return val > d.val; }\\n\\tint val, x, y;\\n    };\\n    \\n    vi xo = {1, -1, 0, 0};\\n    vi yo = {0, 0, 1, -1};\\n    \\n    bool isValid (int x, int y, int n) {\\n        return (x >= 0 && x < n && y >= 0 && y < n);\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size ();\\n        \\n        priority_queue<pos> pq;\\n        \\n        pq.push (pos(grid[0][0], 0, 0));\\n        \\n        vvi done (n, vi (n, -1));\\n        done[0][0] = 1;\\n                  \\n        while (done[n-1][n-1] == -1) {\\n            \\n            auto p = pq.top ();\\n            pq.pop ();\\n            \\n            FORI (0, 4) {\\n                int a = p.x + xo[i];\\n                int b = p.y + yo[i];\\n                if (isValid (a, b, n) && done[a][b] == -1) {\\n                    \\n                    int c = max (grid[a][b], p.val);\\n                    \\n                    pq.push (pos (c, a, b));\\n                    done[a][b] = c;\\n                }\\n            }\\n        }\\n        \\n        return done[n-1][n-1];\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    struct pos {\\n\\tpos (int a, int b, int c) : val (a), x (b), y (c) {}\\n\\tbool operator< (const pos &d) const { return val > d.val; }\\n\\tint val, x, y;\\n    };\\n    \\n    vi xo = {1, -1, 0, 0};\\n    vi yo = {0, 0, 1, -1};\\n    \\n    bool isValid (int x, int y, int n) {\\n        return (x >= 0 && x < n && y >= 0 && y < n);\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size ();\\n        \\n        priority_queue<pos> pq;\\n        \\n        pq.push (pos(grid[0][0], 0, 0));\\n        \\n        vvi done (n, vi (n, -1));\\n        done[0][0] = 1;\\n                  \\n        while (done[n-1][n-1] == -1) {\\n            \\n            auto p = pq.top ();\\n            pq.pop ();\\n            \\n            FORI (0, 4) {\\n                int a = p.x + xo[i];\\n                int b = p.y + yo[i];\\n                if (isValid (a, b, n) && done[a][b] == -1) {\\n                    \\n                    int c = max (grid[a][b], p.val);\\n                    \\n                    pq.push (pos (c, a, b));\\n                    done[a][b] = c;\\n                }\\n            }\\n        }\\n        \\n        return done[n-1][n-1];\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3970935,
                "title": "c-easy-dijikstra-algo-runtime-10ms-tc-o-n-2logn-2-sc-o-n-2",
                "content": "# Intuition\\nDijkstra Algo will be used here just the little variation\\n\\n# Approach\\nThe algorithm iteratively explores neighboring cells and updates their cost if a lower elevation path is found. \\nThis guarantees that the chosen path always has the lowest maximum elevation.\\n->We are always updating the minimum value in v[i][j]>max(grid[x][y],grid[i][j]);\\nJust dry Run;;\\n\\n# Complexity\\n- Time complexity:\\nO(n^2logn^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dict={{0,1},{1,0},{-1,0},{0,-1}};\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>>vis(n,vector<int>(n,0));\\n        vector<vector<int>>v(n,vector<int>(n,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n       pq.push({grid[0][0],{0,0}});\\n       vis[0][0]=1;\\n       v[0][0]=grid[0][0];\\n       while(!pq.empty())\\n       {\\n          pair<int,pair<int,int>> p=pq.top();\\n          pq.pop();\\n\\n          int c=p.first;\\n          int x=p.second.first;\\n          int y=p.second.second;\\n\\n          for(int k=0;k<4;k++){\\n              int i=x+dict[k][0],j=y+dict[k][1];\\n              if(i>=0 && j>=0 && i<n && j<n && vis[i][j]==0){\\n                  if(v[i][j]>max(grid[i][j],c)){\\n                  v[i][j]=max(grid[i][j],c);\\n                  pq.push({max(grid[i][j],c),{i,j}});\\n                  vis[i][j]=1;\\n                  }\\n              }\\n          } \\n       }\\n       return v[n-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dict={{0,1},{1,0},{-1,0},{0,-1}};\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>>vis(n,vector<int>(n,0));\\n        vector<vector<int>>v(n,vector<int>(n,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n       pq.push({grid[0][0],{0,0}});\\n       vis[0][0]=1;\\n       v[0][0]=grid[0][0];\\n       while(!pq.empty())\\n       {\\n          pair<int,pair<int,int>> p=pq.top();\\n          pq.pop();\\n\\n          int c=p.first;\\n          int x=p.second.first;\\n          int y=p.second.second;\\n\\n          for(int k=0;k<4;k++){\\n              int i=x+dict[k][0],j=y+dict[k][1];\\n              if(i>=0 && j>=0 && i<n && j<n && vis[i][j]==0){\\n                  if(v[i][j]>max(grid[i][j],c)){\\n                  v[i][j]=max(grid[i][j],c);\\n                  pq.push({max(grid[i][j],c),{i,j}});\\n                  vis[i][j]=1;\\n                  }\\n              }\\n          } \\n       }\\n       return v[n-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854250,
                "title": "swim-in-rising-water-c-binary-search",
                "content": "# Approach\\nWe treat the time as the search space. At most the time will be the maximum element of the grid. Minimal time if we consider a single element with value 0, in which the time to reach the end is 0. \\nNow since the time is increasing in a linear fashion, we apply binary search to optimize searching from $$O(n)$$ to $$O(log(n))$$. \\nWe use a helper function to determine whether it is possible to reach the end with the given time, i.e., the value we derived from binary search (mid).\\nUsing binary search reduces the overall time complexity from $$O(n ^ 2 * maxval)$$ to $$O(n ^ 2 * log(maxval))$$.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 2 * log(maxval))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n ^ 2) + O(8)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n\\n    bool canReach(int row, int col, vector<vector<int>>& grid, int dr[], int dc[], int depth, vector<vector<bool>>& visited) {\\n        if (row == n - 1 && col == n - 1)\\n            return true;\\n\\n        visited[row][col] = 1;\\n        \\n        for (int i = 0; i < 4; i++) {\\n            int nr = row + dr[i];\\n            int nc = col + dc[i];\\n            if (nr >= 0 && nr < n && nc >= 0 && nc < n && !visited[nr][nc] && grid[nr][nc] <= depth) {\\n                if (canReach(nr, nc, grid, dr, dc, depth, visited)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int low = 0, high = 0;\\n        n = grid.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                high = max(high, grid[i][j]);\\n            }\\n        }\\n\\n        int dr[4] = {-1, 1, 0, 0};\\n        int dc[4] = {0, 0, -1, 1};\\n\\n        int res = 0;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            vector<vector<bool>> visited(n, vector<bool>(n, 0));\\n            if (grid[0][0] <= mid && canReach(0, 0, grid, dr, dc, mid, visited)) {\\n                res = mid;\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n\\n    bool canReach(int row, int col, vector<vector<int>>& grid, int dr[], int dc[], int depth, vector<vector<bool>>& visited) {\\n        if (row == n - 1 && col == n - 1)\\n            return true;\\n\\n        visited[row][col] = 1;\\n        \\n        for (int i = 0; i < 4; i++) {\\n            int nr = row + dr[i];\\n            int nc = col + dc[i];\\n            if (nr >= 0 && nr < n && nc >= 0 && nc < n && !visited[nr][nc] && grid[nr][nc] <= depth) {\\n                if (canReach(nr, nc, grid, dr, dc, depth, visited)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int low = 0, high = 0;\\n        n = grid.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                high = max(high, grid[i][j]);\\n            }\\n        }\\n\\n        int dr[4] = {-1, 1, 0, 0};\\n        int dc[4] = {0, 0, -1, 1};\\n\\n        int res = 0;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            vector<vector<bool>> visited(n, vector<bool>(n, 0));\\n            if (grid[0][0] <= mid && canReach(0, 0, grid, dr, dc, mid, visited)) {\\n                res = mid;\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750784,
                "title": "c-bfs-minheap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> minheap;\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        vector<int> dx={0,-1,0,1};\\n        vector<int> dy={-1,0,1,0};\\n        minheap.push({grid[0][0],{0,0}});\\n        vis[0][0]=1;\\n        while(!minheap.empty()){\\n            int t=minheap.top().first;\\n            int x=minheap.top().second.first;\\n            int y=minheap.top().second.second;\\n            minheap.pop();\\n            if(x==n-1 && y==n-1) \\n                return t;\\n            for(int i=0;i<4;i++){\\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                if(nx<n && nx>=0 && ny<n && ny>=0 && vis[nx][ny]!=1){\\n                    vis[nx][ny]=1;\\n                    if(grid[nx][ny]<=t)\\n                        minheap.push({t,{nx,ny}}); //No need to update time\\n                    else\\n                        minheap.push({grid[nx][ny],{nx,ny}}); //Update time\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> minheap;\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        vector<int> dx={0,-1,0,1};\\n        vector<int> dy={-1,0,1,0};\\n        minheap.push({grid[0][0],{0,0}});\\n        vis[0][0]=1;\\n        while(!minheap.empty()){\\n            int t=minheap.top().first;\\n            int x=minheap.top().second.first;\\n            int y=minheap.top().second.second;\\n            minheap.pop();\\n            if(x==n-1 && y==n-1) \\n                return t;\\n            for(int i=0;i<4;i++){\\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                if(nx<n && nx>=0 && ny<n && ny>=0 && vis[nx][ny]!=1){\\n                    vis[nx][ny]=1;\\n                    if(grid[nx][ny]<=t)\\n                        minheap.push({t,{nx,ny}}); //No need to update time\\n                    else\\n                        minheap.push({grid[nx][ny],{nx,ny}}); //Update time\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691420,
                "title": "c-easy-and-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vis[0][0]=1;\\n        int dr[]={-1,0,1,0};\\n        int dc[]={0,1,0,-1};\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int t=it.first;\\n            int r=it.second.first;\\n            int c=it.second.second;\\n            if(r==n-1 && c==n-1) return t;\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<n && vis[nr][nc]!=1){\\n                    vis[nr][nc]=1;\\n                    pq.push({max(t,grid[nr][nc]),{nr,nc}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vis[0][0]=1;\\n        int dr[]={-1,0,1,0};\\n        int dc[]={0,1,0,-1};\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            pq.pop();\\n            int t=it.first;\\n            int r=it.second.first;\\n            int c=it.second.second;\\n            if(r==n-1 && c==n-1) return t;\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<n && vis[nr][nc]!=1){\\n                    vis[nr][nc]=1;\\n                    pq.push({max(t,grid[nr][nc]),{nr,nc}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648429,
                "title": "dijkstra-variation-using-set-but-why-priority-queue-giving-tle",
                "content": "The idea is go in all possible 4 directions and push the adjacent node with max(max_till, grid[x][y]) .\\n``` cpp\\nclass Solution\\n{\\npublic:\\n    int swimInWater(vector<vector < int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        // TLE with pq;\\n        set<pair<int, pair<int, int>>> q;\\n        q.insert({grid[0][0], {0, 0}});\\n\\n        vector<vector<int>> vis(n, vector<int>(m));\\n\\n        vector<pair<int, int>> dir = {{ -1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n\\n        while (q.size())\\n        {\\n            auto front =  *q.begin();\\n            q.erase(front);\\n            int max_yet = front.first;\\n            int i = front.second.first;\\n            int j = front.second.second;\\n            vis[i][j] = 1;\\n\\n            if (i == n - 1 && j == m - 1)\\n            {\\n                return max_yet;\\n            }\\n\\n            for (auto &c : dir)\\n            {\\n                int x = i + c.first, y = j + c.second;\\n\\n                if (x >= 0 && x < n && y >= 0 && y < n && vis[x][y] == 0)\\n                {\\n                    int d = max(max_yet, grid[x][y]);\\n                    q.insert({d, {x, y}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "``` cpp\\nclass Solution\\n{\\npublic:\\n    int swimInWater(vector<vector < int>> &grid)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        // TLE with pq;\\n        set<pair<int, pair<int, int>>> q;\\n        q.insert({grid[0][0], {0, 0}});\\n\\n        vector<vector<int>> vis(n, vector<int>(m));\\n\\n        vector<pair<int, int>> dir = {{ -1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n\\n        while (q.size())\\n        {\\n            auto front =  *q.begin();\\n            q.erase(front);\\n            int max_yet = front.first;\\n            int i = front.second.first;\\n            int j = front.second.second;\\n            vis[i][j] = 1;\\n\\n            if (i == n - 1 && j == m - 1)\\n            {\\n                return max_yet;\\n            }\\n\\n            for (auto &c : dir)\\n            {\\n                int x = i + c.first, y = j + c.second;\\n\\n                if (x >= 0 && x < n && y >= 0 && y < n && vis[x][y] == 0)\\n                {\\n                    int d = max(max_yet, grid[x][y]);\\n                    q.insert({d, {x, y}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628819,
                "title": "c-bfs-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs there are multiple paths that can lead to answer, we need the path that minimizes the time and so using Set data structure.\\nNormal BFS will do.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSet will store`{time, {x, y}}`. So each time, the top element in set will have the point in`grid`with minimum`time`till that point.\\nArriving at new point we check for it\\'s validity and then insert that point with`time`as maximum of current`grid`value and previously max value in that path.\\nAt any point if we arrive at target coordinate i.e.`(n-1, n-1)`we store the`time` in answer and break as upcoming values will surely be greater than current`time`value. \\n\\n# Complexity\\n- Time complexity: Normal BFS using set\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: Visited matrix + Set\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(int newX, int newY, int n){\\n        return (newX>=0 && newX<n && newY>=0 && newY<n);\\n    }\\n\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size(), i;\\n        vector<vector<int>> vis(n, vector<int>(n, 0));\\n        // {max time, {x, y}} \\n        set<pair<int, pair<int, int>>> st;\\n        int ans=0;\\n        st.insert({grid[0][0], {0, 0}});\\n        while(st.size()!=0){\\n            auto it=*(st.begin());\\n            int time=it.first;\\n            int x=it.second.first;\\n            int y=it.second.second;\\n            st.erase(it);\\n            vis[x][y]=1;\\n            if(x==n-1 && y==n-1){\\n                ans=time;\\n                break;\\n            }\\n            // (row-1, row, row+0, row)\\n            int dr[]={-1, 0, 1, 0};\\n            // (col, col+1, col, col-1)\\n            int dc[]={0, 1, 0, -1};\\n            for(i=0; i<4; ++i){\\n                int newX=x+dr[i];\\n                int newY=y+dc[i];\\n                if(isValid(newX, newY, n) && vis[newX][newY]==0){\\n                    st.insert({max(time, grid[newX][newY]), {newX, newY}});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(int newX, int newY, int n){\\n        return (newX>=0 && newX<n && newY>=0 && newY<n);\\n    }\\n\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size(), i;\\n        vector<vector<int>> vis(n, vector<int>(n, 0));\\n        // {max time, {x, y}} \\n        set<pair<int, pair<int, int>>> st;\\n        int ans=0;\\n        st.insert({grid[0][0], {0, 0}});\\n        while(st.size()!=0){\\n            auto it=*(st.begin());\\n            int time=it.first;\\n            int x=it.second.first;\\n            int y=it.second.second;\\n            st.erase(it);\\n            vis[x][y]=1;\\n            if(x==n-1 && y==n-1){\\n                ans=time;\\n                break;\\n            }\\n            // (row-1, row, row+0, row)\\n            int dr[]={-1, 0, 1, 0};\\n            // (col, col+1, col, col-1)\\n            int dc[]={0, 1, 0, -1};\\n            for(i=0; i<4; ++i){\\n                int newX=x+dr[i];\\n                int newY=y+dc[i];\\n                if(isValid(newX, newY, n) && vis[newX][newY]==0){\\n                    st.insert({max(time, grid[newX][newY]), {newX, newY}});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463871,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n=grid.length;\\n        int l=grid[0][0];\\n        int r=n*n-1;\\n        while(l<r)\\n        {\\n            int m= l+(r-l)/2;\\n            boolean v[][]=new boolean[n][n];\\n            if(dfs(grid,0,0,v,m)==true)\\n                r=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n    public boolean dfs(int g[][],int r, int c, boolean v[][],int t)\\n    {\\n        int n=g.length;\\n        if(r<0 || r>=n || c<0 || c>=n || v[r][c]==true || g[r][c]>t) return false;\\n        v[r][c]=true;\\n        if(r==n-1 && c==n-1) return true;\\n        if(dfs(g,r-1,c,v,t) || dfs(g,r+1,c,v,t) || dfs(g,r,c-1,v,t) || dfs(g,r,c+1,v,t))return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n=grid.length;\\n        int l=grid[0][0];\\n        int r=n*n-1;\\n        while(l<r)\\n        {\\n            int m= l+(r-l)/2;\\n            boolean v[][]=new boolean[n][n];\\n            if(dfs(grid,0,0,v,m)==true)\\n                r=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n    public boolean dfs(int g[][],int r, int c, boolean v[][],int t)\\n    {\\n        int n=g.length;\\n        if(r<0 || r>=n || c<0 || c>=n || v[r][c]==true || g[r][c]>t) return false;\\n        v[r][c]=true;\\n        if(r==n-1 && c==n-1) return true;\\n        if(dfs(g,r-1,c,v,t) || dfs(g,r+1,c,v,t) || dfs(g,r,c-1,v,t) || dfs(g,r,c+1,v,t))return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462895,
                "title": "solution",
                "content": "```C++ []\\n#include <vector>\\n#include <queue>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>> const& grid) {\\n        char const n = size(grid);\\n        short added[50][50] = {};\\n        using qtup = tuple<short, char, char>;\\n        auto const qgreater = [](auto const& x, auto const& y) { return get<0>(x) > get<0>(y); };\\n        priority_queue<qtup, vector<qtup>, decltype(qgreater)> pque(qgreater);\\n        vector<qtup> stack;\\n        stack.emplace_back(grid[0][0]+1, 0, 0);\\n        added[0][0] = grid[0][0]+1;\\n        while(true) {\\n            short path_max; char i, j;\\n            if(!empty(stack)) {\\n                tie(path_max, i, j) = stack.back();\\n                stack.pop_back();\\n            }\\n            else {\\n                tie(path_max, i, j) = pque.top();\\n                pque.pop();\\n            }\\n            if(i == n-1 && j == n-1) {\\n                return path_max-1;\\n            }\\n            char const dx[] = {0, -1, 0, 1, 0};\\n            for(char x{0}; x < 4; ++x) {\\n                char const i2 = i + dx[x], j2 = j + dx[x+1];\\n                if(0 <= i2 && i2 < n && 0 <= j2 && j2 < n) {\\n                    auto const path_max2 = max<short>(path_max, grid[i2][j2]+1);\\n                    if(!added[i2][j2]) {//} || path_max2 < added[i2][j2]) {\\n                        added[i2][j2] = path_max2;\\n                        if(grid[i2][j2] < path_max) {\\n                            stack.emplace_back(path_max2, i2, j2);\\n                        }\\n                        else {\\n                            pque.emplace(path_max2, i2, j2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 911;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def swimInWater(self, grid) -> int:\\n        def dfs(row: int, col: int, swim_time: int, visited) -> bool:\\n            if row < 0 or row >= len_grid or col < 0 or col >= len_grid:\\n                return False\\n            if (row, col) in visited:\\n                return False\\n            visited.add((row, col))\\n            cell_time = grid[row][col]\\n            if cell_time > swim_time:\\n                return False\\n            \\n            if row == len_grid - 1 and col == len_grid - 1:\\n                return True\\n          \\n            if dfs(row + 1, col, swim_time, visited):\\n                return True\\n            elif dfs( row, col + 1, swim_time, visited ):\\n                return True\\n            elif dfs( row - 1, col, swim_time, visited ):\\n                return True\\n            elif dfs(row, col - 1, swim_time, visited):\\n                return True\\n            return False\\n\\n        len_grid = len(grid)\\n        left = grid[-1][-1]\\n        right = len_grid * len_grid - 1\\n        while left < right:\\n            visited = set()\\n            swim_time = left + (right - left) // 2\\n            if dfs(0, 0, swim_time, visited):\\n                right = swim_time\\n            else:\\n                left = swim_time + 1\\n        return left\\n```\\n\\n```Java []\\nclass Solution {\\n  int len;\\nfinal static int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n\\npublic int swimInWater(int[][] grid) {\\n    len = grid.length;\\n    int left = Math.max(grid[0][0], grid[len - 1][len - 1]), right = len * len - 1, mid, res = 0;\\n    while (left <= right) {\\n        mid = (left + right) / 2;\\n        boolean[] seen = new boolean[len * len];\\n        if (dfs(0, 0, grid, mid, seen)) {\\n            res = mid;\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\npublic boolean dfs(int xn, int yn, int[][] grid, int mid, boolean[] seen) {\\n    int idx = xn * len + yn;\\n    if (seen[idx]) return true;\\n    seen[idx] = true;\\n    for (int i = 0; i < 4; i++) {\\n        int newx = xn + dirs[i][0], newy = yn + dirs[i][1];\\n        if (newx >= 0 && newx < len && newy >= 0\\n                && newy < len && !seen[newx * len + newy] && grid[newx][newy] <= mid) {\\n            if (newx == len - 1 && newy == len - 1) {\\n                return true;\\n            }\\n            if (dfs(newx, newy, grid, mid, seen)) {\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#include <vector>\\n#include <queue>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>> const& grid) {\\n        char const n = size(grid);\\n        short added[50][50] = {};\\n        using qtup = tuple<short, char, char>;\\n        auto const qgreater = [](auto const& x, auto const& y) { return get<0>(x) > get<0>(y); };\\n        priority_queue<qtup, vector<qtup>, decltype(qgreater)> pque(qgreater);\\n        vector<qtup> stack;\\n        stack.emplace_back(grid[0][0]+1, 0, 0);\\n        added[0][0] = grid[0][0]+1;\\n        while(true) {\\n            short path_max; char i, j;\\n            if(!empty(stack)) {\\n                tie(path_max, i, j) = stack.back();\\n                stack.pop_back();\\n            }\\n            else {\\n                tie(path_max, i, j) = pque.top();\\n                pque.pop();\\n            }\\n            if(i == n-1 && j == n-1) {\\n                return path_max-1;\\n            }\\n            char const dx[] = {0, -1, 0, 1, 0};\\n            for(char x{0}; x < 4; ++x) {\\n                char const i2 = i + dx[x], j2 = j + dx[x+1];\\n                if(0 <= i2 && i2 < n && 0 <= j2 && j2 < n) {\\n                    auto const path_max2 = max<short>(path_max, grid[i2][j2]+1);\\n                    if(!added[i2][j2]) {//} || path_max2 < added[i2][j2]) {\\n                        added[i2][j2] = path_max2;\\n                        if(grid[i2][j2] < path_max) {\\n                            stack.emplace_back(path_max2, i2, j2);\\n                        }\\n                        else {\\n                            pque.emplace(path_max2, i2, j2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 911;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def swimInWater(self, grid) -> int:\\n        def dfs(row: int, col: int, swim_time: int, visited) -> bool:\\n            if row < 0 or row >= len_grid or col < 0 or col >= len_grid:\\n                return False\\n            if (row, col) in visited:\\n                return False\\n            visited.add((row, col))\\n            cell_time = grid[row][col]\\n            if cell_time > swim_time:\\n                return False\\n            \\n            if row == len_grid - 1 and col == len_grid - 1:\\n                return True\\n          \\n            if dfs(row + 1, col, swim_time, visited):\\n                return True\\n            elif dfs( row, col + 1, swim_time, visited ):\\n                return True\\n            elif dfs( row - 1, col, swim_time, visited ):\\n                return True\\n            elif dfs(row, col - 1, swim_time, visited):\\n                return True\\n            return False\\n\\n        len_grid = len(grid)\\n        left = grid[-1][-1]\\n        right = len_grid * len_grid - 1\\n        while left < right:\\n            visited = set()\\n            swim_time = left + (right - left) // 2\\n            if dfs(0, 0, swim_time, visited):\\n                right = swim_time\\n            else:\\n                left = swim_time + 1\\n        return left\\n```\n```Java []\\nclass Solution {\\n  int len;\\nfinal static int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n\\npublic int swimInWater(int[][] grid) {\\n    len = grid.length;\\n    int left = Math.max(grid[0][0], grid[len - 1][len - 1]), right = len * len - 1, mid, res = 0;\\n    while (left <= right) {\\n        mid = (left + right) / 2;\\n        boolean[] seen = new boolean[len * len];\\n        if (dfs(0, 0, grid, mid, seen)) {\\n            res = mid;\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\npublic boolean dfs(int xn, int yn, int[][] grid, int mid, boolean[] seen) {\\n    int idx = xn * len + yn;\\n    if (seen[idx]) return true;\\n    seen[idx] = true;\\n    for (int i = 0; i < 4; i++) {\\n        int newx = xn + dirs[i][0], newy = yn + dirs[i][1];\\n        if (newx >= 0 && newx < len && newy >= 0\\n                && newy < len && !seen[newx * len + newy] && grid[newx][newy] <= mid) {\\n            if (newx == len - 1 && newy == len - 1) {\\n                return true;\\n            }\\n            if (dfs(newx, newy, grid, mid, seen)) {\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3206346,
                "title": "runtime-9-ms-beats-76-95-memory-41-8-mb-beats-91-98",
                "content": "# Intuition\\njust think of reaching the last point how many ways u can reach at last and then with the help of priority queue u choose the minimum cost\\n\\n# Approach\\ninsert the first node at the pq and delete the node and then caluclate the cost which will be maximum cost right now in variable min and  add all its neighbour inside the priority queue.\\nthen again in next iteration u will get the node with minimum cost as u are using pq so every time u get the minimum node first which is ur need. until u reach the matrix end when u reach there just return the cost .\\n\\nrun the 2nd testcase on ur copy u will understand better \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass pair{\\n    int x;\\n    int y;\\n    int value;\\n    \\n    pair(int x,int y,int value){\\n        this.x=x;\\n        this.y=y;\\n        this.value=value;\\n    }\\n}\\nclass Solution {\\n    public static int Dijkstra(int[][] grid){\\n        PriorityQueue<pair> pq=new PriorityQueue<>((a,b)->a.value-b.value);\\n        pq.add(new pair(0,0,grid[0][0]));\\n        int[][] distance={{-1,0},{1,0},{0,1},{0,-1}};\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<visited.length;i++){\\n            Arrays.fill(visited[i],false);\\n        }\\n        visited[0][0]=true;\\n        int min=Integer.MIN_VALUE;\\n        while(!pq.isEmpty()){\\n            pair p=pq.poll();\\n            int x=p.x;\\n            int y=p.y;\\n            int value=p.value;\\n            if(value>min){\\n                min=value;\\n            }\\n            if(x==grid.length-1 && y==grid[0].length-1){\\n                return min;\\n            }\\n            for(int i=0;i<distance.length;i++){\\n                int nbr_x=x+distance[i][0];\\n                int nbr_y=y+distance[i][1];\\n                if(nbr_x>=0 && nbr_x<grid.length && nbr_y>=0 && nbr_y<grid[0].length && visited[nbr_x][nbr_y]==false){\\n                   \\n                    pq.add(new pair(nbr_x,nbr_y,grid[nbr_x][nbr_y]));\\n                     visited[nbr_x][nbr_y]=true;\\n                     \\n                }\\n            }\\n        }\\n        return min;\\n\\n    }\\n    public int swimInWater(int[][] grid){\\n        \\n        int k=Dijkstra(grid);\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass pair{\\n    int x;\\n    int y;\\n    int value;\\n    \\n    pair(int x,int y,int value){\\n        this.x=x;\\n        this.y=y;\\n        this.value=value;\\n    }\\n}\\nclass Solution {\\n    public static int Dijkstra(int[][] grid){\\n        PriorityQueue<pair> pq=new PriorityQueue<>((a,b)->a.value-b.value);\\n        pq.add(new pair(0,0,grid[0][0]));\\n        int[][] distance={{-1,0},{1,0},{0,1},{0,-1}};\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<visited.length;i++){\\n            Arrays.fill(visited[i],false);\\n        }\\n        visited[0][0]=true;\\n        int min=Integer.MIN_VALUE;\\n        while(!pq.isEmpty()){\\n            pair p=pq.poll();\\n            int x=p.x;\\n            int y=p.y;\\n            int value=p.value;\\n            if(value>min){\\n                min=value;\\n            }\\n            if(x==grid.length-1 && y==grid[0].length-1){\\n                return min;\\n            }\\n            for(int i=0;i<distance.length;i++){\\n                int nbr_x=x+distance[i][0];\\n                int nbr_y=y+distance[i][1];\\n                if(nbr_x>=0 && nbr_x<grid.length && nbr_y>=0 && nbr_y<grid[0].length && visited[nbr_x][nbr_y]==false){\\n                   \\n                    pq.add(new pair(nbr_x,nbr_y,grid[nbr_x][nbr_y]));\\n                     visited[nbr_x][nbr_y]=true;\\n                     \\n                }\\n            }\\n        }\\n        return min;\\n\\n    }\\n    public int swimInWater(int[][] grid){\\n        \\n        int k=Dijkstra(grid);\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013058,
                "title": "python3-min-heap-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Brute force approach is to start from (0,0) traverse through every item in grid and return the smallest elevation value when we reach n-1,n-1. However this approach could possibly take O(N^N). \\n\\nhence we need a way to take smallest route at any point in time. Using a priority queue instead of a normal queue help us with that\\n\\n# Approach\\n\\n- maintain a priority queue to pick up the smallest elevation point.\\n- maintain a reference of highest elevation value seen for each (x,y), initialize the reference to inf.\\n- start from n-1, n-1 and traverse up to 0,0.\\n- as the traversal is 4-directional,it is possible that we may visit the same (x,y) coordinates again. we should avoid it. we can avoid it by a condition that we step into a x,y only if reference value is greater than the biggest elevation seen in a path. this means we reach a x,y with a lesser elevation value than before. \\n- push the neighbours of the x,y if they are valid\\n- keep updating the reference until we reach 0,0\\n- the first time we reach (0,0), that is the smallest elevation point we could achieve, hence we dont have to traverse any further.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nComplexity to maintain min heap - $$O(n^2 log(n^2))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nreference is a 2D grid as same as size of input array, hence $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        ref = [[float(\"inf\") for i in range(COLS)] for j in range(ROWS)]\\n        hq = [[(grid[ROWS-1][COLS-1]),ROWS-1,COLS-1]]\\n        iter = [[-1,0],[1,0],[0,-1],[0,1]]\\n        while hq:\\n            curr_big,idx_x,idx_y = heapq.heappop(hq)\\n            if ref[idx_x][idx_y]>curr_big:\\n                ref[idx_x][idx_y] = curr_big\\n                for x1,y1 in iter:\\n                    x,y = idx_x+x1,idx_y+y1\\n                    if x>=0 and x<ROWS and y>=0 and y<COLS:\\n                        if (x,y)==(0,0):\\n                            print(f\\'reached\\')\\n                            return max(curr_big,grid[x][y])\\n                        \\n                        if ref[x][y]>curr_big:\\n                            heapq.heappush(hq,[max(curr_big,grid[x][y]),x,y])\\n        return ref[0][0] \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        ref = [[float(\"inf\") for i in range(COLS)] for j in range(ROWS)]\\n        hq = [[(grid[ROWS-1][COLS-1]),ROWS-1,COLS-1]]\\n        iter = [[-1,0],[1,0],[0,-1],[0,1]]\\n        while hq:\\n            curr_big,idx_x,idx_y = heapq.heappop(hq)\\n            if ref[idx_x][idx_y]>curr_big:\\n                ref[idx_x][idx_y] = curr_big\\n                for x1,y1 in iter:\\n                    x,y = idx_x+x1,idx_y+y1\\n                    if x>=0 and x<ROWS and y>=0 and y<COLS:\\n                        if (x,y)==(0,0):\\n                            print(f\\'reached\\')\\n                            return max(curr_big,grid[x][y])\\n                        \\n                        if ref[x][y]>curr_big:\\n                            heapq.heappush(hq,[max(curr_big,grid[x][y]),x,y])\\n        return ref[0][0] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727741,
                "title": "ruby-binary-search-dfs",
                "content": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef swim_in_water(grid)\\n  low = grid[0][0]\\n  high = grid.length * grid.length - 1\\n  \\n  while low < high\\n    middle = ((high - low) / 2) + low\\n    if !is_possible?(grid, middle)\\n      low = middle + 1\\n    else\\n      high = middle\\n    end\\n  end\\n  \\n  low\\nend\\n\\ndef is_possible?(grid, middle)\\n  seen = Set.new([0, 0])\\n  stack = [[0, 0]]\\n  directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n  \\n  until stack.empty?\\n    row, col = stack.pop\\n    return true if row == grid.length - 1 && col == grid.length - 1\\n    \\n    directions.each do |row_change, col_change|\\n      new_row = row + row_change\\n      new_col = col + col_change\\n      \\n      if new_row.between?(0, grid.length - 1) &&\\n          new_col.between?(0, grid[0].length - 1) &&\\n          !seen.include?([new_row, new_col]) &&\\n          grid[new_row][new_col] <= middle\\n        \\n        stack << [new_row, new_col]\\n        seen.add([new_row, new_col])\\n      end\\n    end\\n  end\\n  \\n  false\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef swim_in_water(grid)\\n  low = grid[0][0]\\n  high = grid.length * grid.length - 1\\n  \\n  while low < high\\n    middle = ((high - low) / 2) + low\\n    if !is_possible?(grid, middle)\\n      low = middle + 1\\n    else\\n      high = middle\\n    end\\n  end\\n  \\n  low\\nend\\n\\ndef is_possible?(grid, middle)\\n  seen = Set.new([0, 0])\\n  stack = [[0, 0]]\\n  directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n  \\n  until stack.empty?\\n    row, col = stack.pop\\n    return true if row == grid.length - 1 && col == grid.length - 1\\n    \\n    directions.each do |row_change, col_change|\\n      new_row = row + row_change\\n      new_col = col + col_change\\n      \\n      if new_row.between?(0, grid.length - 1) &&\\n          new_col.between?(0, grid[0].length - 1) &&\\n          !seen.include?([new_row, new_col]) &&\\n          grid[new_row][new_col] <= middle\\n        \\n        stack << [new_row, new_col]\\n        seen.add([new_row, new_col])\\n      end\\n    end\\n  end\\n  \\n  false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2600797,
                "title": "javascript-dijkstra-algo-bfs-greedy-minheap-n-2-log-n",
                "content": "```\\nconst swimInWater = function(grid) {\\n    let n = grid.length\\n    let dirs = [[1,0], [-1,0], [0,1], [0,-1]]\\n    let mh = new MinPriorityQueue({priority: v=>v[0]})\\n    mh.enqueue([grid[0][0], 0, 0])\\n    \\n    let visit = new Set()\\n    visit.add(0 + \\'\\' + 0)\\n    \\n    while(mh.size()){\\n        let [t, r, c] = mh.dequeue().element\\n        if(r === n - 1 && c === n - 1) return t\\n        for(let [dx, dy] of dirs){\\n            let dx1 = r + dx\\n            let dy1 = c + dy\\n            if(dx1 < 0 || dy1 < 0 || dx1 >= n || dy1 >= n || visit.has(dx1 + \\'\\' + dy1)) continue\\n             visit.add(dx1 + \\'\\' + dy1)\\n             mh.enqueue([Math.max(t, grid[dx1][dy1]), dx1, dy1])\\n        }   \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nconst swimInWater = function(grid) {\\n    let n = grid.length\\n    let dirs = [[1,0], [-1,0], [0,1], [0,-1]]\\n    let mh = new MinPriorityQueue({priority: v=>v[0]})\\n    mh.enqueue([grid[0][0], 0, 0])\\n    \\n    let visit = new Set()\\n    visit.add(0 + \\'\\' + 0)\\n    \\n    while(mh.size()){\\n        let [t, r, c] = mh.dequeue().element\\n        if(r === n - 1 && c === n - 1) return t\\n        for(let [dx, dy] of dirs){\\n            let dx1 = r + dx\\n            let dy1 = c + dy\\n            if(dx1 < 0 || dy1 < 0 || dx1 >= n || dy1 >= n || visit.has(dx1 + \\'\\' + dy1)) continue\\n             visit.add(dx1 + \\'\\' + dy1)\\n             mh.enqueue([Math.max(t, grid[dx1][dy1]), dx1, dy1])\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575375,
                "title": "java-dfs-binary-search-on-answer",
                "content": "The Fact that the values in the Grid lie between 0 & (m * n  - 1) can be leveraged to perform a Binary Search on the Answer within the Range. We can search whether for each Mid value, can we reach from Start (0,0) to end (m-1, n-1) ? \\n\\n```\\nclass Solution {\\n    int[][] directions = {{1, 0},{0, 1},{-1, 0},{0, -1}};\\n    \\n    public int swimInWater(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int left = grid[0][0], right = rows*cols - 1;\\n        \\n        while(left < right)\\n        {\\n            int mid = left + (right - left)/2;\\n            \\n            if(canReach(mid, 0, 0, grid, new boolean[rows][cols]))\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean canReach(int mid, int i, int j, int[][] grid, boolean[][] visited)\\n    {\\n        if(i < 0 || j < 0 || i == grid.length || j == grid.length) return false;\\n        if(visited[i][j] || grid[i][j] > mid) return false;\\n        \\n        visited[i][j] = true;\\n        if(i == grid.length - 1 && j == grid[0].length - 1) return true;\\n        boolean ans = false;\\n        \\n        for(int k = 0; k < 4; k++)\\n        {\\n            int x = directions[k][0] + i;\\n            int y = directions[k][1] + j;\\n            \\n            ans |= canReach(mid, x, y, grid, visited);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = {{1, 0},{0, 1},{-1, 0},{0, -1}};\\n    \\n    public int swimInWater(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        int left = grid[0][0], right = rows*cols - 1;\\n        \\n        while(left < right)\\n        {\\n            int mid = left + (right - left)/2;\\n            \\n            if(canReach(mid, 0, 0, grid, new boolean[rows][cols]))\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private boolean canReach(int mid, int i, int j, int[][] grid, boolean[][] visited)\\n    {\\n        if(i < 0 || j < 0 || i == grid.length || j == grid.length) return false;\\n        if(visited[i][j] || grid[i][j] > mid) return false;\\n        \\n        visited[i][j] = true;\\n        if(i == grid.length - 1 && j == grid[0].length - 1) return true;\\n        boolean ans = false;\\n        \\n        for(int k = 0; k < 4; k++)\\n        {\\n            int x = directions[k][0] + i;\\n            int y = directions[k][1] + j;\\n            \\n            ans |= canReach(mid, x, y, grid, visited);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464943,
                "title": "easy-to-follow-python3-solutoon",
                "content": "Do please comment if the complexity analysis needs correction, I am more than happy to hear it.\\n\\n```\\nclass Solution:\\n    # O(max(n^2, m)) time, h --> the highest elevation in the grid\\n    # O(n^2) space,\\n    # Approach: BFS, Priority queue\\n    # I wld advise to do task scheduler question, it\\'s pretty similar\\n    # except that u apply bfs to traverse the grid 4 directionally\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        if n == 1:\\n            return 0\\n        \\n        def getNeighbours(coord: Tuple) -> List[Tuple]:\\n            i, j = coord\\n            n = len(grid)\\n            neighbours = []\\n            \\n            if i < n-1:\\n                neighbours.append((i+1, j))\\n            if i > 0:\\n                neighbours.append((i-1, j))\\n            if j < n-1:\\n                neighbours.append((i, j+1))\\n            if j > 0:\\n                neighbours.append((i, j-1))\\n                \\n            return neighbours\\n        \\n        qu = deque()\\n        waiting_qu = []\\n        vstd = set()\\n        waiting_qu.append([grid[0][0], (0, 0)])\\n        vstd.add((0, 0))\\n        time = 0\\n        \\n        while waiting_qu:\\n            time +=1\\n            while waiting_qu and waiting_qu[0][0] <= time:\\n                qu.append(heapq.heappop(waiting_qu)[1])\\n            \\n            while qu:\\n                cell = qu.popleft()\\n                if cell == (n-1, n-1):\\n                    return time\\n                nbrs = getNeighbours(cell)\\n                for nb in nbrs:\\n                    if nb in vstd:  continue\\n                    x, y = nb\\n                    elevation = grid[x][y]\\n                    vstd.add(nb)\\n                    if elevation > time:\\n                        heapq.heappush(waiting_qu, [elevation, nb])\\n                    else:\\n                        qu.append(nb)\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    # O(max(n^2, m)) time, h --> the highest elevation in the grid\\n    # O(n^2) space,\\n    # Approach: BFS, Priority queue\\n    # I wld advise to do task scheduler question, it\\'s pretty similar\\n    # except that u apply bfs to traverse the grid 4 directionally\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        if n == 1:\\n            return 0\\n        \\n        def getNeighbours(coord: Tuple) -> List[Tuple]:\\n            i, j = coord\\n            n = len(grid)\\n            neighbours = []\\n            \\n            if i < n-1:\\n                neighbours.append((i+1, j))\\n            if i > 0:\\n                neighbours.append((i-1, j))\\n            if j < n-1:\\n                neighbours.append((i, j+1))\\n            if j > 0:\\n                neighbours.append((i, j-1))\\n                \\n            return neighbours\\n        \\n        qu = deque()\\n        waiting_qu = []\\n        vstd = set()\\n        waiting_qu.append([grid[0][0], (0, 0)])\\n        vstd.add((0, 0))\\n        time = 0\\n        \\n        while waiting_qu:\\n            time +=1\\n            while waiting_qu and waiting_qu[0][0] <= time:\\n                qu.append(heapq.heappop(waiting_qu)[1])\\n            \\n            while qu:\\n                cell = qu.popleft()\\n                if cell == (n-1, n-1):\\n                    return time\\n                nbrs = getNeighbours(cell)\\n                for nb in nbrs:\\n                    if nb in vstd:  continue\\n                    x, y = nb\\n                    elevation = grid[x][y]\\n                    vstd.add(nb)\\n                    if elevation > time:\\n                        heapq.heappush(waiting_qu, [elevation, nb])\\n                    else:\\n                        qu.append(nb)\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428614,
                "title": "java-code-dp-binary-search-98-02-faster",
                "content": "class Solution {\\n    \\n    int X[] = {1 , 0 , -1 , 0 };\\n    int Y[] = { 0 , 1 , 0 , -1};\\n    int dp[][];\\n    public boolean isValid(int x , int y , int grid[][])\\n    {\\n        //Checks both for index validity and visited validity.\\n        int n = grid.length;\\n        if(x<0 || y<0 || x>=n || y>=n || grid[x][y]==-1)\\n        {\\n            return false;\\n        }\\n        return true;\\n        \\n    }\\n    public int isPossible(int[][] grid , int x , int y , int max , int tx , int ty)\\n    {\\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        \\n        if(grid[x][y] > max)\\n        {\\n            return dp[x][y]=0;\\n        }\\n        \\n        if(x==tx && y==ty)\\n        {\\n            return dp[x][y]=1;\\n        }\\n        \\n        int h = grid[x][y];\\n        grid[x][y] = -1;//Marking cell as visited.\\n        //Loop through our choices.\\n        for(int i=0;i<4;i++)\\n        {\\n            int ax  = x+X[i];\\n            int ay =  y+Y[i];\\n            //Adjacent x and y calculated.\\n            if(isValid(ax , ay , grid) && grid[ax][ay]<=max)\\n            {\\n                //Valid point and less than our chosen max.\\n                if(isPossible(grid , ax , ay , max , tx , ty)==1)\\n                {\\n                    grid[x][y] = h;//Before retreating..again set as unvisited(Previous Value).\\n                    return dp[x][y]=1;\\n                }\\n            }\\n        }\\n        //Having looped through all choices..none returned true..then return false &  store in dp.\\n        //But .. before returning  always mark the grid as unvisited.\\n        \\n        grid[x][y] = h;\\n        dp[x][y]=0;\\n        return 0;\\n    }\\n    \\n    \\n    public int swimInWater(int[][] grid) {\\n        \\n        int n = grid.length;\\n        dp = new int[n][n];\\n       \\n        \\n        //Simple problem..we need to find a path , whose max value is min possible.\\n        \\n        //We find range of possible solutions.\\n        \\n        //Then call the isPossible method for the values in our sol set.\\n        \\n        int min = 2*n -2;//Min 2n-1 steps..which atleat has a value of 2n-2.\\n        int max = n*n-1;//Max value in the matrix.\\n        int ans = 0;\\n        while(min<=max)\\n        {\\n            int mid = min + (max - min)/2;\\n            \\n            for(int x=0;x<n;x++)\\n            {\\n                Arrays.fill(dp[x] , -1);\\n            }\\n            \\n            if(isPossible(grid ,0 , 0 , mid , n-1 , n-1)==1)\\n            {\\n                ans = mid;\\n                max = mid - 1;\\n            }\\n            else\\n            {\\n                min = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n    int X[] = {1 , 0 , -1 , 0 }",
                "codeTag": "Java"
            },
            {
                "id": 2411682,
                "title": "java-solution-binary-search-bfs-solution-with-explanation",
                "content": "```\\n/* Binary Search on time and performing any search traversal for a given time  \\nIf destination is reachable from starting node at a particular time t, then it will also be reachable for time>t \\nIf destination is not reachable from starting node at a particular time t, then it will also be not reachable for time<t \\nHence binary search on time can be applied .\\n*/\\n\\nclass Solution {\\n    int n,m;\\n    int [][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n    \\n    boolean inBound(int i, int j){\\n        return i>=0 && j>=0 && i<n && j<m;\\n    }\\n    \\n    boolean seen[][];\\n    \\n    boolean check(int[][] grid, int t){\\n        // do bfs from starting cell and check if last point is reachable\\n        Queue<int[]> q = new LinkedList<>();\\n        int currVal = Math.max(grid[0][0],t);\\n        q.add(new int[]{0,0,currVal});\\n        \\n        for(int i=0;i<n;i++)\\n            Arrays.fill(seen[i],false);\\n        \\n        seen[0][0]= true;\\n        while(!q.isEmpty()){\\n            int[] pop = q.poll();\\n            int x = pop[0];\\n            int y = pop[1];\\n            currVal = pop[2];\\n            if(x==n-1 && y==m-1)\\n                return true;\\n            for(int[] dir: dirs){\\n                int newX = x+ dir[0];\\n                int newY = y+ dir[1];\\n                \\n                if(!inBound(newX,newY) || seen[newX][newY])\\n                    continue;\\n                \\n                int newVal = Math.max(grid[newX][newY],t);\\n                if(newVal != currVal)\\n                    continue;\\n                q.add(new int[]{newX,newY,newVal});\\n                seen[newX][newY] = true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int swimInWater(int[][] grid) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        seen = new boolean[n][m];\\n        int ans = Integer.MAX_VALUE;\\n        int l = 0, h = n*m;\\n        while(l<=h){\\n            int m = l+ (h-l)/2;\\n            boolean res = check(grid,m);\\n            if(res==true){\\n                ans = m;\\n                h= m-1;\\n            }else\\n                l=m+1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nT.C. O(n*m*log(n*m))\\nS.C. O(n*m) \\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/* Binary Search on time and performing any search traversal for a given time  \\nIf destination is reachable from starting node at a particular time t, then it will also be reachable for time>t \\nIf destination is not reachable from starting node at a particular time t, then it will also be not reachable for time<t \\nHence binary search on time can be applied .\\n*/\\n\\nclass Solution {\\n    int n,m;\\n    int [][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n    \\n    boolean inBound(int i, int j){\\n        return i>=0 && j>=0 && i<n && j<m;\\n    }\\n    \\n    boolean seen[][];\\n    \\n    boolean check(int[][] grid, int t){\\n        // do bfs from starting cell and check if last point is reachable\\n        Queue<int[]> q = new LinkedList<>();\\n        int currVal = Math.max(grid[0][0],t);\\n        q.add(new int[]{0,0,currVal});\\n        \\n        for(int i=0;i<n;i++)\\n            Arrays.fill(seen[i],false);\\n        \\n        seen[0][0]= true;\\n        while(!q.isEmpty()){\\n            int[] pop = q.poll();\\n            int x = pop[0];\\n            int y = pop[1];\\n            currVal = pop[2];\\n            if(x==n-1 && y==m-1)\\n                return true;\\n            for(int[] dir: dirs){\\n                int newX = x+ dir[0];\\n                int newY = y+ dir[1];\\n                \\n                if(!inBound(newX,newY) || seen[newX][newY])\\n                    continue;\\n                \\n                int newVal = Math.max(grid[newX][newY],t);\\n                if(newVal != currVal)\\n                    continue;\\n                q.add(new int[]{newX,newY,newVal});\\n                seen[newX][newY] = true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int swimInWater(int[][] grid) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        seen = new boolean[n][m];\\n        int ans = Integer.MAX_VALUE;\\n        int l = 0, h = n*m;\\n        while(l<=h){\\n            int m = l+ (h-l)/2;\\n            boolean res = check(grid,m);\\n            if(res==true){\\n                ans = m;\\n                h= m-1;\\n            }else\\n                l=m+1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nT.C. O(n*m*log(n*m))\\nS.C. O(n*m) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409253,
                "title": "java-simple-add-all-elements-in-priorityqueue-and-find-max-before-last",
                "content": "```\\nclass Solution {\\n    \\n    class Element {\\n        int row, col, value;\\n        Element(int row, int col, int value) {\\n            this.row = row;\\n            this.col = col;\\n            this.value = value;\\n        }\\n    }\\n    \\n    public int swimInWater(int[][] grid) {\\n        \\n        final int rows = grid.length;\\n        final int cols = grid[0].length;\\n        final boolean[][] visited = new boolean[rows][cols];\\n        final PriorityQueue<Element> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.value));\\n        \\n        int firstValue = grid[0][0];\\n        int lastValue = grid[rows-1][cols-1];\\n        int maxSoFar = firstValue;\\n        \\n        pq.offer(new Element(0, 0, firstValue));\\n        visited[0][0] = true;\\n        \\n        while (!pq.isEmpty()) {\\n            Element currEle = pq.poll();\\n            maxSoFar = Math.max(maxSoFar, currEle.value);\\n            \\n            if (currEle.value == lastValue) break;\\n            \\n            // add left\\n            if (currEle.col > 0 && !visited[currEle.row][currEle.col-1]) {\\n                int r = currEle.row;\\n                int c = currEle.col-1;\\n                pq.offer(new Element(r, c, grid[r][c]));\\n                visited[r][c] = true;\\n            }\\n            \\n            // add right\\n            if (currEle.col < cols-1 && !visited[currEle.row][currEle.col+1]) {\\n                int r = currEle.row;\\n                int c = currEle.col+1;\\n                pq.offer(new Element(r, c, grid[r][c]));\\n                visited[r][c] = true;\\n            }\\n            \\n            // add top\\n            if (currEle.row > 0 && !visited[currEle.row-1][currEle.col]) {\\n                int r = currEle.row-1;\\n                int c = currEle.col;\\n                pq.offer(new Element(r, c, grid[r][c]));\\n                visited[r][c] = true;\\n            }\\n            \\n            // add bottom\\n            if (currEle.row < rows-1 && !visited[currEle.row+1][currEle.col]) {\\n                int r = currEle.row+1;\\n                int c = currEle.col;\\n                pq.offer(new Element(r, c, grid[r][c]));\\n                visited[r][c] = true;\\n            }\\n        }\\n        \\n        return maxSoFar;\\n\\n    }\\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    \\n    class Element {\\n        int row, col, value;\\n        Element(int row, int col, int value) {\\n            this.row = row;\\n            this.col = col;\\n            this.value = value;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2402015,
                "title": "2-methods-binary-search-dfs-union-find",
                "content": "```python\\n\\'\\'\\'\\nbinary search, dfs\\nO(n^2*log(n^2)), O(n^2)\\n\\'\\'\\'\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        def find_neighbors(node):\\n            r, c = node\\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                r2, c2 = r + dr, c + dc\\n                if 0 <= r2 < n and 0 <= c2 < n:\\n                    yield r2, c2\\n        \\n        def dfs(time):\\n            stack = [(0, 0)]\\n            visited = {(0, 0)}\\n            while stack:\\n                node = stack.pop()\\n                if node == (n - 1, n - 1):\\n                    return True\\n                for neighbor in find_neighbors(node):\\n                    if neighbor in visited:\\n                        continue\\n                    r, c = neighbor\\n                    if grid[r][c] <= time:\\n                        stack.append(neighbor)\\n                        visited.add(neighbor)\\n            return False     \\n        \\n        n = len(grid)\\n        res = -1\\n        left, right = grid[0][0], n * n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if dfs(mid):\\n                res = mid\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return res\\n```\\n\\n```python\\n\\'\\'\\'\\nunion find\\nO(n^2*log(n^2)), O(n^2)\\n\\'\\'\\'\\nclass UnionFind:\\n    def __init__(self):\\n        self.id = {}\\n        \\n    def find(self, x):\\n        y = self.id.get(x, x)\\n        if y != x:\\n            self.id[x] = y = self.find(y)\\n        return y\\n    \\n    def union(self, x, y):\\n        self.id[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        def find_neighbors(node):\\n            r, c = node\\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                r2, c2 = r + dr, c + dc\\n                if 0 <= r2 < n and 0 <= c2 < n:\\n                    yield r2, c2\\n        \\n        points = []\\n        n = len(grid)\\n        for r in range(n):\\n            for c in range(n):\\n                points.append((r, c, grid[r][c]))\\n        points.sort(key=lambda x: x[2])\\n        \\n        uf = UnionFind()\\n        selected = set()\\n        for r, c, elevation in points:\\n            selected.add((r, c))\\n            for neighbor in find_neighbors((r, c)):\\n                if neighbor in selected:\\n                    uf.union((r, c), neighbor)\\n            if uf.find((0, 0)) == uf.find((n - 1, n - 1)):\\n                return elevation\\n        return -1\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```python\\n\\'\\'\\'\\nbinary search, dfs\\nO(n^2*log(n^2)), O(n^2)\\n\\'\\'\\'\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        def find_neighbors(node):\\n            r, c = node\\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                r2, c2 = r + dr, c + dc\\n                if 0 <= r2 < n and 0 <= c2 < n:\\n                    yield r2, c2\\n        \\n        def dfs(time):\\n            stack = [(0, 0)]\\n            visited = {(0, 0)}\\n            while stack:\\n                node = stack.pop()\\n                if node == (n - 1, n - 1):\\n                    return True\\n                for neighbor in find_neighbors(node):\\n                    if neighbor in visited:\\n                        continue\\n                    r, c = neighbor\\n                    if grid[r][c] <= time:\\n                        stack.append(neighbor)\\n                        visited.add(neighbor)\\n            return False     \\n        \\n        n = len(grid)\\n        res = -1\\n        left, right = grid[0][0], n * n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if dfs(mid):\\n                res = mid\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return res\\n```\n```python\\n\\'\\'\\'\\nunion find\\nO(n^2*log(n^2)), O(n^2)\\n\\'\\'\\'\\nclass UnionFind:\\n    def __init__(self):\\n        self.id = {}\\n        \\n    def find(self, x):\\n        y = self.id.get(x, x)\\n        if y != x:\\n            self.id[x] = y = self.find(y)\\n        return y\\n    \\n    def union(self, x, y):\\n        self.id[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        def find_neighbors(node):\\n            r, c = node\\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\\n                r2, c2 = r + dr, c + dc\\n                if 0 <= r2 < n and 0 <= c2 < n:\\n                    yield r2, c2\\n        \\n        points = []\\n        n = len(grid)\\n        for r in range(n):\\n            for c in range(n):\\n                points.append((r, c, grid[r][c]))\\n        points.sort(key=lambda x: x[2])\\n        \\n        uf = UnionFind()\\n        selected = set()\\n        for r, c, elevation in points:\\n            selected.add((r, c))\\n            for neighbor in find_neighbors((r, c)):\\n                if neighbor in selected:\\n                    uf.union((r, c), neighbor)\\n            if uf.find((0, 0)) == uf.find((n - 1, n - 1)):\\n                return elevation\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398441,
                "title": "c-bfs-priority-queue",
                "content": "\\t//simple brute force solution with priority queues.\\n\\tint swimInWater(vector<vector<int>>& heights) \\n    {\\n        int n=heights.size();\\n        int m=heights[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        \\n        int ans=max(heights[0][0],heights[n-1][m-1]);\\n        \\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        \\n        pq.push({-ans,{0,0}});\\n        vector<int> dir(5,0);\\n        \\n        dir[0]=-1;\\n        dir[4]=-1;\\n        dir[2]=1;\\n        int eff,x,y,nx,ny;\\n        \\n        while(!pq.empty())\\n        {\\n            eff = -pq.top().first;\\n            x = pq.top().second.first;\\n            y = pq.top().second.second;\\n            pq.pop();\\n            \\n            ans = max(ans,eff);\\n            if(x==n-1 && y==m-1)\\n                return ans;\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                nx=x+dir[i];\\n                ny=y+dir[i+1];\\n                \\n                if(nx<0 || ny<0 || nx>=n || ny>=m)\\n                    continue;\\n                \\n                if(vis[nx][ny])\\n                    continue;\\n                \\n                vis[nx][ny]=true;\\n                pq.push({-heights[nx][ny],{nx,ny}});\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "\\t//simple brute force solution with priority queues.\\n\\tint swimInWater(vector<vector<int>>& heights) \\n    {\\n        int n=heights.size();\\n        int m=heights[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        \\n        int ans=max(heights[0][0],heights[n-1][m-1]);\\n        \\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        \\n        pq.push({-ans,{0,0}});\\n        vector<int> dir(5,0);\\n        \\n        dir[0]=-1;\\n        dir[4]=-1;\\n        dir[2]=1;\\n        int eff,x,y,nx,ny;\\n        \\n        while(!pq.empty())\\n        {\\n            eff = -pq.top().first;\\n            x = pq.top().second.first;\\n            y = pq.top().second.second;\\n            pq.pop();\\n            \\n            ans = max(ans,eff);\\n            if(x==n-1 && y==m-1)\\n                return ans;\\n            \\n            for(int i=0;i<4;i++)\\n            {\\n                nx=x+dir[i];\\n                ny=y+dir[i+1];\\n                \\n                if(nx<0 || ny<0 || nx>=n || ny>=m)\\n                    continue;\\n                \\n                if(vis[nx][ny])\\n                    continue;\\n                \\n                vis[nx][ny]=true;\\n                pq.push({-heights[nx][ny],{nx,ny}});\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2384040,
                "title": "very-simple-and-easy-to-understand-c-solution-using-dfs-binary-search",
                "content": "<b> UP vote if you like the solution\\n```\\n/*\\nTrick is to find a path to the end node with visiting nodes that has minimum of max value.\\nTo do so we need to consider each grid value as the max possible value and check if \\ncan reach to end by considering this value as heighest possible value and other node\\nwith value more than it will be treated as obstacles.\\nThis trailing and checking can be optimized by using binary search for the max value.\\n*/\\n\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n    bool dfs(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i, int j, int obstacle){\\n        int n = grid.size()-1;\\n        if(i == n && j == n) return true;\\n        if(grid[i][j] > obstacle) return false;\\n        vis[i][j] = false;\\n        for(int d = 0; d < 4; d++){\\n            int x = i + dir[d][0], y = j + dir[d][1];\\n            if(x >= 0 && y >= 0 && x <= n && y <= n && grid[x][y] <= obstacle && vis[x][y]){\\n                if(dfs(grid, vis, x, y, obstacle)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        int start = 0, end = n*n - 1, mid;\\n        while(start <= end){\\n            mid = start + (end - start)/2;\\n            vector<vector<bool>> vis(n, vector<bool> (n, 1));\\n            if(dfs(grid, vis, 0, 0, mid)){  ans = mid; end = mid - 1; }\\n            else start = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\nTrick is to find a path to the end node with visiting nodes that has minimum of max value.\\nTo do so we need to consider each grid value as the max possible value and check if \\ncan reach to end by considering this value as heighest possible value and other node\\nwith value more than it will be treated as obstacles.\\nThis trailing and checking can be optimized by using binary search for the max value.\\n*/\\n\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n    bool dfs(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i, int j, int obstacle){\\n        int n = grid.size()-1;\\n        if(i == n && j == n) return true;\\n        if(grid[i][j] > obstacle) return false;\\n        vis[i][j] = false;\\n        for(int d = 0; d < 4; d++){\\n            int x = i + dir[d][0], y = j + dir[d][1];\\n            if(x >= 0 && y >= 0 && x <= n && y <= n && grid[x][y] <= obstacle && vis[x][y]){\\n                if(dfs(grid, vis, x, y, obstacle)) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        int start = 0, end = n*n - 1, mid;\\n        while(start <= end){\\n            mid = start + (end - start)/2;\\n            vector<vector<bool>> vis(n, vector<bool> (n, 1));\\n            if(dfs(grid, vis, 0, 0, mid)){  ans = mid; end = mid - 1; }\\n            else start = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373120,
                "title": "90-tc-and-67-sc-easy-python-solution",
                "content": "```\\ndef swimInWater(self, grid: List[List[int]]) -> int:\\n\\tn = len(grid)\\n\\theap = [(grid[0][0], [0, 0])]\\n\\tvis = {(0, 0)}\\n\\tans = 0\\n\\twhile(True):\\n\\t\\tht, [i, j] = heappop(heap)\\n\\t\\tans = max(ans, ht)\\n\\t\\tif(i == j == n-1):\\n\\t\\t\\treturn ans\\n\\t\\tfor x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n\\t\\t\\tif(0<=i+x<n and 0<=j+y<n and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tvis.add((i+x, j+y))\\n\\t\\t\\t\\theappush(heap, (grid[i+x][j+y], [i+x, j+y]))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef swimInWater(self, grid: List[List[int]]) -> int:\\n\\tn = len(grid)\\n\\theap = [(grid[0][0], [0, 0])]\\n\\tvis = {(0, 0)}\\n\\tans = 0\\n\\twhile(True):\\n\\t\\tht, [i, j] = heappop(heap)\\n\\t\\tans = max(ans, ht)\\n\\t\\tif(i == j == n-1):\\n\\t\\t\\treturn ans\\n\\t\\tfor x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n\\t\\t\\tif(0<=i+x<n and 0<=j+y<n and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tvis.add((i+x, j+y))\\n\\t\\t\\t\\theappush(heap, (grid[i+x][j+y], [i+x, j+y]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2368649,
                "title": "dijkstra-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    #define vi vector<int>\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        priority_queue<vi,vector<vi>,greater<vi>> pq;\\n        vector<vector<bool>> seen(n,vector<bool>(n,false));\\n        pq.push({grid[0][0],0,0});\\n        seen[0][0] = true;\\n        while(!pq.empty()){\\n            auto v = pq.top();\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int x = v[1] + dx[i];\\n                int y = v[2] + dy[i];\\n                if(x<0 || y<0 || x>=n || y>=n)\\n                    continue;\\n                if(seen[x][y])\\n                    continue;\\n                \\n                if(x == n-1 and y == n-1)\\n                    return max(grid[n-1][n-1],v[0]);\\n                \\n                seen[x][y] = true;\\n                int n_max = max(v[0],grid[x][y]);\\n                pq.push({n_max,x,y});\\n            }\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2366109,
                "title": "o-n-2-time-space-beats-99-43",
                "content": "On day `t`, try to reach the cell having the value `t` through one of it\\'s adjecent neibours (check if any neibour is already reached), if possible, run a DFS starting from the cell with value `t` that goes to all unvisited cells having a value less than `t`. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int gridY[2500];\\n    int gridX[2500];\\n    vector<vector<int>> grid;\\n    int n,t;\\n    \\n    bool reachableFromStart[50][50]{};\\n    \\n    bool isReachableFromStart(int y, int x){\\n        if(y>=n || x>=n || x<0 || y<0) return false;\\n        return reachableFromStart[y][x];\\n    }\\n    \\n    bool getIsAnyNeibourReachableFromStart(int y, int x){\\n        if(y==0 && x==0)return true;\\n        \\n        return \\n            isReachableFromStart(y,x+1)||\\n            isReachableFromStart(y,x-1)||\\n            isReachableFromStart(y+1,x)||\\n            isReachableFromStart(y-1,x);\\n    }\\n    \\n    void dfs(int y, int x){\\n        if(x<0||y<0||y>=n||x>=n)return;\\n        if(reachableFromStart[y][x]) return;\\n        if(grid[y][x]>t) return;\\n        \\n        reachableFromStart[y][x] = true;\\n        \\n        dfs(y,x+1);\\n        dfs(y,x-1);\\n        dfs(y+1,x);\\n        dfs(y-1,x);\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& _grid) {\\n        grid = _grid;\\n        n = grid.size();\\n        \\n        for(int y=0; y<n; y++)for(int x=0; x<n;x++){\\n            gridY[grid[y][x]] = y;\\n            gridX[grid[y][x]] = x;\\n        }\\n        \\n        for(t=0; t<n*n; t++){\\n            if(getIsAnyNeibourReachableFromStart(gridY[t], gridX[t])){\\n                dfs(gridY[t], gridX[t]);\\n            }\\n            if(reachableFromStart[n-1][n-1]) return t;\\n        }\\n        \\n        return 42;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int gridY[2500];\\n    int gridX[2500];\\n    vector<vector<int>> grid;\\n    int n,t;\\n    \\n    bool reachableFromStart[50][50]{};\\n    \\n    bool isReachableFromStart(int y, int x){\\n        if(y>=n || x>=n || x<0 || y<0) return false;\\n        return reachableFromStart[y][x];\\n    }\\n    \\n    bool getIsAnyNeibourReachableFromStart(int y, int x){\\n        if(y==0 && x==0)return true;\\n        \\n        return \\n            isReachableFromStart(y,x+1)||\\n            isReachableFromStart(y,x-1)||\\n            isReachableFromStart(y+1,x)||\\n            isReachableFromStart(y-1,x);\\n    }\\n    \\n    void dfs(int y, int x){\\n        if(x<0||y<0||y>=n||x>=n)return;\\n        if(reachableFromStart[y][x]) return;\\n        if(grid[y][x]>t) return;\\n        \\n        reachableFromStart[y][x] = true;\\n        \\n        dfs(y,x+1);\\n        dfs(y,x-1);\\n        dfs(y+1,x);\\n        dfs(y-1,x);\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& _grid) {\\n        grid = _grid;\\n        n = grid.size();\\n        \\n        for(int y=0; y<n; y++)for(int x=0; x<n;x++){\\n            gridY[grid[y][x]] = y;\\n            gridX[grid[y][x]] = x;\\n        }\\n        \\n        for(t=0; t<n*n; t++){\\n            if(getIsAnyNeibourReachableFromStart(gridY[t], gridX[t])){\\n                dfs(gridY[t], gridX[t]);\\n            }\\n            if(reachableFromStart[n-1][n-1]) return t;\\n        }\\n        \\n        return 42;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341762,
                "title": "c-binary-search-dfs",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool visited[51][51];\\n    int row[4]={-1,0,0,1};\\n    int col[4]={0,-1,1,0};\\n    bool inside(int nr,int nc,int n){\\n        return nr>=0&&nr<n&&nc>=0&&nc<n;\\n    }\\n    void dfs(vector<vector<int>>&grid,int r,int c,int n,int mid){\\n        if(grid[r][c]>mid) return;\\n        visited[r][c]=true;\\n        for(int i=0;i<4;i++){\\n            int nr=r+row[i];\\n            int nc=c+col[i];\\n            if(inside(nr,nc,n)&&!visited[nr][nc]&&grid[nr][nc]<=mid) dfs(grid,nr,nc,n,mid);\\n        }\\n    }\\n    bool ok(vector<vector<int>>&grid,int n,int mid){\\n        memset(visited,false,sizeof(visited));\\n        dfs(grid,0,0,n,mid);\\n        if(visited[n-1][n-1]) return true;\\n        return false;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int minn=2501,maxx=-1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                maxx=max(maxx,grid[i][j]);\\n                minn=min(minn,grid[i][j]);\\n            }\\n        }\\n        int low=minn;\\n        int high=maxx;\\n        int mid,ans;\\n        while(low<=high){\\n            mid=low+(high-low)/2;\\n            if(ok(grid,n,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool visited[51][51];\\n    int row[4]={-1,0,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2331375,
                "title": "778-swim-in-rising-water-c-accepted-solution-o-n-2lgn",
                "content": "```\\nclass Solution {\\npublic:\\n    //min_pq={msf,{i,j}}\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<bool>> visited(n,vector<bool>(n,false));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({grid[0][0],{0,0}});\\n        \\n        vector<pair<int,int>> dir={{-1,0},{1,0},{0,-1},{0,1}};\\n        \\n        while(!pq.empty()){\\n            auto rem=pq.top();\\n            pq.pop();\\n            \\n            int msf=rem.first;\\n            int row=rem.second.first;\\n            int col=rem.second.second;\\n            if(row==n-1 && col==n-1)\\n                return msf;\\n            \\n            if(!visited[row][col]){\\n                visited[row][col]=true;\\n                for(int i=0;i<4;i++){\\n                    int new_row=row+dir[i].first;\\n                    int new_col=col+dir[i].second;\\n                    if(new_row>=0 && new_row<n && new_col>=0 && new_col<n && !visited[new_row][new_col]){\\n                        pq.push({max(msf,grid[new_row][new_col]),{new_row,new_col}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //min_pq={msf,{i,j}}\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<bool>> visited(n,vector<bool>(n,false));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({grid[0][0],{0,0}});\\n        \\n        vector<pair<int,int>> dir={{-1,0},{1,0},{0,-1},{0,1}};\\n        \\n        while(!pq.empty()){\\n            auto rem=pq.top();\\n            pq.pop();\\n            \\n            int msf=rem.first;\\n            int row=rem.second.first;\\n            int col=rem.second.second;\\n            if(row==n-1 && col==n-1)\\n                return msf;\\n            \\n            if(!visited[row][col]){\\n                visited[row][col]=true;\\n                for(int i=0;i<4;i++){\\n                    int new_row=row+dir[i].first;\\n                    int new_col=col+dir[i].second;\\n                    if(new_row>=0 && new_row<n && new_col>=0 && new_col<n && !visited[new_row][new_col]){\\n                        pq.push({max(msf,grid[new_row][new_col]),{new_row,new_col}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278851,
                "title": "dijkastra-using-set-n2logn-complexity",
                "content": "using sets , in which we explore every position where the element can go from (i,j) position and then choosing the one which is the best option that is having the minimum value and in order u visit every point only once we mark it with grid[i][j]=-1 something like this so that we r not visiting it again.\\n```\\n int isvalid(int x,int y,vector<vector<int>>& grid){\\n        if(x<0){\\n            return 0;\\n        }\\n        if(y<0){\\n            return 0;\\n        }\\n        if(x>=grid.size()){\\n            return 0;\\n        }\\n        if(y>=grid.size()){\\n            return 0;\\n        }\\n        if(grid[x][y]==-1){\\n            return 0;\\n        }\\n        return 1;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        \\n        int i;\\n        int n=grid.size();\\n        set<pair<int,pair<int,int> >> s;\\n        int ans=grid[0][0];\\n        s.insert(make_pair(grid[0][0],make_pair(0,0)));\\n        while(s.empty()!=1){\\n            pair<int,pair<int,int> > d=*(s.begin());\\n            s.erase(s.begin());\\n            pair<int,int> c=d.second;\\n            ans=max(ans,grid[c.first][c.second]);\\n            if(c.first==n-1&&c.second==n-1){\\n                            \\n                return ans;\\n            }\\n          if(isvalid(c.first+1,c.second,grid)==1){\\n            \\n                  s.insert(make_pair(grid[c.first+1][c.second],make_pair(c.first+1,c.second)));\\n              \\n          }\\n            if(isvalid(c.first-1,c.second,grid)==1){\\n                \\n                   s.insert(make_pair(grid[c.first-1][c.second],make_pair(c.first-1,c.second)));\\n                \\n            }\\n            if(isvalid(c.first,c.second+1,grid)==1){\\n               \\n                   s.insert(make_pair(grid[c.first][c.second+1],make_pair(c.first,c.second+1)));\\n                \\n            }\\n            if(isvalid(c.first,c.second-1,grid)==1){\\n                \\n                   s.insert(make_pair(grid[c.first][c.second-1],make_pair(c.first,c.second-1)));\\n                \\n            }\\n            grid[c.first][c.second]=-1;\\n            \\n               \\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int isvalid(int x,int y,vector<vector<int>>& grid){\\n        if(x<0){\\n            return 0;\\n        }\\n        if(y<0){\\n            return 0;\\n        }\\n        if(x>=grid.size()){\\n            return 0;\\n        }\\n        if(y>=grid.size()){\\n            return 0;\\n        }\\n        if(grid[x][y]==-1){\\n            return 0;\\n        }\\n        return 1;\\n    }\\n    int swimInWater(vector<vector<int>>& grid) {\\n        \\n        int i;\\n        int n=grid.size();\\n        set<pair<int,pair<int,int> >> s;\\n        int ans=grid[0][0];\\n        s.insert(make_pair(grid[0][0],make_pair(0,0)));\\n        while(s.empty()!=1){\\n            pair<int,pair<int,int> > d=*(s.begin());\\n            s.erase(s.begin());\\n            pair<int,int> c=d.second;\\n            ans=max(ans,grid[c.first][c.second]);\\n            if(c.first==n-1&&c.second==n-1){\\n                            \\n                return ans;\\n            }\\n          if(isvalid(c.first+1,c.second,grid)==1){\\n            \\n                  s.insert(make_pair(grid[c.first+1][c.second],make_pair(c.first+1,c.second)));\\n              \\n          }\\n            if(isvalid(c.first-1,c.second,grid)==1){\\n                \\n                   s.insert(make_pair(grid[c.first-1][c.second],make_pair(c.first-1,c.second)));\\n                \\n            }\\n            if(isvalid(c.first,c.second+1,grid)==1){\\n               \\n                   s.insert(make_pair(grid[c.first][c.second+1],make_pair(c.first,c.second+1)));\\n                \\n            }\\n            if(isvalid(c.first,c.second-1,grid)==1){\\n                \\n                   s.insert(make_pair(grid[c.first][c.second-1],make_pair(c.first,c.second-1)));\\n                \\n            }\\n            grid[c.first][c.second]=-1;\\n            \\n               \\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2255836,
                "title": "min-priority-queue-dijkstra-algorithm-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> pq;\\n        pq.push({grid[0][0],0,0});\\n        while(pq.size()){\\n            auto [val, i, j] = pq.top(); pq.pop();\\n            \\n            ans = max(ans,val);\\n            \\n            if(i == grid.size()-1 and j == grid[0].size()-1) break;\\n            \\n            grid[i][j] = -1;\\n            \\n            if(i-1 >= 0 and grid[i-1][j] != -1) pq.push({grid[i-1][j],i-1,j});\\n            if(j-1 >= 0 and grid[i][j-1] != -1) pq.push({grid[i][j-1],i,j-1});\\n            if(i+1 < grid.size() and grid[i+1][j] != -1) pq.push({grid[i+1][j],i+1,j});\\n            if(j+1 < grid[0].size() and grid[i][j+1] != -1) pq.push({grid[i][j+1],i,j+1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> pq;\\n        pq.push({grid[0][0],0,0});\\n        while(pq.size()){\\n            auto [val, i, j] = pq.top(); pq.pop();\\n            \\n            ans = max(ans,val);\\n            \\n            if(i == grid.size()-1 and j == grid[0].size()-1) break;\\n            \\n            grid[i][j] = -1;\\n            \\n            if(i-1 >= 0 and grid[i-1][j] != -1) pq.push({grid[i-1][j],i-1,j});\\n            if(j-1 >= 0 and grid[i][j-1] != -1) pq.push({grid[i][j-1],i,j-1});\\n            if(i+1 < grid.size() and grid[i+1][j] != -1) pq.push({grid[i+1][j],i+1,j});\\n            if(j+1 < grid[0].size() and grid[i][j+1] != -1) pq.push({grid[i][j+1],i,j+1});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213289,
                "title": "easy-min-heap-priority-queue-bfs-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n     int n=grid.size();\\n     //creat a min heap   \\n     priority_queue<pair<int, pair<int, int>>, vector< pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n    // a vis array to keep record of visited indexes\\n    vector<vector<bool>>vis(n,vector<bool>(n,false));\\n    pq.push({grid[0][0],{0,0}});\\n    vis[0][0]=true;\\n    int ans=grid[0][0];\\n    \\n    while(!pq.empty())\\n    {\\n        //min value is on front from all directions to take it\\n        int value=pq.top().first;\\n        int i=pq.top().second.first;\\n        int j=pq.top().second.second;\\n        pq.pop();\\n        //now we want the max stoppage\\n        ans=max(ans,value);\\n        \\n        //base case\\n        if(i==n-1 and j==n-1)\\n        {\\n            break;\\n        }\\n        int dx[4]={0,1,0,-1};\\n        int dy[4]={1,0,-1,0};\\n        \\n        for(int idx=0;idx<4;idx++)\\n        {\\n            int newi=i+dx[idx];\\n            int newj=j+dy[idx];\\n            \\n            if(newi>=0 and newi<n and newj>=0 and newj<n and !vis[newi][newj])\\n            {\\n                vis[newi][newj]=true; \\n                //put all direction element in min heap which are not visited\\n                pq.push({grid[newi][newj],{newi,newj}});\\n            }\\n        }\\n        \\n    }\\n    \\n    return ans;  \\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n     int n=grid.size();\\n     //creat a min heap   \\n     priority_queue<pair<int, pair<int, int>>, vector< pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n    // a vis array to keep record of visited indexes\\n    vector<vector<bool>>vis(n,vector<bool>(n,false));\\n    pq.push({grid[0][0],{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2191366,
                "title": "djikstra-cpp-solution",
                "content": "```\\nint dx[4] = { -1,\\n    1,\\n    0,\\n    0\\n};\\nint dy[4] = { 0,\\n    0,\\n    1,\\n    -1\\n};\\n\\nclass Solution\\n{\\n    public:\\n        int swimInWater(vector<vector < int>> &A)\\n        {\\n\\n            int n = A.size();\\n            int m = A[0].size();\\n\\n            priority_queue<vector < int>, vector< vector< int >>, greater<vector< int>>> pq;\\n\\n            int dis[n][m];\\n            for (int i = 0; i < n; ++i)\\n            {\\n                for (int j = 0; j < m; ++j)\\n                {\\n                    dis[i][j] = 1e7;\\n                }\\n            }\\n\\n            dis[0][0] = max(0,A[0][0]);\\n\\n            pq.push({ dis[0][0],\\n                0,\\n                0 });\\n\\n            while (pq.size())\\n            {\\n                auto a = pq.top();\\n                pq.pop();\\n                int x = a[1];\\n                int y = a[2];\\n                int d = a[0];\\n\\n                for (int i = 0; i < 4; ++i)\\n                {\\n                    int x1 = x + dx[i];\\n                    int y1 = y + dy[i];\\n\\n                    if (x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && dis[x1][y1] > dis[x][y] + max(0, A[x1][y1] - dis[x][y]))\\n                    {\\n                        dis[x1][y1] = dis[x][y] + max(0, A[x1][y1] - dis[x][y]);\\n                        pq.push({ dis[x1][y1],\\n                            x1,\\n                            y1 });\\n                    }\\n                }\\n            }\\n            return dis[n - 1][m - 1];\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dx[4] = { -1,\\n    1,\\n    0,\\n    0\\n};\\nint dy[4] = { 0,\\n    0,\\n    1,\\n    -1\\n};\\n\\nclass Solution\\n{\\n    public:\\n        int swimInWater(vector<vector < int>> &A)\\n        {\\n\\n            int n = A.size();\\n            int m = A[0].size();\\n\\n            priority_queue<vector < int>, vector< vector< int >>, greater<vector< int>>> pq;\\n\\n            int dis[n][m];\\n            for (int i = 0; i < n; ++i)\\n            {\\n                for (int j = 0; j < m; ++j)\\n                {\\n                    dis[i][j] = 1e7;\\n                }\\n            }\\n\\n            dis[0][0] = max(0,A[0][0]);\\n\\n            pq.push({ dis[0][0],\\n                0,\\n                0 });\\n\\n            while (pq.size())\\n            {\\n                auto a = pq.top();\\n                pq.pop();\\n                int x = a[1];\\n                int y = a[2];\\n                int d = a[0];\\n\\n                for (int i = 0; i < 4; ++i)\\n                {\\n                    int x1 = x + dx[i];\\n                    int y1 = y + dy[i];\\n\\n                    if (x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && dis[x1][y1] > dis[x][y] + max(0, A[x1][y1] - dis[x][y]))\\n                    {\\n                        dis[x1][y1] = dis[x][y] + max(0, A[x1][y1] - dis[x][y]);\\n                        pq.push({ dis[x1][y1],\\n                            x1,\\n                            y1 });\\n                    }\\n                }\\n            }\\n            return dis[n - 1][m - 1];\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179806,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\nprivate:\\n    typedef pair<int, pair<int, int>> pi;\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        set<pair<int, int>> visit;        \\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        pq.push({grid[0][0], {0, 0}});\\n        visit.insert({0, 0});\\n        \\n        vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        \\n        while (!pq.empty())\\n        {\\n            int t = pq.top().first, r = pq.top().second.first, c = pq.top().second.second; pq.pop();\\n            if (r == n - 1 && c == n - 1)\\n            {\\n                return t;\\n            }\\n            for (const auto& d : dirs)\\n            {\\n                int i = r + d[0], j = c + d[1];\\n                if (i < 0 || j < 0 || i >= n || j >= n || (visit.find({i, j}) != visit.end()))\\n                {\\n                    continue;\\n                }\\n                visit.insert({i, j});\\n                pq.push({max(t, grid[i][j]), {i, j}});                    \\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    typedef pair<int, pair<int, int>> pi;\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        set<pair<int, int>> visit;        \\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        pq.push({grid[0][0], {0, 0}});\\n        visit.insert({0, 0});\\n        \\n        vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        \\n        while (!pq.empty())\\n        {\\n            int t = pq.top().first, r = pq.top().second.first, c = pq.top().second.second; pq.pop();\\n            if (r == n - 1 && c == n - 1)\\n            {\\n                return t;\\n            }\\n            for (const auto& d : dirs)\\n            {\\n                int i = r + d[0], j = c + d[1];\\n                if (i < 0 || j < 0 || i >= n || j >= n || (visit.find({i, j}) != visit.end()))\\n                {\\n                    continue;\\n                }\\n                visit.insert({i, j});\\n                pq.push({max(t, grid[i][j]), {i, j}});                    \\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176107,
                "title": "javascript-greedy-min-heap-77-time-60-space",
                "content": "```\\nvar swimInWater = function(grid) {\\n    const dir = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    const heap = new MinPriorityQueue({compare: (a, b) => a.depth - b.depth});\\n    heap.enqueue({row: 0, col: 0, depth: grid[0][0], maxDepth: grid[0][0]})\\n    \\n    let visited = new Set();\\n    while (heap.size()) {\\n        let {row, col, maxDepth} = heap.dequeue();\\n        visited.add(`${row}-${col}`);\\n        if (row === grid.length - 1 && col === grid.length - 1) return maxDepth;\\n        for (let [r, c] of dir) {\\n            let newR = row + r, newC = col + c;\\n            if (visited.has(`${newR}-${newC}`)) continue;\\n            if (newR < 0 || newC < 0 || newR >= grid.length || newC >= grid[0].length) continue;\\n            heap.enqueue({row: newR, col: newC, depth: grid[newR][newC], maxDepth: Math.max(maxDepth, grid[newR][newC])});\\n        }\\n    }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar swimInWater = function(grid) {\\n    const dir = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    const heap = new MinPriorityQueue({compare: (a, b) => a.depth - b.depth});\\n    heap.enqueue({row: 0, col: 0, depth: grid[0][0], maxDepth: grid[0][0]})\\n    \\n    let visited = new Set();\\n    while (heap.size()) {\\n        let {row, col, maxDepth} = heap.dequeue();\\n        visited.add(`${row}-${col}`);\\n        if (row === grid.length - 1 && col === grid.length - 1) return maxDepth;\\n        for (let [r, c] of dir) {\\n            let newR = row + r, newC = col + c;\\n            if (visited.has(`${newR}-${newC}`)) continue;\\n            if (newR < 0 || newC < 0 || newR >= grid.length || newC >= grid[0].length) continue;\\n            heap.enqueue({row: newR, col: newC, depth: grid[newR][newC], maxDepth: Math.max(maxDepth, grid[newR][newC])});\\n        }\\n    }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2175670,
                "title": "c-priority-queue-djikstara-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4][2]={{1,0},{0,1},{0,-1},{-1,0}}; //4-directions\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>>dis(n,vector<int>(n,INT_MAX));\\n        if(n==1)return 0;\\n        priority_queue<pair<int,pair<int,int>>>Q; //max heap (greatest element at the top)\\n        Q.push({-grid[0][0],{0,0}}); \\n        int ans=0;\\n        while(Q.size()>0){\\n            int t = -Q.top().first;   //pushing negative values beacause we want the smallest next neighbour\\n\\t\\t\\t//could\\'ve used a min-heap or a custom comparator based heap but this much more subtle and elegant\\n            int x = Q.top().second.first;\\n            int y = Q.top().second.second;\\n            Q.pop();\\n            for(int i=0;i<4;i++){\\n                int xx = x+dx[i][0];\\n                int yy = y+dx[i][1];\\n                if(xx<n and yy<n and xx>-1 and yy>-1){\\n                    int time = max(t , grid[xx][yy]); //time elapsed till reaching this cell \\n                    if(dis[xx][yy] > time){ //if the current value is more than the new time then replace\\n                        dis[xx][yy]=time;\\n                        Q.push({-dis[xx][yy],{xx,yy}}); \\n                    }\\n                }\\n            }\\n        }\\n        return dis[n-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4][2]={{1,0},{0,1},{0,-1},{-1,0}}; //4-directions\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>>dis(n,vector<int>(n,INT_MAX));\\n        if(n==1)return 0;\\n        priority_queue<pair<int,pair<int,int>>>Q; //max heap (greatest element at the top)\\n        Q.push({-grid[0][0],{0,0}}); \\n        int ans=0;\\n        while(Q.size()>0){\\n            int t = -Q.top().first;   //pushing negative values beacause we want the smallest next neighbour\\n\\t\\t\\t//could\\'ve used a min-heap or a custom comparator based heap but this much more subtle and elegant\\n            int x = Q.top().second.first;\\n            int y = Q.top().second.second;\\n            Q.pop();\\n            for(int i=0;i<4;i++){\\n                int xx = x+dx[i][0];\\n                int yy = y+dx[i][1];\\n                if(xx<n and yy<n and xx>-1 and yy>-1){\\n                    int time = max(t , grid[xx][yy]); //time elapsed till reaching this cell \\n                    if(dis[xx][yy] > time){ //if the current value is more than the new time then replace\\n                        dis[xx][yy]=time;\\n                        Q.push({-dis[xx][yy],{xx,yy}}); \\n                    }\\n                }\\n            }\\n        }\\n        return dis[n-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162704,
                "title": "swim-in-rising-water-java-dijkstra-not-hard",
                "content": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        \\n        int n=grid.length;\\n        \\n        int [][]dir={{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        \\n        pq.add(new Pair(0,0,grid[0][0]));\\n        \\n        while(!pq.isEmpty()){\\n            \\n            Pair curr=pq.remove();\\n            \\n            if(curr.i==n-1 && curr.j==n-1){\\n                int ans=Math.max(curr.max,grid[n-1][n-1]);\\n                return ans;\\n            }\\n            \\n            if(grid[curr.i][curr.j]==-1){\\n                continue;\\n            }\\n            \\n            grid[curr.i][curr.j]=-1;\\n            \\n            for(int []d:dir){\\n                int r=curr.i+d[0];\\n                int c=curr.j+d[1];\\n                \\n                if(r<0 || r>=n || c<0 || c>=n || grid[r][c]==-1){\\n                    continue;\\n                }\\n                \\n                int maxAdd=Math.max(grid[r][c],curr.max);\\n                pq.add(new Pair(r,c,maxAdd));\\n            }\\n        }\\n        \\n        return grid[n-1][n-1];\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    int i;\\n    int j;\\n    int max;\\n    \\n    public Pair(int i, int j, int max){\\n        this.i=i;\\n        this.j=j;\\n        this.max=max;\\n    }\\n    \\n    public int compareTo(Pair o){\\n        return this.max-o.max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        \\n        int n=grid.length;\\n        \\n        int [][]dir={{-1,0},{1,0},{0,1},{0,-1}};\\n        \\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n        \\n        pq.add(new Pair(0,0,grid[0][0]));\\n        \\n        while(!pq.isEmpty()){\\n            \\n            Pair curr=pq.remove();\\n            \\n            if(curr.i==n-1 && curr.j==n-1){\\n                int ans=Math.max(curr.max,grid[n-1][n-1]);\\n                return ans;\\n            }\\n            \\n            if(grid[curr.i][curr.j]==-1){\\n                continue;\\n            }\\n            \\n            grid[curr.i][curr.j]=-1;\\n            \\n            for(int []d:dir){\\n                int r=curr.i+d[0];\\n                int c=curr.j+d[1];\\n                \\n                if(r<0 || r>=n || c<0 || c>=n || grid[r][c]==-1){\\n                    continue;\\n                }\\n                \\n                int maxAdd=Math.max(grid[r][c],curr.max);\\n                pq.add(new Pair(r,c,maxAdd));\\n            }\\n        }\\n        \\n        return grid[n-1][n-1];\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    int i;\\n    int j;\\n    int max;\\n    \\n    public Pair(int i, int j, int max){\\n        this.i=i;\\n        this.j=j;\\n        this.max=max;\\n    }\\n    \\n    public int compareTo(Pair o){\\n        return this.max-o.max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156277,
                "title": "easy-and-simple-bfs",
                "content": "class Solution {\\npublic:\\n\\n    int dr[4]={1,-1,0,0};\\n    int dc[4]={0,0,-1,1};\\n    int n, m;\\n    bool isvalid(int i,int j){return (i>=0&&j>=0&&i<n&&j<m);}\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int ans=0;\\n        n=grid.size();\\n        m=n;\\n        int dp [51][51]={0},vis[51][51]={0};\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;\\n        q.push({grid[0][0],0,0});\\n        while(!q.empty()){\\n            vector<int>v=q.top();\\n            int w=v[0],x=v[1],y=v[2];\\n            q.pop();\\n            ans=max(ans,w);\\n            if(x==n-1&&y==n-1)return ans;\\n            vis[x][y]=1;\\n            for(int k=0;k<4;k++){\\n                int tx=x+dr[k];\\n                int ty=y+dc[k];\\n                if(isvalid(tx,ty)&&!vis[tx][ty]){\\n                    vis[tx][ty]=1;\\n                    q.push({grid[tx][ty],tx,ty});\\n                }\\n            }\\n        }\\n        return ans;    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int dr[4]={1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2092608,
                "title": "dijekstra-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<pair<int,int>>  dir{{-1,0},{1,0},{0,1},{0,-1}};\\n         \\n        //initialise dist and pq for DIJEKSTRA ALGORITHM\\n        vector<vector<int>>  dist(n,vector<int>(n,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>> ,vector<pair<int,pair<int,int>>> , greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({grid[0][0],{0,0}});\\n        dist[0][0]=grid[0][0];\\n        \\n        while(!pq.empty()){\\n            \\n            //extract closest node\\n            auto c=pq.top(); pq.pop();\\n            int cdist=c.first;\\n            int cx=c.second.first;\\n            int cy=c.second.second;\\n            if(cx==n-1&&cy==n-1) return cdist;\\n            \\n            //for all neighbours of closest node update cost\\n            for(auto [dx,dy] :dir){\\n                \\n                if(cx+dx>=0&&cx+dx<n&&cy+dy>=0&&cy+dy<n){\\n                    \\n                    int ndist=max( cdist, grid[cx+dx][cy+dy] );\\n                    \\n                    if(ndist<dist[cx+dx][cy+dy] ){\\n                        \\n                        dist[cx+dx][cy+dy]=ndist;\\n                        pq.push({dist[cx+dx][cy+dy],{cx+dx,cy+dy}});\\n                    }\\n                }\\n            }\\n             \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<pair<int,int>>  dir{{-1,0},{1,0},{0,1},{0,-1}};\\n         \\n        //initialise dist and pq for DIJEKSTRA ALGORITHM\\n        vector<vector<int>>  dist(n,vector<int>(n,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>> ,vector<pair<int,pair<int,int>>> , greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({grid[0][0],{0,0}});\\n        dist[0][0]=grid[0][0];\\n        \\n        while(!pq.empty()){\\n            \\n            //extract closest node\\n            auto c=pq.top(); pq.pop();\\n            int cdist=c.first;\\n            int cx=c.second.first;\\n            int cy=c.second.second;\\n            if(cx==n-1&&cy==n-1) return cdist;\\n            \\n            //for all neighbours of closest node update cost\\n            for(auto [dx,dy] :dir){\\n                \\n                if(cx+dx>=0&&cx+dx<n&&cy+dy>=0&&cy+dy<n){\\n                    \\n                    int ndist=max( cdist, grid[cx+dx][cy+dy] );\\n                    \\n                    if(ndist<dist[cx+dx][cy+dy] ){\\n                        \\n                        dist[cx+dx][cy+dy]=ndist;\\n                        pq.push({dist[cx+dx][cy+dy],{cx+dx,cy+dy}});\\n                    }\\n                }\\n            }\\n             \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080712,
                "title": "c-bfs-priority-queue-beats-100",
                "content": "```\\nint swimInWater(vector<vector<int>>& grid) {\\n        //find smallest from all adjacent points, move there, \\n        // maximum of minimum path\\n        // maximum value is answer\\n        // use bfs, priority queue\\n        vector<int>dx {1,-1,0,0};\\n        vector<int>dy {0,0,1,-1};\\n        \\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int, pair<int,int>>>, greater<pair<int, pair<int,int>>> > pq;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n        \\n        pq.push(make_pair(grid[0][0], make_pair(0,0)));\\n        \\n        int maxValue = grid[0][0];\\n        grid[0][0] = 1;\\n        while(!pq.empty())\\n        {\\n            auto itr = pq.top();\\n            pq.pop();\\n            int value = itr.first;\\n            maxValue = max(maxValue, value);\\n            int x = itr.second.first;\\n            int y = itr.second.second;\\n            \\n            if(x == n-1 && y == m-1)\\n                return maxValue;\\n            for(int i=0;i<4;i++)\\n            {\\n                int newX =  x+ dx[i];\\n                int newY =  y+ dy[i];\\n                if(newX >=0 && newX <=n-1 && newY>=0 && newY<=m-1 && visited[newX][newY] == 0)\\n                {\\n                    visited[newX][newY] = 1;\\n                    pq.push(make_pair(grid[newX][newY], make_pair(newX,newY)));\\n                }\\n            }\\n            \\n            \\n        }\\n        return maxValue;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint swimInWater(vector<vector<int>>& grid) {\\n        //find smallest from all adjacent points, move there, \\n        // maximum of minimum path\\n        // maximum value is answer\\n        // use bfs, priority queue\\n        vector<int>dx {1,-1,0,0};\\n        vector<int>dy {0,0,1,-1};\\n        \\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int, pair<int,int>>>, greater<pair<int, pair<int,int>>> > pq;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n        \\n        pq.push(make_pair(grid[0][0], make_pair(0,0)));\\n        \\n        int maxValue = grid[0][0];\\n        grid[0][0] = 1;\\n        while(!pq.empty())\\n        {\\n            auto itr = pq.top();\\n            pq.pop();\\n            int value = itr.first;\\n            maxValue = max(maxValue, value);\\n            int x = itr.second.first;\\n            int y = itr.second.second;\\n            \\n            if(x == n-1 && y == m-1)\\n                return maxValue;\\n            for(int i=0;i<4;i++)\\n            {\\n                int newX =  x+ dx[i];\\n                int newY =  y+ dy[i];\\n                if(newX >=0 && newX <=n-1 && newY>=0 && newY<=m-1 && visited[newX][newY] == 0)\\n                {\\n                    visited[newX][newY] = 1;\\n                    pq.push(make_pair(grid[newX][newY], make_pair(newX,newY)));\\n                }\\n            }\\n            \\n            \\n        }\\n        return maxValue;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057378,
                "title": "the-correctness-of-the-heap-approach",
                "content": "The Leetcode official solution one itself is a great solution with barely any explanation. It took me a long time to understand that heap-based solution. Therefore I share my understanding below and hope it can help somebody. \\n\\nThe intuition behind this approach is not clear (at least to me). I felt like it is not a very intuitive approach. (whoever came up with this approach is a genius.) I can only prove the correctness of it. \\n\\nSuppose we have input as follows.\\n![image](https://assets.leetcode.com/users/images/4bc4d3a3-71ce-4f19-a56b-b26b21cea0a1_1653041941.7291894.png)\\n\\nUsing the logic in the official solution 1, we will first pull the top-left element out from the min-heap. Let us color it green in the graph to signify that it has already been pulled out from the min-heap. \\n![image](https://assets.leetcode.com/users/images/4f378a2c-9578-4956-8568-8b599e52b917_1653042157.362994.png)\\n\\nAs we pull out this `0`, we would add its neighbors` 2` and `28` into the min-heap. As a result, our min-heap will look like this.\\n```\\nmin_heap = [(2, 0, 1), (28, 1, 0)]\\nans = 0\\n# The distance from top-left to `0` is 0.\\n```\\n\\nNext, we will pull out `2` since it is the smallest value in the heap.\\n![image](https://assets.leetcode.com/users/images/7efdc486-ff5a-4431-a23a-20f4dcac9a83_1653042402.1805983.png)\\n\\nWe also add its neighbors `29` and `31` into the heap.\\n```\\nmin_heap = [(28, 1, 0), (29, 0, 2), (31, 1, 1)]\\nans = 2\\n# The distance from top-left to `2` is 2.\\n```\\n\\nWe use the same logic to pull elements out of the heap one by one. I will not show them in detail, but you get the idea. \\n>(1)\\n\\n![image](https://assets.leetcode.com/users/images/9a4cf4a2-cc2a-43a8-87e6-1e67ea01ad4a_1653042650.1108682.png)\\n```\\nmin_heap = [(19, 2, 0), (29, 0, 2), (31, 1, 1)]\\nans = 28\\n# The distance from top-left to `28` is 28.\\n```\\n\\n>(2)\\n\\n![image](https://assets.leetcode.com/users/images/7326d6cc-439c-44e0-8cb8-5c60c2234083_1653042776.2892425.png)\\n```\\nmin_heap = [(16, 2, 1), (29, 0, 2), (31, 1, 1)]\\nans = 28\\n# The distance from top-left to `19` is 28.\\n```\\n\\n>(3)\\n![image](https://assets.leetcode.com/users/images/fac70243-bca6-4941-b7e7-9256a91ea600_1653043011.9242618.png)\\n```\\nmin_heap = [(13, 2, 2), (29, 0, 2), (31, 1, 1)]\\nans = 28\\n# The distance from top-left to `16` is 28.\\n```\\n\\n>(4)\\n\\n![image](https://assets.leetcode.com/users/images/f969aeef-6182-48d3-b33e-33027060da1a_1653043097.6198225.png)\\n```\\nmin_heap = [(14, 1, 2), (29, 0, 2), (31, 1, 1)]\\nans = 28\\n# The distance from top-left to `13` is 28.\\n```\\n\\n>(5)\\n\\n![image](https://assets.leetcode.com/users/images/c5eb5396-1f93-497a-841b-b7e13d0fe297_1653043216.451552.png)\\n```\\nmin_heap = [(29, 0, 2), (31, 1, 1)]\\nans = 28\\n# The distance from top-left to `14` is 28.\\n```\\n\\n>(6)\\n\\n![image](https://assets.leetcode.com/users/images/568544e1-1ef3-4f7a-ad75-d195b2fd1b75_1653043277.735894.png)\\n```\\nmin_heap = [(31, 1, 1)]\\nans = 29\\n# The distance from top-left to `29` is 29.\\n```\\n\\n>(7)\\n\\n![image](https://assets.leetcode.com/users/images/0e8476c3-2a7a-4101-a326-73e2cfdf1e2f_1653043329.2019446.png)\\n```\\nmin_heap = []\\nans = 31\\n# The distance from top-left to `31` is 31.\\n```\\n\\nOur algorithm terminates after step (7) since the heap became empty. We can make two important observations during these steps.\\n* There are many paths (consisting of 4 directionally adjacent elements) connecting the top-left element to another element in the graph. For example, if we want to go to `14` from the top left `0`, we can go `0 -> 2 -> 29 -> 14`, we can also go `0 -> 2 -> 31 -> 16 -> 13 -> 14`. We can have a lot of different choices.\\n* When an element is pulled out from the min-heap, there is a `pulled-out` path that connects this element to the top-left element. All elements in this path are alrealy pulled out. For example, when `31` is pulled out from the priority queue, its `pulled-out` path is `0 -> 2 -> 31`. When `14` is pulled out, its `pulled-out` path is `0 -> 28 -> 19 -> 16 -> 13 -> 14`. You can verify this by looking at the graphs shown above. To prove this is always true, we observe that when an element is pulled out from the priority queue, say `14` (step (5)), it must connect to an already pulled out element. In this case, it is `13`. `14` is in the min-heap because of the already pulled out element `13`. When `13` was pulled out from the min-heap, it added `14` into the min-heap. Using the same logic, we can conclude that there must be a `pulled-out` path that connects the top-left element with a pulled-out element. \\n\\nHaving these two observations, we can begin to verify the correctness of the algorithm. In the code, we see that when an element is pulled out from the min-heap, its distance to the top left `0` is:\\n\\n```\\nd, r, c = heapq.heappop(pq)\\nans = max(ans, d)\\n```\\n\\nWhen we pull the bottom-right element out of the min-heap, its distance is `ans = max(ans, d)`. We then return this`ans` as our final answer. \\n\\nNow the main concern is: is this `ans` always true for all elements in the grid? If it is, then this algorithm is correct. If we can prove that this distance measure is always true for all elements in the grid, we have proved the correctness of the algorithm. Now, let\\'s prove this.\\n\\nWe can easily see that there are two cases: ```d <= ans```, and ```d > ans```. We will discuss these two cases separately below.\\n\\n> Case 1: ```d <= ans```.\\n\\nWhen ```d <= ans```, the distance is determined by `ans`. Let\\'s use element `14` in the above graph as an example. Running the algorithm, we will get `28` as the distance to the element `14`. We can easily verify this is the correct answer. We can also see that the element `28` is pulled out before this `14`. Therefore, we can make the following observations.\\n\\n* All paths that connect `14` to the top-left `0` must have at least a value which is `>= 28`. In other words, for each path that connects `14` to the top-left `0`, there must be an element in that path that has the value `>= 28`. Why? Imagine there is a path containing no values `>= 28`. All values in that path are `< 28`. Then running the algorithm, we must pull this `14` before `28`, since the min-heap always pops the smallest element. The algorithm will find this path and pop all elements are `<= 28` before pop `28`. \\n* When we pulled `14` out of the min-heap. All values in its `pulled-out` path must be `<= 28`. Since the `ans` is monotonically nondecreasing, this `ans` must contain the maximal value we have ever pulled out. \\n\\nCombining the above two observations, we can conclude that:\\n* `28` is in the `pulled-out` path of `14`. The elements in this `pulled-out` path are all \\'<= 28\\'.\\n*  Other paths connecting `14` with top-left `0` must have at least a value `>= 28` in the path.\\n\\nTherefore, we can see that `28` is the correct distance for this `14`.\\n\\n>Case 2: ```d > ans```.\\n\\nWhen ```d > ans```, we know that all elements previously been pulled out must have values `<= ans`. Therefore we can conclude that all paths connecting top-left `0` to the currently pulled-out element have distance at most `ans`. At the same time, the value of this currently pulled-out element is `> ans`. We can easily conclude that ```ans = max(ans, d)``` yields the correct distance for the current element.\\n\\n> Why we can\\'t add a same element into the min-heap more than once?\\n\\nYou might noticed that in the code, the author used a `seen` set to prevent we add a same element into the min-heap more than once. The reason is that if we are allowed to do so, the correctness of the algorithm breaks. We would add a same element into the heap again and again and again. In the end, all elements in the grid might have the distance which equals to the largest value in the grid. Even worse, the algorithm will never stops running. It will run forever.\\n\\n> Implementation\\n\\nThe following implementation is identical to the official solution 1. I just renamed some variables to make them more readable. \\n\\n```\\n# O(n^2 log(n)) time | O(n^2) space, where n is the length of the `grid`.\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        seen = {(0, 0)}\\n        heap = [(grid[0][0], 0, 0)]\\n        ans = 0\\n        n = len(grid)\\n        \\n        while heap:\\n            distance, row, col = heapq.heappop(heap)\\n            ans = max(ans, distance)\\n            if row == n - 1 and col == n - 1:\\n                return ans\\n            \\n            for new_row, new_col in ((row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)):\\n                if 0 <= new_row < n and 0 <= new_col < n and (new_row, new_col) not in seen:\\n                    heapq.heappush(heap, (grid[new_row][new_col], new_row, new_col))\\n                    seen.add((new_row, new_col))\\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nmin_heap = [(2, 0, 1), (28, 1, 0)]\\nans = 0\\n# The distance from top-left to `0` is 0.\\n```\n```\\nmin_heap = [(28, 1, 0), (29, 0, 2), (31, 1, 1)]\\nans = 2\\n# The distance from top-left to `2` is 2.\\n```\n```\\nmin_heap = [(19, 2, 0), (29, 0, 2), (31, 1, 1)]\\nans = 28\\n# The distance from top-left to `28` is 28.\\n```\n```\\nmin_heap = [(16, 2, 1), (29, 0, 2), (31, 1, 1)]\\nans = 28\\n# The distance from top-left to `19` is 28.\\n```\n```\\nmin_heap = [(13, 2, 2), (29, 0, 2), (31, 1, 1)]\\nans = 28\\n# The distance from top-left to `16` is 28.\\n```\n```\\nmin_heap = [(14, 1, 2), (29, 0, 2), (31, 1, 1)]\\nans = 28\\n# The distance from top-left to `13` is 28.\\n```\n```\\nmin_heap = [(29, 0, 2), (31, 1, 1)]\\nans = 28\\n# The distance from top-left to `14` is 28.\\n```\n```\\nmin_heap = [(31, 1, 1)]\\nans = 29\\n# The distance from top-left to `29` is 29.\\n```\n```\\nmin_heap = []\\nans = 31\\n# The distance from top-left to `31` is 31.\\n```\n```\\nd, r, c = heapq.heappop(pq)\\nans = max(ans, d)\\n```\n```d <= ans```\n```d > ans```\n```d <= ans```\n```d <= ans```\n```d > ans```\n```d > ans```\n```ans = max(ans, d)```\n```\\n# O(n^2 log(n)) time | O(n^2) space, where n is the length of the `grid`.\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        seen = {(0, 0)}\\n        heap = [(grid[0][0], 0, 0)]\\n        ans = 0\\n        n = len(grid)\\n        \\n        while heap:\\n            distance, row, col = heapq.heappop(heap)\\n            ans = max(ans, distance)\\n            if row == n - 1 and col == n - 1:\\n                return ans\\n            \\n            for new_row, new_col in ((row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)):\\n                if 0 <= new_row < n and 0 <= new_col < n and (new_row, new_col) not in seen:\\n                    heapq.heappush(heap, (grid[new_row][new_col], new_row, new_col))\\n                    seen.add((new_row, new_col))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998179,
                "title": "bfs-priority-queue-c",
                "content": "So basically my approach is to keep track of minimum value of time. For this i have used priority queue of min heap showing {time, {xposition, yposition}}. Insert initially {grid[0][0], {0,0}} to start the bfs and then traverse in its 4 directions. Keep on inserting them and build one visited matrix to keep track of visited and unvisited positions.\\n`class Solution {\\npublic:\\n    \\n    int row[4]={1,-1,0,0};\\n    int col[4]={0,0,1,-1};\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        \\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({grid[0][0],{0,0}});\\n        int mx=0, m=grid.size(), n=grid[0].size();\\n        \\n        vector<vector<bool>> vec(m,vector<bool> (n,false));\\n        int t, x, y;\\n        while(!pq.empty()) {\\n            \\n            auto it = pq.top();\\n            t = it.first;\\n            x = it.second.first;\\n            y = it.second.second;\\n            vec[x][y]=true;\\n            \\n            pq.pop();\\n            mx=max(mx,t);\\n            \\n            if(x==m-1 && y==n-1)\\n                break;\\n            \\n            for(int i=0;i<4;i++) {\\n                int rr = x + row[i];\\n                int cc = y + col[i];\\n                \\n                if(rr>=0 && cc>=0 && rr<m && cc<n && !vec[rr][cc])\\n                    pq.push({grid[rr][cc], {rr,cc}});\\n            }\\n        }\\n        return mx;\\n    }\\n};`",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int row[4]={1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1964540,
                "title": "java-simple-binary-search-dfs-o-n-n-log-maxtime",
                "content": "For the example given, any value beyond 3 will allow you to reach (N-1, N-1) and any value below 3 will not. Using this simple inference, we can binary search over 0 and max value possible and find the first value which is true for our predicate.\\nPredicate here is, is time sufficient to reach (N-1, N-1) or not\\n\\n```\\nclass Solution {\\n    int N;\\n    \\n    int[][] dirs = new int[][] { {-1,0}, {0,-1}, {1,0}, {0,1} };\\n    \\n    public int swimInWater(int[][] grid) {\\n        N = grid.length;\\n        \\n        int lo = 0;\\n        int hi = 2501;\\n        \\n        while(lo<hi) {\\n            \\n            int mid = lo + (hi-lo)/2;\\n            boolean[][] visited = new boolean[N][N];\\n            if(dfs(0,0,mid, visited, grid)) {\\n                hi=mid;\\n            } else{\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n    \\n    \\n    boolean dfs(int i, int j, int value, boolean[][] visited, int[][] grid) {\\n        \\n        if(i==N-1 && j==N-1) return true;\\n        if(visited[i][j]) return false;\\n        \\n        visited[i][j] = true;\\n        \\n        boolean ans = false;\\n        for(int[] dir: dirs){\\n            int x = dir[0] + i;\\n            int y = dir[1] + j;\\n            \\n            if(x>=0 && x<N && y>=0 && y<N && grid[i][j]<=value && grid[x][y] <= value) {\\n                ans = ans || dfs(x, y, value, visited, grid);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int N;\\n    \\n    int[][] dirs = new int[][] { {-1,0}, {0,-1}, {1,0}, {0,1} };\\n    \\n    public int swimInWater(int[][] grid) {\\n        N = grid.length;\\n        \\n        int lo = 0;\\n        int hi = 2501;\\n        \\n        while(lo<hi) {\\n            \\n            int mid = lo + (hi-lo)/2;\\n            boolean[][] visited = new boolean[N][N];\\n            if(dfs(0,0,mid, visited, grid)) {\\n                hi=mid;\\n            } else{\\n                lo = mid+1;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n    \\n    \\n    boolean dfs(int i, int j, int value, boolean[][] visited, int[][] grid) {\\n        \\n        if(i==N-1 && j==N-1) return true;\\n        if(visited[i][j]) return false;\\n        \\n        visited[i][j] = true;\\n        \\n        boolean ans = false;\\n        for(int[] dir: dirs){\\n            int x = dir[0] + i;\\n            int y = dir[1] + j;\\n            \\n            if(x>=0 && x<N && y>=0 && y<N && grid[i][j]<=value && grid[x][y] <= value) {\\n                ans = ans || dfs(x, y, value, visited, grid);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957845,
                "title": "java-dijkstra-ez2-understand",
                "content": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n=grid.length,m=grid[0].length;\\n        PriorityQueue<Vertex> queue=new PriorityQueue<>((x1,x2)->x1.height-x2.height);\\n        queue.add(new Vertex(0,0,grid[0][0]));\\n        while(true){\\n            Vertex temp=queue.poll();\\n            if(temp.i==n-1 && temp.j==m-1)\\n                return temp.height;\\n            else{\\n                addToQueue(temp,grid,queue);\\n            }\\n        }\\n        \\n    }\\n    void addToQueue(Vertex temp,int[][] grid,PriorityQueue<Vertex> queue){\\n        int i=temp.i,j=temp.j,n=grid.length,m=grid[0].length;\\n        //add up\\n        if(i-1>=0 && grid[i-1][j]!=-1){\\n            queue.add(new Vertex(i-1,j,Math.max(grid[i-1][j],temp.height)));\\n            grid[i-1][j]=-1;\\n        } \\n        //add down\\n        if(i+1<n && grid[i+1][j]!=-1){\\n            queue.add(new Vertex(i+1,j,Math.max(grid[i+1][j],temp.height)));\\n            grid[i+1][j]=-1;\\n        } \\n        //add left\\n        if(j-1>=0 && grid[i][j-1]!=-1){\\n            queue.add(new Vertex(i,j-1,Math.max(grid[i][j-1],temp.height)));\\n            grid[i][j-1]=-1;\\n        } \\n        //add right\\n        if(j+1<m && grid[i][j+1]!=-1){\\n            queue.add(new Vertex(i,j+1,Math.max(grid[i][j+1],temp.height)));\\n            grid[i][j+1]=-1;\\n        }\\n\\n    }\\n    class Vertex{\\n        int i;\\n        int j;\\n        int height;\\n        Vertex(int i,int j,int height){\\n            this.i=i;\\n            this.j=j;\\n            this.height=height;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n=grid.length,m=grid[0].length;\\n        PriorityQueue<Vertex> queue=new PriorityQueue<>((x1,x2)->x1.height-x2.height);\\n        queue.add(new Vertex(0,0,grid[0][0]));\\n        while(true){\\n            Vertex temp=queue.poll();\\n            if(temp.i==n-1 && temp.j==m-1)\\n                return temp.height;\\n            else{\\n                addToQueue(temp,grid,queue);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1880504,
                "title": "java-priority-queue-based-solution",
                "content": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n = grid.length;\\n        Queue<int[]> queue = new PriorityQueue<>((a,b) -> a[2]-b[2]); //Min heap\\n        boolean[][] vis = new boolean[n][n];\\n        int[] dirs = new int[]{1,0,-1,0,1};  // helper array to visit 4 adjacent neighbours\\n        int res = Integer.MIN_VALUE;\\n        \\n        queue.offer(new int[]{0,0,grid[0][0]});  //starting with the (0,0) index\\n        vis[0][0]=true;\\n        \\n        //using the idea from Dijkstra\\'s Algorithm\\n        //Traverse till you either get to the last destination or till queue is empty which will never         be the case\\n        while(!queue.isEmpty()){\\n            int[] edge = queue.poll();\\n            res = Math.max(res,edge[2]);\\n            for(int i = 0 ; i < 4 ; i++){\\n                int x = edge[0] + dirs[i];\\n                int y = edge[1] + dirs[i+1];\\n                if(x<0 || y<0 || x>=n || y>=n || vis[x][y]) continue;//check if youre moving out of grid\\n                if(x == n-1 && y == n-1) return Math.max(res,grid[x][y]);\\n                vis[x][y] = true;\\n                queue.offer(new int[]{x,y,grid[x][y]});\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```\\n\\nThe solution is simple as we are using Priority queue to greedily select only those indices which has the smallest cost . However we have to keep track of  the max in the path we are travelling , and that will be our answer . \\n\\nPlease feel free to comment if you have any doubt and Please UPVOTE if you like it . \\n\\nThankyou,\\nHave a great day.",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n = grid.length;\\n        Queue<int[]> queue = new PriorityQueue<>((a,b) -> a[2]-b[2]); //Min heap\\n        boolean[][] vis = new boolean[n][n];\\n        int[] dirs = new int[]{1,0,-1,0,1};  // helper array to visit 4 adjacent neighbours\\n        int res = Integer.MIN_VALUE;\\n        \\n        queue.offer(new int[]{0,0,grid[0][0]});  //starting with the (0,0) index\\n        vis[0][0]=true;\\n        \\n        //using the idea from Dijkstra\\'s Algorithm\\n        //Traverse till you either get to the last destination or till queue is empty which will never         be the case\\n        while(!queue.isEmpty()){\\n            int[] edge = queue.poll();\\n            res = Math.max(res,edge[2]);\\n            for(int i = 0 ; i < 4 ; i++){\\n                int x = edge[0] + dirs[i];\\n                int y = edge[1] + dirs[i+1];\\n                if(x<0 || y<0 || x>=n || y>=n || vis[x][y]) continue;//check if youre moving out of grid\\n                if(x == n-1 && y == n-1) return Math.max(res,grid[x][y]);\\n                vis[x][y] = true;\\n                queue.offer(new int[]{x,y,grid[x][y]});\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821444,
                "title": "c-easy-solution-using-bfs-priority-queue",
                "content": "**TIME COMPLEXITY : O(N^2log(N))\\nSPACE COMPLEXITY : O(N^2)**\\n\\n **Please UPVOTE if you like this Solution**\\n```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid){\\n        \\n        // BFS IS SUITABLE FOR THIS QUESTION\\n        if(grid.size() == 1)\\n            return grid[0][0];\\n        \\n        int n = grid.size();\\n        vector<vector<int>> vis(n, vector<int>(n, 0));\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minH;\\n        \\n        int ans = max(grid[0][0], grid[n-1][n-1]);\\n        minH.push({ans, 0, 0});\\n        vis[0][0] = 1;\\n        \\n        int dx[4] = {-1,1,0,0};\\n        int dy[4] = {0,0,-1,1};\\n        \\n        while(!minH.empty()){\\n            auto curr = minH.top();\\n            ans = max(ans, curr[0]);\\n            minH.pop();\\n            \\n            for(int i=0 ; i<4 ; i++){\\n                int nx = curr[1] + dx[i];\\n                int ny = curr[2] + dy[i];\\n                    \\n                if(nx<0 || ny<0 || nx>=n || ny>=n || vis[nx][ny] != 0)\\n                    continue;\\n                if(nx == n-1 && ny == n-1)\\n                    return ans;\\n                \\n                minH.push({grid[nx][ny], nx, ny});\\n                vis[nx][ny] = 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid){\\n        \\n        // BFS IS SUITABLE FOR THIS QUESTION\\n        if(grid.size() == 1)\\n            return grid[0][0];\\n        \\n        int n = grid.size();\\n        vector<vector<int>> vis(n, vector<int>(n, 0));\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minH;\\n        \\n        int ans = max(grid[0][0], grid[n-1][n-1]);\\n        minH.push({ans, 0, 0});\\n        vis[0][0] = 1;\\n        \\n        int dx[4] = {-1,1,0,0};\\n        int dy[4] = {0,0,-1,1};\\n        \\n        while(!minH.empty()){\\n            auto curr = minH.top();\\n            ans = max(ans, curr[0]);\\n            minH.pop();\\n            \\n            for(int i=0 ; i<4 ; i++){\\n                int nx = curr[1] + dx[i];\\n                int ny = curr[2] + dy[i];\\n                    \\n                if(nx<0 || ny<0 || nx>=n || ny>=n || vis[nx][ny] != 0)\\n                    continue;\\n                if(nx == n-1 && ny == n-1)\\n                    return ans;\\n                \\n                minH.push({grid[nx][ny], nx, ny});\\n                vis[nx][ny] = 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808506,
                "title": "c-cleanest-priority-queue-solution",
                "content": "```\\nclass Cell                                                                  {\\npublic :\\n    int x, y, elevation                                                     ;\\n    Cell(int x, int y, int elevation)                                       {\\n        this->x = x                                                         ;\\n        this->y = y                                                         ;\\n        this->elevation = elevation                                         ;\\n                                                                            }};\\nstruct comp                                                                 {\\n  bool operator()(Cell a, Cell b)                                           {\\n      return (a.elevation > b.elevation)                                    ;\\n                                                                            }  };\\nbool isValidCell(int i, int j, int n){\\n    return (i >= 0 and i < n and j >= 0 and j < n)                          ;\\n                                                                            }              \\nclass Solution                                                              {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid)                              {\\n        int n = grid.size()                                                 ;\\n        priority_queue<Cell, vector<Cell>, comp> pq                         ;\\n        pq.push(Cell(0, 0, grid[0][0]))                                     ;\\n        int direction[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}            ;\\n        bool visited[n][n]; memset(visited, false, sizeof(visited))         ;\\n        int time = 0                                                        ;\\n        visited[0][0] = true                                                ;\\n        while(true)                                                         {\\n            auto curr = pq.top(); pq.pop()                                  ;\\n            time = max(time, curr.elevation)                                ;\\n            if(curr.x == (n-1) and curr.y == (n-1)) return time             ;\\n            for(auto d : direction)                                         {\\n                int i = curr.x + d[0]                                       ;\\n                int j = curr.y + d[1]                                       ;\\n                if(isValidCell(i,j,n) and (!visited[i][j]))                 {\\n                    visited[i][j] = true                                    ;\\n                    pq.push(Cell(i, j, grid[i][j]))                         ;}}}}\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Cell                                                                  {\\npublic :\\n    int x, y, elevation                                                     ;\\n    Cell(int x, int y, int elevation)                                       {\\n        this->x = x                                                         ;\\n        this->y = y                                                         ;\\n        this->elevation = elevation                                         ;\\n                                                                            }};\\nstruct comp                                                                 {\\n  bool operator()(Cell a, Cell b)                                           {\\n      return (a.elevation > b.elevation)                                    ;\\n                                                                            }  };\\nbool isValidCell(int i, int j, int n){\\n    return (i >= 0 and i < n and j >= 0 and j < n)                          ;\\n                                                                            }              \\nclass Solution                                                              {\\npublic:\\n    int swimInWater(vector<vector<int>>& grid)                              {\\n        int n = grid.size()                                                 ;\\n        priority_queue<Cell, vector<Cell>, comp> pq                         ;\\n        pq.push(Cell(0, 0, grid[0][0]))                                     ;\\n        int direction[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}            ;\\n        bool visited[n][n]; memset(visited, false, sizeof(visited))         ;\\n        int time = 0                                                        ;\\n        visited[0][0] = true                                                ;\\n        while(true)                                                         {\\n            auto curr = pq.top(); pq.pop()                                  ;\\n            time = max(time, curr.elevation)                                ;\\n            if(curr.x == (n-1) and curr.y == (n-1)) return time             ;\\n            for(auto d : direction)                                         {\\n                int i = curr.x + d[0]                                       ;\\n                int j = curr.y + d[1]                                       ;\\n                if(isValidCell(i,j,n) and (!visited[i][j]))                 {\\n                    visited[i][j] = true                                    ;\\n                    pq.push(Cell(i, j, grid[i][j]))                         ;}}}}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739695,
                "title": "python-easy-to-understand-djikstras",
                "content": "```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        minheap = [(grid[0][0], 0, 0)]\\n        visited = [[False for _ in range(n)] for _ in range(n)]\\n        visited[0][0] = True\\n\\n        while minheap:\\n            maxht, x, y = heapq.heappop(minheap)\\n            #print(maxht, x, y)\\n            if x == n-1 and y == n-1:\\n                return maxht\\n            if x > 0 and visited[x-1][y] == False:\\n                visited[x-1][y] = True\\n                heapq.heappush(minheap, (max(maxht, grid[x-1][y]), x-1, y))\\n            if y > 0 and visited[x][y-1] == False:\\n                visited[x][y-1] = True\\n                heapq.heappush(minheap, (max(maxht, grid[x][y-1]), x, y-1))\\n            if x < n-1 and visited[x+1][y] == False:\\n                visited[x+1][y] = True\\n                heapq.heappush(minheap, (max(maxht, grid[x+1][y]), x+1, y))\\n            if y < n-1 and visited[x][y+1] == False:\\n                visited[x][y+1] = True\\n                heapq.heappush(minheap, (max(maxht, grid[x][y+1]), x, y+1))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        minheap = [(grid[0][0], 0, 0)]\\n        visited = [[False for _ in range(n)] for _ in range(n)]\\n        visited[0][0] = True\\n\\n        while minheap:\\n            maxht, x, y = heapq.heappop(minheap)\\n            #print(maxht, x, y)\\n            if x == n-1 and y == n-1:\\n                return maxht\\n            if x > 0 and visited[x-1][y] == False:\\n                visited[x-1][y] = True\\n                heapq.heappush(minheap, (max(maxht, grid[x-1][y]), x-1, y))\\n            if y > 0 and visited[x][y-1] == False:\\n                visited[x][y-1] = True\\n                heapq.heappush(minheap, (max(maxht, grid[x][y-1]), x, y-1))\\n            if x < n-1 and visited[x+1][y] == False:\\n                visited[x+1][y] = True\\n                heapq.heappush(minheap, (max(maxht, grid[x+1][y]), x+1, y))\\n            if y < n-1 and visited[x][y+1] == False:\\n                visited[x][y+1] = True\\n                heapq.heappush(minheap, (max(maxht, grid[x][y+1]), x, y+1))",
                "codeTag": "Java"
            },
            {
                "id": 1701918,
                "title": "c-solution-using-priority-queue-path-with-minimum-maximum-value",
                "content": "class Solution {\\npublic:\\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,-1,1};\\n    #define pipii pair<int,pair<int,int>>\\n    struct cmp{\\n        bool operator()(pipii p1, pipii p2){\\n            return p1.first > p2.first;\\n        }\\n    };\\n    int swimInWater(vector<vector<int>>& grid) {\\n\\n        int m = grid.size(), n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int>(n, 0));\\n\\n        priority_queue<pipii, vector<pipii>, cmp> pq;\\n\\n        pq.push({grid[0][0],{0,0}});\\n\\n        int ans = INT_MIN;\\n\\n        while(!pq.empty()){\\n\\n            int currval = pq.top().first, x = pq.top().second.first, y = pq.top().second.second;\\n            pq.pop();\\n\\n            ans = max(ans, currval);\\n\\n            if(x == m - 1 && y == n - 1){\\n                return ans;\\n            }\\n\\n            for(int i = 0; i < 4; i++){\\n                int xo = x + dx[i], yo = y + dy[i];\\n                if(xo >= 0 && yo >= 0 && xo < m && yo < n){\\n                    if(vis[xo][yo] == 0){\\n                        vis[xo][yo] = 1;\\n                        pq.push({grid[xo][yo],{xo,yo}});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int dx[4] = {-1,1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1639014,
                "title": "java-easy-and-clean-solution-dijkstra",
                "content": "```\\nclass Solution {\\n    public class Pair implements Comparable<Pair>{\\n        int i;\\n        int j;\\n        int wt;\\n        Pair(int i, int j, int wt){\\n            this.i = i;\\n            this.j = j;\\n            this.wt = wt;\\n        }\\n        public int compareTo(Pair o){\\n            return this.wt - o.wt;\\n        }\\n    }\\n    \\n    public int swimInWater(int[][] grid) {\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.add(new Pair(0, 0, grid[0][0]));\\n        int ans = 0;\\n        while(pq.size() > 0){\\n            Pair rem = pq.remove();\\n            if(vis[rem.i][rem.j])\\n                continue;\\n            vis[rem.i][rem.j] = true;\\n            if(rem.wt > ans)\\n                ans = rem.wt;\\n            if(rem.i == grid.length - 1 && rem.j == grid[0].length - 1)\\n                return ans;\\n            if(rem.i - 1 >= 0)\\n                pq.add(new Pair(rem.i - 1, rem.j, grid[rem.i - 1][rem.j]));\\n            if(rem.i + 1 < grid.length)\\n                pq.add(new Pair(rem.i + 1, rem.j, grid[rem.i + 1][rem.j]));\\n            if(rem.j - 1 >= 0)\\n                pq.add(new Pair(rem.i, rem.j - 1, grid[rem.i][rem.j - 1]));\\n            if(rem.j + 1 < grid[0].length)\\n                pq.add(new Pair(rem.i, rem.j + 1, grid[rem.i][rem.j + 1]));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair implements Comparable<Pair>{\\n        int i;\\n        int j;\\n        int wt;\\n        Pair(int i, int j, int wt){\\n            this.i = i;\\n            this.j = j;\\n            this.wt = wt;\\n        }\\n        public int compareTo(Pair o){\\n            return this.wt - o.wt;\\n        }\\n    }\\n    \\n    public int swimInWater(int[][] grid) {\\n        boolean[][] vis = new boolean[grid.length][grid[0].length];\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.add(new Pair(0, 0, grid[0][0]));\\n        int ans = 0;\\n        while(pq.size() > 0){\\n            Pair rem = pq.remove();\\n            if(vis[rem.i][rem.j])\\n                continue;\\n            vis[rem.i][rem.j] = true;\\n            if(rem.wt > ans)\\n                ans = rem.wt;\\n            if(rem.i == grid.length - 1 && rem.j == grid[0].length - 1)\\n                return ans;\\n            if(rem.i - 1 >= 0)\\n                pq.add(new Pair(rem.i - 1, rem.j, grid[rem.i - 1][rem.j]));\\n            if(rem.i + 1 < grid.length)\\n                pq.add(new Pair(rem.i + 1, rem.j, grid[rem.i + 1][rem.j]));\\n            if(rem.j - 1 >= 0)\\n                pq.add(new Pair(rem.i, rem.j - 1, grid[rem.i][rem.j - 1]));\\n            if(rem.j + 1 < grid[0].length)\\n                pq.add(new Pair(rem.i, rem.j + 1, grid[rem.i][rem.j + 1]));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621747,
                "title": "c-bfs-priority-queue-o-n-2logn-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool isValid(int index, int lim){\\n        return index >= 0 && index < lim;\\n    }\\n    \\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        priority_queue<pair<int, pair<int, int>>> pq;\\n        pq.push({(-1)*grid[0][0], {0, 0}});\\n        grid[0][0] = -grid[0][0];\\n        \\n        int dx[4] = {-1, 0, 0, 1};\\n        int dy[4] = {0, -1, 1, 0};\\n        \\n        int res = 0;\\n        while(!pq.empty()){\\n            int i = pq.top().second.first;\\n            int j = pq.top().second.second;\\n            int elevation = (-1)*pq.top().first;\\n            pq.pop();\\n            \\n            res = max(res, elevation);\\n            if(i == m-1 && j == n-1) return res;\\n                \\n            for(int k=0; k<4; k++){\\n                int x = i+dx[k];\\n                int y = j+dy[k];\\n                \\n                if(isValid(x, m) && isValid(y, n) && grid[x][y] >= 0){\\n                    pq.push({(-1)*grid[x][y], {x, y}});\\n                    grid[x][y] = -grid[x][y];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(int index, int lim){\\n        return index >= 0 && index < lim;\\n    }\\n    \\npublic:\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        priority_queue<pair<int, pair<int, int>>> pq;\\n        pq.push({(-1)*grid[0][0], {0, 0}});\\n        grid[0][0] = -grid[0][0];\\n        \\n        int dx[4] = {-1, 0, 0, 1};\\n        int dy[4] = {0, -1, 1, 0};\\n        \\n        int res = 0;\\n        while(!pq.empty()){\\n            int i = pq.top().second.first;\\n            int j = pq.top().second.second;\\n            int elevation = (-1)*pq.top().first;\\n            pq.pop();\\n            \\n            res = max(res, elevation);\\n            if(i == m-1 && j == n-1) return res;\\n                \\n            for(int k=0; k<4; k++){\\n                int x = i+dx[k];\\n                int y = j+dy[k];\\n                \\n                if(isValid(x, m) && isValid(y, n) && grid[x][y] >= 0){\\n                    pq.push({(-1)*grid[x][y], {x, y}});\\n                    grid[x][y] = -grid[x][y];\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610720,
                "title": "golang-min-heap-solution",
                "content": "```go\\nfunc swimInWater(grid [][]int) int {\\n\\tstep := make([][]bool, len(grid))\\n\\tfor i := range step {\\n\\t\\tstep[i] = make([]bool, len(grid[0]))\\n\\t}\\n\\tcurrentHeight := grid[0][0]\\n\\tstep[0][0] = true\\n\\th := &Heap{}\\n\\theap.Push(h, []int{0, 0, grid[0][0]})\\n\\tfor {\\n\\t\\telem := heap.Pop(h).([]int)\\n\\t\\t// refresh current height\\n\\t\\tif elem[2] > currentHeight {\\n\\t\\t\\tcurrentHeight = elem[2]\\n\\t\\t}\\n\\t\\t// reached grid[n-1][n-1]\\n\\t\\tif elem[0] == len(grid)-1 && elem[1] == len(grid)-1 {\\n\\t\\t\\treturn currentHeight\\n\\t\\t}\\n\\t\\t// try up\\n\\t\\tif r, c := elem[0] - 1, elem[1]; r >= 0 && step[r][c] == false {\\n\\t\\t\\theap.Push(h, []int{r, c, grid[r][c]})\\n\\t\\t\\tstep[r][c] = true\\n\\t\\t}\\n\\t\\t// try down\\n\\t\\tif r, c := elem[0] + 1, elem[1]; r < len(grid) && step[r][c] == false {\\n\\t\\t\\theap.Push(h, []int{r, c, grid[r][c]})\\n\\t\\t\\tstep[r][c] = true\\n\\t\\t}\\n\\t\\t// try left\\n\\t\\tif r, c := elem[0], elem[1] - 1; c >= 0 && step[r][c] == false {\\n\\t\\t\\theap.Push(h, []int{r, c, grid[r][c]})\\n\\t\\t\\tstep[r][c] = true\\n\\t\\t}\\n\\t\\t// try right\\n\\t\\tif r, c := elem[0], elem[1] + 1; c < len(grid) && step[r][c] == false {\\n\\t\\t\\theap.Push(h, []int{r, c, grid[r][c]})\\n\\t\\t\\tstep[r][c] = true\\n\\t\\t}\\n\\t}\\n}\\n\\ntype Heap [][]int\\n\\nfunc (p Heap) Len() int            { return len(p) }\\nfunc (p Heap) Less(i, j int) bool  { return p[i][2] < p[j][2] }\\nfunc (p Heap) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }\\nfunc (p *Heap) Push(i interface{}) { *p = append(*p, i.([]int)) }\\nfunc (p *Heap) Pop() interface{}   { v := (*p)[len(*p)-1]; *p = (*p)[:len(*p)-1]; return v }\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\nfunc swimInWater(grid [][]int) int {\\n\\tstep := make([][]bool, len(grid))\\n\\tfor i := range step {\\n\\t\\tstep[i] = make([]bool, len(grid[0]))\\n\\t}\\n\\tcurrentHeight := grid[0][0]\\n\\tstep[0][0] = true\\n\\th := &Heap{}\\n\\theap.Push(h, []int{0, 0, grid[0][0]})\\n\\tfor {\\n\\t\\telem := heap.Pop(h).([]int)\\n\\t\\t// refresh current height\\n\\t\\tif elem[2] > currentHeight {\\n\\t\\t\\tcurrentHeight = elem[2]\\n\\t\\t}\\n\\t\\t// reached grid[n-1][n-1]\\n\\t\\tif elem[0] == len(grid)-1 && elem[1] == len(grid)-1 {\\n\\t\\t\\treturn currentHeight\\n\\t\\t}\\n\\t\\t// try up\\n\\t\\tif r, c := elem[0] - 1, elem[1]; r >= 0 && step[r][c] == false {\\n\\t\\t\\theap.Push(h, []int{r, c, grid[r][c]})\\n\\t\\t\\tstep[r][c] = true\\n\\t\\t}\\n\\t\\t// try down\\n\\t\\tif r, c := elem[0] + 1, elem[1]; r < len(grid) && step[r][c] == false {\\n\\t\\t\\theap.Push(h, []int{r, c, grid[r][c]})\\n\\t\\t\\tstep[r][c] = true\\n\\t\\t}\\n\\t\\t// try left\\n\\t\\tif r, c := elem[0], elem[1] - 1; c >= 0 && step[r][c] == false {\\n\\t\\t\\theap.Push(h, []int{r, c, grid[r][c]})\\n\\t\\t\\tstep[r][c] = true\\n\\t\\t}\\n\\t\\t// try right\\n\\t\\tif r, c := elem[0], elem[1] + 1; c < len(grid) && step[r][c] == false {\\n\\t\\t\\theap.Push(h, []int{r, c, grid[r][c]})\\n\\t\\t\\tstep[r][c] = true\\n\\t\\t}\\n\\t}\\n}\\n\\ntype Heap [][]int\\n\\nfunc (p Heap) Len() int            { return len(p) }\\nfunc (p Heap) Less(i, j int) bool  { return p[i][2] < p[j][2] }\\nfunc (p Heap) Swap(i, j int)       { p[i], p[j] = p[j], p[i] }\\nfunc (p *Heap) Push(i interface{}) { *p = append(*p, i.([]int)) }\\nfunc (p *Heap) Pop() interface{}   { v := (*p)[len(*p)-1]; *p = (*p)[:len(*p)-1]; return v }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1565826,
                "title": "hoc5-joy-code-discussion",
                "content": "DFS\\n\\n```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n = 0;\\n        int d = grid.length -1;\\n        if (d == 0) return 0;\\n        while(! reachToEndDFS(grid, 0, 0, \\n                          new boolean[grid.length][grid.length], ++n)) {\\n            \\n        };\\n        return n;\\n    }\\n    \\n    private boolean reachToEndDFS(int[][] grid, int i, int j, boolean[][] lReached, int level) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid.length \\n           || lReached[i][j]) {\\n            return false;\\n        }\\n        lReached[i][j] = true;\\n\\n        if (grid[i][j] <= level) {\\n            if (i == grid.length -1 && j == grid.length -1) {\\n                return true;\\n            }\\n            if (\\n            reachToEndDFS(grid, i -1, j, lReached, level) ||\\n            reachToEndDFS(grid, i, j - 1, lReached, level) ||\\n            reachToEndDFS(grid, i + 1, j , lReached, level) ||\\n            reachToEndDFS(grid, i, j + 1, lReached, level) ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int swimInWater(int[][] grid) {\\n        int n = 0;\\n        int d = grid.length -1;\\n        if (d == 0) return 0;\\n        while(! reachToEndDFS(grid, 0, 0, \\n                          new boolean[grid.length][grid.length], ++n)) {\\n            \\n        };\\n        return n;\\n    }\\n    \\n    private boolean reachToEndDFS(int[][] grid, int i, int j, boolean[][] lReached, int level) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid.length \\n           || lReached[i][j]) {\\n            return false;\\n        }\\n        lReached[i][j] = true;\\n\\n        if (grid[i][j] <= level) {\\n            if (i == grid.length -1 && j == grid.length -1) {\\n                return true;\\n            }\\n            if (\\n            reachToEndDFS(grid, i -1, j, lReached, level) ||\\n            reachToEndDFS(grid, i, j - 1, lReached, level) ||\\n            reachToEndDFS(grid, i + 1, j , lReached, level) ||\\n            reachToEndDFS(grid, i, j + 1, lReached, level) ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504302,
                "title": "c-bfs-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Pair{\\n        int val;int x;int y;\\n        Pair(){}\\n        Pair(int a,int b,int c){\\n            val=a;\\n            x=b;\\n            y=c;\\n        }\\n        \\n    };\\n    struct compare{\\n      bool operator()(const Pair&a,const Pair&b){\\n          return a.val>b.val;\\n      }  \\n    };\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int arr[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\\n        priority_queue<Pair,vector<Pair>,compare>q;\\n        q.push(Pair(grid[0][0],0,0));\\n        int ans=INT_MIN;\\n        vector<vector<bool>>vis(grid.size(),vector<bool>(grid[0].size(),false));\\n        while(q.size()>0){\\n            struct Pair src=q.top();\\n            q.pop();\\n            ans=max(ans,grid[src.x][src.y]);\\n            if(src.x==grid.size()-1&&src.y==grid[0].size()-1){\\n                return ans;\\n            }\\n            if(vis[src.x][src.y]==true){\\n                continue;\\n            }\\n            vis[src.x][src.y]=true;\\n            for(int i=0;i<4;i++)\\n            {\\n                int xdash=src.x+arr[i][0];\\n                int ydash=src.y+arr[i][1];\\n                if(xdash<0||ydash<0||xdash>=grid.size()||ydash>=grid[0].size()||vis[xdash][ydash]){\\n                    continue;\\n                }else{\\n                    q.push(Pair(grid[xdash][ydash],xdash,ydash));\\n                }\\n            }\\n                \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Pair{\\n        int val;int x;int y;\\n        Pair(){}\\n        Pair(int a,int b,int c){\\n            val=a;\\n            x=b;\\n            y=c;\\n        }\\n        \\n    };\\n    struct compare{\\n      bool operator()(const Pair&a,const Pair&b){\\n          return a.val>b.val;\\n      }  \\n    };\\n    int swimInWater(vector<vector<int>>& grid) {\\n        int arr[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\\n        priority_queue<Pair,vector<Pair>,compare>q;\\n        q.push(Pair(grid[0][0],0,0));\\n        int ans=INT_MIN;\\n        vector<vector<bool>>vis(grid.size(),vector<bool>(grid[0].size(),false));\\n        while(q.size()>0){\\n            struct Pair src=q.top();\\n            q.pop();\\n            ans=max(ans,grid[src.x][src.y]);\\n            if(src.x==grid.size()-1&&src.y==grid[0].size()-1){\\n                return ans;\\n            }\\n            if(vis[src.x][src.y]==true){\\n                continue;\\n            }\\n            vis[src.x][src.y]=true;\\n            for(int i=0;i<4;i++)\\n            {\\n                int xdash=src.x+arr[i][0];\\n                int ydash=src.y+arr[i][1];\\n                if(xdash<0||ydash<0||xdash>=grid.size()||ydash>=grid[0].size()||vis[xdash][ydash]){\\n                    continue;\\n                }else{\\n                    q.push(Pair(grid[xdash][ydash],xdash,ydash));\\n                }\\n            }\\n                \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487378,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    struct node {\\n        int x;\\n        int y;\\n        int val;\\n        \\n        node(int _x, int _y, int _val): x(_x), y(_y), val(_val){}\\n    };\\n    \\n    class comparator {\\n        public:\\n            bool operator()(const node& a, const node& b){\\n                return a.val > b.val;\\n            }\\n    };\\n    \\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y, int r, int c){\\n        if(x >= 0 && x < r && y >= 0 && y < c)\\n            return true;\\n        return false;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        priority_queue<node, vector<node>, comparator> pq;\\n        \\n        pq.push(node(0,0,grid[0][0]));\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        while(pq.size() > 0){\\n            auto top = pq.top();\\n            vis[top.x][top.y] = true;\\n            pq.pop();\\n            ans = max(ans, top.val);\\n            if(top.x == r-1 && top.y == c-1)\\n                break;\\n            for(int i=0; i < 4; i++){\\n                int nx = top.x + dx[i];\\n                int ny = top.y + dy[i];\\n                \\n                if(check(nx, ny, r, c) && !vis[nx][ny]){\\n                    pq.push(node(nx, ny, grid[nx][ny]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node {\\n        int x;\\n        int y;\\n        int val;\\n        \\n        node(int _x, int _y, int _val): x(_x), y(_y), val(_val){}\\n    };\\n    \\n    class comparator {\\n        public:\\n            bool operator()(const node& a, const node& b){\\n                return a.val > b.val;\\n            }\\n    };\\n    \\n    int dx[4] = {1, 0, -1, 0};\\n    int dy[4] = {0, 1, 0, -1};\\n    \\n    bool check(int x, int y, int r, int c){\\n        if(x >= 0 && x < r && y >= 0 && y < c)\\n            return true;\\n        return false;\\n    }\\n    \\n    int swimInWater(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        priority_queue<node, vector<node>, comparator> pq;\\n        \\n        pq.push(node(0,0,grid[0][0]));\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        while(pq.size() > 0){\\n            auto top = pq.top();\\n            vis[top.x][top.y] = true;\\n            pq.pop();\\n            ans = max(ans, top.val);\\n            if(top.x == r-1 && top.y == c-1)\\n                break;\\n            for(int i=0; i < 4; i++){\\n                int nx = top.x + dx[i];\\n                int ny = top.y + dy[i];\\n                \\n                if(check(nx, ny, r, c) && !vis[nx][ny]){\\n                    pq.push(node(nx, ny, grid[nx][ny]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564847,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 1947034,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 1941874,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 1570844,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 2016739,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 1969475,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 2062852,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 2061657,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 2051932,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 2046901,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 1564847,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 1947034,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 1941874,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 1570844,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 2016739,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 1969475,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 2062852,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 2061657,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 2051932,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            },
            {
                "id": 2046901,
                "content": [
                    {
                        "username": "ArizonaTea",
                        "content": "\"At time t, the depth of the water everywhere is t.\"\\n\\nWhat does this mean? In my understanding, water flow from higher elevation to lower elevation until no place to go...\\nBut the statment seems to mean the water will be hold at each cell no matter what......"
                    },
                    {
                        "username": "user8699UM",
                        "content": "Bad problem wording. Based on comments in the editorial, it seems like:\\nWhat they really mean is that the surface is flat (elevation 0, \"sea level\", whatever)\\nBut it has holes. position i,j has a hole which is grid[i][j] deep.\\nThe holes slowly fill up 1 unit of height for each unit of time.\\nWhen the hole is full (water level at elevation 0) further water pouring into that cell miraculously disappears.\\n(Not like other problems where you have to track spillover into neighboring cells)\\nTo get \"out of\" and \"into\"\" that hole at time t you need grid[i][j] <= t"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "imagine it as in each step water is fiiling from below in individual cells which have a rigid boundary"
                    },
                    {
                        "username": "shinron4",
                        "content": "If each grid point holds water and as same amount of water falls at each grid point the then after any amount of the time elevation map will remain same so raining will not have any impact. \\n\\nSo I think question phrasing is wrong and you analysis that water will flow from high elevation to low is correct."
                    },
                    {
                        "username": "shubhampawar16298",
                        "content": "Epitome of a garbage description"
                    },
                    {
                        "username": "0x6B0",
                        "content": "I think it\\'s quite clear. We just need to find a path going from top left to bottom right cell in the grid such that the highest value on the path is the smallest possible out of all possible paths. "
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Solve this question after solving \"Path with Minimum Effort\" it\\'ll be very easy then :)"
                    },
                    {
                        "username": "RedHessian",
                        "content": "For real, the code is almost the same. Should be ranked \"medium\" this one."
                    },
                    {
                        "username": "PandaPro",
                        "content": "I would be really appreciate if someone might expalin me why I can\\'t solve it my DP or memoization, I am struggling to come up a solution for it using the same."
                    },
                    {
                        "username": "Blake_Han12",
                        "content": "I second the first reply, just wanna add that when you think in terms of DP, you need to be able to find an optimal substucture, but there's no substructure here as you can get the minimum path from all 4 directions."
                    },
                    {
                        "username": "user1010QP",
                        "content": "because dp needs some clear pattern when moving from in one direciton - here you can\\'t do that since all 4 directions might give you the shortest path. "
                    },
                    {
                        "username": "easwersuthar509",
                        "content": "If anyone having trouble understanding the question :\\nHere we have to find the path which has lowest maximum cell value."
                    },
                    {
                        "username": "Saiteja6",
                        "content": "first try solving path with minimum effort and then do ctrl c+ ctrl v"
                    },
                    {
                        "username": "sattu_supari",
                        "content": "quite similar to Minimum Effort 1631 \\ntest case ->\\n[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49],[50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149],[150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199],[200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249],[250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349],[350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399],[400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449],[450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499],[500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549],[550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599],[600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649],[650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699],[700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749],[750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799],[800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849],[850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899],[900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949],[950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999],[1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049],[1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099],[1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149],[1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199],[1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249],[1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299],[1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349],[1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399],[1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449],[1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499],[1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549],[1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599],[1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649],[1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699],[1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749],[1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799],[1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849],[1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899],[1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949],[1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999],[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049],[2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099],[2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149],[2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199],[2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249],[2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299],[2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349],[2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399],[2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449],[2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499]]\\n"
                    },
                    {
                        "username": "keenborder786",
                        "content": "The real question is finding the path such that maximum value along the path is minimized because you would be able to swim for sure along that path if and only if t has reached the maximum value. Therefore the question becomes classical application of Dijkstra Algorithm."
                    },
                    {
                        "username": "chandleryeh",
                        "content": "binary search is your good friend"
                    },
                    {
                        "username": "sinsaayi",
                        "content": "i guess i am the only one that doesn\\'t understand the problem at all... but once i read the comment: find a path from 0,0 to the bottom right that has the minimum maximum value among all other possible paths.. the problem becomes easy.. "
                    }
                ]
            }
        ]
    }
]