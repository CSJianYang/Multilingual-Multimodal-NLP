[
    {
        "title": "K Radius Subarray Averages",
        "question_content": "You are given a 0-indexed array nums of n integers, and an integer k.\nThe k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1.\nBuild and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i.\nThe average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.\n\n\tFor example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2.\n\n&nbsp;\nExample 1:\n\nInput: nums = [7,4,3,9,1,8,5,2,6], k = 3\nOutput: [-1,-1,-1,5,4,4,-1,-1,-1]\nExplanation:\n- avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.\n- The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.\n  Using integer division, avg[3] = 37 / 7 = 5.\n- For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.\n- For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.\n- avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.\n\nExample 2:\n\nInput: nums = [100000], k = 0\nOutput: [100000]\nExplanation:\n- The sum of the subarray centered at index 0 with radius 0 is: 100000.\n  avg[0] = 100000 / 1 = 100000.\n\nExample 3:\n\nInput: nums = [8], k = 100000\nOutput: [-1]\nExplanation: \n- avg[0] is -1 because there are less than k elements before and after index 0.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t1 <= n <= 105\n\t0 <= nums[i], k <= 105",
        "solutions": [
            {
                "id": 3659283,
                "title": "2-method-s-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nThe problem aims to calculate the averages of subarrays within a given array, where each subarray has a fixed radius of `k` (i.e., a subarray of length `2k + 1`). The goal is to efficiently compute these averages for each subarray.\\n\\n# Approach 1: Prefix Sum\\n\\n1. First, it checks if the size of the input list `nums` is too small to form a valid subarray. If it is, the code returns a list of -1s as there are not enough numbers to calculate the averages.\\n2. If the input list is large enough, the code proceeds to calculate the averages. It creates a new list called `ans` with the same size as `nums` and fills it with -1s. This list will store the calculated averages.\\n3. The code then creates another list called `prefixSum` to help efficiently calculate the sum of subarrays. This list will store the cumulative sums of the numbers in `nums`.\\n4. It goes through each number in `nums` and calculates the cumulative sum up to that point. It does this by adding the current number to the sum of all previous numbers. The cumulative sums are stored in the `prefixSum` list.\\n5. Next, the code enters a loop that goes through the indices of `nums`, starting from `k` and ending at `n - k - 1`, where `n` is the size of `nums`. These indices represent the starting positions of the subarrays for which we want to calculate the averages.\\n6. For each index `i`, the code calculates the sum of the subarray by subtracting the prefix sum at index `i - k` from the prefix sum at index `i + k + 1`. This gives us the sum of all the numbers within the subarray.\\n7. After obtaining the sum of the subarray, the code divides it by the size of the subarray (`2k + 1`) to calculate the average. This average represents the average value of the numbers within the subarray.\\n8. The code stores the calculated average in the `ans` list at the corresponding index `i`. This way, each element in the `ans` list represents the average value of the subarray starting at that index.\\n9. Once the loop completes, the code has calculated the averages for all valid subarrays. It returns the `ans` list, which contains the computed averages.\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int windowSize = 2 * k + 1;\\n        vector<int> ans(n, -1);\\n\\n        if (n < windowSize) {\\n            return ans;\\n        }\\n\\n        vector<long long> prefixSum(n + 1);\\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\\n        }\\n\\n        for (int i = k; i + k < n; ++i) {\\n            ans[i] = (prefixSum[i + k + 1] - prefixSum[i - k]) / windowSize;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int windowSize = 2 * k + 1;\\n        int[] ans = new int[n];\\n        Arrays.fill(ans,-1);\\n        \\n        if (n < windowSize) {\\n            return ans;\\n        }\\n        \\n        long[] prefixSum = new long[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\\n        }\\n        \\n        for (int i = k; i + k < n; ++i) {\\n            ans[i] = (int) ((prefixSum[i + k + 1] - prefixSum[i - k]) / windowSize);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        windowSize = 2 * k + 1\\n        ans = [-1] * n\\n        \\n        if n < windowSize:\\n            return ans\\n        \\n        prefixSum = [0] * (n + 1)\\n        for i in range(n):\\n            prefixSum[i + 1] = prefixSum[i] + nums[i]\\n        \\n        for i in range(k, n - k):\\n            ans[i] = (prefixSum[i + k + 1] - prefixSum[i - k]) // windowSize\\n        \\n        return ans\\n```\\n\\n# Approach 2: Sliding Window\\n\\n1. It starts by initializing variables, such as the size of the input list `nums` (`n`), the window size (`2k + 1`), a variable `windowSum` to track the sum of the current window, and a list called `result` to store the calculated averages.\\n2. It checks if the size of the input list `nums` is too small to form a valid subarray. If it is, the code returns the initialized `result` list filled with -1s.\\n3. The code enters a loop that iterates over each index `i` in the list `nums`.\\n4. Inside the loop, it updates the `windowSum` by adding the current number `nums[i]` to it. This step represents adding the new number to the current window.\\n5. The code checks if the current index `i` minus the window size (`i - windowSize`) is greater than or equal to zero. If this condition is met, it means the current window has moved beyond the first window (starting at index 0). In this case, the code subtracts the number at `nums[i - windowSize]` from the `windowSum` to remove it from the window. This step represents removing the number that is no longer part of the window.\\n6. The code checks if the current index `i` is greater than or equal to `windowSize - 1`. If this condition is met, it means the current window has reached the desired size. In this case, the code calculates the average of the window by dividing the `windowSum` by the window size (`windowSum / windowSize`). It then stores the calculated average in the `result` list at the corresponding index `i - k`, where `k` represents half the window size. This step represents storing the average value in the `result` list.\\n7. Once the loop completes, the code has calculated the averages for all valid subarrays. It returns the `result` list, which contains the computed averages.\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int windowSize = 2 * k + 1;\\n        \\n        long long windowSum = 0;\\n        vector<int> result(n, -1);\\n\\n        if (n < windowSize) {\\n            return result;\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            windowSum += nums[i]; // Add nums[i] to the window sum\\n\\n            if (i - windowSize >= 0) {\\n                windowSum -= nums[i - windowSize]; // Remove nums[i - windowSize] from the window sum\\n            }\\n\\n            if (i >= windowSize - 1) {\\n                result[i - k] = windowSum / windowSize; // Calculate and store the average in the result\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int windowSize = 2 * k + 1;\\n        \\n        long windowSum = 0;\\n        int[] result = new int[n];\\n        Arrays.fill(result,-1);\\n\\n        if (n < windowSize) {\\n            return result;\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            windowSum += nums[i]; // Add nums[i] to the window sum\\n\\n            if (i - windowSize >= 0) {\\n                windowSum -= nums[i - windowSize]; // Remove nums[i - windowSize] from the window sum\\n            }\\n\\n            if (i >= windowSize - 1) {\\n                result[i - k] = (int) (windowSum / windowSize); // Calculate and store the average in the result\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        windowSize = 2 * k + 1\\n\\n        windowSum = 0\\n        result = [-1] * n\\n\\n        if n < windowSize:\\n            return result\\n\\n        for i in range(n):\\n            windowSum += nums[i]  # Add nums[i] to the window sum\\n\\n            if i - windowSize >= 0:\\n                windowSum -= nums[i - windowSize]  # Remove nums[i - windowSize] from the window sum\\n\\n            if i >= windowSize - 1:\\n                result[i - k] = windowSum // windowSize  # Calculate and store the average in the result\\n\\n        return result\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/2b48518e-0228-49af-b7ab-c577815d6098_1687229589.1216552.png)\\n\\n[Two Sum best solution once have a look please support](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int windowSize = 2 * k + 1;\\n        vector<int> ans(n, -1);\\n\\n        if (n < windowSize) {\\n            return ans;\\n        }\\n\\n        vector<long long> prefixSum(n + 1);\\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\\n        }\\n\\n        for (int i = k; i + k < n; ++i) {\\n            ans[i] = (prefixSum[i + k + 1] - prefixSum[i - k]) / windowSize;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int windowSize = 2 * k + 1;\\n        int[] ans = new int[n];\\n        Arrays.fill(ans,-1);\\n        \\n        if (n < windowSize) {\\n            return ans;\\n        }\\n        \\n        long[] prefixSum = new long[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\\n        }\\n        \\n        for (int i = k; i + k < n; ++i) {\\n            ans[i] = (int) ((prefixSum[i + k + 1] - prefixSum[i - k]) / windowSize);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        windowSize = 2 * k + 1\\n        ans = [-1] * n\\n        \\n        if n < windowSize:\\n            return ans\\n        \\n        prefixSum = [0] * (n + 1)\\n        for i in range(n):\\n            prefixSum[i + 1] = prefixSum[i] + nums[i]\\n        \\n        for i in range(k, n - k):\\n            ans[i] = (prefixSum[i + k + 1] - prefixSum[i - k]) // windowSize\\n        \\n        return ans\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int windowSize = 2 * k + 1;\\n        \\n        long long windowSum = 0;\\n        vector<int> result(n, -1);\\n\\n        if (n < windowSize) {\\n            return result;\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            windowSum += nums[i]; // Add nums[i] to the window sum\\n\\n            if (i - windowSize >= 0) {\\n                windowSum -= nums[i - windowSize]; // Remove nums[i - windowSize] from the window sum\\n            }\\n\\n            if (i >= windowSize - 1) {\\n                result[i - k] = windowSum / windowSize; // Calculate and store the average in the result\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int windowSize = 2 * k + 1;\\n        \\n        long windowSum = 0;\\n        int[] result = new int[n];\\n        Arrays.fill(result,-1);\\n\\n        if (n < windowSize) {\\n            return result;\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            windowSum += nums[i]; // Add nums[i] to the window sum\\n\\n            if (i - windowSize >= 0) {\\n                windowSum -= nums[i - windowSize]; // Remove nums[i - windowSize] from the window sum\\n            }\\n\\n            if (i >= windowSize - 1) {\\n                result[i - k] = (int) (windowSum / windowSize); // Calculate and store the average in the result\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        windowSize = 2 * k + 1\\n\\n        windowSum = 0\\n        result = [-1] * n\\n\\n        if n < windowSize:\\n            return result\\n\\n        for i in range(n):\\n            windowSum += nums[i]  # Add nums[i] to the window sum\\n\\n            if i - windowSize >= 0:\\n                windowSum -= nums[i - windowSize]  # Remove nums[i - windowSize] from the window sum\\n\\n            if i >= windowSize - 1:\\n                result[i - k] = windowSum // windowSize  # Calculate and store the average in the result\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599973,
                "title": "python-3-sliding-window-illustration-with-picture",
                "content": "![image](https://assets.leetcode.com/users/images/a410ce10-f0b6-47bc-acd0-334c707e059a_1654662681.7457461.png)\\n\\n\\n```python\\nclass Solution:\\n  def getAverages(self, nums: List[int], k: int) -> List[int]:\\n    res = [-1]*len(nums)\\n\\n    left, curWindowSum, diameter = 0, 0, 2*k+1\\n    for right in range(len(nums)):\\n      curWindowSum += nums[right]\\n      if (right-left+1 >= diameter):\\n        res[left+k] = curWindowSum//diameter\\n        curWindowSum -= nums[left]\\n        left += 1\\n    return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n  def getAverages(self, nums: List[int], k: int) -> List[int]:\\n    res = [-1]*len(nums)\\n\\n    left, curWindowSum, diameter = 0, 0, 2*k+1\\n    for right in range(len(nums)):\\n      curWindowSum += nums[right]\\n      if (right-left+1 >= diameter):\\n        res[left+k] = curWindowSum//diameter\\n        curWindowSum -= nums[left]\\n        left += 1\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599803,
                "title": "c-o-n-time-sliding-window-or-prefix-sum",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Sliding Window\\n\\n**Intuition**: Keep a fixed-length sliding window of length `2k + 1`. Slide it from left to right, and update the sum of the window on the fly.\\n\\n**Algorithm**:\\n\\nLet `len = 2*k + 1`.\\n\\nIf `N < len`, return all `-1`s directly because this array is too short to cover any window\\n\\nOtherwise, loop `i` from `0` to `N-1`:\\n* Push `A[i]` into the window. `sum += A[i]`\\n* Pop `A[i-len]` out of the window. `sum -= A[i - len]`\\n* Assign the average value. `ans[i - k] = sum / len`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-269/problems/k-radius-subarray-averages/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& A, int k) {\\n        long N = A.size(), len = 2 * k + 1, sum = 0; // `len` is the length of the window\\n        vector<int> ans(N, -1);\\n        if (N < len) return ans; // If the array is too short to cover a window, return all -1s\\n        for (int i = 0; i < N; ++i) {\\n            sum += A[i]; // push A[i] into the window\\n            if (i - len >= 0) sum -= A[i - len]; // pop A[i-len], if any, out of window\\n            if (i >= len - 1) ans[i - k] = sum / len; // the center of this window is at `i-k`\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Prefix Sum\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/k-radius-subarray-averages/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& A, int k) {\\n        int N = A.size(), len = 2 * k + 1;\\n        vector<int> ans(N, -1);\\n        if (N < len) return ans; // If the array is too short to cover a window, return all -1s\\n        vector<long> sum(N + 1);\\n        for (int i = 0; i < N; ++i) sum[i + 1] = sum[i] + A[i];\\n        for (int i = k; i + k < N; ++i) ans[i] = (sum[i + k + 1] - sum[i - k]) / len;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-269/problems/k-radius-subarray-averages/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1) extra space\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& A, int k) {\\n        long N = A.size(), len = 2 * k + 1, sum = 0; // `len` is the length of the window\\n        vector<int> ans(N, -1);\\n        if (N < len) return ans; // If the array is too short to cover a window, return all -1s\\n        for (int i = 0; i < N; ++i) {\\n            sum += A[i]; // push A[i] into the window\\n            if (i - len >= 0) sum -= A[i - len]; // pop A[i-len], if any, out of window\\n            if (i >= len - 1) ans[i - k] = sum / len; // the center of this window is at `i-k`\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/k-radius-subarray-averages/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& A, int k) {\\n        int N = A.size(), len = 2 * k + 1;\\n        vector<int> ans(N, -1);\\n        if (N < len) return ans; // If the array is too short to cover a window, return all -1s\\n        vector<long> sum(N + 1);\\n        for (int i = 0; i < N; ++i) sum[i + 1] = sum[i] + A[i];\\n        for (int i = k; i + k < N; ++i) ans[i] = (sum[i + k + 1] - sum[i - k]) / len;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659994,
                "title": "c-easy-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& v, int k) {\\n        int n=v.size();\\n        vector<int>a(n,-1);\\n        int l=0,r=0;\\n        long long sum=0;\\n        while(r<n){\\n            sum += v[r];\\n            if((r-l+1)==(2*k+1)){\\n                a[r-k] = sum/(2*k+1);\\n                sum -= v[l];\\n                l++; \\n            }\\n            r++;\\n        }\\n        return a;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/ce444f70-268e-4b51-a645-7856b861eed1_1687241383.6346185.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& v, int k) {\\n        int n=v.size();\\n        vector<int>a(n,-1);\\n        int l=0,r=0;\\n        long long sum=0;\\n        while(r<n){\\n            sum += v[r];\\n            if((r-l+1)==(2*k+1)){\\n                a[r-k] = sum/(2*k+1);\\n                sum -= v[l];\\n                l++; \\n            }\\n            r++;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599893,
                "title": "java-presum-one-loop",
                "content": "```\\none loop\\n```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int N = nums.length;\\n        int[] res = new int[N];\\n        long sum = 0;\\n        for (int i = 0; i < N; i++) {\\n            if (i < k) res[i] = -1;            \\n            sum += nums[i];\\n            if (i >= 2*k) {\\n                res[i - k] = (int)(sum / (2*k + 1));\\n                sum -= nums[i - 2*k];\\n            }\\n\\t\\t\\tif (i >= N - k) res[i] = -1;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\none loop\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659461,
                "title": "c-easy-c-solution-prefix-sum-array-o-n",
                "content": "1. The k-radius subarray average centred at i only exists if number of elements to it\\'s left and right are **greater than or equal to k**\\n2. We try to maintain the left count and right count which indicates the counts of elements to left and right side of the element respectively.\\n3. If both the counts are greater than or equal to k, we can calculate the k-radius subarray average. If not, answer is -1.\\n4. To get the sum of the right and left segments, we use the concept of **Prefix-Sums** to calculate it in O(1) time.\\n5. The total number of elements in the subarray will be **2*k + 1**.\\n6. Hence the average can be easily calculated with the total sum of segment and total number of elements by dividing them.\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(n)\\n\\n```\\nvector<int> getAverages(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int>ans(n);\\n        \\n        vector<long long>pref(n);\\n        pref[0] = arr[0];\\n        for (int i = 1; i < n; i++)\\n            pref[i] = pref[i - 1] + arr[i];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            int lcnt = i;\\n            int rcnt = n - i - 1;\\n            if (lcnt >= k and rcnt >= k)\\n            {\\n                long long lsum = 0;\\n                long long rsum = pref[i + k];\\n                \\n                if (i - k > 0)\\n                    lsum = pref[i - k - 1];\\n                    \\n                ans[i] = (rsum - lsum) / (2*k + 1);\\n            }\\n            else\\n                ans[i] = -1;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> getAverages(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        vector<int>ans(n);\\n        \\n        vector<long long>pref(n);\\n        pref[0] = arr[0];\\n        for (int i = 1; i < n; i++)\\n            pref[i] = pref[i - 1] + arr[i];\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            int lcnt = i;\\n            int rcnt = n - i - 1;\\n            if (lcnt >= k and rcnt >= k)\\n            {\\n                long long lsum = 0;\\n                long long rsum = pref[i + k];\\n                \\n                if (i - k > 0)\\n                    lsum = pref[i - k - 1];\\n                    \\n                ans[i] = (rsum - lsum) / (2*k + 1);\\n            }\\n            else\\n                ans[i] = -1;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601669,
                "title": "sliding-window",
                "content": "The size of the sliding window is `d = k * 2 + 1` (`d` is for diameter). \\n\\nWe pre-populate the result array `res` with `-1`, and set centered indexes to the sliding window average: ` res[i - d / 2] = sum / d`.\\n\\n> A catch - we need to store the window sum using a 64-bit integer to avoid overflow.\\n\\n**C++**\\n```cpp\\nvector<int> getAverages(vector<int>& nums, int k) {\\n    vector<int> res(nums.size(), -1);\\n    long long sum = 0, d = k * 2 + 1;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        if (i + 1 >= d) {\\n            if (i >= d)\\n                sum -= nums[i - d];\\n            res[i - d / 2] = sum / d;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> getAverages(vector<int>& nums, int k) {\\n    vector<int> res(nums.size(), -1);\\n    long long sum = 0, d = k * 2 + 1;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        sum += nums[i];\\n        if (i + 1 >= d) {\\n            if (i >= d)\\n                sum -= nums[i - d];\\n            res[i - d / 2] = sum / d;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1599853,
                "title": "python3-prefix-sum",
                "content": "Pleaes check out this [commit](https://github.com/gaosanyong/leetcode/commit/b3dd8d234940d5e4afc6a22cc8fc1f4a2e69dd3d) for solutions of weekly 269.\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = [-1]*len(nums)\\n        for i, x in enumerate(nums): \\n            if k <= i < len(nums)-k: ans[i] = (prefix[i+k+1] - prefix[i-k])//(2*k+1)\\n        return ans \\n```\\n\\nAdding sliding window solution \\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        ans = [-1]*len(nums)\\n        rsm = 0 # range sum\\n        for i, x in enumerate(nums): \\n            rsm += x\\n            if i >= 2*k+1: rsm -= nums[i-(2*k+1)]\\n            if i+1 >= 2*k+1: ans[i-k] = rsm//(2*k+1)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = [-1]*len(nums)\\n        for i, x in enumerate(nums): \\n            if k <= i < len(nums)-k: ans[i] = (prefix[i+k+1] - prefix[i-k])//(2*k+1)\\n        return ans \\n```\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        ans = [-1]*len(nums)\\n        rsm = 0 # range sum\\n        for i, x in enumerate(nums): \\n            rsm += x\\n            if i >= 2*k+1: rsm -= nums[i-(2*k+1)]\\n            if i+1 >= 2*k+1: ans[i-k] = rsm//(2*k+1)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599859,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution\\n{\\n    public int[] getAverages(int[] nums, int k)\\n    {\\n        if(k == 0)\\n            return nums;\\n\\t\\t\\t\\n        int N = nums.length;\\n        long[] sum = new long[N];\\n        sum[0] = nums[0];\\n\\t\\t\\n        for(int i = 1; i < N; i++)\\n            sum[i] = sum[i-1]+nums[i]; // Sum of 0 - ith element at sum[i]\\n\\t\\t\\t\\n        int[] ret = new int[N];\\n        Arrays.fill(ret,-1);\\n\\t\\t\\n        for(int i = k; i < N-k; i++) // Beyond this range, there are less than k elements so -1\\n        {\\n            long temp = (sum[i+k]-sum[i-k]+nums[i-k])/(k*2+1);\\n            ret[i] = (int)temp;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int[] getAverages(int[] nums, int k)\\n    {\\n        if(k == 0)\\n            return nums;\\n\\t\\t\\t\\n        int N = nums.length;\\n        long[] sum = new long[N];\\n        sum[0] = nums[0];\\n\\t\\t\\n        for(int i = 1; i < N; i++)\\n            sum[i] = sum[i-1]+nums[i]; // Sum of 0 - ith element at sum[i]\\n\\t\\t\\t\\n        int[] ret = new int[N];\\n        Arrays.fill(ret,-1);\\n\\t\\t\\n        for(int i = k; i < N-k; i++) // Beyond this range, there are less than k elements so -1\\n        {\\n            long temp = (sum[i+k]-sum[i-k]+nums[i-k])/(k*2+1);\\n            ret[i] = (int)temp;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659683,
                "title": "c-two-pointers-beginner-friendly",
                "content": "### \\uD83D\\uDD25 Donn forget to Upvote. \\uD83D\\uDD25\\n\\n\\n# Approach\\n**Approach to this problem is**,\\nFirstly made an 0-indexed ***ans*** vector and made all its intial \\'k\\' values as -1 (*since for the first k elements we won\\'t be able to make a circle of radius k within the array boundaries*).\\nAfter that I stored the sum of first ***2*k+1*** (i.e, k+1+k=2*k+1) elements which will behave as the sum of values of k radius for the index \\'k\\'.\\nNow I just iterated untill my right pointer gets out of boundaries and keep on adding the subsequent values of array meanwhile subtracting the left most values at the same time and store all the values of sum/(2*k+1) i.e, averaging the values, into the vector ans.\\nafter that made all the rest elements of the ans vector as -1 (logic is similar to the Step 1) and then returned the ans vector.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> ans;\\n\\n        if(nums.size()>=2*k+1)\\n        {\\n            int i=0,j=2*k+1;\\n            long long int sum=0;\\n            // storing sum .\\n            for(int p=0;p<2*k+1;p++) \\n                sum+=nums[p];\\n            // making first k elements -1.\\n            for(int i=0;i<k;i++)\\n                ans.push_back(-1);\\n            // simple sliding window.\\n            while(j<nums.size())\\n            {\\n                ans.push_back(sum/(2*k+1));\\n                sum+=nums[j]-nums[i];\\n                j++;\\n                i++;\\n            }\\n\\n            ans.push_back(sum/(2*k+1));\\n        }\\n        //making the rest of the elements -1.\\n        while(ans.size()<nums.size()) \\n            ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> ans;\\n\\n        if(nums.size()>=2*k+1)\\n        {\\n            int i=0,j=2*k+1;\\n            long long int sum=0;\\n            // storing sum .\\n            for(int p=0;p<2*k+1;p++) \\n                sum+=nums[p];\\n            // making first k elements -1.\\n            for(int i=0;i<k;i++)\\n                ans.push_back(-1);\\n            // simple sliding window.\\n            while(j<nums.size())\\n            {\\n                ans.push_back(sum/(2*k+1));\\n                sum+=nums[j]-nums[i];\\n                j++;\\n                i++;\\n            }\\n\\n            ans.push_back(sum/(2*k+1));\\n        }\\n        //making the rest of the elements -1.\\n        while(ans.size()<nums.size()) \\n            ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659092,
                "title": "sliding-window-video-java-c-python",
                "content": "# Sliding Window\\nIts staright forward to use a window of length 2*k+1.Detailed explanation in the video\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/oogIFAvVwGU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int [] ans = new int[n];\\n        Arrays.fill(ans, -1);\\n        \\n        long sum = 0;\\n        int length = 2*k+1;\\n        if(length>n) return ans;\\n        for(int i = 0;i<length;i++){\\n            sum+=nums[i];\\n        }\\n        ans[k] = (int)(sum/length);\\n        int start = 0 ;\\n        for(int last = length;last<n;last++){\\n            sum = sum - nums[start]+ nums[last];\\n            start++;\\n            ans[last-k] = (int)(sum/length);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    std::vector<int> ans(n, -1);\\n    \\n    long long sum = 0;\\n    int length = 2 * k + 1;\\n    if (length > n)\\n        return ans;\\n    \\n    for (int i = 0; i < length; i++) {\\n        sum += nums[i];\\n    }\\n    ans[k] = static_cast<int>(sum / length);\\n    \\n    int start = 0;\\n    for (int last = length; last < n; last++) {\\n        sum = sum - nums[start] + nums[last];\\n        start++;\\n        ans[last - k] = static_cast<int>(sum / length);\\n    }\\n    \\n    return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution(object):\\n    def getAverages(self, nums, k):\\n            n = len(nums)\\n            ans = [-1] * n\\n            length = 2 * k + 1\\n            if length > n:\\n                return ans\\n\\n            total_sum = sum(nums[:length])\\n            ans[k] = total_sum // length\\n            start = 0\\n            for last in range(length, n):\\n                total_sum = total_sum - nums[start] + nums[last]\\n                start += 1\\n                ans[last - k] = total_sum // length\\n\\n            return ans\\n        \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int [] ans = new int[n];\\n        Arrays.fill(ans, -1);\\n        \\n        long sum = 0;\\n        int length = 2*k+1;\\n        if(length>n) return ans;\\n        for(int i = 0;i<length;i++){\\n            sum+=nums[i];\\n        }\\n        ans[k] = (int)(sum/length);\\n        int start = 0 ;\\n        for(int last = length;last<n;last++){\\n            sum = sum - nums[start]+ nums[last];\\n            start++;\\n            ans[last-k] = (int)(sum/length);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    int n = nums.size();\\n    std::vector<int> ans(n, -1);\\n    \\n    long long sum = 0;\\n    int length = 2 * k + 1;\\n    if (length > n)\\n        return ans;\\n    \\n    for (int i = 0; i < length; i++) {\\n        sum += nums[i];\\n    }\\n    ans[k] = static_cast<int>(sum / length);\\n    \\n    int start = 0;\\n    for (int last = length; last < n; last++) {\\n        sum = sum - nums[start] + nums[last];\\n        start++;\\n        ans[last - k] = static_cast<int>(sum / length);\\n    }\\n    \\n    return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def getAverages(self, nums, k):\\n            n = len(nums)\\n            ans = [-1] * n\\n            length = 2 * k + 1\\n            if length > n:\\n                return ans\\n\\n            total_sum = sum(nums[:length])\\n            ans[k] = total_sum // length\\n            start = 0\\n            for last in range(length, n):\\n                total_sum = total_sum - nums[start] + nums[last]\\n                start += 1\\n                ans[last - k] = total_sum // length\\n\\n            return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072811,
                "title": "easy-c-approach-o-n-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe whole Intuition I get is itself from the question, that is, (i-k) and (i+k). with this i decided to make a window of (2*k)+1 size.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this problem, we have to check whether k size elements are present to left and right of index i. if yes, then proceed further else give -1. For this, declare  vector of size n and initialize it with -1.\\n\\n Now if k is 0, return the nums vector as it is. Now traverse whole vector and starts computing sum of window size of 2k+1. and calculate the average when window sum is computed. minus the index j value from sum and add next i value to keep window size intact.\\n\\nStore the avg at i-k index in the vector declared.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(N) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) because we make an extra vector of size n.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        vector<int> v(n,-1);\\n        int temp= (2*k) +1;\\n\\n        if(n<temp)  // base case 1;\\n        return v;\\n\\n        if(k==0)   // base case 2;\\n        return nums;\\n        long long int j=0, sum=0, avg=0;\\n        for(int i=0; i< n; i++)\\n        {\\n            sum = sum + nums[i];\\n            if(i-j+1==temp)\\n            {\\n                avg= sum/temp;\\n                // v.push_back(avg);\\n                v[i-k]= avg;\\n                sum= sum- nums[j];\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        vector<int> v(n,-1);\\n        int temp= (2*k) +1;\\n\\n        if(n<temp)  // base case 1;\\n        return v;\\n\\n        if(k==0)   // base case 2;\\n        return nums;\\n        long long int j=0, sum=0, avg=0;\\n        for(int i=0; i< n; i++)\\n        {\\n            sum = sum + nums[i];\\n            if(i-j+1==temp)\\n            {\\n                avg= sum/temp;\\n                // v.push_back(avg);\\n                v[i-k]= avg;\\n                sum= sum- nums[j];\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602145,
                "title": "c-o-n-faster-than-100-in-space-and-time-very-easy-with-explanation",
                "content": "Here I am first checking whether there is elements less than k or not then I am sliding the window while adding the next element and subtracting the previous one so that window is maintained and my solution is created.\\n\\nI hope you are able to understand. Otherwise **comment down I will be glad to help you out**.\\n\\nPlease **Upvote if you like my solution**.\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int dia=k+k+1,i=0,start=0;\\n\\t\\tlong long avg=0,avg_ans=0;\\n        vector<int> out(n,-1);               // creating array with size -1 so that we dont have to push -1 at every step.\\n        if(n<dia)\\n               return  out;   \\n        for(i=0;i<dia;i++)\\n        {\\n            avg+=nums[i];\\n        }\\n        avg_ans=avg/dia;\\n        out[i-k-1]=avg_ans;\\n        while(i<n)\\n        {\\n            avg+=nums[i++];\\n            avg-=nums[start++];\\n            avg_ans=avg/dia;\\n            out[i-k-1]=avg_ans;\\n        }\\n        return out;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int dia=k+k+1,i=0,start=0;\\n\\t\\tlong long avg=0,avg_ans=0;\\n        vector<int> out(n,-1);               // creating array with size -1 so that we dont have to push -1 at every step.\\n        if(n<dia)\\n               return  out;   \\n        for(i=0;i<dia;i++)\\n        {\\n            avg+=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1600245,
                "title": "idea-explained-prefix-sum-sliding-window-c-clean-code",
                "content": "**Idea :**\\n\\n--------------------------------------------------\\n\\n* Idea is that we need to consider **all windows** of size **`d = 2*k + 1`**. \\n\\n* For each such window, we need to calcuate its sum and then divide by `d` to get *average*. \\n* We can use **prefix sum array** to directly get sum of elements between index `i` and index `j`.\\n\\t* i.e **`window sum = prefix[j] - prefix[i-1]`**, if `i != 0`\\n\\t* else if `i=0`, **`window sum = prefix[j]`**\\n* Therefore, if we need **`k-radius subarray average`** for some index `i`, such that \\n\\t* `i-k >= 0` and `i+k < n`, i.e window is of size `d = 2*k + 1`.\\n\\t\\t\\n\\t\\t\\tEx: nums = [7,4,3,9,1,8,5,2,6] , k = 3\\n\\t\\t\\t     k           k\\n\\t\\t\\t  <----->     <----->\\n\\t\\t\\t\\t7  4  3  9  1  8  5  2  6\\n\\t\\t\\t\\t^        ^        ^\\n\\t\\t\\t i-k       i       i+k\\n\\t\\t\\t \\n\\t\\t\\t Slide this window of size d = 2*k+1, till it well within allowed range.\\n\\t\\t\\t \\n\\t* Otherwise, it is out of bound, average will be `-1`\\n* So, we can calculate average for all index `i = [k ... n-1-k]` , using a simple formula :\\n\\t* **`average[i] = (prefix[i+k] - prefix[i-k-1]) / d`**, if `i-k-1 >= 0`,\\n\\t* otherwise, **`average[i] = (prefix[i+k] - 0) / d`**, if `i-k-1 < 0`\\n\\n--------------------------------------------------------\\n# Code:\\n---------------------------------------------------------\\n\\n\\t\\n\\tvector<int> getAverages(vector<int>& nums, int k) {\\n\\n\\t\\tint n = nums.size();\\n\\t\\tvector<long long> prefSum(n, 0);\\n\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tprefSum[i] = nums[i] + ((i==0) ? 0 : prefSum[i-1]); \\n\\t\\t}\\n\\n\\t\\tvector<int> avgs(n, -1);\\n\\n\\t\\tint d = 2*k + 1;\\n\\t\\tfor(int i=k; i<=n-k-1; i++) {\\n\\t\\t\\tavgs[i] = (prefSum[i+k] - ((i-k-1) < 0 ? 0 : prefSum[i-k-1])) / d;\\n\\t\\t}\\n\\n\\t\\treturn avgs;\\n\\t} \\n\\n--------------------------------------------------\\n**Complexity :**\\n--------------------------------------------------\\n* Time : `O(N + W)`, calculating prefix sum and averages\\n\\t* N : size of `nums` \\n\\t* W : number of windows of size `d = 2*k + 1`\\n\\n* Space : `O(N)`, N is size of prefix sum array\\n--------------------------------------------------\\n***If you find this helpful do give it a like :)***",
                "solutionTags": [
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "**Idea :**\\n\\n--------------------------------------------------\\n\\n* Idea is that we need to consider **all windows** of size **`d = 2*k + 1`**. \\n\\n* For each such window, we need to calcuate its sum and then divide by `d` to get *average*. \\n* We can use **prefix sum array** to directly get sum of elements between index `i` and index `j`.\\n\\t* i.e **`window sum = prefix[j] - prefix[i-1]`**, if `i != 0`\\n\\t* else if `i=0`, **`window sum = prefix[j]`**\\n* Therefore, if we need **`k-radius subarray average`** for some index `i`, such that \\n\\t* `i-k >= 0` and `i+k < n`, i.e window is of size `d = 2*k + 1`.\\n\\t\\t\\n\\t\\t\\tEx: nums = [7,4,3,9,1,8,5,2,6] , k = 3\\n\\t\\t\\t     k           k\\n\\t\\t\\t  <----->     <----->\\n\\t\\t\\t\\t7  4  3  9  1  8  5  2  6\\n\\t\\t\\t\\t^        ^        ^\\n\\t\\t\\t i-k       i       i+k\\n\\t\\t\\t \\n\\t\\t\\t Slide this window of size d = 2*k+1, till it well within allowed range.\\n\\t\\t\\t \\n\\t* Otherwise, it is out of bound, average will be `-1`\\n* So, we can calculate average for all index `i = [k ... n-1-k]` , using a simple formula :\\n\\t* **`average[i] = (prefix[i+k] - prefix[i-k-1]) / d`**, if `i-k-1 >= 0`,\\n\\t* otherwise, **`average[i] = (prefix[i+k] - 0) / d`**, if `i-k-1 < 0`\\n\\n--------------------------------------------------------\\n# Code:\\n---------------------------------------------------------\\n\\n\\t\\n\\tvector<int> getAverages(vector<int>& nums, int k) {\\n\\n\\t\\tint n = nums.size();\\n\\t\\tvector<long long> prefSum(n, 0);\\n\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tprefSum[i] = nums[i] + ((i==0) ? 0 : prefSum[i-1]); \\n\\t\\t}\\n\\n\\t\\tvector<int> avgs(n, -1);\\n\\n\\t\\tint d = 2*k + 1;\\n\\t\\tfor(int i=k; i<=n-k-1; i++) {\\n\\t\\t\\tavgs[i] = (prefSum[i+k] - ((i-k-1) < 0 ? 0 : prefSum[i-k-1])) / d;\\n\\t\\t}\\n\\n\\t\\treturn avgs;\\n\\t} \\n\\n--------------------------------------------------\\n**Complexity :**\\n--------------------------------------------------\\n* Time : `O(N + W)`, calculating prefix sum and averages\\n\\t* N : size of `nums` \\n\\t* W : number of windows of size `d = 2*k + 1`\\n\\n* Space : `O(N)`, N is size of prefix sum array\\n--------------------------------------------------\\n***If you find this helpful do give it a like :)***",
                "codeTag": "Unknown"
            },
            {
                "id": 3659482,
                "title": "c-prefix-sum-easy-with-explanation",
                "content": "Simply check for validity of indexes if i-k indexes exist and i+k index exist then substract the prefix sum till i-k-1 index from prefix till i+k index. otherwise if i-k elements or i+k elements do not exist simply push -1 to answer vector.\\n\\n**Please upvote if it helped!**\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        vector<long long>pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1; i<n; i++){\\n            pre[i]= nums[i]+pre[i-1];\\n            cout<<pre[i]<<\" \";\\n        }\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            if(i-k<0 || i+k>n-1){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                long long no= 2*k+1;\\n                long long presum= pre[i+k];\\n                if(i-k-1>=0){\\n                    presum-=pre[i-k-1];\\n                }\\n                ans.push_back(presum/no);\\n                \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        vector<long long>pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1; i<n; i++){\\n            pre[i]= nums[i]+pre[i-1];\\n            cout<<pre[i]<<\" \";\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 3658985,
                "title": "w-explanation-c-python-c-solutions-sliding-window-beats-98-25",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis function calculates sliding window averages for a given input vector nums and window size k. It first checks if there are enough elements in the input vector to form a valid window. If not, it returns a vector with all elements set to -1. If there are enough elements, it proceeds to calculate the sliding window averages.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPlease turn english subtitles if neccessary\\n[https://youtu.be/u5p1dEiaAPw](https://youtu.be/u5p1dEiaAPw)\\nTo calculate the averages, the code initializes a vector avg of the same size as the input vector, with all elements initially set to -1.\\n\\nIt uses a loop to iterate over the input vector, summing up the first 2 * k + 1 elements. It then calculates the average of these elements and stores it in the avg vector at the index k, representing the center of the window.\\n\\nNext, the code enters another loop that starts from k + 1 and iterates until n - k - 1, where n is the size of the input vector.\\n\\nWithin this loop, it updates the sum by subtracting the element that moved out of the window (at index i - k - 1) and adding the element that enters the window (at index k + i). It then calculates the average based on the updated sum and stores it in the avg vector at the current index i.\\n\\nFinally, the function returns the avg vector, which contains the sliding window averages for each position in the input vector. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code Runtime 229 ms Beats 94.77%\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> avg(n, -1);\\n        if (2*k+1>n) return avg;\\n        unsigned long long sum=0;\\n        //sum=accumulate(nums.begin(), nums.begin()+(k*2+1), 0L);\\n        for(int i=0; i<=2*k; i++){\\n            sum+=nums[i];\\n        }\\n        avg[k]=sum/(2*k+1);\\n        for(int i=k+1; i<n-k; i++){\\n            sum+=nums[k+i]-nums[i-k-1];\\n            avg[i]=sum/(2*k+1);\\n        }\\n        return avg;\\n    }\\n};\\n```\\n# Python solution\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n=len(nums)\\n        avg=[-1]*n\\n        k2_1=2*k+1\\n        if k2_1>n: return avg\\n        # wsum=sum(nums[0:k2_1])\\n        wsum=0\\n        for x in nums[0:k2_1]:\\n            wsum+=x\\n        # Can replace by sum()\\n        avg[k]=wsum//k2_1\\n        for i in range(k+1, n-k):\\n            wsum+=nums[k+i]-nums[i-k-1]\\n            avg[i]=sum//k2_1\\n        return avg\\n```\\n# C solution\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* getAverages(int* nums, int n, int k, int* returnSize){\\n    int* avg=(int*)malloc(sizeof(int)*n);\\n    memset(avg, -1, sizeof(int)*n);\\n    *returnSize=n;\\n    int k2_1=2*k+1;\\n    if (k2_1>n) return avg;\\n    unsigned long long sum=0;\\n    for(register int i=0; i<k2_1; i++){\\n        sum+=nums[i];\\n    }\\n    avg[k]=sum/k2_1;\\n    for(register int i=k+1; i<n-k; i++){\\n        sum+=nums[k+i]-nums[i-k-1];\\n        avg[i]=sum/k2_1;\\n    }\\n    return avg;\\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> avg(n, -1);\\n        if (2*k+1>n) return avg;\\n        unsigned long long sum=0;\\n        //sum=accumulate(nums.begin(), nums.begin()+(k*2+1), 0L);\\n        for(int i=0; i<=2*k; i++){\\n            sum+=nums[i];\\n        }\\n        avg[k]=sum/(2*k+1);\\n        for(int i=k+1; i<n-k; i++){\\n            sum+=nums[k+i]-nums[i-k-1];\\n            avg[i]=sum/(2*k+1);\\n        }\\n        return avg;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n=len(nums)\\n        avg=[-1]*n\\n        k2_1=2*k+1\\n        if k2_1>n: return avg\\n        # wsum=sum(nums[0:k2_1])\\n        wsum=0\\n        for x in nums[0:k2_1]:\\n            wsum+=x\\n        # Can replace by sum()\\n        avg[k]=wsum//k2_1\\n        for i in range(k+1, n-k):\\n            wsum+=nums[k+i]-nums[i-k-1]\\n            avg[i]=sum//k2_1\\n        return avg\\n```\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* getAverages(int* nums, int n, int k, int* returnSize){\\n    int* avg=(int*)malloc(sizeof(int)*n);\\n    memset(avg, -1, sizeof(int)*n);\\n    *returnSize=n;\\n    int k2_1=2*k+1;\\n    if (k2_1>n) return avg;\\n    unsigned long long sum=0;\\n    for(register int i=0; i<k2_1; i++){\\n        sum+=nums[i];\\n    }\\n    avg[k]=sum/k2_1;\\n    for(register int i=k+1; i<n-k; i++){\\n        sum+=nums[k+i]-nums[i-k-1];\\n        avg[i]=sum/k2_1;\\n    }\\n    return avg;\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660181,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery element except from k to size-k-1 will be -1. The sum of next k elements will be sum - sum of first element and + sum of next element \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUpvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> ans(nums.size(), -1); \\n        if(ans.size() < 2*k+1) return ans; \\n        stack<int> st; long long int t = 0; \\n        int s = 1, e = 2*k+1; \\n        for(int i=0; i<=2*k; i++) t += nums[i];  st.push(t/(2*k+1)); \\n        while(e <nums.size()){\\n             t -= nums[s-1]; t += nums[e]; s++; e++;\\n             st.push(t/(2*k+1)); \\n        }\\n\\n        int start = k, end = nums.size()-k-1;\\n        for(int i=end; i>=start ; i--) {\\n            ans[i] = st.top(); st.pop(); \\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> ans(nums.size(), -1); \\n        if(ans.size() < 2*k+1) return ans; \\n        stack<int> st; long long int t = 0; \\n        int s = 1, e = 2*k+1; \\n        for(int i=0; i<=2*k; i++) t += nums[i];  st.push(t/(2*k+1)); \\n        while(e <nums.size()){\\n             t -= nums[s-1]; t += nums[e]; s++; e++;\\n             st.push(t/(2*k+1)); \\n        }\\n\\n        int start = k, end = nums.size()-k-1;\\n        for(int i=end; i>=start ; i--) {\\n            ans[i] = st.top(); st.pop(); \\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660169,
                "title": "c-using-prefix-sum-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to calculate the averages of subarrays of length **2k + 1** within the given vector **nums**. It uses the prefix sum technique to efficiently calculate the cumulative sums of elements in **nums**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If k is equal to zero, there are no subarrays to calculate averages for, so the function returns the original vector nums.\\n2. Initialize variables n (size of nums) and ans (resultant vector) with appropriate values. The ans vector is initialized with -1 as a placeholder value.\\n3. If k is greater than n/2, it means there are not enough elements to form a subarray of length 2k + 1. In this case, the function returns the initialized ans vector.\\n4. Create a prefix sum array called prefix to store the cumulative sums of elements in nums. Iterate over the indices of nums, starting from 1, and calculate each element in the prefix array by adding the current element in nums to the previous prefix sum.\\n5. Set the divisor variable to 2k + 1, which represents the length of the subarray.\\n6. Initialize the sum variable to 0. It will keep track of the sum of elements within each subarray.\\n7. Iterate over the range k to n - k - 1 (inclusive) to calculate the averages. For each iteration:\\n- Calculate the average of the subarray using the formula (prefix[i + k] - sum) / divisor.\\n- Update the ans vector with the calculated average at index i.\\n- Update the sum by subtracting the element that is k positions behind the current index, nums[i - k], from the previous sum.\\n8. After the loop completes, the function returns the ans vector containing the averages of the subarrays.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if(k==0) return nums;\\n\\n        int n=nums.size();\\n        vector<int> ans(n,-1);\\n\\n        if(k>n/2) return ans;\\n\\n        //prefix sum\\n        vector<long long> prefix(n,0);\\n        prefix[0]=nums[0];\\n\\n        for(int i=1;i<n;i++) prefix[i]=prefix[i-1]+nums[i];\\n\\n        int divisor=2*k+1;\\n        long sum=0;\\n        for(int i=k;i<n-k;i++){\\n            ans[i]=(prefix[i+k]-sum)/divisor;\\n            sum+=nums[i-k];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if(k==0) return nums;\\n\\n        int n=nums.size();\\n        vector<int> ans(n,-1);\\n\\n        if(k>n/2) return ans;\\n\\n        //prefix sum\\n        vector<long long> prefix(n,0);\\n        prefix[0]=nums[0];\\n\\n        for(int i=1;i<n;i++) prefix[i]=prefix[i-1]+nums[i];\\n\\n        int divisor=2*k+1;\\n        long sum=0;\\n        for(int i=k;i<n-k;i++){\\n            ans[i]=(prefix[i+k]-sum)/divisor;\\n            sum+=nums[i-k];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659872,
                "title": "c-python-java-two-pointer-with-comments-for-easy-understanding",
                "content": "C++ Code--------------------------------------------------------------------->\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n//         create an array to store the mid vals if present\\n        vector<int>ans(n,-1);\\n//         end bounds check \\n        if(n%2==0&&n/2<=k){\\n            return ans;\\n        }else if(n%2!=0&&n/2<k){\\n            return ans;\\n        }\\n        \\n        int j=0,i=0,sz=2*k+1,m=k;\\n        long long int s=0;\\n//         iteration over the array \\n        while(i<n&&j<n){\\n            s+=nums[i];\\n            if(i-j+1==sz){\\n                ans[m++]=s/sz;\\n                s-=nums[j++];\\n            }\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nJava code-------------------------------------------------------------------->\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        // Create an array to store the mid vals if present\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = -1;\\n        }\\n        // End bounds check\\n        if (n % 2 == 0 && n / 2 <= k) {\\n            return ans;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return ans;\\n        }\\n\\n        int j = 0, i = 0, sz = 2 * k + 1, m = k;\\n        long s = 0;\\n        // Iteration over the array\\n        while (i < n && j < n) {\\n            s += nums[i];\\n            if (i - j + 1 == sz) {\\n                ans[m] = (int) (s / sz);\\n                s -= nums[j];\\n                j++;\\n                m++;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPython------------------------------------------------------->\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        # Create a list to store the mid vals if present\\n        ans = [-1] * n\\n        # End bounds check\\n        if n % 2 == 0 and n // 2 <= k:\\n            return ans\\n        elif n % 2 != 0 and n // 2 < k:\\n            return ans\\n\\n        j, i, sz, m = 0, 0, 2 * k + 1, k\\n        s = 0\\n        # Iteration over the list\\n        while i < n and j < n:\\n            s += nums[i]\\n            if i - j + 1 == sz:\\n                ans[m] = s // sz\\n                s -= nums[j]\\n                j += 1\\n                m += 1\\n            i += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n//         create an array to store the mid vals if present\\n        vector<int>ans(n,-1);\\n//         end bounds check \\n        if(n%2==0&&n/2<=k){\\n            return ans;\\n        }else if(n%2!=0&&n/2<k){\\n            return ans;\\n        }\\n        \\n        int j=0,i=0,sz=2*k+1,m=k;\\n        long long int s=0;\\n//         iteration over the array \\n        while(i<n&&j<n){\\n            s+=nums[i];\\n            if(i-j+1==sz){\\n                ans[m++]=s/sz;\\n                s-=nums[j++];\\n            }\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        // Create an array to store the mid vals if present\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = -1;\\n        }\\n        // End bounds check\\n        if (n % 2 == 0 && n / 2 <= k) {\\n            return ans;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return ans;\\n        }\\n\\n        int j = 0, i = 0, sz = 2 * k + 1, m = k;\\n        long s = 0;\\n        // Iteration over the array\\n        while (i < n && j < n) {\\n            s += nums[i];\\n            if (i - j + 1 == sz) {\\n                ans[m] = (int) (s / sz);\\n                s -= nums[j];\\n                j++;\\n                m++;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        # Create a list to store the mid vals if present\\n        ans = [-1] * n\\n        # End bounds check\\n        if n % 2 == 0 and n // 2 <= k:\\n            return ans\\n        elif n % 2 != 0 and n // 2 < k:\\n            return ans\\n\\n        j, i, sz, m = 0, 0, 2 * k + 1, k\\n        s = 0\\n        # Iteration over the list\\n        while i < n and j < n:\\n            s += nums[i]\\n            if i - j + 1 == sz:\\n                ans[m] = s // sz\\n                s -= nums[j]\\n                j += 1\\n                m += 1\\n            i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659650,
                "title": "easiest-python-solution-using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires calculating the averages of subarrays of length k within the given nums list. The approach involves using prefix sums to efficiently calculate the sum of subarrays.\\n\\nUpvote thank you \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the prefix sum of the nums list using an array psum. Each element of psum represents the sum of all elements up to that index in nums.\\n1. Initialize the lower limit L as k (the length of subarrays) and the upper limit H as n - k, where n is the length of the nums list.\\n1. Initialize an answer array ans of size n with all elements set to -1.\\n1. Calculate the range r required for averaging, which is 2 * k + 1.\\n1. If r is larger than the total number of elements in nums, return the ans array as it is since it\\'s not possible to form subarrays of length k.\\n1. Calculate the average for the first element in the subarray by dividing the sum of elements from index L + k to index L by r.\\n1. Use a loop to calculate the averages for the remaining elements. For each index i in the range (L + 1, H), calculate the average by subtracting the prefix sum at index c (which represents the starting index of the previous subarray) from the prefix sum at index i + k, and then dividing the result by r.\\n1. Increment c in each iteration to update the starting index of the previous subarray.\\n1. Return the ans array containing the calculated averages.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        # Get the length of the nums list\\n        n = len(nums)\\n        \\n        # Handle edge cases\\n        if n == 1:\\n            if k < n:\\n                return nums\\n            return [-1]\\n        \\n        if k > n:\\n            return [-1] * n\\n        \\n        # Initialize prefix sum array\\n        psum = [0] * n\\n        psum[0] = nums[0]\\n        \\n        # Calculate the prefix sum\\n        for i in range(1, n):\\n            psum[i] = psum[i - 1] + nums[i]\\n        \\n        # Define the lower and upper limits for calculating averages\\n        L = k\\n        H = n - k\\n        \\n        # Initialize the answer array with -1\\n        ans = [-1] * n\\n        \\n        # Calculate the range of values for averaging\\n        r = 2 * k + 1\\n        \\n        # If the range is larger than the total number of elements, return the answer array\\n        if r > n:\\n            return ans\\n        \\n        # Calculate the average for the first element\\n        ans[L] = psum[L + k] // r\\n        \\n        c = 0\\n        # Calculate the averages for the remaining elements\\n        for i in range(L + 1, H):\\n            ans[i] = (psum[i + k] - psum[c]) // r\\n            c += 1\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        # Get the length of the nums list\\n        n = len(nums)\\n        \\n        # Handle edge cases\\n        if n == 1:\\n            if k < n:\\n                return nums\\n            return [-1]\\n        \\n        if k > n:\\n            return [-1] * n\\n        \\n        # Initialize prefix sum array\\n        psum = [0] * n\\n        psum[0] = nums[0]\\n        \\n        # Calculate the prefix sum\\n        for i in range(1, n):\\n            psum[i] = psum[i - 1] + nums[i]\\n        \\n        # Define the lower and upper limits for calculating averages\\n        L = k\\n        H = n - k\\n        \\n        # Initialize the answer array with -1\\n        ans = [-1] * n\\n        \\n        # Calculate the range of values for averaging\\n        r = 2 * k + 1\\n        \\n        # If the range is larger than the total number of elements, return the answer array\\n        if r > n:\\n            return ans\\n        \\n        # Calculate the average for the first element\\n        ans[L] = psum[L + k] // r\\n        \\n        c = 0\\n        # Calculate the averages for the remaining elements\\n        for i in range(L + 1, H):\\n            ans[i] = (psum[i + k] - psum[c]) // r\\n            c += 1\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659083,
                "title": "python-short-and-clean-code-sliding-window",
                "content": "# Intuition\\nIt is intuitive to use `Sliding Window` in this problem since there are only two numbers difference between the current window and the previous one.\\n\\n# Approach\\n1. initialize `avgs`\\n2. check if it is necessary to continue\\n3. build the first window\\n4. Slide the window\\n5. return `avgs`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: list[int], k: int) -> list[int]:\\n        n = len(nums)\\n        avgs = [-1] * n\\n        window_size = 2 * k + 1\\n\\n        # Early stop\\n        if n < window_size:\\n            return avgs\\n\\n        # Build our first window\\n        window = nums[k]\\n        for i in range(1, k + 1):\\n            window += nums[k + i] + nums[k - i]\\n        avgs[k] = window // window_size\\n\\n        # Just let it traverse the list\\n        for i in range(k + 1, n - k):\\n            window += nums[i + k] - nums[i - k - 1]\\n            avgs[i] = window // window_size\\n\\n        return avgs\\n```\\n![image.png](https://assets.leetcode.com/users/images/ee8e6862-3a29-4a39-a236-054816605d91_1687224437.9701416.png)\\n\\n**THX for reading.\\nI would appreciate it very much if you would upvote this.**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: list[int], k: int) -> list[int]:\\n        n = len(nums)\\n        avgs = [-1] * n\\n        window_size = 2 * k + 1\\n\\n        # Early stop\\n        if n < window_size:\\n            return avgs\\n\\n        # Build our first window\\n        window = nums[k]\\n        for i in range(1, k + 1):\\n            window += nums[k + i] + nums[k - i]\\n        avgs[k] = window // window_size\\n\\n        # Just let it traverse the list\\n        for i in range(k + 1, n - k):\\n            window += nums[i + k] - nums[i - k - 1]\\n            avgs[i] = window // window_size\\n\\n        return avgs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599974,
                "title": "javascript-sliding-window",
                "content": "```javascript\\nvar getAverages = function(nums, k) {\\n    const twoK = 2 * k;\\n    const windowSize = twoK + 1;\\n    \\n    const result = [...nums].fill(-1);\\n    let sum = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        if (i >= twoK) {\\n            result[i - k] = Math.floor(sum / windowSize)\\n            sum -= nums[i - twoK];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```javascript\\nvar getAverages = function(nums, k) {\\n    const twoK = 2 * k;\\n    const windowSize = twoK + 1;\\n    \\n    const result = [...nums].fill(-1);\\n    let sum = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        if (i >= twoK) {\\n            result[i - k] = Math.floor(sum / windowSize)\\n            sum -= nums[i - twoK];\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1599968,
                "title": "c-simple-sliding-window-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> ans(n , -1);\\n        \\n        if(2 * k + 1 > n) return ans;\\n        \\n        \\n        // Simple Sliding Window\\n        \\n        long long int sum = 0;\\n        \\n        // Take a window of size 2 * k + 1\\n        for(int i =0 ; i < 2 * k + 1 ; i++) {\\n            sum += nums[i];\\n        }\\n        \\n        ans[k] = sum / (2 * k + 1);\\n        \\n        // Then slide it untill the end of the window reaches at the end\\n        \\n        for(int i = 2 * k + 1 , j = k + 1, s = 0; i < n ; i++ , j++, s++) {\\n            \\n            sum += nums[i];\\n            sum -= nums[s];\\n            ans[j] = sum /(2 * k + 1);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> ans(n , -1);\\n        \\n        if(2 * k + 1 > n) return ans;\\n        \\n        \\n        // Simple Sliding Window\\n        \\n        long long int sum = 0;\\n        \\n        // Take a window of size 2 * k + 1\\n        for(int i =0 ; i < 2 * k + 1 ; i++) {\\n            sum += nums[i];\\n        }\\n        \\n        ans[k] = sum / (2 * k + 1);\\n        \\n        // Then slide it untill the end of the window reaches at the end\\n        \\n        for(int i = 2 * k + 1 , j = k + 1, s = 0; i < n ; i++ , j++, s++) {\\n            \\n            sum += nums[i];\\n            sum -= nums[s];\\n            ans[j] = sum /(2 * k + 1);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599864,
                "title": "c-prefix-array-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int size=nums.size();\\n        vector<int>ans(size,-1);\\n        vector<long long>pre(size,0);\\n        long long a=0;\\n        // make prefix array\\n        for(int i=0;i<size;i++){\\n            a+=nums[i];\\n            pre[i]=a;\\n        }\\n        for(int i=0;i<size;i++){\\n            // if all the 2k+1 elements are not in the array then assign -1(default value in my case)\\n            if(i-k<0 || i+k>=size)\\n                continue;\\n            else{\\n                // if 2k+1 elements start from the 0th index then use pre[i+k]\\n                if(i-k==0)\\n                    ans[i]=pre[i+k]/(2*k+1);\\n                // else we have to subtract pre[i-k-1] from pre[i+k] for getting the sum of the range\\n                else\\n                   ans[i]=(pre[i+k]-pre[i-k-1])/(2*k+1); \\n        }\\n        }\\n    return ans;\\n}\\n};\\n```\\nDo **UPVOTE** if it helps:)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int size=nums.size();\\n        vector<int>ans(size,-1);\\n        vector<long long>pre(size,0);\\n        long long a=0;\\n        // make prefix array\\n        for(int i=0;i<size;i++){\\n            a+=nums[i];\\n            pre[i]=a;\\n        }\\n        for(int i=0;i<size;i++){\\n            // if all the 2k+1 elements are not in the array then assign -1(default value in my case)\\n            if(i-k<0 || i+k>=size)\\n                continue;\\n            else{\\n                // if 2k+1 elements start from the 0th index then use pre[i+k]\\n                if(i-k==0)\\n                    ans[i]=pre[i+k]/(2*k+1);\\n                // else we have to subtract pre[i-k-1] from pre[i+k] for getting the sum of the range\\n                else\\n                   ans[i]=(pre[i+k]-pre[i-k-1])/(2*k+1); \\n        }\\n        }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661642,
                "title": "the-most-clean-and-neat-solution-in-python",
                "content": "# Python Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        result = [-1 for i in range(n)]\\n        if k == 0:\\n            return nums\\n        leftSum = [0 for i in range(n)]\\n        leftSum[0] = nums[0]\\n        for i in range(1,len(nums)):\\n            leftSum[i] = (leftSum[i-1]+nums[i])\\n        for i in range(k,n-k):\\n            if i == k:\\n                result[i] = leftSum[i+k]//(2*k+1)\\n            else:\\n                result[i] = (leftSum[i+k]-leftSum[i-k-1])//(2*k+1)\\n        return result\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n---",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        result = [-1 for i in range(n)]\\n        if k == 0:\\n            return nums\\n        leftSum = [0 for i in range(n)]\\n        leftSum[0] = nums[0]\\n        for i in range(1,len(nums)):\\n            leftSum[i] = (leftSum[i-1]+nums[i])\\n        for i in range(k,n-k):\\n            if i == k:\\n                result[i] = leftSum[i+k]//(2*k+1)\\n            else:\\n                result[i] = (leftSum[i+k]-leftSum[i-k-1])//(2*k+1)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660550,
                "title": "c-easiest-solution-beginners-friendly-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUPVOTE PLS:-\\ncomment your queries below:- \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans(n,-1);\\n      int j=0, i=0;\\n      long long sum=0;\\n        while(j<n){\\n            sum +=nums[j];\\n             if(j-i+1<2*k+1){\\n                j++;\\n                   }\\n          else if(j-i+1==2*k+1){ \\n                ans[i+k]=sum/(2*k+1);\\n                sum-=nums[i];\\n                i++;\\n                j++;\\n                \\n            }\\n             else {\\n                break;\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans(n,-1);\\n      int j=0, i=0;\\n      long long sum=0;\\n        while(j<n){\\n            sum +=nums[j];\\n             if(j-i+1<2*k+1){\\n                j++;\\n                   }\\n          else if(j-i+1==2*k+1){ \\n                ans[i+k]=sum/(2*k+1);\\n                sum-=nums[i];\\n                i++;\\n                j++;\\n                \\n            }\\n             else {\\n                break;\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659533,
                "title": "sliding-window-o-n-solution",
                "content": "# Intuition\\n###### Maintain a window of size (2*k+1). Slide it from left to right and change the window sum accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If k==0,the answer corresponds to the value of nums itself.\\n- If the window size is greater than input size, then the result is all -1 because we can\\'t fit a window in that input.\\n- In order to address cases where a radius/window cannot be established at the initial indices, the result vector is populated with k instances of -1.\\n- The sum of the window size is maintained, and upon division by the window size, the value is appended to the result vector.\\n- At every iteration next number is added and previous number is removed from the sum of window size variable.\\n- Finally, k instances of -1 are again appended to the result vector.(because window can\\'t be made).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void fill_neg_ones(vector<int> &result, int k)\\n    {\\n        for(int i = 0;i<k;i++)\\n        {\\n            result.push_back(-1);\\n        }\\n\\n        return;\\n    }\\n    vector<int> getAverages(vector<int>& nums, int k)\\n    {\\n\\n        if(k==0)\\n        {\\n            return nums;\\n        }\\n\\n\\n        int window_size = 2*k + 1;\\n        \\n        if(nums.size()<window_size)\\n        {\\n            vector<int> result(nums.size(),-1);\\n            return result;\\n        }\\n\\n        \\n        long long int rad_sum = 0;\\n        vector<int> result;\\n        \\n        fill_neg_ones(result,k);\\n\\n        for(int i = 0;i<window_size;i++)\\n        {\\n            rad_sum+=nums[i];\\n        }\\n\\n        result.push_back(rad_sum/window_size);\\n\\n        int remove_index = 0;\\n        int add_index = window_size;\\n\\n        while(add_index<nums.size())\\n        {\\n            rad_sum = (rad_sum - nums[remove_index++] + nums[add_index++]);\\n            result.push_back(rad_sum/(window_size));\\n        }\\n\\n        fill_neg_ones(result,k);\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void fill_neg_ones(vector<int> &result, int k)\\n    {\\n        for(int i = 0;i<k;i++)\\n        {\\n            result.push_back(-1);\\n        }\\n\\n        return;\\n    }\\n    vector<int> getAverages(vector<int>& nums, int k)\\n    {\\n\\n        if(k==0)\\n        {\\n            return nums;\\n        }\\n\\n\\n        int window_size = 2*k + 1;\\n        \\n        if(nums.size()<window_size)\\n        {\\n            vector<int> result(nums.size(),-1);\\n            return result;\\n        }\\n\\n        \\n        long long int rad_sum = 0;\\n        vector<int> result;\\n        \\n        fill_neg_ones(result,k);\\n\\n        for(int i = 0;i<window_size;i++)\\n        {\\n            rad_sum+=nums[i];\\n        }\\n\\n        result.push_back(rad_sum/window_size);\\n\\n        int remove_index = 0;\\n        int add_index = window_size;\\n\\n        while(add_index<nums.size())\\n        {\\n            rad_sum = (rad_sum - nums[remove_index++] + nums[add_index++]);\\n            result.push_back(rad_sum/(window_size));\\n        }\\n\\n        fill_neg_ones(result,k);\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659436,
                "title": "python-3-7-lines-w-explanation-t-m-98-97",
                "content": "Here\\'s how the code works:\\n\\n- The variables `n` and `diam` are initialized, in which `n` represents `len(nums)`, and `diam` represents the diameter of the subarray `(2 * k + 1)`.\\n\\n- If the `len(nums)` is less than `diam`, then there are not enough elements to form a subarray of size `diam`. In this case, the code returns a list of -1s with length`len(nums)`. \\n\\n- The variable `ans` is initialized as a list of -1s with length `k`.\\n\\n- `arr`collects the cumulative sums of `nums`.\\n\\n- A loop iterates over `nums` over which a subarray of `len(diam)` can be formed.\\n\\n- Inside the loop, the `k`-radius average for the subarray centered at index `i` is calculated using the formula `(arr[i + diam] - arr[i]) // diam`. Here, `arr[i + diam]` represents the cumulative sum up to the right end of the subarray, and `arr[i]` represents the cumulative sum up to the left end of the subarray. The difference between these two cumulative sums integer-divided by `diam` gives the average.\\n\\n- The calculated average is appended to`ans`.\\n\\n- After the loop, `ans` is concatenated with `k` -1s at the end using the + operator.\\n\\n- `ans`, which contains the `k`-radius averages for each subarray centered at each index, is returned as the final result.  *--ChatGPT*\\n```\\nclass Solution:\\n    def getAverages(self, nums: list[int], k: int) -> list[int]:\\n\\n        n, diam = len(nums), 2*k+1\\n        if n < diam: return [-1]*n\\n\\n        ans = [-1]*k\\n\\n        arr = list(accumulate(nums, initial = 0))\\n\\n        for i in range(n-diam+1):\\n            ans.append((arr[i+diam]-arr[i])//diam)\\n\\n        return  ans + [-1]*k\\n```\\n[https://leetcode.com/problems/k-radius-subarray-averages/submissions/975198055/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: list[int], k: int) -> list[int]:\\n\\n        n, diam = len(nums), 2*k+1\\n        if n < diam: return [-1]*n\\n\\n        ans = [-1]*k\\n\\n        arr = list(accumulate(nums, initial = 0))\\n\\n        for i in range(n-diam+1):\\n            ans.append((arr[i+diam]-arr[i])//diam)\\n\\n        return  ans + [-1]*k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659314,
                "title": "sliding-window-py",
                "content": "# Approach\\nSliding_Window\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n![](https://cdn.hashnode.com/res/hashnode/image/upload/v1653169623956/S71q7bcr7.gif)\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        a=k                                   # number of \\'-1\\'\\n        k=2*k+1\\n        if len(nums)<k:return [-1]*len(nums)\\n        ans,sm=[-1]*a,0\\n        for i in range(k):sm+=nums[i]\\n        ans.append(sm//k)\\n        for i in range(len(nums)-k):          # Sliding window start\\n            sm-=nums[i]\\n            sm+=nums[i+k]\\n            ans.append(sm//k)\\n        for i in range(a):ans.append(-1)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        a=k                                   # number of \\'-1\\'\\n        k=2*k+1\\n        if len(nums)<k:return [-1]*len(nums)\\n        ans,sm=[-1]*a,0\\n        for i in range(k):sm+=nums[i]\\n        ans.append(sm//k)\\n        for i in range(len(nums)-k):          # Sliding window start\\n            sm-=nums[i]\\n            sm+=nums[i+k]\\n            ans.append(sm//k)\\n        for i in range(a):ans.append(-1)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659186,
                "title": "c-clean-code-sliding-window-o-n",
                "content": "We just add the sum of 2k values in advance in the sum variable and when start with the index having k elements to its left, we add the i+kth index value, calculate avg and subtract i-kth index value to maintain our 2k+1 window size. Easy.\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> avg(n,-1);\\n        if(2*k+1>n) return avg;\\n        long long sum=0;\\n        int z=0;\\n        while(z<2*k && z<n){\\n            sum+=nums[z++];\\n        }\\n        for(int i=k;i<n && n-i-1>=k;i++){\\n            sum += nums[i+k];\\n            avg[i] = sum/(2*k+1);\\n            sum -= nums[i-k];\\n        }\\n        return avg;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> avg(n,-1);\\n        if(2*k+1>n) return avg;\\n        long long sum=0;\\n        int z=0;\\n        while(z<2*k && z<n){\\n            sum+=nums[z++];\\n        }\\n        for(int i=k;i<n && n-i-1>=k;i++){\\n            sum += nums[i+k];\\n            avg[i] = sum/(2*k+1);\\n            sum -= nums[i-k];\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659072,
                "title": "time-o-n-space-o-ans-array-c-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size(),i;\\n        long long int s=0;\\n        vector<int> ans(n,-1);\\n        for(i=0;i<n;i++){\\n            if(i<2*k){\\n                s+= nums[i];\\n            }else{\\n                s+=nums[i];\\n                ans[i-k] = s/(2*k+1);\\n                s -= nums[i-(2*k)];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size(),i;\\n        long long int s=0;\\n        vector<int> ans(n,-1);\\n        for(i=0;i<n;i++){\\n            if(i<2*k){\\n                s+= nums[i];\\n            }else{\\n                s+=nums[i];\\n                ans[i-k] = s/(2*k+1);\\n                s -= nums[i-(2*k)];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658976,
                "title": "sliding-window-o-n-explaination-through-illustration-image-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep a fixed-length sliding window of length 2k + 1. Slide it from left to right, and update the sum of the window on the fly.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$$Sliding Window$$\\n\\n\\nLet **len = 2*k + 1.**\\n\\nIf **N < len**, return all -1s directly because this array is too short to cover any window\\n\\nOtherwise, loop i from 0 to N-1:\\n\\nPush **A[i]** into the window. **sum += A[i]**\\nPop **A[i-len]** out of the window. **sum -= A[i - len]**\\nAssign the average value. **ans[i - k] = sum / len**\\n\\n![a410ce10-f0b6-47bc-acd0-334c707e059a_1654662681.7457461.png](https://assets.leetcode.com/users/images/4e4f1714-b929-4960-8bba-0eb8773ed199_1687220319.3085337.png)\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) \\n    {\\n        long long n = nums.size();\\n        long long int sum = 0, i = 0;\\n\\n        vector<int> ans(n, -1);  // intializing vector by -1\\n\\n        if(n < 2 * k) \\n            return ans;\\n\\n        if(k==0) \\n           return nums;\\n        \\n        int p = k * 2 + 1; // window size \\n        int j=0;\\n        while(j<n)\\n        {\\n            sum += nums[j];\\n            if(j - i + 1 == p) \\n            {\\n                ans[j - k] = sum / p;\\n                sum -= nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Guys Please upvote if you like approach.....\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) \\n    {\\n        long long n = nums.size();\\n        long long int sum = 0, i = 0;\\n\\n        vector<int> ans(n, -1);  // intializing vector by -1\\n\\n        if(n < 2 * k) \\n            return ans;\\n\\n        if(k==0) \\n           return nums;\\n        \\n        int p = k * 2 + 1; // window size \\n        int j=0;\\n        while(j<n)\\n        {\\n            sum += nums[j];\\n            if(j - i + 1 == p) \\n            {\\n                ans[j - k] = sum / p;\\n                sum -= nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Guys Please upvote if you like approach.....\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641622,
                "title": "go-solution-great-explanation-and-full-description",
                "content": "# Intuition\\nThe problem requires us to find the average of a subarray of size `2k + 1` for each element in the array, where `k` is the number of elements on either side of the current element. The twist is that if an element does not have `k` elements on either side, it should be assigned `-1`. \\n\\nA direct approach to calculate the average for each position would be to sum all `2k + 1` elements for each position and then divide the sum by `2k + 1`. However, this would involve recalculating the sum of `2k` elements for each position, which is inefficient.\\n\\nA more efficient way is to use a sliding window approach, where we keep a running sum of the last `2k + 1` elements and slide this window through the array. This way, when we move the window one step to the right, we can update the sum by subtracting the element that is now outside the window on the left and adding the new element from the right. This method requires each element to be processed only twice, which is significantly more efficient for large inputs.\\n\\n# Approach\\nWe initialize the `div` and `sum` variables to `2k + 1` and `0`, respectively. The `div` variable will be used to divide the sum to calculate the average, while the `sum` variable will be used to store the sum of the current subarray.\\n\\nWe then create a prefix array to store the averages and iterate over `nums`. For each element at index `i`, if `i` is less than `k` or `i` is greater than or equal to the length of `nums` minus `k`, we set the corresponding value in the prefix array to `-1` as it does not have `k` elements on either side.\\n\\nIf the element does have `k` elements on both sides, we check if `sum` is `0`. If it is, we calculate the sum of all elements in the subarray of size `2k + 1` centered on the element. If `sum` is not `0`, it means we have a previous sum. We subtract the first element of the previous subarray and add the last element of the current subarray to `sum`. After that, we divide `sum` by `div` to get the average and store it in the prefix array.\\n\\nFinally, we return the prefix array which contains the averages for all elements in `nums`.\\n\\n# Complexity\\n- Time complexity: The time complexity for this algorithm is O(n), where `n` is the length of the `nums` array. This is because we only calculate the sum of the subarray once and then adjust it for subsequent elements, resulting in a constant time complexity per element.\\n\\n- Space complexity: The space complexity is O(n), as we create an array of the same size as the `nums` array.\\n\\n# Code\\n```go\\nfunc getAverages(nums []int, k int) []int {\\n    if k==0{\\n        return nums\\n    }\\n    div,sum:=2*k+1,0\\n    \\n    prefix:=make([]int,len(nums))\\n    for i:=0;i<len(nums);i++{\\n        if i<k || i>=len(nums)-k{\\n            prefix[i]=-1\\n            continue\\n        }\\n        if sum==0{\\n            for j:=i-k;j<=i+k;j++{\\n                sum+=nums[j]\\n            }   \\n        }else{\\n            sum-=nums[i-k-1]\\n            sum+=nums[i+k]\\n        }\\n        prefix[i]=sum/div\\n    }\\n    return prefix\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc getAverages(nums []int, k int) []int {\\n    if k==0{\\n        return nums\\n    }\\n    div,sum:=2*k+1,0\\n    \\n    prefix:=make([]int,len(nums))\\n    for i:=0;i<len(nums);i++{\\n        if i<k || i>=len(nums)-k{\\n            prefix[i]=-1\\n            continue\\n        }\\n        if sum==0{\\n            for j:=i-k;j<=i+k;j++{\\n                sum+=nums[j]\\n            }   \\n        }else{\\n            sum-=nums[i-k-1]\\n            sum+=nums[i+k]\\n        }\\n        prefix[i]=sum/div\\n    }\\n    return prefix\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600127,
                "title": "java-prefix-sum-sliding-window",
                "content": "* Here window size = radius\\n* The first k and last k value will be -1\\n* The sum of window ith is ```pre[i+k+1] - pre[i-k]```\\n**Solution 1: Prefix Array + Sliding Window**\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n=nums.length, radius = 2*k+1;\\n        long pre[] = new long[n+1]; // use long because integer overflow\\n        for(int i=0; i<n; i++){\\n            pre[i+1] = pre[i] + nums[i];\\n        }\\n        \\n        int res[] = new int[n];\\n        Arrays.fill(res, -1);\\n        for(int i=k; i<n-k; i++){\\n            res[i] = (int) ((pre[i+k+1] - pre[i-k]) / radius);\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```pre[i+k+1] - pre[i-k]```\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n=nums.length, radius = 2*k+1;\\n        long pre[] = new long[n+1]; // use long because integer overflow\\n        for(int i=0; i<n; i++){\\n            pre[i+1] = pre[i] + nums[i];\\n        }\\n        \\n        int res[] = new int[n];\\n        Arrays.fill(res, -1);\\n        for(int i=k; i<n-k; i++){\\n            res[i] = (int) ((pre[i+k+1] - pre[i-k]) / radius);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599834,
                "title": "c-easy-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         vector<int> result(nums.size(),-1);\\n        vector<long long> c(nums.size());\\n        c[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            c[i]=c[i-1]+nums[i];\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i-k>=0 && i+k<nums.size())\\n            {\\n                int b=i+k;\\n                int a=i-k;\\n                long long n=(2*k)+1;\\n                long long val=c[b];\\n                if(a>0)\\n                    val-=c[a-1];\\n                result[i]=val/n;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         vector<int> result(nums.size(),-1);\\n        vector<long long> c(nums.size());\\n        c[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            c[i]=c[i-1]+nums[i];\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i-k>=0 && i+k<nums.size())\\n            {\\n                int b=i+k;\\n                int a=i-k;\\n                long long n=(2*k)+1;\\n                long long val=c[b];\\n                if(a>0)\\n                    val-=c[a-1];\\n                result[i]=val/n;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662973,
                "title": "easy-java-solution-beginner-friendly",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Arrays.fill(ans,-1);\\n        int windowSize = 2*k+1;\\n        if(n < windowSize){\\n            return ans;\\n        }\\n        int start = 0;\\n        int end = windowSize-1;\\n        long currSum = 0;\\n        for(int i = 0 ; i < windowSize-1; i ++){\\n            currSum += nums[i];\\n        }\\n        for(int i = k; i < n; i ++){\\n            if(i + k >= n){\\n                break;\\n            }\\n            currSum += nums[end++];\\n            ans[i] = (int)(currSum/windowSize);\\n            currSum -= nums[start++];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.\\nHappy Coding**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Arrays.fill(ans,-1);\\n        int windowSize = 2*k+1;\\n        if(n < windowSize){\\n            return ans;\\n        }\\n        int start = 0;\\n        int end = windowSize-1;\\n        long currSum = 0;\\n        for(int i = 0 ; i < windowSize-1; i ++){\\n            currSum += nums[i];\\n        }\\n        for(int i = k; i < n; i ++){\\n            if(i + k >= n){\\n                break;\\n            }\\n            currSum += nums[end++];\\n            ans[i] = (int)(currSum/windowSize);\\n            currSum -= nums[start++];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662483,
                "title": "c-easiest-explanation-2-approaches-codestorywithmik",
                "content": "YouTube Link - [K Radius Subarray Averages - Prefix Sum Method](https://www.youtube.com/watch?v=RSE_GB0eBZY)\\nYouTube Link - [K Radius Subarray Averages - Sliding Window Method](https://www.youtube.com/watch?v=M_YXCATc4ro)\\nMy Github Treasure - [Click to see](https://github.com/MAZHARMIK/Interview_DS_Algo)\\n\\n\\n```\\n//Approach-1 (Using Prefix Array)\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        if(k == 0)\\n            return nums;\\n    \\n        vector<int> result(n, -1);\\n        \\n        if(n < 2*k + 1)\\n            return result;\\n        \\n        vector<long long> prefixSum(n, 0);\\n        prefixSum[0] = nums[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n            \\n        }\\n\\n        for(int i = k; i<n-k; i++) {\\n            \\n            int left_idx  = i-k;\\n            int right_idx = i+k;\\n            \\n            long long sum = prefixSum[right_idx];\\n            \\n            if(left_idx > 0)\\n                sum -= prefixSum[left_idx-1];\\n            \\n            \\n            int avg = sum/(2*k+1);\\n            \\n            result[i] = avg;\\n            \\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```\\n\\n```\\n//Approach-2 : Using Sliding Window\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        if(k == 0)\\n            return nums;\\n    \\n        vector<int> result(n, -1);\\n        \\n        if(n < 2*k + 1)\\n            return result;\\n        \\n        long long windowSum = 0;\\n        \\n        int left  = 0;\\n        int right = 2*k;\\n        int i     = k;\\n        \\n        for(int i = left; i <= right; i++) {\\n            windowSum += nums[i];\\n        }\\n        \\n        \\n        result[i] = windowSum/(2*k+1);\\n        \\n        i++;\\n        right++; //Shifting window\\n        \\n        while(right < n) {\\n            \\n            int out_of_window  = nums[left];\\n            int came_to_window = nums[right];\\n            \\n            windowSum = windowSum - out_of_window + came_to_window;\\n            \\n            result[i] = windowSum/(2*k+1);\\n            i++;\\n            left++;\\n            right++;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using Prefix Array)\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        if(k == 0)\\n            return nums;\\n    \\n        vector<int> result(n, -1);\\n        \\n        if(n < 2*k + 1)\\n            return result;\\n        \\n        vector<long long> prefixSum(n, 0);\\n        prefixSum[0] = nums[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n            \\n        }\\n\\n        for(int i = k; i<n-k; i++) {\\n            \\n            int left_idx  = i-k;\\n            int right_idx = i+k;\\n            \\n            long long sum = prefixSum[right_idx];\\n            \\n            if(left_idx > 0)\\n                sum -= prefixSum[left_idx-1];\\n            \\n            \\n            int avg = sum/(2*k+1);\\n            \\n            result[i] = avg;\\n            \\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```\n```\\n//Approach-2 : Using Sliding Window\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        if(k == 0)\\n            return nums;\\n    \\n        vector<int> result(n, -1);\\n        \\n        if(n < 2*k + 1)\\n            return result;\\n        \\n        long long windowSum = 0;\\n        \\n        int left  = 0;\\n        int right = 2*k;\\n        int i     = k;\\n        \\n        for(int i = left; i <= right; i++) {\\n            windowSum += nums[i];\\n        }\\n        \\n        \\n        result[i] = windowSum/(2*k+1);\\n        \\n        i++;\\n        right++; //Shifting window\\n        \\n        while(right < n) {\\n            \\n            int out_of_window  = nums[left];\\n            int came_to_window = nums[right];\\n            \\n            windowSum = windowSum - out_of_window + came_to_window;\\n            \\n            result[i] = windowSum/(2*k+1);\\n            i++;\\n            left++;\\n            right++;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661946,
                "title": "very-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> ans;\\n\\n        if(nums.size()>=2*k+1)\\n        {\\n            int i=0,j=2*k+1;\\n            long long int sum=0;\\n            for(int p=0;p<2*k+1;p++) \\n                sum+=nums[p];\\n            for(int i=0;i<k;i++)\\n                ans.push_back(-1);\\n            while(j<nums.size())\\n            {\\n                ans.push_back(sum/(2*k+1));\\n                sum+=nums[j]-nums[i];\\n                j++;\\n                i++;\\n            }\\n\\n            ans.push_back(sum/(2*k+1));\\n        }\\n        while(ans.size()<nums.size()) \\n            ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> ans;\\n\\n        if(nums.size()>=2*k+1)\\n        {\\n            int i=0,j=2*k+1;\\n            long long int sum=0;\\n            for(int p=0;p<2*k+1;p++) \\n                sum+=nums[p];\\n            for(int i=0;i<k;i++)\\n                ans.push_back(-1);\\n            while(j<nums.size())\\n            {\\n                ans.push_back(sum/(2*k+1));\\n                sum+=nums[j]-nums[i];\\n                j++;\\n                i++;\\n            }\\n\\n            ans.push_back(sum/(2*k+1));\\n        }\\n        while(ans.size()<nums.size()) \\n            ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661838,
                "title": "c-prefix-sum-fast-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (k==0) return nums;\\n        if (k>nums.size()) {\\n            return vector<int> (nums.size(),-1);\\n        }\\n        vector<long long int> pref(nums.size(),-1);\\n        pref[0]=nums[0];\\n        vector<int> avgs(nums.size(),-1);\\n        //prefix sum\\n        for (int i=1;i<nums.size();i++) {\\n            pref[i]=pref[i-1]+nums[i];\\n        }\\n        for (int i=k;i<nums.size()-k;i++) {\\n            if (i!=k) avgs[i]=(pref[i+k]-pref[i-k-1])/(2*k+1);\\n            else avgs[i]=(pref[i+k]/(2*k+1));\\n        }\\n        return avgs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (k==0) return nums;\\n        if (k>nums.size()) {\\n            return vector<int> (nums.size(),-1);\\n        }\\n        vector<long long int> pref(nums.size(),-1);\\n        pref[0]=nums[0];\\n        vector<int> avgs(nums.size(),-1);\\n        //prefix sum\\n        for (int i=1;i<nums.size();i++) {\\n            pref[i]=pref[i-1]+nums[i];\\n        }\\n        for (int i=k;i<nums.size()-k;i++) {\\n            if (i!=k) avgs[i]=(pref[i+k]-pref[i-k-1])/(2*k+1);\\n            else avgs[i]=(pref[i+k]/(2*k+1));\\n        }\\n        return avgs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660797,
                "title": "python-elegant-short-sliding-window-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n\\n        # Initially all equal -1\\n        averages = [-1] * n\\n\\n        # Sliding sum initialization\\n        window = sum(nums[:2 * k])\\n\\n        for i in range(k, n - k):\\n            window += nums[i + k]\\n            averages[i] = window // (2 * k + 1)\\n            window -= nums[i - k]\\n\\n        return averages\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n\\n        # Initially all equal -1\\n        averages = [-1] * n\\n\\n        # Sliding sum initialization\\n        window = sum(nums[:2 * k])\\n\\n        for i in range(k, n - k):\\n            window += nums[i + k]\\n            averages[i] = window // (2 * k + 1)\\n            window -= nums[i - k]\\n\\n        return averages\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660444,
                "title": "c-optimized-fully-explained-prefix-sum-64bit-integer",
                "content": "# Intuition\\nTo find the averages of subarrays, we can utilize the concept of **Partial Sum**. By calculating the partial sum of the input array v, we can efficiently compute the sum of any subarray. By subtracting the sum of the subarray\\'s left boundary (of length k) from the sum of the subarray\\'s right boundary (of length k), we can obtain the sum of the subarray itself. Dividing this sum by 2*k+1 gives us the average of the subarray.\\n\\n# Approach\\n1.Initialize the size of the input array v as n.\\n\\n2.If n is less than 2*k+1, return a new array ans with all elements initialized to -1.\\n\\n3.Create a vector t of type int64_t and copy the elements of v into it.\\n\\n4.Calculate the partial sum of t using the partial_sum function from the STL library.\\n\\n5.Initialize a new array ans of size n with all elements initialized to -1.\\n6.Iterate over the range from k to n - k - 1:\\n- Calculate the sum of the subarray using the partial sum array t.\\n- Subtract the sum of the left boundary subarray (of length k) from the sum of the right boundary subarray (of length k).\\n- Divide the obtained sum by 2*k+1 to get the average of the subarray.\\n- Assign the average to the corresponding element in ans.\\n\\n7.Return the resulting array ans containing the averages of the subarrays.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity:  **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>&v, int k) {\\n        int n=v.size(),e=(2*k+1);vector<int>ans(n,-1);\\n        if(n<(2*k+1)) return ans;\\n        vector<int64_t>t(v.begin(),v.end());\\n        partial_sum(t.begin(),t.end(),t.begin());\\n        for(int i=k;i+k<n;i++){\\n            int64_t u=t[i+k];\\n            if(i-k-1 >=0) u-=t[i-k-1];\\n            ans[i]=u/e;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window",
                    "Iterator",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>&v, int k) {\\n        int n=v.size(),e=(2*k+1);vector<int>ans(n,-1);\\n        if(n<(2*k+1)) return ans;\\n        vector<int64_t>t(v.begin(),v.end());\\n        partial_sum(t.begin(),t.end(),t.begin());\\n        for(int i=k;i+k<n;i++){\\n            int64_t u=t[i+k];\\n            if(i-k-1 >=0) u-=t[i-k-1];\\n            ans[i]=u/e;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660073,
                "title": "prefix-sum-soln",
                "content": "# Approach\\nfirstly we will precompute the prefixsum and suffixsum of the array, which will help in finding the forwardsum and backwardsum for every valid element.\\n              we will run a for loop from index i=k till n-i>k the backsum will be equal to sum of previous k elements and forward sum will be the sum of next k elements which will be find using pefix and suffix array, and then find the avg by adding (curr_element+backsum+forwardsum)/total no.of elements. Total number of elements=(2*k)+1.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<ll>prefix(n,0);\\n        vector<ll>suffix(n,0);\\n        prefix[0]=nums[0];\\n        suffix[n-1]=nums[n-1];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n       \\n        \\n        ll temp=(2*k)+1;\\n        ll j=-1;\\n        ll z=temp;\\n        vector<int>ans(n,-1);\\n        if(k==0){\\n            return nums;\\n        }\\n        for(int i=k;n-i>k;i++){\\n           ll element=nums[i];\\n           ll backsum=prefix[i-1];\\n           if(j!=-1){\\n               backsum-=prefix[j];\\n           }\\n           j++;\\n            ll forward=suffix[i+1];\\n            if(z<n){\\n                forward-=suffix[z];\\n                        \\n            }\\n\\n            z++;\\n            ll sum=element+backsum+forward;\\n           \\n            ll avg=sum/temp;\\n            ans[i]=avg;\\n           \\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<ll>prefix(n,0);\\n        vector<ll>suffix(n,0);\\n        prefix[0]=nums[0];\\n        suffix[n-1]=nums[n-1];\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n       \\n        \\n        ll temp=(2*k)+1;\\n        ll j=-1;\\n        ll z=temp;\\n        vector<int>ans(n,-1);\\n        if(k==0){\\n            return nums;\\n        }\\n        for(int i=k;n-i>k;i++){\\n           ll element=nums[i];\\n           ll backsum=prefix[i-1];\\n           if(j!=-1){\\n               backsum-=prefix[j];\\n           }\\n           j++;\\n            ll forward=suffix[i+1];\\n            if(z<n){\\n                forward-=suffix[z];\\n                        \\n            }\\n\\n            z++;\\n            ll sum=element+backsum+forward;\\n           \\n            ll avg=sum/temp;\\n            ans[i]=avg;\\n           \\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659802,
                "title": "convert-the-problem-to-simple-sliding-window-o-n-c",
                "content": "# Intuition and Approach\\n\\n- Sliding window comes to mind when reading the solution\\n- But before solving it we can convert the problem to a simple sliding window by taking the window size as 2*k + 1\\n- Now simple calculate the total sum for each window with size 2*k+1 and then store it in the middle of the window i.e i - windowSize / 2, where i is index at end of the window\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1), no space other than result is used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        // Size of sliding window\\n        int windowSize = 2 * k + 1;\\n\\n        // Initialize result of size n with all -1\\n        vector<int> result(n, -1);\\n\\n        // using long long for avoiding integer overflow\\n        long long total = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            // Add the element to the total\\n            total += nums[i];\\n         \\n            // If we are at the end of the window then store the result\\n            if(i >= windowSize - 1){\\n                // store the result  \\n                result[i - windowSize / 2] = total / windowSize;\\n\\n                // removing the first element from window to not overflow the window on next iteration\\n                total -= nums[i - windowSize + 1];\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        // Size of sliding window\\n        int windowSize = 2 * k + 1;\\n\\n        // Initialize result of size n with all -1\\n        vector<int> result(n, -1);\\n\\n        // using long long for avoiding integer overflow\\n        long long total = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            // Add the element to the total\\n            total += nums[i];\\n         \\n            // If we are at the end of the window then store the result\\n            if(i >= windowSize - 1){\\n                // store the result  \\n                result[i - windowSize / 2] = total / windowSize;\\n\\n                // removing the first element from window to not overflow the window on next iteration\\n                total -= nums[i - windowSize + 1];\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659384,
                "title": "c-prefix-sum-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->The provided solution calculates the average of subarrays of length `2k + 1` for each index `i` in the given `nums` array. It first calculates the prefix sums of the `nums` array using the `prefsum` array. \\n\\nThen, it iterates through each index `i` and checks if it is at the beginning or end of the array. If so, it sets the result at that index to -1.\\n\\nFor indices that are not at the beginning or end, it uses the prefix sums to calculate the sum of the subarray `[i - k, i + k]` and divides it by the length of the subarray to get the average. The result is stored in the `res` array.\\n\\nFinally, the function returns the `res` array containing the averages.\\n\\nNote: It\\'s worth mentioning that the solution assumes the input vector `nums` has a size greater than or equal to `2k + 1`. If this condition is not met, the solution may produce unexpected results.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The approach to solving the problem involves calculating the averages of subarrays of length `2k + 1` for each index `i` in the given `nums` array. Here is a step-by-step breakdown of the approach:\\n\\n1. Create an empty result array to store the averages.\\n2. Calculate the prefix sums of the `nums` array and store them in the `prefsum` array. This step helps in efficiently calculating the sum of any subarray by subtracting the prefix sum at the start index from the prefix sum at the end index.\\n3. Iterate through each index `i` in the `nums` array.\\n4. Check if the current index `i` is within the valid range to form a subarray of length `2k + 1`. If `i` is less than `k` or greater than or equal to `nums.size() - k`, it means that the subarray cannot be formed, so set the corresponding result value to -1.\\n5. For indices within the valid range, calculate the sum of the subarray `[i - k, i + k]` using the prefix sums. This can be done by subtracting the prefix sum at index `i - k` from the prefix sum at index `i + k`, and adding the element at index `i - k` (to account for its exclusion in the prefix sums).\\n6. Divide the sum obtained in the previous step by the length of the subarray (i.e., `2k + 1`) to obtain the average.\\n7. Store the average in the result array at index `i`.\\n8. Repeat steps 4-7 until all indices are processed.\\n9. Return the result array containing the averages.\\n\\nThis approach efficiently calculates the averages by utilizing prefix sums and avoids redundant calculations by checking the valid range for each index. The time complexity of this approach is O(n), where n is the size of the input array `nums`.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<long> prefsum(nums.size(), 0); // Array to store prefix sums\\n        long sum = 0; // Variable to track the sum of elements\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i]; // Add current element to the sum\\n            prefsum[i] = sum; // Store the prefix sum up to index i\\n        }\\n        vector<int> res(nums.size()); // Array to store the result\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i < k || i >= nums.size() - k)\\n                res[i] = -1; // If the index is at the beginning or end, set result to -1\\n            else {\\n                // Calculate the average using the prefix sums\\n                res[i] = (prefsum[i + k] - prefsum[i - k] + nums[i - k]) / (2 * k + 1);\\n                // Divide the difference of prefix sums by the length of the subarray (2k + 1)\\n            }\\n        }\\n        return res; // Return the result array\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/77f081bb-4480-4d06-816c-628e1596ed3f_1687231895.2803783.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<long> prefsum(nums.size(), 0); // Array to store prefix sums\\n        long sum = 0; // Variable to track the sum of elements\\n        for (int i = 0; i < nums.size(); i++) {\\n            sum += nums[i]; // Add current element to the sum\\n            prefsum[i] = sum; // Store the prefix sum up to index i\\n        }\\n        vector<int> res(nums.size()); // Array to store the result\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i < k || i >= nums.size() - k)\\n                res[i] = -1; // If the index is at the beginning or end, set result to -1\\n            else {\\n                // Calculate the average using the prefix sums\\n                res[i] = (prefsum[i + k] - prefsum[i - k] + nums[i - k]) / (2 * k + 1);\\n                // Divide the difference of prefix sums by the length of the subarray (2k + 1)\\n            }\\n        }\\n        return res; // Return the result array\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659226,
                "title": "c-easy-solution-using-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<long> prefsum(nums.size(), 0);\\n        long sum = 0;\\n        for (int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            prefsum[i] = sum;\\n        }\\n        vector<int> res(nums.size());\\n\\n        for (int i=0; i<nums.size(); i++) {\\n            if (i < k || i >= nums.size() - k)\\n                res[i] = -1;\\n            else {\\n                res[i] = (prefsum[i+k] - prefsum[i-k] + nums[i-k]) / (2 * k + 1);\\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<long> prefsum(nums.size(), 0);\\n        long sum = 0;\\n        for (int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            prefsum[i] = sum;\\n        }\\n        vector<int> res(nums.size());\\n\\n        for (int i=0; i<nums.size(); i++) {\\n            if (i < k || i >= nums.size() - k)\\n                res[i] = -1;\\n            else {\\n                res[i] = (prefsum[i+k] - prefsum[i-k] + nums[i-k]) / (2 * k + 1);\\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659166,
                "title": "k-radius-subarray-averages-optimized-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> v(n, -1); // Initialize the result vector with -1\\n        int temp = (2 * k) + 1; // Calculate the length of the subarray\\n        \\n        if (n < temp)  // Base case 1: If the array size is less than the subarray length, return the result vector with -1s\\n            return v;\\n\\n        if (k == 0)   // Base case 2: If k is 0, each element is its own average, so return the input array itself\\n            return nums;\\n\\n        long long int j = 0, sum = 0, avg = 0; // Initialize variables for index, sum, and average calculations\\n        for (int i = 0; i < n; i++) {\\n            sum = sum + nums[i]; // Add the current element to the sum\\n            \\n            if (i - j + 1 == temp) { // Check if the subarray length reaches the desired length\\n                avg = sum / temp; // Calculate the average of the subarray\\n                \\n                v[i - k] = avg; // Store the average in the result vector at the corresponding index\\n                \\n                sum = sum - nums[j]; // Subtract the element at the beginning of the subarray from the sum\\n                j++; // Increment the starting index of the subarray\\n            }\\n        }\\n        return v; // Return the result vector containing the k-radius averages\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> v(n, -1); // Initialize the result vector with -1\\n        int temp = (2 * k) + 1; // Calculate the length of the subarray\\n        \\n        if (n < temp)  // Base case 1: If the array size is less than the subarray length, return the result vector with -1s\\n            return v;\\n\\n        if (k == 0)   // Base case 2: If k is 0, each element is its own average, so return the input array itself\\n            return nums;\\n\\n        long long int j = 0, sum = 0, avg = 0; // Initialize variables for index, sum, and average calculations\\n        for (int i = 0; i < n; i++) {\\n            sum = sum + nums[i]; // Add the current element to the sum\\n            \\n            if (i - j + 1 == temp) { // Check if the subarray length reaches the desired length\\n                avg = sum / temp; // Calculate the average of the subarray\\n                \\n                v[i - k] = avg; // Store the average in the result vector at the corresponding index\\n                \\n                sum = sum - nums[j]; // Subtract the element at the beginning of the subarray from the sum\\n                j++; // Increment the starting index of the subarray\\n            }\\n        }\\n        return v; // Return the result vector containing the k-radius averages\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658983,
                "title": "java-sliding-window-beats-91-12-lines-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the return array to all `-1` values.\\n2. Only for subarrays that exist of length `2k +1`, compute the sum of all values in the subarray.\\n3. Use a sliding window to advance one element at a time and update the sum by subtracting the element that is exiting the window and adding the element that is joining the window.\\n4. For each valid subarray center element, compute the average by dividing the current sum by the length of the sliding window (`2k + 1`) and store it in the return array.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] getAverages(int[] nums, int k) {\\n    int n = nums.length, K = 2*k + 1, ans[] = new int[n];\\n    var sum = 0L;\\n\\n    Arrays.fill(ans, -1);\\n    if (K > n) return ans;\\n\\n    for (var i = 0; i < K; i++)\\n      sum += nums[i];\\n\\n    ans[k] = (int) (sum / K);\\n    for (var i = k+1; i < n-k; i++) {\\n      sum += nums[i+k] - nums[i-k-1];\\n      ans[i] = (int) (sum / K);\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n  public int[] getAverages(int[] nums, int k) {\\n    int n = nums.length, K = 2*k + 1, ans[] = new int[n];\\n    var sum = 0L;\\n\\n    Arrays.fill(ans, -1);\\n    if (K > n) return ans;\\n\\n    for (var i = 0; i < K; i++)\\n      sum += nums[i];\\n\\n    ans[k] = (int) (sum / K);\\n    for (var i = k+1; i < n-k; i++) {\\n      sum += nums[i+k] - nums[i-k-1];\\n      ans[i] = (int) (sum / K);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333482,
                "title": "c-solution-fast-solution-using-sliding-window",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int[] GetAverages(int[] nums, int k) {\\n        int[] r = new int[nums.Length];\\n        for(int i = 0; i < r.Length;i++) r[i] = -1;\\n        int totalCount = 2 * k + 1;\\n        long sum = 0;\\n        for(int i = 0; i < nums.Length;i++){\\n            sum+= nums[i];\\n            if(i >= 2 * k){\\n                long val = sum / totalCount;\\n                r[i - k] = (int)val;\\n                sum-= nums[i - (2 * k)];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetAverages(int[] nums, int k) {\\n        int[] r = new int[nums.Length];\\n        for(int i = 0; i < r.Length;i++) r[i] = -1;\\n        int totalCount = 2 * k + 1;\\n        long sum = 0;\\n        for(int i = 0; i < nums.Length;i++){\\n            sum+= nums[i];\\n            if(i >= 2 * k){\\n                long val = sum / totalCount;\\n                r[i - k] = (int)val;\\n                sum-= nums[i - (2 * k)];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222321,
                "title": "time-o-n-space-o-n-c",
                "content": "```\\n// OJ: https://leetcode.com/problems/k-radius-subarray-averages/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& A, int k) {\\n        int N = A.size(), len = 2 * k + 1;\\n        vector<int> ans(N, -1);\\n        if (N < len) return ans; // If the array is too short to cover a window, return all -1s\\n        vector<long> sum(N + 1);\\n        for (int i = 0; i < N; ++i) sum[i + 1] = sum[i] + A[i];\\n        for (int i = k; i + k < N; ++i) ans[i] = (sum[i + k + 1] - sum[i - k]) / len;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n// OJ: https://leetcode.com/problems/k-radius-subarray-averages/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& A, int k) {\\n        int N = A.size(), len = 2 * k + 1;\\n        vector<int> ans(N, -1);\\n        if (N < len) return ans; // If the array is too short to cover a window, return all -1s\\n        vector<long> sum(N + 1);\\n        for (int i = 0; i < N; ++i) sum[i + 1] = sum[i] + A[i];\\n        for (int i = k; i + k < N; ++i) ans[i] = (sum[i + k + 1] - sum[i - k]) / len;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555874,
                "title": "using-sliding-window-in-javascript-with-description",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar getAverages = function(nums, k) {\\n    // We can\\'t get average of k numbers if nums is less in length\\n    if (k > nums.length) {\\n        // Means all the numbers in nums are invalid so we return an array with same length of -1        \\n        return Array(nums.length).fill(-1);\\n    }\\n    \\n    // Fill up the array with -1 (could also push -1 each time length is not valid)\\n    const result = Array(nums.length).fill(-1);\\n    \\n    // Our starting window\\n    let left = 0;\\n    // Total before we start averaging\\n    let sum = 0;\\n    // Loop\\n    for (let right = 0; right < nums.length; right++) {\\n        // Add to sum at each iteration\\n        sum += nums[right];\\n\\n        // We check if the amount is equal to the entire length of our window (which is k * 2 + 1)\\n        // Why * 2? because the description says from the index we will have k left and k right. k + index + k\\n        if (right - left + 1 === k * 2 + 1) {\\n            // Get our average\\n            const average = Math.floor(sum / (k * 2 + 1));\\n            // Put it in the result array\\n            result[right - k] = average;\\n            // Close the window by making it smaller.\\n            // Decrease left and sum \\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n\\n    // return result\\n    return result;\\n};\\n```\\n\\nP.S. -> If see better improvement. Welcome to suggestions",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar getAverages = function(nums, k) {\\n    // We can\\'t get average of k numbers if nums is less in length\\n    if (k > nums.length) {\\n        // Means all the numbers in nums are invalid so we return an array with same length of -1        \\n        return Array(nums.length).fill(-1);\\n    }\\n    \\n    // Fill up the array with -1 (could also push -1 each time length is not valid)\\n    const result = Array(nums.length).fill(-1);\\n    \\n    // Our starting window\\n    let left = 0;\\n    // Total before we start averaging\\n    let sum = 0;\\n    // Loop\\n    for (let right = 0; right < nums.length; right++) {\\n        // Add to sum at each iteration\\n        sum += nums[right];\\n\\n        // We check if the amount is equal to the entire length of our window (which is k * 2 + 1)\\n        // Why * 2? because the description says from the index we will have k left and k right. k + index + k\\n        if (right - left + 1 === k * 2 + 1) {\\n            // Get our average\\n            const average = Math.floor(sum / (k * 2 + 1));\\n            // Put it in the result array\\n            result[right - k] = average;\\n            // Close the window by making it smaller.\\n            // Decrease left and sum \\n            sum -= nums[left];\\n            left++;\\n        }\\n    }\\n\\n    // return result\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1999858,
                "title": "python-3-sliding-window",
                "content": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        x = 2*k + 1\\n        n = len(nums)\\n        if x > n:\\n            return [-1] * n\\n        \\n        s = sum(nums[i] for i in range(x))\\n        res = [-1] * k + [s // x]\\n\\n        for i in range(k + 1, n - k):\\n            s += nums[i + k] - nums[i - k - 1]\\n            res.append(s // x)\\n        \\n        res.extend([-1] * k)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        x = 2*k + 1\\n        n = len(nums)\\n        if x > n:\\n            return [-1] * n\\n        \\n        s = sum(nums[i] for i in range(x))\\n        res = [-1] * k + [s // x]\\n\\n        for i in range(k + 1, n - k):\\n            s += nums[i + k] - nums[i - k - 1]\\n            res.append(s // x)\\n        \\n        res.extend([-1] * k)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3661964,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        long sum = 0l;\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res, -1);\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (i >= 2 * k) {\\n                res[i - k] = (int) (sum / (2 * k + 1));\\n                sum -= nums[i - 2 * k];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        long sum = 0l;\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        Arrays.fill(res, -1);\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (i >= 2 * k) {\\n                res[i - k] = (int) (sum / (2 * k + 1));\\n                sum -= nums[i - 2 * k];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661504,
                "title": "c-easy-sliding-window-aditya-verma-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& v, int k) {\\n        int n=v.size();\\n        vector<int> ans(n,-1);\\n        int i=0,j=0;\\n        long long sum=0;\\n        while(j<n){\\n            sum += v[j];\\n            if((j-i+1)==(2*k+1)){\\n                ans[j-k] = sum/(2*k+1);\\n                sum -= v[i];\\n                i++; \\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& v, int k) {\\n        int n=v.size();\\n        vector<int> ans(n,-1);\\n        int i=0,j=0;\\n        long long sum=0;\\n        while(j<n){\\n            sum += v[j];\\n            if((j-i+1)==(2*k+1)){\\n                ans[j-k] = sum/(2*k+1);\\n                sum -= v[i];\\n                i++; \\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660958,
                "title": "c-easy-for-beginners",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        const int n = nums.size();\\n        vector <long> ans(n, -1);\\n        long sum = 0;\\n        vector<int> huh(n, -1);\\n        if(n <= 2*k) return huh;\\n        for(int j = 0; j<=2*k; ++j){\\n            sum += nums[j];\\n        }\\n        \\n        ans[k] = sum;\\n        for(int i=k+1; i<n-k; ++i){\\n            ans[i] = (ans[i-1]-nums[i-k-1]+nums[i+k]);\\n            \\n        }\\n        vector <int> bu;\\n        for(auto &it: ans){\\n            if(it != -1)    it /= (2*k+1);\\n            bu.push_back(it);\\n        }\\n        return bu;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        const int n = nums.size();\\n        vector <long> ans(n, -1);\\n        long sum = 0;\\n        vector<int> huh(n, -1);\\n        if(n <= 2*k) return huh;\\n        for(int j = 0; j<=2*k; ++j){\\n            sum += nums[j];\\n        }\\n        \\n        ans[k] = sum;\\n        for(int i=k+1; i<n-k; ++i){\\n            ans[i] = (ans[i-1]-nums[i-k-1]+nums[i+k]);\\n            \\n        }\\n        vector <int> bu;\\n        for(auto &it: ans){\\n            if(it != -1)    it /= (2*k+1);\\n            bu.push_back(it);\\n        }\\n        return bu;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660796,
                "title": "sliding-window-typescript-solution-in-o-n-explained",
                "content": "# Approach\\n1. Calculate sum for first sliding window, which is always of size `d = k * 2 + 1`.\\n2. Iterate over nums, and if `i < k` or `i > nums.length - k - 1` we push -1 into the output.\\n3. Otherwise we push `sum / d` rounded down to the output array.\\n4. Whenever `i > k`, we add `i + k` element to sum and substract `i - k - 1` from it.\\n5. Finally we return the output array.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) if output array is not considered, O(N) otherwise\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction getAverages(nums: number[], k: number, sum = 0, d = k * 2 + 1, output = []): number[] {\\n  for ( let i = 0; i < d; i++ ) {\\n    sum += nums[i]\\n  }\\n  for ( let i = 0; i < nums.length; i++ ) {\\n    if ( i < k || i > nums.length - k - 1 ) {\\n      output.push(-1)\\n      continue\\n    }\\n    if ( i > k ) {\\n      sum += nums[i + k] - nums[i - k - 1]\\n    }\\n    output.push(Math.floor(sum / d))\\n  }\\n  return output\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nfunction getAverages(nums: number[], k: number, sum = 0, d = k * 2 + 1, output = []): number[] {\\n  for ( let i = 0; i < d; i++ ) {\\n    sum += nums[i]\\n  }\\n  for ( let i = 0; i < nums.length; i++ ) {\\n    if ( i < k || i > nums.length - k - 1 ) {\\n      output.push(-1)\\n      continue\\n    }\\n    if ( i > k ) {\\n      sum += nums[i + k] - nums[i - k - 1]\\n    }\\n    output.push(Math.floor(sum / d))\\n  }\\n  return output\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3660576,
                "title": "optimal-solution-using-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(std::vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> avgs(n, -1);\\n\\n        long long sum = 0; \\n        int count = 0;\\n        for (int i = 0; i <= 2 * k; i++) {\\n            if (i < n) {\\n                sum += nums[i];\\n                count++;\\n            }\\n        }\\n        if (count == 2 * k + 1) {\\n            avgs[k] = sum / count;\\n        }\\n        for (int i = k + 1; i < n - k; i++) {\\n            sum -= nums[i - k - 1];\\n            sum += nums[i + k];\\n            avgs[i] = sum / (2 * k + 1);\\n        }\\n        return avgs;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(std::vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> avgs(n, -1);\\n\\n        long long sum = 0; \\n        int count = 0;\\n        for (int i = 0; i <= 2 * k; i++) {\\n            if (i < n) {\\n                sum += nums[i];\\n                count++;\\n            }\\n        }\\n        if (count == 2 * k + 1) {\\n            avgs[k] = sum / count;\\n        }\\n        for (int i = k + 1; i < n - k; i++) {\\n            sum -= nums[i - k - 1];\\n            sum += nums[i + k];\\n            avgs[i] = sum / (2 * k + 1);\\n        }\\n        return avgs;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660208,
                "title": "easy-c-solution-sliding-window-prefix-sum-o-n-solution",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    \\n    #define ll long long\\n    \\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if(k==0)return nums;\\n        int i=0,j=0,n=nums.size(),p=2*k+1;\\n        vector<int>vect(n,-1);\\n        ll sum=0;\\n        while(j<n){\\n            sum+=nums[j];\\n            if(j>=p-1){\\n                vect[j-k]=sum/p;\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        return vect;\\n        }\\n     };",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public:\\n    \\n    #define ll long long\\n    \\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if(k==0)return nums;\\n        int i=0,j=0,n=nums.size(),p=2*k+1;\\n        vector<int>vect(n,-1);\\n        ll sum=0;\\n        while(j<n){\\n            sum+=nums[j];\\n            if(j>=p-1){\\n                vect[j-k]=sum/p;\\n                sum-=nums[i];\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3660180,
                "title": "very-easy-prefix-suffix-sum-approach-c",
                "content": "# Intuition and Approach\\nThis question is a little bit tricky if we go with Prefix and Suffix Sum Approach\\nBut Worry not I will make it Understandable for you my *nakama*,\\n\\nOkay first understand the prefix sum and suffix sum,\\ni.e. \\n```\\narray=[1,2,3]\\nprefix sum array will be = [1,3,6] -> [1, 1+2, 1+2+3] : adding in forward order\\nsuffix sum array will be = [6,5,3] -> [1+2+3, 2+3, 3] : adding in reverse order\\n```\\n*(You can refer code now and see how I implemented it)*\\nIf you didn\\'t Understand above example then you can refer youtube to know the concept of prefix sum and suffix sum.\\n\\nThere are Three main cases to before we starting to make our answer vector\\n(i) if(k==0) -> then we dont need to prefix and suffix sum using this in the start of the code will result in fast code execution\\nk = no. of element from one side to take\\nso 2*k -> elements from both left and right\\nand `2*k+1` -> above + the element self\\nps. thats how we take average `elements sum/no. of element` \\n\\n(ii) if(k>n/2) -> then we dont have sufficient elements to take from both left and right side at any position of the vector\\n\\n(iii) this include four different cases for which you can refer code\\n\\n \\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<long long> pre,suf; //use long long as constraints are given\\n        vector<int> ans;\\n        long long temp=0,n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n            pre.emplace_back(nums[i]+temp);\\n            temp+=nums[i];\\n        }\\n        temp=0;\\n        for(int i=n-1;i>=0;i--){\\n            suf.emplace_back(nums[i]+temp);\\n            temp+=nums[i];        \\n        }\\n        reverse(suf.begin(),suf.end());\\n        //reversing the array would help to get the suffix array as.. \\n        //..we are inserting the element from start\\n\\n        //Uncommenting below will help you see the prefix and suffix vector\\n        // for(auto val:pre){\\n        //     cout<<val<<\" \";\\n        // }\\n        // cout<<\"\\\\n\";\\n        // for(auto val:suf){\\n        //     cout<<val<<\" \";\\n        // }\\n        // cout<<\"\\\\n\";\\n\\n        //three cases\\n        if(k==0){\\n            for(int i=0;i<n;i++){\\n                int a;\\n                a = nums[i];\\n                ans.emplace_back(a/(2*k+1));                \\n            }            \\n        }            \\n        else if(k>n/2){\\n            for(int i=0;i<n;i++){\\n                ans.emplace_back(-1);\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n-k;i++){\\n                if(i<k){\\n                    ans.emplace_back(-1);\\n                }\\n                else{\\n                    long long a;\\n                    if(i-k == 0 and i+k == n-1){\\n                        a = pre[i-1] + suf[i+1] + nums[i];\\n                    }\\n                    else if(i-k == 0 ){\\n                        a = pre[i-1] + suf[i+1]-suf[i+k+1] + nums[i];\\n                    }\\n                    else if(i+k == n-1){\\n                        a = pre[i-1]-pre[i-k-1] + suf[i+1] + nums[i];\\n                    }\\n                    else{\\n                        a = (pre[i-1]-pre[i-k-1]) + (suf[i+1]-suf[i+k+1]) + nums[i];\\n                    }\\n                    ans.emplace_back(a/(2*k+1));\\n                }\\n            }\\n            for(int i=n-k;i<n;i++){\\n                ans.emplace_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\narray=[1,2,3]\\nprefix sum array will be = [1,3,6] -> [1, 1+2, 1+2+3] : adding in forward order\\nsuffix sum array will be = [6,5,3] -> [1+2+3, 2+3, 3] : adding in reverse order\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<long long> pre,suf; //use long long as constraints are given\\n        vector<int> ans;\\n        long long temp=0,n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n            pre.emplace_back(nums[i]+temp);\\n            temp+=nums[i];\\n        }\\n        temp=0;\\n        for(int i=n-1;i>=0;i--){\\n            suf.emplace_back(nums[i]+temp);\\n            temp+=nums[i];        \\n        }\\n        reverse(suf.begin(),suf.end());\\n        //reversing the array would help to get the suffix array as.. \\n        //..we are inserting the element from start\\n\\n        //Uncommenting below will help you see the prefix and suffix vector\\n        // for(auto val:pre){\\n        //     cout<<val<<\" \";\\n        // }\\n        // cout<<\"\\\\n\";\\n        // for(auto val:suf){\\n        //     cout<<val<<\" \";\\n        // }\\n        // cout<<\"\\\\n\";\\n\\n        //three cases\\n        if(k==0){\\n            for(int i=0;i<n;i++){\\n                int a;\\n                a = nums[i];\\n                ans.emplace_back(a/(2*k+1));                \\n            }            \\n        }            \\n        else if(k>n/2){\\n            for(int i=0;i<n;i++){\\n                ans.emplace_back(-1);\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n-k;i++){\\n                if(i<k){\\n                    ans.emplace_back(-1);\\n                }\\n                else{\\n                    long long a;\\n                    if(i-k == 0 and i+k == n-1){\\n                        a = pre[i-1] + suf[i+1] + nums[i];\\n                    }\\n                    else if(i-k == 0 ){\\n                        a = pre[i-1] + suf[i+1]-suf[i+k+1] + nums[i];\\n                    }\\n                    else if(i+k == n-1){\\n                        a = pre[i-1]-pre[i-k-1] + suf[i+1] + nums[i];\\n                    }\\n                    else{\\n                        a = (pre[i-1]-pre[i-k-1]) + (suf[i+1]-suf[i+k+1]) + nums[i];\\n                    }\\n                    ans.emplace_back(a/(2*k+1));\\n                }\\n            }\\n            for(int i=n-k;i<n;i++){\\n                ans.emplace_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3660146,
                "title": "c-simple-sliding-window-o-n-approach",
                "content": "# Intuition\\n- Keep a fixed-length sliding window of length 2*k+1.\\n- Slide it from left to right, and update the sum and avg of window.\\n\\n# Approach\\n- Take a windows size of window = 2*k+1\\n- Push nums[i] into the window i.e. windowSum += A[i]\\n- Pop nums[i-window] out of the window i.e. windowSum -= nums[i-window]\\n- Assign the average value i.e. ans[i - k] = windowSum/window.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n\\n- Space complexity: `O(1)`\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k){\\n        long window = 2*k+1;\\n        long n = nums.size();\\n        vector<int> ans(n, -1);\\n        \\n        // edge case\\n        if(n < window)\\n            return ans;\\n        \\n        long windowSum = 0;\\n        for(int i=0; i<n; i++){\\n            windowSum += nums[i];\\n            if(i-window >= 0)\\n                windowSum -= nums[i-window];\\n            if(i >= window-1)\\n                ans[i-k] = windowSum/window;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# **Do upvote !!!**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k){\\n        long window = 2*k+1;\\n        long n = nums.size();\\n        vector<int> ans(n, -1);\\n        \\n        // edge case\\n        if(n < window)\\n            return ans;\\n        \\n        long windowSum = 0;\\n        for(int i=0; i<n; i++){\\n            windowSum += nums[i];\\n            if(i-window >= 0)\\n                windowSum -= nums[i-window];\\n            if(i >= window-1)\\n                ans[i-k] = windowSum/window;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659809,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach\\n1. Let `w` be the window size. For a `k` radius array, `w = 2 * k + 1`.\\n\\n2. If `len(nums) < w`, there are no full sized windows. Return `-1` for each indices in `nums`, else continue to next step.\\n\\n3. Let `lefts` and `rights` be the left and right edges of the rolling window of size `w`.\\n    i.e, $$lefts = \\\\{x_0, x_1, ..., x_{n-1}\\\\}, rights = \\\\{x_w, x_{w + 1}, ..., x_{n-1}\\\\}$$, where $$x_i = nums[i]$$\\n\\n4. Accumulate rolling `sums` for every full sized windows using,\\n    $$sums_i = sums_{i - 1} + rights_i - lefts_i$$\\n\\n5. Divide `sums` by `w` to get averages.\\n\\n6. Return the averages with padding of `-1`, `k` times on either side.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$, excluding return value.\\n\\n# Code\\n```python\\nclass Solution:\\n    def getAverages(self, nums: list[int], k: int) -> list[int]:\\n        w = 2 * k + 1\\n        if len(nums) < w: return [-1] * len(nums)\\n\\n        lefts, rights = iter(nums), iter(nums)\\n        first_sum = sum(islice(rights, w))\\n\\n        sums = accumulate(zip(lefts, rights), lambda a, x: a + x[1] - x[0], initial=first_sum)\\n        return list(chain(repeat(-1, k), (s // w for s in sums), repeat(-1, k)))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def getAverages(self, nums: list[int], k: int) -> list[int]:\\n        w = 2 * k + 1\\n        if len(nums) < w: return [-1] * len(nums)\\n\\n        lefts, rights = iter(nums), iter(nums)\\n        first_sum = sum(islice(rights, w))\\n\\n        sums = accumulate(zip(lefts, rights), lambda a, x: a + x[1] - x[0], initial=first_sum)\\n        return list(chain(repeat(-1, k), (s // w for s in sums), repeat(-1, k)))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659744,
                "title": "java-daily-coding-challenge-with-explanation-easy-and-understandable-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a class Solution with a single method getAverages, which takes an integer array nums and an integer k as parameters. The method is declared as public and returns an integer array.\\n\\nThe code initializes a few variables:\\n\\nn represents the length of the input array nums.\\navrg is an integer array of size n used to store the computed averages. It is initially filled with -1 using Arrays.fill.\\nh is a variable set to 2 * k + 1. It represents the length of the subarrays for which averages will be computed.\\nsum is a variable of type double used to store the sum of elements in each subarray.\\nThe code checks if the length of the input array nums is less than 2 * k + 1. If this condition is true, it means there are not enough elements in nums to form subarrays of length 2k + 1, so it returns the avrg array filled with -1.\\n\\nIf there are enough elements in nums, the code proceeds to compute the averages of the subarrays.\\n\\nThe first for loop iterates h times, from 0 to h - 1. This loop calculates the sum of the first subarray of length h by adding up the elements in nums from index 0 to index h - 1.\\n\\nAfter calculating the sum, the code computes the average of the first subarray by dividing the sum by h. The average is stored in the avg variable, which is then casted to an integer and assigned to avrg[k], representing the central index of the first subarray.\\n\\nThe second for loop iterates from k + 1 to n - k - 1, representing the indices of the subarrays whose averages will be computed.\\n\\nInside the loop, the code updates the sum by subtracting the first element in the previous subarray (nums[i - k - 1]) and adding the next element (nums[i + k]).\\n\\nThe updated sum is divided by h to calculate the average of the current subarray. The average is stored in a temporary variable l of type double, which is then casted to an integer and assigned to avrg[i], representing the current index of the avrg array.\\n\\nOnce the loop completes, the code has computed the averages for all the subarrays, and the avrg array is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] avrg = new int[n];\\n        Arrays.fill(avrg, -1);\\n        int h = 2 * k + 1;\\n        double sum = 0;\\n        if (n < 2 * k + 1) {\\n            return avrg; \\n        }\\n        for (int i = 0; i < h; i++) {\\n            sum += nums[i];\\n        }\\n        double avg = sum / h;\\n        avrg[k] = (int) avg;\\n        for (int i = k + 1; i < n - k; i++) {\\n            sum -= nums[i - k - 1];\\n            sum += nums[i + k];\\n            double l = sum / h;\\n            avrg[i] = (int) l;\\n        }\\n        return avrg;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] avrg = new int[n];\\n        Arrays.fill(avrg, -1);\\n        int h = 2 * k + 1;\\n        double sum = 0;\\n        if (n < 2 * k + 1) {\\n            return avrg; \\n        }\\n        for (int i = 0; i < h; i++) {\\n            sum += nums[i];\\n        }\\n        double avg = sum / h;\\n        avrg[k] = (int) avg;\\n        for (int i = k + 1; i < n - k; i++) {\\n            sum -= nums[i - k - 1];\\n            sum += nums[i + k];\\n            double l = sum / h;\\n            avrg[i] = (int) l;\\n        }\\n        return avrg;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659579,
                "title": "java-solution-for-k-radius-sub-array-averages-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution uses the prefix sum technique to efficiently calculate the sum of elements in subarrays. By precomputing the prefix sum array, we can calculate the sum of any subarray in constant time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If k is 0, it means we need to calculate the average of each individual element. In this case, we return the original nums array.\\n1. Create an averages array of the same length as nums and fill it with -1. This array will store the calculated averages.\\n1. If there are not enough elements on both the left and right sides of the subarray (less than (2 * k + 1) elements), return the averages array as it is.\\n1. Generate the prefix sum array prefix by iterating through nums and calculating the cumulative sum up to each index.\\n1. Iterate over the indices from k to (n - k - 1) (where n is the length of nums):\\na. Calculate the left and right bounds for the subarray using the current index and k.\\nb. Compute the sum of the subarray using the prefix sum array: prefix[rightBound + 1] - prefix[leftBound].\\nc. Calculate the average of the subarray by dividing the sum by (2 * k + 1).\\nd. Store the average in the corresponding index of the averages array.\\n1. Return the averages array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe solution has a time complexity of O(n), where n is the length of the nums array. This complexity arises from iterating through the array once to generate the prefix sum array and then iterating again to calculate the averages.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) as well. It is determined by the space used to store the averages array, which has the same length as nums, and the prefix array, which also has a length of n + 1.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[] getAverages(int[] nums, int k) \\n    {\\n        if (k == 0) {\\n            return nums;\\n        }\\n\\n        int n = nums.length;\\n        int[] averages = new int[n];\\n        Arrays.fill(averages, -1);\\n\\n        // Any index will not have \\'k\\' elements on its left and right.\\n        if (2 * k + 1 > n) {\\n            return averages;\\n        }\\n\\n        // Generate the prefix array for \\'nums\\'.\\n        // \\'prefix[i + 1]\\' will be the sum of all elements of \\'nums\\' from index \\'0\\' to \\'i\\'.\\n        long[] prefix = new long[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n\\n        // Iterate only on those indices which have at least \\'k\\' elements on their left and right.\\n        // i.e. indices from \\'k\\' to \\'n - k\\'\\n        for (int i = k; i < (n - k); ++i) {\\n            int leftBound = i - k, rightBound = i + k;\\n            long subArraySum = prefix[rightBound + 1] - prefix[leftBound];\\n            int average = (int) (subArraySum / (2 * k + 1));\\n            averages[i] = average;\\n        }\\n\\n        return averages;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] getAverages(int[] nums, int k) \\n    {\\n        if (k == 0) {\\n            return nums;\\n        }\\n\\n        int n = nums.length;\\n        int[] averages = new int[n];\\n        Arrays.fill(averages, -1);\\n\\n        // Any index will not have \\'k\\' elements on its left and right.\\n        if (2 * k + 1 > n) {\\n            return averages;\\n        }\\n\\n        // Generate the prefix array for \\'nums\\'.\\n        // \\'prefix[i + 1]\\' will be the sum of all elements of \\'nums\\' from index \\'0\\' to \\'i\\'.\\n        long[] prefix = new long[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n\\n        // Iterate only on those indices which have at least \\'k\\' elements on their left and right.\\n        // i.e. indices from \\'k\\' to \\'n - k\\'\\n        for (int i = k; i < (n - k); ++i) {\\n            int leftBound = i - k, rightBound = i + k;\\n            long subArraySum = prefix[rightBound + 1] - prefix[leftBound];\\n            int average = (int) (subArraySum / (2 * k + 1));\\n            averages[i] = average;\\n        }\\n\\n        return averages;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659538,
                "title": "short-and-easy-c-solution-using-sliding-window-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if(k == 0) return nums;\\n        int n = nums.size(), winSize = 0, tar = 2 * k + 1, i = 0;\\n        long long sum = 0;\\n        vector<int>ans(n,-1);\\n        for(int j=0; j<n; j++){\\n            winSize++;\\n            sum += nums[j];\\n            if(winSize < tar) continue;\\n            ans[j-k] = sum/tar;\\n            sum -= nums[i];\\n            winSize--; i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if(k == 0) return nums;\\n        int n = nums.size(), winSize = 0, tar = 2 * k + 1, i = 0;\\n        long long sum = 0;\\n        vector<int>ans(n,-1);\\n        for(int j=0; j<n; j++){\\n            winSize++;\\n            sum += nums[j];\\n            if(winSize < tar) continue;\\n            ans[j-k] = sum/tar;\\n            sum -= nums[i];\\n            winSize--; i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659451,
                "title": "easy-solution-sliding-window-c-o-n-time",
                "content": "# Intuition \\nWhenever there is a problem of subarray or substring always give a thought to sliding window technique.\\n\\n# Approach\\nHere I have creater a window of size 2*k+1 and just calculate average in each window .\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int wl=2*k+1;\\n        int i=0,j=0;\\n        long  sum=0;\\n        vector<int>avg(n,-1);\\n        while(j<n){\\n            sum+=nums[j];\\n            if(j-i+1>wl){\\n                sum-=nums[i];\\n                i++;\\n            }\\n            if(j-i+1==wl){\\n                avg[(i+j)/2]=sum/wl;\\n            }\\n            j++;\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int wl=2*k+1;\\n        int i=0,j=0;\\n        long  sum=0;\\n        vector<int>avg(n,-1);\\n        while(j<n){\\n            sum+=nums[j];\\n            if(j-i+1>wl){\\n                sum-=nums[i];\\n                i++;\\n            }\\n            if(j-i+1==wl){\\n                avg[(i+j)/2]=sum/wl;\\n            }\\n            j++;\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659344,
                "title": "easy-and-effective-solution-in-python-2090-k-radius-subarray-averages",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        res =[-1]*len(nums)\\n        left_ptr = 0\\n        sum = 0\\n        diameter = 2*k +1 #7 so till 7 elements add to the sum\\n\\n        for right_ptr in range(len(nums)):\\n            sum += nums[right_ptr]\\n            if right_ptr - left_ptr + 1 == diameter:\\n                res[left_ptr + k] = sum // diameter # store 5 at index 3\\n                sum -= nums[left_ptr]\\n                left_ptr +=1\\n        return res\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        res =[-1]*len(nums)\\n        left_ptr = 0\\n        sum = 0\\n        diameter = 2*k +1 #7 so till 7 elements add to the sum\\n\\n        for right_ptr in range(len(nums)):\\n            sum += nums[right_ptr]\\n            if right_ptr - left_ptr + 1 == diameter:\\n                res[left_ptr + k] = sum // diameter # store 5 at index 3\\n                sum -= nums[left_ptr]\\n                left_ptr +=1\\n        return res\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659287,
                "title": "java-python-brute-force-to-prefix-sum",
                "content": "# Intuition\\nAfter seeing this Question very first thing that comes in my mind was sliding window because its obious we need sum of that range element and by sliding window by removing the last one and adding ahead one we can get done things in more simpler manner. \\n\\n# Approach\\nAt very First I applied brute force even by knowing that it will get TLE it makes easy to understand the problem so I done this code in two different languages I did brute force in java and done optimized one in python both are similar only little change in same code and it get done from TLE to optimized. \\n\\n## Brute Force: \\n- just checked the condition i-k and i+k if valid then sum all the elements by using for loop \\n- calculated average and add it to list \\n## Optimized \\n- you know what we need to change to stop that again and again computation of the sum of elements in range \\n- yes right just need to keep a sliding window of that length\\n- at starting I calculated the sum \\n- and later just add the last+1 element into the sum \\n- and substracted first element from the sum \\n- that\\'s all \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\nthat used space will not gonna count as used space it was the requirement of that function to create that space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length; \\n        int[] arr = new int[n];\\n        int len = k*2+1;\\n        for(int i=0; i<n; i++){\\n            if(i-k>=0 && i+k<n){\\n                int sum =0;\\n                for(int j=i-k; j<=i+k; j++){\\n                    sum+=nums[j];\\n                }\\n                arr[i] = sum/len;\\n            }else{\\n                arr[i] = -1;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        ans = []\\n        n = len(nums)\\n        li = k*2+1\\n        sum = 0\\n\\n        for i in range(0, li):\\n            if i>=n:\\n                break\\n            sum+=nums[i]\\n\\n        for i in range(n):\\n            if i-k>=0 and i+k<n:\\n                ans.append(int(sum/li))\\n                sum-=nums[i-k]\\n                if i+k+1<n:\\n                    sum+=nums[i+k+1]\\n            else:\\n                ans.append(-1)\\n\\n        return ans        \\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n = nums.length; \\n        int[] arr = new int[n];\\n        int len = k*2+1;\\n        for(int i=0; i<n; i++){\\n            if(i-k>=0 && i+k<n){\\n                int sum =0;\\n                for(int j=i-k; j<=i+k; j++){\\n                    sum+=nums[j];\\n                }\\n                arr[i] = sum/len;\\n            }else{\\n                arr[i] = -1;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        ans = []\\n        n = len(nums)\\n        li = k*2+1\\n        sum = 0\\n\\n        for i in range(0, li):\\n            if i>=n:\\n                break\\n            sum+=nums[i]\\n\\n        for i in range(n):\\n            if i-k>=0 and i+k<n:\\n                ans.append(int(sum/li))\\n                sum-=nums[i-k]\\n                if i+k+1<n:\\n                    sum+=nums[i+k+1]\\n            else:\\n                ans.append(-1)\\n\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659222,
                "title": "easy-beginner-friendly-o-n-space-o-n-easy-explanation",
                "content": "# From Writer\\nRead the code with comments .You will definitely understand.\\n\\n# Approach\\nSimple Sliding Window .\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n =nums.size();\\n        // Intializing whole array with -1.\\n        vector<int>avg(n,-1);\\n        // window two pointers . sliding them will give us everytime new averages .\\n        int p=0,q=2*k;\\n        long long sum=0;\\n        // pre-computing 1st window average. LaterON we just remove 1 element from back \\n        // and include 1 element from q+1.\\n        for(int i=0;i<n && i<=q;i++){\\n            sum+=nums[i];\\n        }\\n        // start from i=k and end at [(n-1)-k] .Rest self-Explanatory \\n        // Just check what you are accessing through array,is it valid \\n        // i.e. if(q<n-1) then nums[++q].\\n        for(int i=k;i<=(n-1-k);i++){\\n            avg[i]=sum/(2*k+1);\\n            sum-=(nums[p++]);\\n            if(q<n-1)sum+=(nums[++q]);\\n        }\\n        return avg;\\n    }\\n};\\n```\\nThank you \\nCode By :) AMAN MAURYA",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n =nums.size();\\n        // Intializing whole array with -1.\\n        vector<int>avg(n,-1);\\n        // window two pointers . sliding them will give us everytime new averages .\\n        int p=0,q=2*k;\\n        long long sum=0;\\n        // pre-computing 1st window average. LaterON we just remove 1 element from back \\n        // and include 1 element from q+1.\\n        for(int i=0;i<n && i<=q;i++){\\n            sum+=nums[i];\\n        }\\n        // start from i=k and end at [(n-1)-k] .Rest self-Explanatory \\n        // Just check what you are accessing through array,is it valid \\n        // i.e. if(q<n-1) then nums[++q].\\n        for(int i=k;i<=(n-1-k);i++){\\n            avg[i]=sum/(2*k+1);\\n            sum-=(nums[p++]);\\n            if(q<n-1)sum+=(nums[++q]);\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659211,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] GetAverages(int[] nums, int k) {\\n        var len = nums.Length;\\n        long curSum = nums.Take(2*k).Sum(x => (long)x);\\n\\n        int[] op = Enumerable.Repeat(-1, len).ToArray();\\n\\n        for (int i = k; i < len - k; i++) {\\n            int a = i - k;\\n            int b = k + i;\\n\\n            curSum += nums[b];\\n            op[i] = (int)(curSum/(b - a + 1));\\n            curSum -= nums[a];\\n        }\\n\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetAverages(int[] nums, int k) {\\n        var len = nums.Length;\\n        long curSum = nums.Take(2*k).Sum(x => (long)x);\\n\\n        int[] op = Enumerable.Repeat(-1, len).ToArray();\\n\\n        for (int i = k; i < len - k; i++) {\\n            int a = i - k;\\n            int b = k + i;\\n\\n            curSum += nums[b];\\n            op[i] = (int)(curSum/(b - a + 1));\\n            curSum -= nums[a];\\n        }\\n\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659162,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n=len(nums)\\n        counts=(2*k+1)\\n        prefix=[0]\\n        for x in nums:\\n            prefix.append(prefix[-1]+x)\\n\\n        ans=[]\\n        for i in range(n):\\n            if i-k>=0 and i+k<n:\\n                ans.append((prefix[i+k+1]-prefix[i-k])//counts)\\n\\n            else:\\n                ans.append(-1)\\n\\n        return ans                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n=len(nums)\\n        counts=(2*k+1)\\n        prefix=[0]\\n        for x in nums:\\n            prefix.append(prefix[-1]+x)\\n\\n        ans=[]\\n        for i in range(n):\\n            if i-k>=0 and i+k<n:\\n                ans.append((prefix[i+k+1]-prefix[i-k])//counts)\\n\\n            else:\\n                ans.append(-1)\\n\\n        return ans                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659007,
                "title": "clear-explanation-with-easy-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each index in nums, we simply need to calculate ```sum(nums[i-k:i+k])``` \\u2014 if the current range is valid \\u2014 and integer divide it by the number of elements in the range to compute the result. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNotice that the first ```k``` indices in nums will not have a valid range. Therefore the average is ```-1```. Similarly, the last ```k``` elements will also not have a valid range and their average will also be ```-1```. \\n\\nAnother thing to note is that each valid range will have ```k``` elements to the left of the current index, and ```k``` elements to the right of the current index. This means that each range has ```2k + 1``` elements in it. \\n\\nWe can represent each range as a window. We can then calculate the sum of this range and integer divide it by ```2k + 1``` for its average. The corresponding index in nums will be the middle of the range which is ```(start + end) // 2```. As we move through the arrage and look at different ranges, we can simply remove the left most element from the sum and include the new right element to the sum and avoid having to recompute the whole sum again. \\n\\nLet\\'s implement this approach. We first initialize an array ```res```, which has the same length as ```nums```, with all values being ```-1```. Next we calculate the bounds for the first valid range. The start of the range will be ```left = 0```, and the end of the range will be ```right = 2k```. We also calculate the sum for the current range. Using the ```sum``` function, we can calculate the sum for the current range barring the last element. This is because when we iterate over the array, the first thing we do when we get to a new range is adding the new ```nums[right]```. Now, we iterate until the end of the range is in bounds. We calculate the corresponding index to the current range and add the current end of the range to the total. We then divide this by ```(2k + 1)``` and assign this to ```res[i]```. Now, we shift the range. First we remove the leftmost element from the sum and then increment the left pointer. After this, we increment the right pointer. We return res when the loop ends. \\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        \"\"\"\\n        Returns the radius average for each index in nums.\\n\\n        Args:\\n            nums: List[int] = input array\\n        \\n        Returns:\\n            res: List[int] = radius average for each index in nums\\n        \"\"\"\\n\\n        # Initialize the result array which will hold the radius average\\n        # for each index in nums\\n        res = [-1] * len(nums)\\n\\n        # Initialze two pointers which indicate the range of nums considered\\n        # in the average. The center of the range is the corresponding index\\n        # in nums. \\n        left, right = 0, 2*k\\n\\n        # Calculate the initial sum of this current range\\n        total = sum(nums[l:r])\\n\\n        # Iterate while the range is valid\\n        while r < len(nums):\\n\\n            # get the corresponding index in nums\\n            idx = (left + right) // 2\\n\\n            # add the right boundary number to the sum and calculate \\n            # average.\\n            total += nums[right]\\n            res[idx] = total // (2*k + 1)\\n\\n            # As we move our range across, we must remove the left\\n            # boundary number\\n            total -= nums[left]\\n            left += 1 \\n            right += 1 \\n        \\n        # Now that we have calculate the average for all valid ranges, \\n        # return the result array\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```sum(nums[i-k:i+k])```\n```k```\n```-1```\n```k```\n```-1```\n```k```\n```k```\n```2k + 1```\n```2k + 1```\n```(start + end) // 2```\n```res```\n```nums```\n```-1```\n```left = 0```\n```right = 2k```\n```sum```\n```nums[right]```\n```(2k + 1)```\n```res[i]```\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        \"\"\"\\n        Returns the radius average for each index in nums.\\n\\n        Args:\\n            nums: List[int] = input array\\n        \\n        Returns:\\n            res: List[int] = radius average for each index in nums\\n        \"\"\"\\n\\n        # Initialize the result array which will hold the radius average\\n        # for each index in nums\\n        res = [-1] * len(nums)\\n\\n        # Initialze two pointers which indicate the range of nums considered\\n        # in the average. The center of the range is the corresponding index\\n        # in nums. \\n        left, right = 0, 2*k\\n\\n        # Calculate the initial sum of this current range\\n        total = sum(nums[l:r])\\n\\n        # Iterate while the range is valid\\n        while r < len(nums):\\n\\n            # get the corresponding index in nums\\n            idx = (left + right) // 2\\n\\n            # add the right boundary number to the sum and calculate \\n            # average.\\n            total += nums[right]\\n            res[idx] = total // (2*k + 1)\\n\\n            # As we move our range across, we must remove the left\\n            # boundary number\\n            total -= nums[left]\\n            left += 1 \\n            right += 1 \\n        \\n        # Now that we have calculate the average for all valid ranges, \\n        # return the result array\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592730,
                "title": "swift-sliding-window-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func getAverages(_ nums: [Int], _ k: Int) -> [Int] {\\n        guard k != 0 else { return nums }\\n        let diameter = k * 2 + 1\\n        var result = Array(repeating: -1, count: nums.count)\\n        var left = 0\\n        var sum = nums[0]\\n        for right in 1..<nums.count {\\n            sum += nums[right]\\n            if right - left + 1 >= diameter {\\n                result[left + k] = sum / diameter\\n                sum-=nums[left]\\n                left+=1\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    func getAverages(_ nums: [Int], _ k: Int) -> [Int] {\\n        guard k != 0 else { return nums }\\n        let diameter = k * 2 + 1\\n        var result = Array(repeating: -1, count: nums.count)\\n        var left = 0\\n        var sum = nums[0]\\n        for right in 1..<nums.count {\\n            sum += nums[right]\\n            if right - left + 1 >= diameter {\\n                result[left + k] = sum / diameter\\n                sum-=nums[left]\\n                left+=1\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797823,
                "title": "python-easy-sliding-window-o-n-solution",
                "content": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n=len(nums)\\n        t=2*k+1\\n        if n<t:\\n            return [-1]*n\\n        ans=[-1]*k\\n        s=sum(nums[:t])\\n        avg=s//t\\n        ans.append(avg)\\n        l,r=0,t\\n        for i in range(k+1,n):\\n            if i+k>=n:\\n                ans.append(-1)\\n            else:\\n                s+=nums[r]-nums[l]\\n                avg=s//t\\n                ans.append(avg)\\n            l+=1\\n            r+=1\\n        return ans\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n=len(nums)\\n        t=2*k+1\\n        if n<t:\\n            return [-1]*n\\n        ans=[-1]*k\\n        s=sum(nums[:t])\\n        avg=s//t\\n        ans.append(avg)\\n        l,r=0,t\\n        for i in range(k+1,n):\\n            if i+k>=n:\\n                ans.append(-1)\\n            else:\\n                s+=nums[r]-nums[l]\\n                avg=s//t\\n                ans.append(avg)\\n            l+=1\\n            r+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778399,
                "title": "time-limit-execeded-by-brute-force-method",
                "content": "res=[]\\n        for i in range(0,len(nums)):\\n            if(i-k>=0 and i+k<len(nums)):\\n                res.append(sum(nums[i-k:i+k+1])//((2*k)+1))\\n            else:\\n                res.append(-1)\\n        return res\\n\\t\\t\\n\\t\\t\\n\\t\\t#this throws an tle",
                "solutionTags": [],
                "code": "res=[]\\n        for i in range(0,len(nums)):\\n            if(i-k>=0 and i+k<len(nums)):\\n                res.append(sum(nums[i-k:i+k+1])//((2*k)+1))\\n            else:\\n                res.append(-1)\\n        return res\\n\\t\\t\\n\\t\\t\\n\\t\\t#this throws an tle",
                "codeTag": "Unknown"
            },
            {
                "id": 2731956,
                "title": "well-explained-c-t-o-n-s-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt clearly seems the question on sliding window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere could be three possibilty\\n\\n1) The length of the given array is less than 2*k +1 ie,no   circle formed by given arra.\\n    solution:In this case we just have to store the as many -1 as there in the given array in the answer vector and return.\\n\\n2) The length of the given vector is zero.\\n    solution:just return the given vector\\n\\n3) The length of the vector is greater than 2k+1 i,e circles are possible of radius k\\n    solution: just store k times -1 for the numbers having left radius less than k.\\nthen run a loop to store the sum of numbers whose radius is k.\\nagain store k times -1 for the numbers whose right radius is less than k.\\nNOTE:take sum as double not int as the sum of 2k+1 can exceeds the range of int.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        long int sum=0;\\n        int l=k;\\n        int h=k;\\n        int n=nums.size();\\n        if(2*k+1>nums.size()){\\n            while(n--){\\n            ans.push_back(-1);\\n        }\\n            return ans;\\n        }\\n        if(k==0){\\n            ans.push_back(nums[0]);\\n            return nums;\\n        }\\n        while(l--){\\n            ans.push_back(-1);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(i<=(2*k)){\\n                sum+=nums[i];\\n                if(i==2*k){\\n                    if(k>0)\\n                        ans.push_back(int(sum/(2*k+1)));\\n                }\\n            }\\n            else{\\n                sum=sum-nums[i-2*k-1]+nums[i];\\n                ans.push_back(sum/(2*k+1));\\n            }\\n        }\\n        while(h--){\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        long int sum=0;\\n        int l=k;\\n        int h=k;\\n        int n=nums.size();\\n        if(2*k+1>nums.size()){\\n            while(n--){\\n            ans.push_back(-1);\\n        }\\n            return ans;\\n        }\\n        if(k==0){\\n            ans.push_back(nums[0]);\\n            return nums;\\n        }\\n        while(l--){\\n            ans.push_back(-1);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(i<=(2*k)){\\n                sum+=nums[i];\\n                if(i==2*k){\\n                    if(k>0)\\n                        ans.push_back(int(sum/(2*k+1)));\\n                }\\n            }\\n            else{\\n                sum=sum-nums[i-2*k-1]+nums[i];\\n                ans.push_back(sum/(2*k+1));\\n            }\\n        }\\n        while(h--){\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718863,
                "title": "tells-how-to-optimize-code-c-o-n",
                "content": "Things to take care of : \\n1. time complexity -> Don\\'t keep calculating the sum for the average every time, this will lead to TLE, calculate sum for only the first time, and just subtract nums[i - k - 1] and add nums[i + k] to sum.\\n2. Integer value overflow -> use a long long int for calculating the summ as it will exceed the maximum int value\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int>getAverages(vector<int>& nums, int k){\\n    vector<int>result;\\n    int den = 2*k + 1;\\n    long long int sum = 0;\\n    for(int i = 0;i<nums.size();i++){\\n        if((i - k<0 )|| (k + i >= nums.size())){\\n            result.push_back(-1);\\n        }\\n        else{\\n\\t\\t    // Unoptimized code\\n            // int sum = 0;\\n            // int lower_bound = i - k;\\n            // int upper_bound = i + k;\\n            // while(lower_bound <= upper_bound){\\n            //     sum += nums[lower_bound];\\n            //     lower_bound++;\\n            // }\\n            // result.push_back(sum/den);\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//Optimized code\\n            if(sum == 0){\\n                int lower_bound = i - k;\\n                int upper_bound = i + k;\\n                while(lower_bound <= upper_bound){\\n                    sum += nums[lower_bound];\\n                    lower_bound++;\\n                }\\n                result.push_back(int(sum/den));\\n            }\\n            else{\\n                sum -= nums[i - k - 1];\\n                sum += nums[i + k];\\n                result.push_back(int(sum/den));\\n            }\\n        }\\n    }\\n    return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int>getAverages(vector<int>& nums, int k){\\n    vector<int>result;\\n    int den = 2*k + 1;\\n    long long int sum = 0;\\n    for(int i = 0;i<nums.size();i++){\\n        if((i - k<0 )|| (k + i >= nums.size())){\\n            result.push_back(-1);\\n        }\\n        else{\\n\\t\\t    // Unoptimized code\\n            // int sum = 0;\\n            // int lower_bound = i - k;\\n            // int upper_bound = i + k;\\n            // while(lower_bound <= upper_bound){\\n            //     sum += nums[lower_bound];\\n            //     lower_bound++;\\n            // }\\n            // result.push_back(sum/den);\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//Optimized code\\n            if(sum == 0){\\n                int lower_bound = i - k;\\n                int upper_bound = i + k;\\n                while(lower_bound <= upper_bound){\\n                    sum += nums[lower_bound];\\n                    lower_bound++;\\n                }\\n                result.push_back(int(sum/den));\\n            }\\n            else{\\n                sum -= nums[i - k - 1];\\n                sum += nums[i + k];\\n                result.push_back(int(sum/den));\\n            }\\n        }\\n    }\\n    return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373292,
                "title": "golang-sliding-window-o-n",
                "content": "```go\\nfunc getAverages(nums []int, k int) []int {\\n  res := make([]int, len(nums))\\n  for i := 0; i < len(nums); i++ {\\n    res[i] = -1\\n  }\\n  sublen := 2 * k + 1 // length of the sub-array with k-radius is 2*k+1\\n  var sum int\\n  // We\\'re going to be using a sliding window of sublen length\\n  for i := 0; i < len(nums); i++ {\\n    sum += nums[i]\\n    if i < sublen-1 {\\n      continue\\n    }\\n    res[i-k] = sum/sublen // i-k points to the right position in the result array\\n    sum -= nums[i-sublen+1]\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```go\\nfunc getAverages(nums []int, k int) []int {\\n  res := make([]int, len(nums))\\n  for i := 0; i < len(nums); i++ {\\n    res[i] = -1\\n  }\\n  sublen := 2 * k + 1 // length of the sub-array with k-radius is 2*k+1\\n  var sum int\\n  // We\\'re going to be using a sliding window of sublen length\\n  for i := 0; i < len(nums); i++ {\\n    sum += nums[i]\\n    if i < sublen-1 {\\n      continue\\n    }\\n    res[i-k] = sum/sublen // i-k points to the right position in the result array\\n    sum -= nums[i-sublen+1]\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2227320,
                "title": "please-help-me-in-finding-the-bug-k-radius-subarray-averages",
                "content": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int res[] = new int[nums.length];\\n        Arrays.fill(res,-1);\\n        if(nums.length<2*k+1)\\n            return res;\\n        long sum = 0;\\n        for(int i = 0; i<2*k+1; i++)\\n            sum+=nums[i];\\n        for(int i = k, j = 0; i<nums.length-k; i++)\\n        {\\n            if(i == k)\\n                res[i] = (int)sum/(2*k+1);\\n            else\\n            {\\n                sum = sum + nums[i+k] - nums[j++];\\n                res[i] = (int)sum/(2*k+1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n[https://leetcode.com/submissions/detail/736579105/testcase/] Only this test case is stuck.\\n\\n![image](https://assets.leetcode.com/users/images/a4c81f80-f50a-4ab7-8e08-2a42f20c49cb_1656764855.7471097.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int res[] = new int[nums.length];\\n        Arrays.fill(res,-1);\\n        if(nums.length<2*k+1)\\n            return res;\\n        long sum = 0;\\n        for(int i = 0; i<2*k+1; i++)\\n            sum+=nums[i];\\n        for(int i = k, j = 0; i<nums.length-k; i++)\\n        {\\n            if(i == k)\\n                res[i] = (int)sum/(2*k+1);\\n            else\\n            {\\n                sum = sum + nums[i+k] - nums[j++];\\n                res[i] = (int)sum/(2*k+1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222648,
                "title": "java-sliding-window-solution",
                "content": "This is my simple solution via sliding window approach:\\n\\n```\\nclass Solution {\\n    \\n    public int[] getAverages(int[] nums, int k) {\\n        if (k <= 0) {\\n            return nums;\\n        }\\n\\n\\t\\t//calculate initial sliding window sum \\n        long currRadiusAvg = 0;\\n        int numsSize = nums.length, windowSize = k * 2 + 1;\\n        for (int windowIndex = 0; windowIndex < numsSize && windowIndex < windowSize; windowIndex++) {\\n            currRadiusAvg += nums[windowIndex];\\n        }\\n\\n\\n        int[] avgs = new int[numsSize];\\n\\n\\t\\t//move window and calculate avg\\n        for (int numIndex = 0; numIndex < numsSize; numIndex++) {\\n            //for positions where range less than k (radius is impossible)\\n\\t\\t\\tif (numIndex < k || numIndex >= numsSize - k) {\\n                avgs[numIndex] = -1;\\n\\n                continue;\\n            }\\n\\t\\t\\n            if (numIndex == k) {\\n                avgs[numIndex] = (int) (currRadiusAvg / windowSize);\\n\\n                continue;\\n            }\\n\\n            currRadiusAvg = currRadiusAvg - nums[numIndex - k - 1] + nums[numIndex + k];\\n            avgs[numIndex] = (int) (currRadiusAvg / windowSize);\\n        }\\n\\n        return avgs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[] getAverages(int[] nums, int k) {\\n        if (k <= 0) {\\n            return nums;\\n        }\\n\\n\\t\\t//calculate initial sliding window sum \\n        long currRadiusAvg = 0;\\n        int numsSize = nums.length, windowSize = k * 2 + 1;\\n        for (int windowIndex = 0; windowIndex < numsSize && windowIndex < windowSize; windowIndex++) {\\n            currRadiusAvg += nums[windowIndex];\\n        }\\n\\n\\n        int[] avgs = new int[numsSize];\\n\\n\\t\\t//move window and calculate avg\\n        for (int numIndex = 0; numIndex < numsSize; numIndex++) {\\n            //for positions where range less than k (radius is impossible)\\n\\t\\t\\tif (numIndex < k || numIndex >= numsSize - k) {\\n                avgs[numIndex] = -1;\\n\\n                continue;\\n            }\\n\\t\\t\\n            if (numIndex == k) {\\n                avgs[numIndex] = (int) (currRadiusAvg / windowSize);\\n\\n                continue;\\n            }\\n\\n            currRadiusAvg = currRadiusAvg - nums[numIndex - k - 1] + nums[numIndex + k];\\n            avgs[numIndex] = (int) (currRadiusAvg / windowSize);\\n        }\\n\\n        return avgs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114532,
                "title": "python-sliding-window-and-prefix-sum-solutions",
                "content": "Added comments in code to try and make the algorithm more explainable.\\n\\n## Sliding window solution\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        result = [-1] * n\\n        running_sum = 0\\n        \\n        # We need n to be at least k*2+1 since k must be on both left and right sides\\n        if k*2 >= n:\\n            return result\\n        \\n        # run only on the range that we know contains k for both sides\\n        for i in range(k, n - k):\\n            # the first iteration we calculate the sliding window sum\\n            if i == k:\\n                running_sum = sum(nums[:i+k+1])\\n                result[i] = running_sum//(k*2+1)\\n                continue\\n            \\n            # on other iterations we remove the element that went out and insert the element that went in\\n            running_sum -= nums[i-k-1]\\n            running_sum += nums[i+k]\\n            result[i] = running_sum//(k*2+1)\\n        \\n        return result\\n```\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`\\n\\n\\n## Prefix sum solution\\n\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        result = [-1]*n\\n        if k*2 >= n:\\n            return result\\n        \\n        prefix_sum = [0]\\n        for v in nums:\\n            prefix_sum.append(prefix_sum[-1] + v)\\n        \\n        for i in range(k, n - k):\\n            # Since we have +1 indexes on prefix_sum we need to access the indexes one to the right\\n            result[i] = (prefix_sum[i+k+1] - prefix_sum[i-k]) // (k*2+1)\\n        return result\\n```\\n\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        result = [-1] * n\\n        running_sum = 0\\n        \\n        # We need n to be at least k*2+1 since k must be on both left and right sides\\n        if k*2 >= n:\\n            return result\\n        \\n        # run only on the range that we know contains k for both sides\\n        for i in range(k, n - k):\\n            # the first iteration we calculate the sliding window sum\\n            if i == k:\\n                running_sum = sum(nums[:i+k+1])\\n                result[i] = running_sum//(k*2+1)\\n                continue\\n            \\n            # on other iterations we remove the element that went out and insert the element that went in\\n            running_sum -= nums[i-k-1]\\n            running_sum += nums[i+k]\\n            result[i] = running_sum//(k*2+1)\\n        \\n        return result\\n```\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        result = [-1]*n\\n        if k*2 >= n:\\n            return result\\n        \\n        prefix_sum = [0]\\n        for v in nums:\\n            prefix_sum.append(prefix_sum[-1] + v)\\n        \\n        for i in range(k, n - k):\\n            # Since we have +1 indexes on prefix_sum we need to access the indexes one to the right\\n            result[i] = (prefix_sum[i+k+1] - prefix_sum[i-k]) // (k*2+1)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999667,
                "title": "simple-python-3-solution-with-sliding-window-and-current-sum",
                "content": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        # The idea is quite simple.\\n        # We will have a sliding window of 2k+1 since we need k to left and k to right numbers.\\n        # We will keep track of the current sum\\n\\n        k = 2*k+1\\n        res = [-1] * len(nums)\\n        l, curr = 0, 0\\n        \\n        for r, num in enumerate(nums):\\n            curr += num\\n            \\n            # r-l+1 == len of curr window\\n            if r - l + 1 > k:\\n                curr -= nums[l]\\n                l += 1\\n\\n            if r - l + 1 == k:\\n                # update the middle of the current window\\n                ind = (l+r)//2\\n                res[ind] = curr // k\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        # The idea is quite simple.\\n        # We will have a sliding window of 2k+1 since we need k to left and k to right numbers.\\n        # We will keep track of the current sum\\n\\n        k = 2*k+1\\n        res = [-1] * len(nums)\\n        l, curr = 0, 0\\n        \\n        for r, num in enumerate(nums):\\n            curr += num\\n            \\n            # r-l+1 == len of curr window\\n            if r - l + 1 > k:\\n                curr -= nums[l]\\n                l += 1\\n\\n            if r - l + 1 == k:\\n                # update the middle of the current window\\n                ind = (l+r)//2\\n                res[ind] = curr // k\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1736963,
                "title": "c-o-n-time-sliding-window",
                "content": "```\\nvector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int>res(n,-1);\\n        k = (2*k)+1;\\n        long sum =0;\\n        if(k>n)return res;\\n        else if(k==n){\\n            sum =accumulate(nums.begin(),nums.end(),sum); \\n            res[n/2]=sum/n;\\n            return res;\\n        }\\n        int i=0;\\n        int j=0;\\n        int mid = (k-1)/2;\\n        while(j<n){\\n            sum=sum+nums[j];\\n            if(j-i+1<k){\\n                j++;\\n            }else if(j-i+1==k){\\n                int avg = sum/k;\\n                res[mid++] = avg;\\n                sum=sum-nums[i];\\n                i++;j++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int>res(n,-1);\\n        k = (2*k)+1;\\n        long sum =0;\\n        if(k>n)return res;\\n        else if(k==n){\\n            sum =accumulate(nums.begin(),nums.end(),sum); \\n            res[n/2]=sum/n;\\n            return res;\\n        }\\n        int i=0;\\n        int j=0;\\n        int mid = (k-1)/2;\\n        while(j<n){\\n            sum=sum+nums[j];\\n            if(j-i+1<k){\\n                j++;\\n            }else if(j-i+1==k){\\n                int avg = sum/k;\\n                res[mid++] = avg;\\n                sum=sum-nums[i];\\n                i++;j++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734570,
                "title": "c-easy-sliding-window-solution-faster-than-90",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> result(nums.size(), -1);\\n        long long runningSum = 0;\\n        \\n        if(nums.size() <= (k * 2)) return result;\\n        \\n        for(int i = 0; i <= (k * 2); i++){\\n            runningSum += nums[i];\\n        }\\n        \\n        int current = k;\\n        result[current] = runningSum / ((k * 2) + 1);\\n        \\n        for(int i = 1; i + (k * 2) < nums.size(); i++){\\n            runningSum = (runningSum - nums[i - 1]) + nums[i + (k * 2)];\\n            result[++current] = runningSum / ((k * 2) + 1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> result(nums.size(), -1);\\n        long long runningSum = 0;\\n        \\n        if(nums.size() <= (k * 2)) return result;\\n        \\n        for(int i = 0; i <= (k * 2); i++){\\n            runningSum += nums[i];\\n        }\\n        \\n        int current = k;\\n        result[current] = runningSum / ((k * 2) + 1);\\n        \\n        for(int i = 1; i + (k * 2) < nums.size(); i++){\\n            runningSum = (runningSum - nums[i - 1]) + nums[i + (k * 2)];\\n            result[++current] = runningSum / ((k * 2) + 1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602440,
                "title": "java-o-n-sliding-window-with-rolling-sum-faster-than-100",
                "content": "All in just one pass.\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int[] result = new int[nums.length];\\n        int len = nums.length;\\n        \\n        long sum = 0l; // sum should be long to avoid overflow \\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (i < k || i > (len - 1 - k)) {\\n               result[i] = -1;\\n            }\\n                \\n            if (i >= (k * 2)) {\\n                result[i - k] = (int) (sum / (k * 2 + 1));\\n                sum -= nums[i - (k * 2)];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int[] result = new int[nums.length];\\n        int len = nums.length;\\n        \\n        long sum = 0l; // sum should be long to avoid overflow \\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            if (i < k || i > (len - 1 - k)) {\\n               result[i] = -1;\\n            }\\n                \\n            if (i >= (k * 2)) {\\n                result[i - k] = (int) (sum / (k * 2 + 1));\\n                sum -= nums[i - (k * 2)];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602153,
                "title": "c-o-n-time-o-1-space-single-traversal-100-faster-in-time-and-space",
                "content": "The approach is to use the sliding window concept as we traverse the array,\\n1. Initialize the resultant array with -1 values as default.\\n2. Now according to question we have to find average of k elements both side. So keep on adding in sum variables until u reach first valid output for Eg.\\n[7,4,3,9,1,8,5,2,6],k=3\\n3. so our first valid output will be for i = 3 that have three elements on boh side now traverse when u encouter the window of 7 elements ie( i + k left side element + k right side element)\\n4. find the average and update the result also remove the last element from the sliding window sum.\\n5. this way when u reach the last element all the valid ouputs in result are updated and rest of them has default values.\\n\\n**Please Upvote if you like my solution.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> result(n, -1);\\n        \\n        long int sum = 0;\\n        int start = 0;\\n        int result_start = k;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            if(i >= 2*k)\\n            {\\n                result[result_start++] = sum/(2*k + 1);\\n                sum -= nums[start++];\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> result(n, -1);\\n        \\n        long int sum = 0;\\n        int start = 0;\\n        int result_start = k;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum += nums[i];\\n            if(i >= 2*k)\\n            {\\n                result[result_start++] = sum/(2*k + 1);\\n                sum -= nums[start++];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3993983,
                "title": "c-sliding-window-simple-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) \\n    {\\n        vector<int> res(nums.size(), -1);\\n        int left = 0, right = 2*k;\\n        long sum = 0;\\n        \\n        if(right >= nums.size()) return res;\\n        \\n        for(int i=0; i<=right; i++) sum += nums[i];\\n        res[k] = sum/(2*k+1);\\n        \\n        for(int i=k+1; i<nums.size()-k; i++)\\n        {            \\n            sum -= nums[left++];\\n            sum += nums[++right];\\n            res[i] = sum/(2*k+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) \\n    {\\n        vector<int> res(nums.size(), -1);\\n        int left = 0, right = 2*k;\\n        long sum = 0;\\n        \\n        if(right >= nums.size()) return res;\\n        \\n        for(int i=0; i<=right; i++) sum += nums[i];\\n        res[k] = sum/(2*k+1);\\n        \\n        for(int i=k+1; i<nums.size()-k; i++)\\n        {            \\n            sum -= nums[left++];\\n            sum += nums[++right];\\n            res[i] = sum/(2*k+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991931,
                "title": "prefix-sum-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n- We could use two approaches here, first is sliding window and second which I used, is prefix sum. We understand this by reading description and understands that we need to calculate average of specific range in array.\\n\\n# Approach\\n- we need to keep in mind that when calculating prfix sum we should use long type instead of int for prefix sum array, it\\'s stated in description that numbers may be bigger than int allows. \\n\\n# Complexity\\n- Time complexity:\\n- O(n) - Sin\\u0441e we iterates only two times we actually get O(2n), but since constants are discarded we get O(n).\\n\\n- Space complexity:\\n- O(n) - same as with time complexity, we use two additional arrays one for result and second for prefix, we could mutate nums array for results after we calculate prefix sum, but mutating input data is considered bad approach.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        // declare result array of nums.length\\n        int[] result = new int[nums.length];\\n        // fill it with -1\\n        Arrays.fill(result, -1);\\n        // declare prefix sum arra with nums.length + 1\\n        long[] prefix = new long[nums.length + 1];\\n        // set 0th element of prefix sum as 0\\n        prefix[0] = 0;\\n        // calculate prefix sum\\n        for(int i = 0; i < nums.length; i++) {\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n        // iterate over nums array, from k to nums.length - k, since we need only viable ranges\\n        for(int i = k; i < nums.length - k; i++) {\\n            // calculate sum by taking prefix sum for right boundary + 1(i + k + 1) and subtracting prefix sum for left boundary(i - k)\\n            long sum = prefix[i + k + 1] - prefix[i - k];\\n            // now calculate average, cast it to int and place in result array\\n            result[i] = (int)(sum / (k * 2 + 1));\\n        }\\n        // return result\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        // declare result array of nums.length\\n        int[] result = new int[nums.length];\\n        // fill it with -1\\n        Arrays.fill(result, -1);\\n        // declare prefix sum arra with nums.length + 1\\n        long[] prefix = new long[nums.length + 1];\\n        // set 0th element of prefix sum as 0\\n        prefix[0] = 0;\\n        // calculate prefix sum\\n        for(int i = 0; i < nums.length; i++) {\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n        // iterate over nums array, from k to nums.length - k, since we need only viable ranges\\n        for(int i = k; i < nums.length - k; i++) {\\n            // calculate sum by taking prefix sum for right boundary + 1(i + k + 1) and subtracting prefix sum for left boundary(i - k)\\n            long sum = prefix[i + k + 1] - prefix[i - k];\\n            // now calculate average, cast it to int and place in result array\\n            result[i] = (int)(sum / (k * 2 + 1));\\n        }\\n        // return result\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668995,
                "title": "two-approach-prefix-sum-and-sliding-window",
                "content": "---\\n# sliding-window approach (optimal)\\n---\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int len = k+k+1;\\n\\n        vector<int> res(n, -1);\\n        long long sum = 0;\\n        int j = 0;\\n\\n        for (int i=0; i<n; i++) {\\n            sum += nums[i];\\n            if (i-j+1 > len) sum -= nums[j++];\\n            if (i-j+1 == len) res[k+j] = sum/len;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n# prefix-sum approach\\n---\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int len = k+k+1;\\n\\n        vector<int> res(n, -1);\\n        vector<long long> psum(n);\\n\\n        psum[0] = 1LL*nums[0];\\n        for (int i=1; i<n; i++) psum[i] = 1LL*psum[i-1] + 1LL*nums[i];\\n\\n        for (int i=k; i<n-k; i++) {\\n            long long a = psum[i+k];\\n            long long b = i-k-1 < 0 ? 0: psum[i-k-1];\\n            res[i] = (a-b)/len;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int len = k+k+1;\\n\\n        vector<int> res(n, -1);\\n        long long sum = 0;\\n        int j = 0;\\n\\n        for (int i=0; i<n; i++) {\\n            sum += nums[i];\\n            if (i-j+1 > len) sum -= nums[j++];\\n            if (i-j+1 == len) res[k+j] = sum/len;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int len = k+k+1;\\n\\n        vector<int> res(n, -1);\\n        vector<long long> psum(n);\\n\\n        psum[0] = 1LL*nums[0];\\n        for (int i=1; i<n; i++) psum[i] = 1LL*psum[i-1] + 1LL*nums[i];\\n\\n        for (int i=k; i<n-k; i++) {\\n            long long a = psum[i+k];\\n            long long b = i-k-1 < 0 ? 0: psum[i-k-1];\\n            res[i] = (a-b)/len;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665597,
                "title": "c-super-easy-sliding-window-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int window = 2 * k + 1 ;\\n        if(window > n) return ans;\\n\\n        vector<int> ans(n,-1);\\n\\n        long long prefix = 0;\\n        for(int i=0; i<window; i++){\\n            prefix += nums[i];\\n        }\\n\\n        int j = k;\\n        ans[j++] = prefix/window;\\n        for(int i=window; i<n; i++){\\n            prefix -= nums[i-window];\\n            prefix += nums[i];\\n            ans[j++] = prefix/window; \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int window = 2 * k + 1 ;\\n        if(window > n) return ans;\\n\\n        vector<int> ans(n,-1);\\n\\n        long long prefix = 0;\\n        for(int i=0; i<window; i++){\\n            prefix += nums[i];\\n        }\\n\\n        int j = k;\\n        ans[j++] = prefix/window;\\n        for(int i=window; i<n; i++){\\n            prefix -= nums[i-window];\\n            prefix += nums[i];\\n            ans[j++] = prefix/window; \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664977,
                "title": "linear-c-solution",
                "content": "# Intuition\\nSliding window by maintaining window sum\\n\\n# Approach\\nmaintain sliding window sum and update the resultant array\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] GetAverages(int[] nums, int k) {\\n        var result = new int[nums.Length];\\n        var windowSize = 2*k + 1;\\n        for(var i = 0; i< nums.Length; i++) result[i] = -1;\\n        \\n        if(nums.Length < windowSize) return result;\\n\\n        var windowStart = 0;\\n        long sum = 0;\\n        for(var i = 0; i<= (2*k) - 1 ; i++) sum += nums[i];\\n\\n        for( var j = (2 * k); j< nums.Length; j++)\\n        {\\n            sum += nums[j];\\n            result[windowStart + k] = (int)(sum/windowSize);\\n            sum -= nums[windowStart];\\n            windowStart += 1;\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetAverages(int[] nums, int k) {\\n        var result = new int[nums.Length];\\n        var windowSize = 2*k + 1;\\n        for(var i = 0; i< nums.Length; i++) result[i] = -1;\\n        \\n        if(nums.Length < windowSize) return result;\\n\\n        var windowStart = 0;\\n        long sum = 0;\\n        for(var i = 0; i<= (2*k) - 1 ; i++) sum += nums[i];\\n\\n        for( var j = (2 * k); j< nums.Length; j++)\\n        {\\n            sum += nums[j];\\n            result[windowStart + k] = (int)(sum/windowSize);\\n            sum -= nums[windowStart];\\n            windowStart += 1;\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664960,
                "title": "linear-java-solution",
                "content": "# Intuition\\nSliding Window approch by maintaining window sum\\n\\n# Approach\\nmaintaining window sum and add to resultant array\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n                int [] rest = new int[nums.length];\\n        int windowSize= 2*k+1;\\n        Arrays.fill(rest,-1);\\n        if(windowSize > nums.length) return rest;\\n        long sum = 0;\\n        for (int i = 0; i <windowSize ; i++) sum += nums[i];\\n        for (int i = k; i < nums.length-k ; i++) {\\n            rest[i] = (int) (sum/windowSize);\\n            if( i+k+1 < nums.length){\\n                sum = sum -nums[i-k] + nums[i+k+1];\\n            }\\n        }\\n        return rest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n                int [] rest = new int[nums.length];\\n        int windowSize= 2*k+1;\\n        Arrays.fill(rest,-1);\\n        if(windowSize > nums.length) return rest;\\n        long sum = 0;\\n        for (int i = 0; i <windowSize ; i++) sum += nums[i];\\n        for (int i = k; i < nums.length-k ; i++) {\\n            rest[i] = (int) (sum/windowSize);\\n            if( i+k+1 < nums.length){\\n                sum = sum -nums[i-k] + nums[i+k+1];\\n            }\\n        }\\n        return rest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664874,
                "title": "sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n=nums.length;\\n        int [] ans=new int[n];\\n        Arrays.fill(ans ,-1);\\n        \\n        if(k==0){\\n            return nums;\\n\\n        }\\n\\n        if(n < 2*k+1){\\n            return ans;\\n\\n        }\\n\\n        int left=0;\\n        int right=2*k;\\n        long sum=0;\\n        int i=k;\\n        for(int j=left; j<=right; j++){\\n            sum=sum+nums[j];\\n        }\\n        int avg=(int)(sum/(2*k+1));\\n        ans[i]=avg;\\n        i++;\\n        right++;\\n        \\n        while(right<n){\\n            int leftsidewindow=nums[left];\\n            int rightsidewindow=nums[right];\\n            sum=sum-leftsidewindow+rightsidewindow;\\n\\n            ans[i]=(int)(sum/(2*k+1));\\n            i++;\\n            right++;\\n            left++;\\n        }\\n        \\n\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n=nums.length;\\n        int [] ans=new int[n];\\n        Arrays.fill(ans ,-1);\\n        \\n        if(k==0){\\n            return nums;\\n\\n        }\\n\\n        if(n < 2*k+1){\\n            return ans;\\n\\n        }\\n\\n        int left=0;\\n        int right=2*k;\\n        long sum=0;\\n        int i=k;\\n        for(int j=left; j<=right; j++){\\n            sum=sum+nums[j];\\n        }\\n        int avg=(int)(sum/(2*k+1));\\n        ans[i]=avg;\\n        i++;\\n        right++;\\n        \\n        while(right<n){\\n            int leftsidewindow=nums[left];\\n            int rightsidewindow=nums[right];\\n            sum=sum-leftsidewindow+rightsidewindow;\\n\\n            ans[i]=(int)(sum/(2*k+1));\\n            i++;\\n            right++;\\n            left++;\\n        }\\n        \\n\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664425,
                "title": "2-methods-o-n-sliding-window-prefix-sum-java",
                "content": "**Prefix Sum**\\n```\\n\\nclass Solution {\\n  public int[] getAverages(int[] nums, int k) {\\n    long prefix[] = new long[nums.length];\\n    int ans[] = new int[nums.length];\\n\\n    long pre = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n      pre = pre + nums[i];\\n      prefix[i] = pre;\\n    }\\n    for (int i = 0; i < nums.length; i++) {\\n      if (i - k < 0 || i + k >= nums.length) {\\n        ans[i] = -1;\\n        continue;\\n      }\\n\\n      if (i - k - 1 < 0) {\\n        ans[i] += prefix[i + k] / (2 * k + 1);\\n        continue;\\n      }\\n     \\n      ans[i] += (prefix[i + k] - prefix[i - k - 1]) / (2 * k + 1);\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\\n\\n**Sliding Window**\\n\\n```\\nclass Solution {\\n  public int[] getAverages(int[] nums, int k) {\\nint ans[] = new int[nums.length];\\nArrays.fill(ans, -1);\\nint i = 0, j = 0;\\nlong sum = 0;\\nwhile (j < nums.length) {\\n  sum += nums[j];\\n  if (j - i + 1 < 2 * k + 1) { //window size not yet hit\\n    j++;\\n  } else if (j - i + 1 == 2 * k + 1) { // window size hit\\n    ans[j - k] = (int) (sum / (2 * k + 1));\\n\\n    sum -= nums[i];\\n    i++;\\n\\n    j++;\\n  }\\n}\\nreturn ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass Solution {\\n  public int[] getAverages(int[] nums, int k) {\\n    long prefix[] = new long[nums.length];\\n    int ans[] = new int[nums.length];\\n\\n    long pre = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n      pre = pre + nums[i];\\n      prefix[i] = pre;\\n    }\\n    for (int i = 0; i < nums.length; i++) {\\n      if (i - k < 0 || i + k >= nums.length) {\\n        ans[i] = -1;\\n        continue;\\n      }\\n\\n      if (i - k - 1 < 0) {\\n        ans[i] += prefix[i + k] / (2 * k + 1);\\n        continue;\\n      }\\n     \\n      ans[i] += (prefix[i + k] - prefix[i - k - 1]) / (2 * k + 1);\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public int[] getAverages(int[] nums, int k) {\\nint ans[] = new int[nums.length];\\nArrays.fill(ans, -1);\\nint i = 0, j = 0;\\nlong sum = 0;\\nwhile (j < nums.length) {\\n  sum += nums[j];\\n  if (j - i + 1 < 2 * k + 1) { //window size not yet hit\\n    j++;\\n  } else if (j - i + 1 == 2 * k + 1) { // window size hit\\n    ans[j - k] = (int) (sum / (2 * k + 1));\\n\\n    sum -= nums[i];\\n    i++;\\n\\n    j++;\\n  }\\n}\\nreturn ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664368,
                "title": "java-solution-using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n=nums.length;\\n        int [] arr=new int[n];\\n        Arrays.fill(arr ,-1);\\n        int d=2 * k + 1;\\n        if(k==0){\\n            return nums;\\n\\n        }\\n\\n        if(n < d){\\n            return arr;\\n\\n        }\\n\\n        long [] sumarr =new long[n];\\n        long sum=0;\\n        for(int i=0; i<n; i++){\\n            sum=sum+nums[i];\\n            sumarr[i]=sum;\\n            \\n        }\\n      //  System.out.print(Arrays.toString(sumarr) +\" \");\\n        \\n\\n        for(int i=k; i+k<n; i++){\\n            if(i-k>0){\\n                arr[i]=(int)((sumarr[i+k]-sumarr[i-k-1])/(2*k+1));\\n            }else if(i-k==0){\\n                arr[i]=(int)((sumarr[i+k])/(2*k+1));\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n=nums.length;\\n        int [] arr=new int[n];\\n        Arrays.fill(arr ,-1);\\n        int d=2 * k + 1;\\n        if(k==0){\\n            return nums;\\n\\n        }\\n\\n        if(n < d){\\n            return arr;\\n\\n        }\\n\\n        long [] sumarr =new long[n];\\n        long sum=0;\\n        for(int i=0; i<n; i++){\\n            sum=sum+nums[i];\\n            sumarr[i]=sum;\\n            \\n        }\\n      //  System.out.print(Arrays.toString(sumarr) +\" \");\\n        \\n\\n        for(int i=k; i+k<n; i++){\\n            if(i-k>0){\\n                arr[i]=(int)((sumarr[i+k]-sumarr[i-k-1])/(2*k+1));\\n            }else if(i-k==0){\\n                arr[i]=(int)((sumarr[i+k])/(2*k+1));\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663295,
                "title": "best-c-beginner-friendly-solution-intuition-and-approach-well-commented",
                "content": "# Intuition\\nAccording to the problem, we have to return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i. Which means for every index i, we have to calculate the sum of the element at current index, k elements coming before, and k elements coming after that point and then calculate it\\'s averge by dividing the sum with the length of the subarray. If at any index the next or the prev k numbers doesn\\'t exists, we have to store -1 at that point and then return it. So the catch here is to calculate the sum of the valid subarray.\\nSince we have to figure out the sum of next and prev k elements at any given point and we can\\'t do this by iterating at each point and then finding the sum so it will be better if we can just store the sums in some arrays.\\n\\n# Approach\\nDeclare two arrays, one is prefix sum and another is suffix sum. Prefix sum will store the sum up to current index from left side and suffix sum will store the sum up to current index from right side.\\nThen iterate in the nums array and for every valid subarray, find the average by finding the sum of next k arrays and the sum of prev k arrays which can be easily calculated with the help of pre and suff arrays.\\n\\nExample: \\nnums[]: 7 4 3 9 1 8 5 2 6\\nk = 3,   i:  0 1 2 3 4 5 6 7 8\\n\\npre[] = 7 11 14 23 24 32 37 39 45\\n\\nsuff[]= 45 38 34 31 22 21 13 8 6\\n\\nfor i = 0, 1, 2, 6, 7 ,8, the subarray doesn\\'t exist.\\n\\nfor i = 3, \\nthe sum of next 3 elements = pre[i+k] - pre[i] i.e pre[6] - pre[3] i.e 37-23 = 14\\nand the sum of prev 3 elements = suff[i-k] - suff[i] i.e suff[0] - suff[3] i.e 45-31 = 14\\navg = (14 + 14 + nums[3])/window length\\n    = (28 + 9)/(2k+1) = 37/(2k+1) = 35/7 = 5\\nSimilarly find the sum at each index and store it in answer vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        //Declare prefix sum and suffix sum vector\\n        int n = nums.size(); \\n        vector<int>ans;\\n        long long int pre[n], suff[n];\\n\\n        //filling prefix sum vector\\n        pre[0] = nums[0];\\n        for(int i = 1; i<n; i++){\\n            pre[i] = pre[i-1] + nums[i];\\n        }\\n\\n        //Filling suffix sum vector\\n        suff[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0; i--){\\n            suff[i] = suff[i+1] + nums[i];\\n        }\\n\\n        //traversing in the nums array\\n        for(int i = 0; i<n; i++){\\n            if(i<k || i+k >=n){ // if the prev k digits and next k digits doesn\\'t exist\\n                ans.push_back(-1);\\n            }\\n            else {\\n                //calculate sum of the k radius\\n                long long int sumOfNextKElements = pre[i+k] - pre[i];\\n                long long int sumOfPrevKElements = suff[i-k] - suff[i];\\n                long long int sum = sumOfNextKElements + sumOfPrevKElements + nums[i];\\n                sum = sum /(2*k +1);\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        //Declare prefix sum and suffix sum vector\\n        int n = nums.size(); \\n        vector<int>ans;\\n        long long int pre[n], suff[n];\\n\\n        //filling prefix sum vector\\n        pre[0] = nums[0];\\n        for(int i = 1; i<n; i++){\\n            pre[i] = pre[i-1] + nums[i];\\n        }\\n\\n        //Filling suffix sum vector\\n        suff[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0; i--){\\n            suff[i] = suff[i+1] + nums[i];\\n        }\\n\\n        //traversing in the nums array\\n        for(int i = 0; i<n; i++){\\n            if(i<k || i+k >=n){ // if the prev k digits and next k digits doesn\\'t exist\\n                ans.push_back(-1);\\n            }\\n            else {\\n                //calculate sum of the k radius\\n                long long int sumOfNextKElements = pre[i+k] - pre[i];\\n                long long int sumOfPrevKElements = suff[i-k] - suff[i];\\n                long long int sum = sumOfNextKElements + sumOfPrevKElements + nums[i];\\n                sum = sum /(2*k +1);\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663294,
                "title": "simple-solution-by-prefix-sum",
                "content": "# Clarification\\n![10.PNG](https://assets.leetcode.com/users/images/1769b29a-4ea1-42d1-8d10-212dc8ede291_1687294428.8834345.png)\\n\\n![13.PNG](https://assets.leetcode.com/users/images/c994bb6f-6ed7-4acc-946e-d81acc64437b_1687294450.6369336.png)\\n\\n\\n\\n\\n# Code (C++)\\n```\\nclass Solution {\\npublic:\\n\\tvector<int> getAverages(vector<int>& nums, int k) {\\n\\n\\t\\tint n;\\n\\t\\tn = nums.size();\\n\\t\\tvector<long long>prf(n + 1, 0);// to create prefix sum 1-based\\n\\t\\tvector<int>res(n, -1);// to make all invalid equal 1\\n\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t{\\n\\t\\t\\tprf[i] = prf[i - 1] + nums[i - 1];// nums[i-1] because nums is base 0\\n\\t\\t}\\n\\n\\t\\t// valid indeces are range >> [k+1 , n-k]\\n\\t\\tfor (int idx = k + 1; idx <= (n - k); idx++)\\n\\t\\t{\\n\\t\\t\\t// the first index for this new subarray is >> idx - k \\n\\t\\t\\tint start = idx - k;\\n\\t\\t\\t// so i need to subtract (first -1) to delete all element before me from prefix sum.\\n\\t\\t\\tstart--;\\n\\t\\t\\tint end = idx + k; // the end of this new subarray\\n\\t\\t\\tlong long Sub_arr = prf[end] - prf[start];\\n\\t\\t\\tSub_arr /= (k * 2 + 1);\\n\\t\\t\\tres[idx - 1] = Sub_arr;// idx-1 >> because i will return vector 0-based and i work with prefix 1-based\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> getAverages(vector<int>& nums, int k) {\\n\\n\\t\\tint n;\\n\\t\\tn = nums.size();\\n\\t\\tvector<long long>prf(n + 1, 0);// to create prefix sum 1-based\\n\\t\\tvector<int>res(n, -1);// to make all invalid equal 1\\n\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t{\\n\\t\\t\\tprf[i] = prf[i - 1] + nums[i - 1];// nums[i-1] because nums is base 0\\n\\t\\t}\\n\\n\\t\\t// valid indeces are range >> [k+1 , n-k]\\n\\t\\tfor (int idx = k + 1; idx <= (n - k); idx++)\\n\\t\\t{\\n\\t\\t\\t// the first index for this new subarray is >> idx - k \\n\\t\\t\\tint start = idx - k;\\n\\t\\t\\t// so i need to subtract (first -1) to delete all element before me from prefix sum.\\n\\t\\t\\tstart--;\\n\\t\\t\\tint end = idx + k; // the end of this new subarray\\n\\t\\t\\tlong long Sub_arr = prf[end] - prf[start];\\n\\t\\t\\tSub_arr /= (k * 2 + 1);\\n\\t\\t\\tres[idx - 1] = Sub_arr;// idx-1 >> because i will return vector 0-based and i work with prefix 1-based\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663122,
                "title": "o-n-sliding-window-algorithm",
                "content": "# Intuition\\nMove accross the array using a sliding window with a width of 2K + 1. Keep a running total of the elements within the window, calculating the average each time the window is moved.\\n\\nThis YouTube video provides an excellent overview of this kind of sliding window algorithm: https://youtu.be/9-3BXsfrpbY\\n\\n# Approach\\nHandle the edge case where K is large enough that every element of the return array should be -1.\\n\\nFirst set all elements within K elements from the start/end of the return array to -1. Then, add up all the numbers within the first iteration of the window and calculate the average. Once this is done, we can iterate through the middle of the array, subtracting the an element from `total` each time it exits the window and adding an element to `total` each time it enters the window - this way, we avoid having to iterate through the window with each iteration of the for loop, resulting in an algorithm with O(N) time complexity instead of O(NK).\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int[] GetAverages(int[] numbers, int k)\\n    {\\n        // Handle edge case where k large enough for the return array to be all 1\\n        if (k > Math.Ceiling((double)numbers.Length / 2.0) - 1)\\n        {\\n            return numbers.Select(number => -1).ToArray();\\n        }\\n\\n        // Array to return\\n        int[] averages = new int[numbers.Length];\\n\\n        // Set the start and end segments of the return array to -1\\n        for (var i = 0; i < k; i++) averages[i] = -1;\\n        for (var i = numbers.Length - k; i < numbers.Length; i++) averages[i] = -1;\\n\\n        // Calculate the averages for the middle of the array. We need to use ulong\\n        // math to prevent overflows when dealing with large sets of large numbers.\\n        // In a real-world scenario, we\\'d probably also want to throw/handle an\\n        // exception if it overflows anyway.\\n        ulong total = 0;\\n        ulong divisor = (ulong)(2*k + 1); // Cache divisor as optimization\\n\\n        // Calculate the first number\\n        for (var i = 0; i <= 2*k; i++) total += (ulong)numbers[i];\\n        averages[k] = (int)(total/divisor);\\n\\n        // For each of the remaining numbers\\n        for (var i = k+1; i < numbers.Length - k; i++)\\n        {\\n            // Adjust the value of total by subtracting and adding the\\n            // relevant two numbers\\n            total -= (ulong)numbers[i - k - 1];\\n            total += (ulong)numbers[i + k];\\n\\n            // Calculate the average\\n            averages[i] = (int)(total/divisor);\\n        }\\n        \\n        // Done\\n        return averages;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] GetAverages(int[] numbers, int k)\\n    {\\n        // Handle edge case where k large enough for the return array to be all 1\\n        if (k > Math.Ceiling((double)numbers.Length / 2.0) - 1)\\n        {\\n            return numbers.Select(number => -1).ToArray();\\n        }\\n\\n        // Array to return\\n        int[] averages = new int[numbers.Length];\\n\\n        // Set the start and end segments of the return array to -1\\n        for (var i = 0; i < k; i++) averages[i] = -1;\\n        for (var i = numbers.Length - k; i < numbers.Length; i++) averages[i] = -1;\\n\\n        // Calculate the averages for the middle of the array. We need to use ulong\\n        // math to prevent overflows when dealing with large sets of large numbers.\\n        // In a real-world scenario, we\\'d probably also want to throw/handle an\\n        // exception if it overflows anyway.\\n        ulong total = 0;\\n        ulong divisor = (ulong)(2*k + 1); // Cache divisor as optimization\\n\\n        // Calculate the first number\\n        for (var i = 0; i <= 2*k; i++) total += (ulong)numbers[i];\\n        averages[k] = (int)(total/divisor);\\n\\n        // For each of the remaining numbers\\n        for (var i = k+1; i < numbers.Length - k; i++)\\n        {\\n            // Adjust the value of total by subtracting and adding the\\n            // relevant two numbers\\n            total -= (ulong)numbers[i - k - 1];\\n            total += (ulong)numbers[i + k];\\n\\n            // Calculate the average\\n            averages[i] = (int)(total/divisor);\\n        }\\n        \\n        // Done\\n        return averages;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662949,
                "title": "c-solution-sliding-window-simplified-o-n-code-with-comment-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding Window with constant length.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window Approach:\\n\\nInitialize variables:\\n\\n- n is the size of the input vector nums.\\n- ans is a vector of size n initialized with -1. This vector will store the computed averages.\\n- i and j are indices used to define the current subarray.\\n- sum is the running sum of elements in the current subarray.\\n\\nIterate through the input vector nums using the variable j as the loop index.\\n\\nAdd the current element nums[j] to the sum.\\n\\nCheck if the length of the current subarray (j-i) is less than 2*k.\\n- If the length is less than 2*k, increment j to expand the subarray.\\n\\nIf the length of the current subarray is equal to 2*k, calculate the average.\\n- Divide the sum by 2*k + 1 to get the average.\\n- Update the ans vector at index i+k with the calculated average.\\n- Subtract the element nums[i] from the sum to remove it from the running sum.\\n- Increment i to move the window.\\nRepeat steps 3-5 until j reaches the end of the input vector.\\n\\nReturn the ans vector containing the computed averages.\\n\\nOverall, this code divides the input vector nums into overlapping subarrays of length 2*k + 1 and calculates the average for each subarray, storing the results in the ans vector.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(constant)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(n, -1); // Create a vector of size n initialized with -1\\n        int i = 0, j = 0; // Initialize two pointers i and j\\n        long long int sum = 0; // Initialize a variable to store the sum of elements in the subarray\\n        \\n        while (j < n) { // Iterate through the input vector using the j pointer\\n            sum += nums[j]; // Add the current element nums[j] to the running sum\\n            \\n            if (j - i < 2 * k) {\\n                j++; // Expand the subarray by incrementing j if the length is less than 2*k\\n            } else if (j - i == 2 * k) { // Once the subarray length is equal to 2*k\\n                int avg = sum / (2 * k + 1); // Calculate the average of the subarray\\n                \\n                ans[i + k] = avg; // Store the average at the corresponding index in the ans vector\\n                \\n                sum = sum - nums[i]; // Remove the element at index i from the running sum\\n                i++; // Move the window by incrementing i\\n                \\n                j++; // Expand the subarray by incrementing j\\n            }\\n        }\\n        \\n        return ans; // Return the ans vector containing the computed averages\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(n, -1); // Create a vector of size n initialized with -1\\n        int i = 0, j = 0; // Initialize two pointers i and j\\n        long long int sum = 0; // Initialize a variable to store the sum of elements in the subarray\\n        \\n        while (j < n) { // Iterate through the input vector using the j pointer\\n            sum += nums[j]; // Add the current element nums[j] to the running sum\\n            \\n            if (j - i < 2 * k) {\\n                j++; // Expand the subarray by incrementing j if the length is less than 2*k\\n            } else if (j - i == 2 * k) { // Once the subarray length is equal to 2*k\\n                int avg = sum / (2 * k + 1); // Calculate the average of the subarray\\n                \\n                ans[i + k] = avg; // Store the average at the corresponding index in the ans vector\\n                \\n                sum = sum - nums[i]; // Remove the element at index i from the running sum\\n                i++; // Move the window by incrementing i\\n                \\n                j++; // Expand the subarray by incrementing j\\n            }\\n        }\\n        \\n        return ans; // Return the ans vector containing the computed averages\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662822,
                "title": "python-solution-using-prefix-sum-concept",
                "content": "# Intuition\\nThe code aims to calculate the averages of subarrays by utilizing the concept of prefix sums to efficiently calculate the sum of elements within each subarray.\\n\\n# Approach\\n1. The `getPrefixSum` method calculates the prefix sum of the `nums` list and returns a prefix sum list.\\n\\n2. The `getAverages` method takes in the `nums` list and the subarray size `k`. It initializes an empty `result` list of the same length as `nums`, filled with -1.\\n\\n4. It iterates from index `k` to `len(nums)-k-1`. For each index `i`:\\n   - If `i` is equal to `k`, it calculates the average as `(prefix[i+k]) // (2*k+1)` and assigns it to `result[i]`.\\n   - For other indices, it calculates the average as `(prefix[i+k] - prefix[i-k-1]) // (2*k+1)` and assigns it to `result[i]`.\\n\\n5. Finally, the `result` list containing the averages of subarrays.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n# Code\\n```\\nclass Solution:\\n    def getPrefixSum(self,nums):   \\n        prefix = [nums[0]]\\n        for i in range(1,len(nums)):\\n            prefix.append(prefix[i-1] + nums[i])\\n        return prefix \\n    \\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        prefix = self.getPrefixSum(nums)    \\n        result = [-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            if i == k:\\n                result[i] = (prefix[i+k])//(2*k+1)\\n            else:\\n                result[i] = (prefix[i+k]-prefix[i-k-1])//(2*k+1)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def getPrefixSum(self,nums):   \\n        prefix = [nums[0]]\\n        for i in range(1,len(nums)):\\n            prefix.append(prefix[i-1] + nums[i])\\n        return prefix \\n    \\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        prefix = self.getPrefixSum(nums)    \\n        result = [-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            if i == k:\\n                result[i] = (prefix[i+k])//(2*k+1)\\n            else:\\n                result[i] = (prefix[i+k]-prefix[i-k-1])//(2*k+1)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662765,
                "title": "c-solution-using-prefix-and-suffix-sum",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int>res(n,-1);\\n\\n        vector<long long>prefix(n+1);\\n        vector<long long>suffix(n+1);\\n\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(i-k<0 || i+k>=n){\\n                continue;\\n            }\\n             else{\\n     long long sum=(long long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n               sum=sum/(2*k+1);\\n               res[i]=sum;\\n           }\\n        }\\n\\n         return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int>res(n,-1);\\n\\n        vector<long long>prefix(n+1);\\n        vector<long long>suffix(n+1);\\n\\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(i-k<0 || i+k>=n){\\n                continue;\\n            }\\n             else{\\n     long long sum=(long long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n               sum=sum/(2*k+1);\\n               res[i]=sum;\\n           }\\n        }\\n\\n         return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662716,
                "title": "python-o-n-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can iterate over each index of the array and check whether a valid window of size 2k + 1 can be formed around that index.\\n\\n- If it is not possible to form a valid window, we add -1 to the result.\\n- If a valid window can be formed, we have two cases:\\n    - **Case 1**: *The sum of the window has not been calculated yet*. \\n    In this case, we calculate the sum of the elements in the window and add the average of the sum to the result.\\n    - **Case 2**: *The sum of the window has been calculated for the previous index*. \\n    In this case, we subtract the leftmost element of the previous window and add the rightmost element of the current window. Then we find the average of the new sum and add it to the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize variables:\\n\\n- **`n`** as the length of the input array nums.\\n- **`is_sum_cal`** as `False` to keep track of whether the sum of the window has been calculated.\\n- **`win_sum`** as `0` to store the sum of the window.\\n- **`win_size`** as `2k + 1` to represent the size of the window.\\n- **`res`** as an empty list to store the results.\\n\\n2. Iterate over each index `i` from `0` to `n-1`:\\n\\n- Check if a valid window can be formed around index `i` by ensuring that `i-k` is greater than or equal to `0` and `i+k` is less than `n`.\\n    - If a valid window cannot be formed, add `-1` to the result.\\n    - If a valid window can be formed:\\n        - **Case 1**: Check if the sum of the window has not been calculated (**`is_sum_cal`** is `False`).\\n            - Calculate the sum of the elements in the window nums`[i-k: i+k+1]` and assign it to win_sum.\\n            - Set **`is_sum_cal`** to `True`.\\n            - Calculate the average of the sum `(win_sum//win_size)` and add it to the result.\\n        - **Case 2**: The sum of the window has been calculated.\\n            - Subtract the leftmost element of the previous window `(nums[i-k-1])` from **`win_sum`**.\\n            - Add the rightmost element of the current window `(nums[i+k])` to **`win_sum`**.\\n            - Calculate the average of the new sum `(win_sum//win_size)` and add it to the result.\\n\\n3. Return the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) where N is the length of the input array nums. We iterate over each index once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), excluding the output to return. We use a constant amount of additional space for variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n\\n        is_sum_cal = False\\n        win_sum = 0\\n        win_size = 2*k + 1\\n\\n        res = []\\n\\n        for i in range(n):\\n            if i-k >= 0 and i+k < n:\\n                if not is_sum_cal:\\n                    win_sum = sum(nums[i-k: i+k+1])\\n                    is_sum_cal = True\\n                    res.append(win_sum//win_size)\\n                else:\\n                    win_sum -= nums[i-k-1]\\n                    win_sum += nums[i+k]\\n                    res.append(win_sum//win_size)\\n            else:\\n                res.append(-1)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n\\n        is_sum_cal = False\\n        win_sum = 0\\n        win_size = 2*k + 1\\n\\n        res = []\\n\\n        for i in range(n):\\n            if i-k >= 0 and i+k < n:\\n                if not is_sum_cal:\\n                    win_sum = sum(nums[i-k: i+k+1])\\n                    is_sum_cal = True\\n                    res.append(win_sum//win_size)\\n                else:\\n                    win_sum -= nums[i-k-1]\\n                    win_sum += nums[i+k]\\n                    res.append(win_sum//win_size)\\n            else:\\n                res.append(-1)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662712,
                "title": "c-top99-easy-concept-o-n-o-n-beginner-friendly",
                "content": "# Detailed Solution\\n**Sliding Window Approach**\\n* In this approach , we take/assume a window of required `(k)` size .\\n* Afterwards we asssume the window to be moving through the array by taking in the next value and retarding the value outside the window i.e `(i-k)`, like this ![image](https://assets.leetcode.com/users/images/24d083f2-6345-48e9-9ee3-a284ad3ca678_1687282350.5657628.png)\\n* **CODE:**\\n```\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n            \\n            int n=nums.size(),w_size=2*k+1;\\n            long cumm_sum=0;\\n            vector<int> avgs(n);\\n            \\n            for(int i=0;i<n && i<k;i++)\\n                    avgs[i]=-1,avgs[n-i-1]=-1;\\n            \\n            if(w_size-1>=n) return avgs;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                    cumm_sum+=nums[i];\\n                    \\n                    if(i>w_size-2)\\n                    {\\n                            avgs[i-k]=cumm_sum/w_size;\\n                            cumm_sum-=nums[i+1-w_size];\\n                    }\\n            }\\n            return avgs;\\n    }\\n```\\n**Code Flow:**\\n1.  Let\\'s know some major points first of all :\\n\\t* Everytime my window shifts, the avg is stored in the middle that is, `avgs[i]`.\\n\\t* In this way I leave the indexes that should be filled with `-1`.\\n<br>\\n2. 1. First I take `w_size`(window size) as `2*k+1` and `cumm_sum`(cummulative sum) so as to use them further.\\n\\t3. Then I fill all the indexes of `avgs` with `-1` that are outside the radius.\\n\\t4.  Then I check if window size is greater than `nums` size of yes return `avgs` that\\'d be having all `-1.`\\n\\t5.  Then at last inside the loop i keep the track of cumm_sum and shift the window by 1 in each iteration ,calculate the average of the curreent window and fill in at the middle of the window.\\n\\n![image](https://assets.leetcode.com/users/images/2d72686f-7947-4653-876e-6d6f46d3fa08_1687281968.739409.png)\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n            \\n            int n=nums.size(),w_size=2*k+1;\\n            long cumm_sum=0;\\n            vector<int> avgs(n);\\n            \\n            for(int i=0;i<n && i<k;i++)\\n                    avgs[i]=-1,avgs[n-i-1]=-1;\\n            \\n            if(w_size-1>=n) return avgs;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                    cumm_sum+=nums[i];\\n                    \\n                    if(i>w_size-2)\\n                    {\\n                            avgs[i-k]=cumm_sum/w_size;\\n                            cumm_sum-=nums[i+1-w_size];\\n                    }\\n            }\\n            return avgs;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3662670,
                "title": "normal-sliding-window",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = size(nums);\\n        \\n        vector<int> ans(n,-1);\\n        \\n        int i=0,j=0;\\n        long long sum = 0;\\n\\n        while(j<n)\\n        {\\n            sum += nums[j];\\n\\n            if(j-i == 2*k)\\n            {\\n                int avg = -1;\\n                if((2*k+1) != 0)\\n                    avg = sum/(2*k+1);\\n\\n                int idx = (i+j)/2;\\n                ans[idx] = avg;\\n                sum = sum-nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/da69d522-8deb-4aa6-a4db-446363bf029f_1687283488.9528875.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = size(nums);\\n        \\n        vector<int> ans(n,-1);\\n        \\n        int i=0,j=0;\\n        long long sum = 0;\\n\\n        while(j<n)\\n        {\\n            sum += nums[j];\\n\\n            if(j-i == 2*k)\\n            {\\n                int avg = -1;\\n                if((2*k+1) != 0)\\n                    avg = sum/(2*k+1);\\n\\n                int idx = (i+j)/2;\\n                ans[idx] = avg;\\n                sum = sum-nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662667,
                "title": "c-o-n-time-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        ll sum = 0;\\n        vector<int> ans(n,-1);\\n        \\n        if(n < 2*k)\\n            return ans;\\n        \\n        for(int i = 0;i<2*k;i++){\\n            sum += nums[i];\\n        }\\n        \\n        for(int i=k;i<n-k;i++){\\n            \\n            sum += nums[i+k];\\n            int avg = sum/(2*k+1);\\n            ans[i] = avg;\\n            sum -= nums[i-k];\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        ll sum = 0;\\n        vector<int> ans(n,-1);\\n        \\n        if(n < 2*k)\\n            return ans;\\n        \\n        for(int i = 0;i<2*k;i++){\\n            sum += nums[i];\\n        }\\n        \\n        for(int i=k;i<n-k;i++){\\n            \\n            sum += nums[i+k];\\n            int avg = sum/(2*k+1);\\n            ans[i] = avg;\\n            sum -= nums[i-k];\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662380,
                "title": "sliding-window-technique-o-n",
                "content": "# Approach\\nIterate through the entire array and when `index - k` and `index + k` exists update the answer array with the average of all the elements that lie in the range i.e. the radius. \\n\\n# Complexity\\n- Time complexity: Iterating through the entire loop once gives a time complexity of O(n). Inside each loop we calculate the sum of (2K + 1) elements. So this brings the complexity to $$O(nk)$$\\n\\n- Space complexity: $$O(1$$)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(n, -1);\\n        \\n        for(int i = 0; i < n; i++) {\\n            // if radius is possible for the current index\\n            if(i+k < n and i-k >= 0) {\\n                auto beg = nums.begin();\\n                // calulate the average of the radius \\n                ans[i] = accumulate(beg + i - k, beg + i + k + 1, 0) / (2 * k + 1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n**N.B.**  This code gives TLE since `n` and `k` are both of the order $$10^5$$. Therefore total operations becomes of the order $$10^{10}$$\\n\\nSo we need a way such that the calculation of sum doesn\\'t take every time we need it. Hence, we use the sliding **window technique**. \\n\\n\\nWe follow the following steps\\n1. Initialize an `ans` array with values `-1` so that we don\\'t need to handle any cases where the radius doesn\\'t lie in the range of the array.\\n2. The size of the subarray whose average we need to find is equal to `2 * k + 1`. One is added because we consider the element at current index as well.\\n3. Now for each iteration we calculate the running sum of the array elements and store it in the variable `sum`. Remember to keep it of long long type to avoid overflow.\\n4. When we reach the required radius denoted by `windowSize` we calulate the average and store it at index `(j + i) / 2`. \\n5. Then we remove the element at the beginning of the window to make way for the next element to be added.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i(0), j(0);\\n        long long sum = 0;\\n        int windowSize = 2*k + 1;\\n        vector<int> ans(n, -1);\\n\\n        while(i < n) {\\n            sum += nums[i];\\n            \\n            if(i - j + 1 == windowSize) {\\n                ans[(j + i) / 2] = sum / windowSize;\\n                sum -= nums[j++];\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(n, -1);\\n        \\n        for(int i = 0; i < n; i++) {\\n            // if radius is possible for the current index\\n            if(i+k < n and i-k >= 0) {\\n                auto beg = nums.begin();\\n                // calulate the average of the radius \\n                ans[i] = accumulate(beg + i - k, beg + i + k + 1, 0) / (2 * k + 1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i(0), j(0);\\n        long long sum = 0;\\n        int windowSize = 2*k + 1;\\n        vector<int> ans(n, -1);\\n\\n        while(i < n) {\\n            sum += nums[i];\\n            \\n            if(i - j + 1 == windowSize) {\\n                ans[(j + i) / 2] = sum / windowSize;\\n                sum -= nums[j++];\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662162,
                "title": "one-loop-similar-to-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int[] res = new int[nums.length]; Arrays.fill(res, -1);\\nint s =0; long sum=0;\\n        for(int i=0; i<nums.length; i++){\\n            sum+=nums[i];\\n\\n            if(i==((k*2)+s)){\\n                res[k+s]=(int)(sum/(k*2+1));\\n                sum-=nums[s];\\n                s++;\\n            }\\n\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int[] res = new int[nums.length]; Arrays.fill(res, -1);\\nint s =0; long sum=0;\\n        for(int i=0; i<nums.length; i++){\\n            sum+=nums[i];\\n\\n            if(i==((k*2)+s)){\\n                res[k+s]=(int)(sum/(k*2+1));\\n                sum-=nums[s];\\n                s++;\\n            }\\n\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662161,
                "title": "c-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int>ans;\\n        int n=nums.size();\\n        int i=0,j=2*k;\\n        if(n<=2*k){\\n            vector<int>v(n,-1);\\n            return v;\\n        }\\n\\n        for(int a=0;a<k;a++){\\n            ans.push_back(-1);\\n        }\\n      \\n        long long sum=0;\\n        for(int a=i;a<=j;a++)sum+=nums[a];\\n        \\n        while(j<n && i<n){\\n            int avg=sum/(2*k+1);\\n            ans.push_back(avg);\\n            sum-=nums[i];\\n            i++;\\n            j++;\\n            if(j<n)sum+=nums[j]; \\n        }\\n        for(int a=0;a<k;a++){\\n            ans.push_back(-1);\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int>ans;\\n        int n=nums.size();\\n        int i=0,j=2*k;\\n        if(n<=2*k){\\n            vector<int>v(n,-1);\\n            return v;\\n        }\\n\\n        for(int a=0;a<k;a++){\\n            ans.push_back(-1);\\n        }\\n      \\n        long long sum=0;\\n        for(int a=i;a<=j;a++)sum+=nums[a];\\n        \\n        while(j<n && i<n){\\n            int avg=sum/(2*k+1);\\n            ans.push_back(avg);\\n            sum-=nums[i];\\n            i++;\\n            j++;\\n            if(j<n)sum+=nums[j]; \\n        }\\n        for(int a=0;a<k;a++){\\n            ans.push_back(-1);\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662069,
                "title": "prefix-sum",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nur time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        pin=len(nums)\\n        window=2*k+1\\n        a=[-1]*len(nums)\\n        pre=[0]*(pin+1)\\n        for i in range(pin):\\n            pre[i+1]=pre[i]+nums[i]\\n        for i in range(k,pin-k):\\n            a[i]=(pre[i+k+1]-pre[i-k])//window\\n        return a\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        pin=len(nums)\\n        window=2*k+1\\n        a=[-1]*len(nums)\\n        pre=[0]*(pin+1)\\n        for i in range(pin):\\n            pre[i+1]=pre[i]+nums[i]\\n        for i in range(k,pin-k):\\n            a[i]=(pre[i+k+1]-pre[i-k])//window\\n        return a\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661967,
                "title": "short-python3-sliding-window-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n### Brute Force\\nThe simple brute force way to go about this is by looking at each index, if the `index - k` or `index + k` doesn\\'t exist then we mark that index as -1. Otherwise we look at that index and sum `i-k to i+k` and mark that index as the result. However, with this approach the time complexity increases as you are doing repeated calculations.\\n\\n### Optimized\\nInstead we can use the sliding window technique, which utilizes a rollingSum. We know that the sum will only ever change by `i+k` and `i-k`. Therefore we can optimize by only doing these calculations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs I mentioned previously we will be using the sliding window approach. First we can create a return list that will contain the averages. We can initialize all the values to -1 to handle the indexes that cannot be averaged. Next we can initialize the rollingSum to 0. For the sliding window portion we want to continuously add the `nums[i]` we are at, and to handle the edge cases, only when the `i` value is greater than the full length which is `2*k+1` will we ever insert into the list. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) -> where n is the length of nums\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) -> The avgList is the same length as len(nums)\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        avgList = [-1] * len(nums)\\n        rollingSum, length = 0, 2*k\\n\\n        for i in range(len(nums)):\\n            rollingSum += nums[i]\\n            if i >= length:\\n                avgList[i-k] = rollingSum // (length+1)\\n                rollingSum -= nums[i-length]\\n\\n            \\n        return avgList\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        avgList = [-1] * len(nums)\\n        rollingSum, length = 0, 2*k\\n\\n        for i in range(len(nums)):\\n            rollingSum += nums[i]\\n            if i >= length:\\n                avgList[i-k] = rollingSum // (length+1)\\n                rollingSum -= nums[i-length]\\n\\n            \\n        return avgList\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661881,
                "title": "python-easy-code-beats-90-o-n",
                "content": "# Intuition\\n\\nSliding window approach will be used to get the sum and change it as we keep propagating with the array. If k==0 we return nums itself. if 2*k + 1 > n : we return [-1]*n (n being len(nums)). Otherwise we calculate average for indexes k to n - k -1.\\n\\n# Complexity \\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        if k==0:\\n            return nums\\n        n = len(nums)\\n        ans = [-1]*n\\n        if 2*k + 1> n:\\n            return ans\\n        val = 0\\n        if(2*k < n):\\n            val =  sum(nums[:2*k+1])\\n            avg = val//(2*k +1)\\n            ans[k] = avg\\n            for i in range(k+1,n-k):\\n                if(i-k-1>=0 and i+k<n):\\n                    val -= nums[i-k-1]\\n                    val += nums[i+k]\\n                    avg = val//(2*k +1)\\n                    ans[i] = avg\\n        return ans\\n \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        if k==0:\\n            return nums\\n        n = len(nums)\\n        ans = [-1]*n\\n        if 2*k + 1> n:\\n            return ans\\n        val = 0\\n        if(2*k < n):\\n            val =  sum(nums[:2*k+1])\\n            avg = val//(2*k +1)\\n            ans[k] = avg\\n            for i in range(k+1,n-k):\\n                if(i-k-1>=0 and i+k<n):\\n                    val -= nums[i-k-1]\\n                    val += nums[i+k]\\n                    avg = val//(2*k +1)\\n                    ans[i] = avg\\n        return ans\\n \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661870,
                "title": "easy-clean-code-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- We\\'ll create an average vector of size same as nums : n, and initialize with \\'-1\\' \\n- Now if the index is valid then we\\'ll update the values accordingly\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> avg(n, -1);\\n        if (2*k+1>n) return avg;\\n        unsigned long long sum=0;\\n        //sum=accumulate(nums.begin(), nums.begin()+(k*2+1), 0L);\\n        for(int i=0; i<=2*k; i++){\\n            sum+=nums[i];\\n        }\\n        avg[k]=sum/(2*k+1);\\n        for(int i=k+1; i<n-k; i++){\\n            sum+=nums[k+i]-nums[i-k-1];\\n            avg[i]=sum/(2*k+1);\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> avg(n, -1);\\n        if (2*k+1>n) return avg;\\n        unsigned long long sum=0;\\n        //sum=accumulate(nums.begin(), nums.begin()+(k*2+1), 0L);\\n        for(int i=0; i<=2*k; i++){\\n            sum+=nums[i];\\n        }\\n        avg[k]=sum/(2*k+1);\\n        for(int i=k+1; i<n-k; i++){\\n            sum+=nums[k+i]-nums[i-k-1];\\n            avg[i]=sum/(2*k+1);\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661844,
                "title": "c-solution-o-n-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe only need to focus on the middle indexes which have atleast left side k elements and right side k elements.\\n\\nThe loop we are running is from i = k to i = n-k where n = nums.size()\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> avg(nums.size(),-1);\\n        if(k == 0)\\n            return nums;\\n\\n        if(nums.size() <= 2*k)\\n        {\\n            return avg;\\n        }\\n        int idx = 2*k + 1;\\n        long long sum = 0;\\n        sum = accumulate(nums.begin(),nums.begin()+idx,sum);\\n        \\n        for(int i = k; i < nums.size()-k; i++)\\n        {\\n            avg[i] = sum/idx;\\n            sum = sum - nums[i-k];\\n            \\n            if(i+k+1 == nums.size())\\n                break;\\n            \\n            sum += nums[i+k+1];\\n        }\\n\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int> avg(nums.size(),-1);\\n        if(k == 0)\\n            return nums;\\n\\n        if(nums.size() <= 2*k)\\n        {\\n            return avg;\\n        }\\n        int idx = 2*k + 1;\\n        long long sum = 0;\\n        sum = accumulate(nums.begin(),nums.begin()+idx,sum);\\n        \\n        for(int i = k; i < nums.size()-k; i++)\\n        {\\n            avg[i] = sum/idx;\\n            sum = sum - nums[i-k];\\n            \\n            if(i+k+1 == nums.size())\\n                break;\\n            \\n            sum += nums[i+k+1];\\n        }\\n\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661764,
                "title": "python3-one-pass-100-faster-53-less-mem",
                "content": "# Intuition\\nJust scan the input.\\nKeep track of sum of sliding window sum.\\n\\n# Approach\\n1. start with `[-1, -1, ..., -1]` of size `n`\\n2. calculate the initial window sum `s := sum(nums[:r])`\\n3. store int(sum / radius)\\n4. slide the window by adding element from the right and removing from the left.\\n5. repeat from step 3 until window gets to the end of `nums`\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ (we don\\'t count the output!) \\n\\nIf you like it, please up-vote. Thanks!\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        ans = [-1] * n\\n        r = 2*k + 1\\n        if r > n:\\n            return ans\\n        s = 0\\n        for i in range(r):\\n            s+=nums[i]\\n        span = k+k+1-n  # -n so wo dont have to deal with last iteration \\n        for i in range(n-k-k):\\n            ans[i+k] = s // r\\n            s += nums[i+span] - nums[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        ans = [-1] * n\\n        r = 2*k + 1\\n        if r > n:\\n            return ans\\n        s = 0\\n        for i in range(r):\\n            s+=nums[i]\\n        span = k+k+1-n  # -n so wo dont have to deal with last iteration \\n        for i in range(n-k-k):\\n            ans[i+k] = s // r\\n            s += nums[i+span] - nums[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661720,
                "title": "c-sliding-window-complete-explanation-easy-intuition-observation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s see the example:\\n\\nTake a vector of size 8: ```[1,1,1,1,**1**,1,1,1]```\\n\\nTake the ```1``` at index $$4$$.\\n$$(i-4)=(4-4)=0$$ \\n$$(i+4)=(4+4)=8$$\\nBut for Array of size 8, the $$lastindex = 7$$\\nThus answer will entirely be ```[-1,-1,-1,-1,-1,-1,-1,-1]```\\n\\nSo you require the size of given array to be at least: $$2*k+1$$\\nSo in our example, `k=4`, we require an array of at least size 9.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Window size is always $$(i-(i-k))+((i+k)-i)+1 = 2*k+1$$\\n- Array must be of size minimum $$2*k+1$$\\n- Have 3 pointers: one back element, one current element, one right element\\n- When you shift the window, add right element, subtract left element \\n[Classic Sliding Window]\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1) \\n[Because answer requires an array so array not counted in space complexity]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // k=4\\n    // [1,1,1,1,1,1,1,1,1] (At least 9 required)\\n    // window always of size (2*k+1)\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size(),window_size=2*k+1;\\n        vector<int> v(n,-1);\\n        if(n<window_size) return v;\\n        \\n        int l,cur,r; //pointers\\n        unsigned long long sum=0; //track sum\\n        l=0-k,cur=0,r=cur+k;\\n\\n        while(l<0) sum+=(nums[cur++]+nums[r++]),++l;\\n        sum+=nums[r]; // add the last r element that you couldn\\'t add when l reached 0\\n        \\n        //you can also do - keep the while loop condition as (l<=0)\\n        //then \"sum-=nums[l];\" after loop completes because:\\n        //duplicate addition as l reaches index of initial r\\n\\n        while(r<n)\\n        {\\n            if(cur<n) v[cur]=sum/window_size;\\n            sum-=nums[l];\\n            if(r+1<n) sum+=nums[r+1];\\n            else break; //reached right end of array, end\\n            l++,r++,cur++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```[1,1,1,1,**1**,1,1,1]```\n```1```\n```[-1,-1,-1,-1,-1,-1,-1,-1]```\n```\\nclass Solution {\\npublic:\\n    // k=4\\n    // [1,1,1,1,1,1,1,1,1] (At least 9 required)\\n    // window always of size (2*k+1)\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size(),window_size=2*k+1;\\n        vector<int> v(n,-1);\\n        if(n<window_size) return v;\\n        \\n        int l,cur,r; //pointers\\n        unsigned long long sum=0; //track sum\\n        l=0-k,cur=0,r=cur+k;\\n\\n        while(l<0) sum+=(nums[cur++]+nums[r++]),++l;\\n        sum+=nums[r]; // add the last r element that you couldn\\'t add when l reached 0\\n        \\n        //you can also do - keep the while loop condition as (l<=0)\\n        //then \"sum-=nums[l];\" after loop completes because:\\n        //duplicate addition as l reaches index of initial r\\n\\n        while(r<n)\\n        {\\n            if(cur<n) v[cur]=sum/window_size;\\n            sum-=nums[l];\\n            if(r+1<n) sum+=nums[r+1];\\n            else break; //reached right end of array, end\\n            l++,r++,cur++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661529,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "https://www.youtube.com/watch?v=gvAshJLzSrI\\nDo Check out my YouTube video for Detiled explanation of everything.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(n, -1);\\n        int i =0, j=0;\\n        long long sum =0;\\n        int size = (2*k) +1;\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            if(j-i+1 == size)\\n            {\\n                ans[j-k] = (sum/size);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(n, -1);\\n        int i =0, j=0;\\n        long long sum =0;\\n        int size = (2*k) +1;\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            if(j-i+1 == size)\\n            {\\n                ans[j-k] = (sum/size);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661463,
                "title": "c-simple-using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have to calculate the avg of a particular window size say ****2*k+1*** , its better to store the summation of the elements upto the index in a preix array. This will avoid from looping to find the sum of the window size.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we store the prefix sum in a vector.\\n```\\nvector<long long> preSum;\\n        long long sum=0;\\n        for(int x:nums){\\n            sum+=x;\\n            preSum.push_back(sum);\\n        }\\n\\n```\\n\\n---\\n\\nAfter this step the prefix sum is going to look like this\\n```\\n/*  \\n    index -> 0   1   2   3   4   5   6   7   8 \\n    nums  -> 7   4   3   9   1   8   5   2   6\\n    preSum-> 7   11  14  23  24  32  37  39  45\\n*/\\n```\\n*So how does it helps to calculate the avg?*\\n\\n***--->Example 1 :*** Suppose you\\'re at **index->4** **[k=3]**\\n```\\n    index -> 0   1   2   3   4   5   6   7   8 \\n    nums  -> 7   4   3   9   1   8   5   2   6\\n                 <---------- ^ ---------->\\n                 |     *Window Size*     |\\n                low                     high\\n                 |                       |\\n    preSum-> 7   11  14  23  24  32  37  39  45\\n```\\nBy Common observation we know that ,\\n            ***Window Size =*** 2*k + 1\\n***Low index =*** i - k\\n***High index =*** i + k\\n\\n---\\n\\n***Window Size sum =*** ```preSum[high] - preSum[low-1]```\\n```\\n    index        -> 0   1   2   3   4   5   6   7   8 \\n    nums         -> 7   4   3   9   1   8   5   2   6\\n                        <---------- ^ ---------->\\n                        |   *Window Size Sum*   |\\n                       low                     high\\n                                               \\n*Window Size Sum*->  4+3+9+1+8+5+2 = 32 = preSum[high]-preSum[low-1]  \\n```\\n\\n---\\n\\n**Edge case :** While being at index i = k **[k=3]**\\n```\\n    index -> 0   1   2   3   4   5   6   7   8 \\n    nums  -> 7   4   3   9   1   8   5   2   6\\n             <---------- ^ ---------->\\n             |     *Window Size*     |\\n            low                     high\\n             |                       |\\n    preSum-> 7   11  14  23  24  32  37  39  45\\n```\\nHere ```low = 0``` so ```low - 1 = -1``` which is not possible so\\n***Window Size sum =*** ``` preSum[high] ```\\n# Time Complexity\\n$$O(n) $$  -> Making of preSum\\n$$O(n) $$  -> Modification of nums\\n\\nAll the Arithmetic and Conditional operations occurs in $$O(1)$$\\n\\nSo ***Total Time Complexity :*** $$2O(n)$$ \\u2248 $$O(n)$$\\n# Space Complexity\\n$$O(n) $$  -> Making of preSum\\nSo ***Total Time Complexity :*** $$O(n)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        // making the prefix sum array; \\n        vector<long long> preSum;\\n        long long sum=0;\\n        for(int x:nums){\\n            sum+=x;\\n            preSum.push_back(sum);\\n        }\\n        for(int i=0 ; i<n ; i++){\\n            //if the index is out of bounds for the window size [i.e for index->i , window size->{i-k,i+k} ] we set nums[i]= -1.\\n            if(i<k || n-1-i<k){\\n                nums[i]=-1;\\n            }\\n            else{\\n\\n            int low = i-k , high = i+k;\\n            if(low-1<0){ // handling the edge case\\n                    nums[i] = preSum[high]/(2*k+1);\\n                }\\n            else{\\n                    nums[i] = (preSum[high]-preSum[low-1])/(2*k+1);\\n                }\\n            }\\n\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n>  Upvote if understood \\n\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<long long> preSum;\\n        long long sum=0;\\n        for(int x:nums){\\n            sum+=x;\\n            preSum.push_back(sum);\\n        }\\n\\n```\n```\\n/*  \\n    index -> 0   1   2   3   4   5   6   7   8 \\n    nums  -> 7   4   3   9   1   8   5   2   6\\n    preSum-> 7   11  14  23  24  32  37  39  45\\n*/\\n```\n```\\n    index -> 0   1   2   3   4   5   6   7   8 \\n    nums  -> 7   4   3   9   1   8   5   2   6\\n                 <---------- ^ ---------->\\n                 |     *Window Size*     |\\n                low                     high\\n                 |                       |\\n    preSum-> 7   11  14  23  24  32  37  39  45\\n```\n```preSum[high] - preSum[low-1]```\n```\\n    index        -> 0   1   2   3   4   5   6   7   8 \\n    nums         -> 7   4   3   9   1   8   5   2   6\\n                        <---------- ^ ---------->\\n                        |   *Window Size Sum*   |\\n                       low                     high\\n                                               \\n*Window Size Sum*->  4+3+9+1+8+5+2 = 32 = preSum[high]-preSum[low-1]  \\n```\n```\\n    index -> 0   1   2   3   4   5   6   7   8 \\n    nums  -> 7   4   3   9   1   8   5   2   6\\n             <---------- ^ ---------->\\n             |     *Window Size*     |\\n            low                     high\\n             |                       |\\n    preSum-> 7   11  14  23  24  32  37  39  45\\n```\n```low = 0```\n```low - 1 = -1```\n``` preSum[high] ```\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        // making the prefix sum array; \\n        vector<long long> preSum;\\n        long long sum=0;\\n        for(int x:nums){\\n            sum+=x;\\n            preSum.push_back(sum);\\n        }\\n        for(int i=0 ; i<n ; i++){\\n            //if the index is out of bounds for the window size [i.e for index->i , window size->{i-k,i+k} ] we set nums[i]= -1.\\n            if(i<k || n-1-i<k){\\n                nums[i]=-1;\\n            }\\n            else{\\n\\n            int low = i-k , high = i+k;\\n            if(low-1<0){ // handling the edge case\\n                    nums[i] = preSum[high]/(2*k+1);\\n                }\\n            else{\\n                    nums[i] = (preSum[high]-preSum[low-1])/(2*k+1);\\n                }\\n            }\\n\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661354,
                "title": "efficient-solution-with-incremental-calculation",
                "content": "# Intuition\\n    The problem requires calculating the moving average of an array\\n     nums with a given window size 2k+1.\\n     We need to find an efficient solution to compute the average\\n     efficiently for each window.\\n# Approach\\n    To solve this problem efficiently, we can use the concept of \\n    incremental calculation. Instead of recalculating the sum of each \\n    window from scratch, we can update the sum by subtracting the element\\n\\n    going out of the window and adding the new element coming into the window.\\n\\n\\n    Create an array avg to store the averages for each window.\\n    Check for the edge case where k is 0. In this case, return the \\n    original array nums.\\n    Initialize the sum variable as the sum of the first k elements of\\n    nums.\\n\\n    Iterate through the array nums from index k to nums.Length - 1:\\n    If the current index is less than k or greater than nums.Length -\\n    k - 1, set avg[i] to -1 since the window is not complete.\\n\\n    Otherwise, update the sum by subtracting the element going out of\\n    the window (i.e., nums[i - k]) and adding the new element coming \\n    into the window (i.e., nums[i]).\\n\\n    Compute the average by dividing the sum by k.\\n\\n    Set avg[i] to the computed average.\\n\\n    Return the avg array.\\n\\n# Complexity\\n    Time complexity: O(n), where n is the length of the input array\\n     nums. We iterate through the array once to compute the averages.\\n    Space complexity: O(n), where n is the length of the input array\\n     nums. We use an additional array avg to store the computed averages.\\n# Code\\n```\\npublic class Solution {\\n    public int[] GetAverages(int[] nums, int k) {\\n        int[] avg = new int[nums.Length];\\n        if (k == 0)\\n            return nums;\\n\\n        long sum = 0;\\n\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (i < k || i > nums.Length - k - 1 || k == 0) {\\n                avg[i] = -1;\\n            } else {\\n                if (i == k) {\\n                    for (int j = 0; j <= 2 * k; j++) {\\n                        sum += nums[j];\\n                    }\\n                } else {\\n                    sum -= nums[i - k - 1];\\n                    sum += nums[i + k];\\n                }\\n                avg[i] = (int)(sum / (2 * k + 1));\\n            }\\n        }\\n\\n        return avg;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetAverages(int[] nums, int k) {\\n        int[] avg = new int[nums.Length];\\n        if (k == 0)\\n            return nums;\\n\\n        long sum = 0;\\n\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (i < k || i > nums.Length - k - 1 || k == 0) {\\n                avg[i] = -1;\\n            } else {\\n                if (i == k) {\\n                    for (int j = 0; j <= 2 * k; j++) {\\n                        sum += nums[j];\\n                    }\\n                } else {\\n                    sum -= nums[i - k - 1];\\n                    sum += nums[i + k];\\n                }\\n                avg[i] = (int)(sum / (2 * k + 1));\\n            }\\n        }\\n\\n        return avg;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661287,
                "title": "c-90-fast-easy-and-simple-code-sliding-window",
                "content": "# Intuition\\nJust keeping deleting staring numbers from sum and keep adding upcoming numbers to it\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> arr(nums.size(), -1);\\n        long long sum = 0;\\n        for(int i=0; i<nums.size() && i<2*k ; i++){\\n            sum += nums[i];\\n        }\\n\\n        int len = 2*k + 1;\\n\\n        for(int i=k; i<n-k; i++){\\n            sum = sum + nums[i+k];\\n            arr[i] = sum / len;\\n            sum = sum - nums[i-k];\\n        }\\n\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> arr(nums.size(), -1);\\n        long long sum = 0;\\n        for(int i=0; i<nums.size() && i<2*k ; i++){\\n            sum += nums[i];\\n        }\\n\\n        int len = 2*k + 1;\\n\\n        for(int i=k; i<n-k; i++){\\n            sum = sum + nums[i+k];\\n            arr[i] = sum / len;\\n            sum = sum - nums[i-k];\\n        }\\n\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660915,
                "title": "very-easy-sliding-window-solution-optimal-solution-clean-code-with-explanation",
                "content": "# Intuition\\nAfter seeing the question the thing that came to my mind was that we have to maintain a sum for a window of length 2*k+1 and two edge cases i.e. if window length is greater than the given array nums we have to return an array with all element as -1 and if k is equal to 0 we have to return original array as raidus formed will be 1 with window size 1 that is original array itself.\\n\\n# Approach\\nI initialised an array of size n and with all element -1, checked for edge cases and straight away went on the calculation part.\\nI declared two variables i for checking window length and j for iterating the ans array for storing ans.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long sum = 0; //to overcome overflows for int\\n        vector<int> ans(n,-1); //initialising ans vector with -1 and size n\\n        if((2*k+1)>n) return ans; //check for window size greater than given array\\n        if(k==0) return ans = nums; //check for window size = 1\\n        for(int i=0, j=k; i<n; i++) { //initialising loop to traverse the nums array and variable ifor checking window size and j to store average in ans array\\n            sum += nums[i]; // adding the upcoming elements of nums\\n            if(i>=2*k) { //checking if i has become greater or equal to required window size\\n                ans[j++] = sum/(2*k+1); // calculating average from window length and storing it and incrementing j operator for next iteration for next index\\n                sum -= nums[i-2*k]; // subtracting the first element so that it retains window size for next iteration\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sliding Window",
                    "Rolling Hash",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long sum = 0; //to overcome overflows for int\\n        vector<int> ans(n,-1); //initialising ans vector with -1 and size n\\n        if((2*k+1)>n) return ans; //check for window size greater than given array\\n        if(k==0) return ans = nums; //check for window size = 1\\n        for(int i=0, j=k; i<n; i++) { //initialising loop to traverse the nums array and variable ifor checking window size and j to store average in ans array\\n            sum += nums[i]; // adding the upcoming elements of nums\\n            if(i>=2*k) { //checking if i has become greater or equal to required window size\\n                ans[j++] = sum/(2*k+1); // calculating average from window length and storing it and incrementing j operator for next iteration for next index\\n                sum -= nums[i-2*k]; // subtracting the first element so that it retains window size for next iteration\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660732,
                "title": "69-iq-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_averages(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n        let k = k as usize;\\n        let len = 2 * k as u64 + 1;\\n\\n        let mut result = vec![-1; nums.len()];\\n        if nums.len() < len as usize {\\n            return result;\\n        }\\n\\n        let mut sum = nums[..len as usize].into_iter().map(|&num| num as u64).sum::<u64>();\\n        result[k] = (sum / len) as i32;\\n\\n        for i in k + 1..nums.len() - k {\\n            sum += nums[i + k] as u64;\\n            sum -= nums[i - k - 1] as u64;\\n            result[i] = (sum / len) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sliding Window"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_averages(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n        let k = k as usize;\\n        let len = 2 * k as u64 + 1;\\n\\n        let mut result = vec![-1; nums.len()];\\n        if nums.len() < len as usize {\\n            return result;\\n        }\\n\\n        let mut sum = nums[..len as usize].into_iter().map(|&num| num as u64).sum::<u64>();\\n        result[k] = (sum / len) as i32;\\n\\n        for i in k + 1..nums.len() - k {\\n            sum += nums[i + k] as u64;\\n            sum -= nums[i - k - 1] as u64;\\n            result[i] = (sum / len) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3660650,
                "title": "c-80-faster-time-complexity-o-n-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding window and math.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing sliding window approch approch first add all the element from 0 to 2*k and then find the average and insert it to the answer array at index k and after that move forward\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) because we are storing and returning the vector.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>a(n,-1);\\n        if(n<2*k+1)\\n            return a;\\n        long sum=0;\\n        for(int i=0;i<=2*k and i<n;i++)\\n            sum+=nums[i];\\n        int z=1,p=0;\\n        a[k+p]=sum/(2*k+1);\\n        for(int i=2*k+1;i<nums.size();i++)\\n        {\\n            sum-=nums[p];\\n            sum+=nums[i];\\n            a[k+z]=sum/(2*k+1);\\n            z++;\\n            p++;\\n        }\\n        return a;\\n    }\\n};\\nfeel free to ask your doubt happyto help......\\nIf it help then plz upvote it......Thaks!!!!!\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>a(n,-1);\\n        if(n<2*k+1)\\n            return a;\\n        long sum=0;\\n        for(int i=0;i<=2*k and i<n;i++)\\n            sum+=nums[i];\\n        int z=1,p=0;\\n        a[k+p]=sum/(2*k+1);\\n        for(int i=2*k+1;i<nums.size();i++)\\n        {\\n            sum-=nums[p];\\n            sum+=nums[i];\\n            a[k+z]=sum/(2*k+1);\\n            z++;\\n            p++;\\n        }\\n        return a;\\n    }\\n};\\nfeel free to ask your doubt happyto help......\\nIf it help then plz upvote it......Thaks!!!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660643,
                "title": "easy-to-understand-sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int N= nums.size();\\n        vector<int> ans(N,-1);\\n        int size=2*k+1;\\n        int i=0, j=0;\\n        long long int sum=0;\\n        while(j<N){\\n            sum+=nums[j];\\n            if(j-i+1 < size){\\n                j++;\\n            }\\n\\n            else if(j-i+1 == size){\\n                int avg= sum/size;\\n                ans[i+k]=avg;\\n                j++;\\n                sum-=nums[i];\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int N= nums.size();\\n        vector<int> ans(N,-1);\\n        int size=2*k+1;\\n        int i=0, j=0;\\n        long long int sum=0;\\n        while(j<N){\\n            sum+=nums[j];\\n            if(j-i+1 < size){\\n                j++;\\n            }\\n\\n            else if(j-i+1 == size){\\n                int avg= sum/size;\\n                ans[i+k]=avg;\\n                j++;\\n                sum-=nums[i];\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660617,
                "title": "easy-solution-c-two-pointers-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly create the vector ans of size n and assign it with -1.\\nCheck if their exist a radius for given k that is nums.size()>=2*k+1\\nif yes then calculate the running average and store at index ans[i+k] and rest will be -1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Pointers and Sliding Window\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> ans(n,-1);\\n        if(n>=2*k+1){\\n            int i=0,j=2*k+1;\\n            long long int sum=0;\\n            for(int i=0;i<j;i++) sum+=nums[i];\\n            while(j<n){\\n                ans[i+k]=(sum/(2*k+1));\\n                sum+=nums[j++];\\n                sum-=nums[i++];\\n            }\\n            ans[i+k]=(sum/(2*k+1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> ans(n,-1);\\n        if(n>=2*k+1){\\n            int i=0,j=2*k+1;\\n            long long int sum=0;\\n            for(int i=0;i<j;i++) sum+=nums[i];\\n            while(j<n){\\n                ans[i+k]=(sum/(2*k+1));\\n                sum+=nums[j++];\\n                sum-=nums[i++];\\n            }\\n            ans[i+k]=(sum/(2*k+1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660566,
                "title": "extremely-simple-c-dp-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> ans(n,-1);\\n        long long pre[n];\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=nums[i]+pre[i-1];\\n        }\\n        for(int i=k;i<=n-k-1;i++)\\n        {\\n            long long a=pre[i+k]-pre[i-k]+nums[i-k];\\n            ans[i]=a/(2*k+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> ans(n,-1);\\n        long long pre[n];\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=nums[i]+pre[i-1];\\n        }\\n        for(int i=k;i<=n-k-1;i++)\\n        {\\n            long long a=pre[i+k]-pre[i-k]+nums[i-k];\\n            ans[i]=a/(2*k+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660495,
                "title": "prefix-sum",
                "content": "# Approach\\nThe window\\'s size is defined as 2*k + 1, where k is the radius. Our goal is to compute the answer for indices ranging from k to n-k since only those indices possess k elements on both their left and right sides. This computation can be easily achieved by using a prefix array.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<ll> px(n);\\n        px[0] = nums[0];\\n        for(int i=1 ; i<n ; ++i) {\\n            px[i] = px[i-1] + nums[i];\\n        }\\n\\n        vector<int> ans(n,-1);\\n        int d = 2*k + 1;\\n        for(int i = k ; i<n-k ; ++i) {\\n           ans[i] = (px[i+k] - (i-k > 0 ? px[i-k-1] : 0))/ d;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<ll> px(n);\\n        px[0] = nums[0];\\n        for(int i=1 ; i<n ; ++i) {\\n            px[i] = px[i-1] + nums[i];\\n        }\\n\\n        vector<int> ans(n,-1);\\n        int d = 2*k + 1;\\n        for(int i = k ; i<n-k ; ++i) {\\n           ans[i] = (px[i+k] - (i-k > 0 ? px[i-k-1] : 0))/ d;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660408,
                "title": "c-prefix-sum-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<long long int> prefixSum;// array containing the prefix sum\\n        vector<int> radAvg;// array containing the radius average\\n        long long int s = 0;\\n\\n        // storing the prefix sum\\n        for(auto num: nums) {\\n            s += num;\\n            prefixSum.push_back(s);\\n        }\\n\\n\\n        for(int i = 0;i < nums.size();i++){\\n            if(i - k >= 0 && i + k < nums.size()) // checking whether i - k and i + k lies within indices of array\\n                radAvg.push_back((prefixSum[i + k] - (i - k - 1 < 0 ? 0 : prefixSum[i - k - 1]))/(2*k + 1));\\n                // radial sum will be prefix[i + k] - prefix[i - k - 1]\\n                // if i - k - 1 < 0 then it\\'s 0 \\n                // average will be sum divided By ((i + k) - (i - k) + 1)\\n            else \\n                radAvg.push_back(-1);// less than k elements before or after the index i so -1 is inserted\\n            \\n        }\\n\\n        // return the resultant array\\n        return radAvg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<long long int> prefixSum;// array containing the prefix sum\\n        vector<int> radAvg;// array containing the radius average\\n        long long int s = 0;\\n\\n        // storing the prefix sum\\n        for(auto num: nums) {\\n            s += num;\\n            prefixSum.push_back(s);\\n        }\\n\\n\\n        for(int i = 0;i < nums.size();i++){\\n            if(i - k >= 0 && i + k < nums.size()) // checking whether i - k and i + k lies within indices of array\\n                radAvg.push_back((prefixSum[i + k] - (i - k - 1 < 0 ? 0 : prefixSum[i - k - 1]))/(2*k + 1));\\n                // radial sum will be prefix[i + k] - prefix[i - k - 1]\\n                // if i - k - 1 < 0 then it\\'s 0 \\n                // average will be sum divided By ((i + k) - (i - k) + 1)\\n            else \\n                radAvg.push_back(-1);// less than k elements before or after the index i so -1 is inserted\\n            \\n        }\\n\\n        // return the resultant array\\n        return radAvg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660371,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        output = []\\n        div = (2*k)+1\\n        currSum = -1\\n        for i in range(len(nums)) : \\n            if i < k :\\n                output.append(-1)\\n            elif i+k >= len(nums) : \\n                output.append(-1)\\n            else : \\n                if currSum == -1 :\\n                    sumSubArr = sum(nums[i-k:i+k+1])\\n                    output.append(sumSubArr//div)\\n                    currSum = sumSubArr \\n                else : \\n                    currSum = currSum + (nums[i+k] - nums[i-k-1]) \\n                    output.append(currSum//div)\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        output = []\\n        div = (2*k)+1\\n        currSum = -1\\n        for i in range(len(nums)) : \\n            if i < k :\\n                output.append(-1)\\n            elif i+k >= len(nums) : \\n                output.append(-1)\\n            else : \\n                if currSum == -1 :\\n                    sumSubArr = sum(nums[i-k:i+k+1])\\n                    output.append(sumSubArr//div)\\n                    currSum = sumSubArr \\n                else : \\n                    currSum = currSum + (nums[i+k] - nums[i-k-1]) \\n                    output.append(currSum//div)\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660292,
                "title": "c-sliding-window",
                "content": "# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n  `If we do not consider resultant vector it wil be \\'O(1)\\'`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        else if(k == 0) return nums;\\n\\n        vector<int>res(n,-1);\\n\\n        long long preSum = 0 , postSum = 0;\\n        int prei = 0 , prej = 0;\\n        int posti = k , postj = k + 1;\\n\\n        while(postj < n){\\n\\n            preSum += nums[prej];\\n            postSum += nums[postj];\\n\\n            if(prej - prei + 1 < k){\\n                prej++; postj++;\\n            }\\n            else if(prej - prei + 1 == k){\\n                // here posti holding index where we have k elements in left & k elements in right\\n                res[posti] = (preSum + postSum + nums[posti]) / ((k*2) + 1 );\\n\\n                preSum -= nums[prei];\\n                postSum -= nums[posti+1];\\n                \\n                prei++; prej++; posti++; postj++;\\n\\n            }\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n\\n        else if(k == 0) return nums;\\n\\n        vector<int>res(n,-1);\\n\\n        long long preSum = 0 , postSum = 0;\\n        int prei = 0 , prej = 0;\\n        int posti = k , postj = k + 1;\\n\\n        while(postj < n){\\n\\n            preSum += nums[prej];\\n            postSum += nums[postj];\\n\\n            if(prej - prei + 1 < k){\\n                prej++; postj++;\\n            }\\n            else if(prej - prei + 1 == k){\\n                // here posti holding index where we have k elements in left & k elements in right\\n                res[posti] = (preSum + postSum + nums[posti]) / ((k*2) + 1 );\\n\\n                preSum -= nums[prei];\\n                postSum -= nums[posti+1];\\n                \\n                prei++; prej++; posti++; postj++;\\n\\n            }\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660263,
                "title": "simple-two-pointers-python3-solution-o-n-beats-96-34-sliding-window-with-detailed-explanation",
                "content": "Initialized a result array **res** with a length equal to the input array nums, filled with -1s. This array will store the average values of the subarrays. The variables **left** and **windowSum** are initialized to 0, representing the left pointer of the sliding window and the sum of elements within the window, respectively.\\n\\n**windowLength** is calculated as **2 * k + 1**, which represents the total length of each window.\\nThen iterating over the nums array using the variable **right** as the right pointer of the sliding window.\\nIn each iteration, the current element is added to the **windowSum** to update the sum of elements within the window. If the length of the current window is equal to **windowLength**, it means the window is complete and we can calculate the average.\\n\\nThe average is obtained by dividing the **windowSum** by **windowLength**, and it is stored in the **res** array at the corresponding index **(left + k)**. Next, we adjust the window by subtracting the element at the left pointer from the **windowSum** and moving the left pointer to the right by incrementing it by 1.\\n\\nFinally, the res array is returned, which contains the averages of all the subarrays!\\n\\n**Time Complexity:** The algorithm iterates over the nums array once using the right pointer, resulting in a time complexity of **O(N)**, where N is the length of the input array.\\n\\n**Space Complexity:** The algorithm uses additional space to store the res array, which has the same length as the input array. Therefore, the space complexity is **O(N)**, where N is the length of the input array.\\n\\n**Please Upvote if you like the solution!**\\n\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        res, left, windowSum, windowLength = [-1] * len(nums), 0, 0, 2 * k + 1\\n        \\n        for right in range(len(nums)):\\n            windowSum += nums[right]  # Add the current element to the window sum\\n            \\n            # Check if the window length is reached\\n            if right - left + 1 == windowLength:\\n                # Calculate the average of the window and store it in the result array\\n                res[left + k] = windowSum // windowLength\\n                \\n                # Adjust the window sum and move the left pointer\\n                windowSum -= nums[left]\\n                left += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        res, left, windowSum, windowLength = [-1] * len(nums), 0, 0, 2 * k + 1\\n        \\n        for right in range(len(nums)):\\n            windowSum += nums[right]  # Add the current element to the window sum\\n            \\n            # Check if the window length is reached\\n            if right - left + 1 == windowLength:\\n                # Calculate the average of the window and store it in the result array\\n                res[left + k] = windowSum // windowLength\\n                \\n                # Adjust the window sum and move the left pointer\\n                windowSum -= nums[left]\\n                left += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660235,
                "title": "java-o-n-time-95-faster-singleiteration",
                "content": "***Please upvote if you like the Solution :-)***\\n# Intuition\\nSliding Window\\n\\n# Approach\\n1)Traverse the first k element make it as -1 and store their sum.\\n2)For next k+1 elements store the sum and when i==2*k put the sum/(2*k+1) in ans[k].\\n3)For elements from 2*k+1 till n-k add current element and delete curr-(2*k+1) element, store the sum/(2*k+1) in ans[i-k].\\n4)Traverse last n-k elements and store -1 in them. \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        int div=2*k+1;\\n\\n        long sum=0;\\n\\n        for(int i=0;i<k&&i<n;i++){\\n            sum+=nums[i];\\n            ans[i]=-1;\\n        }\\n\\n        for(int i=k;i<(2*k+1)&&i<n;i++){\\n            sum+=nums[i];\\n            if(i==(2*k))ans[k]=(int)(sum/div);\\n        }\\n\\n        for(int i=(2*k+1);i<n;i++){\\n            sum+=nums[i];\\n            sum-=nums[i-div];\\n            ans[i-k]=(int)(sum/div);\\n        }\\n\\n        for(int i=n-k;i>=0&&i<n;i++){\\n            ans[i]=-1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        int div=2*k+1;\\n\\n        long sum=0;\\n\\n        for(int i=0;i<k&&i<n;i++){\\n            sum+=nums[i];\\n            ans[i]=-1;\\n        }\\n\\n        for(int i=k;i<(2*k+1)&&i<n;i++){\\n            sum+=nums[i];\\n            if(i==(2*k))ans[k]=(int)(sum/div);\\n        }\\n\\n        for(int i=(2*k+1);i<n;i++){\\n            sum+=nums[i];\\n            sum-=nums[i-div];\\n            ans[i-k]=(int)(sum/div);\\n        }\\n\\n        for(int i=n-k;i>=0&&i<n;i++){\\n            ans[i]=-1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660051,
                "title": "python3-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHave a helper function that calculates the average and run it through the List for all n items in the array.\\n\\nHowever, there time limit was exceeded for this initial thought process, hence the solution shifted to having an additional List that stored the sums of all the elements in nums for O(1) access.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Declare the list that stores the sums\\n2. Add all the sums to the list declared above\\n4. return a list that contains the averages (-1 if the average does not exist)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        a = [0]\\n        for i in range(len(nums)): a.append(a[i] + nums[i])\\n        return [-1 if i < k or i > len(nums) - 1 - k else (a[i + k + 1] - a[i - k]) // (2 * k + 1) for i in range(len(nums))]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        a = [0]\\n        for i in range(len(nums)): a.append(a[i] + nums[i])\\n        return [-1 if i < k or i > len(nums) - 1 - k else (a[i + k + 1] - a[i - k]) // (2 * k + 1) for i in range(len(nums))]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660004,
                "title": "c-easy-solution-beginner-s-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> res(n,-1);\\n\\n        long long i=0, j=0, sum=0;\\n        \\n        while(j<n){\\n            sum += nums[j];\\n\\n            if(j-i == (k*2)){\\n                res[j-k] = (sum/(k*2+1));\\n                sum -= nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> res(n,-1);\\n\\n        long long i=0, j=0, sum=0;\\n        \\n        while(j<n){\\n            sum += nums[j];\\n\\n            if(j-i == (k*2)){\\n                res[j-k] = (sum/(k*2+1));\\n                sum -= nums[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659943,
                "title": "sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& a, int k) {\\n        int n  = a.size();\\n        int lim  = 2*k+1;\\n        vector<int> v(n,-1);\\n        if(lim>n || k > n)\\n            return v;\\n        \\n        long long int sum = 0;\\n        sum = accumulate(a.begin(),a.begin()+lim,sum);\\n        int ind = k;\\n        v[ind++] = sum/lim;\\n        int start = 0;\\n        for(int i=lim;i<n;i++)\\n        {\\n            if(start<n){\\n                sum-=a[start++];\\n            }\\n            \\n            sum+=a[i];\\n            \\n            if(ind<n)\\n            {\\n                v[ind++] = sum/lim;\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& a, int k) {\\n        int n  = a.size();\\n        int lim  = 2*k+1;\\n        vector<int> v(n,-1);\\n        if(lim>n || k > n)\\n            return v;\\n        \\n        long long int sum = 0;\\n        sum = accumulate(a.begin(),a.begin()+lim,sum);\\n        int ind = k;\\n        v[ind++] = sum/lim;\\n        int start = 0;\\n        for(int i=lim;i<n;i++)\\n        {\\n            if(start<n){\\n                sum-=a[start++];\\n            }\\n            \\n            sum+=a[i];\\n            \\n            if(ind<n)\\n            {\\n                v[ind++] = sum/lim;\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659895,
                "title": "python-beats-99-85-easy-solution-sliding-window",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:  \\n        n=2*k+1\\n        if n>len(nums):\\n            return [-1]*len(nums)\\n        sum1=sum(nums[:n])\\n        res=[-1]*k\\n        res.append(sum1//n)\\n        print(n)\\n        for i in range(len(nums)-n):\\n            sum1=sum1-nums[i]+nums[i+n]\\n            res.append(sum1//n)\\n        res+=[-1]*k\\n        return res\\n\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:  \\n        n=2*k+1\\n        if n>len(nums):\\n            return [-1]*len(nums)\\n        sum1=sum(nums[:n])\\n        res=[-1]*k\\n        res.append(sum1//n)\\n        print(n)\\n        for i in range(len(nums)-n):\\n            sum1=sum1-nums[i]+nums[i+n]\\n            res.append(sum1//n)\\n        res+=[-1]*k\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659850,
                "title": "easy-c-sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int>v(nums.size(),-1);\\n       long long int x=2*k;\\n        if(k==0)return nums;\\n        if(nums.size()<x)return v;\\n       long long int pre=0,next=0,sum=0;\\n        while(next<nums.size() && next<=x){\\n            sum+=nums[next];\\n            next++;\\n        }\\n        next--;\\n        while(next<nums.size()){\\n            int mid=(pre+next)/2;\\n            if(next-pre>=x)\\n               v[mid]=sum/(x+1);\\n            pre++;\\n            next++;\\n            if (next < nums.size()) {\\n                sum = sum + nums[next] - nums[pre-1];\\n            }\\n        }\\n      return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int>v(nums.size(),-1);\\n       long long int x=2*k;\\n        if(k==0)return nums;\\n        if(nums.size()<x)return v;\\n       long long int pre=0,next=0,sum=0;\\n        while(next<nums.size() && next<=x){\\n            sum+=nums[next];\\n            next++;\\n        }\\n        next--;\\n        while(next<nums.size()){\\n            int mid=(pre+next)/2;\\n            if(next-pre>=x)\\n               v[mid]=sum/(x+1);\\n            pre++;\\n            next++;\\n            if (next < nums.size()) {\\n                sum = sum + nums[next] - nums[pre-1];\\n            }\\n        }\\n      return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659837,
                "title": "c-simple-sliding-window-clean",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ (Not considering output)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> result(n, -1);\\n        if (k > n / 2) return result;\\n\\n        uint64_t sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            if (i >= 2*k) {\\n                result[i - k] = sum / (2*k + 1);    \\n                sum -= nums[i - 2*k];\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> result(n, -1);\\n        if (k > n / 2) return result;\\n\\n        uint64_t sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            if (i >= 2*k) {\\n                result[i - k] = sum / (2*k + 1);    \\n                sum -= nums[i - 2*k];\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659834,
                "title": "two-pointer-approach-c-simple-solution",
                "content": "# Intuition\\n\\nTry to find sum for ith index with help of sum calculted for (i-1)th index.\\n\\n# Approach\\n    \\nStart with a pointer at index 0 and a start index for starting value of element for \\nnumbers inside radius k,Now for starting and last k element average will be -1 and for \\nremaining elements in between them, first find the average for kth element and next\\ntime to find sum inside the circle delete last element from sum i.e at index start and add the number at index start+2*k+1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(n,0);\\n        int start=0,end = 0;\\n        long long sum=0;\\n        while(end<n){\\n            if(end<k || end>n-k-1){ans[end]=-1;}\\n            else if(end==k) {\\n               for(int i=0;i<2*k+1;i++){\\n                   sum+=nums[i];\\n               }\\n               start=0;\\n               ans[end] = sum/(2*k+1);\\n            }\\n            else{\\n                sum = sum-nums[start]+nums[start+2*k+1];\\n                ans[end] = sum/(2*k+1);\\n                start++;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans(n,0);\\n        int start=0,end = 0;\\n        long long sum=0;\\n        while(end<n){\\n            if(end<k || end>n-k-1){ans[end]=-1;}\\n            else if(end==k) {\\n               for(int i=0;i<2*k+1;i++){\\n                   sum+=nums[i];\\n               }\\n               start=0;\\n               ans[end] = sum/(2*k+1);\\n            }\\n            else{\\n                sum = sum-nums[start]+nums[start+2*k+1];\\n                ans[end] = sum/(2*k+1);\\n                start++;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659792,
                "title": "easy-to-understand-using-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbasic problem of sliding window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake a window of size 2*k+1 from i to j. when it had been made then insert answer at ans[i+k],because \\'i+k\\' element is at center of ith and jth position.\\n\\n\\nkeep in mind to take sum as long data type.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int div=2*k+1;\\n        vector<int>ans(n,-1);\\n        long sum=0;\\n        int i=0;\\n        int j=0;\\n\\n        while(j<n){\\n            sum+=nums[j];\\n            if(j-i+1==div){\\n                ans[i+k]=sum/div;\\n                sum-=nums[i];\\n                i++;\\n                j++;\\n            }\\n            else if(j-i+1<div)  j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int div=2*k+1;\\n        vector<int>ans(n,-1);\\n        long sum=0;\\n        int i=0;\\n        int j=0;\\n\\n        while(j<n){\\n            sum+=nums[j];\\n            if(j-i+1==div){\\n                ans[i+k]=sum/div;\\n                sum-=nums[i];\\n                i++;\\n                j++;\\n            }\\n            else if(j-i+1<div)  j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659778,
                "title": "c-easy-solution-with-explanation",
                "content": "# Institution:\\n- The code implements a solution to the problem of calculating the k-radius averages for a given array of integers nums and a value k.\\n- It utilizes prefix sums to efficiently calculate the sums of subarrays.\\n\\n# Approach:\\n\\n- The code starts by calculating the prefix sums of the input array nums and storing them in the vector ans.\\n- It then iterates over the indices of nums and calculates the k-radius average for each index based on the prefix sums.\\n- The k-radius average is calculated by subtracting the prefix sum at i-k-1 (if applicable) from the prefix sum at i+k and dividing the result by 2*k + 1.\\n- If the range (i-k, i+k) is outside the bounds of nums, it sets the k-radius average to -1.\\n- The calculated k-radius averages are stored in the vector v, which is returned as the result.\\n\\n# Time Complexity:\\n\\n- The initial loop that calculates the prefix sums has a time complexity of O(n), where n is the size of the input array nums.\\n- The second loop that calculates the k-radius averages also has a time complexity of O(n) since it iterates over all elements of nums.\\n- Therefore, the overall time complexity of the provided code is O(n).\\n\\n\\n# Space Complexity:\\n- The code utilizes three additional vectors: ans, v, and the returned vector.\\n- The ans vector stores the prefix sums of nums, which requires O(n) space.\\n- The v vector stores the k-radius averages, which also requires O(n) space since it has the same size as nums.\\nThe returned vector has the same size as nums and thus requires O(n) space.\\nTherefore, the overall space complexity of the provided code is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<long long> ans;\\n        ans.push_back(nums[0]);\\n        for(int i= 1; i<n; i++){\\n          ans.push_back(1ll*nums[i]+ans[i-1]);\\n        }\\n\\n        vector<int> v;\\n        int f = 2*k + 1;\\n        for(int i = 0; i<n; i++){\\n          if(i-k<0 || i+k>=n) v.push_back(-1);\\n          else{\\n            if(i-k>0)v.push_back((ans[i+k]-ans[i-k-1])/f);\\n            else v.push_back(ans[i+k]/f);\\n          }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<long long> ans;\\n        ans.push_back(nums[0]);\\n        for(int i= 1; i<n; i++){\\n          ans.push_back(1ll*nums[i]+ans[i-1]);\\n        }\\n\\n        vector<int> v;\\n        int f = 2*k + 1;\\n        for(int i = 0; i<n; i++){\\n          if(i-k<0 || i+k>=n) v.push_back(-1);\\n          else{\\n            if(i-k>0)v.push_back((ans[i+k]-ans[i-k-1])/f);\\n            else v.push_back(ans[i+k]/f);\\n          }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659732,
                "title": "sliding-window-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem statement is very clear that we have to find the window of size k and we will store the average of each window if the window size is less than k then we will store -1 as the average.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& arr, int k) {\\n\\n        long long n = arr.size(),sum = 0;\\n        vector<int> ans(n,-1);\\n\\n        if(n<(2*k+1))\\n        return ans;\\n\\n        for(int i = 0;i<(2*k+1);i++)\\n        sum+=(arr[i]);\\n\\n        int left = 0,mid = k,right = 2*k+1;\\n        ans[mid] = sum/(2*k+1);\\n        mid++;\\n\\n        while(right<n)\\n        {\\n            sum-=arr[left];\\n            sum+=arr[right];\\n            ans[mid] = sum/(2*k+1);\\n\\n            mid++;\\n            left++;\\n            right++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/693c596b-b542-4538-83d7-ee317d58c243_1687237628.2354898.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& arr, int k) {\\n\\n        long long n = arr.size(),sum = 0;\\n        vector<int> ans(n,-1);\\n\\n        if(n<(2*k+1))\\n        return ans;\\n\\n        for(int i = 0;i<(2*k+1);i++)\\n        sum+=(arr[i]);\\n\\n        int left = 0,mid = k,right = 2*k+1;\\n        ans[mid] = sum/(2*k+1);\\n        mid++;\\n\\n        while(right<n)\\n        {\\n            sum-=arr[left];\\n            sum+=arr[right];\\n            ans[mid] = sum/(2*k+1);\\n\\n            mid++;\\n            left++;\\n            right++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659724,
                "title": "python3-c-brute-force-optimal-prefix-sum-sliding-window-full-explanation",
                "content": "- Approach\\n    - Brute-force (TLE)\\n        - For each element in the array, we check if we can compute the average for that point (i.e. if it is in boundary)\\n        - If the element is not in the boundary then we append -1 to our answer array\\n        - Else we loop from nums[i-k] to nums[i+k] and compute the average of all the elements in that subarray and append the average to our answer array\\n        - Time Complexity: $O(n*k)$\\n        - Space Complexity: $O(n)$ for storing answer else $O(1)$\\n    - Optimal (Using Prefix Sum)\\n        - Compute Prefix Sum\\n        - We know that we cannot compute the average for the first and last k elements in the given array as they are out of boundary and thus we append -1 to our answer array\\n        - For all valid nums[i], calculate average by `nums[i+k] - nums[i-k-1] // (2 * k + 1)` and append it to answer array\\n        - Time Complexity: $O(n)$\\n        - Space Complexity: $O(n)$ for storing answer else $O(1)$\\n    - Optimal (Using Sliding Window)\\n        - Initialize `sum = 0` and `vector<int> v(n, -1)` (n = nums.size() and all initial elements as -1)\\n        - Loop over all the elements in the array\\n        - Add current element to the sum variable\\n        - We get valid subarrays when `i \\u2265 2 * k` so then we subtract the element which is out of boundary from the sum variable (i.e. `sum -= nums[i - 2*k - 1]`) and set `v[i-k] = sum / (2 * k + 1)`\\n        - Time Complexity: $O(n)$\\n        - Space Complexity: $O(n)$ for storing answer else $O(1)$\\n\\n```python\\n# Python3\\n# Brute-force Solution\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if n < k:   return [-1] * n\\n        if k == 0:  return nums\\n        \\n        ans = []\\n        for i in range(n):\\n            if i < k or i + k >= n:\\n                ans += -1,\\n            else:\\n                sum = 0\\n                for j in range(i-k, i+k+1):\\n                    sum += nums[j]\\n                sum //= (2 * k + 1)\\n                ans += sum,\\n        return ans\\n```\\n\\n```python\\n# Python3\\n# Optimal Solution\\n# Prefix Sum\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        # trivial cases\\n        n = len(nums)\\n        if n < k:   return [-1] * n\\n        if k == 0:  return nums\\n\\n        # prefix sum\\n        for i in range(1, n):\\n            nums[i] += nums[i-1]\\n        \\n        ans = []\\n        i = 0\\n        while i < n:\\n            if i < k or i + k >= n:\\n                ans += -1,\\n            else:\\n                ans += (nums[i+k] - (nums[i-k-1] if (i-k-1) >= 0 else 0)) // (2*k + 1),\\n            i += 1\\n        return ans\\n```\\n\\n```cpp\\n// C++\\n// Optimal Solution\\n// Sliding Window\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> v(n, -1);\\n        if (n < k) {\\n            return v;\\n        }\\n        if (k == 0) {return nums;}\\n\\n        long sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            if (i >= 2 * k) {\\n                sum -= (i-2*k-1 >= 0) ? nums[i-2*k-1] : 0;\\n                v[i-k] = sum / (2 * k + 1);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```python\\n# Python3\\n# Brute-force Solution\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if n < k:   return [-1] * n\\n        if k == 0:  return nums\\n        \\n        ans = []\\n        for i in range(n):\\n            if i < k or i + k >= n:\\n                ans += -1,\\n            else:\\n                sum = 0\\n                for j in range(i-k, i+k+1):\\n                    sum += nums[j]\\n                sum //= (2 * k + 1)\\n                ans += sum,\\n        return ans\\n```\n```python\\n# Python3\\n# Optimal Solution\\n# Prefix Sum\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        # trivial cases\\n        n = len(nums)\\n        if n < k:   return [-1] * n\\n        if k == 0:  return nums\\n\\n        # prefix sum\\n        for i in range(1, n):\\n            nums[i] += nums[i-1]\\n        \\n        ans = []\\n        i = 0\\n        while i < n:\\n            if i < k or i + k >= n:\\n                ans += -1,\\n            else:\\n                ans += (nums[i+k] - (nums[i-k-1] if (i-k-1) >= 0 else 0)) // (2*k + 1),\\n            i += 1\\n        return ans\\n```\n```cpp\\n// C++\\n// Optimal Solution\\n// Sliding Window\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> v(n, -1);\\n        if (n < k) {\\n            return v;\\n        }\\n        if (k == 0) {return nums;}\\n\\n        long sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            if (i >= 2 * k) {\\n                sum -= (i-2*k-1 >= 0) ? nums[i-2*k-1] : 0;\\n                v[i-k] = sum / (2 * k + 1);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659722,
                "title": "python-solution-for-noobs",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the heading of this solution says\\n\\n\\nYou will not be able to understand the problem like $$me$$ from its description.\\nSo to understand go to example 1 where an array nums is given here we can understand that \\n\\nwe have to create an array which will have **average of sum of first k elements on left and right sides inclusive of the element at index i**\\n\\nThat means if k=3 and nums=[7,4,3,9,1,8,5,2,6]\\nthen for first k elements it should be -1 i.e. indexes in place of 7,4,3 because these don\\'t have first k elements on their left\\nSo we used res=[-1]*k\\n\\n\\nNow we have to choose how we want to solve next part of the problem either **brute force** that can be taking sum of all 2*k+1 elements and then taking average of the elements.\\n\\nBut if this was that simple then why would this be medium problem so we will be using **sliding window approach**.\\n\\n\\nNow we assign the $$window_size=2*k+1$$\\nwhich will be our sample size for getting average\\n\\nand we assign **window_sum=sum(nums[:window_size])** i.e first 2+k+1 elements sum.\\n\\nnow we transverse through the loop with starting value k because all previous values are -1.\\nAnd with every transition we add the next value of array and subtract last value of array in windows sum\\n\\nand at last we use res.extend([-1]*k) to add last k [-1] elements and return res.\\n\\n**But we forgot to add few edge case**\\n\\nfor that 1st edge case is if k==0 then **return nums**\\n\\nand 2nd edge case is if len(nums) is smaller than 2*k+1,\\nin this case we **return [-1]*n**\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(N)** because we transverse through whole array in case it array is large thus overall time complexity is O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)** because we store our answer in res array of length N\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if k == 0:\\n            return nums\\n        if 2 * k + 1 > n:\\n            return [-1] * n\\n\\n        res = [-1] * k\\n        window_size = 2 * k + 1\\n        window_sum = sum(nums[:window_size])\\n\\n        for i in range(k, n - k - 1):\\n            res.append(window_sum // window_size)\\n            window_sum += nums[i + k + 1] - nums[i - k]\\n\\n        res.append(window_sum // window_size)\\n        res.extend([-1] * k)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if k == 0:\\n            return nums\\n        if 2 * k + 1 > n:\\n            return [-1] * n\\n\\n        res = [-1] * k\\n        window_size = 2 * k + 1\\n        window_sum = sum(nums[:window_size])\\n\\n        for i in range(k, n - k - 1):\\n            res.append(window_sum // window_size)\\n            window_sum += nums[i + k + 1] - nums[i - k]\\n\\n        res.append(window_sum // window_size)\\n        res.extend([-1] * k)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659627,
                "title": "best-solution-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> avgs(n, -1);\\n\\n        long long sum = 0;\\n\\n        // Calculate sum for the first window\\n        for (int i = 0; i <= 2 * k && i < n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        // Calculate average for the first window\\n        if (n >= 2 * k + 1) {\\n            avgs[k] = sum / (2 * k + 1);\\n        }\\n\\n        // Slide the window and calculate averages\\n        for (int i = k + 1; i < n - k; i++) {\\n            sum -= nums[i - k - 1]; // Subtract the element going out of the window\\n            sum += nums[i + k];     // Add the new element coming into the window\\n            avgs[i] = sum / (2 * k + 1);\\n        }\\n\\n        return avgs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> avgs(n, -1);\\n\\n        long long sum = 0;\\n\\n        // Calculate sum for the first window\\n        for (int i = 0; i <= 2 * k && i < n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        // Calculate average for the first window\\n        if (n >= 2 * k + 1) {\\n            avgs[k] = sum / (2 * k + 1);\\n        }\\n\\n        // Slide the window and calculate averages\\n        for (int i = k + 1; i < n - k; i++) {\\n            sum -= nums[i - k - 1]; // Subtract the element going out of the window\\n            sum += nums[i + k];     // Add the new element coming into the window\\n            avgs[i] = sum / (2 * k + 1);\\n        }\\n\\n        return avgs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659582,
                "title": "someone-help-me",
                "content": "**Getting TLE someone help me :(**\\n27/39 testcase passed !\\n```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        ans = [-1] * len(nums)\\n        if k>=len(nums):\\n            return ans\\n        ans[:]=[-1]*k+[sum(nums[i-k:i+k+1])//(2*k+1) for i in range(k,len(nums)-k)]+[-1]*k\\n        \\n        \\n        if ans == [-1] * len(ans):\\n            return nums\\n        \\n        return ans \\n```\\n\\n### Please help me and upvote it ;(\\n![image](https://assets.leetcode.com/users/images/c4d8ed83-2df2-4da3-b6c7-695376544897_1687235303.417338.jpeg)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        ans = [-1] * len(nums)\\n        if k>=len(nums):\\n            return ans\\n        ans[:]=[-1]*k+[sum(nums[i-k:i+k+1])//(2*k+1) for i in range(k,len(nums)-k)]+[-1]*k\\n        \\n        \\n        if ans == [-1] * len(ans):\\n            return nums\\n        \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659568,
                "title": "100-beats-typecasting-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans(nums.size(),-1);\\n        if(k>=nums.size())\\n        return ans;\\n        if(2*k+1>nums.size())\\n        return ans;\\n\\n        long long sum=0;\\n        for(int i=0;i<=2*k;i++)\\n            sum+=nums[i];\\n        ans[k]=sum/(2*k+1);\\n        for(int i=k+1;i<n-k;i++)\\n        {\\n            sum=sum-nums[i-k-1];\\n            sum=sum+nums[i+k];\\n            ans[i]=int(sum/(2*k+1));\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans(nums.size(),-1);\\n        if(k>=nums.size())\\n        return ans;\\n        if(2*k+1>nums.size())\\n        return ans;\\n\\n        long long sum=0;\\n        for(int i=0;i<=2*k;i++)\\n            sum+=nums[i];\\n        ans[k]=sum/(2*k+1);\\n        for(int i=k+1;i<n-k;i++)\\n        {\\n            sum=sum-nums[i-k-1];\\n            sum=sum+nums[i+k];\\n            ans[i]=int(sum/(2*k+1));\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659529,
                "title": "very-simple-appoach-using-suffix-and-prefix-array",
                "content": "# Intuition\\nBy initially seeing this que first thought that should cross our mind is we need the sum of no between k-i to k+i , So all number with index\\n(0 to k-1 and (n-k)to n-1) will always have -1  as there ans .Hence then we just need to iterate from k to n-k-1 .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will make suffix vector and prefix vector  both will store sum from end and start respectively. So at index i the sum of i-k to\\n i+k  will we equal to \\n\\n      (suffix[i-k]+prefix[i+k]-suffix[i]-prefix[i]+nums[i])\\n\\nand no of element will we \\n\\n                        (2*k+1)\\n\\nso average will we\\n        \\n    (suffix[i-k]+prefix[i+k]-suffix[i]-prefix[i]+nums[i])/ (2*k+1)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    \\n    O(3N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans(n,-1);\\n        vector<long long>p(n,0),s(n,0);\\n        p[0]=nums[0];\\n        s[n-1]=nums[n-1];\\n        for(int i=1;i<n;i++){\\n            p[i]=p[i-1]+nums[i];\\n        }\\n        for(int j=n-2;j>=0;j--){\\n            s[j]=s[j+1]+nums[j];\\n        }\\n        int no=(2*k)+1;\\n        for(int i=k;i+k<n;i++){\\n            long long  sum=(s[i-k]+p[i+k]-s[i]-p[i]+nums[i]);\\n            sum=(sum)/no;\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans(n,-1);\\n        vector<long long>p(n,0),s(n,0);\\n        p[0]=nums[0];\\n        s[n-1]=nums[n-1];\\n        for(int i=1;i<n;i++){\\n            p[i]=p[i-1]+nums[i];\\n        }\\n        for(int j=n-2;j>=0;j--){\\n            s[j]=s[j+1]+nums[j];\\n        }\\n        int no=(2*k)+1;\\n        for(int i=k;i+k<n;i++){\\n            long long  sum=(s[i-k]+p[i+k]-s[i]-p[i]+nums[i]);\\n            sum=(sum)/no;\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659524,
                "title": "c-prefixsum-constant-space-easy-to-understand",
                "content": "# Approach\\nTo calculate the avg of the centre element first need to calculate sum up `K+K+1` element \\nKeep the `start` variable at `zero` postion initially\\nInitialize the `avg` vector to -1\\nIterate over the nums array when encounter a index `i > k+k`means there is a centre element and has k elements in before and after it\\nCalculate the avg at that index\\nSubstract value at start index from `sum` So that sum always contain sum of `k+k+1` element\\nupdate `start` to next index\\n\\n\\n# Complexity\\n- Time complexity:\\n O(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int>avg(nums.size(),-1);\\n        long long sum=0;\\n        int start=0,n=k+k+1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(i>=k+k){\\n                avg[i-k]=sum/n;\\n                sum-=nums[start];\\n                start++;\\n            }\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        vector<int>avg(nums.size(),-1);\\n        long long sum=0;\\n        int start=0,n=k+k+1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(i>=k+k){\\n                avg[i-k]=sum/n;\\n                sum-=nums[start];\\n                start++;\\n            }\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659512,
                "title": "my-kotlin-solution-with-time-o-n-and-space-o-n",
                "content": "The idea is to apply the sliding window technique to compute the sum of each k-radius subarray.\\n\\nBelow is my solution in kotlin,\\n```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(N) and Space O(N) where N is the size of nums;\\n     */\\n    fun getAverages(nums: IntArray, k: Int): IntArray {\\n        if (k == 0) {\\n            return nums.clone()\\n        }\\n\\n        val lessKRadiusAverage = -1\\n        val result = IntArray(nums.size) { lessKRadiusAverage }\\n\\n        val validCenterIndices = k until (nums.size - k)\\n        if (validCenterIndices.isEmpty()) {\\n            return result\\n        }\\n\\n        // Apply sliding window technique\\n        val windowSize = k * 2 + 1\\n        var windowSum = nums.sum(0 until windowSize)\\n        result[k] = quotient(windowSum, windowSize)\\n\\n        for (centerIndex in (k + 1) until (nums.size - k)) {\\n            windowSum = windowSum - nums[centerIndex - k - 1] + nums[centerIndex + k]\\n            result[centerIndex] = quotient(windowSum, windowSize)\\n        }\\n        return result\\n    }\\n\\n    private fun IntArray.sum(indexRange: IntRange): Long {\\n        return indexRange.fold(0L) { acc: Long, index: Int -> acc + this[index] }\\n    }\\n\\n    private fun quotient(dividend: Long, divisor: Int): Int {\\n        return (dividend / divisor).toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(N) and Space O(N) where N is the size of nums;\\n     */\\n    fun getAverages(nums: IntArray, k: Int): IntArray {\\n        if (k == 0) {\\n            return nums.clone()\\n        }\\n\\n        val lessKRadiusAverage = -1\\n        val result = IntArray(nums.size) { lessKRadiusAverage }\\n\\n        val validCenterIndices = k until (nums.size - k)\\n        if (validCenterIndices.isEmpty()) {\\n            return result\\n        }\\n\\n        // Apply sliding window technique\\n        val windowSize = k * 2 + 1\\n        var windowSum = nums.sum(0 until windowSize)\\n        result[k] = quotient(windowSum, windowSize)\\n\\n        for (centerIndex in (k + 1) until (nums.size - k)) {\\n            windowSum = windowSum - nums[centerIndex - k - 1] + nums[centerIndex + k]\\n            result[centerIndex] = quotient(windowSum, windowSize)\\n        }\\n        return result\\n    }\\n\\n    private fun IntArray.sum(indexRange: IntRange): Long {\\n        return indexRange.fold(0L) { acc: Long, index: Int -> acc + this[index] }\\n    }\\n\\n    private fun quotient(dividend: Long, divisor: Int): Int {\\n        return (dividend / divisor).toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659473,
                "title": "pen-paper-explaination",
                "content": "![photo_2023-06-20_09-28-14.jpg](https://assets.leetcode.com/users/images/96024a89-94a6-484c-9049-09b83ff12818_1687233601.0074837.jpeg)\\n\\n\\n# Time complexity: \\n \\nO(N)\\n\\n# Space complexity:\\n\\nO(1)\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> getAverages(vector<int> &nums, int k)\\n    {\\n        vector<int> result;\\n        \\n        // CASE 1 //\\n        if (nums.size() <= k)\\n        {\\n            for (int i = 1; i <= k && nums.size() > result.size(); i++)\\n            {\\n                result.push_back(-1);\\n            }\\n            return result;\\n        }\\n         \\n\\n        // CASE 2 //\\n        for (int i = 1; i <= k && nums.size() > result.size(); i++)\\n        {\\n            result.push_back(-1);\\n        }\\n\\n        // sliding window code\\n        long long int sum = 0;  // sum may cause overflow\\n        int wsize = (2 * k) + 1;\\n        int i = 0, j = 0;\\n        while (j < nums.size())\\n        {\\n            sum += nums[j];\\n            if (j - i + 1 < wsize)\\n            {\\n                j++;\\n            }\\n            else if (j - i + 1 == wsize)\\n            {\\n                result.push_back(sum / wsize);\\n                sum -= nums[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        for (int i = 1; i <= k && nums.size() > result.size(); i++)\\n        {\\n            result.push_back(-1);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> getAverages(vector<int> &nums, int k)\\n    {\\n        vector<int> result;\\n        \\n        // CASE 1 //\\n        if (nums.size() <= k)\\n        {\\n            for (int i = 1; i <= k && nums.size() > result.size(); i++)\\n            {\\n                result.push_back(-1);\\n            }\\n            return result;\\n        }\\n         \\n\\n        // CASE 2 //\\n        for (int i = 1; i <= k && nums.size() > result.size(); i++)\\n        {\\n            result.push_back(-1);\\n        }\\n\\n        // sliding window code\\n        long long int sum = 0;  // sum may cause overflow\\n        int wsize = (2 * k) + 1;\\n        int i = 0, j = 0;\\n        while (j < nums.size())\\n        {\\n            sum += nums[j];\\n            if (j - i + 1 < wsize)\\n            {\\n                j++;\\n            }\\n            else if (j - i + 1 == wsize)\\n            {\\n                result.push_back(sum / wsize);\\n                sum -= nums[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        for (int i = 1; i <= k && nums.size() > result.size(); i++)\\n        {\\n            result.push_back(-1);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659470,
                "title": "c-code-using-sliding-window",
                "content": "# Intuition\\nSliding Window \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst checking the main base case that the length of the array should be greater than 2*k, otherwise the array should be of all -1\\'s.\\nThen, pushing \\'k\\' -1\\'s to the result array, and then calculating sum of the subarrays using sliding window technique.\\nAt each index from (k to n-k), we add the sum/(2*k+1) to the result array.\\nFinally, pushing \\'k\\' -1\\'s again into the result array.\\nWe use sum as long long to avoid integer overflow, as the range of given value is upto 1e5 and length of the array is 1e5, which can definitely leads to integer overflow.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)    // Excluding result array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> res;\\n        if(n<=2*k){\\n            res.resize(n,-1);\\n            return res;\\n        }\\n        for(int i=0;i<k;i++){\\n            res.push_back(-1);\\n        }\\n        long long sum = 0;      // To avoid integer overflow.\\n        for(int i=0;i<=2*k;i++){\\n                sum+=nums[i];\\n        }\\n        // cout<<sum<<\" \";\\n        int ind = 0;\\n        int div = (2*k)+1;  \\n        for(int i=k+1;i<n-k;i++){\\n            res.push_back(sum/div);\\n            sum-=nums[ind++];   //removing first element\\n            sum+=nums[i+k];     // adding last element\\n        }\\n        res.push_back(sum/div);\\n        for(int i=n-k;i<n;i++){\\n            res.push_back(-1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> res;\\n        if(n<=2*k){\\n            res.resize(n,-1);\\n            return res;\\n        }\\n        for(int i=0;i<k;i++){\\n            res.push_back(-1);\\n        }\\n        long long sum = 0;      // To avoid integer overflow.\\n        for(int i=0;i<=2*k;i++){\\n                sum+=nums[i];\\n        }\\n        // cout<<sum<<\" \";\\n        int ind = 0;\\n        int div = (2*k)+1;  \\n        for(int i=k+1;i<n-k;i++){\\n            res.push_back(sum/div);\\n            sum-=nums[ind++];   //removing first element\\n            sum+=nums[i+k];     // adding last element\\n        }\\n        res.push_back(sum/div);\\n        for(int i=n-k;i<n;i++){\\n            res.push_back(-1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3659383,
                "title": "python-easy-fast-solution-subarray-averages-with-window-size",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Determine the window size: Since we need to calculate averages for subarrays with a window size of 2k + 1, I would compute the window size based on the given k.\\n\\n- Handle edge cases: If the length of the input list is less than the window size, the subarrays cannot be formed, so we would return a default list of -1 as the answer.\\n\\n- Create a prefix sum array: To efficiently calculate the sum of subarrays, I would initialize a prefix sum array that stores the cumulative sum up to each index. This array can be used to compute the sum of any subarray in constant time.\\n\\n- Iterate over the input list: Starting from the (k + 1)th element up to (n - k)th element, I would calculate the average of each subarray by using the prefix sum array. The average can be calculated by subtracting the prefix sum at (i - k - 1) from the prefix sum at (i + k) and dividing it by the window size.\\n\\n- Store the averages: I would store the calculated averages in a separate list.\\n\\n- Return the answer: After iterating over all elements, I would return the list containing the averages of the subarrays.\\n\\n\\n\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        # Get the length of the input list\\n        n = len(nums)\\n        # Calculate the window size\\n        windowSize = 2 * k + 1\\n        # Initialize the answer list with -1\\n        ans = [-1] * n\\n        \\n        # If the length of the input list is less than the window size,\\n        # return the initialized answer list\\n        if n < windowSize:\\n            return ans\\n        \\n        # Create a prefix sum array to efficiently calculate sums of subarrays\\n        prefixSum = [0] * (n + 1)\\n        for i in range(n):\\n            # Calculate the prefix sum by adding the current element to the previous prefix sum\\n            prefixSum[i + 1] = prefixSum[i] + nums[i]\\n        \\n        # Iterate over the elements in the input list, excluding the boundary elements\\n        for i in range(k, n - k):\\n            # Calculate the average of the subarray using the prefix sum array\\n            ans[i] = (prefixSum[i + k + 1] - prefixSum[i - k]) // windowSize\\n        \\n        # Return the answer list\\n        return ans\\n\\n\\n```\\n\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/82f941c0-1615-4629-8166-4f2ecd6490d9_1687231897.110448.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        # Get the length of the input list\\n        n = len(nums)\\n        # Calculate the window size\\n        windowSize = 2 * k + 1\\n        # Initialize the answer list with -1\\n        ans = [-1] * n\\n        \\n        # If the length of the input list is less than the window size,\\n        # return the initialized answer list\\n        if n < windowSize:\\n            return ans\\n        \\n        # Create a prefix sum array to efficiently calculate sums of subarrays\\n        prefixSum = [0] * (n + 1)\\n        for i in range(n):\\n            # Calculate the prefix sum by adding the current element to the previous prefix sum\\n            prefixSum[i + 1] = prefixSum[i] + nums[i]\\n        \\n        # Iterate over the elements in the input list, excluding the boundary elements\\n        for i in range(k, n - k):\\n            # Calculate the average of the subarray using the prefix sum array\\n            ans[i] = (prefixSum[i + k + 1] - prefixSum[i - k]) // windowSize\\n        \\n        # Return the answer list\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1936684,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1891523,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1937059,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936499,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936511,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936617,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936489,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936607,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936867,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936542,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936684,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1891523,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1937059,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936499,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936511,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936617,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936489,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936607,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936867,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1936542,
                "content": [
                    {
                        "username": "perfectroad",
                        "content": "Whoever made the last test case deserves a spank in the butt."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@AnywaySo](/AnywaySo) Even with the last test case it\\'s an easy, you just need to use long instead of int"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If there is no final test case, this problem should be an EASY."
                    },
                    {
                        "username": "psionl0",
                        "content": "You want to reward the person for that?"
                    },
                    {
                        "username": "Noah492",
                        "content": "Heads up, the final test case is pretty ridiculous where the array length looks to be 100000 and all the elements are 100000. Use a long rather than an int if you are summing them up!"
                    },
                    {
                        "username": "afzaltec",
                        "content": "Bro you are a life saver!!!! "
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Thanks! That made my day xD"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, when u taking sum of a vector in any step, be prepared:  it\\'s a trap!"
                    },
                    {
                        "username": "Chrisgoo888",
                        "content": "Bro nearly saved my life.... ran into more edge cases"
                    },
                    {
                        "username": "Cong-GD",
                        "content": "yeah i forgot that problem and made the mistake"
                    },
                    {
                        "username": "mrepractice",
                        "content": "i love u"
                    },
                    {
                        "username": "sajidrec",
                        "content": "Most of the Discussion section I found some people who will always say this shouldn\\'t be medium should be easy or this shouldn\\'t be hard this should be medium.\\nIt\\'s good  for you to feel  the problem easy but think about people who couldn\\'t figure it out, you are demotivating those people.\\nWho ever didn\\'t figure it out how to solve this in one or more try don\\'t give up I think every time you submit wrong answer it\\'s helps you to become better programmer."
                    },
                    {
                        "username": "sajidrec",
                        "content": "[@dev-null0](/dev-null0)  there is feedback option you can report that the problem should be easy not medium no bad thing in that. Don't misunderstand me I just want to point out telling this problem should be easy on discussion section I think it's a better option to give you're feedback on report section ."
                    },
                    {
                        "username": "dev-null0",
                        "content": "We're saying it's an easy question because it should be categorized as easy. Right now it's marked as \"Medium\" which is the same category as much harder questions. If you're getting demotivated by it then that's your own problem."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "To be fair, there are some hard problems where absolutely no one in the discussion section is saying that this shouldn\\'t be a hard. Although its best not to think about those problems too much"
                    },
                    {
                        "username": "jensenlwt",
                        "content": "same thoughts! when I just started out, this problem could be even hard for me. Let\\'s leave those unnecessary comments and make this place a more conducive place to learn from each other instead. "
                    },
                    {
                        "username": "kevinyou77",
                        "content": "The \"tHeSe sHoUlD bE eAsY\" people are seriously getting on my nerves. Like you solve hundreds of questions in this site already ofc you\\'re going to feel this is an easy when you\\'re already familiar with all the concepts. These  kind of comments can really be discouraging to beginners.\\nSo my advice to these kind of people, please, stfu."
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Exactly ! If I was given the same problem like 4 - 5 months ago, I probably would have use the simple BRUTE approach. Mediums become easy only with experience."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Be mindful of long to int type casting in java. \\nRemember :\\n(int) (long1-long2)/(int) is different from (int) ((long1-long2)/(int))\\na bracket can make big difference."
                    },
                    {
                        "username": "caaaarrllooooss",
                        "content": "Thanks!"
                    },
                    {
                        "username": "avanibarmecha",
                        "content": "thanks for pointing this out."
                    },
                    {
                        "username": "who_rules",
                        "content": "thanks!"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Can we avoid this problem finding how difference in sum affects average. If not using long and double were a restriction. "
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Yes! Made the same mistake"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Did you see the test case [100000]*40000?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\nHave to do a type conversion because int isn't big enough for that."
                    },
                    {
                        "username": "_jaguar",
                        "content": "Testcases are better than description."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Always been"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "I quit when it\\'s description is like an essay"
                    },
                    {
                        "username": "eminimus",
                        "content": "you\\'re hired"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "It should be an EASY."
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "thanks for your great contribution to the platform, every member of this community appreciates it"
                    },
                    {
                        "username": "liebrynth",
                        "content": "except last test case it is tricky on first try\\n"
                    },
                    {
                        "username": "Anuj2711",
                        "content": "39/39 testcases passed still not submitting the code. What a lucky day for me......sigh"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "Use long type for sum numbers"
                    },
                    {
                        "username": "AMIR34A",
                        "content": "[@malfunctioner](/malfunctioner) Use long type for sum numbers"
                    },
                    {
                        "username": "malfunctioner",
                        "content": "same here ...getting a invalid test case\\'"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "The 38/39 integer overflow testcase is very disappointing..."
                    }
                ]
            },
            {
                "id": 1910304,
                "content": [
                    {
                        "username": "jerielchanzy",
                        "content": "Testcase 39  (last test case as of date) has no input ( no nums array nor k integer) nor expected output. Any advice regarding this? I keep failing this last weird test case."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "Should be easy with sliding window."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "guys, it\\'s the week of prefix sum!!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "[@Ashish_4k](/Ashish_4k) urgh nothing we can do bruh"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@hardcoredummmy](/hardcoredummmy) the most wag thing about this is addition of 10^5 of values 10^5 like who made these absurd test cases."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@hardcoredummmy](/hardcoredummmy) I did with sliding window , isn\\'t wordy at all !!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Well, sliding window would work too, might be slightly wordy to implement "
                    },
                    {
                        "username": "andryuwka",
                        "content": "I finally dissappointed with case  `nums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk = 1`\nMy output at `i = 3` was `60091`, but they expected `60092`\ntried to debug this issue and what is happend.\naverage value calculated by swift  as `60091.999999999993` and `floor(_:)` function ofc gives `60091`\n¯\\_(ツ)_/¯ "
                    },
                    {
                        "username": "andryuwka",
                        "content": "problem was when i tried to optimize immediately by preserving `prevAvg` instead of `prevSum with UInt64 type` and in some cases eventually it failed. And when i turned my solution via `prevSum` it passed all cases =))"
                    },
                    {
                        "username": "Aadil42",
                        "content": "The description is harder than solving the problem itself. "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Fun problem!"
                    },
                    {
                        "username": "Tushar0009",
                        "content": "Test Case 38/39 falls under the category of Medium difficulty?\nThe ideal difficulty would be easy."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "This is an easy problem only if you have gained experience solving problems and learning concepts. Don\\'t be discouraged at all if you can\\'t solve this whilst seeing others claim its easy. Just learn the concepts and patterns and keep going!!! A year ago i doubt I would\\'ve solved this at all even if i had two hours."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "MY laptop lagged for a momment adding that big number."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@codepiyush1](/codepiyush1) Ohh the thing is the input values were too large that also was one of the cause."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro. your code is not run in your local system. It is running on Leetcode server."
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Why the last test case mannnn \\uD83D\\uDE25 just whyyyyy ???? one submit wasted !"
                    }
                ]
            },
            {
                "id": 1936675,
                "content": [
                    {
                        "username": "jerielchanzy",
                        "content": "Testcase 39  (last test case as of date) has no input ( no nums array nor k integer) nor expected output. Any advice regarding this? I keep failing this last weird test case."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "Should be easy with sliding window."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "guys, it\\'s the week of prefix sum!!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "[@Ashish_4k](/Ashish_4k) urgh nothing we can do bruh"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@hardcoredummmy](/hardcoredummmy) the most wag thing about this is addition of 10^5 of values 10^5 like who made these absurd test cases."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@hardcoredummmy](/hardcoredummmy) I did with sliding window , isn\\'t wordy at all !!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Well, sliding window would work too, might be slightly wordy to implement "
                    },
                    {
                        "username": "andryuwka",
                        "content": "I finally dissappointed with case  `nums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk = 1`\nMy output at `i = 3` was `60091`, but they expected `60092`\ntried to debug this issue and what is happend.\naverage value calculated by swift  as `60091.999999999993` and `floor(_:)` function ofc gives `60091`\n¯\\_(ツ)_/¯ "
                    },
                    {
                        "username": "andryuwka",
                        "content": "problem was when i tried to optimize immediately by preserving `prevAvg` instead of `prevSum with UInt64 type` and in some cases eventually it failed. And when i turned my solution via `prevSum` it passed all cases =))"
                    },
                    {
                        "username": "Aadil42",
                        "content": "The description is harder than solving the problem itself. "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Fun problem!"
                    },
                    {
                        "username": "Tushar0009",
                        "content": "Test Case 38/39 falls under the category of Medium difficulty?\nThe ideal difficulty would be easy."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "This is an easy problem only if you have gained experience solving problems and learning concepts. Don\\'t be discouraged at all if you can\\'t solve this whilst seeing others claim its easy. Just learn the concepts and patterns and keep going!!! A year ago i doubt I would\\'ve solved this at all even if i had two hours."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "MY laptop lagged for a momment adding that big number."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@codepiyush1](/codepiyush1) Ohh the thing is the input values were too large that also was one of the cause."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro. your code is not run in your local system. It is running on Leetcode server."
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Why the last test case mannnn \\uD83D\\uDE25 just whyyyyy ???? one submit wasted !"
                    }
                ]
            },
            {
                "id": 1936490,
                "content": [
                    {
                        "username": "jerielchanzy",
                        "content": "Testcase 39  (last test case as of date) has no input ( no nums array nor k integer) nor expected output. Any advice regarding this? I keep failing this last weird test case."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "Should be easy with sliding window."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "guys, it\\'s the week of prefix sum!!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "[@Ashish_4k](/Ashish_4k) urgh nothing we can do bruh"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@hardcoredummmy](/hardcoredummmy) the most wag thing about this is addition of 10^5 of values 10^5 like who made these absurd test cases."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@hardcoredummmy](/hardcoredummmy) I did with sliding window , isn\\'t wordy at all !!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Well, sliding window would work too, might be slightly wordy to implement "
                    },
                    {
                        "username": "andryuwka",
                        "content": "I finally dissappointed with case  `nums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk = 1`\nMy output at `i = 3` was `60091`, but they expected `60092`\ntried to debug this issue and what is happend.\naverage value calculated by swift  as `60091.999999999993` and `floor(_:)` function ofc gives `60091`\n¯\\_(ツ)_/¯ "
                    },
                    {
                        "username": "andryuwka",
                        "content": "problem was when i tried to optimize immediately by preserving `prevAvg` instead of `prevSum with UInt64 type` and in some cases eventually it failed. And when i turned my solution via `prevSum` it passed all cases =))"
                    },
                    {
                        "username": "Aadil42",
                        "content": "The description is harder than solving the problem itself. "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Fun problem!"
                    },
                    {
                        "username": "Tushar0009",
                        "content": "Test Case 38/39 falls under the category of Medium difficulty?\nThe ideal difficulty would be easy."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "This is an easy problem only if you have gained experience solving problems and learning concepts. Don\\'t be discouraged at all if you can\\'t solve this whilst seeing others claim its easy. Just learn the concepts and patterns and keep going!!! A year ago i doubt I would\\'ve solved this at all even if i had two hours."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "MY laptop lagged for a momment adding that big number."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@codepiyush1](/codepiyush1) Ohh the thing is the input values were too large that also was one of the cause."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro. your code is not run in your local system. It is running on Leetcode server."
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Why the last test case mannnn \\uD83D\\uDE25 just whyyyyy ???? one submit wasted !"
                    }
                ]
            },
            {
                "id": 1937161,
                "content": [
                    {
                        "username": "jerielchanzy",
                        "content": "Testcase 39  (last test case as of date) has no input ( no nums array nor k integer) nor expected output. Any advice regarding this? I keep failing this last weird test case."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "Should be easy with sliding window."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "guys, it\\'s the week of prefix sum!!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "[@Ashish_4k](/Ashish_4k) urgh nothing we can do bruh"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@hardcoredummmy](/hardcoredummmy) the most wag thing about this is addition of 10^5 of values 10^5 like who made these absurd test cases."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@hardcoredummmy](/hardcoredummmy) I did with sliding window , isn\\'t wordy at all !!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Well, sliding window would work too, might be slightly wordy to implement "
                    },
                    {
                        "username": "andryuwka",
                        "content": "I finally dissappointed with case  `nums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk = 1`\nMy output at `i = 3` was `60091`, but they expected `60092`\ntried to debug this issue and what is happend.\naverage value calculated by swift  as `60091.999999999993` and `floor(_:)` function ofc gives `60091`\n¯\\_(ツ)_/¯ "
                    },
                    {
                        "username": "andryuwka",
                        "content": "problem was when i tried to optimize immediately by preserving `prevAvg` instead of `prevSum with UInt64 type` and in some cases eventually it failed. And when i turned my solution via `prevSum` it passed all cases =))"
                    },
                    {
                        "username": "Aadil42",
                        "content": "The description is harder than solving the problem itself. "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Fun problem!"
                    },
                    {
                        "username": "Tushar0009",
                        "content": "Test Case 38/39 falls under the category of Medium difficulty?\nThe ideal difficulty would be easy."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "This is an easy problem only if you have gained experience solving problems and learning concepts. Don\\'t be discouraged at all if you can\\'t solve this whilst seeing others claim its easy. Just learn the concepts and patterns and keep going!!! A year ago i doubt I would\\'ve solved this at all even if i had two hours."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "MY laptop lagged for a momment adding that big number."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@codepiyush1](/codepiyush1) Ohh the thing is the input values were too large that also was one of the cause."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro. your code is not run in your local system. It is running on Leetcode server."
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Why the last test case mannnn \\uD83D\\uDE25 just whyyyyy ???? one submit wasted !"
                    }
                ]
            },
            {
                "id": 1936632,
                "content": [
                    {
                        "username": "jerielchanzy",
                        "content": "Testcase 39  (last test case as of date) has no input ( no nums array nor k integer) nor expected output. Any advice regarding this? I keep failing this last weird test case."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "Should be easy with sliding window."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "guys, it\\'s the week of prefix sum!!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "[@Ashish_4k](/Ashish_4k) urgh nothing we can do bruh"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@hardcoredummmy](/hardcoredummmy) the most wag thing about this is addition of 10^5 of values 10^5 like who made these absurd test cases."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@hardcoredummmy](/hardcoredummmy) I did with sliding window , isn\\'t wordy at all !!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Well, sliding window would work too, might be slightly wordy to implement "
                    },
                    {
                        "username": "andryuwka",
                        "content": "I finally dissappointed with case  `nums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk = 1`\nMy output at `i = 3` was `60091`, but they expected `60092`\ntried to debug this issue and what is happend.\naverage value calculated by swift  as `60091.999999999993` and `floor(_:)` function ofc gives `60091`\n¯\\_(ツ)_/¯ "
                    },
                    {
                        "username": "andryuwka",
                        "content": "problem was when i tried to optimize immediately by preserving `prevAvg` instead of `prevSum with UInt64 type` and in some cases eventually it failed. And when i turned my solution via `prevSum` it passed all cases =))"
                    },
                    {
                        "username": "Aadil42",
                        "content": "The description is harder than solving the problem itself. "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Fun problem!"
                    },
                    {
                        "username": "Tushar0009",
                        "content": "Test Case 38/39 falls under the category of Medium difficulty?\nThe ideal difficulty would be easy."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "This is an easy problem only if you have gained experience solving problems and learning concepts. Don\\'t be discouraged at all if you can\\'t solve this whilst seeing others claim its easy. Just learn the concepts and patterns and keep going!!! A year ago i doubt I would\\'ve solved this at all even if i had two hours."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "MY laptop lagged for a momment adding that big number."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@codepiyush1](/codepiyush1) Ohh the thing is the input values were too large that also was one of the cause."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro. your code is not run in your local system. It is running on Leetcode server."
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Why the last test case mannnn \\uD83D\\uDE25 just whyyyyy ???? one submit wasted !"
                    }
                ]
            },
            {
                "id": 1936594,
                "content": [
                    {
                        "username": "jerielchanzy",
                        "content": "Testcase 39  (last test case as of date) has no input ( no nums array nor k integer) nor expected output. Any advice regarding this? I keep failing this last weird test case."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "Should be easy with sliding window."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "guys, it\\'s the week of prefix sum!!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "[@Ashish_4k](/Ashish_4k) urgh nothing we can do bruh"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@hardcoredummmy](/hardcoredummmy) the most wag thing about this is addition of 10^5 of values 10^5 like who made these absurd test cases."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@hardcoredummmy](/hardcoredummmy) I did with sliding window , isn\\'t wordy at all !!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Well, sliding window would work too, might be slightly wordy to implement "
                    },
                    {
                        "username": "andryuwka",
                        "content": "I finally dissappointed with case  `nums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk = 1`\nMy output at `i = 3` was `60091`, but they expected `60092`\ntried to debug this issue and what is happend.\naverage value calculated by swift  as `60091.999999999993` and `floor(_:)` function ofc gives `60091`\n¯\\_(ツ)_/¯ "
                    },
                    {
                        "username": "andryuwka",
                        "content": "problem was when i tried to optimize immediately by preserving `prevAvg` instead of `prevSum with UInt64 type` and in some cases eventually it failed. And when i turned my solution via `prevSum` it passed all cases =))"
                    },
                    {
                        "username": "Aadil42",
                        "content": "The description is harder than solving the problem itself. "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Fun problem!"
                    },
                    {
                        "username": "Tushar0009",
                        "content": "Test Case 38/39 falls under the category of Medium difficulty?\nThe ideal difficulty would be easy."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "This is an easy problem only if you have gained experience solving problems and learning concepts. Don\\'t be discouraged at all if you can\\'t solve this whilst seeing others claim its easy. Just learn the concepts and patterns and keep going!!! A year ago i doubt I would\\'ve solved this at all even if i had two hours."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "MY laptop lagged for a momment adding that big number."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@codepiyush1](/codepiyush1) Ohh the thing is the input values were too large that also was one of the cause."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro. your code is not run in your local system. It is running on Leetcode server."
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Why the last test case mannnn \\uD83D\\uDE25 just whyyyyy ???? one submit wasted !"
                    }
                ]
            },
            {
                "id": 1936550,
                "content": [
                    {
                        "username": "jerielchanzy",
                        "content": "Testcase 39  (last test case as of date) has no input ( no nums array nor k integer) nor expected output. Any advice regarding this? I keep failing this last weird test case."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "Should be easy with sliding window."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "guys, it\\'s the week of prefix sum!!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "[@Ashish_4k](/Ashish_4k) urgh nothing we can do bruh"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@hardcoredummmy](/hardcoredummmy) the most wag thing about this is addition of 10^5 of values 10^5 like who made these absurd test cases."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@hardcoredummmy](/hardcoredummmy) I did with sliding window , isn\\'t wordy at all !!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Well, sliding window would work too, might be slightly wordy to implement "
                    },
                    {
                        "username": "andryuwka",
                        "content": "I finally dissappointed with case  `nums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk = 1`\nMy output at `i = 3` was `60091`, but they expected `60092`\ntried to debug this issue and what is happend.\naverage value calculated by swift  as `60091.999999999993` and `floor(_:)` function ofc gives `60091`\n¯\\_(ツ)_/¯ "
                    },
                    {
                        "username": "andryuwka",
                        "content": "problem was when i tried to optimize immediately by preserving `prevAvg` instead of `prevSum with UInt64 type` and in some cases eventually it failed. And when i turned my solution via `prevSum` it passed all cases =))"
                    },
                    {
                        "username": "Aadil42",
                        "content": "The description is harder than solving the problem itself. "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Fun problem!"
                    },
                    {
                        "username": "Tushar0009",
                        "content": "Test Case 38/39 falls under the category of Medium difficulty?\nThe ideal difficulty would be easy."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "This is an easy problem only if you have gained experience solving problems and learning concepts. Don\\'t be discouraged at all if you can\\'t solve this whilst seeing others claim its easy. Just learn the concepts and patterns and keep going!!! A year ago i doubt I would\\'ve solved this at all even if i had two hours."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "MY laptop lagged for a momment adding that big number."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@codepiyush1](/codepiyush1) Ohh the thing is the input values were too large that also was one of the cause."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro. your code is not run in your local system. It is running on Leetcode server."
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Why the last test case mannnn \\uD83D\\uDE25 just whyyyyy ???? one submit wasted !"
                    }
                ]
            },
            {
                "id": 1941909,
                "content": [
                    {
                        "username": "jerielchanzy",
                        "content": "Testcase 39  (last test case as of date) has no input ( no nums array nor k integer) nor expected output. Any advice regarding this? I keep failing this last weird test case."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "Should be easy with sliding window."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "guys, it\\'s the week of prefix sum!!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "[@Ashish_4k](/Ashish_4k) urgh nothing we can do bruh"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@hardcoredummmy](/hardcoredummmy) the most wag thing about this is addition of 10^5 of values 10^5 like who made these absurd test cases."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@hardcoredummmy](/hardcoredummmy) I did with sliding window , isn\\'t wordy at all !!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Well, sliding window would work too, might be slightly wordy to implement "
                    },
                    {
                        "username": "andryuwka",
                        "content": "I finally dissappointed with case  `nums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk = 1`\nMy output at `i = 3` was `60091`, but they expected `60092`\ntried to debug this issue and what is happend.\naverage value calculated by swift  as `60091.999999999993` and `floor(_:)` function ofc gives `60091`\n¯\\_(ツ)_/¯ "
                    },
                    {
                        "username": "andryuwka",
                        "content": "problem was when i tried to optimize immediately by preserving `prevAvg` instead of `prevSum with UInt64 type` and in some cases eventually it failed. And when i turned my solution via `prevSum` it passed all cases =))"
                    },
                    {
                        "username": "Aadil42",
                        "content": "The description is harder than solving the problem itself. "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Fun problem!"
                    },
                    {
                        "username": "Tushar0009",
                        "content": "Test Case 38/39 falls under the category of Medium difficulty?\nThe ideal difficulty would be easy."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "This is an easy problem only if you have gained experience solving problems and learning concepts. Don\\'t be discouraged at all if you can\\'t solve this whilst seeing others claim its easy. Just learn the concepts and patterns and keep going!!! A year ago i doubt I would\\'ve solved this at all even if i had two hours."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "MY laptop lagged for a momment adding that big number."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@codepiyush1](/codepiyush1) Ohh the thing is the input values were too large that also was one of the cause."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro. your code is not run in your local system. It is running on Leetcode server."
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Why the last test case mannnn \\uD83D\\uDE25 just whyyyyy ???? one submit wasted !"
                    }
                ]
            },
            {
                "id": 1937393,
                "content": [
                    {
                        "username": "jerielchanzy",
                        "content": "Testcase 39  (last test case as of date) has no input ( no nums array nor k integer) nor expected output. Any advice regarding this? I keep failing this last weird test case."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "Should be easy with sliding window."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "guys, it\\'s the week of prefix sum!!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "[@Ashish_4k](/Ashish_4k) urgh nothing we can do bruh"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@hardcoredummmy](/hardcoredummmy) the most wag thing about this is addition of 10^5 of values 10^5 like who made these absurd test cases."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@hardcoredummmy](/hardcoredummmy) I did with sliding window , isn\\'t wordy at all !!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Well, sliding window would work too, might be slightly wordy to implement "
                    },
                    {
                        "username": "andryuwka",
                        "content": "I finally dissappointed with case  `nums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk = 1`\nMy output at `i = 3` was `60091`, but they expected `60092`\ntried to debug this issue and what is happend.\naverage value calculated by swift  as `60091.999999999993` and `floor(_:)` function ofc gives `60091`\n¯\\_(ツ)_/¯ "
                    },
                    {
                        "username": "andryuwka",
                        "content": "problem was when i tried to optimize immediately by preserving `prevAvg` instead of `prevSum with UInt64 type` and in some cases eventually it failed. And when i turned my solution via `prevSum` it passed all cases =))"
                    },
                    {
                        "username": "Aadil42",
                        "content": "The description is harder than solving the problem itself. "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Fun problem!"
                    },
                    {
                        "username": "Tushar0009",
                        "content": "Test Case 38/39 falls under the category of Medium difficulty?\nThe ideal difficulty would be easy."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "This is an easy problem only if you have gained experience solving problems and learning concepts. Don\\'t be discouraged at all if you can\\'t solve this whilst seeing others claim its easy. Just learn the concepts and patterns and keep going!!! A year ago i doubt I would\\'ve solved this at all even if i had two hours."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "MY laptop lagged for a momment adding that big number."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@codepiyush1](/codepiyush1) Ohh the thing is the input values were too large that also was one of the cause."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro. your code is not run in your local system. It is running on Leetcode server."
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Why the last test case mannnn \\uD83D\\uDE25 just whyyyyy ???? one submit wasted !"
                    }
                ]
            },
            {
                "id": 1937120,
                "content": [
                    {
                        "username": "jerielchanzy",
                        "content": "Testcase 39  (last test case as of date) has no input ( no nums array nor k integer) nor expected output. Any advice regarding this? I keep failing this last weird test case."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "Should be easy with sliding window."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "guys, it\\'s the week of prefix sum!!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "[@Ashish_4k](/Ashish_4k) urgh nothing we can do bruh"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@hardcoredummmy](/hardcoredummmy) the most wag thing about this is addition of 10^5 of values 10^5 like who made these absurd test cases."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@hardcoredummmy](/hardcoredummmy) I did with sliding window , isn\\'t wordy at all !!"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Well, sliding window would work too, might be slightly wordy to implement "
                    },
                    {
                        "username": "andryuwka",
                        "content": "I finally dissappointed with case  `nums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk = 1`\nMy output at `i = 3` was `60091`, but they expected `60092`\ntried to debug this issue and what is happend.\naverage value calculated by swift  as `60091.999999999993` and `floor(_:)` function ofc gives `60091`\n¯\\_(ツ)_/¯ "
                    },
                    {
                        "username": "andryuwka",
                        "content": "problem was when i tried to optimize immediately by preserving `prevAvg` instead of `prevSum with UInt64 type` and in some cases eventually it failed. And when i turned my solution via `prevSum` it passed all cases =))"
                    },
                    {
                        "username": "Aadil42",
                        "content": "The description is harder than solving the problem itself. "
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Fun problem!"
                    },
                    {
                        "username": "Tushar0009",
                        "content": "Test Case 38/39 falls under the category of Medium difficulty?\nThe ideal difficulty would be easy."
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "This is an easy problem only if you have gained experience solving problems and learning concepts. Don\\'t be discouraged at all if you can\\'t solve this whilst seeing others claim its easy. Just learn the concepts and patterns and keep going!!! A year ago i doubt I would\\'ve solved this at all even if i had two hours."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "MY laptop lagged for a momment adding that big number."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@codepiyush1](/codepiyush1) Ohh the thing is the input values were too large that also was one of the cause."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Bro. your code is not run in your local system. It is running on Leetcode server."
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Why the last test case mannnn \\uD83D\\uDE25 just whyyyyy ???? one submit wasted !"
                    }
                ]
            },
            {
                "id": 1936924,
                "content": [
                    {
                        "username": "lucistark",
                        "content": "failing one test-case can anyone help me in this \\n ```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=nums.length-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<nums.length;i++){\\n            if(i-k<0||i+k>=nums.length){\\n               continue;\\n            }\\n            else{\\n                int sum=(int)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n                sum=sum/(2*k+1);\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n} ```"
                    },
                    {
                        "username": "lucistark",
                        "content": "[@satyam47](/satyam47) thank you"
                    },
                    {
                        "username": "satyam47",
                        "content": "make prefix and sufix array of long data type\n```\nlong prefix[]=new long[nums.length];\nlong suffix[]=new long[nums.length];\n```\nand use long type for sum then store avg in int  \n```\nlong sum=(long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\nsum=sum/(2*k+1);\nans[i]=(int)sum;\n```"
                    },
                    {
                        "username": "guri_1",
                        "content": "Can some pls tell me why if i intialize val as below it fails on the final testcase\\nbut if i do it like this int val=(pre[i+k+1]-pre[i-k])/divi it passes?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         int n=nums.size();\\n          vector<long long >pre(n+1,0);\\n           vector<int>ans(n,-1);\\n           int divi=2*k+1;\\n           if(n<divi) return ans;\\n           \\n            for(int i=0;i<n;i++){\\n                 pre[i+1]=pre[i]+nums[i];\\n            }\\n           \\n           \\n             for(int i=k;i<n-k;i++){\\n               int val=(pre[i+k+1]-pre[i-k]);\\n               val=val/divi;\\n             \\n               ans[i]=val;\\n             }\\n             return ans;\\n    }\\n};"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "The final test case has large numbers which makes your prefix sum exceed integer limit. In your code, you are initializing val as integer and thus fails, where as passing the val after dividing prevents the same."
                    },
                    {
                        "username": "satyam47",
                        "content": "you should store prefix in long data type and also use val of long data type"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The repetitive silly mistake of signed Integer overflow makes me wanna move to Python\\uD83E\\uDD72"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Please let me make my June streak."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      vector<int> ans(n, -1);\\n\\n      if(n < 2*k+1)\\n        return ans;\\n\\n   long long  sum = 0;\\n    int i ,j , c;\\n    //creating window\\n    for( i = 0; i <= 2*k ; i++){\\n        sum += nums[i];\\n    }\\n    ans[k] = sum/(2*k + 1);\\n    for( i = 0 , j = 2*k + 1 ,c = k+1 ; j < n ; i++,j++,c++){\\n            sum = sum - nums[i] + nums[j];\\n             ans[c] = sum/(2*k + 1);\\n    }  \\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kristjan_vingel",
                        "content": "Can anyone help me - what am I doing wrong? It fails the last test case but I don\\'t understand why.\\n\\n```java\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        \\n        if (k == 0) {\\n            return nums;\\n        }\\n        \\n        // setup\\n        int[] answers = new int[nums.length];\\n        Arrays.fill(answers, -1);\\n        long[] prefixes = new long[nums.length];\\n        \\n        if (nums.length < k * 2 + 1) {\\n            return answers;\\n        }\\n        \\n        // create prefixes array\\n        prefixes[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixes[i] = nums[i] + prefixes[i-1];\\n        }\\n        \\n        for (int i = k; i < (prefixes.length - k); ++i) {\\n            long sum = prefixes[i+k] - (i - k > 0 ? prefixes[i-k-1] : 0);\\n            int avg = (int)sum / (2 * k + 1);\\n            answers[i] = avg;\\n        }\\n        \\n        return answers;\\n    }\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "kirillq",
                        "content": "Think about prefix sum, solution will comes after"
                    },
                    {
                        "username": "dancaps",
                        "content": "The description isn\\'t great. It would be better if they were less cryptic with the expected output."
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "last test is failing because of improper type conversion. while calculating average\\ninstead of doing \\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) sum/(2*k +1);\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\ndo this fix\\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) (sum/(2*k +1));\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\nonly difference is the braces this line\\nans[i-k] =(int) (sum/(2*k +1));"
                    },
                    {
                        "username": "Prajjal",
                        "content": "I have passed 39 test cases but still it shows TLE....\n"
                    }
                ]
            },
            {
                "id": 1936899,
                "content": [
                    {
                        "username": "lucistark",
                        "content": "failing one test-case can anyone help me in this \\n ```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=nums.length-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<nums.length;i++){\\n            if(i-k<0||i+k>=nums.length){\\n               continue;\\n            }\\n            else{\\n                int sum=(int)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n                sum=sum/(2*k+1);\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n} ```"
                    },
                    {
                        "username": "lucistark",
                        "content": "[@satyam47](/satyam47) thank you"
                    },
                    {
                        "username": "satyam47",
                        "content": "make prefix and sufix array of long data type\n```\nlong prefix[]=new long[nums.length];\nlong suffix[]=new long[nums.length];\n```\nand use long type for sum then store avg in int  \n```\nlong sum=(long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\nsum=sum/(2*k+1);\nans[i]=(int)sum;\n```"
                    },
                    {
                        "username": "guri_1",
                        "content": "Can some pls tell me why if i intialize val as below it fails on the final testcase\\nbut if i do it like this int val=(pre[i+k+1]-pre[i-k])/divi it passes?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         int n=nums.size();\\n          vector<long long >pre(n+1,0);\\n           vector<int>ans(n,-1);\\n           int divi=2*k+1;\\n           if(n<divi) return ans;\\n           \\n            for(int i=0;i<n;i++){\\n                 pre[i+1]=pre[i]+nums[i];\\n            }\\n           \\n           \\n             for(int i=k;i<n-k;i++){\\n               int val=(pre[i+k+1]-pre[i-k]);\\n               val=val/divi;\\n             \\n               ans[i]=val;\\n             }\\n             return ans;\\n    }\\n};"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "The final test case has large numbers which makes your prefix sum exceed integer limit. In your code, you are initializing val as integer and thus fails, where as passing the val after dividing prevents the same."
                    },
                    {
                        "username": "satyam47",
                        "content": "you should store prefix in long data type and also use val of long data type"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The repetitive silly mistake of signed Integer overflow makes me wanna move to Python\\uD83E\\uDD72"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Please let me make my June streak."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      vector<int> ans(n, -1);\\n\\n      if(n < 2*k+1)\\n        return ans;\\n\\n   long long  sum = 0;\\n    int i ,j , c;\\n    //creating window\\n    for( i = 0; i <= 2*k ; i++){\\n        sum += nums[i];\\n    }\\n    ans[k] = sum/(2*k + 1);\\n    for( i = 0 , j = 2*k + 1 ,c = k+1 ; j < n ; i++,j++,c++){\\n            sum = sum - nums[i] + nums[j];\\n             ans[c] = sum/(2*k + 1);\\n    }  \\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kristjan_vingel",
                        "content": "Can anyone help me - what am I doing wrong? It fails the last test case but I don\\'t understand why.\\n\\n```java\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        \\n        if (k == 0) {\\n            return nums;\\n        }\\n        \\n        // setup\\n        int[] answers = new int[nums.length];\\n        Arrays.fill(answers, -1);\\n        long[] prefixes = new long[nums.length];\\n        \\n        if (nums.length < k * 2 + 1) {\\n            return answers;\\n        }\\n        \\n        // create prefixes array\\n        prefixes[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixes[i] = nums[i] + prefixes[i-1];\\n        }\\n        \\n        for (int i = k; i < (prefixes.length - k); ++i) {\\n            long sum = prefixes[i+k] - (i - k > 0 ? prefixes[i-k-1] : 0);\\n            int avg = (int)sum / (2 * k + 1);\\n            answers[i] = avg;\\n        }\\n        \\n        return answers;\\n    }\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "kirillq",
                        "content": "Think about prefix sum, solution will comes after"
                    },
                    {
                        "username": "dancaps",
                        "content": "The description isn\\'t great. It would be better if they were less cryptic with the expected output."
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "last test is failing because of improper type conversion. while calculating average\\ninstead of doing \\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) sum/(2*k +1);\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\ndo this fix\\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) (sum/(2*k +1));\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\nonly difference is the braces this line\\nans[i-k] =(int) (sum/(2*k +1));"
                    },
                    {
                        "username": "Prajjal",
                        "content": "I have passed 39 test cases but still it shows TLE....\n"
                    }
                ]
            },
            {
                "id": 1936839,
                "content": [
                    {
                        "username": "lucistark",
                        "content": "failing one test-case can anyone help me in this \\n ```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=nums.length-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<nums.length;i++){\\n            if(i-k<0||i+k>=nums.length){\\n               continue;\\n            }\\n            else{\\n                int sum=(int)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n                sum=sum/(2*k+1);\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n} ```"
                    },
                    {
                        "username": "lucistark",
                        "content": "[@satyam47](/satyam47) thank you"
                    },
                    {
                        "username": "satyam47",
                        "content": "make prefix and sufix array of long data type\n```\nlong prefix[]=new long[nums.length];\nlong suffix[]=new long[nums.length];\n```\nand use long type for sum then store avg in int  \n```\nlong sum=(long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\nsum=sum/(2*k+1);\nans[i]=(int)sum;\n```"
                    },
                    {
                        "username": "guri_1",
                        "content": "Can some pls tell me why if i intialize val as below it fails on the final testcase\\nbut if i do it like this int val=(pre[i+k+1]-pre[i-k])/divi it passes?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         int n=nums.size();\\n          vector<long long >pre(n+1,0);\\n           vector<int>ans(n,-1);\\n           int divi=2*k+1;\\n           if(n<divi) return ans;\\n           \\n            for(int i=0;i<n;i++){\\n                 pre[i+1]=pre[i]+nums[i];\\n            }\\n           \\n           \\n             for(int i=k;i<n-k;i++){\\n               int val=(pre[i+k+1]-pre[i-k]);\\n               val=val/divi;\\n             \\n               ans[i]=val;\\n             }\\n             return ans;\\n    }\\n};"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "The final test case has large numbers which makes your prefix sum exceed integer limit. In your code, you are initializing val as integer and thus fails, where as passing the val after dividing prevents the same."
                    },
                    {
                        "username": "satyam47",
                        "content": "you should store prefix in long data type and also use val of long data type"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The repetitive silly mistake of signed Integer overflow makes me wanna move to Python\\uD83E\\uDD72"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Please let me make my June streak."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      vector<int> ans(n, -1);\\n\\n      if(n < 2*k+1)\\n        return ans;\\n\\n   long long  sum = 0;\\n    int i ,j , c;\\n    //creating window\\n    for( i = 0; i <= 2*k ; i++){\\n        sum += nums[i];\\n    }\\n    ans[k] = sum/(2*k + 1);\\n    for( i = 0 , j = 2*k + 1 ,c = k+1 ; j < n ; i++,j++,c++){\\n            sum = sum - nums[i] + nums[j];\\n             ans[c] = sum/(2*k + 1);\\n    }  \\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kristjan_vingel",
                        "content": "Can anyone help me - what am I doing wrong? It fails the last test case but I don\\'t understand why.\\n\\n```java\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        \\n        if (k == 0) {\\n            return nums;\\n        }\\n        \\n        // setup\\n        int[] answers = new int[nums.length];\\n        Arrays.fill(answers, -1);\\n        long[] prefixes = new long[nums.length];\\n        \\n        if (nums.length < k * 2 + 1) {\\n            return answers;\\n        }\\n        \\n        // create prefixes array\\n        prefixes[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixes[i] = nums[i] + prefixes[i-1];\\n        }\\n        \\n        for (int i = k; i < (prefixes.length - k); ++i) {\\n            long sum = prefixes[i+k] - (i - k > 0 ? prefixes[i-k-1] : 0);\\n            int avg = (int)sum / (2 * k + 1);\\n            answers[i] = avg;\\n        }\\n        \\n        return answers;\\n    }\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "kirillq",
                        "content": "Think about prefix sum, solution will comes after"
                    },
                    {
                        "username": "dancaps",
                        "content": "The description isn\\'t great. It would be better if they were less cryptic with the expected output."
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "last test is failing because of improper type conversion. while calculating average\\ninstead of doing \\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) sum/(2*k +1);\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\ndo this fix\\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) (sum/(2*k +1));\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\nonly difference is the braces this line\\nans[i-k] =(int) (sum/(2*k +1));"
                    },
                    {
                        "username": "Prajjal",
                        "content": "I have passed 39 test cases but still it shows TLE....\n"
                    }
                ]
            },
            {
                "id": 1936534,
                "content": [
                    {
                        "username": "lucistark",
                        "content": "failing one test-case can anyone help me in this \\n ```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=nums.length-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<nums.length;i++){\\n            if(i-k<0||i+k>=nums.length){\\n               continue;\\n            }\\n            else{\\n                int sum=(int)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n                sum=sum/(2*k+1);\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n} ```"
                    },
                    {
                        "username": "lucistark",
                        "content": "[@satyam47](/satyam47) thank you"
                    },
                    {
                        "username": "satyam47",
                        "content": "make prefix and sufix array of long data type\n```\nlong prefix[]=new long[nums.length];\nlong suffix[]=new long[nums.length];\n```\nand use long type for sum then store avg in int  \n```\nlong sum=(long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\nsum=sum/(2*k+1);\nans[i]=(int)sum;\n```"
                    },
                    {
                        "username": "guri_1",
                        "content": "Can some pls tell me why if i intialize val as below it fails on the final testcase\\nbut if i do it like this int val=(pre[i+k+1]-pre[i-k])/divi it passes?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         int n=nums.size();\\n          vector<long long >pre(n+1,0);\\n           vector<int>ans(n,-1);\\n           int divi=2*k+1;\\n           if(n<divi) return ans;\\n           \\n            for(int i=0;i<n;i++){\\n                 pre[i+1]=pre[i]+nums[i];\\n            }\\n           \\n           \\n             for(int i=k;i<n-k;i++){\\n               int val=(pre[i+k+1]-pre[i-k]);\\n               val=val/divi;\\n             \\n               ans[i]=val;\\n             }\\n             return ans;\\n    }\\n};"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "The final test case has large numbers which makes your prefix sum exceed integer limit. In your code, you are initializing val as integer and thus fails, where as passing the val after dividing prevents the same."
                    },
                    {
                        "username": "satyam47",
                        "content": "you should store prefix in long data type and also use val of long data type"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The repetitive silly mistake of signed Integer overflow makes me wanna move to Python\\uD83E\\uDD72"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Please let me make my June streak."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      vector<int> ans(n, -1);\\n\\n      if(n < 2*k+1)\\n        return ans;\\n\\n   long long  sum = 0;\\n    int i ,j , c;\\n    //creating window\\n    for( i = 0; i <= 2*k ; i++){\\n        sum += nums[i];\\n    }\\n    ans[k] = sum/(2*k + 1);\\n    for( i = 0 , j = 2*k + 1 ,c = k+1 ; j < n ; i++,j++,c++){\\n            sum = sum - nums[i] + nums[j];\\n             ans[c] = sum/(2*k + 1);\\n    }  \\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kristjan_vingel",
                        "content": "Can anyone help me - what am I doing wrong? It fails the last test case but I don\\'t understand why.\\n\\n```java\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        \\n        if (k == 0) {\\n            return nums;\\n        }\\n        \\n        // setup\\n        int[] answers = new int[nums.length];\\n        Arrays.fill(answers, -1);\\n        long[] prefixes = new long[nums.length];\\n        \\n        if (nums.length < k * 2 + 1) {\\n            return answers;\\n        }\\n        \\n        // create prefixes array\\n        prefixes[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixes[i] = nums[i] + prefixes[i-1];\\n        }\\n        \\n        for (int i = k; i < (prefixes.length - k); ++i) {\\n            long sum = prefixes[i+k] - (i - k > 0 ? prefixes[i-k-1] : 0);\\n            int avg = (int)sum / (2 * k + 1);\\n            answers[i] = avg;\\n        }\\n        \\n        return answers;\\n    }\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "kirillq",
                        "content": "Think about prefix sum, solution will comes after"
                    },
                    {
                        "username": "dancaps",
                        "content": "The description isn\\'t great. It would be better if they were less cryptic with the expected output."
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "last test is failing because of improper type conversion. while calculating average\\ninstead of doing \\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) sum/(2*k +1);\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\ndo this fix\\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) (sum/(2*k +1));\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\nonly difference is the braces this line\\nans[i-k] =(int) (sum/(2*k +1));"
                    },
                    {
                        "username": "Prajjal",
                        "content": "I have passed 39 test cases but still it shows TLE....\n"
                    }
                ]
            },
            {
                "id": 1763701,
                "content": [
                    {
                        "username": "lucistark",
                        "content": "failing one test-case can anyone help me in this \\n ```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=nums.length-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<nums.length;i++){\\n            if(i-k<0||i+k>=nums.length){\\n               continue;\\n            }\\n            else{\\n                int sum=(int)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n                sum=sum/(2*k+1);\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n} ```"
                    },
                    {
                        "username": "lucistark",
                        "content": "[@satyam47](/satyam47) thank you"
                    },
                    {
                        "username": "satyam47",
                        "content": "make prefix and sufix array of long data type\n```\nlong prefix[]=new long[nums.length];\nlong suffix[]=new long[nums.length];\n```\nand use long type for sum then store avg in int  \n```\nlong sum=(long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\nsum=sum/(2*k+1);\nans[i]=(int)sum;\n```"
                    },
                    {
                        "username": "guri_1",
                        "content": "Can some pls tell me why if i intialize val as below it fails on the final testcase\\nbut if i do it like this int val=(pre[i+k+1]-pre[i-k])/divi it passes?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         int n=nums.size();\\n          vector<long long >pre(n+1,0);\\n           vector<int>ans(n,-1);\\n           int divi=2*k+1;\\n           if(n<divi) return ans;\\n           \\n            for(int i=0;i<n;i++){\\n                 pre[i+1]=pre[i]+nums[i];\\n            }\\n           \\n           \\n             for(int i=k;i<n-k;i++){\\n               int val=(pre[i+k+1]-pre[i-k]);\\n               val=val/divi;\\n             \\n               ans[i]=val;\\n             }\\n             return ans;\\n    }\\n};"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "The final test case has large numbers which makes your prefix sum exceed integer limit. In your code, you are initializing val as integer and thus fails, where as passing the val after dividing prevents the same."
                    },
                    {
                        "username": "satyam47",
                        "content": "you should store prefix in long data type and also use val of long data type"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The repetitive silly mistake of signed Integer overflow makes me wanna move to Python\\uD83E\\uDD72"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Please let me make my June streak."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      vector<int> ans(n, -1);\\n\\n      if(n < 2*k+1)\\n        return ans;\\n\\n   long long  sum = 0;\\n    int i ,j , c;\\n    //creating window\\n    for( i = 0; i <= 2*k ; i++){\\n        sum += nums[i];\\n    }\\n    ans[k] = sum/(2*k + 1);\\n    for( i = 0 , j = 2*k + 1 ,c = k+1 ; j < n ; i++,j++,c++){\\n            sum = sum - nums[i] + nums[j];\\n             ans[c] = sum/(2*k + 1);\\n    }  \\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kristjan_vingel",
                        "content": "Can anyone help me - what am I doing wrong? It fails the last test case but I don\\'t understand why.\\n\\n```java\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        \\n        if (k == 0) {\\n            return nums;\\n        }\\n        \\n        // setup\\n        int[] answers = new int[nums.length];\\n        Arrays.fill(answers, -1);\\n        long[] prefixes = new long[nums.length];\\n        \\n        if (nums.length < k * 2 + 1) {\\n            return answers;\\n        }\\n        \\n        // create prefixes array\\n        prefixes[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixes[i] = nums[i] + prefixes[i-1];\\n        }\\n        \\n        for (int i = k; i < (prefixes.length - k); ++i) {\\n            long sum = prefixes[i+k] - (i - k > 0 ? prefixes[i-k-1] : 0);\\n            int avg = (int)sum / (2 * k + 1);\\n            answers[i] = avg;\\n        }\\n        \\n        return answers;\\n    }\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "kirillq",
                        "content": "Think about prefix sum, solution will comes after"
                    },
                    {
                        "username": "dancaps",
                        "content": "The description isn\\'t great. It would be better if they were less cryptic with the expected output."
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "last test is failing because of improper type conversion. while calculating average\\ninstead of doing \\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) sum/(2*k +1);\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\ndo this fix\\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) (sum/(2*k +1));\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\nonly difference is the braces this line\\nans[i-k] =(int) (sum/(2*k +1));"
                    },
                    {
                        "username": "Prajjal",
                        "content": "I have passed 39 test cases but still it shows TLE....\n"
                    }
                ]
            },
            {
                "id": 2064292,
                "content": [
                    {
                        "username": "lucistark",
                        "content": "failing one test-case can anyone help me in this \\n ```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=nums.length-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<nums.length;i++){\\n            if(i-k<0||i+k>=nums.length){\\n               continue;\\n            }\\n            else{\\n                int sum=(int)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n                sum=sum/(2*k+1);\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n} ```"
                    },
                    {
                        "username": "lucistark",
                        "content": "[@satyam47](/satyam47) thank you"
                    },
                    {
                        "username": "satyam47",
                        "content": "make prefix and sufix array of long data type\n```\nlong prefix[]=new long[nums.length];\nlong suffix[]=new long[nums.length];\n```\nand use long type for sum then store avg in int  \n```\nlong sum=(long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\nsum=sum/(2*k+1);\nans[i]=(int)sum;\n```"
                    },
                    {
                        "username": "guri_1",
                        "content": "Can some pls tell me why if i intialize val as below it fails on the final testcase\\nbut if i do it like this int val=(pre[i+k+1]-pre[i-k])/divi it passes?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         int n=nums.size();\\n          vector<long long >pre(n+1,0);\\n           vector<int>ans(n,-1);\\n           int divi=2*k+1;\\n           if(n<divi) return ans;\\n           \\n            for(int i=0;i<n;i++){\\n                 pre[i+1]=pre[i]+nums[i];\\n            }\\n           \\n           \\n             for(int i=k;i<n-k;i++){\\n               int val=(pre[i+k+1]-pre[i-k]);\\n               val=val/divi;\\n             \\n               ans[i]=val;\\n             }\\n             return ans;\\n    }\\n};"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "The final test case has large numbers which makes your prefix sum exceed integer limit. In your code, you are initializing val as integer and thus fails, where as passing the val after dividing prevents the same."
                    },
                    {
                        "username": "satyam47",
                        "content": "you should store prefix in long data type and also use val of long data type"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The repetitive silly mistake of signed Integer overflow makes me wanna move to Python\\uD83E\\uDD72"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Please let me make my June streak."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      vector<int> ans(n, -1);\\n\\n      if(n < 2*k+1)\\n        return ans;\\n\\n   long long  sum = 0;\\n    int i ,j , c;\\n    //creating window\\n    for( i = 0; i <= 2*k ; i++){\\n        sum += nums[i];\\n    }\\n    ans[k] = sum/(2*k + 1);\\n    for( i = 0 , j = 2*k + 1 ,c = k+1 ; j < n ; i++,j++,c++){\\n            sum = sum - nums[i] + nums[j];\\n             ans[c] = sum/(2*k + 1);\\n    }  \\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kristjan_vingel",
                        "content": "Can anyone help me - what am I doing wrong? It fails the last test case but I don\\'t understand why.\\n\\n```java\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        \\n        if (k == 0) {\\n            return nums;\\n        }\\n        \\n        // setup\\n        int[] answers = new int[nums.length];\\n        Arrays.fill(answers, -1);\\n        long[] prefixes = new long[nums.length];\\n        \\n        if (nums.length < k * 2 + 1) {\\n            return answers;\\n        }\\n        \\n        // create prefixes array\\n        prefixes[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixes[i] = nums[i] + prefixes[i-1];\\n        }\\n        \\n        for (int i = k; i < (prefixes.length - k); ++i) {\\n            long sum = prefixes[i+k] - (i - k > 0 ? prefixes[i-k-1] : 0);\\n            int avg = (int)sum / (2 * k + 1);\\n            answers[i] = avg;\\n        }\\n        \\n        return answers;\\n    }\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "kirillq",
                        "content": "Think about prefix sum, solution will comes after"
                    },
                    {
                        "username": "dancaps",
                        "content": "The description isn\\'t great. It would be better if they were less cryptic with the expected output."
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "last test is failing because of improper type conversion. while calculating average\\ninstead of doing \\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) sum/(2*k +1);\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\ndo this fix\\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) (sum/(2*k +1));\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\nonly difference is the braces this line\\nans[i-k] =(int) (sum/(2*k +1));"
                    },
                    {
                        "username": "Prajjal",
                        "content": "I have passed 39 test cases but still it shows TLE....\n"
                    }
                ]
            },
            {
                "id": 2043201,
                "content": [
                    {
                        "username": "lucistark",
                        "content": "failing one test-case can anyone help me in this \\n ```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=nums.length-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<nums.length;i++){\\n            if(i-k<0||i+k>=nums.length){\\n               continue;\\n            }\\n            else{\\n                int sum=(int)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n                sum=sum/(2*k+1);\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n} ```"
                    },
                    {
                        "username": "lucistark",
                        "content": "[@satyam47](/satyam47) thank you"
                    },
                    {
                        "username": "satyam47",
                        "content": "make prefix and sufix array of long data type\n```\nlong prefix[]=new long[nums.length];\nlong suffix[]=new long[nums.length];\n```\nand use long type for sum then store avg in int  \n```\nlong sum=(long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\nsum=sum/(2*k+1);\nans[i]=(int)sum;\n```"
                    },
                    {
                        "username": "guri_1",
                        "content": "Can some pls tell me why if i intialize val as below it fails on the final testcase\\nbut if i do it like this int val=(pre[i+k+1]-pre[i-k])/divi it passes?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         int n=nums.size();\\n          vector<long long >pre(n+1,0);\\n           vector<int>ans(n,-1);\\n           int divi=2*k+1;\\n           if(n<divi) return ans;\\n           \\n            for(int i=0;i<n;i++){\\n                 pre[i+1]=pre[i]+nums[i];\\n            }\\n           \\n           \\n             for(int i=k;i<n-k;i++){\\n               int val=(pre[i+k+1]-pre[i-k]);\\n               val=val/divi;\\n             \\n               ans[i]=val;\\n             }\\n             return ans;\\n    }\\n};"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "The final test case has large numbers which makes your prefix sum exceed integer limit. In your code, you are initializing val as integer and thus fails, where as passing the val after dividing prevents the same."
                    },
                    {
                        "username": "satyam47",
                        "content": "you should store prefix in long data type and also use val of long data type"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The repetitive silly mistake of signed Integer overflow makes me wanna move to Python\\uD83E\\uDD72"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Please let me make my June streak."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      vector<int> ans(n, -1);\\n\\n      if(n < 2*k+1)\\n        return ans;\\n\\n   long long  sum = 0;\\n    int i ,j , c;\\n    //creating window\\n    for( i = 0; i <= 2*k ; i++){\\n        sum += nums[i];\\n    }\\n    ans[k] = sum/(2*k + 1);\\n    for( i = 0 , j = 2*k + 1 ,c = k+1 ; j < n ; i++,j++,c++){\\n            sum = sum - nums[i] + nums[j];\\n             ans[c] = sum/(2*k + 1);\\n    }  \\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kristjan_vingel",
                        "content": "Can anyone help me - what am I doing wrong? It fails the last test case but I don\\'t understand why.\\n\\n```java\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        \\n        if (k == 0) {\\n            return nums;\\n        }\\n        \\n        // setup\\n        int[] answers = new int[nums.length];\\n        Arrays.fill(answers, -1);\\n        long[] prefixes = new long[nums.length];\\n        \\n        if (nums.length < k * 2 + 1) {\\n            return answers;\\n        }\\n        \\n        // create prefixes array\\n        prefixes[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixes[i] = nums[i] + prefixes[i-1];\\n        }\\n        \\n        for (int i = k; i < (prefixes.length - k); ++i) {\\n            long sum = prefixes[i+k] - (i - k > 0 ? prefixes[i-k-1] : 0);\\n            int avg = (int)sum / (2 * k + 1);\\n            answers[i] = avg;\\n        }\\n        \\n        return answers;\\n    }\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "kirillq",
                        "content": "Think about prefix sum, solution will comes after"
                    },
                    {
                        "username": "dancaps",
                        "content": "The description isn\\'t great. It would be better if they were less cryptic with the expected output."
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "last test is failing because of improper type conversion. while calculating average\\ninstead of doing \\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) sum/(2*k +1);\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\ndo this fix\\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) (sum/(2*k +1));\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\nonly difference is the braces this line\\nans[i-k] =(int) (sum/(2*k +1));"
                    },
                    {
                        "username": "Prajjal",
                        "content": "I have passed 39 test cases but still it shows TLE....\n"
                    }
                ]
            },
            {
                "id": 2033001,
                "content": [
                    {
                        "username": "lucistark",
                        "content": "failing one test-case can anyone help me in this \\n ```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=nums.length-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<nums.length;i++){\\n            if(i-k<0||i+k>=nums.length){\\n               continue;\\n            }\\n            else{\\n                int sum=(int)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n                sum=sum/(2*k+1);\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n} ```"
                    },
                    {
                        "username": "lucistark",
                        "content": "[@satyam47](/satyam47) thank you"
                    },
                    {
                        "username": "satyam47",
                        "content": "make prefix and sufix array of long data type\n```\nlong prefix[]=new long[nums.length];\nlong suffix[]=new long[nums.length];\n```\nand use long type for sum then store avg in int  \n```\nlong sum=(long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\nsum=sum/(2*k+1);\nans[i]=(int)sum;\n```"
                    },
                    {
                        "username": "guri_1",
                        "content": "Can some pls tell me why if i intialize val as below it fails on the final testcase\\nbut if i do it like this int val=(pre[i+k+1]-pre[i-k])/divi it passes?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         int n=nums.size();\\n          vector<long long >pre(n+1,0);\\n           vector<int>ans(n,-1);\\n           int divi=2*k+1;\\n           if(n<divi) return ans;\\n           \\n            for(int i=0;i<n;i++){\\n                 pre[i+1]=pre[i]+nums[i];\\n            }\\n           \\n           \\n             for(int i=k;i<n-k;i++){\\n               int val=(pre[i+k+1]-pre[i-k]);\\n               val=val/divi;\\n             \\n               ans[i]=val;\\n             }\\n             return ans;\\n    }\\n};"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "The final test case has large numbers which makes your prefix sum exceed integer limit. In your code, you are initializing val as integer and thus fails, where as passing the val after dividing prevents the same."
                    },
                    {
                        "username": "satyam47",
                        "content": "you should store prefix in long data type and also use val of long data type"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The repetitive silly mistake of signed Integer overflow makes me wanna move to Python\\uD83E\\uDD72"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Please let me make my June streak."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      vector<int> ans(n, -1);\\n\\n      if(n < 2*k+1)\\n        return ans;\\n\\n   long long  sum = 0;\\n    int i ,j , c;\\n    //creating window\\n    for( i = 0; i <= 2*k ; i++){\\n        sum += nums[i];\\n    }\\n    ans[k] = sum/(2*k + 1);\\n    for( i = 0 , j = 2*k + 1 ,c = k+1 ; j < n ; i++,j++,c++){\\n            sum = sum - nums[i] + nums[j];\\n             ans[c] = sum/(2*k + 1);\\n    }  \\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kristjan_vingel",
                        "content": "Can anyone help me - what am I doing wrong? It fails the last test case but I don\\'t understand why.\\n\\n```java\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        \\n        if (k == 0) {\\n            return nums;\\n        }\\n        \\n        // setup\\n        int[] answers = new int[nums.length];\\n        Arrays.fill(answers, -1);\\n        long[] prefixes = new long[nums.length];\\n        \\n        if (nums.length < k * 2 + 1) {\\n            return answers;\\n        }\\n        \\n        // create prefixes array\\n        prefixes[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixes[i] = nums[i] + prefixes[i-1];\\n        }\\n        \\n        for (int i = k; i < (prefixes.length - k); ++i) {\\n            long sum = prefixes[i+k] - (i - k > 0 ? prefixes[i-k-1] : 0);\\n            int avg = (int)sum / (2 * k + 1);\\n            answers[i] = avg;\\n        }\\n        \\n        return answers;\\n    }\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "kirillq",
                        "content": "Think about prefix sum, solution will comes after"
                    },
                    {
                        "username": "dancaps",
                        "content": "The description isn\\'t great. It would be better if they were less cryptic with the expected output."
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "last test is failing because of improper type conversion. while calculating average\\ninstead of doing \\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) sum/(2*k +1);\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\ndo this fix\\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) (sum/(2*k +1));\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\nonly difference is the braces this line\\nans[i-k] =(int) (sum/(2*k +1));"
                    },
                    {
                        "username": "Prajjal",
                        "content": "I have passed 39 test cases but still it shows TLE....\n"
                    }
                ]
            },
            {
                "id": 1975834,
                "content": [
                    {
                        "username": "lucistark",
                        "content": "failing one test-case can anyone help me in this \\n ```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=nums.length-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<nums.length;i++){\\n            if(i-k<0||i+k>=nums.length){\\n               continue;\\n            }\\n            else{\\n                int sum=(int)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n                sum=sum/(2*k+1);\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n} ```"
                    },
                    {
                        "username": "lucistark",
                        "content": "[@satyam47](/satyam47) thank you"
                    },
                    {
                        "username": "satyam47",
                        "content": "make prefix and sufix array of long data type\n```\nlong prefix[]=new long[nums.length];\nlong suffix[]=new long[nums.length];\n```\nand use long type for sum then store avg in int  \n```\nlong sum=(long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\nsum=sum/(2*k+1);\nans[i]=(int)sum;\n```"
                    },
                    {
                        "username": "guri_1",
                        "content": "Can some pls tell me why if i intialize val as below it fails on the final testcase\\nbut if i do it like this int val=(pre[i+k+1]-pre[i-k])/divi it passes?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         int n=nums.size();\\n          vector<long long >pre(n+1,0);\\n           vector<int>ans(n,-1);\\n           int divi=2*k+1;\\n           if(n<divi) return ans;\\n           \\n            for(int i=0;i<n;i++){\\n                 pre[i+1]=pre[i]+nums[i];\\n            }\\n           \\n           \\n             for(int i=k;i<n-k;i++){\\n               int val=(pre[i+k+1]-pre[i-k]);\\n               val=val/divi;\\n             \\n               ans[i]=val;\\n             }\\n             return ans;\\n    }\\n};"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "The final test case has large numbers which makes your prefix sum exceed integer limit. In your code, you are initializing val as integer and thus fails, where as passing the val after dividing prevents the same."
                    },
                    {
                        "username": "satyam47",
                        "content": "you should store prefix in long data type and also use val of long data type"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The repetitive silly mistake of signed Integer overflow makes me wanna move to Python\\uD83E\\uDD72"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Please let me make my June streak."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      vector<int> ans(n, -1);\\n\\n      if(n < 2*k+1)\\n        return ans;\\n\\n   long long  sum = 0;\\n    int i ,j , c;\\n    //creating window\\n    for( i = 0; i <= 2*k ; i++){\\n        sum += nums[i];\\n    }\\n    ans[k] = sum/(2*k + 1);\\n    for( i = 0 , j = 2*k + 1 ,c = k+1 ; j < n ; i++,j++,c++){\\n            sum = sum - nums[i] + nums[j];\\n             ans[c] = sum/(2*k + 1);\\n    }  \\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kristjan_vingel",
                        "content": "Can anyone help me - what am I doing wrong? It fails the last test case but I don\\'t understand why.\\n\\n```java\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        \\n        if (k == 0) {\\n            return nums;\\n        }\\n        \\n        // setup\\n        int[] answers = new int[nums.length];\\n        Arrays.fill(answers, -1);\\n        long[] prefixes = new long[nums.length];\\n        \\n        if (nums.length < k * 2 + 1) {\\n            return answers;\\n        }\\n        \\n        // create prefixes array\\n        prefixes[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixes[i] = nums[i] + prefixes[i-1];\\n        }\\n        \\n        for (int i = k; i < (prefixes.length - k); ++i) {\\n            long sum = prefixes[i+k] - (i - k > 0 ? prefixes[i-k-1] : 0);\\n            int avg = (int)sum / (2 * k + 1);\\n            answers[i] = avg;\\n        }\\n        \\n        return answers;\\n    }\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "kirillq",
                        "content": "Think about prefix sum, solution will comes after"
                    },
                    {
                        "username": "dancaps",
                        "content": "The description isn\\'t great. It would be better if they were less cryptic with the expected output."
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "last test is failing because of improper type conversion. while calculating average\\ninstead of doing \\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) sum/(2*k +1);\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\ndo this fix\\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) (sum/(2*k +1));\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\nonly difference is the braces this line\\nans[i-k] =(int) (sum/(2*k +1));"
                    },
                    {
                        "username": "Prajjal",
                        "content": "I have passed 39 test cases but still it shows TLE....\n"
                    }
                ]
            },
            {
                "id": 1975475,
                "content": [
                    {
                        "username": "lucistark",
                        "content": "failing one test-case can anyone help me in this \\n ```class Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        for(int i=1;i<nums.length;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        for(int i=nums.length-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        int ans[]=new int[nums.length];\\n        Arrays.fill(ans,-1);\\n        for(int i=0;i<nums.length;i++){\\n            if(i-k<0||i+k>=nums.length){\\n               continue;\\n            }\\n            else{\\n                int sum=(int)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\\n                sum=sum/(2*k+1);\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n} ```"
                    },
                    {
                        "username": "lucistark",
                        "content": "[@satyam47](/satyam47) thank you"
                    },
                    {
                        "username": "satyam47",
                        "content": "make prefix and sufix array of long data type\n```\nlong prefix[]=new long[nums.length];\nlong suffix[]=new long[nums.length];\n```\nand use long type for sum then store avg in int  \n```\nlong sum=(long)((suffix[i-k]-suffix[i])+(prefix[i+k]-prefix[i])+nums[i]);\nsum=sum/(2*k+1);\nans[i]=(int)sum;\n```"
                    },
                    {
                        "username": "guri_1",
                        "content": "Can some pls tell me why if i intialize val as below it fails on the final testcase\\nbut if i do it like this int val=(pre[i+k+1]-pre[i-k])/divi it passes?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n         int n=nums.size();\\n          vector<long long >pre(n+1,0);\\n           vector<int>ans(n,-1);\\n           int divi=2*k+1;\\n           if(n<divi) return ans;\\n           \\n            for(int i=0;i<n;i++){\\n                 pre[i+1]=pre[i]+nums[i];\\n            }\\n           \\n           \\n             for(int i=k;i<n-k;i++){\\n               int val=(pre[i+k+1]-pre[i-k]);\\n               val=val/divi;\\n             \\n               ans[i]=val;\\n             }\\n             return ans;\\n    }\\n};"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "The final test case has large numbers which makes your prefix sum exceed integer limit. In your code, you are initializing val as integer and thus fails, where as passing the val after dividing prevents the same."
                    },
                    {
                        "username": "satyam47",
                        "content": "you should store prefix in long data type and also use val of long data type"
                    },
                    {
                        "username": "arghyadas",
                        "content": "The repetitive silly mistake of signed Integer overflow makes me wanna move to Python\\uD83E\\uDD72"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Please let me make my June streak."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      vector<int> ans(n, -1);\\n\\n      if(n < 2*k+1)\\n        return ans;\\n\\n   long long  sum = 0;\\n    int i ,j , c;\\n    //creating window\\n    for( i = 0; i <= 2*k ; i++){\\n        sum += nums[i];\\n    }\\n    ans[k] = sum/(2*k + 1);\\n    for( i = 0 , j = 2*k + 1 ,c = k+1 ; j < n ; i++,j++,c++){\\n            sum = sum - nums[i] + nums[j];\\n             ans[c] = sum/(2*k + 1);\\n    }  \\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kristjan_vingel",
                        "content": "Can anyone help me - what am I doing wrong? It fails the last test case but I don\\'t understand why.\\n\\n```java\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        \\n        if (k == 0) {\\n            return nums;\\n        }\\n        \\n        // setup\\n        int[] answers = new int[nums.length];\\n        Arrays.fill(answers, -1);\\n        long[] prefixes = new long[nums.length];\\n        \\n        if (nums.length < k * 2 + 1) {\\n            return answers;\\n        }\\n        \\n        // create prefixes array\\n        prefixes[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixes[i] = nums[i] + prefixes[i-1];\\n        }\\n        \\n        for (int i = k; i < (prefixes.length - k); ++i) {\\n            long sum = prefixes[i+k] - (i - k > 0 ? prefixes[i-k-1] : 0);\\n            int avg = (int)sum / (2 * k + 1);\\n            answers[i] = avg;\\n        }\\n        \\n        return answers;\\n    }\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "kirillq",
                        "content": "Think about prefix sum, solution will comes after"
                    },
                    {
                        "username": "dancaps",
                        "content": "The description isn\\'t great. It would be better if they were less cryptic with the expected output."
                    },
                    {
                        "username": "pallavi1k1",
                        "content": "last test is failing because of improper type conversion. while calculating average\\ninstead of doing \\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) sum/(2*k +1);\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\ndo this fix\\nfor (int i =0 ; i < nums.length ;i++){\\n            sum+=(long)nums[i];\\n          if (i >= 2*k){\\n              ans[i-k] =(int) (sum/(2*k +1));\\n              sum-= (long)nums[i-2*k];\\n          }\\n\\n        }\\nonly difference is the braces this line\\nans[i-k] =(int) (sum/(2*k +1));"
                    },
                    {
                        "username": "Prajjal",
                        "content": "I have passed 39 test cases but still it shows TLE....\n"
                    }
                ]
            },
            {
                "id": 1949141,
                "content": [
                    {
                        "username": "sourabh03062002",
                        "content": "How is the average being calculated?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "long int (sum of elements) divided by int (number of elements) cast back into int."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Sum of elements divided by no of elements "
                    },
                    {
                        "username": "Ankushthalet26",
                        "content": "be sure use long data type for store sum and then convert into int before divided by count\\nlong sum=0;\\nint count=0;\\n\\navgs[i]=((int)sum/count);\\n"
                    },
                    {
                        "username": "zazac",
                        "content": "FINALMENTE"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "more or less a sliding window application"
                    },
                    {
                        "username": "rush0204",
                        "content": "Dont understand whats wrong with my code Can anyone help me\\n  `    long long ori = 0;\\n        int n = nums.size()-1;\\n        vector<int> ans;\\n        for(int i = 0;i<2*k+1;i++){\\n            ori = ori + nums[i];\\n            ans.push_back(-1);   }\\n      for(int i = 1; i<n-2*k+1;i++){\\n      ori = ori - nums[i-1] + nums[2*k+i];\\n    ans.push_back(ori/(2*k+1));\\n      }return ans;   }     `"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "checkOut my solution.\\n\\nhttps://leetcode.com/problems/k-radius-subarray-averages/submissions/975364294/\\n\\nPlease UpVote If you understand the logic."
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "27/39 test cases passed. \\nTime Limit Executed\\n\\nCan anyone correct my code and tell me where am I wrong???\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<int > avgs;\\nfor(int i =0; i<n; i++){\\n    if((i-k) <0 || (n-i)<=k) {\\n        avgs.push_back(-1);\\n    }\\n      else if ((n-i)>k){\\nlong  int sum=0;\\n          for(int j = i-k; j<=(i+k) && (i+k) <n; j++ ){\\n              sum += nums[j];\\n          }\\n       long int res = (2*k +1);\\n          int avg = sum/ res;\\n\\n          avgs.push_back(avg);\\n      }\\n}\\nreturn avgs;\\n            }\\n};\\n"
                    },
                    {
                        "username": "aditya_mad",
                        "content": "And also you are using nested loops. So during the last testcases you will get tle for sure. So this wont work you need to do it without nested loops. Taje a sliding window of size 2*k + 1 and then try to solve this. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "Give this a try \\n`int avg = (int)(sum/res);`\\nI had the similar problem. Like we are trying to fit long long number in int. So one time or the other you will get wrong ans. So typecast into int and then store in avg. "
                    },
                    {
                        "username": "who_rules",
                        "content": "you can avoid computing the sum every time from zero. Essentially, you have almost the same sum at every step, you just need to subtract element outside a new area and add a new one."
                    },
                    {
                        "username": "erezzz44",
                        "content": "what is the deal with testcase 23? theres so many elements and i keep getting a time limit exceeded. i dont think my time complexity is bad in general but this test case is making me rethink that. i am using python. my sum is a double. "
                    },
                    {
                        "username": "Challenger_Arun",
                        "content": "Really nice question....."
                    },
                    {
                        "username": "Abhishek_Code_Art",
                        "content": "Can anyone please tell me what is wrong in this code because only one testcase is failed I don\\'t know what is wrong in it \\nif anyone finds out please tell me \\n\\n `int n = nums.length;\\n        if(k == 0) return nums;\\n\\n        int[] avgs = new int[n];\\n        Arrays.fill(avgs, -1);\\n\\n        if(n < 2*k+1) return avgs;\\n\\n       int left = 0;\\n       int right = 2*k;\\n       int i = k;\\n\\n       int sum = 0;\\n       for(int j = left; j <= right; j++) {\\n           sum += nums[j];\\n       }\\n\\n       int count = 2*k+1;\\n       avgs[i++] = sum/count;\\n       right++;\\n\\n       while(right < n) {\\n           int elem_to_add = nums[right];\\n           int elem_to_delete = nums[left];\\n\\n           sum = sum + elem_to_add - elem_to_delete;\\n           avgs[i] = (int)sum/count;\\n           i++;\\n           left++;\\n           right++;\\n       }\\n       return avgs; `\\nThanks"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Large because the constraint are like each element of array can be from 1 to 10^5"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "The sum is very large actually to be stored in it maybe try long long or long int"
                    },
                    {
                        "username": "Piyush__Tiwari",
                        "content": "just another day , just another TLE ( average programmer life)"
                    }
                ]
            },
            {
                "id": 1940650,
                "content": [
                    {
                        "username": "sourabh03062002",
                        "content": "How is the average being calculated?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "long int (sum of elements) divided by int (number of elements) cast back into int."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Sum of elements divided by no of elements "
                    },
                    {
                        "username": "Ankushthalet26",
                        "content": "be sure use long data type for store sum and then convert into int before divided by count\\nlong sum=0;\\nint count=0;\\n\\navgs[i]=((int)sum/count);\\n"
                    },
                    {
                        "username": "zazac",
                        "content": "FINALMENTE"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "more or less a sliding window application"
                    },
                    {
                        "username": "rush0204",
                        "content": "Dont understand whats wrong with my code Can anyone help me\\n  `    long long ori = 0;\\n        int n = nums.size()-1;\\n        vector<int> ans;\\n        for(int i = 0;i<2*k+1;i++){\\n            ori = ori + nums[i];\\n            ans.push_back(-1);   }\\n      for(int i = 1; i<n-2*k+1;i++){\\n      ori = ori - nums[i-1] + nums[2*k+i];\\n    ans.push_back(ori/(2*k+1));\\n      }return ans;   }     `"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "checkOut my solution.\\n\\nhttps://leetcode.com/problems/k-radius-subarray-averages/submissions/975364294/\\n\\nPlease UpVote If you understand the logic."
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "27/39 test cases passed. \\nTime Limit Executed\\n\\nCan anyone correct my code and tell me where am I wrong???\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<int > avgs;\\nfor(int i =0; i<n; i++){\\n    if((i-k) <0 || (n-i)<=k) {\\n        avgs.push_back(-1);\\n    }\\n      else if ((n-i)>k){\\nlong  int sum=0;\\n          for(int j = i-k; j<=(i+k) && (i+k) <n; j++ ){\\n              sum += nums[j];\\n          }\\n       long int res = (2*k +1);\\n          int avg = sum/ res;\\n\\n          avgs.push_back(avg);\\n      }\\n}\\nreturn avgs;\\n            }\\n};\\n"
                    },
                    {
                        "username": "aditya_mad",
                        "content": "And also you are using nested loops. So during the last testcases you will get tle for sure. So this wont work you need to do it without nested loops. Taje a sliding window of size 2*k + 1 and then try to solve this. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "Give this a try \\n`int avg = (int)(sum/res);`\\nI had the similar problem. Like we are trying to fit long long number in int. So one time or the other you will get wrong ans. So typecast into int and then store in avg. "
                    },
                    {
                        "username": "who_rules",
                        "content": "you can avoid computing the sum every time from zero. Essentially, you have almost the same sum at every step, you just need to subtract element outside a new area and add a new one."
                    },
                    {
                        "username": "erezzz44",
                        "content": "what is the deal with testcase 23? theres so many elements and i keep getting a time limit exceeded. i dont think my time complexity is bad in general but this test case is making me rethink that. i am using python. my sum is a double. "
                    },
                    {
                        "username": "Challenger_Arun",
                        "content": "Really nice question....."
                    },
                    {
                        "username": "Abhishek_Code_Art",
                        "content": "Can anyone please tell me what is wrong in this code because only one testcase is failed I don\\'t know what is wrong in it \\nif anyone finds out please tell me \\n\\n `int n = nums.length;\\n        if(k == 0) return nums;\\n\\n        int[] avgs = new int[n];\\n        Arrays.fill(avgs, -1);\\n\\n        if(n < 2*k+1) return avgs;\\n\\n       int left = 0;\\n       int right = 2*k;\\n       int i = k;\\n\\n       int sum = 0;\\n       for(int j = left; j <= right; j++) {\\n           sum += nums[j];\\n       }\\n\\n       int count = 2*k+1;\\n       avgs[i++] = sum/count;\\n       right++;\\n\\n       while(right < n) {\\n           int elem_to_add = nums[right];\\n           int elem_to_delete = nums[left];\\n\\n           sum = sum + elem_to_add - elem_to_delete;\\n           avgs[i] = (int)sum/count;\\n           i++;\\n           left++;\\n           right++;\\n       }\\n       return avgs; `\\nThanks"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Large because the constraint are like each element of array can be from 1 to 10^5"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "The sum is very large actually to be stored in it maybe try long long or long int"
                    },
                    {
                        "username": "Piyush__Tiwari",
                        "content": "just another day , just another TLE ( average programmer life)"
                    }
                ]
            },
            {
                "id": 1938701,
                "content": [
                    {
                        "username": "sourabh03062002",
                        "content": "How is the average being calculated?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "long int (sum of elements) divided by int (number of elements) cast back into int."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Sum of elements divided by no of elements "
                    },
                    {
                        "username": "Ankushthalet26",
                        "content": "be sure use long data type for store sum and then convert into int before divided by count\\nlong sum=0;\\nint count=0;\\n\\navgs[i]=((int)sum/count);\\n"
                    },
                    {
                        "username": "zazac",
                        "content": "FINALMENTE"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "more or less a sliding window application"
                    },
                    {
                        "username": "rush0204",
                        "content": "Dont understand whats wrong with my code Can anyone help me\\n  `    long long ori = 0;\\n        int n = nums.size()-1;\\n        vector<int> ans;\\n        for(int i = 0;i<2*k+1;i++){\\n            ori = ori + nums[i];\\n            ans.push_back(-1);   }\\n      for(int i = 1; i<n-2*k+1;i++){\\n      ori = ori - nums[i-1] + nums[2*k+i];\\n    ans.push_back(ori/(2*k+1));\\n      }return ans;   }     `"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "checkOut my solution.\\n\\nhttps://leetcode.com/problems/k-radius-subarray-averages/submissions/975364294/\\n\\nPlease UpVote If you understand the logic."
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "27/39 test cases passed. \\nTime Limit Executed\\n\\nCan anyone correct my code and tell me where am I wrong???\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<int > avgs;\\nfor(int i =0; i<n; i++){\\n    if((i-k) <0 || (n-i)<=k) {\\n        avgs.push_back(-1);\\n    }\\n      else if ((n-i)>k){\\nlong  int sum=0;\\n          for(int j = i-k; j<=(i+k) && (i+k) <n; j++ ){\\n              sum += nums[j];\\n          }\\n       long int res = (2*k +1);\\n          int avg = sum/ res;\\n\\n          avgs.push_back(avg);\\n      }\\n}\\nreturn avgs;\\n            }\\n};\\n"
                    },
                    {
                        "username": "aditya_mad",
                        "content": "And also you are using nested loops. So during the last testcases you will get tle for sure. So this wont work you need to do it without nested loops. Taje a sliding window of size 2*k + 1 and then try to solve this. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "Give this a try \\n`int avg = (int)(sum/res);`\\nI had the similar problem. Like we are trying to fit long long number in int. So one time or the other you will get wrong ans. So typecast into int and then store in avg. "
                    },
                    {
                        "username": "who_rules",
                        "content": "you can avoid computing the sum every time from zero. Essentially, you have almost the same sum at every step, you just need to subtract element outside a new area and add a new one."
                    },
                    {
                        "username": "erezzz44",
                        "content": "what is the deal with testcase 23? theres so many elements and i keep getting a time limit exceeded. i dont think my time complexity is bad in general but this test case is making me rethink that. i am using python. my sum is a double. "
                    },
                    {
                        "username": "Challenger_Arun",
                        "content": "Really nice question....."
                    },
                    {
                        "username": "Abhishek_Code_Art",
                        "content": "Can anyone please tell me what is wrong in this code because only one testcase is failed I don\\'t know what is wrong in it \\nif anyone finds out please tell me \\n\\n `int n = nums.length;\\n        if(k == 0) return nums;\\n\\n        int[] avgs = new int[n];\\n        Arrays.fill(avgs, -1);\\n\\n        if(n < 2*k+1) return avgs;\\n\\n       int left = 0;\\n       int right = 2*k;\\n       int i = k;\\n\\n       int sum = 0;\\n       for(int j = left; j <= right; j++) {\\n           sum += nums[j];\\n       }\\n\\n       int count = 2*k+1;\\n       avgs[i++] = sum/count;\\n       right++;\\n\\n       while(right < n) {\\n           int elem_to_add = nums[right];\\n           int elem_to_delete = nums[left];\\n\\n           sum = sum + elem_to_add - elem_to_delete;\\n           avgs[i] = (int)sum/count;\\n           i++;\\n           left++;\\n           right++;\\n       }\\n       return avgs; `\\nThanks"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Large because the constraint are like each element of array can be from 1 to 10^5"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "The sum is very large actually to be stored in it maybe try long long or long int"
                    },
                    {
                        "username": "Piyush__Tiwari",
                        "content": "just another day , just another TLE ( average programmer life)"
                    }
                ]
            },
            {
                "id": 1938462,
                "content": [
                    {
                        "username": "sourabh03062002",
                        "content": "How is the average being calculated?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "long int (sum of elements) divided by int (number of elements) cast back into int."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Sum of elements divided by no of elements "
                    },
                    {
                        "username": "Ankushthalet26",
                        "content": "be sure use long data type for store sum and then convert into int before divided by count\\nlong sum=0;\\nint count=0;\\n\\navgs[i]=((int)sum/count);\\n"
                    },
                    {
                        "username": "zazac",
                        "content": "FINALMENTE"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "more or less a sliding window application"
                    },
                    {
                        "username": "rush0204",
                        "content": "Dont understand whats wrong with my code Can anyone help me\\n  `    long long ori = 0;\\n        int n = nums.size()-1;\\n        vector<int> ans;\\n        for(int i = 0;i<2*k+1;i++){\\n            ori = ori + nums[i];\\n            ans.push_back(-1);   }\\n      for(int i = 1; i<n-2*k+1;i++){\\n      ori = ori - nums[i-1] + nums[2*k+i];\\n    ans.push_back(ori/(2*k+1));\\n      }return ans;   }     `"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "checkOut my solution.\\n\\nhttps://leetcode.com/problems/k-radius-subarray-averages/submissions/975364294/\\n\\nPlease UpVote If you understand the logic."
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "27/39 test cases passed. \\nTime Limit Executed\\n\\nCan anyone correct my code and tell me where am I wrong???\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<int > avgs;\\nfor(int i =0; i<n; i++){\\n    if((i-k) <0 || (n-i)<=k) {\\n        avgs.push_back(-1);\\n    }\\n      else if ((n-i)>k){\\nlong  int sum=0;\\n          for(int j = i-k; j<=(i+k) && (i+k) <n; j++ ){\\n              sum += nums[j];\\n          }\\n       long int res = (2*k +1);\\n          int avg = sum/ res;\\n\\n          avgs.push_back(avg);\\n      }\\n}\\nreturn avgs;\\n            }\\n};\\n"
                    },
                    {
                        "username": "aditya_mad",
                        "content": "And also you are using nested loops. So during the last testcases you will get tle for sure. So this wont work you need to do it without nested loops. Taje a sliding window of size 2*k + 1 and then try to solve this. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "Give this a try \\n`int avg = (int)(sum/res);`\\nI had the similar problem. Like we are trying to fit long long number in int. So one time or the other you will get wrong ans. So typecast into int and then store in avg. "
                    },
                    {
                        "username": "who_rules",
                        "content": "you can avoid computing the sum every time from zero. Essentially, you have almost the same sum at every step, you just need to subtract element outside a new area and add a new one."
                    },
                    {
                        "username": "erezzz44",
                        "content": "what is the deal with testcase 23? theres so many elements and i keep getting a time limit exceeded. i dont think my time complexity is bad in general but this test case is making me rethink that. i am using python. my sum is a double. "
                    },
                    {
                        "username": "Challenger_Arun",
                        "content": "Really nice question....."
                    },
                    {
                        "username": "Abhishek_Code_Art",
                        "content": "Can anyone please tell me what is wrong in this code because only one testcase is failed I don\\'t know what is wrong in it \\nif anyone finds out please tell me \\n\\n `int n = nums.length;\\n        if(k == 0) return nums;\\n\\n        int[] avgs = new int[n];\\n        Arrays.fill(avgs, -1);\\n\\n        if(n < 2*k+1) return avgs;\\n\\n       int left = 0;\\n       int right = 2*k;\\n       int i = k;\\n\\n       int sum = 0;\\n       for(int j = left; j <= right; j++) {\\n           sum += nums[j];\\n       }\\n\\n       int count = 2*k+1;\\n       avgs[i++] = sum/count;\\n       right++;\\n\\n       while(right < n) {\\n           int elem_to_add = nums[right];\\n           int elem_to_delete = nums[left];\\n\\n           sum = sum + elem_to_add - elem_to_delete;\\n           avgs[i] = (int)sum/count;\\n           i++;\\n           left++;\\n           right++;\\n       }\\n       return avgs; `\\nThanks"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Large because the constraint are like each element of array can be from 1 to 10^5"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "The sum is very large actually to be stored in it maybe try long long or long int"
                    },
                    {
                        "username": "Piyush__Tiwari",
                        "content": "just another day , just another TLE ( average programmer life)"
                    }
                ]
            },
            {
                "id": 1938143,
                "content": [
                    {
                        "username": "sourabh03062002",
                        "content": "How is the average being calculated?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "long int (sum of elements) divided by int (number of elements) cast back into int."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Sum of elements divided by no of elements "
                    },
                    {
                        "username": "Ankushthalet26",
                        "content": "be sure use long data type for store sum and then convert into int before divided by count\\nlong sum=0;\\nint count=0;\\n\\navgs[i]=((int)sum/count);\\n"
                    },
                    {
                        "username": "zazac",
                        "content": "FINALMENTE"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "more or less a sliding window application"
                    },
                    {
                        "username": "rush0204",
                        "content": "Dont understand whats wrong with my code Can anyone help me\\n  `    long long ori = 0;\\n        int n = nums.size()-1;\\n        vector<int> ans;\\n        for(int i = 0;i<2*k+1;i++){\\n            ori = ori + nums[i];\\n            ans.push_back(-1);   }\\n      for(int i = 1; i<n-2*k+1;i++){\\n      ori = ori - nums[i-1] + nums[2*k+i];\\n    ans.push_back(ori/(2*k+1));\\n      }return ans;   }     `"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "checkOut my solution.\\n\\nhttps://leetcode.com/problems/k-radius-subarray-averages/submissions/975364294/\\n\\nPlease UpVote If you understand the logic."
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "27/39 test cases passed. \\nTime Limit Executed\\n\\nCan anyone correct my code and tell me where am I wrong???\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<int > avgs;\\nfor(int i =0; i<n; i++){\\n    if((i-k) <0 || (n-i)<=k) {\\n        avgs.push_back(-1);\\n    }\\n      else if ((n-i)>k){\\nlong  int sum=0;\\n          for(int j = i-k; j<=(i+k) && (i+k) <n; j++ ){\\n              sum += nums[j];\\n          }\\n       long int res = (2*k +1);\\n          int avg = sum/ res;\\n\\n          avgs.push_back(avg);\\n      }\\n}\\nreturn avgs;\\n            }\\n};\\n"
                    },
                    {
                        "username": "aditya_mad",
                        "content": "And also you are using nested loops. So during the last testcases you will get tle for sure. So this wont work you need to do it without nested loops. Taje a sliding window of size 2*k + 1 and then try to solve this. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "Give this a try \\n`int avg = (int)(sum/res);`\\nI had the similar problem. Like we are trying to fit long long number in int. So one time or the other you will get wrong ans. So typecast into int and then store in avg. "
                    },
                    {
                        "username": "who_rules",
                        "content": "you can avoid computing the sum every time from zero. Essentially, you have almost the same sum at every step, you just need to subtract element outside a new area and add a new one."
                    },
                    {
                        "username": "erezzz44",
                        "content": "what is the deal with testcase 23? theres so many elements and i keep getting a time limit exceeded. i dont think my time complexity is bad in general but this test case is making me rethink that. i am using python. my sum is a double. "
                    },
                    {
                        "username": "Challenger_Arun",
                        "content": "Really nice question....."
                    },
                    {
                        "username": "Abhishek_Code_Art",
                        "content": "Can anyone please tell me what is wrong in this code because only one testcase is failed I don\\'t know what is wrong in it \\nif anyone finds out please tell me \\n\\n `int n = nums.length;\\n        if(k == 0) return nums;\\n\\n        int[] avgs = new int[n];\\n        Arrays.fill(avgs, -1);\\n\\n        if(n < 2*k+1) return avgs;\\n\\n       int left = 0;\\n       int right = 2*k;\\n       int i = k;\\n\\n       int sum = 0;\\n       for(int j = left; j <= right; j++) {\\n           sum += nums[j];\\n       }\\n\\n       int count = 2*k+1;\\n       avgs[i++] = sum/count;\\n       right++;\\n\\n       while(right < n) {\\n           int elem_to_add = nums[right];\\n           int elem_to_delete = nums[left];\\n\\n           sum = sum + elem_to_add - elem_to_delete;\\n           avgs[i] = (int)sum/count;\\n           i++;\\n           left++;\\n           right++;\\n       }\\n       return avgs; `\\nThanks"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Large because the constraint are like each element of array can be from 1 to 10^5"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "The sum is very large actually to be stored in it maybe try long long or long int"
                    },
                    {
                        "username": "Piyush__Tiwari",
                        "content": "just another day , just another TLE ( average programmer life)"
                    }
                ]
            },
            {
                "id": 1937792,
                "content": [
                    {
                        "username": "sourabh03062002",
                        "content": "How is the average being calculated?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "long int (sum of elements) divided by int (number of elements) cast back into int."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Sum of elements divided by no of elements "
                    },
                    {
                        "username": "Ankushthalet26",
                        "content": "be sure use long data type for store sum and then convert into int before divided by count\\nlong sum=0;\\nint count=0;\\n\\navgs[i]=((int)sum/count);\\n"
                    },
                    {
                        "username": "zazac",
                        "content": "FINALMENTE"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "more or less a sliding window application"
                    },
                    {
                        "username": "rush0204",
                        "content": "Dont understand whats wrong with my code Can anyone help me\\n  `    long long ori = 0;\\n        int n = nums.size()-1;\\n        vector<int> ans;\\n        for(int i = 0;i<2*k+1;i++){\\n            ori = ori + nums[i];\\n            ans.push_back(-1);   }\\n      for(int i = 1; i<n-2*k+1;i++){\\n      ori = ori - nums[i-1] + nums[2*k+i];\\n    ans.push_back(ori/(2*k+1));\\n      }return ans;   }     `"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "checkOut my solution.\\n\\nhttps://leetcode.com/problems/k-radius-subarray-averages/submissions/975364294/\\n\\nPlease UpVote If you understand the logic."
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "27/39 test cases passed. \\nTime Limit Executed\\n\\nCan anyone correct my code and tell me where am I wrong???\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<int > avgs;\\nfor(int i =0; i<n; i++){\\n    if((i-k) <0 || (n-i)<=k) {\\n        avgs.push_back(-1);\\n    }\\n      else if ((n-i)>k){\\nlong  int sum=0;\\n          for(int j = i-k; j<=(i+k) && (i+k) <n; j++ ){\\n              sum += nums[j];\\n          }\\n       long int res = (2*k +1);\\n          int avg = sum/ res;\\n\\n          avgs.push_back(avg);\\n      }\\n}\\nreturn avgs;\\n            }\\n};\\n"
                    },
                    {
                        "username": "aditya_mad",
                        "content": "And also you are using nested loops. So during the last testcases you will get tle for sure. So this wont work you need to do it without nested loops. Taje a sliding window of size 2*k + 1 and then try to solve this. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "Give this a try \\n`int avg = (int)(sum/res);`\\nI had the similar problem. Like we are trying to fit long long number in int. So one time or the other you will get wrong ans. So typecast into int and then store in avg. "
                    },
                    {
                        "username": "who_rules",
                        "content": "you can avoid computing the sum every time from zero. Essentially, you have almost the same sum at every step, you just need to subtract element outside a new area and add a new one."
                    },
                    {
                        "username": "erezzz44",
                        "content": "what is the deal with testcase 23? theres so many elements and i keep getting a time limit exceeded. i dont think my time complexity is bad in general but this test case is making me rethink that. i am using python. my sum is a double. "
                    },
                    {
                        "username": "Challenger_Arun",
                        "content": "Really nice question....."
                    },
                    {
                        "username": "Abhishek_Code_Art",
                        "content": "Can anyone please tell me what is wrong in this code because only one testcase is failed I don\\'t know what is wrong in it \\nif anyone finds out please tell me \\n\\n `int n = nums.length;\\n        if(k == 0) return nums;\\n\\n        int[] avgs = new int[n];\\n        Arrays.fill(avgs, -1);\\n\\n        if(n < 2*k+1) return avgs;\\n\\n       int left = 0;\\n       int right = 2*k;\\n       int i = k;\\n\\n       int sum = 0;\\n       for(int j = left; j <= right; j++) {\\n           sum += nums[j];\\n       }\\n\\n       int count = 2*k+1;\\n       avgs[i++] = sum/count;\\n       right++;\\n\\n       while(right < n) {\\n           int elem_to_add = nums[right];\\n           int elem_to_delete = nums[left];\\n\\n           sum = sum + elem_to_add - elem_to_delete;\\n           avgs[i] = (int)sum/count;\\n           i++;\\n           left++;\\n           right++;\\n       }\\n       return avgs; `\\nThanks"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Large because the constraint are like each element of array can be from 1 to 10^5"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "The sum is very large actually to be stored in it maybe try long long or long int"
                    },
                    {
                        "username": "Piyush__Tiwari",
                        "content": "just another day , just another TLE ( average programmer life)"
                    }
                ]
            },
            {
                "id": 1937693,
                "content": [
                    {
                        "username": "sourabh03062002",
                        "content": "How is the average being calculated?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "long int (sum of elements) divided by int (number of elements) cast back into int."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Sum of elements divided by no of elements "
                    },
                    {
                        "username": "Ankushthalet26",
                        "content": "be sure use long data type for store sum and then convert into int before divided by count\\nlong sum=0;\\nint count=0;\\n\\navgs[i]=((int)sum/count);\\n"
                    },
                    {
                        "username": "zazac",
                        "content": "FINALMENTE"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "more or less a sliding window application"
                    },
                    {
                        "username": "rush0204",
                        "content": "Dont understand whats wrong with my code Can anyone help me\\n  `    long long ori = 0;\\n        int n = nums.size()-1;\\n        vector<int> ans;\\n        for(int i = 0;i<2*k+1;i++){\\n            ori = ori + nums[i];\\n            ans.push_back(-1);   }\\n      for(int i = 1; i<n-2*k+1;i++){\\n      ori = ori - nums[i-1] + nums[2*k+i];\\n    ans.push_back(ori/(2*k+1));\\n      }return ans;   }     `"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "checkOut my solution.\\n\\nhttps://leetcode.com/problems/k-radius-subarray-averages/submissions/975364294/\\n\\nPlease UpVote If you understand the logic."
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "27/39 test cases passed. \\nTime Limit Executed\\n\\nCan anyone correct my code and tell me where am I wrong???\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<int > avgs;\\nfor(int i =0; i<n; i++){\\n    if((i-k) <0 || (n-i)<=k) {\\n        avgs.push_back(-1);\\n    }\\n      else if ((n-i)>k){\\nlong  int sum=0;\\n          for(int j = i-k; j<=(i+k) && (i+k) <n; j++ ){\\n              sum += nums[j];\\n          }\\n       long int res = (2*k +1);\\n          int avg = sum/ res;\\n\\n          avgs.push_back(avg);\\n      }\\n}\\nreturn avgs;\\n            }\\n};\\n"
                    },
                    {
                        "username": "aditya_mad",
                        "content": "And also you are using nested loops. So during the last testcases you will get tle for sure. So this wont work you need to do it without nested loops. Taje a sliding window of size 2*k + 1 and then try to solve this. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "Give this a try \\n`int avg = (int)(sum/res);`\\nI had the similar problem. Like we are trying to fit long long number in int. So one time or the other you will get wrong ans. So typecast into int and then store in avg. "
                    },
                    {
                        "username": "who_rules",
                        "content": "you can avoid computing the sum every time from zero. Essentially, you have almost the same sum at every step, you just need to subtract element outside a new area and add a new one."
                    },
                    {
                        "username": "erezzz44",
                        "content": "what is the deal with testcase 23? theres so many elements and i keep getting a time limit exceeded. i dont think my time complexity is bad in general but this test case is making me rethink that. i am using python. my sum is a double. "
                    },
                    {
                        "username": "Challenger_Arun",
                        "content": "Really nice question....."
                    },
                    {
                        "username": "Abhishek_Code_Art",
                        "content": "Can anyone please tell me what is wrong in this code because only one testcase is failed I don\\'t know what is wrong in it \\nif anyone finds out please tell me \\n\\n `int n = nums.length;\\n        if(k == 0) return nums;\\n\\n        int[] avgs = new int[n];\\n        Arrays.fill(avgs, -1);\\n\\n        if(n < 2*k+1) return avgs;\\n\\n       int left = 0;\\n       int right = 2*k;\\n       int i = k;\\n\\n       int sum = 0;\\n       for(int j = left; j <= right; j++) {\\n           sum += nums[j];\\n       }\\n\\n       int count = 2*k+1;\\n       avgs[i++] = sum/count;\\n       right++;\\n\\n       while(right < n) {\\n           int elem_to_add = nums[right];\\n           int elem_to_delete = nums[left];\\n\\n           sum = sum + elem_to_add - elem_to_delete;\\n           avgs[i] = (int)sum/count;\\n           i++;\\n           left++;\\n           right++;\\n       }\\n       return avgs; `\\nThanks"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Large because the constraint are like each element of array can be from 1 to 10^5"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "The sum is very large actually to be stored in it maybe try long long or long int"
                    },
                    {
                        "username": "Piyush__Tiwari",
                        "content": "just another day , just another TLE ( average programmer life)"
                    }
                ]
            },
            {
                "id": 1937656,
                "content": [
                    {
                        "username": "sourabh03062002",
                        "content": "How is the average being calculated?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "long int (sum of elements) divided by int (number of elements) cast back into int."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Sum of elements divided by no of elements "
                    },
                    {
                        "username": "Ankushthalet26",
                        "content": "be sure use long data type for store sum and then convert into int before divided by count\\nlong sum=0;\\nint count=0;\\n\\navgs[i]=((int)sum/count);\\n"
                    },
                    {
                        "username": "zazac",
                        "content": "FINALMENTE"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "more or less a sliding window application"
                    },
                    {
                        "username": "rush0204",
                        "content": "Dont understand whats wrong with my code Can anyone help me\\n  `    long long ori = 0;\\n        int n = nums.size()-1;\\n        vector<int> ans;\\n        for(int i = 0;i<2*k+1;i++){\\n            ori = ori + nums[i];\\n            ans.push_back(-1);   }\\n      for(int i = 1; i<n-2*k+1;i++){\\n      ori = ori - nums[i-1] + nums[2*k+i];\\n    ans.push_back(ori/(2*k+1));\\n      }return ans;   }     `"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "checkOut my solution.\\n\\nhttps://leetcode.com/problems/k-radius-subarray-averages/submissions/975364294/\\n\\nPlease UpVote If you understand the logic."
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "27/39 test cases passed. \\nTime Limit Executed\\n\\nCan anyone correct my code and tell me where am I wrong???\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<int > avgs;\\nfor(int i =0; i<n; i++){\\n    if((i-k) <0 || (n-i)<=k) {\\n        avgs.push_back(-1);\\n    }\\n      else if ((n-i)>k){\\nlong  int sum=0;\\n          for(int j = i-k; j<=(i+k) && (i+k) <n; j++ ){\\n              sum += nums[j];\\n          }\\n       long int res = (2*k +1);\\n          int avg = sum/ res;\\n\\n          avgs.push_back(avg);\\n      }\\n}\\nreturn avgs;\\n            }\\n};\\n"
                    },
                    {
                        "username": "aditya_mad",
                        "content": "And also you are using nested loops. So during the last testcases you will get tle for sure. So this wont work you need to do it without nested loops. Taje a sliding window of size 2*k + 1 and then try to solve this. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "Give this a try \\n`int avg = (int)(sum/res);`\\nI had the similar problem. Like we are trying to fit long long number in int. So one time or the other you will get wrong ans. So typecast into int and then store in avg. "
                    },
                    {
                        "username": "who_rules",
                        "content": "you can avoid computing the sum every time from zero. Essentially, you have almost the same sum at every step, you just need to subtract element outside a new area and add a new one."
                    },
                    {
                        "username": "erezzz44",
                        "content": "what is the deal with testcase 23? theres so many elements and i keep getting a time limit exceeded. i dont think my time complexity is bad in general but this test case is making me rethink that. i am using python. my sum is a double. "
                    },
                    {
                        "username": "Challenger_Arun",
                        "content": "Really nice question....."
                    },
                    {
                        "username": "Abhishek_Code_Art",
                        "content": "Can anyone please tell me what is wrong in this code because only one testcase is failed I don\\'t know what is wrong in it \\nif anyone finds out please tell me \\n\\n `int n = nums.length;\\n        if(k == 0) return nums;\\n\\n        int[] avgs = new int[n];\\n        Arrays.fill(avgs, -1);\\n\\n        if(n < 2*k+1) return avgs;\\n\\n       int left = 0;\\n       int right = 2*k;\\n       int i = k;\\n\\n       int sum = 0;\\n       for(int j = left; j <= right; j++) {\\n           sum += nums[j];\\n       }\\n\\n       int count = 2*k+1;\\n       avgs[i++] = sum/count;\\n       right++;\\n\\n       while(right < n) {\\n           int elem_to_add = nums[right];\\n           int elem_to_delete = nums[left];\\n\\n           sum = sum + elem_to_add - elem_to_delete;\\n           avgs[i] = (int)sum/count;\\n           i++;\\n           left++;\\n           right++;\\n       }\\n       return avgs; `\\nThanks"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Large because the constraint are like each element of array can be from 1 to 10^5"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "The sum is very large actually to be stored in it maybe try long long or long int"
                    },
                    {
                        "username": "Piyush__Tiwari",
                        "content": "just another day , just another TLE ( average programmer life)"
                    }
                ]
            },
            {
                "id": 1937558,
                "content": [
                    {
                        "username": "sourabh03062002",
                        "content": "How is the average being calculated?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "long int (sum of elements) divided by int (number of elements) cast back into int."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Sum of elements divided by no of elements "
                    },
                    {
                        "username": "Ankushthalet26",
                        "content": "be sure use long data type for store sum and then convert into int before divided by count\\nlong sum=0;\\nint count=0;\\n\\navgs[i]=((int)sum/count);\\n"
                    },
                    {
                        "username": "zazac",
                        "content": "FINALMENTE"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "more or less a sliding window application"
                    },
                    {
                        "username": "rush0204",
                        "content": "Dont understand whats wrong with my code Can anyone help me\\n  `    long long ori = 0;\\n        int n = nums.size()-1;\\n        vector<int> ans;\\n        for(int i = 0;i<2*k+1;i++){\\n            ori = ori + nums[i];\\n            ans.push_back(-1);   }\\n      for(int i = 1; i<n-2*k+1;i++){\\n      ori = ori - nums[i-1] + nums[2*k+i];\\n    ans.push_back(ori/(2*k+1));\\n      }return ans;   }     `"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "checkOut my solution.\\n\\nhttps://leetcode.com/problems/k-radius-subarray-averages/submissions/975364294/\\n\\nPlease UpVote If you understand the logic."
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "27/39 test cases passed. \\nTime Limit Executed\\n\\nCan anyone correct my code and tell me where am I wrong???\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<int > avgs;\\nfor(int i =0; i<n; i++){\\n    if((i-k) <0 || (n-i)<=k) {\\n        avgs.push_back(-1);\\n    }\\n      else if ((n-i)>k){\\nlong  int sum=0;\\n          for(int j = i-k; j<=(i+k) && (i+k) <n; j++ ){\\n              sum += nums[j];\\n          }\\n       long int res = (2*k +1);\\n          int avg = sum/ res;\\n\\n          avgs.push_back(avg);\\n      }\\n}\\nreturn avgs;\\n            }\\n};\\n"
                    },
                    {
                        "username": "aditya_mad",
                        "content": "And also you are using nested loops. So during the last testcases you will get tle for sure. So this wont work you need to do it without nested loops. Taje a sliding window of size 2*k + 1 and then try to solve this. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "Give this a try \\n`int avg = (int)(sum/res);`\\nI had the similar problem. Like we are trying to fit long long number in int. So one time or the other you will get wrong ans. So typecast into int and then store in avg. "
                    },
                    {
                        "username": "who_rules",
                        "content": "you can avoid computing the sum every time from zero. Essentially, you have almost the same sum at every step, you just need to subtract element outside a new area and add a new one."
                    },
                    {
                        "username": "erezzz44",
                        "content": "what is the deal with testcase 23? theres so many elements and i keep getting a time limit exceeded. i dont think my time complexity is bad in general but this test case is making me rethink that. i am using python. my sum is a double. "
                    },
                    {
                        "username": "Challenger_Arun",
                        "content": "Really nice question....."
                    },
                    {
                        "username": "Abhishek_Code_Art",
                        "content": "Can anyone please tell me what is wrong in this code because only one testcase is failed I don\\'t know what is wrong in it \\nif anyone finds out please tell me \\n\\n `int n = nums.length;\\n        if(k == 0) return nums;\\n\\n        int[] avgs = new int[n];\\n        Arrays.fill(avgs, -1);\\n\\n        if(n < 2*k+1) return avgs;\\n\\n       int left = 0;\\n       int right = 2*k;\\n       int i = k;\\n\\n       int sum = 0;\\n       for(int j = left; j <= right; j++) {\\n           sum += nums[j];\\n       }\\n\\n       int count = 2*k+1;\\n       avgs[i++] = sum/count;\\n       right++;\\n\\n       while(right < n) {\\n           int elem_to_add = nums[right];\\n           int elem_to_delete = nums[left];\\n\\n           sum = sum + elem_to_add - elem_to_delete;\\n           avgs[i] = (int)sum/count;\\n           i++;\\n           left++;\\n           right++;\\n       }\\n       return avgs; `\\nThanks"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Large because the constraint are like each element of array can be from 1 to 10^5"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "The sum is very large actually to be stored in it maybe try long long or long int"
                    },
                    {
                        "username": "Piyush__Tiwari",
                        "content": "just another day , just another TLE ( average programmer life)"
                    }
                ]
            },
            {
                "id": 1937498,
                "content": [
                    {
                        "username": "sourabh03062002",
                        "content": "How is the average being calculated?\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "long int (sum of elements) divided by int (number of elements) cast back into int."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Sum of elements divided by no of elements "
                    },
                    {
                        "username": "Ankushthalet26",
                        "content": "be sure use long data type for store sum and then convert into int before divided by count\\nlong sum=0;\\nint count=0;\\n\\navgs[i]=((int)sum/count);\\n"
                    },
                    {
                        "username": "zazac",
                        "content": "FINALMENTE"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "more or less a sliding window application"
                    },
                    {
                        "username": "rush0204",
                        "content": "Dont understand whats wrong with my code Can anyone help me\\n  `    long long ori = 0;\\n        int n = nums.size()-1;\\n        vector<int> ans;\\n        for(int i = 0;i<2*k+1;i++){\\n            ori = ori + nums[i];\\n            ans.push_back(-1);   }\\n      for(int i = 1; i<n-2*k+1;i++){\\n      ori = ori - nums[i-1] + nums[2*k+i];\\n    ans.push_back(ori/(2*k+1));\\n      }return ans;   }     `"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "checkOut my solution.\\n\\nhttps://leetcode.com/problems/k-radius-subarray-averages/submissions/975364294/\\n\\nPlease UpVote If you understand the logic."
                    },
                    {
                        "username": "nainikatrivedi05",
                        "content": "27/39 test cases passed. \\nTime Limit Executed\\n\\nCan anyone correct my code and tell me where am I wrong???\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        vector<int > avgs;\\nfor(int i =0; i<n; i++){\\n    if((i-k) <0 || (n-i)<=k) {\\n        avgs.push_back(-1);\\n    }\\n      else if ((n-i)>k){\\nlong  int sum=0;\\n          for(int j = i-k; j<=(i+k) && (i+k) <n; j++ ){\\n              sum += nums[j];\\n          }\\n       long int res = (2*k +1);\\n          int avg = sum/ res;\\n\\n          avgs.push_back(avg);\\n      }\\n}\\nreturn avgs;\\n            }\\n};\\n"
                    },
                    {
                        "username": "aditya_mad",
                        "content": "And also you are using nested loops. So during the last testcases you will get tle for sure. So this wont work you need to do it without nested loops. Taje a sliding window of size 2*k + 1 and then try to solve this. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "Give this a try \\n`int avg = (int)(sum/res);`\\nI had the similar problem. Like we are trying to fit long long number in int. So one time or the other you will get wrong ans. So typecast into int and then store in avg. "
                    },
                    {
                        "username": "who_rules",
                        "content": "you can avoid computing the sum every time from zero. Essentially, you have almost the same sum at every step, you just need to subtract element outside a new area and add a new one."
                    },
                    {
                        "username": "erezzz44",
                        "content": "what is the deal with testcase 23? theres so many elements and i keep getting a time limit exceeded. i dont think my time complexity is bad in general but this test case is making me rethink that. i am using python. my sum is a double. "
                    },
                    {
                        "username": "Challenger_Arun",
                        "content": "Really nice question....."
                    },
                    {
                        "username": "Abhishek_Code_Art",
                        "content": "Can anyone please tell me what is wrong in this code because only one testcase is failed I don\\'t know what is wrong in it \\nif anyone finds out please tell me \\n\\n `int n = nums.length;\\n        if(k == 0) return nums;\\n\\n        int[] avgs = new int[n];\\n        Arrays.fill(avgs, -1);\\n\\n        if(n < 2*k+1) return avgs;\\n\\n       int left = 0;\\n       int right = 2*k;\\n       int i = k;\\n\\n       int sum = 0;\\n       for(int j = left; j <= right; j++) {\\n           sum += nums[j];\\n       }\\n\\n       int count = 2*k+1;\\n       avgs[i++] = sum/count;\\n       right++;\\n\\n       while(right < n) {\\n           int elem_to_add = nums[right];\\n           int elem_to_delete = nums[left];\\n\\n           sum = sum + elem_to_add - elem_to_delete;\\n           avgs[i] = (int)sum/count;\\n           i++;\\n           left++;\\n           right++;\\n       }\\n       return avgs; `\\nThanks"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Large because the constraint are like each element of array can be from 1 to 10^5"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "The sum is very large actually to be stored in it maybe try long long or long int"
                    },
                    {
                        "username": "Piyush__Tiwari",
                        "content": "just another day , just another TLE ( average programmer life)"
                    }
                ]
            },
            {
                "id": 1937445,
                "content": [
                    {
                        "username": "b0s00ii",
                        "content": "39/39 testcases passed, but still not submitting the code. \\n\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        if(k==0) return nums;\\n        int n = nums.length;\\n        int [] result = new int[n];\\n        Arrays.fill(result,-1);\\n       \\n       if (n % 2 == 0 && n / 2 <= k) {\\n            return result;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return result;\\n        }\\n       \\n        for(int i=k;i<(n-k);i++){\\n            long sum = 0;\\n            for(int j=(i-k);j<=(i+k);j++){\\n                sum+=nums[j];\\n            }\\n            result[i]=(int)(sum/((2*k)+1));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "DezS",
                        "content": "Time limit exceed ;-;\\n\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        result= []\\n        for i in range(len(nums)):\\n            if (i-k)<0 or i+k>=len(nums):\\n                avgs=-1\\n            else:\\n                subnums=nums[i-k:i+k+1]\\n                avgs=floor(sum(subnums)/len(subnums))\\n            result.append(avgs)\\n        return result"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Try prefix sum or sliding window approch "
                    },
                    {
                        "username": "K4shal",
                        "content": "[@DezS](/DezS) Because You are computing sum at every index. Can we keep track of sum we already computed ? Because at every index we just need to add the curr value and remove the first value of the window from the sum.   "
                    },
                    {
                        "username": "Tigarana",
                        "content": "Reading question, thinking: how is this medium, how is the acceptance rate so low?? What am I missing\\nAfter quick implementation: TLE, ah. Ok. I see"
                    },
                    {
                        "username": "OussamaELh",
                        "content": "Does the time limit of a test vary according to the size of the inputs, or there is a fixed time limit that applies for all the tests , if it\\'s the case what is it? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "What I think is the procccesing takes time for large values such as adding 10^5 10^5 times"
                    },
                    {
                        "username": "layyy",
                        "content": "Try it with both the prefix sum and sliding window approach"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "TAKE CARE OF OVERFLOW TAKE LONG AS SUM"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "this solution is showing tle for last 11 (27/39) cases , can anyone help me improve this code\\n`\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n\\n        if len(nums)<2*k+1:\\n            return [-1]*len(nums)\\n        if k==0:\\n            return nums\\n        ans=[-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            sub=nums[i-k:i+k+1]\\n            \\n            avg=sum(sub)//(2*k+1)\\n            ans[i]=avg\\n        \\n           \\n        return(ans)`"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "It\\'s because we are calculating the sum many times actually you can use sliding window here to reduce those extra iterations "
                    },
                    {
                        "username": "rammurini",
                        "content": "as well as my result same 64987+ come "
                    },
                    {
                        "username": "devilz",
                        "content": "Something is wrong with the input.\\n\\nclass Solution {\\nprivate:\\n    bool debug = true;\\n\\n    void printInput(vector<int>& nums) {\\n        cout<<\"Input: \";\\n        for(int t: nums) cout<<nums[t]<<\" \";\\n        cout<<endl;\\n    }\\n\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (debug) printInput(nums);\\n        vector<int> ans;\\n        return ans;\\n    }\\n};\\n\\nFor input nums=[7,4,3,9,1,8,5,2,6] and k=3\\nInput: 2 1 9 -1094795586 4 6 8 3 5 \\nis getting printed in Stdout"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "If you are good with prefix-sum, it\\'s not that hard then."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Also sliding window works "
                    }
                ]
            },
            {
                "id": 1937402,
                "content": [
                    {
                        "username": "b0s00ii",
                        "content": "39/39 testcases passed, but still not submitting the code. \\n\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        if(k==0) return nums;\\n        int n = nums.length;\\n        int [] result = new int[n];\\n        Arrays.fill(result,-1);\\n       \\n       if (n % 2 == 0 && n / 2 <= k) {\\n            return result;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return result;\\n        }\\n       \\n        for(int i=k;i<(n-k);i++){\\n            long sum = 0;\\n            for(int j=(i-k);j<=(i+k);j++){\\n                sum+=nums[j];\\n            }\\n            result[i]=(int)(sum/((2*k)+1));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "DezS",
                        "content": "Time limit exceed ;-;\\n\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        result= []\\n        for i in range(len(nums)):\\n            if (i-k)<0 or i+k>=len(nums):\\n                avgs=-1\\n            else:\\n                subnums=nums[i-k:i+k+1]\\n                avgs=floor(sum(subnums)/len(subnums))\\n            result.append(avgs)\\n        return result"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Try prefix sum or sliding window approch "
                    },
                    {
                        "username": "K4shal",
                        "content": "[@DezS](/DezS) Because You are computing sum at every index. Can we keep track of sum we already computed ? Because at every index we just need to add the curr value and remove the first value of the window from the sum.   "
                    },
                    {
                        "username": "Tigarana",
                        "content": "Reading question, thinking: how is this medium, how is the acceptance rate so low?? What am I missing\\nAfter quick implementation: TLE, ah. Ok. I see"
                    },
                    {
                        "username": "OussamaELh",
                        "content": "Does the time limit of a test vary according to the size of the inputs, or there is a fixed time limit that applies for all the tests , if it\\'s the case what is it? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "What I think is the procccesing takes time for large values such as adding 10^5 10^5 times"
                    },
                    {
                        "username": "layyy",
                        "content": "Try it with both the prefix sum and sliding window approach"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "TAKE CARE OF OVERFLOW TAKE LONG AS SUM"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "this solution is showing tle for last 11 (27/39) cases , can anyone help me improve this code\\n`\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n\\n        if len(nums)<2*k+1:\\n            return [-1]*len(nums)\\n        if k==0:\\n            return nums\\n        ans=[-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            sub=nums[i-k:i+k+1]\\n            \\n            avg=sum(sub)//(2*k+1)\\n            ans[i]=avg\\n        \\n           \\n        return(ans)`"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "It\\'s because we are calculating the sum many times actually you can use sliding window here to reduce those extra iterations "
                    },
                    {
                        "username": "rammurini",
                        "content": "as well as my result same 64987+ come "
                    },
                    {
                        "username": "devilz",
                        "content": "Something is wrong with the input.\\n\\nclass Solution {\\nprivate:\\n    bool debug = true;\\n\\n    void printInput(vector<int>& nums) {\\n        cout<<\"Input: \";\\n        for(int t: nums) cout<<nums[t]<<\" \";\\n        cout<<endl;\\n    }\\n\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (debug) printInput(nums);\\n        vector<int> ans;\\n        return ans;\\n    }\\n};\\n\\nFor input nums=[7,4,3,9,1,8,5,2,6] and k=3\\nInput: 2 1 9 -1094795586 4 6 8 3 5 \\nis getting printed in Stdout"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "If you are good with prefix-sum, it\\'s not that hard then."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Also sliding window works "
                    }
                ]
            },
            {
                "id": 1937362,
                "content": [
                    {
                        "username": "b0s00ii",
                        "content": "39/39 testcases passed, but still not submitting the code. \\n\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        if(k==0) return nums;\\n        int n = nums.length;\\n        int [] result = new int[n];\\n        Arrays.fill(result,-1);\\n       \\n       if (n % 2 == 0 && n / 2 <= k) {\\n            return result;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return result;\\n        }\\n       \\n        for(int i=k;i<(n-k);i++){\\n            long sum = 0;\\n            for(int j=(i-k);j<=(i+k);j++){\\n                sum+=nums[j];\\n            }\\n            result[i]=(int)(sum/((2*k)+1));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "DezS",
                        "content": "Time limit exceed ;-;\\n\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        result= []\\n        for i in range(len(nums)):\\n            if (i-k)<0 or i+k>=len(nums):\\n                avgs=-1\\n            else:\\n                subnums=nums[i-k:i+k+1]\\n                avgs=floor(sum(subnums)/len(subnums))\\n            result.append(avgs)\\n        return result"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Try prefix sum or sliding window approch "
                    },
                    {
                        "username": "K4shal",
                        "content": "[@DezS](/DezS) Because You are computing sum at every index. Can we keep track of sum we already computed ? Because at every index we just need to add the curr value and remove the first value of the window from the sum.   "
                    },
                    {
                        "username": "Tigarana",
                        "content": "Reading question, thinking: how is this medium, how is the acceptance rate so low?? What am I missing\\nAfter quick implementation: TLE, ah. Ok. I see"
                    },
                    {
                        "username": "OussamaELh",
                        "content": "Does the time limit of a test vary according to the size of the inputs, or there is a fixed time limit that applies for all the tests , if it\\'s the case what is it? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "What I think is the procccesing takes time for large values such as adding 10^5 10^5 times"
                    },
                    {
                        "username": "layyy",
                        "content": "Try it with both the prefix sum and sliding window approach"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "TAKE CARE OF OVERFLOW TAKE LONG AS SUM"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "this solution is showing tle for last 11 (27/39) cases , can anyone help me improve this code\\n`\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n\\n        if len(nums)<2*k+1:\\n            return [-1]*len(nums)\\n        if k==0:\\n            return nums\\n        ans=[-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            sub=nums[i-k:i+k+1]\\n            \\n            avg=sum(sub)//(2*k+1)\\n            ans[i]=avg\\n        \\n           \\n        return(ans)`"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "It\\'s because we are calculating the sum many times actually you can use sliding window here to reduce those extra iterations "
                    },
                    {
                        "username": "rammurini",
                        "content": "as well as my result same 64987+ come "
                    },
                    {
                        "username": "devilz",
                        "content": "Something is wrong with the input.\\n\\nclass Solution {\\nprivate:\\n    bool debug = true;\\n\\n    void printInput(vector<int>& nums) {\\n        cout<<\"Input: \";\\n        for(int t: nums) cout<<nums[t]<<\" \";\\n        cout<<endl;\\n    }\\n\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (debug) printInput(nums);\\n        vector<int> ans;\\n        return ans;\\n    }\\n};\\n\\nFor input nums=[7,4,3,9,1,8,5,2,6] and k=3\\nInput: 2 1 9 -1094795586 4 6 8 3 5 \\nis getting printed in Stdout"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "If you are good with prefix-sum, it\\'s not that hard then."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Also sliding window works "
                    }
                ]
            },
            {
                "id": 1937246,
                "content": [
                    {
                        "username": "b0s00ii",
                        "content": "39/39 testcases passed, but still not submitting the code. \\n\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        if(k==0) return nums;\\n        int n = nums.length;\\n        int [] result = new int[n];\\n        Arrays.fill(result,-1);\\n       \\n       if (n % 2 == 0 && n / 2 <= k) {\\n            return result;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return result;\\n        }\\n       \\n        for(int i=k;i<(n-k);i++){\\n            long sum = 0;\\n            for(int j=(i-k);j<=(i+k);j++){\\n                sum+=nums[j];\\n            }\\n            result[i]=(int)(sum/((2*k)+1));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "DezS",
                        "content": "Time limit exceed ;-;\\n\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        result= []\\n        for i in range(len(nums)):\\n            if (i-k)<0 or i+k>=len(nums):\\n                avgs=-1\\n            else:\\n                subnums=nums[i-k:i+k+1]\\n                avgs=floor(sum(subnums)/len(subnums))\\n            result.append(avgs)\\n        return result"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Try prefix sum or sliding window approch "
                    },
                    {
                        "username": "K4shal",
                        "content": "[@DezS](/DezS) Because You are computing sum at every index. Can we keep track of sum we already computed ? Because at every index we just need to add the curr value and remove the first value of the window from the sum.   "
                    },
                    {
                        "username": "Tigarana",
                        "content": "Reading question, thinking: how is this medium, how is the acceptance rate so low?? What am I missing\\nAfter quick implementation: TLE, ah. Ok. I see"
                    },
                    {
                        "username": "OussamaELh",
                        "content": "Does the time limit of a test vary according to the size of the inputs, or there is a fixed time limit that applies for all the tests , if it\\'s the case what is it? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "What I think is the procccesing takes time for large values such as adding 10^5 10^5 times"
                    },
                    {
                        "username": "layyy",
                        "content": "Try it with both the prefix sum and sliding window approach"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "TAKE CARE OF OVERFLOW TAKE LONG AS SUM"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "this solution is showing tle for last 11 (27/39) cases , can anyone help me improve this code\\n`\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n\\n        if len(nums)<2*k+1:\\n            return [-1]*len(nums)\\n        if k==0:\\n            return nums\\n        ans=[-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            sub=nums[i-k:i+k+1]\\n            \\n            avg=sum(sub)//(2*k+1)\\n            ans[i]=avg\\n        \\n           \\n        return(ans)`"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "It\\'s because we are calculating the sum many times actually you can use sliding window here to reduce those extra iterations "
                    },
                    {
                        "username": "rammurini",
                        "content": "as well as my result same 64987+ come "
                    },
                    {
                        "username": "devilz",
                        "content": "Something is wrong with the input.\\n\\nclass Solution {\\nprivate:\\n    bool debug = true;\\n\\n    void printInput(vector<int>& nums) {\\n        cout<<\"Input: \";\\n        for(int t: nums) cout<<nums[t]<<\" \";\\n        cout<<endl;\\n    }\\n\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (debug) printInput(nums);\\n        vector<int> ans;\\n        return ans;\\n    }\\n};\\n\\nFor input nums=[7,4,3,9,1,8,5,2,6] and k=3\\nInput: 2 1 9 -1094795586 4 6 8 3 5 \\nis getting printed in Stdout"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "If you are good with prefix-sum, it\\'s not that hard then."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Also sliding window works "
                    }
                ]
            },
            {
                "id": 1937241,
                "content": [
                    {
                        "username": "b0s00ii",
                        "content": "39/39 testcases passed, but still not submitting the code. \\n\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        if(k==0) return nums;\\n        int n = nums.length;\\n        int [] result = new int[n];\\n        Arrays.fill(result,-1);\\n       \\n       if (n % 2 == 0 && n / 2 <= k) {\\n            return result;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return result;\\n        }\\n       \\n        for(int i=k;i<(n-k);i++){\\n            long sum = 0;\\n            for(int j=(i-k);j<=(i+k);j++){\\n                sum+=nums[j];\\n            }\\n            result[i]=(int)(sum/((2*k)+1));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "DezS",
                        "content": "Time limit exceed ;-;\\n\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        result= []\\n        for i in range(len(nums)):\\n            if (i-k)<0 or i+k>=len(nums):\\n                avgs=-1\\n            else:\\n                subnums=nums[i-k:i+k+1]\\n                avgs=floor(sum(subnums)/len(subnums))\\n            result.append(avgs)\\n        return result"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Try prefix sum or sliding window approch "
                    },
                    {
                        "username": "K4shal",
                        "content": "[@DezS](/DezS) Because You are computing sum at every index. Can we keep track of sum we already computed ? Because at every index we just need to add the curr value and remove the first value of the window from the sum.   "
                    },
                    {
                        "username": "Tigarana",
                        "content": "Reading question, thinking: how is this medium, how is the acceptance rate so low?? What am I missing\\nAfter quick implementation: TLE, ah. Ok. I see"
                    },
                    {
                        "username": "OussamaELh",
                        "content": "Does the time limit of a test vary according to the size of the inputs, or there is a fixed time limit that applies for all the tests , if it\\'s the case what is it? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "What I think is the procccesing takes time for large values such as adding 10^5 10^5 times"
                    },
                    {
                        "username": "layyy",
                        "content": "Try it with both the prefix sum and sliding window approach"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "TAKE CARE OF OVERFLOW TAKE LONG AS SUM"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "this solution is showing tle for last 11 (27/39) cases , can anyone help me improve this code\\n`\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n\\n        if len(nums)<2*k+1:\\n            return [-1]*len(nums)\\n        if k==0:\\n            return nums\\n        ans=[-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            sub=nums[i-k:i+k+1]\\n            \\n            avg=sum(sub)//(2*k+1)\\n            ans[i]=avg\\n        \\n           \\n        return(ans)`"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "It\\'s because we are calculating the sum many times actually you can use sliding window here to reduce those extra iterations "
                    },
                    {
                        "username": "rammurini",
                        "content": "as well as my result same 64987+ come "
                    },
                    {
                        "username": "devilz",
                        "content": "Something is wrong with the input.\\n\\nclass Solution {\\nprivate:\\n    bool debug = true;\\n\\n    void printInput(vector<int>& nums) {\\n        cout<<\"Input: \";\\n        for(int t: nums) cout<<nums[t]<<\" \";\\n        cout<<endl;\\n    }\\n\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (debug) printInput(nums);\\n        vector<int> ans;\\n        return ans;\\n    }\\n};\\n\\nFor input nums=[7,4,3,9,1,8,5,2,6] and k=3\\nInput: 2 1 9 -1094795586 4 6 8 3 5 \\nis getting printed in Stdout"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "If you are good with prefix-sum, it\\'s not that hard then."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Also sliding window works "
                    }
                ]
            },
            {
                "id": 1937223,
                "content": [
                    {
                        "username": "b0s00ii",
                        "content": "39/39 testcases passed, but still not submitting the code. \\n\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        if(k==0) return nums;\\n        int n = nums.length;\\n        int [] result = new int[n];\\n        Arrays.fill(result,-1);\\n       \\n       if (n % 2 == 0 && n / 2 <= k) {\\n            return result;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return result;\\n        }\\n       \\n        for(int i=k;i<(n-k);i++){\\n            long sum = 0;\\n            for(int j=(i-k);j<=(i+k);j++){\\n                sum+=nums[j];\\n            }\\n            result[i]=(int)(sum/((2*k)+1));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "DezS",
                        "content": "Time limit exceed ;-;\\n\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        result= []\\n        for i in range(len(nums)):\\n            if (i-k)<0 or i+k>=len(nums):\\n                avgs=-1\\n            else:\\n                subnums=nums[i-k:i+k+1]\\n                avgs=floor(sum(subnums)/len(subnums))\\n            result.append(avgs)\\n        return result"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Try prefix sum or sliding window approch "
                    },
                    {
                        "username": "K4shal",
                        "content": "[@DezS](/DezS) Because You are computing sum at every index. Can we keep track of sum we already computed ? Because at every index we just need to add the curr value and remove the first value of the window from the sum.   "
                    },
                    {
                        "username": "Tigarana",
                        "content": "Reading question, thinking: how is this medium, how is the acceptance rate so low?? What am I missing\\nAfter quick implementation: TLE, ah. Ok. I see"
                    },
                    {
                        "username": "OussamaELh",
                        "content": "Does the time limit of a test vary according to the size of the inputs, or there is a fixed time limit that applies for all the tests , if it\\'s the case what is it? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "What I think is the procccesing takes time for large values such as adding 10^5 10^5 times"
                    },
                    {
                        "username": "layyy",
                        "content": "Try it with both the prefix sum and sliding window approach"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "TAKE CARE OF OVERFLOW TAKE LONG AS SUM"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "this solution is showing tle for last 11 (27/39) cases , can anyone help me improve this code\\n`\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n\\n        if len(nums)<2*k+1:\\n            return [-1]*len(nums)\\n        if k==0:\\n            return nums\\n        ans=[-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            sub=nums[i-k:i+k+1]\\n            \\n            avg=sum(sub)//(2*k+1)\\n            ans[i]=avg\\n        \\n           \\n        return(ans)`"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "It\\'s because we are calculating the sum many times actually you can use sliding window here to reduce those extra iterations "
                    },
                    {
                        "username": "rammurini",
                        "content": "as well as my result same 64987+ come "
                    },
                    {
                        "username": "devilz",
                        "content": "Something is wrong with the input.\\n\\nclass Solution {\\nprivate:\\n    bool debug = true;\\n\\n    void printInput(vector<int>& nums) {\\n        cout<<\"Input: \";\\n        for(int t: nums) cout<<nums[t]<<\" \";\\n        cout<<endl;\\n    }\\n\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (debug) printInput(nums);\\n        vector<int> ans;\\n        return ans;\\n    }\\n};\\n\\nFor input nums=[7,4,3,9,1,8,5,2,6] and k=3\\nInput: 2 1 9 -1094795586 4 6 8 3 5 \\nis getting printed in Stdout"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "If you are good with prefix-sum, it\\'s not that hard then."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Also sliding window works "
                    }
                ]
            },
            {
                "id": 1937218,
                "content": [
                    {
                        "username": "b0s00ii",
                        "content": "39/39 testcases passed, but still not submitting the code. \\n\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        if(k==0) return nums;\\n        int n = nums.length;\\n        int [] result = new int[n];\\n        Arrays.fill(result,-1);\\n       \\n       if (n % 2 == 0 && n / 2 <= k) {\\n            return result;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return result;\\n        }\\n       \\n        for(int i=k;i<(n-k);i++){\\n            long sum = 0;\\n            for(int j=(i-k);j<=(i+k);j++){\\n                sum+=nums[j];\\n            }\\n            result[i]=(int)(sum/((2*k)+1));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "DezS",
                        "content": "Time limit exceed ;-;\\n\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        result= []\\n        for i in range(len(nums)):\\n            if (i-k)<0 or i+k>=len(nums):\\n                avgs=-1\\n            else:\\n                subnums=nums[i-k:i+k+1]\\n                avgs=floor(sum(subnums)/len(subnums))\\n            result.append(avgs)\\n        return result"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Try prefix sum or sliding window approch "
                    },
                    {
                        "username": "K4shal",
                        "content": "[@DezS](/DezS) Because You are computing sum at every index. Can we keep track of sum we already computed ? Because at every index we just need to add the curr value and remove the first value of the window from the sum.   "
                    },
                    {
                        "username": "Tigarana",
                        "content": "Reading question, thinking: how is this medium, how is the acceptance rate so low?? What am I missing\\nAfter quick implementation: TLE, ah. Ok. I see"
                    },
                    {
                        "username": "OussamaELh",
                        "content": "Does the time limit of a test vary according to the size of the inputs, or there is a fixed time limit that applies for all the tests , if it\\'s the case what is it? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "What I think is the procccesing takes time for large values such as adding 10^5 10^5 times"
                    },
                    {
                        "username": "layyy",
                        "content": "Try it with both the prefix sum and sliding window approach"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "TAKE CARE OF OVERFLOW TAKE LONG AS SUM"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "this solution is showing tle for last 11 (27/39) cases , can anyone help me improve this code\\n`\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n\\n        if len(nums)<2*k+1:\\n            return [-1]*len(nums)\\n        if k==0:\\n            return nums\\n        ans=[-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            sub=nums[i-k:i+k+1]\\n            \\n            avg=sum(sub)//(2*k+1)\\n            ans[i]=avg\\n        \\n           \\n        return(ans)`"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "It\\'s because we are calculating the sum many times actually you can use sliding window here to reduce those extra iterations "
                    },
                    {
                        "username": "rammurini",
                        "content": "as well as my result same 64987+ come "
                    },
                    {
                        "username": "devilz",
                        "content": "Something is wrong with the input.\\n\\nclass Solution {\\nprivate:\\n    bool debug = true;\\n\\n    void printInput(vector<int>& nums) {\\n        cout<<\"Input: \";\\n        for(int t: nums) cout<<nums[t]<<\" \";\\n        cout<<endl;\\n    }\\n\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (debug) printInput(nums);\\n        vector<int> ans;\\n        return ans;\\n    }\\n};\\n\\nFor input nums=[7,4,3,9,1,8,5,2,6] and k=3\\nInput: 2 1 9 -1094795586 4 6 8 3 5 \\nis getting printed in Stdout"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "If you are good with prefix-sum, it\\'s not that hard then."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Also sliding window works "
                    }
                ]
            },
            {
                "id": 1937199,
                "content": [
                    {
                        "username": "b0s00ii",
                        "content": "39/39 testcases passed, but still not submitting the code. \\n\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        if(k==0) return nums;\\n        int n = nums.length;\\n        int [] result = new int[n];\\n        Arrays.fill(result,-1);\\n       \\n       if (n % 2 == 0 && n / 2 <= k) {\\n            return result;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return result;\\n        }\\n       \\n        for(int i=k;i<(n-k);i++){\\n            long sum = 0;\\n            for(int j=(i-k);j<=(i+k);j++){\\n                sum+=nums[j];\\n            }\\n            result[i]=(int)(sum/((2*k)+1));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "DezS",
                        "content": "Time limit exceed ;-;\\n\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        result= []\\n        for i in range(len(nums)):\\n            if (i-k)<0 or i+k>=len(nums):\\n                avgs=-1\\n            else:\\n                subnums=nums[i-k:i+k+1]\\n                avgs=floor(sum(subnums)/len(subnums))\\n            result.append(avgs)\\n        return result"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Try prefix sum or sliding window approch "
                    },
                    {
                        "username": "K4shal",
                        "content": "[@DezS](/DezS) Because You are computing sum at every index. Can we keep track of sum we already computed ? Because at every index we just need to add the curr value and remove the first value of the window from the sum.   "
                    },
                    {
                        "username": "Tigarana",
                        "content": "Reading question, thinking: how is this medium, how is the acceptance rate so low?? What am I missing\\nAfter quick implementation: TLE, ah. Ok. I see"
                    },
                    {
                        "username": "OussamaELh",
                        "content": "Does the time limit of a test vary according to the size of the inputs, or there is a fixed time limit that applies for all the tests , if it\\'s the case what is it? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "What I think is the procccesing takes time for large values such as adding 10^5 10^5 times"
                    },
                    {
                        "username": "layyy",
                        "content": "Try it with both the prefix sum and sliding window approach"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "TAKE CARE OF OVERFLOW TAKE LONG AS SUM"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "this solution is showing tle for last 11 (27/39) cases , can anyone help me improve this code\\n`\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n\\n        if len(nums)<2*k+1:\\n            return [-1]*len(nums)\\n        if k==0:\\n            return nums\\n        ans=[-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            sub=nums[i-k:i+k+1]\\n            \\n            avg=sum(sub)//(2*k+1)\\n            ans[i]=avg\\n        \\n           \\n        return(ans)`"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "It\\'s because we are calculating the sum many times actually you can use sliding window here to reduce those extra iterations "
                    },
                    {
                        "username": "rammurini",
                        "content": "as well as my result same 64987+ come "
                    },
                    {
                        "username": "devilz",
                        "content": "Something is wrong with the input.\\n\\nclass Solution {\\nprivate:\\n    bool debug = true;\\n\\n    void printInput(vector<int>& nums) {\\n        cout<<\"Input: \";\\n        for(int t: nums) cout<<nums[t]<<\" \";\\n        cout<<endl;\\n    }\\n\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (debug) printInput(nums);\\n        vector<int> ans;\\n        return ans;\\n    }\\n};\\n\\nFor input nums=[7,4,3,9,1,8,5,2,6] and k=3\\nInput: 2 1 9 -1094795586 4 6 8 3 5 \\nis getting printed in Stdout"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "If you are good with prefix-sum, it\\'s not that hard then."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Also sliding window works "
                    }
                ]
            },
            {
                "id": 1937185,
                "content": [
                    {
                        "username": "b0s00ii",
                        "content": "39/39 testcases passed, but still not submitting the code. \\n\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        if(k==0) return nums;\\n        int n = nums.length;\\n        int [] result = new int[n];\\n        Arrays.fill(result,-1);\\n       \\n       if (n % 2 == 0 && n / 2 <= k) {\\n            return result;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return result;\\n        }\\n       \\n        for(int i=k;i<(n-k);i++){\\n            long sum = 0;\\n            for(int j=(i-k);j<=(i+k);j++){\\n                sum+=nums[j];\\n            }\\n            result[i]=(int)(sum/((2*k)+1));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "DezS",
                        "content": "Time limit exceed ;-;\\n\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        result= []\\n        for i in range(len(nums)):\\n            if (i-k)<0 or i+k>=len(nums):\\n                avgs=-1\\n            else:\\n                subnums=nums[i-k:i+k+1]\\n                avgs=floor(sum(subnums)/len(subnums))\\n            result.append(avgs)\\n        return result"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Try prefix sum or sliding window approch "
                    },
                    {
                        "username": "K4shal",
                        "content": "[@DezS](/DezS) Because You are computing sum at every index. Can we keep track of sum we already computed ? Because at every index we just need to add the curr value and remove the first value of the window from the sum.   "
                    },
                    {
                        "username": "Tigarana",
                        "content": "Reading question, thinking: how is this medium, how is the acceptance rate so low?? What am I missing\\nAfter quick implementation: TLE, ah. Ok. I see"
                    },
                    {
                        "username": "OussamaELh",
                        "content": "Does the time limit of a test vary according to the size of the inputs, or there is a fixed time limit that applies for all the tests , if it\\'s the case what is it? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "What I think is the procccesing takes time for large values such as adding 10^5 10^5 times"
                    },
                    {
                        "username": "layyy",
                        "content": "Try it with both the prefix sum and sliding window approach"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "TAKE CARE OF OVERFLOW TAKE LONG AS SUM"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "this solution is showing tle for last 11 (27/39) cases , can anyone help me improve this code\\n`\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n\\n        if len(nums)<2*k+1:\\n            return [-1]*len(nums)\\n        if k==0:\\n            return nums\\n        ans=[-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            sub=nums[i-k:i+k+1]\\n            \\n            avg=sum(sub)//(2*k+1)\\n            ans[i]=avg\\n        \\n           \\n        return(ans)`"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "It\\'s because we are calculating the sum many times actually you can use sliding window here to reduce those extra iterations "
                    },
                    {
                        "username": "rammurini",
                        "content": "as well as my result same 64987+ come "
                    },
                    {
                        "username": "devilz",
                        "content": "Something is wrong with the input.\\n\\nclass Solution {\\nprivate:\\n    bool debug = true;\\n\\n    void printInput(vector<int>& nums) {\\n        cout<<\"Input: \";\\n        for(int t: nums) cout<<nums[t]<<\" \";\\n        cout<<endl;\\n    }\\n\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (debug) printInput(nums);\\n        vector<int> ans;\\n        return ans;\\n    }\\n};\\n\\nFor input nums=[7,4,3,9,1,8,5,2,6] and k=3\\nInput: 2 1 9 -1094795586 4 6 8 3 5 \\nis getting printed in Stdout"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "If you are good with prefix-sum, it\\'s not that hard then."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Also sliding window works "
                    }
                ]
            },
            {
                "id": 1937143,
                "content": [
                    {
                        "username": "b0s00ii",
                        "content": "39/39 testcases passed, but still not submitting the code. \\n\\nclass Solution {\\n    public int[] getAverages(int[] nums, int k) {\\n        if(k==0) return nums;\\n        int n = nums.length;\\n        int [] result = new int[n];\\n        Arrays.fill(result,-1);\\n       \\n       if (n % 2 == 0 && n / 2 <= k) {\\n            return result;\\n        } else if (n % 2 != 0 && n / 2 < k) {\\n            return result;\\n        }\\n       \\n        for(int i=k;i<(n-k);i++){\\n            long sum = 0;\\n            for(int j=(i-k);j<=(i+k);j++){\\n                sum+=nums[j];\\n            }\\n            result[i]=(int)(sum/((2*k)+1));\\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "DezS",
                        "content": "Time limit exceed ;-;\\n\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n        result= []\\n        for i in range(len(nums)):\\n            if (i-k)<0 or i+k>=len(nums):\\n                avgs=-1\\n            else:\\n                subnums=nums[i-k:i+k+1]\\n                avgs=floor(sum(subnums)/len(subnums))\\n            result.append(avgs)\\n        return result"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Try prefix sum or sliding window approch "
                    },
                    {
                        "username": "K4shal",
                        "content": "[@DezS](/DezS) Because You are computing sum at every index. Can we keep track of sum we already computed ? Because at every index we just need to add the curr value and remove the first value of the window from the sum.   "
                    },
                    {
                        "username": "Tigarana",
                        "content": "Reading question, thinking: how is this medium, how is the acceptance rate so low?? What am I missing\\nAfter quick implementation: TLE, ah. Ok. I see"
                    },
                    {
                        "username": "OussamaELh",
                        "content": "Does the time limit of a test vary according to the size of the inputs, or there is a fixed time limit that applies for all the tests , if it\\'s the case what is it? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "What I think is the procccesing takes time for large values such as adding 10^5 10^5 times"
                    },
                    {
                        "username": "layyy",
                        "content": "Try it with both the prefix sum and sliding window approach"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "TAKE CARE OF OVERFLOW TAKE LONG AS SUM"
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "this solution is showing tle for last 11 (27/39) cases , can anyone help me improve this code\\n`\\n    def getAverages(self, nums: List[int], k: int) -> List[int]:\\n\\n        if len(nums)<2*k+1:\\n            return [-1]*len(nums)\\n        if k==0:\\n            return nums\\n        ans=[-1]*len(nums)\\n        for i in range(k,len(nums)-k):\\n            sub=nums[i-k:i+k+1]\\n            \\n            avg=sum(sub)//(2*k+1)\\n            ans[i]=avg\\n        \\n           \\n        return(ans)`"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "It\\'s because we are calculating the sum many times actually you can use sliding window here to reduce those extra iterations "
                    },
                    {
                        "username": "rammurini",
                        "content": "as well as my result same 64987+ come "
                    },
                    {
                        "username": "devilz",
                        "content": "Something is wrong with the input.\\n\\nclass Solution {\\nprivate:\\n    bool debug = true;\\n\\n    void printInput(vector<int>& nums) {\\n        cout<<\"Input: \";\\n        for(int t: nums) cout<<nums[t]<<\" \";\\n        cout<<endl;\\n    }\\n\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n        if (debug) printInput(nums);\\n        vector<int> ans;\\n        return ans;\\n    }\\n};\\n\\nFor input nums=[7,4,3,9,1,8,5,2,6] and k=3\\nInput: 2 1 9 -1094795586 4 6 8 3 5 \\nis getting printed in Stdout"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "If you are good with prefix-sum, it\\'s not that hard then."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Also sliding window works "
                    }
                ]
            },
            {
                "id": 1937119,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "For those looking for a little more practice with sliding windows, this is a nice little primer: https://leetcode.com/problems/maximum-average-subarray-i/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "did anyone took care of k==0. I got wrong answer there \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I got correct on first run for that condition just return nums"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "my code is showing incorrect answer for 38th testcase. But I cant see where it is wrong as there are too many elements in the array and not all of them are visible. can someone tell me what am I supposed to do?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@Aditya1008](/Aditya1008) Most of the people got wrong op on 38th case. That is because of integer overflow. \nMake your \"sum\" variable long/double. \nThen for average, ans[i] = ```(int)(sum/(int)(2*k + 1))```\n\nIf you are using prefix sum method, use long[]"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "[@saikiran1s](/saikiran1s) if you dont mind, can I share my code with you? I did what you asked but still showing wrong output\\n"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Use long to store sum and also take care of type conversion while taking average\n```(int)(sum/(int)n)``` See the parenthesis"
                    },
                    {
                        "username": "psionl0",
                        "content": "It could be a problem with int. Try using long long for your summations."
                    },
                    {
                        "username": "aditya_mad",
                        "content": " `int size = nums.size();\n        vector<int> ans(size, -1);\n\n        if(size < (2 * k) + 1)\n        {\n            return ans;\n        }\n\n        long long int sum = 0;\n        for(int i = 0; i < (2 * k) + 1; i++)\n        {\n            sum += nums[i];\n        }\n        int left = 0, right = (2 * k) + 1;\n        for(int i = k; i < size - k; i++)\n        {\n            ans[i] = sum;\n            ans[i] /= ((2 * k) + 1);\n            if(i != size - k - 1)\n            {\n                sum -= nums[left++];\n                sum += nums[right++];\n            }     \n        }\n        return ans;`\nCan anyone help me with this is code. It is failing on test case 38\nI used sliding window of size (2* k + 1)"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) This is no different than ```ans[i] = (int)(sum/(int)(2*k + 1))``` coz dividing int(or long) by double leads to both numerator and denominator to be double. And the most outer (int) will convert that double to int. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) Thank man worked! Understood my mistake"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) Do this ```ans[i] = (int)(sum/(int)(2*k + 1))``` "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \\n`ans[i] = (int)(sum/(double)((2 * k) + 1));`\\nThis worked for some weird reason. Can someone please explain why? I don\\'t think the result would be different. 11 / 4 (both int by default) will give me 2 and  (int)(11 / (double) 4) will also be 2. So why this worked and why not the plain vanilla both int division?\\n "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \n`\nans[i] = (int) sum;\nans[i] /= (int) ((2 * k) + 1);\n`\n\ndid this but no change WA on test case 38"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "```\\nans = (convert to int) sum\\nans[i] /= (convert to int) ((2 * k) + 1);\\n``` "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Question description is so bad and understanding question was more difficult than actually solving it :)"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Straight forward sliding window\\n\\nspoiler:\\n\\n\\nwindow size is k * 2 + 1\\nuse  int64_t for window size"
                    },
                    {
                        "username": "aabhishekmishra",
                        "content": "Not medium, it should be an easy problem. Just think about brute force and modify your brute force algorithm just adding and subtracting an element  while you move forward."
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Guys, use long/double for summation."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Don\\'t know why they mark it as medium. Easy solution."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\n**Easy Solution C++. 2 pointer approach. Single traversal **\\n\\n# Approach\\n1. Start the function `getAverages` with parameters `nums` (a reference to a vector of integers) and `k` (an integer).\\n2. Set the variable `n` as the size of the `nums` vector.\\n3. If `k` is equal to 0, return the original `nums` vector.\\n4. Create a new vector `ans` with size `n` and initialize all elements to -1.\\n5. Calculate the value of `dia` as `2*k + 1`.\\n6. Initialize the variables `low` and `sum` to 0.\\n7. Iterate over the elements of `nums` from index 0 to index `n-1` using the variable `high`.\\n8. Inside the loop:\\n   - Add the value of `nums[high]` to the `sum`.\\n   - Check if the length of the current subarray, `(high-low+1)`, is equal to `dia`.\\n     - If it is, proceed with the following steps:\\n       - Calculate the index of the middle element as `mid` using `(high + low) / 2`.\\n       - Assign the average of the subarray, `sum/dia`, to `ans[mid]`.\\n       - Subtract the value of `nums[low]` from `sum`.\\n       - Increment the value of `low` by 1.\\n9. After the loop, return the resulting `ans` vector containing the averages of subarrays with length `dia`.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(N) single traversal\\n\\n- Space complexity:\\nS.C=O(1) No extra space\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/k-radius-subarray-averages/solutions/3660393/optimal-easy-solution-c-2-pointer-approach-single-traversal/"
                    }
                ]
            },
            {
                "id": 1937111,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "For those looking for a little more practice with sliding windows, this is a nice little primer: https://leetcode.com/problems/maximum-average-subarray-i/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "did anyone took care of k==0. I got wrong answer there \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I got correct on first run for that condition just return nums"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "my code is showing incorrect answer for 38th testcase. But I cant see where it is wrong as there are too many elements in the array and not all of them are visible. can someone tell me what am I supposed to do?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@Aditya1008](/Aditya1008) Most of the people got wrong op on 38th case. That is because of integer overflow. \nMake your \"sum\" variable long/double. \nThen for average, ans[i] = ```(int)(sum/(int)(2*k + 1))```\n\nIf you are using prefix sum method, use long[]"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "[@saikiran1s](/saikiran1s) if you dont mind, can I share my code with you? I did what you asked but still showing wrong output\\n"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Use long to store sum and also take care of type conversion while taking average\n```(int)(sum/(int)n)``` See the parenthesis"
                    },
                    {
                        "username": "psionl0",
                        "content": "It could be a problem with int. Try using long long for your summations."
                    },
                    {
                        "username": "aditya_mad",
                        "content": " `int size = nums.size();\n        vector<int> ans(size, -1);\n\n        if(size < (2 * k) + 1)\n        {\n            return ans;\n        }\n\n        long long int sum = 0;\n        for(int i = 0; i < (2 * k) + 1; i++)\n        {\n            sum += nums[i];\n        }\n        int left = 0, right = (2 * k) + 1;\n        for(int i = k; i < size - k; i++)\n        {\n            ans[i] = sum;\n            ans[i] /= ((2 * k) + 1);\n            if(i != size - k - 1)\n            {\n                sum -= nums[left++];\n                sum += nums[right++];\n            }     \n        }\n        return ans;`\nCan anyone help me with this is code. It is failing on test case 38\nI used sliding window of size (2* k + 1)"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) This is no different than ```ans[i] = (int)(sum/(int)(2*k + 1))``` coz dividing int(or long) by double leads to both numerator and denominator to be double. And the most outer (int) will convert that double to int. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) Thank man worked! Understood my mistake"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) Do this ```ans[i] = (int)(sum/(int)(2*k + 1))``` "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \\n`ans[i] = (int)(sum/(double)((2 * k) + 1));`\\nThis worked for some weird reason. Can someone please explain why? I don\\'t think the result would be different. 11 / 4 (both int by default) will give me 2 and  (int)(11 / (double) 4) will also be 2. So why this worked and why not the plain vanilla both int division?\\n "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \n`\nans[i] = (int) sum;\nans[i] /= (int) ((2 * k) + 1);\n`\n\ndid this but no change WA on test case 38"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "```\\nans = (convert to int) sum\\nans[i] /= (convert to int) ((2 * k) + 1);\\n``` "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Question description is so bad and understanding question was more difficult than actually solving it :)"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Straight forward sliding window\\n\\nspoiler:\\n\\n\\nwindow size is k * 2 + 1\\nuse  int64_t for window size"
                    },
                    {
                        "username": "aabhishekmishra",
                        "content": "Not medium, it should be an easy problem. Just think about brute force and modify your brute force algorithm just adding and subtracting an element  while you move forward."
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Guys, use long/double for summation."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Don\\'t know why they mark it as medium. Easy solution."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\n**Easy Solution C++. 2 pointer approach. Single traversal **\\n\\n# Approach\\n1. Start the function `getAverages` with parameters `nums` (a reference to a vector of integers) and `k` (an integer).\\n2. Set the variable `n` as the size of the `nums` vector.\\n3. If `k` is equal to 0, return the original `nums` vector.\\n4. Create a new vector `ans` with size `n` and initialize all elements to -1.\\n5. Calculate the value of `dia` as `2*k + 1`.\\n6. Initialize the variables `low` and `sum` to 0.\\n7. Iterate over the elements of `nums` from index 0 to index `n-1` using the variable `high`.\\n8. Inside the loop:\\n   - Add the value of `nums[high]` to the `sum`.\\n   - Check if the length of the current subarray, `(high-low+1)`, is equal to `dia`.\\n     - If it is, proceed with the following steps:\\n       - Calculate the index of the middle element as `mid` using `(high + low) / 2`.\\n       - Assign the average of the subarray, `sum/dia`, to `ans[mid]`.\\n       - Subtract the value of `nums[low]` from `sum`.\\n       - Increment the value of `low` by 1.\\n9. After the loop, return the resulting `ans` vector containing the averages of subarrays with length `dia`.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(N) single traversal\\n\\n- Space complexity:\\nS.C=O(1) No extra space\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/k-radius-subarray-averages/solutions/3660393/optimal-easy-solution-c-2-pointer-approach-single-traversal/"
                    }
                ]
            },
            {
                "id": 1937034,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "For those looking for a little more practice with sliding windows, this is a nice little primer: https://leetcode.com/problems/maximum-average-subarray-i/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "did anyone took care of k==0. I got wrong answer there \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I got correct on first run for that condition just return nums"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "my code is showing incorrect answer for 38th testcase. But I cant see where it is wrong as there are too many elements in the array and not all of them are visible. can someone tell me what am I supposed to do?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@Aditya1008](/Aditya1008) Most of the people got wrong op on 38th case. That is because of integer overflow. \nMake your \"sum\" variable long/double. \nThen for average, ans[i] = ```(int)(sum/(int)(2*k + 1))```\n\nIf you are using prefix sum method, use long[]"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "[@saikiran1s](/saikiran1s) if you dont mind, can I share my code with you? I did what you asked but still showing wrong output\\n"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Use long to store sum and also take care of type conversion while taking average\n```(int)(sum/(int)n)``` See the parenthesis"
                    },
                    {
                        "username": "psionl0",
                        "content": "It could be a problem with int. Try using long long for your summations."
                    },
                    {
                        "username": "aditya_mad",
                        "content": " `int size = nums.size();\n        vector<int> ans(size, -1);\n\n        if(size < (2 * k) + 1)\n        {\n            return ans;\n        }\n\n        long long int sum = 0;\n        for(int i = 0; i < (2 * k) + 1; i++)\n        {\n            sum += nums[i];\n        }\n        int left = 0, right = (2 * k) + 1;\n        for(int i = k; i < size - k; i++)\n        {\n            ans[i] = sum;\n            ans[i] /= ((2 * k) + 1);\n            if(i != size - k - 1)\n            {\n                sum -= nums[left++];\n                sum += nums[right++];\n            }     \n        }\n        return ans;`\nCan anyone help me with this is code. It is failing on test case 38\nI used sliding window of size (2* k + 1)"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) This is no different than ```ans[i] = (int)(sum/(int)(2*k + 1))``` coz dividing int(or long) by double leads to both numerator and denominator to be double. And the most outer (int) will convert that double to int. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) Thank man worked! Understood my mistake"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) Do this ```ans[i] = (int)(sum/(int)(2*k + 1))``` "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \\n`ans[i] = (int)(sum/(double)((2 * k) + 1));`\\nThis worked for some weird reason. Can someone please explain why? I don\\'t think the result would be different. 11 / 4 (both int by default) will give me 2 and  (int)(11 / (double) 4) will also be 2. So why this worked and why not the plain vanilla both int division?\\n "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \n`\nans[i] = (int) sum;\nans[i] /= (int) ((2 * k) + 1);\n`\n\ndid this but no change WA on test case 38"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "```\\nans = (convert to int) sum\\nans[i] /= (convert to int) ((2 * k) + 1);\\n``` "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Question description is so bad and understanding question was more difficult than actually solving it :)"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Straight forward sliding window\\n\\nspoiler:\\n\\n\\nwindow size is k * 2 + 1\\nuse  int64_t for window size"
                    },
                    {
                        "username": "aabhishekmishra",
                        "content": "Not medium, it should be an easy problem. Just think about brute force and modify your brute force algorithm just adding and subtracting an element  while you move forward."
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Guys, use long/double for summation."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Don\\'t know why they mark it as medium. Easy solution."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\n**Easy Solution C++. 2 pointer approach. Single traversal **\\n\\n# Approach\\n1. Start the function `getAverages` with parameters `nums` (a reference to a vector of integers) and `k` (an integer).\\n2. Set the variable `n` as the size of the `nums` vector.\\n3. If `k` is equal to 0, return the original `nums` vector.\\n4. Create a new vector `ans` with size `n` and initialize all elements to -1.\\n5. Calculate the value of `dia` as `2*k + 1`.\\n6. Initialize the variables `low` and `sum` to 0.\\n7. Iterate over the elements of `nums` from index 0 to index `n-1` using the variable `high`.\\n8. Inside the loop:\\n   - Add the value of `nums[high]` to the `sum`.\\n   - Check if the length of the current subarray, `(high-low+1)`, is equal to `dia`.\\n     - If it is, proceed with the following steps:\\n       - Calculate the index of the middle element as `mid` using `(high + low) / 2`.\\n       - Assign the average of the subarray, `sum/dia`, to `ans[mid]`.\\n       - Subtract the value of `nums[low]` from `sum`.\\n       - Increment the value of `low` by 1.\\n9. After the loop, return the resulting `ans` vector containing the averages of subarrays with length `dia`.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(N) single traversal\\n\\n- Space complexity:\\nS.C=O(1) No extra space\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/k-radius-subarray-averages/solutions/3660393/optimal-easy-solution-c-2-pointer-approach-single-traversal/"
                    }
                ]
            },
            {
                "id": 1937027,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "For those looking for a little more practice with sliding windows, this is a nice little primer: https://leetcode.com/problems/maximum-average-subarray-i/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "did anyone took care of k==0. I got wrong answer there \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I got correct on first run for that condition just return nums"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "my code is showing incorrect answer for 38th testcase. But I cant see where it is wrong as there are too many elements in the array and not all of them are visible. can someone tell me what am I supposed to do?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@Aditya1008](/Aditya1008) Most of the people got wrong op on 38th case. That is because of integer overflow. \nMake your \"sum\" variable long/double. \nThen for average, ans[i] = ```(int)(sum/(int)(2*k + 1))```\n\nIf you are using prefix sum method, use long[]"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "[@saikiran1s](/saikiran1s) if you dont mind, can I share my code with you? I did what you asked but still showing wrong output\\n"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Use long to store sum and also take care of type conversion while taking average\n```(int)(sum/(int)n)``` See the parenthesis"
                    },
                    {
                        "username": "psionl0",
                        "content": "It could be a problem with int. Try using long long for your summations."
                    },
                    {
                        "username": "aditya_mad",
                        "content": " `int size = nums.size();\n        vector<int> ans(size, -1);\n\n        if(size < (2 * k) + 1)\n        {\n            return ans;\n        }\n\n        long long int sum = 0;\n        for(int i = 0; i < (2 * k) + 1; i++)\n        {\n            sum += nums[i];\n        }\n        int left = 0, right = (2 * k) + 1;\n        for(int i = k; i < size - k; i++)\n        {\n            ans[i] = sum;\n            ans[i] /= ((2 * k) + 1);\n            if(i != size - k - 1)\n            {\n                sum -= nums[left++];\n                sum += nums[right++];\n            }     \n        }\n        return ans;`\nCan anyone help me with this is code. It is failing on test case 38\nI used sliding window of size (2* k + 1)"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) This is no different than ```ans[i] = (int)(sum/(int)(2*k + 1))``` coz dividing int(or long) by double leads to both numerator and denominator to be double. And the most outer (int) will convert that double to int. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) Thank man worked! Understood my mistake"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) Do this ```ans[i] = (int)(sum/(int)(2*k + 1))``` "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \\n`ans[i] = (int)(sum/(double)((2 * k) + 1));`\\nThis worked for some weird reason. Can someone please explain why? I don\\'t think the result would be different. 11 / 4 (both int by default) will give me 2 and  (int)(11 / (double) 4) will also be 2. So why this worked and why not the plain vanilla both int division?\\n "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \n`\nans[i] = (int) sum;\nans[i] /= (int) ((2 * k) + 1);\n`\n\ndid this but no change WA on test case 38"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "```\\nans = (convert to int) sum\\nans[i] /= (convert to int) ((2 * k) + 1);\\n``` "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Question description is so bad and understanding question was more difficult than actually solving it :)"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Straight forward sliding window\\n\\nspoiler:\\n\\n\\nwindow size is k * 2 + 1\\nuse  int64_t for window size"
                    },
                    {
                        "username": "aabhishekmishra",
                        "content": "Not medium, it should be an easy problem. Just think about brute force and modify your brute force algorithm just adding and subtracting an element  while you move forward."
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Guys, use long/double for summation."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Don\\'t know why they mark it as medium. Easy solution."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\n**Easy Solution C++. 2 pointer approach. Single traversal **\\n\\n# Approach\\n1. Start the function `getAverages` with parameters `nums` (a reference to a vector of integers) and `k` (an integer).\\n2. Set the variable `n` as the size of the `nums` vector.\\n3. If `k` is equal to 0, return the original `nums` vector.\\n4. Create a new vector `ans` with size `n` and initialize all elements to -1.\\n5. Calculate the value of `dia` as `2*k + 1`.\\n6. Initialize the variables `low` and `sum` to 0.\\n7. Iterate over the elements of `nums` from index 0 to index `n-1` using the variable `high`.\\n8. Inside the loop:\\n   - Add the value of `nums[high]` to the `sum`.\\n   - Check if the length of the current subarray, `(high-low+1)`, is equal to `dia`.\\n     - If it is, proceed with the following steps:\\n       - Calculate the index of the middle element as `mid` using `(high + low) / 2`.\\n       - Assign the average of the subarray, `sum/dia`, to `ans[mid]`.\\n       - Subtract the value of `nums[low]` from `sum`.\\n       - Increment the value of `low` by 1.\\n9. After the loop, return the resulting `ans` vector containing the averages of subarrays with length `dia`.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(N) single traversal\\n\\n- Space complexity:\\nS.C=O(1) No extra space\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/k-radius-subarray-averages/solutions/3660393/optimal-easy-solution-c-2-pointer-approach-single-traversal/"
                    }
                ]
            },
            {
                "id": 1937009,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "For those looking for a little more practice with sliding windows, this is a nice little primer: https://leetcode.com/problems/maximum-average-subarray-i/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "did anyone took care of k==0. I got wrong answer there \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I got correct on first run for that condition just return nums"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "my code is showing incorrect answer for 38th testcase. But I cant see where it is wrong as there are too many elements in the array and not all of them are visible. can someone tell me what am I supposed to do?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@Aditya1008](/Aditya1008) Most of the people got wrong op on 38th case. That is because of integer overflow. \nMake your \"sum\" variable long/double. \nThen for average, ans[i] = ```(int)(sum/(int)(2*k + 1))```\n\nIf you are using prefix sum method, use long[]"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "[@saikiran1s](/saikiran1s) if you dont mind, can I share my code with you? I did what you asked but still showing wrong output\\n"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Use long to store sum and also take care of type conversion while taking average\n```(int)(sum/(int)n)``` See the parenthesis"
                    },
                    {
                        "username": "psionl0",
                        "content": "It could be a problem with int. Try using long long for your summations."
                    },
                    {
                        "username": "aditya_mad",
                        "content": " `int size = nums.size();\n        vector<int> ans(size, -1);\n\n        if(size < (2 * k) + 1)\n        {\n            return ans;\n        }\n\n        long long int sum = 0;\n        for(int i = 0; i < (2 * k) + 1; i++)\n        {\n            sum += nums[i];\n        }\n        int left = 0, right = (2 * k) + 1;\n        for(int i = k; i < size - k; i++)\n        {\n            ans[i] = sum;\n            ans[i] /= ((2 * k) + 1);\n            if(i != size - k - 1)\n            {\n                sum -= nums[left++];\n                sum += nums[right++];\n            }     \n        }\n        return ans;`\nCan anyone help me with this is code. It is failing on test case 38\nI used sliding window of size (2* k + 1)"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) This is no different than ```ans[i] = (int)(sum/(int)(2*k + 1))``` coz dividing int(or long) by double leads to both numerator and denominator to be double. And the most outer (int) will convert that double to int. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) Thank man worked! Understood my mistake"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) Do this ```ans[i] = (int)(sum/(int)(2*k + 1))``` "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \\n`ans[i] = (int)(sum/(double)((2 * k) + 1));`\\nThis worked for some weird reason. Can someone please explain why? I don\\'t think the result would be different. 11 / 4 (both int by default) will give me 2 and  (int)(11 / (double) 4) will also be 2. So why this worked and why not the plain vanilla both int division?\\n "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \n`\nans[i] = (int) sum;\nans[i] /= (int) ((2 * k) + 1);\n`\n\ndid this but no change WA on test case 38"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "```\\nans = (convert to int) sum\\nans[i] /= (convert to int) ((2 * k) + 1);\\n``` "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Question description is so bad and understanding question was more difficult than actually solving it :)"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Straight forward sliding window\\n\\nspoiler:\\n\\n\\nwindow size is k * 2 + 1\\nuse  int64_t for window size"
                    },
                    {
                        "username": "aabhishekmishra",
                        "content": "Not medium, it should be an easy problem. Just think about brute force and modify your brute force algorithm just adding and subtracting an element  while you move forward."
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Guys, use long/double for summation."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Don\\'t know why they mark it as medium. Easy solution."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\n**Easy Solution C++. 2 pointer approach. Single traversal **\\n\\n# Approach\\n1. Start the function `getAverages` with parameters `nums` (a reference to a vector of integers) and `k` (an integer).\\n2. Set the variable `n` as the size of the `nums` vector.\\n3. If `k` is equal to 0, return the original `nums` vector.\\n4. Create a new vector `ans` with size `n` and initialize all elements to -1.\\n5. Calculate the value of `dia` as `2*k + 1`.\\n6. Initialize the variables `low` and `sum` to 0.\\n7. Iterate over the elements of `nums` from index 0 to index `n-1` using the variable `high`.\\n8. Inside the loop:\\n   - Add the value of `nums[high]` to the `sum`.\\n   - Check if the length of the current subarray, `(high-low+1)`, is equal to `dia`.\\n     - If it is, proceed with the following steps:\\n       - Calculate the index of the middle element as `mid` using `(high + low) / 2`.\\n       - Assign the average of the subarray, `sum/dia`, to `ans[mid]`.\\n       - Subtract the value of `nums[low]` from `sum`.\\n       - Increment the value of `low` by 1.\\n9. After the loop, return the resulting `ans` vector containing the averages of subarrays with length `dia`.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(N) single traversal\\n\\n- Space complexity:\\nS.C=O(1) No extra space\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/k-radius-subarray-averages/solutions/3660393/optimal-easy-solution-c-2-pointer-approach-single-traversal/"
                    }
                ]
            },
            {
                "id": 1936989,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "For those looking for a little more practice with sliding windows, this is a nice little primer: https://leetcode.com/problems/maximum-average-subarray-i/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "did anyone took care of k==0. I got wrong answer there \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I got correct on first run for that condition just return nums"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "my code is showing incorrect answer for 38th testcase. But I cant see where it is wrong as there are too many elements in the array and not all of them are visible. can someone tell me what am I supposed to do?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@Aditya1008](/Aditya1008) Most of the people got wrong op on 38th case. That is because of integer overflow. \nMake your \"sum\" variable long/double. \nThen for average, ans[i] = ```(int)(sum/(int)(2*k + 1))```\n\nIf you are using prefix sum method, use long[]"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "[@saikiran1s](/saikiran1s) if you dont mind, can I share my code with you? I did what you asked but still showing wrong output\\n"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Use long to store sum and also take care of type conversion while taking average\n```(int)(sum/(int)n)``` See the parenthesis"
                    },
                    {
                        "username": "psionl0",
                        "content": "It could be a problem with int. Try using long long for your summations."
                    },
                    {
                        "username": "aditya_mad",
                        "content": " `int size = nums.size();\n        vector<int> ans(size, -1);\n\n        if(size < (2 * k) + 1)\n        {\n            return ans;\n        }\n\n        long long int sum = 0;\n        for(int i = 0; i < (2 * k) + 1; i++)\n        {\n            sum += nums[i];\n        }\n        int left = 0, right = (2 * k) + 1;\n        for(int i = k; i < size - k; i++)\n        {\n            ans[i] = sum;\n            ans[i] /= ((2 * k) + 1);\n            if(i != size - k - 1)\n            {\n                sum -= nums[left++];\n                sum += nums[right++];\n            }     \n        }\n        return ans;`\nCan anyone help me with this is code. It is failing on test case 38\nI used sliding window of size (2* k + 1)"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) This is no different than ```ans[i] = (int)(sum/(int)(2*k + 1))``` coz dividing int(or long) by double leads to both numerator and denominator to be double. And the most outer (int) will convert that double to int. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) Thank man worked! Understood my mistake"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) Do this ```ans[i] = (int)(sum/(int)(2*k + 1))``` "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \\n`ans[i] = (int)(sum/(double)((2 * k) + 1));`\\nThis worked for some weird reason. Can someone please explain why? I don\\'t think the result would be different. 11 / 4 (both int by default) will give me 2 and  (int)(11 / (double) 4) will also be 2. So why this worked and why not the plain vanilla both int division?\\n "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \n`\nans[i] = (int) sum;\nans[i] /= (int) ((2 * k) + 1);\n`\n\ndid this but no change WA on test case 38"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "```\\nans = (convert to int) sum\\nans[i] /= (convert to int) ((2 * k) + 1);\\n``` "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Question description is so bad and understanding question was more difficult than actually solving it :)"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Straight forward sliding window\\n\\nspoiler:\\n\\n\\nwindow size is k * 2 + 1\\nuse  int64_t for window size"
                    },
                    {
                        "username": "aabhishekmishra",
                        "content": "Not medium, it should be an easy problem. Just think about brute force and modify your brute force algorithm just adding and subtracting an element  while you move forward."
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Guys, use long/double for summation."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Don\\'t know why they mark it as medium. Easy solution."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\n**Easy Solution C++. 2 pointer approach. Single traversal **\\n\\n# Approach\\n1. Start the function `getAverages` with parameters `nums` (a reference to a vector of integers) and `k` (an integer).\\n2. Set the variable `n` as the size of the `nums` vector.\\n3. If `k` is equal to 0, return the original `nums` vector.\\n4. Create a new vector `ans` with size `n` and initialize all elements to -1.\\n5. Calculate the value of `dia` as `2*k + 1`.\\n6. Initialize the variables `low` and `sum` to 0.\\n7. Iterate over the elements of `nums` from index 0 to index `n-1` using the variable `high`.\\n8. Inside the loop:\\n   - Add the value of `nums[high]` to the `sum`.\\n   - Check if the length of the current subarray, `(high-low+1)`, is equal to `dia`.\\n     - If it is, proceed with the following steps:\\n       - Calculate the index of the middle element as `mid` using `(high + low) / 2`.\\n       - Assign the average of the subarray, `sum/dia`, to `ans[mid]`.\\n       - Subtract the value of `nums[low]` from `sum`.\\n       - Increment the value of `low` by 1.\\n9. After the loop, return the resulting `ans` vector containing the averages of subarrays with length `dia`.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(N) single traversal\\n\\n- Space complexity:\\nS.C=O(1) No extra space\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/k-radius-subarray-averages/solutions/3660393/optimal-easy-solution-c-2-pointer-approach-single-traversal/"
                    }
                ]
            },
            {
                "id": 1936978,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "For those looking for a little more practice with sliding windows, this is a nice little primer: https://leetcode.com/problems/maximum-average-subarray-i/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "did anyone took care of k==0. I got wrong answer there \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I got correct on first run for that condition just return nums"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "my code is showing incorrect answer for 38th testcase. But I cant see where it is wrong as there are too many elements in the array and not all of them are visible. can someone tell me what am I supposed to do?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@Aditya1008](/Aditya1008) Most of the people got wrong op on 38th case. That is because of integer overflow. \nMake your \"sum\" variable long/double. \nThen for average, ans[i] = ```(int)(sum/(int)(2*k + 1))```\n\nIf you are using prefix sum method, use long[]"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "[@saikiran1s](/saikiran1s) if you dont mind, can I share my code with you? I did what you asked but still showing wrong output\\n"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Use long to store sum and also take care of type conversion while taking average\n```(int)(sum/(int)n)``` See the parenthesis"
                    },
                    {
                        "username": "psionl0",
                        "content": "It could be a problem with int. Try using long long for your summations."
                    },
                    {
                        "username": "aditya_mad",
                        "content": " `int size = nums.size();\n        vector<int> ans(size, -1);\n\n        if(size < (2 * k) + 1)\n        {\n            return ans;\n        }\n\n        long long int sum = 0;\n        for(int i = 0; i < (2 * k) + 1; i++)\n        {\n            sum += nums[i];\n        }\n        int left = 0, right = (2 * k) + 1;\n        for(int i = k; i < size - k; i++)\n        {\n            ans[i] = sum;\n            ans[i] /= ((2 * k) + 1);\n            if(i != size - k - 1)\n            {\n                sum -= nums[left++];\n                sum += nums[right++];\n            }     \n        }\n        return ans;`\nCan anyone help me with this is code. It is failing on test case 38\nI used sliding window of size (2* k + 1)"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) This is no different than ```ans[i] = (int)(sum/(int)(2*k + 1))``` coz dividing int(or long) by double leads to both numerator and denominator to be double. And the most outer (int) will convert that double to int. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) Thank man worked! Understood my mistake"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) Do this ```ans[i] = (int)(sum/(int)(2*k + 1))``` "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \\n`ans[i] = (int)(sum/(double)((2 * k) + 1));`\\nThis worked for some weird reason. Can someone please explain why? I don\\'t think the result would be different. 11 / 4 (both int by default) will give me 2 and  (int)(11 / (double) 4) will also be 2. So why this worked and why not the plain vanilla both int division?\\n "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \n`\nans[i] = (int) sum;\nans[i] /= (int) ((2 * k) + 1);\n`\n\ndid this but no change WA on test case 38"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "```\\nans = (convert to int) sum\\nans[i] /= (convert to int) ((2 * k) + 1);\\n``` "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Question description is so bad and understanding question was more difficult than actually solving it :)"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Straight forward sliding window\\n\\nspoiler:\\n\\n\\nwindow size is k * 2 + 1\\nuse  int64_t for window size"
                    },
                    {
                        "username": "aabhishekmishra",
                        "content": "Not medium, it should be an easy problem. Just think about brute force and modify your brute force algorithm just adding and subtracting an element  while you move forward."
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Guys, use long/double for summation."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Don\\'t know why they mark it as medium. Easy solution."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\n**Easy Solution C++. 2 pointer approach. Single traversal **\\n\\n# Approach\\n1. Start the function `getAverages` with parameters `nums` (a reference to a vector of integers) and `k` (an integer).\\n2. Set the variable `n` as the size of the `nums` vector.\\n3. If `k` is equal to 0, return the original `nums` vector.\\n4. Create a new vector `ans` with size `n` and initialize all elements to -1.\\n5. Calculate the value of `dia` as `2*k + 1`.\\n6. Initialize the variables `low` and `sum` to 0.\\n7. Iterate over the elements of `nums` from index 0 to index `n-1` using the variable `high`.\\n8. Inside the loop:\\n   - Add the value of `nums[high]` to the `sum`.\\n   - Check if the length of the current subarray, `(high-low+1)`, is equal to `dia`.\\n     - If it is, proceed with the following steps:\\n       - Calculate the index of the middle element as `mid` using `(high + low) / 2`.\\n       - Assign the average of the subarray, `sum/dia`, to `ans[mid]`.\\n       - Subtract the value of `nums[low]` from `sum`.\\n       - Increment the value of `low` by 1.\\n9. After the loop, return the resulting `ans` vector containing the averages of subarrays with length `dia`.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(N) single traversal\\n\\n- Space complexity:\\nS.C=O(1) No extra space\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/k-radius-subarray-averages/solutions/3660393/optimal-easy-solution-c-2-pointer-approach-single-traversal/"
                    }
                ]
            },
            {
                "id": 1936952,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "For those looking for a little more practice with sliding windows, this is a nice little primer: https://leetcode.com/problems/maximum-average-subarray-i/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "did anyone took care of k==0. I got wrong answer there \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I got correct on first run for that condition just return nums"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "my code is showing incorrect answer for 38th testcase. But I cant see where it is wrong as there are too many elements in the array and not all of them are visible. can someone tell me what am I supposed to do?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@Aditya1008](/Aditya1008) Most of the people got wrong op on 38th case. That is because of integer overflow. \nMake your \"sum\" variable long/double. \nThen for average, ans[i] = ```(int)(sum/(int)(2*k + 1))```\n\nIf you are using prefix sum method, use long[]"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "[@saikiran1s](/saikiran1s) if you dont mind, can I share my code with you? I did what you asked but still showing wrong output\\n"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Use long to store sum and also take care of type conversion while taking average\n```(int)(sum/(int)n)``` See the parenthesis"
                    },
                    {
                        "username": "psionl0",
                        "content": "It could be a problem with int. Try using long long for your summations."
                    },
                    {
                        "username": "aditya_mad",
                        "content": " `int size = nums.size();\n        vector<int> ans(size, -1);\n\n        if(size < (2 * k) + 1)\n        {\n            return ans;\n        }\n\n        long long int sum = 0;\n        for(int i = 0; i < (2 * k) + 1; i++)\n        {\n            sum += nums[i];\n        }\n        int left = 0, right = (2 * k) + 1;\n        for(int i = k; i < size - k; i++)\n        {\n            ans[i] = sum;\n            ans[i] /= ((2 * k) + 1);\n            if(i != size - k - 1)\n            {\n                sum -= nums[left++];\n                sum += nums[right++];\n            }     \n        }\n        return ans;`\nCan anyone help me with this is code. It is failing on test case 38\nI used sliding window of size (2* k + 1)"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) This is no different than ```ans[i] = (int)(sum/(int)(2*k + 1))``` coz dividing int(or long) by double leads to both numerator and denominator to be double. And the most outer (int) will convert that double to int. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) Thank man worked! Understood my mistake"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) Do this ```ans[i] = (int)(sum/(int)(2*k + 1))``` "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \\n`ans[i] = (int)(sum/(double)((2 * k) + 1));`\\nThis worked for some weird reason. Can someone please explain why? I don\\'t think the result would be different. 11 / 4 (both int by default) will give me 2 and  (int)(11 / (double) 4) will also be 2. So why this worked and why not the plain vanilla both int division?\\n "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \n`\nans[i] = (int) sum;\nans[i] /= (int) ((2 * k) + 1);\n`\n\ndid this but no change WA on test case 38"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "```\\nans = (convert to int) sum\\nans[i] /= (convert to int) ((2 * k) + 1);\\n``` "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Question description is so bad and understanding question was more difficult than actually solving it :)"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Straight forward sliding window\\n\\nspoiler:\\n\\n\\nwindow size is k * 2 + 1\\nuse  int64_t for window size"
                    },
                    {
                        "username": "aabhishekmishra",
                        "content": "Not medium, it should be an easy problem. Just think about brute force and modify your brute force algorithm just adding and subtracting an element  while you move forward."
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Guys, use long/double for summation."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Don\\'t know why they mark it as medium. Easy solution."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\n**Easy Solution C++. 2 pointer approach. Single traversal **\\n\\n# Approach\\n1. Start the function `getAverages` with parameters `nums` (a reference to a vector of integers) and `k` (an integer).\\n2. Set the variable `n` as the size of the `nums` vector.\\n3. If `k` is equal to 0, return the original `nums` vector.\\n4. Create a new vector `ans` with size `n` and initialize all elements to -1.\\n5. Calculate the value of `dia` as `2*k + 1`.\\n6. Initialize the variables `low` and `sum` to 0.\\n7. Iterate over the elements of `nums` from index 0 to index `n-1` using the variable `high`.\\n8. Inside the loop:\\n   - Add the value of `nums[high]` to the `sum`.\\n   - Check if the length of the current subarray, `(high-low+1)`, is equal to `dia`.\\n     - If it is, proceed with the following steps:\\n       - Calculate the index of the middle element as `mid` using `(high + low) / 2`.\\n       - Assign the average of the subarray, `sum/dia`, to `ans[mid]`.\\n       - Subtract the value of `nums[low]` from `sum`.\\n       - Increment the value of `low` by 1.\\n9. After the loop, return the resulting `ans` vector containing the averages of subarrays with length `dia`.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(N) single traversal\\n\\n- Space complexity:\\nS.C=O(1) No extra space\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/k-radius-subarray-averages/solutions/3660393/optimal-easy-solution-c-2-pointer-approach-single-traversal/"
                    }
                ]
            },
            {
                "id": 1936903,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "For those looking for a little more practice with sliding windows, this is a nice little primer: https://leetcode.com/problems/maximum-average-subarray-i/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "did anyone took care of k==0. I got wrong answer there \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I got correct on first run for that condition just return nums"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "my code is showing incorrect answer for 38th testcase. But I cant see where it is wrong as there are too many elements in the array and not all of them are visible. can someone tell me what am I supposed to do?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@Aditya1008](/Aditya1008) Most of the people got wrong op on 38th case. That is because of integer overflow. \nMake your \"sum\" variable long/double. \nThen for average, ans[i] = ```(int)(sum/(int)(2*k + 1))```\n\nIf you are using prefix sum method, use long[]"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "[@saikiran1s](/saikiran1s) if you dont mind, can I share my code with you? I did what you asked but still showing wrong output\\n"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Use long to store sum and also take care of type conversion while taking average\n```(int)(sum/(int)n)``` See the parenthesis"
                    },
                    {
                        "username": "psionl0",
                        "content": "It could be a problem with int. Try using long long for your summations."
                    },
                    {
                        "username": "aditya_mad",
                        "content": " `int size = nums.size();\n        vector<int> ans(size, -1);\n\n        if(size < (2 * k) + 1)\n        {\n            return ans;\n        }\n\n        long long int sum = 0;\n        for(int i = 0; i < (2 * k) + 1; i++)\n        {\n            sum += nums[i];\n        }\n        int left = 0, right = (2 * k) + 1;\n        for(int i = k; i < size - k; i++)\n        {\n            ans[i] = sum;\n            ans[i] /= ((2 * k) + 1);\n            if(i != size - k - 1)\n            {\n                sum -= nums[left++];\n                sum += nums[right++];\n            }     \n        }\n        return ans;`\nCan anyone help me with this is code. It is failing on test case 38\nI used sliding window of size (2* k + 1)"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) This is no different than ```ans[i] = (int)(sum/(int)(2*k + 1))``` coz dividing int(or long) by double leads to both numerator and denominator to be double. And the most outer (int) will convert that double to int. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) Thank man worked! Understood my mistake"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) Do this ```ans[i] = (int)(sum/(int)(2*k + 1))``` "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \\n`ans[i] = (int)(sum/(double)((2 * k) + 1));`\\nThis worked for some weird reason. Can someone please explain why? I don\\'t think the result would be different. 11 / 4 (both int by default) will give me 2 and  (int)(11 / (double) 4) will also be 2. So why this worked and why not the plain vanilla both int division?\\n "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \n`\nans[i] = (int) sum;\nans[i] /= (int) ((2 * k) + 1);\n`\n\ndid this but no change WA on test case 38"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "```\\nans = (convert to int) sum\\nans[i] /= (convert to int) ((2 * k) + 1);\\n``` "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Question description is so bad and understanding question was more difficult than actually solving it :)"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Straight forward sliding window\\n\\nspoiler:\\n\\n\\nwindow size is k * 2 + 1\\nuse  int64_t for window size"
                    },
                    {
                        "username": "aabhishekmishra",
                        "content": "Not medium, it should be an easy problem. Just think about brute force and modify your brute force algorithm just adding and subtracting an element  while you move forward."
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Guys, use long/double for summation."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Don\\'t know why they mark it as medium. Easy solution."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\n**Easy Solution C++. 2 pointer approach. Single traversal **\\n\\n# Approach\\n1. Start the function `getAverages` with parameters `nums` (a reference to a vector of integers) and `k` (an integer).\\n2. Set the variable `n` as the size of the `nums` vector.\\n3. If `k` is equal to 0, return the original `nums` vector.\\n4. Create a new vector `ans` with size `n` and initialize all elements to -1.\\n5. Calculate the value of `dia` as `2*k + 1`.\\n6. Initialize the variables `low` and `sum` to 0.\\n7. Iterate over the elements of `nums` from index 0 to index `n-1` using the variable `high`.\\n8. Inside the loop:\\n   - Add the value of `nums[high]` to the `sum`.\\n   - Check if the length of the current subarray, `(high-low+1)`, is equal to `dia`.\\n     - If it is, proceed with the following steps:\\n       - Calculate the index of the middle element as `mid` using `(high + low) / 2`.\\n       - Assign the average of the subarray, `sum/dia`, to `ans[mid]`.\\n       - Subtract the value of `nums[low]` from `sum`.\\n       - Increment the value of `low` by 1.\\n9. After the loop, return the resulting `ans` vector containing the averages of subarrays with length `dia`.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(N) single traversal\\n\\n- Space complexity:\\nS.C=O(1) No extra space\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/k-radius-subarray-averages/solutions/3660393/optimal-easy-solution-c-2-pointer-approach-single-traversal/"
                    }
                ]
            },
            {
                "id": 1936901,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "For those looking for a little more practice with sliding windows, this is a nice little primer: https://leetcode.com/problems/maximum-average-subarray-i/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "did anyone took care of k==0. I got wrong answer there \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I got correct on first run for that condition just return nums"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "my code is showing incorrect answer for 38th testcase. But I cant see where it is wrong as there are too many elements in the array and not all of them are visible. can someone tell me what am I supposed to do?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@Aditya1008](/Aditya1008) Most of the people got wrong op on 38th case. That is because of integer overflow. \nMake your \"sum\" variable long/double. \nThen for average, ans[i] = ```(int)(sum/(int)(2*k + 1))```\n\nIf you are using prefix sum method, use long[]"
                    },
                    {
                        "username": "Aditya1008",
                        "content": "[@saikiran1s](/saikiran1s) if you dont mind, can I share my code with you? I did what you asked but still showing wrong output\\n"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Use long to store sum and also take care of type conversion while taking average\n```(int)(sum/(int)n)``` See the parenthesis"
                    },
                    {
                        "username": "psionl0",
                        "content": "It could be a problem with int. Try using long long for your summations."
                    },
                    {
                        "username": "aditya_mad",
                        "content": " `int size = nums.size();\n        vector<int> ans(size, -1);\n\n        if(size < (2 * k) + 1)\n        {\n            return ans;\n        }\n\n        long long int sum = 0;\n        for(int i = 0; i < (2 * k) + 1; i++)\n        {\n            sum += nums[i];\n        }\n        int left = 0, right = (2 * k) + 1;\n        for(int i = k; i < size - k; i++)\n        {\n            ans[i] = sum;\n            ans[i] /= ((2 * k) + 1);\n            if(i != size - k - 1)\n            {\n                sum -= nums[left++];\n                sum += nums[right++];\n            }     \n        }\n        return ans;`\nCan anyone help me with this is code. It is failing on test case 38\nI used sliding window of size (2* k + 1)"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) This is no different than ```ans[i] = (int)(sum/(int)(2*k + 1))``` coz dividing int(or long) by double leads to both numerator and denominator to be double. And the most outer (int) will convert that double to int. "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) Thank man worked! Understood my mistake"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "[@aditya_mad](/aditya_mad) Do this ```ans[i] = (int)(sum/(int)(2*k + 1))``` "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \\n`ans[i] = (int)(sum/(double)((2 * k) + 1));`\\nThis worked for some weird reason. Can someone please explain why? I don\\'t think the result would be different. 11 / 4 (both int by default) will give me 2 and  (int)(11 / (double) 4) will also be 2. So why this worked and why not the plain vanilla both int division?\\n "
                    },
                    {
                        "username": "aditya_mad",
                        "content": "[@saikiran1s](/saikiran1s) \n`\nans[i] = (int) sum;\nans[i] /= (int) ((2 * k) + 1);\n`\n\ndid this but no change WA on test case 38"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "```\\nans = (convert to int) sum\\nans[i] /= (convert to int) ((2 * k) + 1);\\n``` "
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "Question description is so bad and understanding question was more difficult than actually solving it :)"
                    },
                    {
                        "username": "andrewseva",
                        "content": "Straight forward sliding window\\n\\nspoiler:\\n\\n\\nwindow size is k * 2 + 1\\nuse  int64_t for window size"
                    },
                    {
                        "username": "aabhishekmishra",
                        "content": "Not medium, it should be an easy problem. Just think about brute force and modify your brute force algorithm just adding and subtracting an element  while you move forward."
                    },
                    {
                        "username": "saikiran1s",
                        "content": "Guys, use long/double for summation."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Don\\'t know why they mark it as medium. Easy solution."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\n**Easy Solution C++. 2 pointer approach. Single traversal **\\n\\n# Approach\\n1. Start the function `getAverages` with parameters `nums` (a reference to a vector of integers) and `k` (an integer).\\n2. Set the variable `n` as the size of the `nums` vector.\\n3. If `k` is equal to 0, return the original `nums` vector.\\n4. Create a new vector `ans` with size `n` and initialize all elements to -1.\\n5. Calculate the value of `dia` as `2*k + 1`.\\n6. Initialize the variables `low` and `sum` to 0.\\n7. Iterate over the elements of `nums` from index 0 to index `n-1` using the variable `high`.\\n8. Inside the loop:\\n   - Add the value of `nums[high]` to the `sum`.\\n   - Check if the length of the current subarray, `(high-low+1)`, is equal to `dia`.\\n     - If it is, proceed with the following steps:\\n       - Calculate the index of the middle element as `mid` using `(high + low) / 2`.\\n       - Assign the average of the subarray, `sum/dia`, to `ans[mid]`.\\n       - Subtract the value of `nums[low]` from `sum`.\\n       - Increment the value of `low` by 1.\\n9. After the loop, return the resulting `ans` vector containing the averages of subarrays with length `dia`.\\n\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(N) single traversal\\n\\n- Space complexity:\\nS.C=O(1) No extra space\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/k-radius-subarray-averages/solutions/3660393/optimal-easy-solution-c-2-pointer-approach-single-traversal/"
                    }
                ]
            },
            {
                "id": 1936889,
                "content": [
                    {
                        "username": "vivekkumarshiv",
                        "content": "beware of 37th testcase"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Should be an easy problem, leetcode\\'s tagging sometimes a joke"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I can think of 3 ways of doing this problem: -\\n1. Plain ol\\' **Bruteforce**(**TLE\\'d\\'**).\\n2. Simple **Sliding-window of size 2*K+1**\\n3. Using  **Prefix -Sum array** and for each **i**th element check whether **i+k** and **i-k** are within bounds or not, and then update answer accordingly.\\n\\nIf there are other solutions please let me know !!"
                    },
                    {
                        "username": "chenming0317",
                        "content": "happy 38"
                    },
                    {
                        "username": "aditi61",
                        "content": "vector<int> getAverages(vector<int>& nums, int k) {\\n        int sum =0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i,p=i;i-j<=k&&p-i<=k;j--,p++){\\n                if(i-k<0||i+k>nums.size()-1)v.push_back(-1);\\n                sum+=nums[j];\\n                sum+=nums[p];\\n                v.push_back(sum/(2*k+1));\\n\\n            }           \\n        }\\n        return v;\\n        \\n    }\\nwhat is wrong in this"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "use long for the storing the sum"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "This types of questions looks hard to the beginner but believe me once you started solving you can solve easily"
                    },
                    {
                        "username": "najwer23",
                        "content": "TLE TLE TLE TLE.."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "The problem looks difficult, but it\\'s not hard to do."
                    },
                    {
                        "username": "mahesh_rayavarapu",
                        "content": "anyone using python to solve the problem?  For the case k=62638 [36464.....], I got 388 ms of runtime and then I got stuck with k=40000 [100000....] test case as the runtime is exceeding 3380ms. I tried using numpy as well..... :-("
                    }
                ]
            },
            {
                "id": 1936878,
                "content": [
                    {
                        "username": "vivekkumarshiv",
                        "content": "beware of 37th testcase"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Should be an easy problem, leetcode\\'s tagging sometimes a joke"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I can think of 3 ways of doing this problem: -\\n1. Plain ol\\' **Bruteforce**(**TLE\\'d\\'**).\\n2. Simple **Sliding-window of size 2*K+1**\\n3. Using  **Prefix -Sum array** and for each **i**th element check whether **i+k** and **i-k** are within bounds or not, and then update answer accordingly.\\n\\nIf there are other solutions please let me know !!"
                    },
                    {
                        "username": "chenming0317",
                        "content": "happy 38"
                    },
                    {
                        "username": "aditi61",
                        "content": "vector<int> getAverages(vector<int>& nums, int k) {\\n        int sum =0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i,p=i;i-j<=k&&p-i<=k;j--,p++){\\n                if(i-k<0||i+k>nums.size()-1)v.push_back(-1);\\n                sum+=nums[j];\\n                sum+=nums[p];\\n                v.push_back(sum/(2*k+1));\\n\\n            }           \\n        }\\n        return v;\\n        \\n    }\\nwhat is wrong in this"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "use long for the storing the sum"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "This types of questions looks hard to the beginner but believe me once you started solving you can solve easily"
                    },
                    {
                        "username": "najwer23",
                        "content": "TLE TLE TLE TLE.."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "The problem looks difficult, but it\\'s not hard to do."
                    },
                    {
                        "username": "mahesh_rayavarapu",
                        "content": "anyone using python to solve the problem?  For the case k=62638 [36464.....], I got 388 ms of runtime and then I got stuck with k=40000 [100000....] test case as the runtime is exceeding 3380ms. I tried using numpy as well..... :-("
                    }
                ]
            },
            {
                "id": 1936845,
                "content": [
                    {
                        "username": "vivekkumarshiv",
                        "content": "beware of 37th testcase"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Should be an easy problem, leetcode\\'s tagging sometimes a joke"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I can think of 3 ways of doing this problem: -\\n1. Plain ol\\' **Bruteforce**(**TLE\\'d\\'**).\\n2. Simple **Sliding-window of size 2*K+1**\\n3. Using  **Prefix -Sum array** and for each **i**th element check whether **i+k** and **i-k** are within bounds or not, and then update answer accordingly.\\n\\nIf there are other solutions please let me know !!"
                    },
                    {
                        "username": "chenming0317",
                        "content": "happy 38"
                    },
                    {
                        "username": "aditi61",
                        "content": "vector<int> getAverages(vector<int>& nums, int k) {\\n        int sum =0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i,p=i;i-j<=k&&p-i<=k;j--,p++){\\n                if(i-k<0||i+k>nums.size()-1)v.push_back(-1);\\n                sum+=nums[j];\\n                sum+=nums[p];\\n                v.push_back(sum/(2*k+1));\\n\\n            }           \\n        }\\n        return v;\\n        \\n    }\\nwhat is wrong in this"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "use long for the storing the sum"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "This types of questions looks hard to the beginner but believe me once you started solving you can solve easily"
                    },
                    {
                        "username": "najwer23",
                        "content": "TLE TLE TLE TLE.."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "The problem looks difficult, but it\\'s not hard to do."
                    },
                    {
                        "username": "mahesh_rayavarapu",
                        "content": "anyone using python to solve the problem?  For the case k=62638 [36464.....], I got 388 ms of runtime and then I got stuck with k=40000 [100000....] test case as the runtime is exceeding 3380ms. I tried using numpy as well..... :-("
                    }
                ]
            },
            {
                "id": 1936844,
                "content": [
                    {
                        "username": "vivekkumarshiv",
                        "content": "beware of 37th testcase"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Should be an easy problem, leetcode\\'s tagging sometimes a joke"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I can think of 3 ways of doing this problem: -\\n1. Plain ol\\' **Bruteforce**(**TLE\\'d\\'**).\\n2. Simple **Sliding-window of size 2*K+1**\\n3. Using  **Prefix -Sum array** and for each **i**th element check whether **i+k** and **i-k** are within bounds or not, and then update answer accordingly.\\n\\nIf there are other solutions please let me know !!"
                    },
                    {
                        "username": "chenming0317",
                        "content": "happy 38"
                    },
                    {
                        "username": "aditi61",
                        "content": "vector<int> getAverages(vector<int>& nums, int k) {\\n        int sum =0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i,p=i;i-j<=k&&p-i<=k;j--,p++){\\n                if(i-k<0||i+k>nums.size()-1)v.push_back(-1);\\n                sum+=nums[j];\\n                sum+=nums[p];\\n                v.push_back(sum/(2*k+1));\\n\\n            }           \\n        }\\n        return v;\\n        \\n    }\\nwhat is wrong in this"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "use long for the storing the sum"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "This types of questions looks hard to the beginner but believe me once you started solving you can solve easily"
                    },
                    {
                        "username": "najwer23",
                        "content": "TLE TLE TLE TLE.."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "The problem looks difficult, but it\\'s not hard to do."
                    },
                    {
                        "username": "mahesh_rayavarapu",
                        "content": "anyone using python to solve the problem?  For the case k=62638 [36464.....], I got 388 ms of runtime and then I got stuck with k=40000 [100000....] test case as the runtime is exceeding 3380ms. I tried using numpy as well..... :-("
                    }
                ]
            },
            {
                "id": 1936817,
                "content": [
                    {
                        "username": "vivekkumarshiv",
                        "content": "beware of 37th testcase"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Should be an easy problem, leetcode\\'s tagging sometimes a joke"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I can think of 3 ways of doing this problem: -\\n1. Plain ol\\' **Bruteforce**(**TLE\\'d\\'**).\\n2. Simple **Sliding-window of size 2*K+1**\\n3. Using  **Prefix -Sum array** and for each **i**th element check whether **i+k** and **i-k** are within bounds or not, and then update answer accordingly.\\n\\nIf there are other solutions please let me know !!"
                    },
                    {
                        "username": "chenming0317",
                        "content": "happy 38"
                    },
                    {
                        "username": "aditi61",
                        "content": "vector<int> getAverages(vector<int>& nums, int k) {\\n        int sum =0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i,p=i;i-j<=k&&p-i<=k;j--,p++){\\n                if(i-k<0||i+k>nums.size()-1)v.push_back(-1);\\n                sum+=nums[j];\\n                sum+=nums[p];\\n                v.push_back(sum/(2*k+1));\\n\\n            }           \\n        }\\n        return v;\\n        \\n    }\\nwhat is wrong in this"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "use long for the storing the sum"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "This types of questions looks hard to the beginner but believe me once you started solving you can solve easily"
                    },
                    {
                        "username": "najwer23",
                        "content": "TLE TLE TLE TLE.."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "The problem looks difficult, but it\\'s not hard to do."
                    },
                    {
                        "username": "mahesh_rayavarapu",
                        "content": "anyone using python to solve the problem?  For the case k=62638 [36464.....], I got 388 ms of runtime and then I got stuck with k=40000 [100000....] test case as the runtime is exceeding 3380ms. I tried using numpy as well..... :-("
                    }
                ]
            },
            {
                "id": 1936780,
                "content": [
                    {
                        "username": "vivekkumarshiv",
                        "content": "beware of 37th testcase"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Should be an easy problem, leetcode\\'s tagging sometimes a joke"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I can think of 3 ways of doing this problem: -\\n1. Plain ol\\' **Bruteforce**(**TLE\\'d\\'**).\\n2. Simple **Sliding-window of size 2*K+1**\\n3. Using  **Prefix -Sum array** and for each **i**th element check whether **i+k** and **i-k** are within bounds or not, and then update answer accordingly.\\n\\nIf there are other solutions please let me know !!"
                    },
                    {
                        "username": "chenming0317",
                        "content": "happy 38"
                    },
                    {
                        "username": "aditi61",
                        "content": "vector<int> getAverages(vector<int>& nums, int k) {\\n        int sum =0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i,p=i;i-j<=k&&p-i<=k;j--,p++){\\n                if(i-k<0||i+k>nums.size()-1)v.push_back(-1);\\n                sum+=nums[j];\\n                sum+=nums[p];\\n                v.push_back(sum/(2*k+1));\\n\\n            }           \\n        }\\n        return v;\\n        \\n    }\\nwhat is wrong in this"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "use long for the storing the sum"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "This types of questions looks hard to the beginner but believe me once you started solving you can solve easily"
                    },
                    {
                        "username": "najwer23",
                        "content": "TLE TLE TLE TLE.."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "The problem looks difficult, but it\\'s not hard to do."
                    },
                    {
                        "username": "mahesh_rayavarapu",
                        "content": "anyone using python to solve the problem?  For the case k=62638 [36464.....], I got 388 ms of runtime and then I got stuck with k=40000 [100000....] test case as the runtime is exceeding 3380ms. I tried using numpy as well..... :-("
                    }
                ]
            },
            {
                "id": 1936778,
                "content": [
                    {
                        "username": "vivekkumarshiv",
                        "content": "beware of 37th testcase"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Should be an easy problem, leetcode\\'s tagging sometimes a joke"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I can think of 3 ways of doing this problem: -\\n1. Plain ol\\' **Bruteforce**(**TLE\\'d\\'**).\\n2. Simple **Sliding-window of size 2*K+1**\\n3. Using  **Prefix -Sum array** and for each **i**th element check whether **i+k** and **i-k** are within bounds or not, and then update answer accordingly.\\n\\nIf there are other solutions please let me know !!"
                    },
                    {
                        "username": "chenming0317",
                        "content": "happy 38"
                    },
                    {
                        "username": "aditi61",
                        "content": "vector<int> getAverages(vector<int>& nums, int k) {\\n        int sum =0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i,p=i;i-j<=k&&p-i<=k;j--,p++){\\n                if(i-k<0||i+k>nums.size()-1)v.push_back(-1);\\n                sum+=nums[j];\\n                sum+=nums[p];\\n                v.push_back(sum/(2*k+1));\\n\\n            }           \\n        }\\n        return v;\\n        \\n    }\\nwhat is wrong in this"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "use long for the storing the sum"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "This types of questions looks hard to the beginner but believe me once you started solving you can solve easily"
                    },
                    {
                        "username": "najwer23",
                        "content": "TLE TLE TLE TLE.."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "The problem looks difficult, but it\\'s not hard to do."
                    },
                    {
                        "username": "mahesh_rayavarapu",
                        "content": "anyone using python to solve the problem?  For the case k=62638 [36464.....], I got 388 ms of runtime and then I got stuck with k=40000 [100000....] test case as the runtime is exceeding 3380ms. I tried using numpy as well..... :-("
                    }
                ]
            },
            {
                "id": 1936771,
                "content": [
                    {
                        "username": "vivekkumarshiv",
                        "content": "beware of 37th testcase"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Should be an easy problem, leetcode\\'s tagging sometimes a joke"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I can think of 3 ways of doing this problem: -\\n1. Plain ol\\' **Bruteforce**(**TLE\\'d\\'**).\\n2. Simple **Sliding-window of size 2*K+1**\\n3. Using  **Prefix -Sum array** and for each **i**th element check whether **i+k** and **i-k** are within bounds or not, and then update answer accordingly.\\n\\nIf there are other solutions please let me know !!"
                    },
                    {
                        "username": "chenming0317",
                        "content": "happy 38"
                    },
                    {
                        "username": "aditi61",
                        "content": "vector<int> getAverages(vector<int>& nums, int k) {\\n        int sum =0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i,p=i;i-j<=k&&p-i<=k;j--,p++){\\n                if(i-k<0||i+k>nums.size()-1)v.push_back(-1);\\n                sum+=nums[j];\\n                sum+=nums[p];\\n                v.push_back(sum/(2*k+1));\\n\\n            }           \\n        }\\n        return v;\\n        \\n    }\\nwhat is wrong in this"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "use long for the storing the sum"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "This types of questions looks hard to the beginner but believe me once you started solving you can solve easily"
                    },
                    {
                        "username": "najwer23",
                        "content": "TLE TLE TLE TLE.."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "The problem looks difficult, but it\\'s not hard to do."
                    },
                    {
                        "username": "mahesh_rayavarapu",
                        "content": "anyone using python to solve the problem?  For the case k=62638 [36464.....], I got 388 ms of runtime and then I got stuck with k=40000 [100000....] test case as the runtime is exceeding 3380ms. I tried using numpy as well..... :-("
                    }
                ]
            },
            {
                "id": 1936770,
                "content": [
                    {
                        "username": "vivekkumarshiv",
                        "content": "beware of 37th testcase"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Should be an easy problem, leetcode\\'s tagging sometimes a joke"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I can think of 3 ways of doing this problem: -\\n1. Plain ol\\' **Bruteforce**(**TLE\\'d\\'**).\\n2. Simple **Sliding-window of size 2*K+1**\\n3. Using  **Prefix -Sum array** and for each **i**th element check whether **i+k** and **i-k** are within bounds or not, and then update answer accordingly.\\n\\nIf there are other solutions please let me know !!"
                    },
                    {
                        "username": "chenming0317",
                        "content": "happy 38"
                    },
                    {
                        "username": "aditi61",
                        "content": "vector<int> getAverages(vector<int>& nums, int k) {\\n        int sum =0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i,p=i;i-j<=k&&p-i<=k;j--,p++){\\n                if(i-k<0||i+k>nums.size()-1)v.push_back(-1);\\n                sum+=nums[j];\\n                sum+=nums[p];\\n                v.push_back(sum/(2*k+1));\\n\\n            }           \\n        }\\n        return v;\\n        \\n    }\\nwhat is wrong in this"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "use long for the storing the sum"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "This types of questions looks hard to the beginner but believe me once you started solving you can solve easily"
                    },
                    {
                        "username": "najwer23",
                        "content": "TLE TLE TLE TLE.."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "The problem looks difficult, but it\\'s not hard to do."
                    },
                    {
                        "username": "mahesh_rayavarapu",
                        "content": "anyone using python to solve the problem?  For the case k=62638 [36464.....], I got 388 ms of runtime and then I got stuck with k=40000 [100000....] test case as the runtime is exceeding 3380ms. I tried using numpy as well..... :-("
                    }
                ]
            },
            {
                "id": 1936694,
                "content": [
                    {
                        "username": "vivekkumarshiv",
                        "content": "beware of 37th testcase"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Should be an easy problem, leetcode\\'s tagging sometimes a joke"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "I can think of 3 ways of doing this problem: -\\n1. Plain ol\\' **Bruteforce**(**TLE\\'d\\'**).\\n2. Simple **Sliding-window of size 2*K+1**\\n3. Using  **Prefix -Sum array** and for each **i**th element check whether **i+k** and **i-k** are within bounds or not, and then update answer accordingly.\\n\\nIf there are other solutions please let me know !!"
                    },
                    {
                        "username": "chenming0317",
                        "content": "happy 38"
                    },
                    {
                        "username": "aditi61",
                        "content": "vector<int> getAverages(vector<int>& nums, int k) {\\n        int sum =0;\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i,p=i;i-j<=k&&p-i<=k;j--,p++){\\n                if(i-k<0||i+k>nums.size()-1)v.push_back(-1);\\n                sum+=nums[j];\\n                sum+=nums[p];\\n                v.push_back(sum/(2*k+1));\\n\\n            }           \\n        }\\n        return v;\\n        \\n    }\\nwhat is wrong in this"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "use long for the storing the sum"
                    },
                    {
                        "username": "Kapilbhai_Gohil",
                        "content": "This types of questions looks hard to the beginner but believe me once you started solving you can solve easily"
                    },
                    {
                        "username": "najwer23",
                        "content": "TLE TLE TLE TLE.."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "The problem looks difficult, but it\\'s not hard to do."
                    },
                    {
                        "username": "mahesh_rayavarapu",
                        "content": "anyone using python to solve the problem?  For the case k=62638 [36464.....], I got 388 ms of runtime and then I got stuck with k=40000 [100000....] test case as the runtime is exceeding 3380ms. I tried using numpy as well..... :-("
                    }
                ]
            },
            {
                "id": 1936678,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "Who gave up after seeing TLE for final test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "With a sliding window, this should have a O(N) run time."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Is cpp on drugs or what??\nwith cout, I checked, and output was 60092, but when it was stored in vector, it was stored 60091, what the hell, I don't even know how to solve this issue.\n\nInput\nnums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk =\n1 \nStdout\n60147.7 43496.7 *60092* 67396.3 80633.3 49974 \nOutput\n[-1,60147,43496,60091,67396,80633,49974,38542,-1]\nExpected\n[-1,60147,43496,60092,67396,80633,49974,38542,-1]\n\n`class Solution {\npublic:\n    vector<int> getAverages(vector<int>& nums, int k) {\n        if (!k)\n            return nums;\n        int size = nums.size();\n        vector<int> average(size, -1);\n\n        if (2 * k >= size)\n            return average;\n        \n        double avg = 0.0, den = 2.0 * k + 1;\n\n        for(int i = 0; i <= 2*k; i++)\n            avg += nums[i]/den;\n\n        for(int i = k; i < size; i++) {\n            average[i] = avg;\n            if (i+k+1 >= size)\n                break;\n            \n            cout << avg << \" \";\n            avg -= nums[i-k]/den;\n            avg += nums[i+k+1]/den;\n        }\n\n        return average;\n    }\n};`"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) Use long long instead."
                    },
                    {
                        "username": "EricRaw",
                        "content": "it's because, when you assign the avg value (which is a double) to average[i] (which is a int) , the decimal portion gets truncated\n\nwhen showing the decimal portion of the avg\n```\nstd::cout << std::setprecision(20) << avg << \" \";\n```\nyou can see the avg value is 60091.999999999992724 (not 60092) which when truncated become 60091\n\nwhich is why i hate typecast double to int"
                    },
                    {
                        "username": "nkBrew",
                        "content": "For those getting all the starting test cases correct but getting timelimit exceeded errors at around testcase 17:\\n\\nRemember that built in sum() methods are additional loops that add time. You have the right idea, but instead of being lazy I\\'m afraid we\\'ll have to use... MATH!"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Legit why is there a really long solution with ten thousands elements all the same?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Anyone can tell me why answer like this will result in a wrong answer:\\nint[] ans = new int[N];\\nlong[] sum = new long[N];\\n...\\nfor(...){\\n   ans[i] = (int) (using sum to calculate..)\\n}\\nBut if I use :\\nlong temp = (using sum to calculate..)\\nans[i] = (int) temp\\nit will be ok\\nThank you"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@EricRaw](/EricRaw) Yes,It solved, thank u so much!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "maybe because of how you typecast?\n\nans[i] = (int) (a * b) / 2;\nis different than\nans[i] = (int) ((a * b) / 2);"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you should debug to see it your own, no one can giving correct solution by guesting what you had coding, and other thing may helpful, as i see, there is no diffrent, in almost case both long & int are same type with size 4 byte (c++)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Sliding Window (need I say more?)."
                    },
                    {
                        "username": "dle2",
                        "content": "should be easy type"
                    },
                    {
                        "username": "skyday123",
                        "content": "# long! long! long! "
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    \\n    long long sum = 0;\\n    int i,j,c;\\n    long long n=nums.size();\\n    vector<int> res;  \\n    \\n\\n    //if(k>nums.size()) return res;\\n\\n    for(i=0;i<2*k+1;i++) sum += nums[i];\\n    res[k] = (int)(sum/(2*k+1));\\n\\n    for(i=0,j=2*k+1,c=k+1;j<nums.size();c++,j++,i++){\\n        sum += (nums[j]-nums[i]);\\n        res[c] = (int)(sum/(2*k+1));\\n    }\\n    return res;\\n    }\\n};\\ncan anyone find out what i am making mistake?\\n\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "c will start from k, not k+1"
                    },
                    {
                        "username": "addision_007",
                        "content": "you have to focus on few edge cases like :\\n1 :  initialize your output vector with -1.\\n2 : if no. of elements in given vector be less than the given k-radius.\\n3 :  create the window .\\n4:  while creating window take sum of all elements .\\n5: than for let i==k to i<n-k. store the sum and expand the end of window, and shirk by the start of window.\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int i=0;\\n      int j=0;\\n      long long n=nums.size();\\n      long long sum=0;\\n      vector<int>v(n,-1);\\n      if(n<(2*k+1))\\n      {\\n          \\n           return v;\\n      }\\n      if(k==0)\\n      {\\n          return nums;\\n      }\\n      while(j<2*k+1)\\n      {\\n          sum=sum+nums[j];\\n          if(i<k)\\n          {\\n              i++;\\n          }\\n          j++;\\n      }\\n       if(i==k)\\n         v[i]=sum/(2*k+1);\\n      while(j<n && i<n)\\n      {\\n          sum=sum+nums[j];\\n          sum-=nums[i-k];\\n          \\n          if(i<n-k)\\n          {\\n              i++;\\n          v[i]=sum/(2*k+1);\\n          }\\n          \\n          j++;\\n        \\n      }\\n     \\n      return v;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1936677,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "Who gave up after seeing TLE for final test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "With a sliding window, this should have a O(N) run time."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Is cpp on drugs or what??\nwith cout, I checked, and output was 60092, but when it was stored in vector, it was stored 60091, what the hell, I don't even know how to solve this issue.\n\nInput\nnums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk =\n1 \nStdout\n60147.7 43496.7 *60092* 67396.3 80633.3 49974 \nOutput\n[-1,60147,43496,60091,67396,80633,49974,38542,-1]\nExpected\n[-1,60147,43496,60092,67396,80633,49974,38542,-1]\n\n`class Solution {\npublic:\n    vector<int> getAverages(vector<int>& nums, int k) {\n        if (!k)\n            return nums;\n        int size = nums.size();\n        vector<int> average(size, -1);\n\n        if (2 * k >= size)\n            return average;\n        \n        double avg = 0.0, den = 2.0 * k + 1;\n\n        for(int i = 0; i <= 2*k; i++)\n            avg += nums[i]/den;\n\n        for(int i = k; i < size; i++) {\n            average[i] = avg;\n            if (i+k+1 >= size)\n                break;\n            \n            cout << avg << \" \";\n            avg -= nums[i-k]/den;\n            avg += nums[i+k+1]/den;\n        }\n\n        return average;\n    }\n};`"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) Use long long instead."
                    },
                    {
                        "username": "EricRaw",
                        "content": "it's because, when you assign the avg value (which is a double) to average[i] (which is a int) , the decimal portion gets truncated\n\nwhen showing the decimal portion of the avg\n```\nstd::cout << std::setprecision(20) << avg << \" \";\n```\nyou can see the avg value is 60091.999999999992724 (not 60092) which when truncated become 60091\n\nwhich is why i hate typecast double to int"
                    },
                    {
                        "username": "nkBrew",
                        "content": "For those getting all the starting test cases correct but getting timelimit exceeded errors at around testcase 17:\\n\\nRemember that built in sum() methods are additional loops that add time. You have the right idea, but instead of being lazy I\\'m afraid we\\'ll have to use... MATH!"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Legit why is there a really long solution with ten thousands elements all the same?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Anyone can tell me why answer like this will result in a wrong answer:\\nint[] ans = new int[N];\\nlong[] sum = new long[N];\\n...\\nfor(...){\\n   ans[i] = (int) (using sum to calculate..)\\n}\\nBut if I use :\\nlong temp = (using sum to calculate..)\\nans[i] = (int) temp\\nit will be ok\\nThank you"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@EricRaw](/EricRaw) Yes,It solved, thank u so much!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "maybe because of how you typecast?\n\nans[i] = (int) (a * b) / 2;\nis different than\nans[i] = (int) ((a * b) / 2);"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you should debug to see it your own, no one can giving correct solution by guesting what you had coding, and other thing may helpful, as i see, there is no diffrent, in almost case both long & int are same type with size 4 byte (c++)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Sliding Window (need I say more?)."
                    },
                    {
                        "username": "dle2",
                        "content": "should be easy type"
                    },
                    {
                        "username": "skyday123",
                        "content": "# long! long! long! "
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    \\n    long long sum = 0;\\n    int i,j,c;\\n    long long n=nums.size();\\n    vector<int> res;  \\n    \\n\\n    //if(k>nums.size()) return res;\\n\\n    for(i=0;i<2*k+1;i++) sum += nums[i];\\n    res[k] = (int)(sum/(2*k+1));\\n\\n    for(i=0,j=2*k+1,c=k+1;j<nums.size();c++,j++,i++){\\n        sum += (nums[j]-nums[i]);\\n        res[c] = (int)(sum/(2*k+1));\\n    }\\n    return res;\\n    }\\n};\\ncan anyone find out what i am making mistake?\\n\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "c will start from k, not k+1"
                    },
                    {
                        "username": "addision_007",
                        "content": "you have to focus on few edge cases like :\\n1 :  initialize your output vector with -1.\\n2 : if no. of elements in given vector be less than the given k-radius.\\n3 :  create the window .\\n4:  while creating window take sum of all elements .\\n5: than for let i==k to i<n-k. store the sum and expand the end of window, and shirk by the start of window.\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int i=0;\\n      int j=0;\\n      long long n=nums.size();\\n      long long sum=0;\\n      vector<int>v(n,-1);\\n      if(n<(2*k+1))\\n      {\\n          \\n           return v;\\n      }\\n      if(k==0)\\n      {\\n          return nums;\\n      }\\n      while(j<2*k+1)\\n      {\\n          sum=sum+nums[j];\\n          if(i<k)\\n          {\\n              i++;\\n          }\\n          j++;\\n      }\\n       if(i==k)\\n         v[i]=sum/(2*k+1);\\n      while(j<n && i<n)\\n      {\\n          sum=sum+nums[j];\\n          sum-=nums[i-k];\\n          \\n          if(i<n-k)\\n          {\\n              i++;\\n          v[i]=sum/(2*k+1);\\n          }\\n          \\n          j++;\\n        \\n      }\\n     \\n      return v;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1936668,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "Who gave up after seeing TLE for final test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "With a sliding window, this should have a O(N) run time."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Is cpp on drugs or what??\nwith cout, I checked, and output was 60092, but when it was stored in vector, it was stored 60091, what the hell, I don't even know how to solve this issue.\n\nInput\nnums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk =\n1 \nStdout\n60147.7 43496.7 *60092* 67396.3 80633.3 49974 \nOutput\n[-1,60147,43496,60091,67396,80633,49974,38542,-1]\nExpected\n[-1,60147,43496,60092,67396,80633,49974,38542,-1]\n\n`class Solution {\npublic:\n    vector<int> getAverages(vector<int>& nums, int k) {\n        if (!k)\n            return nums;\n        int size = nums.size();\n        vector<int> average(size, -1);\n\n        if (2 * k >= size)\n            return average;\n        \n        double avg = 0.0, den = 2.0 * k + 1;\n\n        for(int i = 0; i <= 2*k; i++)\n            avg += nums[i]/den;\n\n        for(int i = k; i < size; i++) {\n            average[i] = avg;\n            if (i+k+1 >= size)\n                break;\n            \n            cout << avg << \" \";\n            avg -= nums[i-k]/den;\n            avg += nums[i+k+1]/den;\n        }\n\n        return average;\n    }\n};`"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) Use long long instead."
                    },
                    {
                        "username": "EricRaw",
                        "content": "it's because, when you assign the avg value (which is a double) to average[i] (which is a int) , the decimal portion gets truncated\n\nwhen showing the decimal portion of the avg\n```\nstd::cout << std::setprecision(20) << avg << \" \";\n```\nyou can see the avg value is 60091.999999999992724 (not 60092) which when truncated become 60091\n\nwhich is why i hate typecast double to int"
                    },
                    {
                        "username": "nkBrew",
                        "content": "For those getting all the starting test cases correct but getting timelimit exceeded errors at around testcase 17:\\n\\nRemember that built in sum() methods are additional loops that add time. You have the right idea, but instead of being lazy I\\'m afraid we\\'ll have to use... MATH!"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Legit why is there a really long solution with ten thousands elements all the same?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Anyone can tell me why answer like this will result in a wrong answer:\\nint[] ans = new int[N];\\nlong[] sum = new long[N];\\n...\\nfor(...){\\n   ans[i] = (int) (using sum to calculate..)\\n}\\nBut if I use :\\nlong temp = (using sum to calculate..)\\nans[i] = (int) temp\\nit will be ok\\nThank you"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@EricRaw](/EricRaw) Yes,It solved, thank u so much!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "maybe because of how you typecast?\n\nans[i] = (int) (a * b) / 2;\nis different than\nans[i] = (int) ((a * b) / 2);"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you should debug to see it your own, no one can giving correct solution by guesting what you had coding, and other thing may helpful, as i see, there is no diffrent, in almost case both long & int are same type with size 4 byte (c++)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Sliding Window (need I say more?)."
                    },
                    {
                        "username": "dle2",
                        "content": "should be easy type"
                    },
                    {
                        "username": "skyday123",
                        "content": "# long! long! long! "
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    \\n    long long sum = 0;\\n    int i,j,c;\\n    long long n=nums.size();\\n    vector<int> res;  \\n    \\n\\n    //if(k>nums.size()) return res;\\n\\n    for(i=0;i<2*k+1;i++) sum += nums[i];\\n    res[k] = (int)(sum/(2*k+1));\\n\\n    for(i=0,j=2*k+1,c=k+1;j<nums.size();c++,j++,i++){\\n        sum += (nums[j]-nums[i]);\\n        res[c] = (int)(sum/(2*k+1));\\n    }\\n    return res;\\n    }\\n};\\ncan anyone find out what i am making mistake?\\n\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "c will start from k, not k+1"
                    },
                    {
                        "username": "addision_007",
                        "content": "you have to focus on few edge cases like :\\n1 :  initialize your output vector with -1.\\n2 : if no. of elements in given vector be less than the given k-radius.\\n3 :  create the window .\\n4:  while creating window take sum of all elements .\\n5: than for let i==k to i<n-k. store the sum and expand the end of window, and shirk by the start of window.\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int i=0;\\n      int j=0;\\n      long long n=nums.size();\\n      long long sum=0;\\n      vector<int>v(n,-1);\\n      if(n<(2*k+1))\\n      {\\n          \\n           return v;\\n      }\\n      if(k==0)\\n      {\\n          return nums;\\n      }\\n      while(j<2*k+1)\\n      {\\n          sum=sum+nums[j];\\n          if(i<k)\\n          {\\n              i++;\\n          }\\n          j++;\\n      }\\n       if(i==k)\\n         v[i]=sum/(2*k+1);\\n      while(j<n && i<n)\\n      {\\n          sum=sum+nums[j];\\n          sum-=nums[i-k];\\n          \\n          if(i<n-k)\\n          {\\n              i++;\\n          v[i]=sum/(2*k+1);\\n          }\\n          \\n          j++;\\n        \\n      }\\n     \\n      return v;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1936630,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "Who gave up after seeing TLE for final test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "With a sliding window, this should have a O(N) run time."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Is cpp on drugs or what??\nwith cout, I checked, and output was 60092, but when it was stored in vector, it was stored 60091, what the hell, I don't even know how to solve this issue.\n\nInput\nnums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk =\n1 \nStdout\n60147.7 43496.7 *60092* 67396.3 80633.3 49974 \nOutput\n[-1,60147,43496,60091,67396,80633,49974,38542,-1]\nExpected\n[-1,60147,43496,60092,67396,80633,49974,38542,-1]\n\n`class Solution {\npublic:\n    vector<int> getAverages(vector<int>& nums, int k) {\n        if (!k)\n            return nums;\n        int size = nums.size();\n        vector<int> average(size, -1);\n\n        if (2 * k >= size)\n            return average;\n        \n        double avg = 0.0, den = 2.0 * k + 1;\n\n        for(int i = 0; i <= 2*k; i++)\n            avg += nums[i]/den;\n\n        for(int i = k; i < size; i++) {\n            average[i] = avg;\n            if (i+k+1 >= size)\n                break;\n            \n            cout << avg << \" \";\n            avg -= nums[i-k]/den;\n            avg += nums[i+k+1]/den;\n        }\n\n        return average;\n    }\n};`"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) Use long long instead."
                    },
                    {
                        "username": "EricRaw",
                        "content": "it's because, when you assign the avg value (which is a double) to average[i] (which is a int) , the decimal portion gets truncated\n\nwhen showing the decimal portion of the avg\n```\nstd::cout << std::setprecision(20) << avg << \" \";\n```\nyou can see the avg value is 60091.999999999992724 (not 60092) which when truncated become 60091\n\nwhich is why i hate typecast double to int"
                    },
                    {
                        "username": "nkBrew",
                        "content": "For those getting all the starting test cases correct but getting timelimit exceeded errors at around testcase 17:\\n\\nRemember that built in sum() methods are additional loops that add time. You have the right idea, but instead of being lazy I\\'m afraid we\\'ll have to use... MATH!"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Legit why is there a really long solution with ten thousands elements all the same?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Anyone can tell me why answer like this will result in a wrong answer:\\nint[] ans = new int[N];\\nlong[] sum = new long[N];\\n...\\nfor(...){\\n   ans[i] = (int) (using sum to calculate..)\\n}\\nBut if I use :\\nlong temp = (using sum to calculate..)\\nans[i] = (int) temp\\nit will be ok\\nThank you"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@EricRaw](/EricRaw) Yes,It solved, thank u so much!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "maybe because of how you typecast?\n\nans[i] = (int) (a * b) / 2;\nis different than\nans[i] = (int) ((a * b) / 2);"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you should debug to see it your own, no one can giving correct solution by guesting what you had coding, and other thing may helpful, as i see, there is no diffrent, in almost case both long & int are same type with size 4 byte (c++)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Sliding Window (need I say more?)."
                    },
                    {
                        "username": "dle2",
                        "content": "should be easy type"
                    },
                    {
                        "username": "skyday123",
                        "content": "# long! long! long! "
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    \\n    long long sum = 0;\\n    int i,j,c;\\n    long long n=nums.size();\\n    vector<int> res;  \\n    \\n\\n    //if(k>nums.size()) return res;\\n\\n    for(i=0;i<2*k+1;i++) sum += nums[i];\\n    res[k] = (int)(sum/(2*k+1));\\n\\n    for(i=0,j=2*k+1,c=k+1;j<nums.size();c++,j++,i++){\\n        sum += (nums[j]-nums[i]);\\n        res[c] = (int)(sum/(2*k+1));\\n    }\\n    return res;\\n    }\\n};\\ncan anyone find out what i am making mistake?\\n\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "c will start from k, not k+1"
                    },
                    {
                        "username": "addision_007",
                        "content": "you have to focus on few edge cases like :\\n1 :  initialize your output vector with -1.\\n2 : if no. of elements in given vector be less than the given k-radius.\\n3 :  create the window .\\n4:  while creating window take sum of all elements .\\n5: than for let i==k to i<n-k. store the sum and expand the end of window, and shirk by the start of window.\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int i=0;\\n      int j=0;\\n      long long n=nums.size();\\n      long long sum=0;\\n      vector<int>v(n,-1);\\n      if(n<(2*k+1))\\n      {\\n          \\n           return v;\\n      }\\n      if(k==0)\\n      {\\n          return nums;\\n      }\\n      while(j<2*k+1)\\n      {\\n          sum=sum+nums[j];\\n          if(i<k)\\n          {\\n              i++;\\n          }\\n          j++;\\n      }\\n       if(i==k)\\n         v[i]=sum/(2*k+1);\\n      while(j<n && i<n)\\n      {\\n          sum=sum+nums[j];\\n          sum-=nums[i-k];\\n          \\n          if(i<n-k)\\n          {\\n              i++;\\n          v[i]=sum/(2*k+1);\\n          }\\n          \\n          j++;\\n        \\n      }\\n     \\n      return v;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1936622,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "Who gave up after seeing TLE for final test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "With a sliding window, this should have a O(N) run time."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Is cpp on drugs or what??\nwith cout, I checked, and output was 60092, but when it was stored in vector, it was stored 60091, what the hell, I don't even know how to solve this issue.\n\nInput\nnums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk =\n1 \nStdout\n60147.7 43496.7 *60092* 67396.3 80633.3 49974 \nOutput\n[-1,60147,43496,60091,67396,80633,49974,38542,-1]\nExpected\n[-1,60147,43496,60092,67396,80633,49974,38542,-1]\n\n`class Solution {\npublic:\n    vector<int> getAverages(vector<int>& nums, int k) {\n        if (!k)\n            return nums;\n        int size = nums.size();\n        vector<int> average(size, -1);\n\n        if (2 * k >= size)\n            return average;\n        \n        double avg = 0.0, den = 2.0 * k + 1;\n\n        for(int i = 0; i <= 2*k; i++)\n            avg += nums[i]/den;\n\n        for(int i = k; i < size; i++) {\n            average[i] = avg;\n            if (i+k+1 >= size)\n                break;\n            \n            cout << avg << \" \";\n            avg -= nums[i-k]/den;\n            avg += nums[i+k+1]/den;\n        }\n\n        return average;\n    }\n};`"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) Use long long instead."
                    },
                    {
                        "username": "EricRaw",
                        "content": "it's because, when you assign the avg value (which is a double) to average[i] (which is a int) , the decimal portion gets truncated\n\nwhen showing the decimal portion of the avg\n```\nstd::cout << std::setprecision(20) << avg << \" \";\n```\nyou can see the avg value is 60091.999999999992724 (not 60092) which when truncated become 60091\n\nwhich is why i hate typecast double to int"
                    },
                    {
                        "username": "nkBrew",
                        "content": "For those getting all the starting test cases correct but getting timelimit exceeded errors at around testcase 17:\\n\\nRemember that built in sum() methods are additional loops that add time. You have the right idea, but instead of being lazy I\\'m afraid we\\'ll have to use... MATH!"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Legit why is there a really long solution with ten thousands elements all the same?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Anyone can tell me why answer like this will result in a wrong answer:\\nint[] ans = new int[N];\\nlong[] sum = new long[N];\\n...\\nfor(...){\\n   ans[i] = (int) (using sum to calculate..)\\n}\\nBut if I use :\\nlong temp = (using sum to calculate..)\\nans[i] = (int) temp\\nit will be ok\\nThank you"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@EricRaw](/EricRaw) Yes,It solved, thank u so much!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "maybe because of how you typecast?\n\nans[i] = (int) (a * b) / 2;\nis different than\nans[i] = (int) ((a * b) / 2);"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you should debug to see it your own, no one can giving correct solution by guesting what you had coding, and other thing may helpful, as i see, there is no diffrent, in almost case both long & int are same type with size 4 byte (c++)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Sliding Window (need I say more?)."
                    },
                    {
                        "username": "dle2",
                        "content": "should be easy type"
                    },
                    {
                        "username": "skyday123",
                        "content": "# long! long! long! "
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    \\n    long long sum = 0;\\n    int i,j,c;\\n    long long n=nums.size();\\n    vector<int> res;  \\n    \\n\\n    //if(k>nums.size()) return res;\\n\\n    for(i=0;i<2*k+1;i++) sum += nums[i];\\n    res[k] = (int)(sum/(2*k+1));\\n\\n    for(i=0,j=2*k+1,c=k+1;j<nums.size();c++,j++,i++){\\n        sum += (nums[j]-nums[i]);\\n        res[c] = (int)(sum/(2*k+1));\\n    }\\n    return res;\\n    }\\n};\\ncan anyone find out what i am making mistake?\\n\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "c will start from k, not k+1"
                    },
                    {
                        "username": "addision_007",
                        "content": "you have to focus on few edge cases like :\\n1 :  initialize your output vector with -1.\\n2 : if no. of elements in given vector be less than the given k-radius.\\n3 :  create the window .\\n4:  while creating window take sum of all elements .\\n5: than for let i==k to i<n-k. store the sum and expand the end of window, and shirk by the start of window.\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int i=0;\\n      int j=0;\\n      long long n=nums.size();\\n      long long sum=0;\\n      vector<int>v(n,-1);\\n      if(n<(2*k+1))\\n      {\\n          \\n           return v;\\n      }\\n      if(k==0)\\n      {\\n          return nums;\\n      }\\n      while(j<2*k+1)\\n      {\\n          sum=sum+nums[j];\\n          if(i<k)\\n          {\\n              i++;\\n          }\\n          j++;\\n      }\\n       if(i==k)\\n         v[i]=sum/(2*k+1);\\n      while(j<n && i<n)\\n      {\\n          sum=sum+nums[j];\\n          sum-=nums[i-k];\\n          \\n          if(i<n-k)\\n          {\\n              i++;\\n          v[i]=sum/(2*k+1);\\n          }\\n          \\n          j++;\\n        \\n      }\\n     \\n      return v;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1936608,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "Who gave up after seeing TLE for final test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "With a sliding window, this should have a O(N) run time."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Is cpp on drugs or what??\nwith cout, I checked, and output was 60092, but when it was stored in vector, it was stored 60091, what the hell, I don't even know how to solve this issue.\n\nInput\nnums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk =\n1 \nStdout\n60147.7 43496.7 *60092* 67396.3 80633.3 49974 \nOutput\n[-1,60147,43496,60091,67396,80633,49974,38542,-1]\nExpected\n[-1,60147,43496,60092,67396,80633,49974,38542,-1]\n\n`class Solution {\npublic:\n    vector<int> getAverages(vector<int>& nums, int k) {\n        if (!k)\n            return nums;\n        int size = nums.size();\n        vector<int> average(size, -1);\n\n        if (2 * k >= size)\n            return average;\n        \n        double avg = 0.0, den = 2.0 * k + 1;\n\n        for(int i = 0; i <= 2*k; i++)\n            avg += nums[i]/den;\n\n        for(int i = k; i < size; i++) {\n            average[i] = avg;\n            if (i+k+1 >= size)\n                break;\n            \n            cout << avg << \" \";\n            avg -= nums[i-k]/den;\n            avg += nums[i+k+1]/den;\n        }\n\n        return average;\n    }\n};`"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) Use long long instead."
                    },
                    {
                        "username": "EricRaw",
                        "content": "it's because, when you assign the avg value (which is a double) to average[i] (which is a int) , the decimal portion gets truncated\n\nwhen showing the decimal portion of the avg\n```\nstd::cout << std::setprecision(20) << avg << \" \";\n```\nyou can see the avg value is 60091.999999999992724 (not 60092) which when truncated become 60091\n\nwhich is why i hate typecast double to int"
                    },
                    {
                        "username": "nkBrew",
                        "content": "For those getting all the starting test cases correct but getting timelimit exceeded errors at around testcase 17:\\n\\nRemember that built in sum() methods are additional loops that add time. You have the right idea, but instead of being lazy I\\'m afraid we\\'ll have to use... MATH!"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Legit why is there a really long solution with ten thousands elements all the same?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Anyone can tell me why answer like this will result in a wrong answer:\\nint[] ans = new int[N];\\nlong[] sum = new long[N];\\n...\\nfor(...){\\n   ans[i] = (int) (using sum to calculate..)\\n}\\nBut if I use :\\nlong temp = (using sum to calculate..)\\nans[i] = (int) temp\\nit will be ok\\nThank you"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@EricRaw](/EricRaw) Yes,It solved, thank u so much!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "maybe because of how you typecast?\n\nans[i] = (int) (a * b) / 2;\nis different than\nans[i] = (int) ((a * b) / 2);"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you should debug to see it your own, no one can giving correct solution by guesting what you had coding, and other thing may helpful, as i see, there is no diffrent, in almost case both long & int are same type with size 4 byte (c++)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Sliding Window (need I say more?)."
                    },
                    {
                        "username": "dle2",
                        "content": "should be easy type"
                    },
                    {
                        "username": "skyday123",
                        "content": "# long! long! long! "
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    \\n    long long sum = 0;\\n    int i,j,c;\\n    long long n=nums.size();\\n    vector<int> res;  \\n    \\n\\n    //if(k>nums.size()) return res;\\n\\n    for(i=0;i<2*k+1;i++) sum += nums[i];\\n    res[k] = (int)(sum/(2*k+1));\\n\\n    for(i=0,j=2*k+1,c=k+1;j<nums.size();c++,j++,i++){\\n        sum += (nums[j]-nums[i]);\\n        res[c] = (int)(sum/(2*k+1));\\n    }\\n    return res;\\n    }\\n};\\ncan anyone find out what i am making mistake?\\n\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "c will start from k, not k+1"
                    },
                    {
                        "username": "addision_007",
                        "content": "you have to focus on few edge cases like :\\n1 :  initialize your output vector with -1.\\n2 : if no. of elements in given vector be less than the given k-radius.\\n3 :  create the window .\\n4:  while creating window take sum of all elements .\\n5: than for let i==k to i<n-k. store the sum and expand the end of window, and shirk by the start of window.\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int i=0;\\n      int j=0;\\n      long long n=nums.size();\\n      long long sum=0;\\n      vector<int>v(n,-1);\\n      if(n<(2*k+1))\\n      {\\n          \\n           return v;\\n      }\\n      if(k==0)\\n      {\\n          return nums;\\n      }\\n      while(j<2*k+1)\\n      {\\n          sum=sum+nums[j];\\n          if(i<k)\\n          {\\n              i++;\\n          }\\n          j++;\\n      }\\n       if(i==k)\\n         v[i]=sum/(2*k+1);\\n      while(j<n && i<n)\\n      {\\n          sum=sum+nums[j];\\n          sum-=nums[i-k];\\n          \\n          if(i<n-k)\\n          {\\n              i++;\\n          v[i]=sum/(2*k+1);\\n          }\\n          \\n          j++;\\n        \\n      }\\n     \\n      return v;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1936580,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "Who gave up after seeing TLE for final test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "With a sliding window, this should have a O(N) run time."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Is cpp on drugs or what??\nwith cout, I checked, and output was 60092, but when it was stored in vector, it was stored 60091, what the hell, I don't even know how to solve this issue.\n\nInput\nnums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk =\n1 \nStdout\n60147.7 43496.7 *60092* 67396.3 80633.3 49974 \nOutput\n[-1,60147,43496,60091,67396,80633,49974,38542,-1]\nExpected\n[-1,60147,43496,60092,67396,80633,49974,38542,-1]\n\n`class Solution {\npublic:\n    vector<int> getAverages(vector<int>& nums, int k) {\n        if (!k)\n            return nums;\n        int size = nums.size();\n        vector<int> average(size, -1);\n\n        if (2 * k >= size)\n            return average;\n        \n        double avg = 0.0, den = 2.0 * k + 1;\n\n        for(int i = 0; i <= 2*k; i++)\n            avg += nums[i]/den;\n\n        for(int i = k; i < size; i++) {\n            average[i] = avg;\n            if (i+k+1 >= size)\n                break;\n            \n            cout << avg << \" \";\n            avg -= nums[i-k]/den;\n            avg += nums[i+k+1]/den;\n        }\n\n        return average;\n    }\n};`"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) Use long long instead."
                    },
                    {
                        "username": "EricRaw",
                        "content": "it's because, when you assign the avg value (which is a double) to average[i] (which is a int) , the decimal portion gets truncated\n\nwhen showing the decimal portion of the avg\n```\nstd::cout << std::setprecision(20) << avg << \" \";\n```\nyou can see the avg value is 60091.999999999992724 (not 60092) which when truncated become 60091\n\nwhich is why i hate typecast double to int"
                    },
                    {
                        "username": "nkBrew",
                        "content": "For those getting all the starting test cases correct but getting timelimit exceeded errors at around testcase 17:\\n\\nRemember that built in sum() methods are additional loops that add time. You have the right idea, but instead of being lazy I\\'m afraid we\\'ll have to use... MATH!"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Legit why is there a really long solution with ten thousands elements all the same?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Anyone can tell me why answer like this will result in a wrong answer:\\nint[] ans = new int[N];\\nlong[] sum = new long[N];\\n...\\nfor(...){\\n   ans[i] = (int) (using sum to calculate..)\\n}\\nBut if I use :\\nlong temp = (using sum to calculate..)\\nans[i] = (int) temp\\nit will be ok\\nThank you"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@EricRaw](/EricRaw) Yes,It solved, thank u so much!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "maybe because of how you typecast?\n\nans[i] = (int) (a * b) / 2;\nis different than\nans[i] = (int) ((a * b) / 2);"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you should debug to see it your own, no one can giving correct solution by guesting what you had coding, and other thing may helpful, as i see, there is no diffrent, in almost case both long & int are same type with size 4 byte (c++)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Sliding Window (need I say more?)."
                    },
                    {
                        "username": "dle2",
                        "content": "should be easy type"
                    },
                    {
                        "username": "skyday123",
                        "content": "# long! long! long! "
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    \\n    long long sum = 0;\\n    int i,j,c;\\n    long long n=nums.size();\\n    vector<int> res;  \\n    \\n\\n    //if(k>nums.size()) return res;\\n\\n    for(i=0;i<2*k+1;i++) sum += nums[i];\\n    res[k] = (int)(sum/(2*k+1));\\n\\n    for(i=0,j=2*k+1,c=k+1;j<nums.size();c++,j++,i++){\\n        sum += (nums[j]-nums[i]);\\n        res[c] = (int)(sum/(2*k+1));\\n    }\\n    return res;\\n    }\\n};\\ncan anyone find out what i am making mistake?\\n\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "c will start from k, not k+1"
                    },
                    {
                        "username": "addision_007",
                        "content": "you have to focus on few edge cases like :\\n1 :  initialize your output vector with -1.\\n2 : if no. of elements in given vector be less than the given k-radius.\\n3 :  create the window .\\n4:  while creating window take sum of all elements .\\n5: than for let i==k to i<n-k. store the sum and expand the end of window, and shirk by the start of window.\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int i=0;\\n      int j=0;\\n      long long n=nums.size();\\n      long long sum=0;\\n      vector<int>v(n,-1);\\n      if(n<(2*k+1))\\n      {\\n          \\n           return v;\\n      }\\n      if(k==0)\\n      {\\n          return nums;\\n      }\\n      while(j<2*k+1)\\n      {\\n          sum=sum+nums[j];\\n          if(i<k)\\n          {\\n              i++;\\n          }\\n          j++;\\n      }\\n       if(i==k)\\n         v[i]=sum/(2*k+1);\\n      while(j<n && i<n)\\n      {\\n          sum=sum+nums[j];\\n          sum-=nums[i-k];\\n          \\n          if(i<n-k)\\n          {\\n              i++;\\n          v[i]=sum/(2*k+1);\\n          }\\n          \\n          j++;\\n        \\n      }\\n     \\n      return v;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1936573,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "Who gave up after seeing TLE for final test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "With a sliding window, this should have a O(N) run time."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Is cpp on drugs or what??\nwith cout, I checked, and output was 60092, but when it was stored in vector, it was stored 60091, what the hell, I don't even know how to solve this issue.\n\nInput\nnums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk =\n1 \nStdout\n60147.7 43496.7 *60092* 67396.3 80633.3 49974 \nOutput\n[-1,60147,43496,60091,67396,80633,49974,38542,-1]\nExpected\n[-1,60147,43496,60092,67396,80633,49974,38542,-1]\n\n`class Solution {\npublic:\n    vector<int> getAverages(vector<int>& nums, int k) {\n        if (!k)\n            return nums;\n        int size = nums.size();\n        vector<int> average(size, -1);\n\n        if (2 * k >= size)\n            return average;\n        \n        double avg = 0.0, den = 2.0 * k + 1;\n\n        for(int i = 0; i <= 2*k; i++)\n            avg += nums[i]/den;\n\n        for(int i = k; i < size; i++) {\n            average[i] = avg;\n            if (i+k+1 >= size)\n                break;\n            \n            cout << avg << \" \";\n            avg -= nums[i-k]/den;\n            avg += nums[i+k+1]/den;\n        }\n\n        return average;\n    }\n};`"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) Use long long instead."
                    },
                    {
                        "username": "EricRaw",
                        "content": "it's because, when you assign the avg value (which is a double) to average[i] (which is a int) , the decimal portion gets truncated\n\nwhen showing the decimal portion of the avg\n```\nstd::cout << std::setprecision(20) << avg << \" \";\n```\nyou can see the avg value is 60091.999999999992724 (not 60092) which when truncated become 60091\n\nwhich is why i hate typecast double to int"
                    },
                    {
                        "username": "nkBrew",
                        "content": "For those getting all the starting test cases correct but getting timelimit exceeded errors at around testcase 17:\\n\\nRemember that built in sum() methods are additional loops that add time. You have the right idea, but instead of being lazy I\\'m afraid we\\'ll have to use... MATH!"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Legit why is there a really long solution with ten thousands elements all the same?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Anyone can tell me why answer like this will result in a wrong answer:\\nint[] ans = new int[N];\\nlong[] sum = new long[N];\\n...\\nfor(...){\\n   ans[i] = (int) (using sum to calculate..)\\n}\\nBut if I use :\\nlong temp = (using sum to calculate..)\\nans[i] = (int) temp\\nit will be ok\\nThank you"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@EricRaw](/EricRaw) Yes,It solved, thank u so much!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "maybe because of how you typecast?\n\nans[i] = (int) (a * b) / 2;\nis different than\nans[i] = (int) ((a * b) / 2);"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you should debug to see it your own, no one can giving correct solution by guesting what you had coding, and other thing may helpful, as i see, there is no diffrent, in almost case both long & int are same type with size 4 byte (c++)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Sliding Window (need I say more?)."
                    },
                    {
                        "username": "dle2",
                        "content": "should be easy type"
                    },
                    {
                        "username": "skyday123",
                        "content": "# long! long! long! "
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    \\n    long long sum = 0;\\n    int i,j,c;\\n    long long n=nums.size();\\n    vector<int> res;  \\n    \\n\\n    //if(k>nums.size()) return res;\\n\\n    for(i=0;i<2*k+1;i++) sum += nums[i];\\n    res[k] = (int)(sum/(2*k+1));\\n\\n    for(i=0,j=2*k+1,c=k+1;j<nums.size();c++,j++,i++){\\n        sum += (nums[j]-nums[i]);\\n        res[c] = (int)(sum/(2*k+1));\\n    }\\n    return res;\\n    }\\n};\\ncan anyone find out what i am making mistake?\\n\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "c will start from k, not k+1"
                    },
                    {
                        "username": "addision_007",
                        "content": "you have to focus on few edge cases like :\\n1 :  initialize your output vector with -1.\\n2 : if no. of elements in given vector be less than the given k-radius.\\n3 :  create the window .\\n4:  while creating window take sum of all elements .\\n5: than for let i==k to i<n-k. store the sum and expand the end of window, and shirk by the start of window.\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int i=0;\\n      int j=0;\\n      long long n=nums.size();\\n      long long sum=0;\\n      vector<int>v(n,-1);\\n      if(n<(2*k+1))\\n      {\\n          \\n           return v;\\n      }\\n      if(k==0)\\n      {\\n          return nums;\\n      }\\n      while(j<2*k+1)\\n      {\\n          sum=sum+nums[j];\\n          if(i<k)\\n          {\\n              i++;\\n          }\\n          j++;\\n      }\\n       if(i==k)\\n         v[i]=sum/(2*k+1);\\n      while(j<n && i<n)\\n      {\\n          sum=sum+nums[j];\\n          sum-=nums[i-k];\\n          \\n          if(i<n-k)\\n          {\\n              i++;\\n          v[i]=sum/(2*k+1);\\n          }\\n          \\n          j++;\\n        \\n      }\\n     \\n      return v;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1763695,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "Who gave up after seeing TLE for final test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "With a sliding window, this should have a O(N) run time."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Is cpp on drugs or what??\nwith cout, I checked, and output was 60092, but when it was stored in vector, it was stored 60091, what the hell, I don't even know how to solve this issue.\n\nInput\nnums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk =\n1 \nStdout\n60147.7 43496.7 *60092* 67396.3 80633.3 49974 \nOutput\n[-1,60147,43496,60091,67396,80633,49974,38542,-1]\nExpected\n[-1,60147,43496,60092,67396,80633,49974,38542,-1]\n\n`class Solution {\npublic:\n    vector<int> getAverages(vector<int>& nums, int k) {\n        if (!k)\n            return nums;\n        int size = nums.size();\n        vector<int> average(size, -1);\n\n        if (2 * k >= size)\n            return average;\n        \n        double avg = 0.0, den = 2.0 * k + 1;\n\n        for(int i = 0; i <= 2*k; i++)\n            avg += nums[i]/den;\n\n        for(int i = k; i < size; i++) {\n            average[i] = avg;\n            if (i+k+1 >= size)\n                break;\n            \n            cout << avg << \" \";\n            avg -= nums[i-k]/den;\n            avg += nums[i+k+1]/den;\n        }\n\n        return average;\n    }\n};`"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) Use long long instead."
                    },
                    {
                        "username": "EricRaw",
                        "content": "it's because, when you assign the avg value (which is a double) to average[i] (which is a int) , the decimal portion gets truncated\n\nwhen showing the decimal portion of the avg\n```\nstd::cout << std::setprecision(20) << avg << \" \";\n```\nyou can see the avg value is 60091.999999999992724 (not 60092) which when truncated become 60091\n\nwhich is why i hate typecast double to int"
                    },
                    {
                        "username": "nkBrew",
                        "content": "For those getting all the starting test cases correct but getting timelimit exceeded errors at around testcase 17:\\n\\nRemember that built in sum() methods are additional loops that add time. You have the right idea, but instead of being lazy I\\'m afraid we\\'ll have to use... MATH!"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Legit why is there a really long solution with ten thousands elements all the same?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Anyone can tell me why answer like this will result in a wrong answer:\\nint[] ans = new int[N];\\nlong[] sum = new long[N];\\n...\\nfor(...){\\n   ans[i] = (int) (using sum to calculate..)\\n}\\nBut if I use :\\nlong temp = (using sum to calculate..)\\nans[i] = (int) temp\\nit will be ok\\nThank you"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@EricRaw](/EricRaw) Yes,It solved, thank u so much!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "maybe because of how you typecast?\n\nans[i] = (int) (a * b) / 2;\nis different than\nans[i] = (int) ((a * b) / 2);"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you should debug to see it your own, no one can giving correct solution by guesting what you had coding, and other thing may helpful, as i see, there is no diffrent, in almost case both long & int are same type with size 4 byte (c++)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Sliding Window (need I say more?)."
                    },
                    {
                        "username": "dle2",
                        "content": "should be easy type"
                    },
                    {
                        "username": "skyday123",
                        "content": "# long! long! long! "
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    \\n    long long sum = 0;\\n    int i,j,c;\\n    long long n=nums.size();\\n    vector<int> res;  \\n    \\n\\n    //if(k>nums.size()) return res;\\n\\n    for(i=0;i<2*k+1;i++) sum += nums[i];\\n    res[k] = (int)(sum/(2*k+1));\\n\\n    for(i=0,j=2*k+1,c=k+1;j<nums.size();c++,j++,i++){\\n        sum += (nums[j]-nums[i]);\\n        res[c] = (int)(sum/(2*k+1));\\n    }\\n    return res;\\n    }\\n};\\ncan anyone find out what i am making mistake?\\n\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "c will start from k, not k+1"
                    },
                    {
                        "username": "addision_007",
                        "content": "you have to focus on few edge cases like :\\n1 :  initialize your output vector with -1.\\n2 : if no. of elements in given vector be less than the given k-radius.\\n3 :  create the window .\\n4:  while creating window take sum of all elements .\\n5: than for let i==k to i<n-k. store the sum and expand the end of window, and shirk by the start of window.\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int i=0;\\n      int j=0;\\n      long long n=nums.size();\\n      long long sum=0;\\n      vector<int>v(n,-1);\\n      if(n<(2*k+1))\\n      {\\n          \\n           return v;\\n      }\\n      if(k==0)\\n      {\\n          return nums;\\n      }\\n      while(j<2*k+1)\\n      {\\n          sum=sum+nums[j];\\n          if(i<k)\\n          {\\n              i++;\\n          }\\n          j++;\\n      }\\n       if(i==k)\\n         v[i]=sum/(2*k+1);\\n      while(j<n && i<n)\\n      {\\n          sum=sum+nums[j];\\n          sum-=nums[i-k];\\n          \\n          if(i<n-k)\\n          {\\n              i++;\\n          v[i]=sum/(2*k+1);\\n          }\\n          \\n          j++;\\n        \\n      }\\n     \\n      return v;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1762884,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "Who gave up after seeing TLE for final test case?"
                    },
                    {
                        "username": "psionl0",
                        "content": "With a sliding window, this should have a O(N) run time."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Is cpp on drugs or what??\nwith cout, I checked, and output was 60092, but when it was stored in vector, it was stored 60091, what the hell, I don't even know how to solve this issue.\n\nInput\nnums =\n[56725,48784,74934,6772,98570,96847,46483,6592,62552]\nk =\n1 \nStdout\n60147.7 43496.7 *60092* 67396.3 80633.3 49974 \nOutput\n[-1,60147,43496,60091,67396,80633,49974,38542,-1]\nExpected\n[-1,60147,43496,60092,67396,80633,49974,38542,-1]\n\n`class Solution {\npublic:\n    vector<int> getAverages(vector<int>& nums, int k) {\n        if (!k)\n            return nums;\n        int size = nums.size();\n        vector<int> average(size, -1);\n\n        if (2 * k >= size)\n            return average;\n        \n        double avg = 0.0, den = 2.0 * k + 1;\n\n        for(int i = 0; i <= 2*k; i++)\n            avg += nums[i]/den;\n\n        for(int i = k; i < size; i++) {\n            average[i] = avg;\n            if (i+k+1 >= size)\n                break;\n            \n            cout << avg << \" \";\n            avg -= nums[i-k]/den;\n            avg += nums[i+k+1]/den;\n        }\n\n        return average;\n    }\n};`"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) Use long long instead."
                    },
                    {
                        "username": "EricRaw",
                        "content": "it's because, when you assign the avg value (which is a double) to average[i] (which is a int) , the decimal portion gets truncated\n\nwhen showing the decimal portion of the avg\n```\nstd::cout << std::setprecision(20) << avg << \" \";\n```\nyou can see the avg value is 60091.999999999992724 (not 60092) which when truncated become 60091\n\nwhich is why i hate typecast double to int"
                    },
                    {
                        "username": "nkBrew",
                        "content": "For those getting all the starting test cases correct but getting timelimit exceeded errors at around testcase 17:\\n\\nRemember that built in sum() methods are additional loops that add time. You have the right idea, but instead of being lazy I\\'m afraid we\\'ll have to use... MATH!"
                    },
                    {
                        "username": "ethanh8093",
                        "content": "Legit why is there a really long solution with ten thousands elements all the same?"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Anyone can tell me why answer like this will result in a wrong answer:\\nint[] ans = new int[N];\\nlong[] sum = new long[N];\\n...\\nfor(...){\\n   ans[i] = (int) (using sum to calculate..)\\n}\\nBut if I use :\\nlong temp = (using sum to calculate..)\\nans[i] = (int) temp\\nit will be ok\\nThank you"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@EricRaw](/EricRaw) Yes,It solved, thank u so much!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "maybe because of how you typecast?\n\nans[i] = (int) (a * b) / 2;\nis different than\nans[i] = (int) ((a * b) / 2);"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you should debug to see it your own, no one can giving correct solution by guesting what you had coding, and other thing may helpful, as i see, there is no diffrent, in almost case both long & int are same type with size 4 byte (c++)"
                    },
                    {
                        "username": "psionl0",
                        "content": "Sliding Window (need I say more?)."
                    },
                    {
                        "username": "dle2",
                        "content": "should be easy type"
                    },
                    {
                        "username": "skyday123",
                        "content": "# long! long! long! "
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n    \\n    long long sum = 0;\\n    int i,j,c;\\n    long long n=nums.size();\\n    vector<int> res;  \\n    \\n\\n    //if(k>nums.size()) return res;\\n\\n    for(i=0;i<2*k+1;i++) sum += nums[i];\\n    res[k] = (int)(sum/(2*k+1));\\n\\n    for(i=0,j=2*k+1,c=k+1;j<nums.size();c++,j++,i++){\\n        sum += (nums[j]-nums[i]);\\n        res[c] = (int)(sum/(2*k+1));\\n    }\\n    return res;\\n    }\\n};\\ncan anyone find out what i am making mistake?\\n\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "c will start from k, not k+1"
                    },
                    {
                        "username": "addision_007",
                        "content": "you have to focus on few edge cases like :\\n1 :  initialize your output vector with -1.\\n2 : if no. of elements in given vector be less than the given k-radius.\\n3 :  create the window .\\n4:  while creating window take sum of all elements .\\n5: than for let i==k to i<n-k. store the sum and expand the end of window, and shirk by the start of window.\\n\\nclass Solution {\\npublic:\\n    vector<int> getAverages(vector<int>& nums, int k) {\\n      int i=0;\\n      int j=0;\\n      long long n=nums.size();\\n      long long sum=0;\\n      vector<int>v(n,-1);\\n      if(n<(2*k+1))\\n      {\\n          \\n           return v;\\n      }\\n      if(k==0)\\n      {\\n          return nums;\\n      }\\n      while(j<2*k+1)\\n      {\\n          sum=sum+nums[j];\\n          if(i<k)\\n          {\\n              i++;\\n          }\\n          j++;\\n      }\\n       if(i==k)\\n         v[i]=sum/(2*k+1);\\n      while(j<n && i<n)\\n      {\\n          sum=sum+nums[j];\\n          sum-=nums[i-k];\\n          \\n          if(i<n-k)\\n          {\\n              i++;\\n          v[i]=sum/(2*k+1);\\n          }\\n          \\n          j++;\\n        \\n      }\\n     \\n      return v;\\n    }\\n};\\n"
                    }
                ]
            }
        ]
    }
]