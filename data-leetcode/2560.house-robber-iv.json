[
    {
        "title": "House Robber IV",
        "question_content": "There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he refuses to steal from adjacent homes.\nThe capability of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\nYou are given an integer array nums representing how much money is stashed in each house. More formally, the ith house from the left has nums[i] dollars.\nYou are also given an integer k, representing the minimum number of houses the robber will steal from. It is always possible to steal at least k houses.\nReturn the minimum capability of the robber out of all the possible ways to steal at least k houses.\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,5,9], k = 2\nOutput: 5\nExplanation: \nThere are three ways to rob at least 2 houses:\n- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.\n- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.\n- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.\nTherefore, we return min(5, 9, 9) = 5.\n\nExample 2:\n\nInput: nums = [2,7,9,3,1], k = 2\nOutput: 2\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109\n\t1 <= k <= (nums.length + 1)/2",
        "solutions": [
            {
                "id": 3143697,
                "title": "java-c-python-binary-search-o-1-space",
                "content": "# **Intuition**\\nHey Robber series,\\nold school DP problem,\\nI practiced thousands of times.\\n\\nWait, in classical Robber problem,\\nwe usually want to maximize the value to steal.\\n\\nHere we want to minimize the maximum house we steal.\\nSo it\\'s not a robber-like problem,\\nit\\'s actually a mini-max problem.\\n\\nWhen we mini-max one capacity to do something,\\n(here is robber `k` houses)\\nwe can use bianry search.\\n\\nWhen use binary search,\\nI suggest you using my template\\n```\\nwhile (left < right) {\\n    int mid = (left + right) / 2;\\n    if (condition)\\n        right = mid;\\n    else\\n        left = mid + 1;\\n}\\nreturn left;\\n```\\n\\n<br>\\n\\n# **Explanation**\\nBinary search the minimum capability of the robber\\nto steal at least `k` houses.\\n\\nGiven `1 <= A[i] <= 1e9`,\\nwe can initial the binary search range as\\n`left = 1` and `right = 1e9`.\\nwe can also set `left = min(A)` and `right = max(A)`.\\n\\nAssume the capability is `mid`,\\nwe iterate the houses `A`,\\nand greedily take the houses as many as possible,\\nif `mid > A[i]` and we didn\\'t take `A[i-1]`.\\n\\nThen we check if we have take `k` houses,\\nIf `take >= k`,\\nwe have big enough capability,\\n`right = mid`.\\nIf `take < k`,\\nwe don\\'t have big enough capability,\\n`left = mid + 1`.\\n\\nFinally we return the binary search result.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogm)`,\\nwhere `m` is the range of A[i]\\nSpace `O(1)`\\n\\nWe can also binary search the value in `sorted(set(A))`,\\nTime `O(nlogn)`,\\nSpace `O(n)`.\\n<br>\\n\\n**Java**\\n```java\\n    public int minCapability(int[] A, int k) {\\n        int left = 1, right = (int)1e9, n = A.length;\\n        while (left < right) {\\n            int mid = (left + right) / 2, take = 0;\\n            for (int i = 0; i < n; ++i)\\n                if (A[i] <= mid) {\\n                    take += 1;\\n                    i++;\\n                }\\n            if (take >= k)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left; //left == right\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minCapability(vector<int>& A, int k) {\\n        int left = 1, right = 1e9, n = A.size();\\n        while (left < right) {\\n            int mid = (left + right) / 2, take = 0;\\n            for (int i = 0; i < n; ++i)\\n                if (A[i] <= mid) {\\n                    take += 1;\\n                    i++;\\n                }\\n            if (take >= k)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left; //left == right\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minCapability(self, A: List[int], k: int) -> int:\\n        l, r = min(A), max(A)\\n        while l < r:\\n            m = (l + r) // 2\\n            last = take = 0\\n            for a in A:\\n                if last:\\n                    last = 0\\n                    continue\\n                if a <= m:\\n                    take += 1\\n                    last = 1\\n            if take >= k:\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 2226. [Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908888/JavaC%2B%2BPython-Binary-Search-with-Explanation)\\n- 1802. [Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/discuss/1119801/Python-Binary-Search)\\n- 1539. [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC++Python-O(logN))\\n- 1482. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nwhile (left < right) {\\n    int mid = (left + right) / 2;\\n    if (condition)\\n        right = mid;\\n    else\\n        left = mid + 1;\\n}\\nreturn left;\\n```\n```java\\n    public int minCapability(int[] A, int k) {\\n        int left = 1, right = (int)1e9, n = A.length;\\n        while (left < right) {\\n            int mid = (left + right) / 2, take = 0;\\n            for (int i = 0; i < n; ++i)\\n                if (A[i] <= mid) {\\n                    take += 1;\\n                    i++;\\n                }\\n            if (take >= k)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left; //left == right\\n    }\\n```\n```cpp\\n    int minCapability(vector<int>& A, int k) {\\n        int left = 1, right = 1e9, n = A.size();\\n        while (left < right) {\\n            int mid = (left + right) / 2, take = 0;\\n            for (int i = 0; i < n; ++i)\\n                if (A[i] <= mid) {\\n                    take += 1;\\n                    i++;\\n                }\\n            if (take >= k)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n        return left; //left == right\\n    }\\n```\n```py\\n    def minCapability(self, A: List[int], k: int) -> int:\\n        l, r = min(A), max(A)\\n        while l < r:\\n            m = (l + r) // 2\\n            last = take = 0\\n            for a in A:\\n                if last:\\n                    last = 0\\n                    continue\\n                if a <= m:\\n                    take += 1\\n                    last = 1\\n            if take >= k:\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3143741,
                "title": "binary-search-c-with-similar-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**These question screams Binary Search**\\n\\nThis problem asks for **maximum-minimum** problem (thief has capability **maximum** of all houses robbed and we want to identify that way to make it as **minimum** as possible)\\n\\n# Reason:\\n1) We want to find the minimum possible value and capability should be maximum of all selected.\\n2) if we try to think greedy way then we are done unless we define a limit **Mid** such that no element choosen be greater than Limit. (**Binary Search**)\\n3) In general when you will go through the list of bindary search questions, you will observe that questions in which minima-maxima or maxima-minima is asked they are solved by Binary search problems.\\n    \\n# Approach\\n\\n* **Mid** will define the limit, our element should be smaller than this limit.\\n\\n* Iterate over the array and pic any k non-adjacent elements that are smaller than our limit( **Mid** in our case).\\n   \\n* Some of you might be thinking that me wondering why here i have used one loop only well lets observe:\\n\\n* If I have **$$nums[i]<=limit$$** and $$nums[i+1]<=limit$$, if I choose ith element I will have $$n-i-1$$ more choices from $$i+2<=x<n$$. Here, x represents the candidates i can choose. If I choose $$i+1 th$$ element I will have $$n-i-2$$ element to choose from $$i+3<=x<n$$ so first one is better which boils down to choosing the first element every time i get an element within allowable limit.\\n**(Hence there is a greedy way of selecting houses)**\\n# Complexity\\n- Time complexity:**O(nlogn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool calc(vector<int>& nums, int k,int mid)\\n    {\\n        int i=0,n=nums.size();\\n        while(i<n)\\n        {\\n            if(nums[i]<=mid)k--, i+=2;\\n            \\n            else i++;\\n            \\n            if(k == 0) return true;\\n        }\\n        return k == 0;\\n    }\\n    int minCapability(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        int lo = 0,hi = 1e9+1;\\n        while(lo<hi)\\n        {\\n            int mid = (lo+hi)/2;\\n            if(calc(nums, k, mid)) hi=mid;\\n            else lo=mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```\\n# Similar Problems:\\n1) [1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/)\\n2) [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/).\\n3) [1954. Minimum Garden Perimeter to Collect Enough Apples](https://leetcode.com/problems/minimum-garden-perimeter-to-collect-enough-apples/).\\n4) [2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/).\\n5) [1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/).\\n6) [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n7) [2009. Minimum Number of Operations to Make Array Continuous](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/)\\n8) [2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/description/) suggested by @20ryanc\\n9) [1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/)suggested by @hereToRock",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool calc(vector<int>& nums, int k,int mid)\\n    {\\n        int i=0,n=nums.size();\\n        while(i<n)\\n        {\\n            if(nums[i]<=mid)k--, i+=2;\\n            \\n            else i++;\\n            \\n            if(k == 0) return true;\\n        }\\n        return k == 0;\\n    }\\n    int minCapability(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        int lo = 0,hi = 1e9+1;\\n        while(lo<hi)\\n        {\\n            int mid = (lo+hi)/2;\\n            if(calc(nums, k, mid)) hi=mid;\\n            else lo=mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143685,
                "title": "binary-search",
                "content": "It could be tricky to see why a binary search works here.\\n\\nIf we want to steal no more than `m` money from each house, we can greedily count the maximum number of houses that we can steal from.\\n\\nThis is because it\\'s always better to steal from the house if we can, than to skip it. \\n> In other words, If we can steal from either `nums[i]` and `nums[i + 1]`, stealing from `nums[i]` allows us to also potentially steal from `nums[i + 2]`.\\n\\nAfter we steal from the house, we skip the next one.\\n\\nWe can use a binary search to find the minimum capability when stealing from `k` houses.\\n\\n**C++**\\n```cpp\\nint minCapability(vector<int>& nums, int k) {\\n    int l = 1, r = 1000000000;\\n    while (l < r) {\\n        int m = (l + r) / 2, take = 0;\\n        for (int i = 0; i < nums.size() && take < k; ++i) {\\n            take += nums[i] <= m;\\n            i += nums[i] <= m;\\n        }\\n        if (take < k)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minCapability(vector<int>& nums, int k) {\\n    int l = 1, r = 1000000000;\\n    while (l < r) {\\n        int m = (l + r) / 2, take = 0;\\n        for (int i = 0; i < nums.size() && take < k; ++i) {\\n            take += nums[i] <= m;\\n            i += nums[i] <= m;\\n        }\\n        if (take < k)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143852,
                "title": "binary-search-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsee code\\n\\n# Complexity\\n- Time complexity: O(nlog(10e9)) ~ O(30(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int minCapability(int[] a, int k) {\\n        int n = a.length;\\n        int l = a[0], r = a[0]; // left and right bound for binary search\\n\\n        for (int x : a) {\\n            l = Math.min(l, x);\\n            r = Math.max(r, x);\\n        }\\n\\n        while (l < r) { // straight forward binary search logic for min valid value\\n            int m = l + (r-l)/2;\\n            if (valid(a, m, k)) r = m;\\n            else l = m + 1;\\n        }\\n\\n        return l; // when search ends l == r, could return either one\\n    }\\n\\n    private boolean valid(int[] a, int m, int k) {\\n        for (int i = 0; i < a.length; ) {\\n            if (a[i] <= m) { // will hit ith house, GREEDY\\n                if (--k == 0) return true; // hit enough of k houses\\n                i += 2; // if this one is taken, stip next\\n            } else i++; // if this one is not taken, move on to next\\n        }\\n\\n        return false; // fail to hit k houses\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```java\\nclass Solution {\\n    public int minCapability(int[] a, int k) {\\n        int n = a.length;\\n        int l = a[0], r = a[0]; // left and right bound for binary search\\n\\n        for (int x : a) {\\n            l = Math.min(l, x);\\n            r = Math.max(r, x);\\n        }\\n\\n        while (l < r) { // straight forward binary search logic for min valid value\\n            int m = l + (r-l)/2;\\n            if (valid(a, m, k)) r = m;\\n            else l = m + 1;\\n        }\\n\\n        return l; // when search ends l == r, could return either one\\n    }\\n\\n    private boolean valid(int[] a, int m, int k) {\\n        for (int i = 0; i < a.length; ) {\\n            if (a[i] <= m) { // will hit ith house, GREEDY\\n                if (--k == 0) return true; // hit enough of k houses\\n                i += 2; // if this one is taken, stip next\\n            } else i++; // if this one is not taken, move on to next\\n        }\\n\\n        return false; // fail to hit k houses\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149864,
                "title": "from-tle-using-dp-to-100-fast-using-binary-search",
                "content": "# Intuition for DP\\nI think without looking at the constraints, the first idea that comes to mind is to check all the scenarios and return the best one, i.e., DP.\\n\\n# Approach\\nTo implement DP we first come up with the recurrance relation, we have a choice to make on each index, we can either take the element or skip it. If we take the element, we need to skip the next element. Also, we need to return the maximum element of the selected minimum sum subsequence so we can have:\\n```\\n    // this helps in finding the maximum element is the subsequence\\n    int take = max(nums[i], f(i+2, k-1));\\n    int not_take = f(i+1, k);\\n    // this helps is selecting the minimum sum subsequence\\n    return min(take, not_take);\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n * k)\\n\\n- Space complexity:\\nO(n * k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& nums, int k, vector<vector<int> > &dp) {\\n        if (k == 0)\\n            return 0;\\n        if (i>=nums.size()) return INT_MAX;\\n        if (dp[i][k] != -1) return dp[i][k];\\n\\n        int take = max(nums[i], f(i+2, nums, k-1, dp));\\n        int not_take = f(i+1, nums, k, dp);\\n        return dp[i][k] = min(take, not_take);\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        vector<vector<int> > dp(nums.size(), vector<int>(k+1, -1));\\n        return f(0, nums, k, dp);\\n    }\\n};\\n```\\n# Intution for Binary Search\\nAfter looking at the constraints we know that we need a solution with **O(n * logn)** or better TC, thus DP will be too expensive and will give TLE. Moreover, if we read carefully we can observe that the question asks to find the \"***minimum capability of the robber to steal at least k houses***\", this is a central idea in binary search, as we need to find minimum possible value of capability from a range of values, we should start thinking of applying BS on capability.\\n\\n# Approach for Binary Search\\nWe can observe that the range of our answer(capability) will be from 1 to 1e9. We can simply check for each of these values starting from 1, whether it is possible to have at least k elements with current value as the minimum capability. To improve the TC, we can simply use BS. We first need to write the helper function which will tell us if it is possible to select at least \"k\" elements with current capability as minimum. If the answer is \"yes\", we look for a lower value of capability, if not, we search for a higher one.\\n\\nAlso note that this helper function can pick the element if is lower or equal to the current capability, greedily! We can observe that using simple cases for n<5. Mathematically, we can prove this works using induction on n.\\n\\n# Complexity\\n- Time complexity:\\nO(n * log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int m, vector<int>& nums, int k) {\\n        int i=0;\\n        while (i<nums.size()) {\\n            if (nums[i] <= m) {\\n                i+=2;\\n                k--;\\n            }\\n            else i++;\\n\\n            if (k==0) return true;\\n        }\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int l = 1, r = *max_element(nums.begin(), nums.end());\\n        \\n        while (l<r) {\\n            int m = (l + r) / 2;\\n            if (isPossible(m, nums, k))\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n    // this helps in finding the maximum element is the subsequence\\n    int take = max(nums[i], f(i+2, k-1));\\n    int not_take = f(i+1, k);\\n    // this helps is selecting the minimum sum subsequence\\n    return min(take, not_take);\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i, vector<int>& nums, int k, vector<vector<int> > &dp) {\\n        if (k == 0)\\n            return 0;\\n        if (i>=nums.size()) return INT_MAX;\\n        if (dp[i][k] != -1) return dp[i][k];\\n\\n        int take = max(nums[i], f(i+2, nums, k-1, dp));\\n        int not_take = f(i+1, nums, k, dp);\\n        return dp[i][k] = min(take, not_take);\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        vector<vector<int> > dp(nums.size(), vector<int>(k+1, -1));\\n        return f(0, nums, k, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int m, vector<int>& nums, int k) {\\n        int i=0;\\n        while (i<nums.size()) {\\n            if (nums[i] <= m) {\\n                i+=2;\\n                k--;\\n            }\\n            else i++;\\n\\n            if (k==0) return true;\\n        }\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int l = 1, r = *max_element(nums.begin(), nums.end());\\n        \\n        while (l<r) {\\n            int m = (l + r) / 2;\\n            if (isPossible(m, nums, k))\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145793,
                "title": "easy-simple-c-solution-using-binary-search-100-fast-o-1-space-o-n-logn-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->     \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log(n)) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(vector<int>&a, int mid){\\n        int last_picked = -2;\\n        int cnt= 0 ;\\n        for(int i = 0 ;i<a.size();i++){\\n            if(a[i]<=mid && last_picked!=i-1){\\n                last_picked = i;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int minCapability(vector<int>& a, int k) {\\n        int n = a.size();        \\n        int lo = *min_element(a.begin(),a.end());\\n        int hi = *max_element(a.begin(),a.end());\\n        int ans = - 1;\\n        while(hi>=lo){\\n            int mid = (hi+lo)/2;\\n            if(check(a,mid)>=k){\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&a, int mid){\\n        int last_picked = -2;\\n        int cnt= 0 ;\\n        for(int i = 0 ;i<a.size();i++){\\n            if(a[i]<=mid && last_picked!=i-1){\\n                last_picked = i;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int minCapability(vector<int>& a, int k) {\\n        int n = a.size();        \\n        int lo = *min_element(a.begin(),a.end());\\n        int hi = *max_element(a.begin(),a.end());\\n        int ans = - 1;\\n        while(hi>=lo){\\n            int mid = (hi+lo)/2;\\n            if(check(a,mid)>=k){\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143993,
                "title": "java-binary-search-greedy-with-explanation",
                "content": "# Intuition\\n`Binary Search` is always a good option to try if you met the Minimum maximum question (or Maximum minimum question).\\n\\nThere are 2 thoughts for this question.\\n\\n1. If the minimum feasible capability is `i`, then all capabilities larger than `i` are also possible. That fits the nature of `binary search`.\\n\\nSo the current problem becomes how we can verify if the current capability is possible? \\n\\n2. we can just use `Greedy` to find out if the current capability is feasible or not. We always choose the left feasible house first because it can\\'t be worse than selecting the right one. \\n\\nWe can use `Contradiction` to prove that. \\nFor example, there are two adjacent feasible houses. If the solution is we choose the right house and other houses on its right, then it is always feasible that we choose the left house instead of the right one. Because if the other houses are not adjacent to the right house, then they can\\'t be adjacent to the left house as well.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        // find the range of the possible capabilities\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n            min = Math.min(min, num);\\n        }\\n        // binary search\\n        int start = min, end = max;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (isPossible(nums, mid, k)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n    private boolean isPossible(int[] nums, int target, int k) {\\n        // greedy here\\n        int lastStolenIndex = -2;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] <= target && lastStolenIndex + 1 < i) {\\n                k -= 1;\\n                lastStolenIndex = i;\\n                if (k == 0) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        // find the range of the possible capabilities\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n            min = Math.min(min, num);\\n        }\\n        // binary search\\n        int start = min, end = max;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (isPossible(nums, mid, k)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return start;\\n    }\\n    private boolean isPossible(int[] nums, int target, int k) {\\n        // greedy here\\n        int lastStolenIndex = -2;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] <= target && lastStolenIndex + 1 < i) {\\n                k -= 1;\\n                lastStolenIndex = i;\\n                if (k == 0) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146900,
                "title": "c-binary-search-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Since if we see it is a mini-max problem beacuse here we have to find minimize the maximum amount of money house  which robber steal.\\n- Use binary search and greedy appraoch for checking for a particular mid if our `taken >=k` then we need to decrease the mid i.e `high=mid-1`\\nif `taken < k` then `low=mid+1;`.\\n- Greedy approach will check if our guess i.e mid is greater than k or less than k houses in which robber can rob. SO iterate over the array and pick any k non-adjacent elements that are smaller than our mid . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& arr, int k) {\\n        int low=*min_element(arr.begin(),arr.end());\\n        int high=*max_element(arr.begin(),arr.end());\\n        int n=arr.size();\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            int taken=0;\\n            for(int i=0;i<n;i++)\\n               if(mid>=arr[i])taken++,i++;\\n             if(taken<k)low=mid+1;\\n            else high=mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& arr, int k) {\\n        int low=*min_element(arr.begin(),arr.end());\\n        int high=*max_element(arr.begin(),arr.end());\\n        int n=arr.size();\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            int taken=0;\\n            for(int i=0;i<n;i++)\\n               if(mid>=arr[i])taken++,i++;\\n             if(taken<k)low=mid+1;\\n            else high=mid-1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526930,
                "title": "binary-search-c-easy-to-uderstand",
                "content": "binary search for in range (max and min element present in array).\\nend check for mid value that is possible ans or not.\\nif yes that try to minimize it\\nelse maximise it.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int mn = INT_MAX,mx = 0,mid,ans;\\n        for(auto &i: nums){\\n            mn = min(mn,i);\\n            mx = max(mx,i);\\n        }\\n        int n = nums.size(),i;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            vector<int> v(n,0);\\n            for(i = 0; i < n; i++){\\n                if(i==0){\\n                    if(nums[i]<=mid){\\n                        v[i] = 1;\\n                    }\\n                }else if(i==1){\\n                    if(nums[i]<=mid){\\n                        v[i] = 1;\\n                    }\\n                    v[i] = max(v[i],v[i-1]);\\n                }else{\\n                    if(nums[i]<=mid){\\n                        v[i] = max(v[i-2]+1,v[i-1]);\\n                    }else{\\n                        v[i] = v[i-1];\\n                    }\\n                }\\n            }\\n            // for(auto &i: v)cout<<i<<\" \";\\n            // cout<<\" <- \"<<mid<<\" \\\\n\";\\n            if(v[n-1]>=k){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int mn = INT_MAX,mx = 0,mid,ans;\\n        for(auto &i: nums){\\n            mn = min(mn,i);\\n            mx = max(mx,i);\\n        }\\n        int n = nums.size(),i;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            vector<int> v(n,0);\\n            for(i = 0; i < n; i++){\\n                if(i==0){\\n                    if(nums[i]<=mid){\\n                        v[i] = 1;\\n                    }\\n                }else if(i==1){\\n                    if(nums[i]<=mid){\\n                        v[i] = 1;\\n                    }\\n                    v[i] = max(v[i],v[i-1]);\\n                }else{\\n                    if(nums[i]<=mid){\\n                        v[i] = max(v[i-2]+1,v[i-1]);\\n                    }else{\\n                        v[i] = v[i-1];\\n                    }\\n                }\\n            }\\n            // for(auto &i: v)cout<<i<<\" \";\\n            // cout<<\" <- \"<<mid<<\" \\\\n\";\\n            if(v[n-1]>=k){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3144726,
                "title": "super-simple-binary-search-comments-easy-code-c-solution",
                "content": "\\n# Approach\\nMake Binary Search on the answer - The minimum capability that he can steal. and check whether the following binary search answer is posibile or not.\\n\\n# Complexity\\n- Time complexity: nlog(1e9);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& arr, int k, int mid, int n)\\n    {\\n        for(int i=0; i<n && k; i++)\\n        {\\n            // if you pick the current element then i+=2;\\n            if(arr[i] <= mid)\\n            {\\n                k--; i++;\\n            }\\n            // else i+=1;\\n        }\\n\\n        //atleast k elements should be less than the mid\\n        // then it is possible\\n        return k == 0;\\n    }\\n  \\n    int minCapability(vector<int>& arr, int k) \\n    {\\n        int n = arr.size();\\n        int mini = 1e9;\\n        int low = 1, high = 1e9;\\n\\n        //Make Binary Search on the minimum capability.\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n\\n            // Check whether our mid(minimum capability) is true or not\\n            if(check(arr, k , mid, n))\\n            {\\n                mini = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& arr, int k, int mid, int n)\\n    {\\n        for(int i=0; i<n && k; i++)\\n        {\\n            // if you pick the current element then i+=2;\\n            if(arr[i] <= mid)\\n            {\\n                k--; i++;\\n            }\\n            // else i+=1;\\n        }\\n\\n        //atleast k elements should be less than the mid\\n        // then it is possible\\n        return k == 0;\\n    }\\n  \\n    int minCapability(vector<int>& arr, int k) \\n    {\\n        int n = arr.size();\\n        int mini = 1e9;\\n        int low = 1, high = 1e9;\\n\\n        //Make Binary Search on the minimum capability.\\n        while(low <= high)\\n        {\\n            int mid = (low+high)/2;\\n\\n            // Check whether our mid(minimum capability) is true or not\\n            if(check(arr, k , mid, n))\\n            {\\n                mini = mid;\\n                high = mid-1;\\n            }\\n            else low = mid+1;\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143745,
                "title": "c-easy-binary-search-n-log-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRun binary search on possible answer range [min(nums) , max[(nums)]].\\nIf found the value store it in the answer variable and the find the next best possible answer.\\n\\n**How to check for if current mid is a possible answer ?**\\nHere the check function does that.\\n\\n- Store the indexes of all elements having value less than equal to k.\\n- Then find the size of consecutive block having values less than equal to k.\\n- And remove exactly floor of the size of the consecutive block.\\n- Add the new size to the answer.\\n\\nFinally check if the overall size is greater than equal to k or not.\\n\\n# Complexity\\n- Time complexity:\\nO(N log N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &nums, int mid, int k)\\n    {\\n        int n = nums.size();\\n        vector<int> temp;\\n\\n        for(int i=0;i<n;i++)\\n            if(nums[i]<=mid)\\n                temp.push_back(i);\\n        \\n        if(temp.size()<k)\\n            return false;\\n\\n        int sz = 0;\\n        int cnt = 1;\\n        for(int i=1;i<temp.size();i++)\\n        {\\n            if(temp[i]==temp[i-1]+1)\\n                cnt++;\\n            else\\n            {\\n                sz+=(cnt+1)/2;\\n                cnt=1;\\n            }\\n        }\\n        sz+=(cnt+1)/2;\\n        \\n        if(sz<k)\\n            return false;\\n        return true;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        \\n        int ans = *max_element(nums.begin(),nums.end());\\n        int l = *min_element(nums.begin(),nums.end()), r = *max_element(nums.begin(),nums.end());\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(check(nums,mid,k))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else \\n                l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &nums, int mid, int k)\\n    {\\n        int n = nums.size();\\n        vector<int> temp;\\n\\n        for(int i=0;i<n;i++)\\n            if(nums[i]<=mid)\\n                temp.push_back(i);\\n        \\n        if(temp.size()<k)\\n            return false;\\n\\n        int sz = 0;\\n        int cnt = 1;\\n        for(int i=1;i<temp.size();i++)\\n        {\\n            if(temp[i]==temp[i-1]+1)\\n                cnt++;\\n            else\\n            {\\n                sz+=(cnt+1)/2;\\n                cnt=1;\\n            }\\n        }\\n        sz+=(cnt+1)/2;\\n        \\n        if(sz<k)\\n            return false;\\n        return true;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        \\n        int ans = *max_element(nums.begin(),nums.end());\\n        int l = *min_element(nums.begin(),nums.end()), r = *max_element(nums.begin(),nums.end());\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(check(nums,mid,k))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else \\n                l = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831060,
                "title": "c-c-explained-binary-search-greedy-or-dp-beats-100-nlog-m-time-o-1-space",
                "content": "# Explanation\\nThe problem has essentially asked us to find the $k$-element subset, $S$, of ```nums``` such that $\\\\max(S)$ (the capability) is minimized and no two elements of the subset are adjacent to $\\\\max(S)$ in ```nums``` (we\\'ll call a set with the latter property an independent set). \\n\\nWe know that we can limit our search to the range $[min($```nums```$), max($```nums```$)]$ since the minimum capability is necessarily in ```nums```. From here, all we need to do is find the minimal $n \\\\in [min($```nums```$), max($```nums```$)]$ such that $n$ is the maximum of some $k$-element independent subset of ```nums```. We accomplish this by performing a binary search on the specified range. In each step of the binary search, we place an upper bound on the capability of any independent subset of `nums`. In other words, for some considered $n$ in the binary search, we check if there exists a $k$-element independent subset of `nums` whose capability is upper bounded by $n$. If such an independent set of $k$ elements exists, then we need only search the left half of our current range for a potentially smaller capability. Otherwise, we search the right half of our current range since there is clearly no value $m$ smaller than $n$ such that $m$ is greater than or equal to the maximum of a $k$-element independent subset of ```nums``` (since such a $k$-element independent subset would\\'ve been found when considering $n$). Just to make sure, you must understand that each step of the binary search places an UPPER BOUND, $n$, on the capability of each $k$-element independent subset of `nums`, however, discovering that such a subset exists does not mean that $n$ is a valid capability under the constrain of $k$. Let\\'s look at an example to make this clear: suppose `nums = [3,9,2,5,1]` and $k = 3$. The minimum capability of `nums` is `3`. However, notice that the first $n$ considered during our binary search will be $5$. We will find that there exists a $k$-element independent set with a capability less than $5$, namely $\\\\{3,2,1\\\\}$, however, this does not mean $5$ is a valid capability of `nums` even though $5$ is in `nums` (there is no independent set of $3$ elements less than $5$ in `nums`).\\n\\nOne step that was brushed over was checking if for some $n$, there exists a $k$-element independent subset of `nums` with a capability upper bounded by $n$. To do this check, we will construct the largest possible independent subset of `nums` with a capability less than or equal to $n$ and determine if it has a size of at least $k$. One way to approach this is to derive a recurrence and apply dynamic programming. If for some $n$ we let $dp(i)$ denote the largest independent subset with capability less than $n$ and elements in the subarray `nums[0,...,i]`, then `dp(i) = max(dp(i - 1), ((nums[i] <= n) ? 1 : 0) + dp(i - 2))` because we can either choose to include the current element in the $k$-element independent subset or not (given that the current element is upper bounded by $n$). It\\'s possible to implement this as a constant space dynamic programming problem, but we can also just choose elements greedily for our $k$-element independent subset with capability less than $n$. Here\\'s why: suppose we iterate over `nums` and find an element `nums[i]` such that `nums[i] <= n`. If `nums[i + 1] > n`, we can just add `nums[i]` to our set. But if `nums[i + 1] <= n`, how do we know to add `nums[i]` or `nums[i + 1]` to our set? Could adding `nums[i]` to our set lead to a worse solution than adding `nums[i + 1]`. It turns out that choosing `nums[i]` is always at least as good as choosing `nums[i + 1]`. I won\\'t write a formal proof for this, but think of it this way: if we choose `nums[i]` or `nums[i + 1]`, the size of our set increases by $1$ either way, however, suppose `nums[i + 2] <= n`, then by choosing `nums[i + 1]`, we lose the possibility of adding `nums[i + 2]` to our set whereas if we choose `nums[i]`, we can also add `nums[i + 2]` to our set.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\cdot log(m))$$ where $n$ is the size of `nums` and \\n$m$ is $max($`nums`$) - min($`nums`$)$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Greedy Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n\\n        int left, right, mid, subsetLength, n;\\n\\n        n = nums.size();\\n        left = right = nums[0];\\n\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (nums[i] < left) left = nums[i];\\n            else if (nums[i] > right) right = nums[i];\\n        }\\n\\n        for (; left < right; )\\n        {\\n            mid = left + ((right - left) / 2);\\n            subsetLength = 0;\\n\\n            for (int i = 0; i < n && subsetLength < k; ++i)\\n                if (nums[i] <= mid)\\n                    ++i, ++subsetLength;\\n\\n            if (subsetLength == k)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n\\n        return left;\\n    }\\n```\\n\\n# DP Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n\\n        int left, right, mid, n;\\n\\n        n = nums.size();\\n        left = right = nums[0];\\n\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (nums[i] < left) left = nums[i];\\n            else if (nums[i] > right) right = nums[i];\\n        }\\n\\n        for (; left < right; )\\n        {\\n            mid = left + ((right - left) / 2);\\n\\n            int dpOneBack, dpTwoBack;\\n\\n            if (nums[0] <= mid)\\n                dpOneBack = dpTwoBack = 1;\\n            else \\n            {\\n                dpTwoBack = 0;\\n                dpOneBack = (nums[1] <= mid) ? 1 : 0;\\n            }\\n\\n            for (int i = 2, tmp; i < n && dpOneBack < k; ++i)\\n            {\\n                tmp = dpOneBack;\\n                dpOneBack = max(dpOneBack, ((nums[i] <= mid) ? 1 : 0) + dpTwoBack);\\n                dpTwoBack = tmp;\\n            }\\n\\n            if (dpOneBack == k)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```nums```\n```nums```\n```nums```\n```nums```\n```nums```\n```nums```\n```nums```\n```nums```\n```nums```\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n\\n        int left, right, mid, subsetLength, n;\\n\\n        n = nums.size();\\n        left = right = nums[0];\\n\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (nums[i] < left) left = nums[i];\\n            else if (nums[i] > right) right = nums[i];\\n        }\\n\\n        for (; left < right; )\\n        {\\n            mid = left + ((right - left) / 2);\\n            subsetLength = 0;\\n\\n            for (int i = 0; i < n && subsetLength < k; ++i)\\n                if (nums[i] <= mid)\\n                    ++i, ++subsetLength;\\n\\n            if (subsetLength == k)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n\\n        return left;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n\\n        int left, right, mid, n;\\n\\n        n = nums.size();\\n        left = right = nums[0];\\n\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (nums[i] < left) left = nums[i];\\n            else if (nums[i] > right) right = nums[i];\\n        }\\n\\n        for (; left < right; )\\n        {\\n            mid = left + ((right - left) / 2);\\n\\n            int dpOneBack, dpTwoBack;\\n\\n            if (nums[0] <= mid)\\n                dpOneBack = dpTwoBack = 1;\\n            else \\n            {\\n                dpTwoBack = 0;\\n                dpOneBack = (nums[1] <= mid) ? 1 : 0;\\n            }\\n\\n            for (int i = 2, tmp; i < n && dpOneBack < k; ++i)\\n            {\\n                tmp = dpOneBack;\\n                dpOneBack = max(dpOneBack, ((nums[i] <= mid) ? 1 : 0) + dpTwoBack);\\n                dpTwoBack = tmp;\\n            }\\n\\n            if (dpOneBack == k)\\n                right = mid;\\n            else\\n                left = mid + 1;\\n        }\\n\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301924,
                "title": "java-binary-search-on-answers-explained",
                "content": "# Previous post with one of the best explanations got removed \\u2639\\uFE0F\\n---\\n![image.png](https://assets.leetcode.com/users/images/b770bf6e-40a6-4e07-b7e4-9727b689ba4f_1678915050.242989.png)\\n\\n---\\n### Code with commented explanation:\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        // We don\\'t know what our minimum capability is going to be\\n        // so we would do a hit and trial on the given range 1 to 10^9\\n        // trying a linear search is possible, but that\\'d not fit in our constraints\\n        // since the range is sorted, we can use binary search\\n        // to look for the minimum capability to reduce our runtime\\n        int l = 1, r = (int) 1e9;  // initial range\\n        while (l < r) {\\n            // lets try fixing a min capability = mid\\n            int mid = l + (r - l) / 2;\\n            // check if its possible to rob atleast k houses by fixing a min capability = mid\\n            // if yes, we will try again by decreasing our min capability\\n            if (isPossible(nums, mid, k)) { \\n                // mid is a candidate so we keep it in our range\\n                // if we do r = mid - 1 and say we don\\'t get any new candidate in the new range \\n                // this mid which could be the answer would be lost\\n                r = mid;\\n            } \\n            // if not, we will fix a min capability more than \\'mid\\' and try again \\n            else {\\n                // mid is not a candidate so skip it and take range from after mid\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return r;   // return r as it\\'d be holding the \\'mid\\'\\n    }\\n    \\n    private boolean isPossible(int[] nums, int maxMoney, int k) {\\n        int houseStolen = 0;    // to count the number of houses we have robbed \\n        // we can\\'t rob adjacent houses, so we need to keep track of the last index we robbed at\\n        int lastStolenIdx = -2;\\n        for (int i = 0; i < nums.length; i++) {\\n            // if money in current house is more than what we have fixed\\n            // we can\\'t rob it, otherwise our minimum capability would increase\\n            if (nums[i] > maxMoney) {\\n                continue;\\n            }\\n            // we cannot rob the house if we just robbed the previous house\\n            if (i == lastStolenIdx + 1) {\\n                continue;\\n            }\\n            \\n            // otherwise, we rob\\n            houseStolen++;      // number of robbed houses increments\\n            lastStolenIdx = i;  // last robbed place is the current index\\n        }\\n        \\n        // return if we have been able to rob atleast k houses\\n        return houseStolen >= k;\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n``` java []\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int l = 1, r = (int) 1e9;  \\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (isPossible(nums, mid, k)) { \\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return r;   \\n    }\\n    \\n    private boolean isPossible(int[] nums, int maxMoney, int k) {\\n        int houseStolen = 0, lastStolenIdx = -2;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > maxMoney) {\\n                continue;\\n            }\\n            if (i == lastStolenIdx + 1) {\\n                continue;\\n            }\\n            \\n            houseStolen++;    \\n            lastStolenIdx = i; \\n        }\\n        \\n        return houseStolen >= k;\\n    }\\n}\\n```\\n---\\n*The for loop inside* `isPossible()` *can be written this way well:*\\n``` java[]\\nfor (int i = 0; i < nums.length; i++) {\\n    // if money is lesser than minimum capability\\n    if (nums[i] <= maxMoney) {  \\n        houseStolen++;  // we can rob\\n        i++;   // make an extra jump to skip the next house\\n    }\\n}\\n```\\n\\n---\\n#### *Short and simplified solution:*\\n``` java []\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int l = 1, r = (int) 1e9;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            int houseStolen = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums[i] <= mid) {\\n                    houseStolen++;\\n                    i++;\\n                }\\n            }\\n            if (houseStolen >= k) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n}\\n```\\n--- \\n### Complexity analysis:\\nLet $$n$$ be the size of our search space ($$1$$ -> $$10^9$$) and $$m$$ be the number of houses. \\n\\nWe are performing a binary search on the search space which would cost $$O(logn)$$ runtime and a thorough looping over the houses which would cost $$O(m)$$ runtime.\\n##### Time complexity: $$O(m * logn)$$\\n##### Space complexity: $$O(1)$$",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        // We don\\'t know what our minimum capability is going to be\\n        // so we would do a hit and trial on the given range 1 to 10^9\\n        // trying a linear search is possible, but that\\'d not fit in our constraints\\n        // since the range is sorted, we can use binary search\\n        // to look for the minimum capability to reduce our runtime\\n        int l = 1, r = (int) 1e9;  // initial range\\n        while (l < r) {\\n            // lets try fixing a min capability = mid\\n            int mid = l + (r - l) / 2;\\n            // check if its possible to rob atleast k houses by fixing a min capability = mid\\n            // if yes, we will try again by decreasing our min capability\\n            if (isPossible(nums, mid, k)) { \\n                // mid is a candidate so we keep it in our range\\n                // if we do r = mid - 1 and say we don\\'t get any new candidate in the new range \\n                // this mid which could be the answer would be lost\\n                r = mid;\\n            } \\n            // if not, we will fix a min capability more than \\'mid\\' and try again \\n            else {\\n                // mid is not a candidate so skip it and take range from after mid\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return r;   // return r as it\\'d be holding the \\'mid\\'\\n    }\\n    \\n    private boolean isPossible(int[] nums, int maxMoney, int k) {\\n        int houseStolen = 0;    // to count the number of houses we have robbed \\n        // we can\\'t rob adjacent houses, so we need to keep track of the last index we robbed at\\n        int lastStolenIdx = -2;\\n        for (int i = 0; i < nums.length; i++) {\\n            // if money in current house is more than what we have fixed\\n            // we can\\'t rob it, otherwise our minimum capability would increase\\n            if (nums[i] > maxMoney) {\\n                continue;\\n            }\\n            // we cannot rob the house if we just robbed the previous house\\n            if (i == lastStolenIdx + 1) {\\n                continue;\\n            }\\n            \\n            // otherwise, we rob\\n            houseStolen++;      // number of robbed houses increments\\n            lastStolenIdx = i;  // last robbed place is the current index\\n        }\\n        \\n        // return if we have been able to rob atleast k houses\\n        return houseStolen >= k;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int l = 1, r = (int) 1e9;  \\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (isPossible(nums, mid, k)) { \\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return r;   \\n    }\\n    \\n    private boolean isPossible(int[] nums, int maxMoney, int k) {\\n        int houseStolen = 0, lastStolenIdx = -2;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > maxMoney) {\\n                continue;\\n            }\\n            if (i == lastStolenIdx + 1) {\\n                continue;\\n            }\\n            \\n            houseStolen++;    \\n            lastStolenIdx = i; \\n        }\\n        \\n        return houseStolen >= k;\\n    }\\n}\\n```\n``` java[]\\nfor (int i = 0; i < nums.length; i++) {\\n    // if money is lesser than minimum capability\\n    if (nums[i] <= maxMoney) {  \\n        houseStolen++;  // we can rob\\n        i++;   // make an extra jump to skip the next house\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int l = 1, r = (int) 1e9;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            int houseStolen = 0;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums[i] <= mid) {\\n                    houseStolen++;\\n                    i++;\\n                }\\n            }\\n            if (houseStolen >= k) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222332,
                "title": "brute-force-to-binary-search-full-explanation-beginner-friendly-easy-to-understand",
                "content": "# Intuition (Brute Force)\\nWhat we need to do?\\nWe need the min capability and also the capability is the max element he could rob from the array.\\nSo the capability/ans will be any one element from the array.\\nSo we can just check each element if it is my ans or not.\\n\\n**HOW?**\\nFor any element to be my ans, there must be k-1 valid robberies in the array.\\n\\n***What are valid robberies?***\\n1. The element must be less than or equal to my selected element, that is if we are checking for say nums[i], then element must be less than or equal to nums[i].\\n    Why?\\n    Because I want my selected element to be the max element.\\n2. Since adjacent elements can not be robbed, valid robbery won\\'t have adjacent elements.\\n\\nIf any element can pass both this condition, that means this can be my ans. So we can simply do\\n```\\nif(check(nums[i], nums, k)){\\n    ans = Math.min(ans, nums[i]);\\n}\\n```\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Understanding the check function**\\nIf we want nums[i] to be my ans, this nums[i] must be my max element among k valid robbery.\\nSo we can have a variable cnt, that will be the count of valid robberies.\\nAnd since there is a factor of adjacent indexes, we will also have a variable prev which tells us the index of previously taken element, so that we won\\'t be able to take any adjacent element of prev.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt would be O(n^2) solution since for every element we are iterating the array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) // since no extra space used.\\n\\n# Code (Brute Force)\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(func(nums[i], k, nums)){\\n                ans = Math.min(ans, nums[i]);\\n            }\\n        }\\n    }\\n\\n    public boolean func(int max, int k, int[] nums){\\n        int cnt = 0, prev = -1;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] > max || (prev != -1 && i == prev+1 || i == prev-1) ){\\n                continue; \\n            }else{\\n                prev = i;\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```\\n\\n# Binary Search Approach\\nFrom the brute force approach we got how to check if my curr element is valid or not, we just need to find a way of getting the element is logn time.\\nIf we carefully observe, we can following observations --\\n1. My maximum ans can be the maximum element of my array, since that will be the maximum capability robber can have.\\n2. Also if my robber can have capability of 6 then we can also have capability of 7,8,9 and so on, because if he has capability of 6 then there must be k element >= 6,then obviously there will be k elements >= 7,8,9,etc.\\n3. Similarly if there are not k elements >= 3 then there will never be k elements >= 2,1 and so on..\\n4. From this we can have a binary search intution.\\n\\n# Approach\\nWe can do binary search on ans, where ans can be in the range of [1, max(nums)], if my mid is valid then my mid can be my ans, but we will go further left to get any smaller ans, else move right to get a valid ans.\\nOur check function will be the same.\\n\\n# Time Complexity\\nO(nlogn)\\nO(n) for every check that we do, for each mid and (logn) for binary search.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int low = 1, high = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            high = Math.max(high, nums[i]);\\n        }\\n\\n        while(low < high){\\n            int mid = low + (high-low)/2;\\n\\n            if(func(mid, k, nums)){\\n                high = mid;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return high;\\n    }\\n\\n    public boolean func(int max, int k, int[] nums){\\n        int cnt = 0, prev = -1;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] > max || (prev != -1 && i == prev+1 || i == prev-1) ){\\n                continue; \\n            }else{\\n                prev = i;\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nif(check(nums[i], nums, k)){\\n    ans = Math.min(ans, nums[i]);\\n}\\n```\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(func(nums[i], k, nums)){\\n                ans = Math.min(ans, nums[i]);\\n            }\\n        }\\n    }\\n\\n    public boolean func(int max, int k, int[] nums){\\n        int cnt = 0, prev = -1;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] > max || (prev != -1 && i == prev+1 || i == prev-1) ){\\n                continue; \\n            }else{\\n                prev = i;\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int low = 1, high = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            high = Math.max(high, nums[i]);\\n        }\\n\\n        while(low < high){\\n            int mid = low + (high-low)/2;\\n\\n            if(func(mid, k, nums)){\\n                high = mid;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        return high;\\n    }\\n\\n    public boolean func(int max, int k, int[] nums){\\n        int cnt = 0, prev = -1;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] > max || (prev != -1 && i == prev+1 || i == prev-1) ){\\n                continue; \\n            }else{\\n                prev = i;\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146028,
                "title": "python-3-binary-search-with-simple-check",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        def check(cap):\\n            count=taken=0\\n            for x in nums:\\n                if taken:\\n                    taken=False\\n                elif x<=cap:\\n                    count+=1\\n                    taken=True\\n            return count>=k\\n        l,r=min(nums),max(nums)\\n        while l<=r:\\n            mid=l+(r-l)//2\\n            if check(mid):\\n                res=mid\\n                r=mid-1\\n            else:\\n                l=mid+1\\n        return res       \\n```\\n\\nAnother Problem that does not strike as binary search-https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        def check(cap):\\n            count=taken=0\\n            for x in nums:\\n                if taken:\\n                    taken=False\\n                elif x<=cap:\\n                    count+=1\\n                    taken=True\\n            return count>=k\\n        l,r=min(nums),max(nums)\\n        while l<=r:\\n            mid=l+(r-l)//2\\n            if check(mid):\\n                res=mid\\n                r=mid-1\\n            else:\\n                l=mid+1\\n        return res       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144546,
                "title": "100-faster-binary-search",
                "content": "# Intuition\\nwe need to find minimum ability among all. \\nminimum ability is maximum of all robbed house. so we need to find k smallest rob.\\n\\n# Approach\\nbrute force approcah will take O(n2) so to optimise it we have to use Binary search on answer.\\n\\nwe will find that mid is answer or not. to check weatcher mid is answer i have implement a method valid.\\n\\n\\n# Complexity\\n- Time complexity:\\n(n*log(n))\\n\\n- Space complexity:\\nO(n) -> input vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int valid(int mid,vector<int> &nums,int k){\\n        int cn=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]<=mid){\\n                cn++;\\n                i++;\\n            }\\n        }\\n        return cn>=k;\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        int lo=0,hi=1e9;\\n        while(hi-lo>1){\\n            int mid=(long long)(hi+lo)/2;\\n            if(valid(mid,nums,k)){\\n                hi=mid;\\n            }else{\\n                lo=mid;\\n            }\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int valid(int mid,vector<int> &nums,int k){\\n        int cn=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]<=mid){\\n                cn++;\\n                i++;\\n            }\\n        }\\n        return cn>=k;\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        int lo=0,hi=1e9;\\n        while(hi-lo>1){\\n            int mid=(long long)(hi+lo)/2;\\n            if(valid(mid,nums,k)){\\n                hi=mid;\\n            }else{\\n                lo=mid;\\n            }\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831365,
                "title": "easy-binary-search-solution-beats-100-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int lo = Integer.MAX_VALUE, hi = Integer.MIN_VALUE;\\n\\n        for(int it : nums){\\n            lo = Math.min(lo, it);\\n            hi = Math.max(hi, it);\\n        }\\n\\n        while(lo < hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(nums,k,mid)){\\n                hi = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n\\n    private boolean check(int[] nums, int k, int val){\\n        int ct = 0;\\n\\n        for(int i = 0;i < nums.length;i++){\\n            if(nums[i] <= val){\\n                i++;\\n                ct++;\\n                if(ct == k) return true;\\n            }\\n        }\\n\\n        return ct >= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int lo = Integer.MAX_VALUE, hi = Integer.MIN_VALUE;\\n\\n        for(int it : nums){\\n            lo = Math.min(lo, it);\\n            hi = Math.max(hi, it);\\n        }\\n\\n        while(lo < hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(nums,k,mid)){\\n                hi = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n\\n    private boolean check(int[] nums, int k, int val){\\n        int ct = 0;\\n\\n        for(int i = 0;i < nums.length;i++){\\n            if(nums[i] <= val){\\n                i++;\\n                ct++;\\n                if(ct == k) return true;\\n            }\\n        }\\n\\n        return ct >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756280,
                "title": "best-c-solution-list-of-similar-very-imp-binary-problems",
                "content": "# [List of similar binary search questions](https://leetcode.com/problems/koko-eating-bananas/solutions/3750804/best-c-solution-list-of-9-similar-very-imp-binary-search-questions/)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& A, int k) {\\n        int start = 1, end = 1e9, n = A.size();\\n        while (start < end){\\n            int mid = (start + end) / 2, take = 0;\\n            for (int i = 0; i < n; ++i)\\n                if (A[i] <= mid)\\n                    take++, i++;\\n            if(take >= k)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& A, int k) {\\n        int start = 1, end = 1e9, n = A.size();\\n        while (start < end){\\n            int mid = (start + end) / 2, take = 0;\\n            for (int i = 0; i < n; ++i)\\n                if (A[i] <= mid)\\n                    take++, i++;\\n            if(take >= k)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148762,
                "title": "100-faster-easy-to-understand-solution",
                "content": "```\\n bool ispossible(vector<int>& nums, int mid, int k){\\n          int i = 0, n = nums.size();\\n        while (i < n) {\\n            if (nums[i] <= mid) {\\n                k--;\\n                i+=2;\\n            }\\n            else {\\n                i++;\\n            }\\n            if (k == 0) {\\n                return true;\\n            }\\n        }\\n        return k == 0;\\n    }\\n        \\n   int minCapability(vector<int>& nums, int k) {\\n        int st=INT_MAX;\\n        \\n        int end=INT_MIN;\\n        for(int i=0; i<nums.size(); i++){\\n            end = max(end, nums[i]);\\n            st = min(st, nums[i]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        while(st<=end){\\n            int mid=st+(end-st)/2;\\n            if(ispossible(nums,mid,k)){\\n                ans = min(ans, mid);\\n                end = mid-1;\\n            }\\n            else{\\n                st = mid+1;\\n            }\\n         }\\n         return ans;\\n   }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n bool ispossible(vector<int>& nums, int mid, int k){\\n          int i = 0, n = nums.size();\\n        while (i < n) {\\n            if (nums[i] <= mid) {\\n                k--;\\n                i+=2;\\n            }\\n            else {\\n                i++;\\n            }\\n            if (k == 0) {\\n                return true;\\n            }\\n        }\\n        return k == 0;\\n    }\\n        \\n   int minCapability(vector<int>& nums, int k) {\\n        int st=INT_MAX;\\n        \\n        int end=INT_MIN;\\n        for(int i=0; i<nums.size(); i++){\\n            end = max(end, nums[i]);\\n            st = min(st, nums[i]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        while(st<=end){\\n            int mid=st+(end-st)/2;\\n            if(ispossible(nums,mid,k)){\\n                ans = min(ans, mid);\\n                end = mid-1;\\n            }\\n            else{\\n                st = mid+1;\\n            }\\n         }\\n         return ans;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3145944,
                "title": "best-solution-in-c-binarysearch-on-answer",
                "content": "# Complexity\\n- Time complexity:\\nnlog(1e9)     where n is the size of nums array\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n## **Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool checkCapability(int x, vector<int>& nums, int k){\\n        int count=0,prevInd=-2;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=x && (i-prevInd)>1){\\n                count++;\\n                prevInd=i;\\n            }\\n            if(count==k)\\n                break;\\n        }\\n        if(count==k)\\n            return true;\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int ll=1,ul=1e9,mid,ans;\\n        while(ll<=ul){\\n            mid=ll+(ul-ll)/2;\\n            if(checkCapability(mid,nums,k)){\\n                ans=mid;\\n                ul=mid-1;\\n            }\\n            else\\n                ll=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkCapability(int x, vector<int>& nums, int k){\\n        int count=0,prevInd=-2;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=x && (i-prevInd)>1){\\n                count++;\\n                prevInd=i;\\n            }\\n            if(count==k)\\n                break;\\n        }\\n        if(count==k)\\n            return true;\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int ll=1,ul=1e9,mid,ans;\\n        while(ll<=ul){\\n            mid=ll+(ul-ll)/2;\\n            if(checkCapability(mid,nums,k)){\\n                ans=mid;\\n                ul=mid-1;\\n            }\\n            else\\n                ll=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145799,
                "title": "c-easy-binary-search-solution-100-runtime-100-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& a, int k) {\\n        int n=a.size();\\n        \\n        int lo=*min_element(a.begin(),a.end())-1,hi=*max_element(a.begin(),a.end())+1;\\n        auto good = [&](const int mid) {\\n            int l=-2;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(a[i]<=mid&&l!=i-1){\\n                    cnt++;\\n                    l=i;\\n                }\\n            }\\n            return cnt>=k;\\n        };\\n        while(hi>lo+1){\\n            int mid=lo+(hi-lo)/2;\\n            \\n            if(good(mid)){\\n                hi=mid;\\n            }\\n            else\\n                lo=mid;\\n        }\\n        // good(2);\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& a, int k) {\\n        int n=a.size();\\n        \\n        int lo=*min_element(a.begin(),a.end())-1,hi=*max_element(a.begin(),a.end())+1;\\n        auto good = [&](const int mid) {\\n            int l=-2;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(a[i]<=mid&&l!=i-1){\\n                    cnt++;\\n                    l=i;\\n                }\\n            }\\n            return cnt>=k;\\n        };\\n        while(hi>lo+1){\\n            int mid=lo+(hi-lo)/2;\\n            \\n            if(good(mid)){\\n                hi=mid;\\n            }\\n            else\\n                lo=mid;\\n        }\\n        // good(2);\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145323,
                "title": "c-binary-search-dp-clear-and-explained-code",
                "content": "# Intuition\\nBinary serach for trying out capacity and dp for checking its validity\\n\\n# Approach\\nHere let\\'s us consider the minimum capacity that u have to return(ans) is between the maximum and min of nums elements.\\nNow we will use \"binary search\" to check for a cap(mid = (start+end)/2).\\nNow for this mid using \"DP\" we will find the number of elements that are less than or equal to mid in given nums array. if it comes greater than or equal to k then this mid can be a answer and we will try to find an ans less than this mid.\\n\\n# Complexity\\n- Time complexity: O(N*LOG(N)) // calling dp function logn times\\n\\n- Space complexity: O(N*LOG(N)) // creating dp vector logn times \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(int i,int mid,vector<int>& nums,int n,vector<int>& dp){\\n        if(i>=n) return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        int take = 0;\\n        if(nums[i]<=mid){\\n            take = 1 + fun(i+2,mid,nums,n,dp);\\n        }\\n        int not_take = fun(i+1,mid,nums,n,dp);\\n        return dp[i]=max(take,not_take);\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      int maxi = -1e9, mini = 1e9;\\n      for(int i=0;i<n;i++){\\n          mini = min(mini,nums[i]);\\n          maxi = max(maxi,nums[i]);\\n      }\\n      int start = mini,end = maxi;\\n      int ans = 0;\\n      while(start<=end){\\n          int mid = (start+end)/2;\\n          vector<int> dp(n,-1);\\n          int p = fun(0,mid,nums,n,dp);\\n          if(p>=k){\\n              ans = mid;\\n              end = mid-1;\\n          }\\n          else{\\n              start = mid+1;\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int i,int mid,vector<int>& nums,int n,vector<int>& dp){\\n        if(i>=n) return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        int take = 0;\\n        if(nums[i]<=mid){\\n            take = 1 + fun(i+2,mid,nums,n,dp);\\n        }\\n        int not_take = fun(i+1,mid,nums,n,dp);\\n        return dp[i]=max(take,not_take);\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      int maxi = -1e9, mini = 1e9;\\n      for(int i=0;i<n;i++){\\n          mini = min(mini,nums[i]);\\n          maxi = max(maxi,nums[i]);\\n      }\\n      int start = mini,end = maxi;\\n      int ans = 0;\\n      while(start<=end){\\n          int mid = (start+end)/2;\\n          vector<int> dp(n,-1);\\n          int p = fun(0,mid,nums,n,dp);\\n          if(p>=k){\\n              ans = mid;\\n              end = mid-1;\\n          }\\n          else{\\n              start = mid+1;\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144674,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int l=nums[0], h=nums[0];\\n        for(int i:nums)\\n        {\\n            l=min(l, i);\\n            h=max(h, i);\\n        }\\n        int ans=INT_MAX;\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            int c=0, p=-2;\\n            int g=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i]<=m && p+1 != i)\\n                {\\n                    c++;\\n                    p=i;\\n                    g=max(g, nums[i]);\\n                }\\n            }\\n            if(c>=k)\\n            {\\n                h=m-1;\\n                ans=min(ans, g);\\n            }\\n            else\\n            l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int l=nums[0], h=nums[0];\\n        for(int i:nums)\\n        {\\n            l=min(l, i);\\n            h=max(h, i);\\n        }\\n        int ans=INT_MAX;\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            int c=0, p=-2;\\n            int g=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i]<=m && p+1 != i)\\n                {\\n                    c++;\\n                    p=i;\\n                    g=max(g, nums[i]);\\n                }\\n            }\\n            if(c>=k)\\n            {\\n                h=m-1;\\n                ans=min(ans, g);\\n            }\\n            else\\n            l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143958,
                "title": "binary-search-and-dynamic-programming",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your first thoughts on how to solve this problem -->\\n\\n# Approach\\n<!-- Binary search to minimize the capability in each robbery and then use dp inside predicate function to check maximum number of non adjacent houses we can rob whose with given capability. -->\\nBinary search to minimize the capability in each robbery and then use dp inside predicate function to check maximum number of non adjacent houses we can rob whose with given capability.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- O(nlogn) -->\\n\\n\\n- Space complexity: O(n)\\n<!-- O(n) -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int i,vector<int> &nums,int x,vector<int> &dp){\\n        if(i < 0){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int include, exclude;\\n        include = exclude = 0;\\n        if(nums[i] <= x){\\n            include = 1 + helper( i-2, nums, x, dp);\\n        }\\n        exclude = helper( i-1, nums, x, dp);\\n        return dp[i] = max( include, exclude);\\n    }\\n    bool predicate(vector<int> &nums,int k,int x){\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        // dp[i] : maximum number of non adjacent houses that can be robbed from nums(0...i) \\n        // and each robbed houses must be lesser than equal to x\\n        helper( n-1, nums, x, dp);\\n        return dp[n-1] >= k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int l = INT_MAX;\\n        int r = INT_MIN;\\n        for(int num : nums){\\n            l = min( l, num);\\n            r = max( r, num);\\n        }\\n        int m;\\n        int ans = -1;\\n        while(l <= r){\\n            m = l + (r-l)/2;\\n            if(predicate( nums, k, m)){\\n                ans = m;\\n                r = m-1;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i,vector<int> &nums,int x,vector<int> &dp){\\n        if(i < 0){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int include, exclude;\\n        include = exclude = 0;\\n        if(nums[i] <= x){\\n            include = 1 + helper( i-2, nums, x, dp);\\n        }\\n        exclude = helper( i-1, nums, x, dp);\\n        return dp[i] = max( include, exclude);\\n    }\\n    bool predicate(vector<int> &nums,int k,int x){\\n        int n = nums.size();\\n        vector<int> dp(n,-1);\\n        // dp[i] : maximum number of non adjacent houses that can be robbed from nums(0...i) \\n        // and each robbed houses must be lesser than equal to x\\n        helper( n-1, nums, x, dp);\\n        return dp[n-1] >= k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int l = INT_MAX;\\n        int r = INT_MIN;\\n        for(int num : nums){\\n            l = min( l, num);\\n            r = max( r, num);\\n        }\\n        int m;\\n        int ans = -1;\\n        while(l <= r){\\n            m = l + (r-l)/2;\\n            if(predicate( nums, k, m)){\\n                ans = m;\\n                r = m-1;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143672,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\ntypedef pair<ll, ll> pi;\\nbool possible(const vi(int)&v, ll in, const ll&k){\\n    ll tot=1;\\n    bool take=false;\\n    for(ll i=in-1;i>-1;--i){\\n        if(!take){\\n            take=1;\\n            continue;\\n        }\\n        if(v[i]<=v[in]){\\n            tot++;\\n            take=0;\\n        }\\n    }\\n    take=false;\\n    for(ll i=in+1;i<v.size();++i){\\n        if(!take){\\n            take=1;\\n            continue;\\n        }\\n        if(v[i]<=v[in]){\\n            tot++;\\n            take=0;\\n        }\\n    }\\n    return (tot>=k);\\n}\\n\\nint minCapability(vector<int>&v, int k) {\\n    ll n=v.size(), ans=-1, l=0, r=n-1;\\n    vi(pi)arr(n);\\n    for(ll i=0;i<n;++i){\\n        arr[i]={v[i], i};\\n    }\\n    sort(begin(arr), end(arr));\\n    while(l<=r){\\n        ll m=l+((r-l)>>1);\\n        if(possible(v, arr[m].second, k)){\\n            ans=arr[m].first, r=m-1;\\n        }\\n        else{\\n            l=m+1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\ntypedef pair<ll, ll> pi;\\nbool possible(const vi(int)&v, ll in, const ll&k){\\n    ll tot=1;\\n    bool take=false;\\n    for(ll i=in-1;i>-1;--i){\\n        if(!take){\\n            take=1;\\n            continue;\\n        }\\n        if(v[i]<=v[in]){\\n            tot++;\\n            take=0;\\n        }\\n    }\\n    take=false;\\n    for(ll i=in+1;i<v.size();++i){\\n        if(!take){\\n            take=1;\\n            continue;\\n        }\\n        if(v[i]<=v[in]){\\n            tot++;\\n            take=0;\\n        }\\n    }\\n    return (tot>=k);\\n}\\n\\nint minCapability(vector<int>&v, int k) {\\n    ll n=v.size(), ans=-1, l=0, r=n-1;\\n    vi(pi)arr(n);\\n    for(ll i=0;i<n;++i){\\n        arr[i]={v[i], i};\\n    }\\n    sort(begin(arr), end(arr));\\n    while(l<=r){\\n        ll m=l+((r-l)>>1);\\n        if(possible(v, arr[m].second, k)){\\n            ans=arr[m].first, r=m-1;\\n        }\\n        else{\\n            l=m+1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079945,
                "title": "standard-binary-search-no-modification-in-binary-ssearch",
                "content": "# Intuition\\nWhen ever you see  this type of minimum-maximum problems where \\nwhere you have to maximise some thing under some contraints.\\nIn simple words you find the maximum as well as minimum word in the same line you must think of binary search.\\nTheir is very high chances that the problem can be solved using the \\nbinary search. \\n\\n# Approach\\nHere you do the standard binary search to find all the possible answers and than you return the most optimal answers of all the answers which you get in the binary search\\n\\n# Complexity\\n- Time complexity:\\nO(log(1e9)) * n;\\n\\n\\n- Space complexity:\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n// Here you choose your answers range from 1 to 1e9:\\n// as given in the constraints.\\n// You can also choose your range from min(All the elements)\\n// to max//(all the elements) in the array.\\n\\n// Now the very standard Binary search\\n\\n        int left = 1; \\n        int right = 1e9;\\n        int n = nums.size();\\n        int maxi = 1e9;\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n            int take = 0; \\n// Mid can be your possible answers\\n\\n            for(int i = 0; i<n; i++){\\n                if(nums[i] <= mid){\\n                    take += 1;\\n                    i++;\\n// As given in the question that you cannot take \\n// two consecutive houses that why we have done i++ here\\n\\n                }\\n            }\\n// If we have taken more than K houses That is not allowed \\n// hence we reduce the maximum amount of money allowed\\n                if(take > k){\\n                    right = mid-1;\\n                }\\n// If we were unable to take K houses than it is okay but in \\n// order maximise the number of houses we do increase left.\\n                else if(take < k){\\n                    left = mid + 1;\\n                    maxi = min(maxi, mid);      \\n                }\\n// if we were able to get exactly k houses than the answer is \\n//possible one so we check it if it is less than previous stored answers\\n                else{\\n                     maxi = min(maxi, mid);\\n                     right = mid - 1;\\n                }\\n            \\n        }\\n        return maxi;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n// Here you choose your answers range from 1 to 1e9:\\n// as given in the constraints.\\n// You can also choose your range from min(All the elements)\\n// to max//(all the elements) in the array.\\n\\n// Now the very standard Binary search\\n\\n        int left = 1; \\n        int right = 1e9;\\n        int n = nums.size();\\n        int maxi = 1e9;\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n            int take = 0; \\n// Mid can be your possible answers\\n\\n            for(int i = 0; i<n; i++){\\n                if(nums[i] <= mid){\\n                    take += 1;\\n                    i++;\\n// As given in the question that you cannot take \\n// two consecutive houses that why we have done i++ here\\n\\n                }\\n            }\\n// If we have taken more than K houses That is not allowed \\n// hence we reduce the maximum amount of money allowed\\n                if(take > k){\\n                    right = mid-1;\\n                }\\n// If we were unable to take K houses than it is okay but in \\n// order maximise the number of houses we do increase left.\\n                else if(take < k){\\n                    left = mid + 1;\\n                    maxi = min(maxi, mid);      \\n                }\\n// if we were able to get exactly k houses than the answer is \\n//possible one so we check it if it is less than previous stored answers\\n                else{\\n                     maxi = min(maxi, mid);\\n                     right = mid - 1;\\n                }\\n            \\n        }\\n        return maxi;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271671,
                "title": "easy-c-solution-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        // minimum capacity=1\\n        // maximum capacity=max(nums)\\n        // this problem is cobination of robber house 1+limited balls\\n        // in bag\\n        int start=1;\\n        int end=*max_element(nums.begin(),nums.end());\\n        int mid;\\n        int ans=INT_MAX;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            if(fun(nums,k,mid)==true)\\n            {\\n                ans=min(ans,mid);\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&nums,int &k,int &mid)\\n    {\\n        int prev=-1;\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=mid)\\n            {\\n                if(prev==-1)\\n                {\\n                    prev=i;\\n                    c++;\\n                }\\n                else if(i!=prev+1)\\n                {\\n                    prev=i;\\n                    c++;\\n                }\\n            }\\n        }\\n        if(c>=k)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        // minimum capacity=1\\n        // maximum capacity=max(nums)\\n        // this problem is cobination of robber house 1+limited balls\\n        // in bag\\n        int start=1;\\n        int end=*max_element(nums.begin(),nums.end());\\n        int mid;\\n        int ans=INT_MAX;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            if(fun(nums,k,mid)==true)\\n            {\\n                ans=min(ans,mid);\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&nums,int &k,int &mid)\\n    {\\n        int prev=-1;\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=mid)\\n            {\\n                if(prev==-1)\\n                {\\n                    prev=i;\\n                    c++;\\n                }\\n                else if(i!=prev+1)\\n                {\\n                    prev=i;\\n                    c++;\\n                }\\n            }\\n        }\\n        if(c>=k)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235313,
                "title": "python3-binary-search",
                "content": "# Intuition\\nI got stuck in the same rabbit hole others did\\n\\nI started with DP - got a TLE\\nThen I tried BFS - still got a TLE\\nI tried a tweak optimizing for houses you wanted to take from...  waan\\'t happening\\nThen I switched to binary search\\n\\nThe idea is basically you decide ahead of time how \\'bad\\' your result will be and see if that is possible and keep iterating til you find the lowest value and return that\\n\\nThis works because there is no reason NOT to take from a house if it is lower value than the amount you have agreed you are going to take.  \\n\\n# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        def possible(v, r):\\n            i = 0\\n            while i < len(nums) and r > 0:\\n                if nums[i] <= v:\\n                    r -= 1\\n                    i += 2\\n                else:\\n                    i += 1\\n            return r==0\\n        items = list(sorted(set(nums)))\\n        lo, hi = 0, len(items) - 1\\n        while lo < hi:\\n            m = (lo + hi) // 2\\n            if possible(items[m], k):\\n                hi = m\\n            else:\\n                lo = m + 1\\n        return items[lo]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        def possible(v, r):\\n            i = 0\\n            while i < len(nums) and r > 0:\\n                if nums[i] <= v:\\n                    r -= 1\\n                    i += 2\\n                else:\\n                    i += 1\\n            return r==0\\n        items = list(sorted(set(nums)))\\n        lo, hi = 0, len(items) - 1\\n        while lo < hi:\\n            m = (lo + hi) // 2\\n            if possible(items[m], k):\\n                hi = m\\n            else:\\n                lo = m + 1\\n        return items[lo]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205350,
                "title": "c-solution",
                "content": "\\n\\n    int minCapability(vector<int>& nums, int k) {\\n    int s = 1, e = 1e9;\\n    while (s < e) {\\n        int mid = (s + e) / 2;\\n        int take = 0;\\n        for (int i = 0; i < nums.size() && take < k; i++) {\\n            take += nums[i] <= mid;\\n            i += nums[i] <= mid;\\n        }\\n        if (take < k)\\n            s = mid + 1;\\n        else\\n            e = mid;\\n    }\\n    return s;\\n    }\\n\\n",
                "solutionTags": [],
                "code": "\\n\\n    int minCapability(vector<int>& nums, int k) {\\n    int s = 1, e = 1e9;\\n    while (s < e) {\\n        int mid = (s + e) / 2;\\n        int take = 0;\\n        for (int i = 0; i < nums.size() && take < k; i++) {\\n            take += nums[i] <= mid;\\n            i += nums[i] <= mid;\\n        }\\n        if (take < k)\\n            s = mid + 1;\\n        else\\n            e = mid;\\n    }\\n    return s;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3160899,
                "title": "simple-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>v,int k,int m){\\n        \\n        for(int i=0;i<v.size();i++){\\n            if(v[i]<=m)k--,i++;\\n            if(k<=0)return 1;\\n        }\\n        return k<=0;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int l=*min_element(nums.begin(),nums.end());\\n        int r=*max_element(nums.begin(),nums.end());\\n        int m;\\n        while(l<=r){\\n            m=(l+r)/2;\\n            \\n            if(check(nums,k,m))\\n                r=m-1;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>v,int k,int m){\\n        \\n        for(int i=0;i<v.size();i++){\\n            if(v[i]<=m)k--,i++;\\n            if(k<=0)return 1;\\n        }\\n        return k<=0;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int l=*min_element(nums.begin(),nums.end());\\n        int r=*max_element(nums.begin(),nums.end());\\n        int m;\\n        while(l<=r){\\n            m=(l+r)/2;\\n            \\n            if(check(nums,k,m))\\n                r=m-1;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151437,
                "title": "binery-search-explained-o-1-space-beats-100-c",
                "content": "# Intuition\\nSome important points-->\\n1) The ans will surely be on the nums.\\n2) let k=3 and ans = x.\\n    That means if we see all the 3-selection {(a,b,c),....} there will be one selection where x  will be the max among the 3 selected house; {(a,b,x)  ->[ where x> a and x> b]}\\nand the total sum of the 3 house will be min among all selections;\\n\\n3)let see first Test case- nums = [2,3,5,9] and k=2 \\nhere min element =2, max element =9;\\nif have to check i=2 to 9 that there is any 2-selection{(a,b)....} where i is max among the 2 selected numbers ans the selected item is not adjusent;\\n \\nlet check i=2 ->we cant get any selection where 2 is max ;\\nand also for 3,4;\\n\\nnow i=5;\\nwe can get 2,5;\\nand that will surely min sum;\\n\\n\\n# Approach\\n -->for checking X is ans or not we have to check -->\\n for all elements in nums\\n  a)  X > all elements of the selection;\\n  b) selected elements will not be adjusent\\n  c) there must be k selection\\n\\nfor checking min to max for satisfing the above conditions\\nwe can use binery search because if we can\\'t satisfy the above condition for mid that means we cant satisfy this for all the numbers which are less that mid(where mid =(max + min)/2 )\\n\\nand finally we can take the min of all the elememts that are satisfying the conditions\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>& nums,int k,int t)\\n    {\\n        int i=0,n=nums.size();\\n        while(i<n)\\n        {\\n            if(t>=nums[i])\\n            {\\n                k--;\\n                i+=2;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n\\n            if(k==0) return true;\\n        }\\n        return k==0;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int ans=INT_MAX;\\n        int minn=INT_MAX,maxx=INT_MIN;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            minn=min(minn,nums[i]);\\n            maxx=max(maxx,nums[i]);\\n        }\\n        while(maxx>=minn)\\n        {\\n            int mid=(maxx+minn)/2;\\n            if(helper(nums,k,mid))\\n            {\\n                 ans=min(ans,mid);\\n                 maxx=mid-1;\\n            }\\n            else\\n            {\\n                minn=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>& nums,int k,int t)\\n    {\\n        int i=0,n=nums.size();\\n        while(i<n)\\n        {\\n            if(t>=nums[i])\\n            {\\n                k--;\\n                i+=2;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n\\n            if(k==0) return true;\\n        }\\n        return k==0;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int ans=INT_MAX;\\n        int minn=INT_MAX,maxx=INT_MIN;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            minn=min(minn,nums[i]);\\n            maxx=max(maxx,nums[i]);\\n        }\\n        while(maxx>=minn)\\n        {\\n            int mid=(maxx+minn)/2;\\n            if(helper(nums,k,mid))\\n            {\\n                 ans=min(ans,mid);\\n                 maxx=mid-1;\\n            }\\n            else\\n            {\\n                minn=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150642,
                "title": "simple-c-solution-using-binary-search-greedy",
                "content": "```\\n // least ks\\n    bool predicate(vector<vector<int>> &nums, int mid, int k){\\n        vector<int> copy;\\n        int i = 0, n = nums.size();\\n\\t\\t// store indexes of elements smaller than mid value\\n        while(i<n && nums[i][0]<=mid){\\n            copy.push_back(nums[i][1]);\\n            i++;\\n        }\\n        \\n        sort(copy.begin(), copy.end());\\n\\t\\t// check whether k non-adjacent smaller elements exists or not\\n        int j = 0, prev = -2;\\n        for(int i:copy){\\n            if(abs(i-prev)==1)\\n                continue;\\n            prev = i;\\n            j++;\\n        }\\n        \\n        return j>=k;\\n    }\\n    \\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<vector<int>> temp;\\n        for(int i=0;i<n;i++)\\n            temp.push_back({nums[i], i});\\n        \\n        sort(temp.begin(), temp.end());\\n        int res = 0;\\n\\t\\t// ans range is between 1 and 1e9\\n        int low = 1, high = 1e9;\\n        while(low<=high){\\n            int mid = (low+high)>>1;\\n            if(predicate(temp, mid, k)){\\n                res = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\n // least ks\\n    bool predicate(vector<vector<int>> &nums, int mid, int k){\\n        vector<int> copy;\\n        int i = 0, n = nums.size();\\n\\t\\t// store indexes of elements smaller than mid value\\n        while(i<n && nums[i][0]<=mid){\\n            copy.push_back(nums[i][1]);\\n            i++;\\n        }\\n        \\n        sort(copy.begin(), copy.end());\\n\\t\\t// check whether k non-adjacent smaller elements exists or not\\n        int j = 0, prev = -2;\\n        for(int i:copy){\\n            if(abs(i-prev)==1)\\n                continue;\\n            prev = i;\\n            j++;\\n        }\\n        \\n        return j>=k;\\n    }\\n    \\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<vector<int>> temp;\\n        for(int i=0;i<n;i++)\\n            temp.push_back({nums[i], i});\\n        \\n        sort(temp.begin(), temp.end());\\n        int res = 0;\\n\\t\\t// ans range is between 1 and 1e9\\n        int low = 1, high = 1e9;\\n        while(low<=high){\\n            int mid = (low+high)>>1;\\n            if(predicate(temp, mid, k)){\\n                res = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3149915,
                "title": "very-clean-binary-search-solution-c-time-complexity-added",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to choose at least k elements where none of the two elements are consecutive.\\nWe need to have the minimum possible answer. So we can try to take exactly k elements which donesn\\'t exceed a given target.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can binary search for the answer. \\nTry if a answer is possible with x:\\n### case 1:\\nif we are able to take k elements which are not greater than x, then things are going well. Then as we need to make the right side of the search space smaller,i.e., r=mid-1\\n### case 2:\\nelse, try with a bigger element , so make l=mid+1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, -->\\n$$O(ArraySize*log(BiggestElement))$$\\n \\n\\n# Code\\n```\\nclass Solution {\\n    int helper(vector<int>&nums,int mid,int k){\\n       int i=0,n=nums.size();\\n       while(i<n){\\n           if(nums[i]<=mid){\\n               i+=2;\\n               k--;\\n           }else i++; \\n       }\\n       return (k<=0);\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();  \\n        int ans=nums[0]; \\n        int l=1;\\n        int r=1e9+5; \\n\\n        while(l<=r){\\n            int mid=l+(r-l)/2; \\n            if(helper(nums,mid,k)){\\n                ans=mid; \\n                r=mid-1; \\n            }else l=mid+1; \\n        }\\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    int helper(vector<int>&nums,int mid,int k){\\n       int i=0,n=nums.size();\\n       while(i<n){\\n           if(nums[i]<=mid){\\n               i+=2;\\n               k--;\\n           }else i++; \\n       }\\n       return (k<=0);\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();  \\n        int ans=nums[0]; \\n        int l=1;\\n        int r=1e9+5; \\n\\n        while(l<=r){\\n            int mid=l+(r-l)/2; \\n            if(helper(nums,mid,k)){\\n                ans=mid; \\n                r=mid-1; \\n            }else l=mid+1; \\n        }\\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149367,
                "title": "java-binary-search-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nbinary search + dp\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        //binary search\\n        int start = 1;\\n        int end = (int)(Math.pow(10,9));\\n        while(start + 1 < end){\\n            int mid = start + (end - start)/2;\\n            if(canRob(nums,mid,k)){\\n                end = mid;\\n            }\\n            else{\\n                start = mid;\\n            }\\n        }\\n        if(canRob(nums,start,k)){\\n            return start;\\n        }else{\\n            return end;\\n        }\\n        \\n    }\\n    public boolean canRob(int[] nums, int maxCapacity, int k){\\n        // the number of houses robbed if start from the ith to the nth\\n        int[] dp = new int[nums.length + 2];\\n        for(int i = nums.length - 1 ; i >= 0; i--){\\n            //base case\\n            //dp[n] = 0;\\n            //if the ith is over capacity, can not rob\\n            if(nums[i] > maxCapacity){\\n                dp[i] = dp[i + 1];\\n            }\\n            else{\\n                dp[i] = Math.max(dp[i + 2] + 1, dp[i + 1]); \\n            }\\n            \\n            \\n        }\\n        return dp[0] >= k;\\n    }\\n    // private boolean canRob(int[] nums, int maxMoney, int k) {\\n    //     int houseStolen = 0, lastStolenIdx = -2;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] > maxMoney) {\\n    //             continue;\\n    //         }\\n    //         if (i == lastStolenIdx + 1) {\\n    //             continue;\\n    //         }\\n            \\n    //         houseStolen++;    \\n    //         lastStolenIdx = i; \\n    //     }\\n        \\n    //     return houseStolen >= k;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        //binary search\\n        int start = 1;\\n        int end = (int)(Math.pow(10,9));\\n        while(start + 1 < end){\\n            int mid = start + (end - start)/2;\\n            if(canRob(nums,mid,k)){\\n                end = mid;\\n            }\\n            else{\\n                start = mid;\\n            }\\n        }\\n        if(canRob(nums,start,k)){\\n            return start;\\n        }else{\\n            return end;\\n        }\\n        \\n    }\\n    public boolean canRob(int[] nums, int maxCapacity, int k){\\n        // the number of houses robbed if start from the ith to the nth\\n        int[] dp = new int[nums.length + 2];\\n        for(int i = nums.length - 1 ; i >= 0; i--){\\n            //base case\\n            //dp[n] = 0;\\n            //if the ith is over capacity, can not rob\\n            if(nums[i] > maxCapacity){\\n                dp[i] = dp[i + 1];\\n            }\\n            else{\\n                dp[i] = Math.max(dp[i + 2] + 1, dp[i + 1]); \\n            }\\n            \\n            \\n        }\\n        return dp[0] >= k;\\n    }\\n    // private boolean canRob(int[] nums, int maxMoney, int k) {\\n    //     int houseStolen = 0, lastStolenIdx = -2;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] > maxMoney) {\\n    //             continue;\\n    //         }\\n    //         if (i == lastStolenIdx + 1) {\\n    //             continue;\\n    //         }\\n            \\n    //         houseStolen++;    \\n    //         lastStolenIdx = i; \\n    //     }\\n        \\n    //     return houseStolen >= k;\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149046,
                "title": "go-binary-search-with-dp",
                "content": "Use binary search to find what the answer is. Min and max of nums are the boundaries. We need to check, given a number `m`, if we can find a uncontiguous subsequence that yields a capacity <= `m`. We can use a simple dynamic programming method to implement `check(int) bool` in O(n):\\n\\n`dp1[i]` denotes the length of the satisfying sebsequence that starts from i-th number (taking the i-th number).\\n`dp2[i]` denotes the length of the satisfying sebsequence that starts from (i+1)-th number (not taking the i-th number).\\n\\nWe have\\n```\\ndp1[i] = nums[i] <= m ? 1 + dp2[i+1]  : 0\\ndp2[i] = max(dp1[i+1], dp2[i+1])\\n```\\n\\nWe can use a simple optimzation to avoid using two whole dp arrays by just keeping two ints that denote `dp1[i+1]` and `dp2[i+1]`.\\n\\nHere\\'s a solution in Go:\\n```go\\nfunc minCapability(nums []int, k int) int {\\n\\tleft, right := min(nums...)-1, max(nums...)\\n\\n\\tcheck := func(m int) bool {\\n\\t\\tl := len(nums)\\n\\t\\ttake, notTake := 0, 0\\n\\t\\tfor i := l - 1; i >= 0; i-- {\\n\\t\\t\\tif nums[i] > m {\\n\\t\\t\\t\\tnotTake = max(take, notTake)\\n\\t\\t\\t\\ttake = 0\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttake, notTake = 1+notTake, max(take, notTake)\\n\\t\\t\\t}\\n\\t\\t\\tif take == k || notTake == k {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\n\\tfor left+1 < right {\\n\\t\\tm := (left + right) / 2\\n\\t\\tif check(m) {\\n\\t\\t\\tright = m\\n\\t\\t} else {\\n\\t\\t\\tleft = m\\n\\t\\t}\\n\\t}\\n\\treturn right\\n}\\n\\nfunc max(a ...int) int {\\n\\tret := a[0]\\n\\tfor i := 1; i < len(a); i++ {\\n\\t\\tif a[i] > ret {\\n\\t\\t\\tret = a[i]\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n\\nfunc min(a ...int) int {\\n\\tret := a[0]\\n\\tfor i := 1; i < len(a); i++ {\\n\\t\\tif a[i] < ret {\\n\\t\\t\\tret = a[i]\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ndp1[i] = nums[i] <= m ? 1 + dp2[i+1]  : 0\\ndp2[i] = max(dp1[i+1], dp2[i+1])\\n```\n```go\\nfunc minCapability(nums []int, k int) int {\\n\\tleft, right := min(nums...)-1, max(nums...)\\n\\n\\tcheck := func(m int) bool {\\n\\t\\tl := len(nums)\\n\\t\\ttake, notTake := 0, 0\\n\\t\\tfor i := l - 1; i >= 0; i-- {\\n\\t\\t\\tif nums[i] > m {\\n\\t\\t\\t\\tnotTake = max(take, notTake)\\n\\t\\t\\t\\ttake = 0\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttake, notTake = 1+notTake, max(take, notTake)\\n\\t\\t\\t}\\n\\t\\t\\tif take == k || notTake == k {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\n\\tfor left+1 < right {\\n\\t\\tm := (left + right) / 2\\n\\t\\tif check(m) {\\n\\t\\t\\tright = m\\n\\t\\t} else {\\n\\t\\t\\tleft = m\\n\\t\\t}\\n\\t}\\n\\treturn right\\n}\\n\\nfunc max(a ...int) int {\\n\\tret := a[0]\\n\\tfor i := 1; i < len(a); i++ {\\n\\t\\tif a[i] > ret {\\n\\t\\t\\tret = a[i]\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n\\nfunc min(a ...int) int {\\n\\tret := a[0]\\n\\tfor i := 1; i < len(a); i++ {\\n\\t\\tif a[i] < ret {\\n\\t\\t\\tret = a[i]\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3147831,
                "title": "c-simple-o-1-space-binary-search",
                "content": "# Typical Binary Search Problem ( No need to use DP )!!\\n# Approach\\nBinary Search :- MIN-MAX Type of Problem.\\nAs this a Variation of previous parts of House Robber Problem so we all think in terms of Dynamic Programming only. But this Problem can be easily solved using Binary Search.\\nWhenever Min-Max Type of problem is asked than we can think in terms of Binary Search Approach as well.\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Binary Search Problem\\n    // Applied Binary Search because - (Min-Max Type of Problem)\\n    // Time Complexity:- O(n*log(n))\\n    // space Complexity:- O(1)\\n    \\n    bool check_fun(vector<int> &nums,int mid,int k){\\n        int j=0;\\n        while(j < nums.size()){\\n            if(nums[j] <= mid){\\n                k--;\\n                j+=2;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n            if(k==0){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int l=*min_element(nums.begin(),nums.end()),r=*max_element(nums.begin(),nums.end());\\n        int res=r;\\n\\n        while(l<=r){\\n            int mid = (l+(r-l)/2);\\n\\n            if(check_fun(nums,mid,k)){\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Binary Search Problem\\n    // Applied Binary Search because - (Min-Max Type of Problem)\\n    // Time Complexity:- O(n*log(n))\\n    // space Complexity:- O(1)\\n    \\n    bool check_fun(vector<int> &nums,int mid,int k){\\n        int j=0;\\n        while(j < nums.size()){\\n            if(nums[j] <= mid){\\n                k--;\\n                j+=2;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n            if(k==0){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int l=*min_element(nums.begin(),nums.end()),r=*max_element(nums.begin(),nums.end());\\n        int res=r;\\n\\n        while(l<=r){\\n            int mid = (l+(r-l)/2);\\n\\n            if(check_fun(nums,mid,k)){\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145705,
                "title": "c-clean-code-with-explanation",
                "content": "# Intuition\\nTo be honest binary search was the first thing that striked my mind due to the min-max pattern as seen in the problem. But my gut feeling said that something greedy would work. Exact binary search striked very late. \\n\\nI will take you through my approach from start. \\nLets picture it out this way - \\nPut each element and its position inside a vector and sort or put inside a hashset. ```(nums[i],i) ```\\nNow lets start from back, currently we are standing on the largest number and this could be one possible answer if we could select atleast k-1 non adjacent houses out of the remaining houses behind it.\\nIf we could then update ur ```ans = nums[i]``` \\nelse you break because if you could not select k-1 houses out of n-1 houses then you wont be able to select it from n-2.\\n\\nNow we move onto the seccond last element ,this is where we should note one thing, that elements greater than this would be avoided. ```i.e i+1 ... n-1 will be ignored```. \\nWhy ? Because at ith position we consider that nums[i] is the max capability that we can get.\\n\\nA bruteforce solution could be to simply have a loop nested inside and iterate over the non-sorted array where you pick elemnts smaller then equal to current i and make sure that none of them are adjacent. \\nHere I was trying to optimise the inner loop that is trying to see if I could check if it is possible to choose k-1 non adjacent house.\\n\\nAfter a long time I realised that the outer loop could be optimised into a Binary search because if I could do it with i then I am checking for i-1 or else breaking.\\n\\n## This is bruteforce sol :\\n```\\nint minCapability(vector<int>& nums, int k) {\\n        auto v = nums ; \\n        sort(v.begin(),v.end());\\n        int ans = 0 ;\\n        for(int i = v.size()-1 ; i >= 0 ; i--){\\n            int r = 0 , j = 0 ; \\n            while(j < nums.size()){\\n                if(nums[j] <= v[i]){\\n                    r += 1 , j += 2 ;\\n                }else j += 1 ;\\n            }\\n            if(r >= k){\\n                ans = v[i] ; \\n            }\\n            else break ;\\n        }\\n        return ans ;\\n    }\\n```\\n\\n\\n\\n\\n# Approach\\nThe binary search is in the same direction, so take your l = 0 , r = n-1 and apply binary seaach on the sorted array. \\nIf you could do it with mid than check if you could do it for lower index or check for higher. The inner loop in bruteforce becomes the checker.\\n\\n# Complexity\\n- Time complexity:\\nO(logn * n) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        auto v = nums ; \\n        sort(v.begin(),v.end());\\n\\n        auto check = [&](int x){\\n            int r = 0 , i = 0; \\n            while(i < nums.size()){\\n                if(nums[i] <= x){\\n                    r += 1 , i += 2 ; \\n                    continue ;\\n                }\\n                i += 1 ;\\n            }\\n            return r >= k ;\\n        };\\n\\n        int l = 0 , r = nums.size()-1 , ans = 0  ; \\n        while(l <= r){\\n            int mid = (l+r)/2 ; \\n            if(check(v[mid])){\\n                ans = v[mid] ; \\n                r = mid - 1 ; \\n                continue ;\\n            }\\n            l = mid + 1 ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```(nums[i],i) ```\n```ans = nums[i]```\n```i.e i+1 ... n-1 will be ignored```\n```\\nint minCapability(vector<int>& nums, int k) {\\n        auto v = nums ; \\n        sort(v.begin(),v.end());\\n        int ans = 0 ;\\n        for(int i = v.size()-1 ; i >= 0 ; i--){\\n            int r = 0 , j = 0 ; \\n            while(j < nums.size()){\\n                if(nums[j] <= v[i]){\\n                    r += 1 , j += 2 ;\\n                }else j += 1 ;\\n            }\\n            if(r >= k){\\n                ans = v[i] ; \\n            }\\n            else break ;\\n        }\\n        return ans ;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        auto v = nums ; \\n        sort(v.begin(),v.end());\\n\\n        auto check = [&](int x){\\n            int r = 0 , i = 0; \\n            while(i < nums.size()){\\n                if(nums[i] <= x){\\n                    r += 1 , i += 2 ; \\n                    continue ;\\n                }\\n                i += 1 ;\\n            }\\n            return r >= k ;\\n        };\\n\\n        int l = 0 , r = nums.size()-1 , ans = 0  ; \\n        while(l <= r){\\n            int mid = (l+r)/2 ; \\n            if(check(v[mid])){\\n                ans = v[mid] ; \\n                r = mid - 1 ; \\n                continue ;\\n            }\\n            l = mid + 1 ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145420,
                "title": "easy-binary-search-beat-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        int left = 1, right = 1e9;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            int cnt = 0;\\n            for (int i = 0; i < N; i++) {\\n                if (nums[i] <= mid) {\\n                    cnt++;\\n                    i++; // skip adjacent index\\n                }\\n            }\\n            if (cnt < k) {\\n                left = mid+1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        int left = 1, right = 1e9;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            int cnt = 0;\\n            for (int i = 0; i < N; i++) {\\n                if (nums[i] <= mid) {\\n                    cnt++;\\n                    i++; // skip adjacent index\\n                }\\n            }\\n            if (cnt < k) {\\n                left = mid+1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144685,
                "title": "c-binary-search-dp-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlog(maxvalue-minvalue))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint fun(int m,vector<int>&nums){\\n   int x=0,y=0;\\n   for(int i=0;i<nums.size();i++){\\n       int nx=0,ny=0;\\n       if(nums[i]<=m){\\n         nx=1+y;\\n       }\\n       ny=max(x,y);\\n       x=nx,y=ny;\\n     \\n   }\\n   return max(x,y);\\n\\n}\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int l=INT_MAX;\\n        int y=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            l=min(l,nums[i]);\\n            y=max(y,nums[i]);\\n        }\\n        int ans=INT_MAX;\\n        while(l<=y){\\n            int m=l+(y-l)/2;\\n           \\n            int d=fun(m,nums);\\n            if(d>=k){\\n                ans=min(ans,m);\\n                y=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint fun(int m,vector<int>&nums){\\n   int x=0,y=0;\\n   for(int i=0;i<nums.size();i++){\\n       int nx=0,ny=0;\\n       if(nums[i]<=m){\\n         nx=1+y;\\n       }\\n       ny=max(x,y);\\n       x=nx,y=ny;\\n     \\n   }\\n   return max(x,y);\\n\\n}\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int l=INT_MAX;\\n        int y=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            l=min(l,nums[i]);\\n            y=max(y,nums[i]);\\n        }\\n        int ans=INT_MAX;\\n        while(l<=y){\\n            int m=l+(y-l)/2;\\n           \\n            int d=fun(m,nums);\\n            if(d>=k){\\n                ans=min(ans,m);\\n                y=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144416,
                "title": "c-binary-search-on-answer",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& nums, int capacity, int k) {\\n        int i = 0;\\n        int n = nums.size();\\n\\n        while(i < n && k) {\\n            if(nums[i] <= capacity) {\\n                k--;\\n                i += 2;\\n            }\\n            else i++;\\n        }\\n        return k == 0;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int low = 1;\\n        int high = 1e9;\\n        int ans = -1;\\n\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(isValid(nums, mid, k)) {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& nums, int capacity, int k) {\\n        int i = 0;\\n        int n = nums.size();\\n\\n        while(i < n && k) {\\n            if(nums[i] <= capacity) {\\n                k--;\\n                i += 2;\\n            }\\n            else i++;\\n        }\\n        return k == 0;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int low = 1;\\n        int high = 1e9;\\n        int ans = -1;\\n\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(isValid(nums, mid, k)) {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144103,
                "title": "c-easy-binary-search-100-fast",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    bool isPossible(int x, int k, vector<int>& nums) {\\n        int prev = -1, cnt = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > x) continue;\\n            if(prev != -1 && i == prev + 1) continue;\\n            cnt++;\\n            prev = i;\\n        }\\n        return cnt >= k;\\n    }\\n     \\n    int minCapability(vector<int>& nums, int k) {\\n        n = nums.size();\\n        int l = 0, r = 1e9 + 2, ans = -1;\\n\\n        while(l <= r) {\\n            int mid = (l + r) >> 1;\\n            if(isPossible(mid, k, nums)) {\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }        \\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool isPossible(int x, int k, vector<int>& nums) {\\n        int prev = -1, cnt = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] > x) continue;\\n            if(prev != -1 && i == prev + 1) continue;\\n            cnt++;\\n            prev = i;\\n        }\\n        return cnt >= k;\\n    }\\n     \\n    int minCapability(vector<int>& nums, int k) {\\n        n = nums.size();\\n        int l = 0, r = 1e9 + 2, ans = -1;\\n\\n        while(l <= r) {\\n            int mid = (l + r) >> 1;\\n            if(isPossible(mid, k, nums)) {\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }        \\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144026,
                "title": "stupid-greedy-union-find-solution-no-binary-search-c",
                "content": "# Intuition\\nGreedy.. No binary search... I don\\'t know why I didn\\'t think of binary search which is much easier. \\nUse priority queue and sort nums array with its index in the queue(or heap). Pop element from queue 1 by 1 and as soon as you can create a sequence of size >=k with non consecutive elements, you are done.\\n\\n# Approach\\nYou have to find minimum number -> num such that you can construct a sequence of length >=k of non consecutive elements and all the numbers in this sequence are <=num. We start with smallest number and move on to bigger numbers using heap. At any point if we pop an element from heap and find that we can construct such sequence, we are done. \\n\\nMaintain a parent array and size array (standard union find) of all the numbers already popped from the heap. Suppose at any iteration we pop the element at index idx(initially it is its own parent) but we have already popped the element at index ->idx-1 earlier, so we now need to merge these two components. \\nThe idea behind this is that any component represents the consecutive elements that we have already popped from heap (Suppose the elements popped are 1,2,3,6,7,8 then 1,2,3 are present in one component and 6,7,8 in other component). Similarly check if we had earlier popped element at index-> idx+1. If yes, merge again. The benefit is that suppose a component contains x elements. We can only select [(x+1)/2] elements from this component because of non consecutive requirement. \\n\\nMaintain a counter->cur which at any iteration denotes the maximum sequence of non consecutive elements that we can form such that all elements are  <= element popped from heap. Suppose num=[1,2,3,4]. We pop 1 and put it in component 1. We pop 2 and merge with 1st component. Still cur=1. Pop 3 and merge. Now cur=[(3+1)/2]=2. Pop 4. Still cur=[(4+1)/2]=2.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass helper\\n{\\n    public:\\n    bool operator()(const pair<int,int>& a,const pair<int,int>& b)\\n    {\\n        if(a.first<b.first)\\n            return false;\\n        \\n            return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int find(vector<int>& parent,int i)\\n    {\\n        if(i<0 ||i>=parent.size())\\n            return -1;\\n        if(parent[i]==-1) //This means element at index i has not yet been popped from the heap\\n            return -1;\\n        if(parent[i]==i)  \\n            return i;\\n        return parent[i]=find(parent,parent[i]);\\n    }\\n    int flo(int i)\\n    {\\n        return (i+1)/2;\\n    }\\n    void merge(int a,int b,vector<int>& parent,vector<int>& size)\\n    {\\n        parent[a]=b;\\n        size[b]+=size[a];\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,helper> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        int n = nums.size();\\n        int cur=0; // Length of longest sequence with non consecutive element\\n        vector<int> parent(n,-1),size(n,0);\\n        while(cur<k)\\n        {\\n            pair<int,int> p=pq.top();\\n            pq.pop();\\n            int index=p.second;  //Index of popped element in nums\\n            parent[index]=index; //Add this element as its own parent            \\n            size[index]++;     //Size of this component is now 1 \\n            \\n            int comp_prev=find(parent,index-1); //Gives component of index-1 if that element is already popped from heap\\n            int comp_next=find(parent,index+1); //Gives component of index+1 if that element is already popped from heap\\n            \\n            if(comp_prev!=-1 && comp_next!=-1)  //We need to merge 3 components\\n            {\\n                cur-=flo(size[comp_prev]);\\n                cur-=flo(size[comp_next]);\\n                merge(comp_prev,index,parent,size);\\n                merge(comp_next,index,parent,size);\\n                cur+=flo(size[index]);\\n            }\\n            else if(comp_prev!=-1)  //Merge 2 components\\n            {\\n                cur-=flo(size[comp_prev]);\\n                merge(comp_prev,index,parent,size);\\n                cur+=flo(size[index]);\\n            }\\n            else if(comp_next!=-1)  //Merge 2 components\\n            {\\n                cur-=flo(size[comp_next]);\\n                merge(comp_next,index,parent,size);\\n                cur+=flo(size[index]);\\n            }\\n            else    //No merge required\\n                cur++;\\n            if(cur>=k)\\n                return p.first;\\n        }\\n        return -5; //Return anything... it does not matter\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass helper\\n{\\n    public:\\n    bool operator()(const pair<int,int>& a,const pair<int,int>& b)\\n    {\\n        if(a.first<b.first)\\n            return false;\\n        \\n            return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int find(vector<int>& parent,int i)\\n    {\\n        if(i<0 ||i>=parent.size())\\n            return -1;\\n        if(parent[i]==-1) //This means element at index i has not yet been popped from the heap\\n            return -1;\\n        if(parent[i]==i)  \\n            return i;\\n        return parent[i]=find(parent,parent[i]);\\n    }\\n    int flo(int i)\\n    {\\n        return (i+1)/2;\\n    }\\n    void merge(int a,int b,vector<int>& parent,vector<int>& size)\\n    {\\n        parent[a]=b;\\n        size[b]+=size[a];\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,helper> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push({nums[i],i});\\n        }\\n        int n = nums.size();\\n        int cur=0; // Length of longest sequence with non consecutive element\\n        vector<int> parent(n,-1),size(n,0);\\n        while(cur<k)\\n        {\\n            pair<int,int> p=pq.top();\\n            pq.pop();\\n            int index=p.second;  //Index of popped element in nums\\n            parent[index]=index; //Add this element as its own parent            \\n            size[index]++;     //Size of this component is now 1 \\n            \\n            int comp_prev=find(parent,index-1); //Gives component of index-1 if that element is already popped from heap\\n            int comp_next=find(parent,index+1); //Gives component of index+1 if that element is already popped from heap\\n            \\n            if(comp_prev!=-1 && comp_next!=-1)  //We need to merge 3 components\\n            {\\n                cur-=flo(size[comp_prev]);\\n                cur-=flo(size[comp_next]);\\n                merge(comp_prev,index,parent,size);\\n                merge(comp_next,index,parent,size);\\n                cur+=flo(size[index]);\\n            }\\n            else if(comp_prev!=-1)  //Merge 2 components\\n            {\\n                cur-=flo(size[comp_prev]);\\n                merge(comp_prev,index,parent,size);\\n                cur+=flo(size[index]);\\n            }\\n            else if(comp_next!=-1)  //Merge 2 components\\n            {\\n                cur-=flo(size[comp_next]);\\n                merge(comp_next,index,parent,size);\\n                cur+=flo(size[index]);\\n            }\\n            else    //No merge required\\n                cur++;\\n            if(cur>=k)\\n                return p.first;\\n        }\\n        return -5; //Return anything... it does not matter\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143903,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        def good(target):\\n            count=0\\n            i=0\\n\\n            while i<n:\\n                if nums[i]<=target:\\n                    i+=2\\n                    count+=1\\n                    continue\\n\\n                i+=1\\n\\n            return count>=k\\n\\n        left=0\\n        right=10**12\\n        while left<right:\\n            mid=(left+right)//2\\n            if good(mid):\\n                right=mid\\n\\n            else:\\n                left=mid+1\\n\\n\\n        return left                        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        def good(target):\\n            count=0\\n            i=0\\n\\n            while i<n:\\n                if nums[i]<=target:\\n                    i+=2\\n                    count+=1\\n                    continue\\n\\n                i+=1\\n\\n            return count>=k\\n\\n        left=0\\n        right=10**12\\n        while left<right:\\n            mid=(left+right)//2\\n            if good(mid):\\n                right=mid\\n\\n            else:\\n                left=mid+1\\n\\n\\n        return left                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143749,
                "title": "dp-binary-search",
                "content": "# DP + binary search\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &a, int k, int i, vector<int> &dp){\\n        if(i>=a.size())return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int not_take=helper(a,k,i+1,dp);\\n        return dp[i]= (a[i]<=k)?max(helper(a,k,i+2,dp)+1,not_take):not_take;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int low =0, high =1e9;\\n        while(low+1<high){\\n            int m=low+(high-low)/2;\\n            vector<int> dp((int)nums.size(),-1);\\n            if((int)helper(nums,m,0,dp)>=k)high=m;\\n            else low=m;\\n        }\\n        return high;\\n    }\\n};\\n```\\n\\n# Binary search \\n```\\nclass Solution {\\npublic:\\n     \\n    int minCapability(vector<int>& A, int k) {\\n        int left = 1, right = 1e9, n = A.size();\\n        while (left < right) {\\n            int mid = (left + right) / 2, take = 0;\\n            for (int i = 0; i < n; ++i)if (A[i] <= mid) take += 1, i++;\\n            if (take >= k) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;  \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &a, int k, int i, vector<int> &dp){\\n        if(i>=a.size())return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int not_take=helper(a,k,i+1,dp);\\n        return dp[i]= (a[i]<=k)?max(helper(a,k,i+2,dp)+1,not_take):not_take;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int low =0, high =1e9;\\n        while(low+1<high){\\n            int m=low+(high-low)/2;\\n            vector<int> dp((int)nums.size(),-1);\\n            if((int)helper(nums,m,0,dp)>=k)high=m;\\n            else low=m;\\n        }\\n        return high;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     \\n    int minCapability(vector<int>& A, int k) {\\n        int left = 1, right = 1e9, n = A.size();\\n        while (left < right) {\\n            int mid = (left + right) / 2, take = 0;\\n            for (int i = 0; i < n; ++i)if (A[i] <= mid) take += 1, i++;\\n            if (take >= k) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;  \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143727,
                "title": "c-binary-search",
                "content": "Intuition:\\n\\n- If we can figure out that robbery is possible from atleast k houses given a max limit then we can solve this using binary search.\\n- Sort the array given.\\n    - Start from mid element\\n        - If it\\'s possible to rob from atleast k houses with less or equal to this amount, I change my L pointer to mid\\n        - Otherwise change r pointer to mid - 1, since mid or more is definitely not the answer.\\n    - ultimately you will reach the lowest amount with which you can rob k houses\\n    \\n\\n**Please upvote if you like the solution**\\n```\\nclass Solution {\\n    bool isPossible(int maxNum, int k, vector<int>& nums) {\\n        int t = 0;\\n        int pp = 0, p = 0; // pp - max number of houses we can rob which is not adjacent to curr element, p - max number of houses if we include adjacent.\\n        if (nums[0] <= maxNum) p = 1; // we can rob one house\\n        else p = 0;\\n        int n = nums.size();\\n        for (int i = 1; i < n; i++) {\\n            int curr = p;\\n            if (nums[i] <= maxNum) {\\n                curr = max(pp + 1, p);\\n            } \\n            \\n            if (curr == k) return true;\\n            pp = p;\\n            p = curr;\\n        }\\n        return max(pp, p) >= k;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {   \\n        int n = nums.size();\\n        \\n        vector<int> copy = nums;\\n        sort(copy.begin(), copy.end());\\n        \\n        int l = 0, r = n - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (isPossible(copy[mid], k, nums)) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return copy[l];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool isPossible(int maxNum, int k, vector<int>& nums) {\\n        int t = 0;\\n        int pp = 0, p = 0; // pp - max number of houses we can rob which is not adjacent to curr element, p - max number of houses if we include adjacent.\\n        if (nums[0] <= maxNum) p = 1; // we can rob one house\\n        else p = 0;\\n        int n = nums.size();\\n        for (int i = 1; i < n; i++) {\\n            int curr = p;\\n            if (nums[i] <= maxNum) {\\n                curr = max(pp + 1, p);\\n            } \\n            \\n            if (curr == k) return true;\\n            pp = p;\\n            p = curr;\\n        }\\n        return max(pp, p) >= k;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {   \\n        int n = nums.size();\\n        \\n        vector<int> copy = nums;\\n        sort(copy.begin(), copy.end());\\n        \\n        int l = 0, r = n - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (isPossible(copy[mid], k, nums)) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return copy[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143678,
                "title": "rip-my-dp-mle",
                "content": "```\\nclass Solution {\\n    int max=(int)1e9+7;\\n    int dp[][];\\n    public int minCapability(int[] nums, int k) {\\n        dp=new int[nums.length][k+1];\\n        for(int arr[]:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(nums,0,k,0);\\n    }\\n    int helper(int nums[],int idx,int k,int score){\\n        if(idx>=nums.length || k==0){\\n            if(k==0) return 0;\\n            else return max;\\n        }\\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        int take=Math.max(nums[idx],helper(nums,idx+2,k-1,score));\\n        int nottake=helper(nums,idx+1,k,score);\\n        return dp[idx][k]=Math.min(take,nottake);\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max=(int)1e9+7;\\n    int dp[][];\\n    public int minCapability(int[] nums, int k) {\\n        dp=new int[nums.length][k+1];\\n        for(int arr[]:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(nums,0,k,0);\\n    }\\n    int helper(int nums[],int idx,int k,int score){\\n        if(idx>=nums.length || k==0){\\n            if(k==0) return 0;\\n            else return max;\\n        }\\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        int take=Math.max(nums[idx],helper(nums,idx+2,k-1,score));\\n        int nottake=helper(nums,idx+1,k,score);\\n        return dp[idx][k]=Math.min(take,nottake);\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143656,
                "title": "c-binary-search-dp-o-n-log-n",
                "content": "**Intuition:** \\nThis is the classic house robber problem with an additional constraint that lets the amount of houses robbed be non-decreasing as the capability of the robber goes up,  think why. Binary search works with monotonic / non-decreasing functions, so we can use it to find the optimal answer.\\n\\n**Explanation:** \\nInitialize l to 0 and r to 1e9 and run binary search on the middle value every time. In each check, use dfs + memo to find the maximum houses that can be robbed with the current capability. If it is more than k, then r can be shrunk to mid-1 because all values >= mid are also good and we want to minimize r. Likewise for l.\\n\\n**Complexity** \\n``` \\nTime: O(N log N)\\nSpace: O(N)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int memo[100001] = {};\\n    int dfs(vector<int>& nums, int k, int mid, int pos){\\n        if(pos >= nums.size()) return 0;\\n        if(memo[pos] != -1) return memo[pos];\\n        int ans = 0;\\n        ans = dfs(nums, k, mid, pos+1);\\n        if(mid >= nums[pos]) ans = max(ans, dfs(nums, k, mid, pos+2)+1);\\n        return memo[pos] = ans;\\n    }\\n    int check(vector<int>& nums, int k, int mid){\\n        memset(memo, -1, sizeof memo);\\n        int mx = dfs(nums, k, mid, 0);\\n        if(mx >= k) return 1;\\n        else return -1;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        long long l = 0, r = 1e9+100, ans = INT_MAX;\\n        while(l <= r){\\n            long long mid = (l+r)/2;\\n            int res = check(nums, k, mid);\\n            if(res == 1){\\n                r = mid-1;\\n                ans = min(ans, mid);\\n            }\\n            else if(res == -1) l = mid+1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "``` \\nTime: O(N log N)\\nSpace: O(N)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143652,
                "title": "javascript-binary-search",
                "content": "**Solution: Binary Search**\\n\\nBinary search for minimum maximum `nums[i]`.\\nTo check whether it is possible to take `k` non-adjacent houses with maximum score of `nums[i]`,\\n*   Greedily take `k` houses with `nums[i] <= max`.\\n*   When we find `nums[i] <= max`, take the house and skip to `nums[i + 2]` (It is optimal to take a house earlier than later).\\n\\n`n = length of nums`, `m = max(nums[i])`\\nTime Complexity: `O(n log(m))`\\nSpace Complexity: `O(1)`\\n```\\nvar minCapability = function(nums, k) {\\n  let min = nums[0], max = nums[0];\\n  let n = nums.length;\\n  for (let i = 0; i < n; i++) {\\n    min = Math.min(min, nums[i]);\\n    max = Math.max(max, nums[i]);\\n  }\\n  let low = min, high = max;\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (isEnough(mid)) high = mid;\\n    else low = mid + 1;\\n  }\\n  return low;\\n  \\n  function isEnough(max) { // greedily take k houses with nums[i] <= max\\n    let houses = 0;\\n    for (let i = 0; i < n; i++) {\\n      if (nums[i] <= max) {\\n        houses++;\\n        i++;\\n      }\\n      if (houses === k) return true;\\n    }\\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minCapability = function(nums, k) {\\n  let min = nums[0], max = nums[0];\\n  let n = nums.length;\\n  for (let i = 0; i < n; i++) {\\n    min = Math.min(min, nums[i]);\\n    max = Math.max(max, nums[i]);\\n  }\\n  let low = min, high = max;\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (isEnough(mid)) high = mid;\\n    else low = mid + 1;\\n  }\\n  return low;\\n  \\n  function isEnough(max) { // greedily take k houses with nums[i] <= max\\n    let houses = 0;\\n    for (let i = 0; i < n; i++) {\\n      if (nums[i] <= max) {\\n        houses++;\\n        i++;\\n      }\\n      if (houses === k) return true;\\n    }\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068680,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int> &a,int k){\\n        int no_of_house=0,pre_idx=-2;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i] <= mid){\\n                if(i-pre_idx >= 2){\\n                    no_of_house++;\\n                    pre_idx=i;\\n                }\\n            }\\n        }\\n        return no_of_house >= k;\\n    }\\n    int minCapability(vector<int>& a, int k) {\\n        int i=*min_element(a.begin(),a.end()), j=*max_element(a.begin(),a.end()),ans=0;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(check(mid,a,k)){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else i=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int> &a,int k){\\n        int no_of_house=0,pre_idx=-2;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i] <= mid){\\n                if(i-pre_idx >= 2){\\n                    no_of_house++;\\n                    pre_idx=i;\\n                }\\n            }\\n        }\\n        return no_of_house >= k;\\n    }\\n    int minCapability(vector<int>& a, int k) {\\n        int i=*min_element(a.begin(),a.end()), j=*max_element(a.begin(),a.end()),ans=0;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(check(mid,a,k)){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else i=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064831,
                "title": "simple-beginner-level-c-solution-beats-100-in-runtime-and-memory-binary-search-simulation",
                "content": "\\n# Complexity\\n- Time complexity: ```O(log(nums.max - nums.min))```\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp\\n// Runtime 91 ms Beats 100% Memory 13.4 MB Beats 100%\\ninline int max(int a, int b) {\\n    return (a > b) ? a : b;\\n}\\ninline int min(int a, int b) {\\n    return (a < b) ? a : b;\\n}\\nint max_element(int* arr, int arrSize) {\\n    int result = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        result = max(result, arr[i]);\\n    }\\n    return result;\\n}\\nint min_element(int* arr, int arrSize) {\\n    int result = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        result = min(result, arr[i]);\\n    }\\n    return result;\\n}\\nint num_houses_stolen(const int* const nums, int numsSize, int capacity) {\\n    int houses_stolen = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] > capacity) continue;\\n        houses_stolen++;\\n        i++;\\n    }\\n    return houses_stolen;\\n}\\nint minCapability(int* nums, int numsSize, int k) {\\n    // Binary search + Simulatiuon\\n\\n    // Time complexity: O(log(nums.max - nums.min))\\n    // Space complexity: O(1)\\n    \\n    int left = min_element(nums, numsSize);\\n    int right = max_element(nums, numsSize);\\n    while (left < right) {\\n        int middle = left + (right - left) / 2;\\n        if (num_houses_stolen(nums, numsSize, middle) >= k) {\\n            right = middle;\\n        }\\n        else left = middle + 1;\\n    }\\n    return left;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Search",
                    "Simulation"
                ],
                "code": "```O(log(nums.max - nums.min))```\n```O(1)```\n```cpp\\n// Runtime 91 ms Beats 100% Memory 13.4 MB Beats 100%\\ninline int max(int a, int b) {\\n    return (a > b) ? a : b;\\n}\\ninline int min(int a, int b) {\\n    return (a < b) ? a : b;\\n}\\nint max_element(int* arr, int arrSize) {\\n    int result = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        result = max(result, arr[i]);\\n    }\\n    return result;\\n}\\nint min_element(int* arr, int arrSize) {\\n    int result = arr[0];\\n    for (int i = 1; i < arrSize; i++) {\\n        result = min(result, arr[i]);\\n    }\\n    return result;\\n}\\nint num_houses_stolen(const int* const nums, int numsSize, int capacity) {\\n    int houses_stolen = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] > capacity) continue;\\n        houses_stolen++;\\n        i++;\\n    }\\n    return houses_stolen;\\n}\\nint minCapability(int* nums, int numsSize, int k) {\\n    // Binary search + Simulatiuon\\n\\n    // Time complexity: O(log(nums.max - nums.min))\\n    // Space complexity: O(1)\\n    \\n    int left = min_element(nums, numsSize);\\n    int right = max_element(nums, numsSize);\\n    while (left < right) {\\n        int middle = left + (right - left) / 2;\\n        if (num_houses_stolen(nums, numsSize, middle) >= k) {\\n            right = middle;\\n        }\\n        else left = middle + 1;\\n    }\\n    return left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004409,
                "title": "simple-binary-search-with-memoization",
                "content": "# Intuition\\nUsing Dp with Binary Search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSearch space ranges between minimum element and maximum element in the given array. Try finding the required answer from this serach space.\\n\\n# Complexity\\n- Time complexity:  O(n * log(maximum value in \\'nums\\'))\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int helper(int idx, vector<int> &nums, int k, int mid, vector<int> &dp)\\n    {\\n        if(idx >= nums.size()) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int take = 0;\\n        if(nums[idx] <= mid)\\n        {\\n            take = 1 + helper(idx + 2, nums, k, mid, dp);\\n        }\\n        \\n        int notTake = 0 + helper(idx + 1, nums, k, mid, dp);\\n        \\n        return dp[idx] = max(take, notTake);\\n    }\\n    \\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        int start = *min_element(nums.begin(), nums.end());\\n        int end = *max_element(nums.begin(), nums.end());\\n        \\n        int ans = 1e9;\\n        \\n        while(start <= end)\\n        {\\n            int mid = (start + end) / 2;\\n            vector<int> dp(n + 1, -1);\\n            int houses = helper(0, nums, k, mid, dp);\\n            if(houses >= k)\\n            {\\n                ans = min(ans, mid);\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(int idx, vector<int> &nums, int k, int mid, vector<int> &dp)\\n    {\\n        if(idx >= nums.size()) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int take = 0;\\n        if(nums[idx] <= mid)\\n        {\\n            take = 1 + helper(idx + 2, nums, k, mid, dp);\\n        }\\n        \\n        int notTake = 0 + helper(idx + 1, nums, k, mid, dp);\\n        \\n        return dp[idx] = max(take, notTake);\\n    }\\n    \\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        int start = *min_element(nums.begin(), nums.end());\\n        int end = *max_element(nums.begin(), nums.end());\\n        \\n        int ans = 1e9;\\n        \\n        while(start <= end)\\n        {\\n            int mid = (start + end) / 2;\\n            vector<int> dp(n + 1, -1);\\n            int houses = helper(0, nums, k, mid, dp);\\n            if(houses >= k)\\n            {\\n                ans = min(ans, mid);\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949845,
                "title": "binary-search-on-answers-explained",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(max(max) - log(min)))$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    int housesRobbed(int currCapability, vector<int>& nums)\\n    {\\n        int i=0, totalHouses = 0;\\n        //count total non-adjacent houses having currCapability as max capability\\n        while(i < nums.size())\\n        {\\n            if(nums[i] <= currCapability)\\n            {\\n             totalHouses++;\\n             i++; //to skip next house because we have taken current house\\n            }\\n         i++;\\n        }\\n     return totalHouses; \\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n      int low = INT_MAX, high = INT_MIN, mid;\\n\\n      for(auto it : nums)\\n      {\\n          low = min(low,it);\\n          high = max(high,it);\\n      }\\n    //perform binary search on all capabalities from low to high\\n      while(low <= high)\\n      {\\n          mid = low + (high-low)/2;\\n          if(housesRobbed(mid,nums) >= k) //if we can steal at least k houses\\n           high = mid - 1; //look for a lower possible value of capability\\n          else \\n           low = mid + 1; //otherwise, we have to look for a higher value of capability\\n      }\\n      return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    int housesRobbed(int currCapability, vector<int>& nums)\\n    {\\n        int i=0, totalHouses = 0;\\n        //count total non-adjacent houses having currCapability as max capability\\n        while(i < nums.size())\\n        {\\n            if(nums[i] <= currCapability)\\n            {\\n             totalHouses++;\\n             i++; //to skip next house because we have taken current house\\n            }\\n         i++;\\n        }\\n     return totalHouses; \\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n      int low = INT_MAX, high = INT_MIN, mid;\\n\\n      for(auto it : nums)\\n      {\\n          low = min(low,it);\\n          high = max(high,it);\\n      }\\n    //perform binary search on all capabalities from low to high\\n      while(low <= high)\\n      {\\n          mid = low + (high-low)/2;\\n          if(housesRobbed(mid,nums) >= k) //if we can steal at least k houses\\n           high = mid - 1; //look for a lower possible value of capability\\n          else \\n           low = mid + 1; //otherwise, we have to look for a higher value of capability\\n      }\\n      return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933483,
                "title": "python-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n\\n        l=len(nums)\\n\\n\\n        \\n\\n        def cond(mid):\\n            \\n            last=-2\\n            count=0\\n            for i in range(l):\\n                if nums[i]<=mid and i-last>1:\\n                    last=i\\n                    count+=1\\n            if count>=k:\\n                return True\\n            return False\\n                    \\n        left,right=0,max(nums)\\n        while left<right:\\n            mid=left+(right-left)//2\\n            if cond(mid):\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n\\n        l=len(nums)\\n\\n\\n        \\n\\n        def cond(mid):\\n            \\n            last=-2\\n            count=0\\n            for i in range(l):\\n                if nums[i]<=mid and i-last>1:\\n                    last=i\\n                    count+=1\\n            if count>=k:\\n                return True\\n            return False\\n                    \\n        left,right=0,max(nums)\\n        while left<right:\\n            mid=left+(right-left)//2\\n            if cond(mid):\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933240,
                "title": "binary-search-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int start =1;\\n        int ans = Integer.MAX_VALUE;\\n        int end = Integer.MAX_VALUE;\\n        while(start <= end){\\n            int count =0;\\n            int mid = start+(end-start)/2;\\n            int len = nums.length;\\n            for(int i=0;i<len;i++){\\n                if(nums[i]<=mid){\\n                    i++;\\n                    count++;\\n                }\\n            }\\n            if(count>=k){\\n                ans = Math.min(ans,mid);\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int start =1;\\n        int ans = Integer.MAX_VALUE;\\n        int end = Integer.MAX_VALUE;\\n        while(start <= end){\\n            int count =0;\\n            int mid = start+(end-start)/2;\\n            int len = nums.length;\\n            for(int i=0;i<len;i++){\\n                if(nums[i]<=mid){\\n                    i++;\\n                    count++;\\n                }\\n            }\\n            if(count>=k){\\n                ans = Math.min(ans,mid);\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917225,
                "title": "elixir-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(d))$$, where `d = max(nums) - min(nums)`\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec min_capability(nums :: [integer], k :: integer) :: integer\\n  def min_capability(nums, k) do\\n    Enum.min_max(nums)\\n    |> binary_search(nums, k)\\n  end\\n\\n  defp binary_search({lo, lo}, _, _), do: lo\\n  defp binary_search({lo, hi}, nums, k) do\\n    mid = div(lo + hi, 2)\\n    if rob_k?(mid, nums, k) do\\n      binary_search({lo, mid}, nums, k)\\n    else\\n      binary_search({mid + 1, hi}, nums, k)\\n    end\\n  end\\n\\n  defp rob_k?(_, _, 0), do: true\\n  defp rob_k?(_, [], _), do: false\\n  defp rob_k?(mid, nums = [x | _], k) when x <= mid do\\n    rob_k?(mid, Enum.drop(nums, 2), k - 1)\\n  end\\n  defp rob_k?(mid, [_ | tail], k) do\\n    rob_k?(mid, tail, k)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec min_capability(nums :: [integer], k :: integer) :: integer\\n  def min_capability(nums, k) do\\n    Enum.min_max(nums)\\n    |> binary_search(nums, k)\\n  end\\n\\n  defp binary_search({lo, lo}, _, _), do: lo\\n  defp binary_search({lo, hi}, nums, k) do\\n    mid = div(lo + hi, 2)\\n    if rob_k?(mid, nums, k) do\\n      binary_search({lo, mid}, nums, k)\\n    else\\n      binary_search({mid + 1, hi}, nums, k)\\n    end\\n  end\\n\\n  defp rob_k?(_, _, 0), do: true\\n  defp rob_k?(_, [], _), do: false\\n  defp rob_k?(mid, nums = [x | _], k) when x <= mid do\\n    rob_k?(mid, Enum.drop(nums, 2), k - 1)\\n  end\\n  defp rob_k?(mid, [_ | tail], k) do\\n    rob_k?(mid, tail, k)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3908888,
                "title": "binary-search-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minCapability = function(nums, k) {\\n    let min = Math.min(...nums)\\n    let max = Math.max(...nums)\\n    let lowest = min\\n    let highest = max\\n    while (lowest < highest) {\\n      const mid = Math.floor((lowest + highest) / 2)\\n      let houses = 0\\n      let isAtCapacity = false\\n      for (let i = 0; i < nums.length && !isAtCapacity; i++) {\\n        if (nums[i] <= mid) {\\n          houses++;\\n          i++;\\n        }\\n        if (houses === k) isAtCapacity = true\\n      }\\n      if (isAtCapacity) highest = mid\\n      else lowest = mid + 1\\n    }\\n    return lowest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minCapability = function(nums, k) {\\n    let min = Math.min(...nums)\\n    let max = Math.max(...nums)\\n    let lowest = min\\n    let highest = max\\n    while (lowest < highest) {\\n      const mid = Math.floor((lowest + highest) / 2)\\n      let houses = 0\\n      let isAtCapacity = false\\n      for (let i = 0; i < nums.length && !isAtCapacity; i++) {\\n        if (nums[i] <= mid) {\\n          houses++;\\n          i++;\\n        }\\n        if (houses === k) isAtCapacity = true\\n      }\\n      if (isAtCapacity) highest = mid\\n      else lowest = mid + 1\\n    }\\n    return lowest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895498,
                "title": "golang-binary-search-100-solution",
                "content": "# Code\\n```go\\nfunc minCapability(nums []int, k int) int {\\n\\tl, r := 1, 1000000000\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tx := 0\\n\\t\\tfor i := 0; i < len(nums); {\\n\\t\\t\\tif nums[i] <= m {\\n\\t\\t\\t\\ti += 2\\n\\t\\t\\t\\tx++\\n\\t\\t\\t\\tif x >= k {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif x >= k {\\n\\t\\t\\tr = m - 1\\n\\t\\t} else {\\n\\t\\t\\tl = m + 1\\n\\t\\t}\\n\\t}\\n\\treturn r + 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minCapability(nums []int, k int) int {\\n\\tl, r := 1, 1000000000\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tx := 0\\n\\t\\tfor i := 0; i < len(nums); {\\n\\t\\t\\tif nums[i] <= m {\\n\\t\\t\\t\\ti += 2\\n\\t\\t\\t\\tx++\\n\\t\\t\\t\\tif x >= k {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif x >= k {\\n\\t\\t\\tr = m - 1\\n\\t\\t} else {\\n\\t\\t\\tl = m + 1\\n\\t\\t}\\n\\t}\\n\\treturn r + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879486,
                "title": "binary-search-easy-implementation-c-no-dp",
                "content": "\\n```\\nclass Solution {\\n    vector<int> a;\\npublic:\\n// We need to find consective capabilities>=k and take half of them every time as we can\\'t pick consective houses\\n    bool isValid(int c,int k){\\n        int consec=0,cnt=0;\\n        \\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<=c){\\n                consec++;\\n            }\\n            else{\\n                cnt+= (consec+1)/2;\\n                consec=0;\\n            }\\n        }\\n        cnt+= (consec+1)/2;\\n    \\n        return cnt>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        a=nums;\\n       \\n        int l=0,r=1e9+1;\\n        \\n        while(r-l>1){\\n            int m=l+(r-l)/2;\\n            \\n            if(isValid(m,k)){\\n                r=m;\\n            }\\n            else{\\n                l=m;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> a;\\npublic:\\n// We need to find consective capabilities>=k and take half of them every time as we can\\'t pick consective houses\\n    bool isValid(int c,int k){\\n        int consec=0,cnt=0;\\n        \\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<=c){\\n                consec++;\\n            }\\n            else{\\n                cnt+= (consec+1)/2;\\n                consec=0;\\n            }\\n        }\\n        cnt+= (consec+1)/2;\\n    \\n        return cnt>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        a=nums;\\n       \\n        int l=0,r=1e9+1;\\n        \\n        while(r-l>1){\\n            int m=l+(r-l)/2;\\n            \\n            if(isValid(m,k)){\\n                r=m;\\n            }\\n            else{\\n                l=m;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862251,
                "title": "simple-binary-search-99-beats-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we have to find minimum of the maximum, so we can check the solution for each number after sorting the array. And searching efficiently can be done using binary search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssume an array [2, 3, 5, 7, 9] and k=2\\nlet us solve for 9 -> Can we rob 2 non adjacent houses where the maximum capability of the robber is 9. Yes, we can. We can rob [2, 9], [3, 9], [5, 9].\\nSo the answer MAY BE 9, or something below it.\\nNow, let us solve for 7 -> Can we rob 2 non adjacent houses where the maximum capability of the robber is 7. Yes, we can. We can rob [2, 7], [3, 7].\\nSo the answer MAY BE 7, or something below it.\\nNow, let us solve for 5 -> Can we rob 2 non adjacent houses where the maximum capability of the robber is 5. Yes, we can. We can rob [2, 5]. But can we rob [5, 9]? No we can\\'t. If we did the maximum capability becomes 9, and we have to maintain it to 5.\\nSo the answer MAY BE 5, or something below it.\\nAND SO ON..... till we can\\'t rob any more non-adjacent houses.\\nHere if we solve for 3, we can\\'t rob any house that is less than 3 and is non-adjacent. So the last minimum capability of robbing houses was 5 and we return it.\\nWe are searching an answer within the given arrat so binary search can do it efficiently. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\nAs we have to sort the original array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\nAs a new copy array is required.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int x,int k,vector<int>& nums){ \\n// we check for all the non adjacent houses which are less than the current selected house i.e. x.\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=x)   k--,i++;\\n        }\\n// return true if target is reached.\\n        if(k<=0)    return 1;\\n        return 0;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        int l=0,sz=nums.size(),h=sz-1;\\n        vector<int>temp=nums; // Extra array in which we will apply binary search to find the answer.\\n        sort(temp.begin(),temp.end()); // Sort, so binary search can be applied\\n        while(l<h){\\n            int mid=l+(h-l)/2;  // To avoid Overflow \\n            if(!solve(temp[mid],k,nums))   l=mid+1; // If the temp[mid] can\\'t be the answer so we shift the low to mid+1.\\n            else    h=mid; //else high to mid , as that mid might be the last minimum capability.\\n        }\\n        return temp[l];\\n    }\\n};\\n```\\nPLEASE UPVOTE IF YOU LIKED THE SOLUTION.\\uD83D\\uDE09",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int x,int k,vector<int>& nums){ \\n// we check for all the non adjacent houses which are less than the current selected house i.e. x.\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=x)   k--,i++;\\n        }\\n// return true if target is reached.\\n        if(k<=0)    return 1;\\n        return 0;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        int l=0,sz=nums.size(),h=sz-1;\\n        vector<int>temp=nums; // Extra array in which we will apply binary search to find the answer.\\n        sort(temp.begin(),temp.end()); // Sort, so binary search can be applied\\n        while(l<h){\\n            int mid=l+(h-l)/2;  // To avoid Overflow \\n            if(!solve(temp[mid],k,nums))   l=mid+1; // If the temp[mid] can\\'t be the answer so we shift the low to mid+1.\\n            else    h=mid; //else high to mid , as that mid might be the last minimum capability.\\n        }\\n        return temp[l];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3858139,
                "title": "easy-java-begineer-friendly-solution-using-binary-search",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int ans=Integer.MAX_VALUE;\\n        int start=1;\\n        int end=(int)1e9;\\n        while(start<=end){\\n            int org=k;\\n            int mid=(start+end)/2;\\n            int i=0;\\n            while(i<nums.length){\\n                if(nums[i]<=mid){\\n                    org--;\\n                    i+=2;\\n                }else i++;\\n                if(org==0)break;\\n            }\\n            if(org==0){\\n                ans=Math.min(ans,mid);\\n                end=mid-1;\\n            }else start=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int ans=Integer.MAX_VALUE;\\n        int start=1;\\n        int end=(int)1e9;\\n        while(start<=end){\\n            int org=k;\\n            int mid=(start+end)/2;\\n            int i=0;\\n            while(i<nums.length){\\n                if(nums[i]<=mid){\\n                    org--;\\n                    i+=2;\\n                }else i++;\\n                if(org==0)break;\\n            }\\n            if(org==0){\\n                ans=Math.min(ans,mid);\\n                end=mid-1;\\n            }else start=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759742,
                "title": "binary-search-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(nlog(dif)),dif=max-min in array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int h=nums[0];\\n        int l=nums[0];\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            h=Math.max(h,nums[i]);\\n            l=Math.min(l,nums[i]);\\n        }\\n        int ans=h;\\n        while(l<=h){\\n           int mid=l+(h-l)/2;\\n           int count=findCount(nums,mid,n);\\n           if(count>=k){\\n               ans=mid;\\n               h=mid-1;\\n           }\\n           else l=mid+1;\\n        }\\n        return ans;\\n    }\\n    public int findCount(int[] arr,int k,int n){\\n        boolean[] visited=new boolean[n];\\n        int count=0;\\n        if(arr[0]<=k){\\n            visited[0]=true;\\n            count++;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(arr[i]<=k && !visited[i-1]){\\n                visited[i]=true;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int h=nums[0];\\n        int l=nums[0];\\n        int n=nums.length;\\n        for(int i=0;i<n;i++){\\n            h=Math.max(h,nums[i]);\\n            l=Math.min(l,nums[i]);\\n        }\\n        int ans=h;\\n        while(l<=h){\\n           int mid=l+(h-l)/2;\\n           int count=findCount(nums,mid,n);\\n           if(count>=k){\\n               ans=mid;\\n               h=mid-1;\\n           }\\n           else l=mid+1;\\n        }\\n        return ans;\\n    }\\n    public int findCount(int[] arr,int k,int n){\\n        boolean[] visited=new boolean[n];\\n        int count=0;\\n        if(arr[0]<=k){\\n            visited[0]=true;\\n            count++;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(arr[i]<=k && !visited[i-1]){\\n                visited[i]=true;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731031,
                "title": "golang-binary-search-dp",
                "content": "# Code\\n```\\nfunc minCapability(nums []int, k int) int {\\n  if len(nums) == 1 {\\n    return nums[0]\\n  }\\n  min, max := nums[0], nums[0]\\n  for i := 0; i < len(nums); i++ {\\n    if nums[i] < min {\\n      min = nums[i]\\n    }\\n    if nums[i] > max {\\n      max = nums[i]\\n    }\\n  }\\n  left, right := min, max\\n  var res int\\n  for left <= right {\\n    mid := left + (right - left)/2\\n    if check(nums, k, mid) {\\n      res = mid\\n      right = mid - 1 // try to minimize\\n    } else {\\n      left = mid + 1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc check(nums []int, k int, target int) bool {\\n  var oneBack, twoBack int\\n  if nums[0] <= target {\\n    oneBack, twoBack = 1, 1\\n  }\\n  if nums[1] <= target {\\n    oneBack = 1\\n  }\\n  for i := 2; i < len(nums); i++ {\\n    var curr int\\n    if nums[i] <= target {\\n      curr = max(oneBack, 1+twoBack)\\n    } else {\\n      curr = oneBack\\n    }\\n    twoBack, oneBack = oneBack, curr\\n  }\\n  return oneBack >= k\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc minCapability(nums []int, k int) int {\\n  if len(nums) == 1 {\\n    return nums[0]\\n  }\\n  min, max := nums[0], nums[0]\\n  for i := 0; i < len(nums); i++ {\\n    if nums[i] < min {\\n      min = nums[i]\\n    }\\n    if nums[i] > max {\\n      max = nums[i]\\n    }\\n  }\\n  left, right := min, max\\n  var res int\\n  for left <= right {\\n    mid := left + (right - left)/2\\n    if check(nums, k, mid) {\\n      res = mid\\n      right = mid - 1 // try to minimize\\n    } else {\\n      left = mid + 1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc check(nums []int, k int, target int) bool {\\n  var oneBack, twoBack int\\n  if nums[0] <= target {\\n    oneBack, twoBack = 1, 1\\n  }\\n  if nums[1] <= target {\\n    oneBack = 1\\n  }\\n  for i := 2; i < len(nums); i++ {\\n    var curr int\\n    if nums[i] <= target {\\n      curr = max(oneBack, 1+twoBack)\\n    } else {\\n      curr = oneBack\\n    }\\n    twoBack, oneBack = oneBack, curr\\n  }\\n  return oneBack >= k\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702307,
                "title": "binary-search",
                "content": "\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int> nums,int k){\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=mid){\\n                count++;\\n                i++;\\n            }\\n        }\\n\\n        return count>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int i=1;\\n        int j=1e9;\\n        int ans=-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n\\n            if(check(mid,nums,k)){\\n                ans=mid;\\n                j=mid-1;\\n            }else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int> nums,int k){\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=mid){\\n                count++;\\n                i++;\\n            }\\n        }\\n\\n        return count>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int i=1;\\n        int j=1e9;\\n        int ans=-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n\\n            if(check(mid,nums,k)){\\n                ans=mid;\\n                j=mid-1;\\n            }else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648230,
                "title": "easy-soln-int-o-nlogn-time-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\napply binary search and 1d dp \\n\\n# Complexity\\n- Time complexity:o(nlogn)\\n\\n- Space complexity:o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        long long st=1,end=1e9,ans=0;\\n        while(st<=end)\\n        {\\n            long long mid=st+((end-st)/2);\\n            int x=0,y=0;\\n\\t        for(int i=0;i<n;i++)\\n\\t       {\\n               if(nums[i]<=mid) x++;\\n               int val=max(x,y);\\n               x=y;\\n               y=val;\\n\\t       }\\n            if(max(x,y)>=k)\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else st=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        long long st=1,end=1e9,ans=0;\\n        while(st<=end)\\n        {\\n            long long mid=st+((end-st)/2);\\n            int x=0,y=0;\\n\\t        for(int i=0;i<n;i++)\\n\\t       {\\n               if(nums[i]<=mid) x++;\\n               int val=max(x,y);\\n               x=y;\\n               y=val;\\n\\t       }\\n            if(max(x,y)>=k)\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else st=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595794,
                "title": "easy-solution-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        l, r, n = 1, 10**9, len(nums)\\n        while l <= r:\\n            m, t, i = (l+r)//2, 0, 0\\n            while i < n:\\n                if nums[i] <= m:\\n                    i += 2\\n                    t += 1\\n                else:\\n                    i += 1\\n            if t >= k:\\n                ans = m\\n                r = m-1\\n            else:\\n                l = m+1\\n        return ans\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        l, r, n = 1, 10**9, len(nums)\\n        while l <= r:\\n            m, t, i = (l+r)//2, 0, 0\\n            while i < n:\\n                if nums[i] <= m:\\n                    i += 2\\n                    t += 1\\n                else:\\n                    i += 1\\n            if t >= k:\\n                ans = m\\n                r = m-1\\n            else:\\n                l = m+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586077,
                "title": "ruby-solution-using-binary-search-with-explanation-100-100",
                "content": "# Intuition\\nIt\\'s easy to check if a given capability is possible.  Use binary search to find the minimum capability.\\n\\n# Approach\\n1. Perform a binary search from the minimum num in the array to the maximum to find the smallest possible capability.\\n2. To check if a capability is possible:\\n    - Iterate through the array.  If the number if <= the max allowed, skip two spaces and decrement k by one.\\n    - Check if k is <= 0 (i.e., you were able to rob at leaat k houses)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(k))$$, where *k* is the difference between nums.max and nums.min.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef min_capability(nums, k)\\n    @nums = nums\\n\\n    (nums.min..nums.max).bsearch { |max| possible?(max,k) }\\nend\\n\\ndef possible?(max,k)\\n    i = 0\\n\\n    while i < @nums.length\\n        if @nums[i] > max # can\\'t count this one\\n            i += 1\\n        else\\n            k -= 1\\n            i += 2 # skip the next house\\n        end\\n    end\\n\\n    k <= 0 # we were able to rob at least k houses\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef min_capability(nums, k)\\n    @nums = nums\\n\\n    (nums.min..nums.max).bsearch { |max| possible?(max,k) }\\nend\\n\\ndef possible?(max,k)\\n    i = 0\\n\\n    while i < @nums.length\\n        if @nums[i] > max # can\\'t count this one\\n            i += 1\\n        else\\n            k -= 1\\n            i += 2 # skip the next house\\n        end\\n    end\\n\\n    k <= 0 # we were able to rob at least k houses\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3577307,
                "title": "simple-binary-search-o-nlog-10-9-time-o-1-space",
                "content": "# Intuition\\nbinary search for min possible capacity from 1 to 10^9\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        long long l=1,r=1000000000,ans=INT_MAX;\\n        while(l<=r){\\n            long long m=(l+r)/2,c=0;\\n            for (int i=0;i<nums.size();i++)\\n                if (nums[i]<=m)\\n                    c++,i++;\\n            if (c>=k){\\n                r=m-1;\\n                ans=min(ans,m);\\n            }\\n            else\\n                l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        long long l=1,r=1000000000,ans=INT_MAX;\\n        while(l<=r){\\n            long long m=(l+r)/2,c=0;\\n            for (int i=0;i<nums.size();i++)\\n                if (nums[i]<=m)\\n                    c++,i++;\\n            if (c>=k){\\n                r=m-1;\\n                ans=min(ans,m);\\n            }\\n            else\\n                l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509776,
                "title": "2560-house-robber-iv-100-ac-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) \\n    {\\n        //talking all the numbers in possibility of 1<=l<=1000000000 as possible \\n        long long int l=1,r=1e9,mid,count,n=nums.size();\\n        \\n        while(l<r)\\n        {\\n            mid=(l+r)>>1;//doing the same step as traditional binary search\\n            \\n            count=0;//counting how many such homes can be stealed such that maxium still remains the mid value\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                if(mid>=nums[i])\\n                {\\n                    count++;//stealing current home then no need of going to next one so incrementing i hence i++ and count++ is because we are taking usrrent home\\n                    i++;\\n                }\\n            }\\n            \\n            //if total home stealed are less than minimum required i.e. K then we need to have more homes\\n            //so increased the limit of selection to above the current mid by doing l=mid+1 to r\\n            if(count<k)\\n            {\\n                l=mid+1;\\n            }\\n            else//in opposite if the number of stealed home exceeds k then we are talking the r to current mid so that search range comes down to l to mid;\\n            {\\n                r=mid;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) \\n    {\\n        //talking all the numbers in possibility of 1<=l<=1000000000 as possible \\n        long long int l=1,r=1e9,mid,count,n=nums.size();\\n        \\n        while(l<r)\\n        {\\n            mid=(l+r)>>1;//doing the same step as traditional binary search\\n            \\n            count=0;//counting how many such homes can be stealed such that maxium still remains the mid value\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                if(mid>=nums[i])\\n                {\\n                    count++;//stealing current home then no need of going to next one so incrementing i hence i++ and count++ is because we are taking usrrent home\\n                    i++;\\n                }\\n            }\\n            \\n            //if total home stealed are less than minimum required i.e. K then we need to have more homes\\n            //so increased the limit of selection to above the current mid by doing l=mid+1 to r\\n            if(count<k)\\n            {\\n                l=mid+1;\\n            }\\n            else//in opposite if the number of stealed home exceeds k then we are talking the r to current mid so that search range comes down to l to mid;\\n            {\\n                r=mid;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461578,
                "title": "binary-search-with-explanation-python",
                "content": "# Intuition\\nFind minimum maximum:\\n1. Binary Search in range min(nums) and max(nums). The capacity of robber will lie in this range.\\n2. Get count of houses that fit the capacity selected in each step of binary search(mid). \\n3. Compare this count with k(number of houses to be robbed)\\n4. If robber can rob >= k houses with selected capacity(mid) search to the left of mid. If robber can rob < k houses with selected capacity continue search on right.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExactly same as https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n\\n        low, high = min(nums), max(nums)\\n        while low <= high:\\n            mid = (low+high)//2\\n            i=0\\n            c=0\\n            while i < len(nums):\\n                if nums[i]<=mid:\\n                    c+=1\\n                    i+=1\\n                i+=1\\n            if c>=k:\\n                ans=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n        return ans\\n\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n\\n        low, high = min(nums), max(nums)\\n        while low <= high:\\n            mid = (low+high)//2\\n            i=0\\n            c=0\\n            while i < len(nums):\\n                if nums[i]<=mid:\\n                    c+=1\\n                    i+=1\\n                i+=1\\n            if c>=k:\\n                ans=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n        return ans\\n\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336921,
                "title": "super-easy-c-beats-90-binary-search-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(NlogN)\\n\\n- Space complexity: \\nO(N)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    vector<int> arr;\\n\\n    int check(int x,int k){\\n        int i=0,cnt=0;\\n        while(i<n){\\n            if(arr[i]<=x){\\n                cnt++;\\n                i+=2;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        arr = nums;\\n        n = arr.size();\\n        int l=*min_element(arr.begin(),arr.end()),h=*max_element(arr.begin(),arr.end()),ans;\\n\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n\\n            if(check(mid,k)){\\n                h = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    vector<int> arr;\\n\\n    int check(int x,int k){\\n        int i=0,cnt=0;\\n        while(i<n){\\n            if(arr[i]<=x){\\n                cnt++;\\n                i+=2;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        arr = nums;\\n        n = arr.size();\\n        int l=*min_element(arr.begin(),arr.end()),h=*max_element(arr.begin(),arr.end()),ans;\\n\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n\\n            if(check(mid,k)){\\n                h = mid-1;\\n                ans = mid;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289972,
                "title": "easy-to-understand-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>&v, int k) {\\n        int n=v.size();\\n        int lo=*min_element(v.begin(),v.end()),hi=*max_element(v.begin(),v.end());\\n        int md,ans=INT_MAX;\\n        while(hi>=lo){\\n            md=lo+(hi-lo)/2;\\n            int cnt=0,h=0;\\n            for(int i=0;i<n;i++){\\n                if(v[i]<=md){\\n                    if(i==0){\\n                        h=1;\\n                        cnt++;\\n                    }\\n                    else{\\n                        if(v[i-1]<=md){\\n                            if(h==0){\\n                                cnt++;\\n                                h=1;\\n                            }\\n                            else{\\n                                h=0;\\n                            }\\n                        }\\n                        else{\\n                            cnt++;\\n                            h=1;\\n                        }\\n                    }\\n                }\\n                else h=0;\\n            }\\n            if(cnt>=k){\\n                ans=min(ans,md);\\n                hi=md-1;\\n            }\\n            else lo=md+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>&v, int k) {\\n        int n=v.size();\\n        int lo=*min_element(v.begin(),v.end()),hi=*max_element(v.begin(),v.end());\\n        int md,ans=INT_MAX;\\n        while(hi>=lo){\\n            md=lo+(hi-lo)/2;\\n            int cnt=0,h=0;\\n            for(int i=0;i<n;i++){\\n                if(v[i]<=md){\\n                    if(i==0){\\n                        h=1;\\n                        cnt++;\\n                    }\\n                    else{\\n                        if(v[i-1]<=md){\\n                            if(h==0){\\n                                cnt++;\\n                                h=1;\\n                            }\\n                            else{\\n                                h=0;\\n                            }\\n                        }\\n                        else{\\n                            cnt++;\\n                            h=1;\\n                        }\\n                    }\\n                }\\n                else h=0;\\n            }\\n            if(cnt>=k){\\n                ans=min(ans,md);\\n                hi=md-1;\\n            }\\n            else lo=md+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279105,
                "title": "c-easy-solution-in-cpp-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&nums,int mid,int k)\\n    {\\n        int take=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mid>=nums[i])\\n            {\\n                take++;\\n                i++; //To avoid taking adjacent element\\n            }\\n        }\\n        return take>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int left=1;\\n        int right=INT_MAX;\\n        int ans;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isPossible(nums,mid,k))\\n            {\\n                ans=mid;\\n                right=mid-1;\\n            }\\n            else\\n                left=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&nums,int mid,int k)\\n    {\\n        int take=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mid>=nums[i])\\n            {\\n                take++;\\n                i++; //To avoid taking adjacent element\\n            }\\n        }\\n        return take>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int left=1;\\n        int right=INT_MAX;\\n        int ans;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isPossible(nums,mid,k))\\n            {\\n                ans=mid;\\n                right=mid-1;\\n            }\\n            else\\n                left=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254850,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ; //noRob, Rob\\nclass Solution {\\n    int n ;\\n    vector<PII>dp ;\\n    int k ;\\n    \\n    bool check(int& cap, vector<int>& nums){\\n        dp[0].first = 0 ;\\n        dp[0].second = (nums[0] <= cap) ;\\n        \\n        for(int i = 1; i < n; i++){\\n            if(nums[i] > cap){\\n                dp[i].first = max(dp[i-1].first, dp[i-1].second) ;\\n                dp[i].second = 0 ;\\n            }\\n            else{\\n                dp[i].first = max(dp[i-1].first, dp[i-1].second) ;\\n                dp[i].second = 1 + dp[i-1].first ;\\n            }\\n        }\\n\\n        return max(dp[n-1].first, dp[n-1].second) >= k ;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        n = nums.size() ;\\n        this->k = k ;\\n        dp.resize(n) ;\\n        int left = 1, right = *max_element(nums.begin(), nums.end()) ;\\n        while(left < right){\\n            int mid = left + (right-left)/2 ;\\n            if(check(mid, nums))\\n                right = mid ;\\n            else\\n                left = mid + 1 ;\\n        }\\n        return left ;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nusing PII = pair<int, int> ; //noRob, Rob\\nclass Solution {\\n    int n ;\\n    vector<PII>dp ;\\n    int k ;\\n    \\n    bool check(int& cap, vector<int>& nums){\\n        dp[0].first = 0 ;\\n        dp[0].second = (nums[0] <= cap) ;\\n        \\n        for(int i = 1; i < n; i++){\\n            if(nums[i] > cap){\\n                dp[i].first = max(dp[i-1].first, dp[i-1].second) ;\\n                dp[i].second = 0 ;\\n            }\\n            else{\\n                dp[i].first = max(dp[i-1].first, dp[i-1].second) ;\\n                dp[i].second = 1 + dp[i-1].first ;\\n            }\\n        }\\n\\n        return max(dp[n-1].first, dp[n-1].second) >= k ;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        n = nums.size() ;\\n        this->k = k ;\\n        dp.resize(n) ;\\n        int left = 1, right = *max_element(nums.begin(), nums.end()) ;\\n        while(left < right){\\n            int mid = left + (right-left)/2 ;\\n            if(check(mid, nums))\\n                right = mid ;\\n            else\\n                left = mid + 1 ;\\n        }\\n        return left ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254266,
                "title": "easy-commented-binary-search-invariant-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    //Predicate to test if it is possible to steal at least k houses with the max amount of money smaller than or equal to mx.\\n    \\n    bool predicate(vector<int>& nums,int k,int mx){\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            //if current house has money less than mx,pick it. because there is no max limit on the no. of houses we can steal. stealing extra houses won\\'t do any harm .But we won\\'t be able to pick the next one.\\n            \\n            if(nums[i]<=mx){\\n                \\n                //If picked current house:\\n                    //Count of Min Houses to rob will decrease by one.\\n                    k--;\\n\\n                    //Skipping the next house\\n                    i++;\\n            }\\n            //if k houses have been picked we return that it is possible\\n            if(k==0)return true;\\n        }\\n        \\n        //if we couldn\\'t pick k houses with max value smaller than or equal to k then it is  not possible to rob.\\n        return false;\\n    }\\n    \\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        //Using Invariant Binary Search \\n        \\n        int l=0,h=1e9+1;\\n        //Setting l & h to boundary of our search space that are not inclusive in the search space.\\n\\t\\t\\n        while(h-l>1){\\n            int mid=(h-l)/2+l;\\n            if(predicate(nums,k,mid))h=mid;\\n            else l=mid;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //Predicate to test if it is possible to steal at least k houses with the max amount of money smaller than or equal to mx.\\n    \\n    bool predicate(vector<int>& nums,int k,int mx){\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            //if current house has money less than mx,pick it. because there is no max limit on the no. of houses we can steal. stealing extra houses won\\'t do any harm .But we won\\'t be able to pick the next one.\\n            \\n            if(nums[i]<=mx){\\n                \\n                //If picked current house:\\n                    //Count of Min Houses to rob will decrease by one.\\n                    k--;\\n\\n                    //Skipping the next house\\n                    i++;\\n            }\\n            //if k houses have been picked we return that it is possible\\n            if(k==0)return true;\\n        }\\n        \\n        //if we couldn\\'t pick k houses with max value smaller than or equal to k then it is  not possible to rob.\\n        return false;\\n    }\\n    \\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        //Using Invariant Binary Search \\n        \\n        int l=0,h=1e9+1;\\n        //Setting l & h to boundary of our search space that are not inclusive in the search space.\\n\\t\\t\\n        while(h-l>1){\\n            int mid=(h-l)/2+l;\\n            if(predicate(nums,k,mid))h=mid;\\n            else l=mid;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252580,
                "title": "python-simple-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums, k):\\n        n = len(nums)\\n\\n        def check(c):\\n            total, i = 0, 0\\n\\n            while i < n:\\n                if nums[i] <= c:\\n                    total += 1\\n                    i += 2\\n                else:\\n                    i += 1\\n\\n            return total >= k\\n\\n\\n        low, high = min(nums), max(nums)\\n\\n        while low <= high:\\n            mid = (low + high)//2\\n\\n            if check(mid):\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n\\n        return low\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums, k):\\n        n = len(nums)\\n\\n        def check(c):\\n            total, i = 0, 0\\n\\n            while i < n:\\n                if nums[i] <= c:\\n                    total += 1\\n                    i += 2\\n                else:\\n                    i += 1\\n\\n            return total >= k\\n\\n\\n        low, high = min(nums), max(nums)\\n\\n        while low <= high:\\n            mid = (low + high)//2\\n\\n            if check(mid):\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n\\n        return low\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210090,
                "title": "short-c-dp-solution-tle",
                "content": "\\n# Code\\n```\\nint dp[2][100002];\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        for (int i = 0; i < k; ++i) {\\n            dp[i % 2][i] = dp[i % 2][i + 1] = INT_MAX;\\n            for (int j = i; j < nums.size(); ++j) \\n                dp[i % 2][j + 2] = min(max(nums[j], i == 0 ? 0 : dp[(i + 1) % 2][j]), dp[i % 2][j + 1]);\\n        }\\n        return dp[(k + 1) % 2][nums.size() + 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dp[2][100002];\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        for (int i = 0; i < k; ++i) {\\n            dp[i % 2][i] = dp[i % 2][i + 1] = INT_MAX;\\n            for (int j = i; j < nums.size(); ++j) \\n                dp[i % 2][j + 2] = min(max(nums[j], i == 0 ? 0 : dp[(i + 1) % 2][j]), dp[i % 2][j + 1]);\\n        }\\n        return dp[(k + 1) % 2][nums.size() + 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206991,
                "title": "2560-house-robber-iv",
                "content": "\\nApproach - \\n1. As, we need to find the minimum capability. So, DP or Binary Search or Shortest path algorithms comes into the mind. Graph clearly is not possible as their is no relationship between houses, If we use DP then it will be TLE. So, DP also seems not possible.\\n2. Now, Binary search is the only option. OK, we can do binary search between 0 to Integer.MAX_VALUE and their mid value will be the current capacity. But the question is, how to determine if mid is possible or not for robbing the houses.\\n3. Suppose houses are given like a, b, c, d, e, f, g, h. And for any mid value let it be val. a, c, d, f, g and h are less than or equal to val. As to have val as capability, we have to steal from houses with value less than val.\\n4. Now, group together the consecutive minimum values as shown below\\n```\\na       c, d          f, g, h\\n0       2  3          5  6  7\\nSo, from even length group we can have only length/2 houses at max. And for group of houses with odd length, we can have atmost 1 + length/2 houses.\\n```\\n5. So, we will count all these values for each mid or val. If count is less than k then we will return false otherwise true\\n\\nT.C is O(N*log(N)) and S.C is O(1)\\n\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int minVal = Integer.MAX_VALUE, low = 0, high = Integer.MAX_VALUE, mid;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            boolean flag = isPossible(nums, k, mid);\\n            // System.out.printf(\"flag:%b, mid:%d, \", flag, mid);\\n            if(flag){\\n                minVal = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }        \\n        return minVal;\\n    }\\n    \\n    private boolean isPossible(int[] nums, int k, int val){\\n        int count = 0, i = 0, j, len;\\n        while(i < nums.length){\\n            if(nums[i] <= val){\\n                j = i + 1;\\n                while(j < nums.length && nums[j] <= val) ++j;\\n                len = j - i;\\n                if(len%2 == 0) count += len/2;\\n                else count += 1 + len/2;\\n                i = j;\\n            }\\n            else{\\n                ++i;\\n            }\\n            \\n        }\\n        // System.out.printf(\"count:%d\\\\n\", count);\\n        if(count < k) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\na       c, d          f, g, h\\n0       2  3          5  6  7\\nSo, from even length group we can have only length/2 houses at max. And for group of houses with odd length, we can have atmost 1 + length/2 houses.\\n```\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int minVal = Integer.MAX_VALUE, low = 0, high = Integer.MAX_VALUE, mid;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            boolean flag = isPossible(nums, k, mid);\\n            // System.out.printf(\"flag:%b, mid:%d, \", flag, mid);\\n            if(flag){\\n                minVal = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }        \\n        return minVal;\\n    }\\n    \\n    private boolean isPossible(int[] nums, int k, int val){\\n        int count = 0, i = 0, j, len;\\n        while(i < nums.length){\\n            if(nums[i] <= val){\\n                j = i + 1;\\n                while(j < nums.length && nums[j] <= val) ++j;\\n                len = j - i;\\n                if(len%2 == 0) count += len/2;\\n                else count += 1 + len/2;\\n                i = j;\\n            }\\n            else{\\n                ++i;\\n            }\\n            \\n        }\\n        // System.out.printf(\"count:%d\\\\n\", count);\\n        if(count < k) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199019,
                "title": "java-solution-dp-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        if(nums.length == 1 && k == 1){\\n            return nums[0];\\n        }\\n        int left = 0;\\n        int right = Integer.MAX_VALUE;\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(findAtLeastK(mid, nums, k)){\\n                right = mid;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    public boolean findAtLeastK(int cap, int[] nums, int k){\\n        int n = nums.length;\\n        //[][] dp = new int[n + 1][2];\\n        int prev1 = 0;\\n        int prev2 = nums[0] <= cap ? 1 : Integer.MIN_VALUE;\\n        int tmp1 = 0;\\n        int tmp2 = 0;\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] > cap){\\n                tmp1 = Math.max(prev1, prev2);\\n                tmp2 = Integer.MIN_VALUE;\\n                prev1 = tmp1;\\n                prev2 = tmp2;\\n            }\\n            else{\\n                tmp1 = Math.max(prev1, prev2);\\n                tmp2 = prev1 + 1;\\n                prev1 = tmp1;\\n                prev2 = tmp2;\\n            }\\n        }\\n        return Math.max(tmp1, tmp2) >= k ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        if(nums.length == 1 && k == 1){\\n            return nums[0];\\n        }\\n        int left = 0;\\n        int right = Integer.MAX_VALUE;\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(findAtLeastK(mid, nums, k)){\\n                right = mid;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    public boolean findAtLeastK(int cap, int[] nums, int k){\\n        int n = nums.length;\\n        //[][] dp = new int[n + 1][2];\\n        int prev1 = 0;\\n        int prev2 = nums[0] <= cap ? 1 : Integer.MIN_VALUE;\\n        int tmp1 = 0;\\n        int tmp2 = 0;\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] > cap){\\n                tmp1 = Math.max(prev1, prev2);\\n                tmp2 = Integer.MIN_VALUE;\\n                prev1 = tmp1;\\n                prev2 = tmp2;\\n            }\\n            else{\\n                tmp1 = Math.max(prev1, prev2);\\n                tmp2 = prev1 + 1;\\n                prev1 = tmp1;\\n                prev2 = tmp2;\\n            }\\n        }\\n        return Math.max(tmp1, tmp2) >= k ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198916,
                "title": "binary-search-with-tc-sc-well-commented-explained",
                "content": "\\n# Approach\\n    1. Start from 1 till 1e9(max limit of nums[i]), Note: this is mid in Binary Search\\n    2. For particular value of mid, find whether it can one of the answers (handled in isPossible)\\n    3. In isPossible Fn, any mid can be a answer if it satisfies these conditions\\n        a. minimum k counts\\n        b. all other elements less than mid (as it will be max in particular group)\\n        c. all chosen must not be consecutive (as per question)\\n\\n# Complexity\\n- Time complexity:\\n$$O(logV*n)$$ , *V= 1e9, n = length of nums*\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int mid,vector<int>& nums, int k){\\n        int count = 0, prevIdx = -2;\\n        /*\\n            1.mid is the Ans for current group, so all others MUST be smaller than mid\\n            2.First Find the first index Where nums[index] <= mid is Found , As it will definately be a part\\n              of our group ,Not chosing it will make things worse eg: [1,1,1] mid = 3 chosing second one \\n              causes 3rd one to be Lost apart from the first One But we want to make k counts\\n        */\\n\\n\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] > mid){\\n                continue;\\n            }\\n            if((i-prevIdx) > 1){\\n                count++;\\n                prevIdx = i;\\n            }\\n                \\n            \\n        }\\n\\n        return count >= k;\\n\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int low = 1, high = 1e9+1,ans = 0;\\n\\n        while(low <= high){\\n            int mid = (low+high)/2;\\n            if(isPossible(mid,nums,k)){\\n                //since want min , try for more smaller ans\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int mid,vector<int>& nums, int k){\\n        int count = 0, prevIdx = -2;\\n        /*\\n            1.mid is the Ans for current group, so all others MUST be smaller than mid\\n            2.First Find the first index Where nums[index] <= mid is Found , As it will definately be a part\\n              of our group ,Not chosing it will make things worse eg: [1,1,1] mid = 3 chosing second one \\n              causes 3rd one to be Lost apart from the first One But we want to make k counts\\n        */\\n\\n\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] > mid){\\n                continue;\\n            }\\n            if((i-prevIdx) > 1){\\n                count++;\\n                prevIdx = i;\\n            }\\n                \\n            \\n        }\\n\\n        return count >= k;\\n\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int low = 1, high = 1e9+1,ans = 0;\\n\\n        while(low <= high){\\n            int mid = (low+high)/2;\\n            if(isPossible(mid,nums,k)){\\n                //since want min , try for more smaller ans\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186503,
                "title": "1sentence-bisect-with-a-check-max-rob-bool-function-which-greedily-robs-houses-up-to-max-rob",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        def check(val, k):\\n            last = 0    # previous elemnt in the array was not used\\n            for home in nums:\\n                if not last and home <= val:\\n                    k -= 1\\n                    if k == 0:\\n                        return True\\n                    last = 1   # used\\n                else:\\n                    last = 0   # not useed\\n            return False\\n        lo, hi = 0, max(nums)\\n        while lo != hi and lo + 1 != hi:\\n            cur = (lo + hi) // 2\\n            if check(cur, k):\\n                hi = cur\\n            else:\\n                lo = cur\\n        return hi\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        def check(val, k):\\n            last = 0    # previous elemnt in the array was not used\\n            for home in nums:\\n                if not last and home <= val:\\n                    k -= 1\\n                    if k == 0:\\n                        return True\\n                    last = 1   # used\\n                else:\\n                    last = 0   # not useed\\n            return False\\n        lo, hi = 0, max(nums)\\n        while lo != hi and lo + 1 != hi:\\n            cur = (lo + hi) // 2\\n            if check(cur, k):\\n                hi = cur\\n            else:\\n                lo = cur\\n        return hi\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183283,
                "title": "c-solution-using-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int size = nums.size();\\n        int left = 1, right = 1e9;\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            int flag = 0;\\n            for(int i = 0; i < size; ++i){\\n                if(nums[i] <= mid){\\n                    flag += 1;\\n                    i++;\\n                }\\n            }\\n            if(flag >= k) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int size = nums.size();\\n        int left = 1, right = 1e9;\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            int flag = 0;\\n            for(int i = 0; i < size; ++i){\\n                if(nums[i] <= mid){\\n                    flag += 1;\\n                    i++;\\n                }\\n            }\\n            if(flag >= k) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175515,
                "title": "fundamental-approach-binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums, int mid, int k) {\\n        int i = 0;\\n        while(i < nums.size()) {\\n            if(nums[i] <= mid) {\\n                i += 2;\\n                k--;\\n            }\\n            else\\n                i++;\\n            if(k == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int out = INT_MAX;\\n        int l = 1;\\n        int r = 1e9;\\n        while(l <= r) {\\n            int mid = l+(r-l)/2;\\n            if(check(nums, mid, k)) {\\n                out = min(out, mid);\\n                r = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: YouTube Channel (DeepCodes)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums, int mid, int k) {\\n        int i = 0;\\n        while(i < nums.size()) {\\n            if(nums[i] <= mid) {\\n                i += 2;\\n                k--;\\n            }\\n            else\\n                i++;\\n            if(k == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int out = INT_MAX;\\n        int l = 1;\\n        int r = 1e9;\\n        while(l <= r) {\\n            int mid = l+(r-l)/2;\\n            if(check(nums, mid, k)) {\\n                out = min(out, mid);\\n                r = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: YouTube Channel (DeepCodes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174887,
                "title": "easy-c-solution",
                "content": "# Intuition\\n\\nUsing Binary Search\\n\\n\\n# Code\\n```\\n\\n                              \\nclass Solution {\\npublic:\\n    \\n    bool f(int n, vector<int>& nums, int k)\\n    {\\n        int temp = 0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i] <= n && temp == 0)\\n            {\\n                k--;\\n                temp = 1;\\n                if(k == 0) return true;\\n            }\\n            else\\n            {\\n                temp = 0;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minCapability(vector<int>& nums, int k) {\\n        int ans = 0, temp = 0;\\n        vector<int> v;\\n        for(auto &c: nums) v.push_back(c);\\n        sort(v.begin(), v.end());\\n        int l = k-1, r = v.size()-1, m;\\n        while(l <= r)\\n        {\\n            m = (l+r)/2;\\n            if(f(v[m], nums, k)) r = m-1;\\n            else l = m+1;\\n        }\\n        return v[l];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n\\n                              \\nclass Solution {\\npublic:\\n    \\n    bool f(int n, vector<int>& nums, int k)\\n    {\\n        int temp = 0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i] <= n && temp == 0)\\n            {\\n                k--;\\n                temp = 1;\\n                if(k == 0) return true;\\n            }\\n            else\\n            {\\n                temp = 0;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minCapability(vector<int>& nums, int k) {\\n        int ans = 0, temp = 0;\\n        vector<int> v;\\n        for(auto &c: nums) v.push_back(c);\\n        sort(v.begin(), v.end());\\n        int l = k-1, r = v.size()-1, m;\\n        while(l <= r)\\n        {\\n            m = (l+r)/2;\\n            if(f(v[m], nums, k)) r = m-1;\\n            else l = m+1;\\n        }\\n        return v[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173541,
                "title": "swift-binary-search",
                "content": "**Binary Search (accepted answer)**\\n```\\nclass Solution {\\n    func minCapability(_ nums: [Int], _ k: Int) -> Int {\\n        var (lower, upper) = (nums.min()!, nums.max()!)\\n        while lower < upper {\\n            let mid = (lower + upper) / 2\\n            var housesRobbed = 0, lastRobbedHouse = -2\\n            for i in nums.indices where nums[i] <= mid && i-lastRobbedHouse > 1 {\\n                housesRobbed += 1\\n                guard housesRobbed < k else { break }                \\n                lastRobbedHouse = i \\n            }\\n            (lower, upper) = housesRobbed == k ? (lower, mid) : (mid+1, upper)\\n        }\\n        return lower\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minCapability(_ nums: [Int], _ k: Int) -> Int {\\n        var (lower, upper) = (nums.min()!, nums.max()!)\\n        while lower < upper {\\n            let mid = (lower + upper) / 2\\n            var housesRobbed = 0, lastRobbedHouse = -2\\n            for i in nums.indices where nums[i] <= mid && i-lastRobbedHouse > 1 {\\n                housesRobbed += 1\\n                guard housesRobbed < k else { break }                \\n                lastRobbedHouse = i \\n            }\\n            (lower, upper) = housesRobbed == k ? (lower, mid) : (mid+1, upper)\\n        }\\n        return lower\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171164,
                "title": "easy-java-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<NLog(N)>\\n\\n- Space complexity:\\n<O(1)>\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        \\n        long l=1,r=Integer.MAX_VALUE;\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            long mid=(l+r)/2;\\n            \\n            if(solve(nums,mid,k))\\n            {\\n                ans=(int)mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public boolean solve(int nums[],long mid,int k)\\n    {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<=mid)\\n            {\\n                k--;\\n                i++;\\n            }\\n        }\\n        \\n        if(k<=0)\\n            return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        \\n        long l=1,r=Integer.MAX_VALUE;\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            long mid=(l+r)/2;\\n            \\n            if(solve(nums,mid,k))\\n            {\\n                ans=(int)mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public boolean solve(int nums[],long mid,int k)\\n    {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<=mid)\\n            {\\n                k--;\\n                i++;\\n            }\\n        }\\n        \\n        if(k<=0)\\n            return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167829,
                "title": "antarnab-100-faster-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool calc(vector<int>& nums, int k,int mid)\\n    {\\n        int i=0,n=nums.size();\\n        while(i<n)\\n        {\\n            if(nums[i]<=mid)k--, i+=2;\\n            \\n            else i++;\\n            \\n            if(k == 0) return true;\\n        }\\n        return k == 0;\\n    }\\n    int minCapability(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        int lo = 0,hi = 1e9+1;\\n        while(lo<hi)\\n        {\\n            int mid = (lo+hi)/2;\\n            if(calc(nums, k, mid)) hi=mid;\\n            else lo=mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool calc(vector<int>& nums, int k,int mid)\\n    {\\n        int i=0,n=nums.size();\\n        while(i<n)\\n        {\\n            if(nums[i]<=mid)k--, i+=2;\\n            \\n            else i++;\\n            \\n            if(k == 0) return true;\\n        }\\n        return k == 0;\\n    }\\n    int minCapability(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        int lo = 0,hi = 1e9+1;\\n        while(lo<hi)\\n        {\\n            int mid = (lo+hi)/2;\\n            if(calc(nums, k, mid)) hi=mid;\\n            else lo=mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166424,
                "title": "rust-binary-search-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn min_capability(nums: Vec<i32>, k: i32) -> i32 {\\n        let (mut l, mut r) = (1, 1e9 as i32);\\n\\n        while l < r {\\n            let mid = l + (r - l) / 2;\\n\\n            if Self::is_valid(&nums, k, mid) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        l\\n    }\\n\\n    fn is_valid(nums: &Vec<i32>, k: i32, capacity: i32) -> bool {\\n        let mut rob = 0;\\n        let mut i = 0;\\n\\n        while i < nums.len() {\\n            if nums[i] <= capacity {\\n                rob += 1;\\n                i += 1;\\n            }\\n\\n            i += 1;\\n        }\\n\\n        rob >= k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_capability(nums: Vec<i32>, k: i32) -> i32 {\\n        let (mut l, mut r) = (1, 1e9 as i32);\\n\\n        while l < r {\\n            let mid = l + (r - l) / 2;\\n\\n            if Self::is_valid(&nums, k, mid) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        l\\n    }\\n\\n    fn is_valid(nums: &Vec<i32>, k: i32, capacity: i32) -> bool {\\n        let mut rob = 0;\\n        let mut i = 0;\\n\\n        while i < nums.len() {\\n            if nums[i] <= capacity {\\n                rob += 1;\\n                i += 1;\\n            }\\n\\n            i += 1;\\n        }\\n\\n        rob >= k\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164815,
                "title": "binary-search-on-answer-solution-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question pattern is like find Min of Max So binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n/*-------------------------------------Understanding Question----------------------------------*/\\n\\n     1. given nums[] where nums[i] = amount in each house\\n     2. The robber refuses to steal from adjacent homes.\\n     2. capability  -  maximum amount of money he steals from *one* house of all the houses he robbed.\\n     3. k -  steals from at least k houses.\\n     4. Find minimum capability of the robber out of all the possible ways to steal at least k houses.\\n     5. This qstns asks min capability(max amt from one house) - Min Max Problem => Binary Search can be used\\n    \\n/*-------------------------Determining a good and bad pointer---------------------------------*/\\n\\n     1. Think can 0 be the min capablilty?\\n     2. No bcoz nums[i]>0 from constraints given\\n     3. Can it be 1 , maybe\\n     4. What can be the max capability ? any value like  >= sum(nums) \\n     5. So 0 cannot be min - not good, others are good \\n     6. So l = 0 bad, r = sum(nums) - good are the pointers\\n     \\n/*-------------------------------Decision to move the pointers----------------------------------*/\\n\\n      1.  Pattern : FFFTTT, bcoz its minimum maximum, that min cannot be less than some value so left side FFF, and if some X is the min capablilty then anything above will be good so right side TTTT.\\n      2. and since the queestion asks for the minimum we need to find the first \\'T\\' which satisfies below condition.\\n      3. So if i find some T which is good i move to the left region to find the first T which will be pointed by r \\n\\n/*-----------------------------------Good Function----------------------------------------------*/\\n\\n    1. Question asks for min capability.\\n    2. Change it like : Given some capability(max money from one house he can steal)  : mid, can he rob atleast k houses refusing to steal from adj houses. \\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define  ll long long \\nclass Solution {\\npublic:\\n    \\n    \\n    bool good(vector<int> &nums, int k, int maxAmt){\\n        \\n        int cnt = 0;\\n        int i=0;\\n        \\n        //for each house\\n        while(i<nums.size()){\\n            \\n            //capability  -  maximum amount of money he steals from *one* house of all the houses he robbed.\\n            if(nums[i] <= maxAmt){ //if he steals\\n                cnt++; //count\\n                i+=2; //i+=2 bcoz he cannot rob adjacent\\n            }else{\\n                i++; //if he cant steal move to next house\\n            }\\n        }\\n        \\n        //return wether he is able to steal atleast k houses given some limit mid\\n        return cnt >= k;\\n    }\\n    \\n    int minCapability(vector<int>& nums, int k) {\\n        ll l = 0; //bad\\n        ll r = accumulate(nums.begin(),nums.end(),0LL); //good-maybe\\n        \\n        while(r > l+1){\\n            ll m = (l+r)/2;\\n            if(good(nums,k,m)) \\n                r = m; //move left\\n            else\\n                l = m; //move right\\n            \\n        }\\n        \\n        return r;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define  ll long long \\nclass Solution {\\npublic:\\n    \\n    \\n    bool good(vector<int> &nums, int k, int maxAmt){\\n        \\n        int cnt = 0;\\n        int i=0;\\n        \\n        //for each house\\n        while(i<nums.size()){\\n            \\n            //capability  -  maximum amount of money he steals from *one* house of all the houses he robbed.\\n            if(nums[i] <= maxAmt){ //if he steals\\n                cnt++; //count\\n                i+=2; //i+=2 bcoz he cannot rob adjacent\\n            }else{\\n                i++; //if he cant steal move to next house\\n            }\\n        }\\n        \\n        //return wether he is able to steal atleast k houses given some limit mid\\n        return cnt >= k;\\n    }\\n    \\n    int minCapability(vector<int>& nums, int k) {\\n        ll l = 0; //bad\\n        ll r = accumulate(nums.begin(),nums.end(),0LL); //good-maybe\\n        \\n        while(r > l+1){\\n            ll m = (l+r)/2;\\n            if(good(nums,k,m)) \\n                r = m; //move left\\n            else\\n                l = m; //move right\\n            \\n        }\\n        \\n        return r;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162878,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * log(max_num - min_num + 1))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n *       `max_num` is the maximum number in the vector `nums`\\n *       `min_num` is the minimum number in the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minCapability(const vector<int> &nums, const int k) {\\n    constexpr int range = 3;\\n    const int n = static_cast<int>(nums.size());\\n    if (n == 1) {\\n      return nums.front();\\n    }\\n    \\n    int min_num = numeric_limits<int>::max();\\n    int max_num = numeric_limits<int>::min();\\n    for (const int num : nums) {\\n      min_num = min(min_num, num);\\n      max_num = max(max_num, num);\\n    }\\n    \\n    int low = min_num;\\n    int high = max_num + 1;\\n    while (low < high) {\\n      const int mid = low + (high - low) / 2;\\n      \\n      int dp[range]{};\\n      int first = 0;\\n      int second = 1;\\n      int third = 2;\\n      for (const int num : nums) {\\n        if (num > mid) {\\n          dp[third] = dp[second];\\n        } else {\\n          dp[third] = max(dp[second], 1 + dp[first]);\\n        }\\n        \\n        first = second;\\n        second = third;\\n        third = (third + 1) % range;\\n      }\\n      if (dp[second] >= k) {\\n        high = mid;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n    return high;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(max_num - min_num + 1))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n *       `max_num` is the maximum number in the vector `nums`\\n *       `min_num` is the minimum number in the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minCapability(const vector<int> &nums, const int k) {\\n    constexpr int range = 3;\\n    const int n = static_cast<int>(nums.size());\\n    if (n == 1) {\\n      return nums.front();\\n    }\\n    \\n    int min_num = numeric_limits<int>::max();\\n    int max_num = numeric_limits<int>::min();\\n    for (const int num : nums) {\\n      min_num = min(min_num, num);\\n      max_num = max(max_num, num);\\n    }\\n    \\n    int low = min_num;\\n    int high = max_num + 1;\\n    while (low < high) {\\n      const int mid = low + (high - low) / 2;\\n      \\n      int dp[range]{};\\n      int first = 0;\\n      int second = 1;\\n      int third = 2;\\n      for (const int num : nums) {\\n        if (num > mid) {\\n          dp[third] = dp[second];\\n        } else {\\n          dp[third] = max(dp[second], 1 + dp[first]);\\n        }\\n        \\n        first = second;\\n        second = third;\\n        third = (third + 1) % range;\\n      }\\n      if (dp[second] >= k) {\\n        high = mid;\\n      } else {\\n        low = mid + 1;\\n      }\\n    }\\n    return high;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160669,
                "title": "binary-search-c-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& v, int k) {\\n        int l=0,r=1e9;\\n        int ans=0;\\n        while(l<=r) {\\n            int md=(l+r)/2;\\n            bool f=true;\\n            int c=0;\\n            for(int i=0; i<v.size(); i++) {\\n                if(v[i]<=md) c++,i++;\\n            }\\n            if(c>=k) ans=md,r=md-1;\\n            else l=md+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& v, int k) {\\n        int l=0,r=1e9;\\n        int ans=0;\\n        while(l<=r) {\\n            int md=(l+r)/2;\\n            bool f=true;\\n            int c=0;\\n            for(int i=0; i<v.size(); i++) {\\n                if(v[i]<=md) c++,i++;\\n            }\\n            if(c>=k) ans=md,r=md-1;\\n            else l=md+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160656,
                "title": "binary-search-solution",
                "content": "Time complexity: `O(nlogn)`\\nSpace complexity: `O(1)`\\n```\\nclass Solution {\\n    func minCapability(_ nums: [Int], _ k: Int) -> Int {\\n        let n = nums.count\\n        \\n        func check(_ val: Int) -> Bool {\\n            var count = 0\\n            var i = 0\\n            while i < n {\\n                if nums[i] <= val {\\n                    count += 1\\n                    i += 1\\n                }\\n                i += 1\\n                if count >= k { return true }\\n            }\\n            return false\\n        }\\n        \\n        var left = nums.min()!\\n        var right = nums.max()!\\n        var ans = left\\n        while left <= right {\\n            let mid = left + (right - left) / 2\\n            if check(mid) {\\n                ans = mid\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    func minCapability(_ nums: [Int], _ k: Int) -> Int {\\n        let n = nums.count\\n        \\n        func check(_ val: Int) -> Bool {\\n            var count = 0\\n            var i = 0\\n            while i < n {\\n                if nums[i] <= val {\\n                    count += 1\\n                    i += 1\\n                }\\n                i += 1\\n                if count >= k { return true }\\n            }\\n            return false\\n        }\\n        \\n        var left = nums.min()!\\n        var right = nums.max()!\\n        var ans = left\\n        while left <= right {\\n            let mid = left + (right - left) / 2\\n            if check(mid) {\\n                ans = mid\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160500,
                "title": "c-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool poss(vector<int>&nums,int mid,int k){\\n    int n=nums.size();\\n    int j=0;\\n    while(j<n){\\n\\n        if(nums[j]<=mid){\\n            j=j+2;//to not add adjacent elements\\n            k--;\\n        }\\n        else{\\n            j++;\\n        }\\n\\n        if(k==0) return true;\\n    }\\n\\n    return false;\\n}\\n    int minCapability(vector<int>& nums, int k) {\\n        int res=INT_MAX;\\n\\n        int low=0;\\n        int high=*max_element(nums.begin(),nums.end());\\n\\n        while(low<=high){\\n\\n            int mid=low+(high-low)/2;\\n\\n            if(poss(nums,mid,k)){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool poss(vector<int>&nums,int mid,int k){\\n    int n=nums.size();\\n    int j=0;\\n    while(j<n){\\n\\n        if(nums[j]<=mid){\\n            j=j+2;//to not add adjacent elements\\n            k--;\\n        }\\n        else{\\n            j++;\\n        }\\n\\n        if(k==0) return true;\\n    }\\n\\n    return false;\\n}\\n    int minCapability(vector<int>& nums, int k) {\\n        int res=INT_MAX;\\n\\n        int low=0;\\n        int high=*max_element(nums.begin(),nums.end());\\n\\n        while(low<=high){\\n\\n            int mid=low+(high-low)/2;\\n\\n            if(poss(nums,mid,k)){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158643,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) \\n    {\\n        int left=1,right=(int)1e9,mid,n=nums.size();\\n        while(left<right)\\n        {\\n            mid=left+(right-left)/2;\\n            int take=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]<=mid)\\n                {\\n                    take++;\\n                    i++;\\n                }\\n            }\\n            if(take>=k)\\n            {\\n                right=mid;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) \\n    {\\n        int left=1,right=(int)1e9,mid,n=nums.size();\\n        while(left<right)\\n        {\\n            mid=left+(right-left)/2;\\n            int take=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]<=mid)\\n                {\\n                    take++;\\n                    i++;\\n                }\\n            }\\n            if(take>=k)\\n            {\\n                right=mid;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158593,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search \\n\\n# Complexity\\n- Time complexity: n log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>&vec,int k ,long long  mid) {\\n            int n = vec.size();\\n            int i = 0 ;\\n            while(i < n) {\\n                    \\n                    if(vec[i] <= mid) {\\n                            k--;\\n                            i+=2;\\n                    }\\n                    else{\\n                            i++;\\n                    }\\n                    \\n                    if(k == 0) {\\n                            return true ;\\n                    }\\n            }\\n            return k == 0;\\n    }\\n  \\n    int minCapability(vector<int>& vec, int k) {\\n        \\n        int n = vec.size() ;\\n          int   ans = 1e9;\\n        int left = 1;\\n          int high= ans;\\n            while(left<=high) {\\n                    int  mid = left +( high-left)/2 ;\\n                    \\n                    if(find(vec,k,mid)) {\\n                            \\n                            ans = min(ans,mid) ;\\n                            high = mid-1;\\n                    }\\n                    else{\\n                            left = mid+1;\\n                    }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&vec,int k ,long long  mid) {\\n            int n = vec.size();\\n            int i = 0 ;\\n            while(i < n) {\\n                    \\n                    if(vec[i] <= mid) {\\n                            k--;\\n                            i+=2;\\n                    }\\n                    else{\\n                            i++;\\n                    }\\n                    \\n                    if(k == 0) {\\n                            return true ;\\n                    }\\n            }\\n            return k == 0;\\n    }\\n  \\n    int minCapability(vector<int>& vec, int k) {\\n        \\n        int n = vec.size() ;\\n          int   ans = 1e9;\\n        int left = 1;\\n          int high= ans;\\n            while(left<=high) {\\n                    int  mid = left +( high-left)/2 ;\\n                    \\n                    if(find(vec,k,mid)) {\\n                            \\n                            ans = min(ans,mid) ;\\n                            high = mid-1;\\n                    }\\n                    else{\\n                            left = mid+1;\\n                    }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158488,
                "title": "c-binary-search-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool ispossible(int &mid, int &k, int &n, vector<int> &nums){\\n        int prevposs=-1,total=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<=mid){\\n                if(prevposs==-1 or prevposs!=(i-1)){\\n                    total++;\\n                    prevposs=i;\\n                }\\n            }\\n        }\\n        return (total>=k);\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int &k) {\\n        int lo=INT_MAX,hi=INT_MIN,mid,ans,n=nums.size();\\n        for(int &ele:nums){\\n            lo=min(lo,ele);\\n            hi=max(hi,ele);\\n        }\\n        while(lo<=hi){\\n            mid=(hi+lo)/2;\\n            if(ispossible(mid,k,n,nums)){\\n                ans=mid;\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool ispossible(int &mid, int &k, int &n, vector<int> &nums){\\n        int prevposs=-1,total=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<=mid){\\n                if(prevposs==-1 or prevposs!=(i-1)){\\n                    total++;\\n                    prevposs=i;\\n                }\\n            }\\n        }\\n        return (total>=k);\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int &k) {\\n        int lo=INT_MAX,hi=INT_MIN,mid,ans,n=nums.size();\\n        for(int &ele:nums){\\n            lo=min(lo,ele);\\n            hi=max(hi,ele);\\n        }\\n        while(lo<=hi){\\n            mid=(hi+lo)/2;\\n            if(ispossible(mid,k,n,nums)){\\n                ans=mid;\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158334,
                "title": "golang-bin-search",
                "content": "```\\nfunc minCapability(nums []int, k int) int {\\n\\tl, r := 0, 0\\n\\tfor i := range nums { r += nums[i] }\\n\\ta := 1 << 32\\n\\tch := func(b int) bool {\\n\\t\\tcc, c := 0.0, 0\\n\\t\\tfor i := range nums {\\n\\t\\t\\tif nums[i] <= b {\\n\\t\\t\\t\\tcc++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc += int(math.Ceil(cc / 2.0))\\n\\t\\t\\t\\tcc = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif cc != 0 { c += int(math.Ceil(cc / 2.0)) }\\n\\t\\treturn c >= k\\n\\t}\\n\\tfor l <= r {\\n\\t\\tm := (l + r) / 2\\n\\t\\tif ch(m) {\\n\\t\\t\\tif m < a { a = m }\\n\\t\\t\\tr = m - 1\\n\\t\\t} else {\\n\\t\\t\\tl = m + 1\\n\\t\\t}\\n\\t}\\n\\treturn a\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minCapability(nums []int, k int) int {\\n\\tl, r := 0, 0\\n\\tfor i := range nums { r += nums[i] }\\n\\ta := 1 << 32\\n\\tch := func(b int) bool {\\n\\t\\tcc, c := 0.0, 0\\n\\t\\tfor i := range nums {\\n\\t\\t\\tif nums[i] <= b {\\n\\t\\t\\t\\tcc++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc += int(math.Ceil(cc / 2.0))\\n\\t\\t\\t\\tcc = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif cc != 0 { c += int(math.Ceil(cc / 2.0)) }\\n\\t\\treturn c >= k\\n\\t}\\n\\tfor l <= r {\\n\\t\\tm := (l + r) / 2\\n\\t\\tif ch(m) {\\n\\t\\t\\tif m < a { a = m }\\n\\t\\t\\tr = m - 1\\n\\t\\t} else {\\n\\t\\t\\tl = m + 1\\n\\t\\t}\\n\\t}\\n\\treturn a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3157659,
                "title": "o-nlogm-time-o-1-space",
                "content": "# Definitions\\n$$n$$ = The length of $$nums$$\\n$$m$$ = The range of $$nums$$\\n\\n# Intuition\\nSince we are trying to find the minimum, maximum of the range of $$k$$ houses, we should binary search the input over the range of it\\'s min to max. You could set min as 1 and max as $$10^9$$ per the constraints, however, I preferred to go ahead and calc the left/right boundaries as min/max of my range since it didn\\'t mess with the time complexity and for a lot of basic cases, it removes extra operations of reducing the max element over and over until you eventually get to a reasonable left/right boundary.\\n\\n# Approach\\n1. Get min/max as left/right\\n2. If $$k$$ = 1, you are done and can just return $$left$$\\n3. Using $$mid$$, repeatedly identify whether you were able to \"take\" from at least $$k$$ houses. If you were able to, then we should try reducing $$right$$ to find a smaller $$mid$$. Otherwise, increase $$left$$ to provide a larger maximum that we can use to take so that we can take from at least $$k$$ houses.\\n4. Eventually, you will be left with the minimum amount you needed to take in order to take from $$k$$ houses, which also happens to be the maximum amount you could take if you were to steal the minimum possible from at least $$k$$ houses.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogm)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinCapability(int[] nums, int k) {\\n        int n = nums.Length;\\n        if (n == 0) {\\n            return 0;\\n        }\\n\\n        int left = Int32.MaxValue;\\n        int right = Int32.MinValue;\\n\\n        foreach (int num in nums) {\\n            left = Math.Min(left, num);\\n            right = Math.Max(right, num);\\n        }\\n\\n        if (k == 1) {\\n            return left;\\n        }\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int take = 0;\\n\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] <= mid) {\\n                    take += 1;\\n                    i++;\\n                }\\n            }\\n\\n            if (take >= k) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        //At this point, left and right are equal\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinCapability(int[] nums, int k) {\\n        int n = nums.Length;\\n        if (n == 0) {\\n            return 0;\\n        }\\n\\n        int left = Int32.MaxValue;\\n        int right = Int32.MinValue;\\n\\n        foreach (int num in nums) {\\n            left = Math.Min(left, num);\\n            right = Math.Max(right, num);\\n        }\\n\\n        if (k == 1) {\\n            return left;\\n        }\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int take = 0;\\n\\n            for (int i = 0; i < n; i++) {\\n                if (nums[i] <= mid) {\\n                    take += 1;\\n                    i++;\\n                }\\n            }\\n\\n            if (take >= k) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        //At this point, left and right are equal\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157588,
                "title": "c-binary-search-easy-array-approach",
                "content": "# Clear Code\\n```C++\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        vector<int> A = nums;\\n\\t\\tsort(A.begin(), A.end());\\n        nums.push_back(INT_MAX);\\n        int n = nums.size();\\n        \\n        function<int(int)> kcnt =  [&](int v) {\\n            int cnt = 0, L = 0;\\n            for(int R = 0;R<n;R++) {\\n                if(nums[R] > v) {\\n                    cnt+=(R-L+1)/2;\\n                    L=R+1;\\n                }\\n            }\\n            return cnt;\\n        };\\n\\t\\t\\n        int L = 0, R=A.size()-1;\\n        vector<int> cnt = vector<int>(A.size(),-1);\\n        while(L<=R) {\\n            int M = L+(R-L)/2;            \\n            if( (M-1<0 || kcnt(A[M-1])<k) && kcnt(A[M]) == k ) \\n                return A[M];\\n            if(kcnt(A[M]) >= k) \\n                R=M-1;\\n            else \\n                L=M+1;\\n        }\\n        return -1;      \\n    }\\n};\\n```\\n\\n# Easy Idea and Explanation\\n## Binary Search O(log(N))\\nWe have O(log(N)) time to guess which is answer by binary search. \\nAnd then we need to have a O(N) function the check the guessing value \\nis the answer or not.\\n\\nThe code related to binary search part is Easy problem here.\\nhttps://leetcode.com/problems/first-bad-version/\\nI assume you pratice this Easy problem before, \\nso you can understand the part of binary search. \\nIf you still cannot understand, please feel free to ask. \\n\\n## Use O(N) to check guessing\\nWe use this example `nums=[2,7,9,3,1,5], k = 3` to explain. \\n\\nIf you guess `3` as your answer, then you must not to select any value > 3 in nums.\\nThen the nums `[2,7,9,3,1,5]` should be look at like \\n`[2,7,9,3,1,5]` -> `[2,x,x,3,1,x]`  -> `[2] [3,1]` \\nThe `[2]` can contribute the most counting up value 1 for k. \\nThe `[3,1]` can contribute the most counting up value 1 for k. \\nSo we say kcnt(3) = 2. \\n\\nIf we guess `7`. \\n`[2,7,9,3,1,5]` -> `[2,7,x,3,1,5]` -> `[2,7]  [3,1,5]`\\nThe `[2,7]` can contribute the most counting up value 1 for k. \\nThe `[3,1,5]` can contribute the most counting up value 2 for k. \\nSo we say kcnt(7) = 3\\n\\nIf we guess all the elements 1,2,3,5,7,9. Then it will like the following\\nguess `1`  -> `[2,7,9,3,1,5]` -> `[x,x,x,x,1,x]` -> `[1]` -> kcnt(1) = 1\\nguess `2` -> `[2,7,9,3,1,5]` -> `[2,x,x,x,1,x]` -> `[2] [1]` -> kcnt(2) = 2\\nguess `3` -> `[2,7,9,3,1,5]` -> `[2,x,x,3,1,x]` -> `[2] [3,1]` -> kcnt(3) = 2\\nguess `5` -> `[2,7,9,3,1,5]` -> `[2,x,x,3,1,5]` -> `[2] [3,1,5]` -> kcnt(5) = 3\\nguess `7` -> `[2,7,9,3,1,5]` -> `[2,7,x,3,1,5]` -> `[2,7] [3,1,5]` -> kcnt(7) = 3\\nguess `9` -> `[2,7,9,3,1,5]` -> `[2,7,9,3,1,5]` -> `[2,7,9,3,1,5]` -> kcnt(9) = 3\\n\\n\\nThe solution of the input `nums=[2,7,9,3,1,5], k = 3` is 5\\nThe solution of the input `nums=[2,7,9,3,1,5], k = 2` is 2\\nThe solution of the input `nums=[2,7,9,3,1,5], k = 1` is 1\\n\\nEvery time you call `kcnt(i)` function to guess `i`, you just need O(N) time to do it.\\n\\n\\nBTW, \\nWhy I can know this path `[2,7,9,3,1,5]` -> kcnt(9) = 3 ?\\nBecause I reuse this constraint from the descripiton of this problem \\n`1 <= k <= (nums.length + 1)/2` => there are 6 element so the most number it can contribute is 6+1/2 = 3.  \\nIf you want to implement kcnt() function, I think it is a Easy level problem.\\n\\n\\n\\n\\nIn the following,\\nI give the following complete code with log for you. \\n\\n# Complete Code with stdout\\nYou can run any small test case and the information from the stdout \\nis enough you to understand.  \\nIf you comment `#DEBUG`, then it will not do any print. \\nIf you run the code with `#DEBUG` then it need O(N^2) because I show every guessing case in the log. \\n\\n```C++\\nclass Solution {\\npublic:\\n    #define DEBUG\\n    #ifndef DEBUG\\n        #define printf(...) empty_printf(__VA_ARGS__)\\n    #endif \\n    #define empty_printf(...)\\n    #define print_container(name) printf(\"%s = \",#name);for(auto &i:name)printf(\"%d,\",i);printf(\"\\\\n\");\\n    \\n\\n    int minCapability(vector<int>& nums, int k) {\\n        printf(\"\\\\nminCapability, k= %d\\\\n\",k);\\n        print_container(nums);\\n        vector<int> A = nums;\\n        nums.push_back(INT_MAX);\\n        int n = nums.size();\\n        \\n        function<int(int)> kcnt =  [&](int v) {\\n            //select all value that smaller or equal than v\\n            int cnt = 0;\\n            int L = 0;\\n            for(int R = 0;R<n;R++) {\\n                if(nums[R] > v) {//case of no select \\n                    int w = R-L;\\n                    cnt+=(w+1)/2;\\n                    L=R+1;\\n                }\\n            }\\n            return cnt;\\n        };\\n        sort(A.begin(), A.end());\\n        \\n        for(int i = 0; i<A.size();i++) \\n            printf(\"A[i=%d] = %d, kcnt(%d) = %d\\\\n\",  i,A[i], A[i], kcnt(A[i]));\\n        \\n        printf(\"Start to binary search\\\\n\");\\n        int L = 0, R=A.size()-1;\\n        while(L<=R) {\\n            int M = L+(R-L)/2;\\n            printf(\"L,M,R = %d,%d,%d\\\\n\", L,M,R);\\n            if( (M-1<0 || kcnt(A[M-1])<k) && kcnt(A[M]) == k ) {\\n                printf(\"A[M=%d] = %d is solution\\\\n\",M, A[M]);\\n                return A[M];\\n            } \\n            if(kcnt(A[M]) >= k) {\\n                R=M-1;\\n            } else {\\n                L=M+1;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```\\n\\n# Running result\\nInput: \\nnums=[2,7,9,3,1,5],k=3\\nStdout:\\n```\\nminCapability, k= 3\\nnums = 2,7,9,3,1,5,\\nA[i=0] = 1, kcnt(1) = 1\\nA[i=1] = 2, kcnt(2) = 2\\nA[i=2] = 3, kcnt(3) = 2\\nA[i=3] = 5, kcnt(5) = 3\\nA[i=4] = 7, kcnt(7) = 3\\nA[i=5] = 9, kcnt(9) = 3\\nStart to binary search\\nL,M,R = 0,2,5\\nL,M,R = 3,4,5\\nL,M,R = 3,3,3\\nA[M=3] = 5 is solution\\n```\\n\\nInput: \\nnums=[2,3,5,9], k=2\\nStdout:\\n```\\nminCapability, k= 2\\nnums = 2,3,5,9,\\nA[i=0] = 2, kcnt(2) = 1\\nA[i=1] = 3, kcnt(3) = 1\\nA[i=2] = 5, kcnt(5) = 2\\nA[i=3] = 9, kcnt(9) = 2\\nStart to binary search\\nL,M,R = 0,1,3\\nL,M,R = 2,2,3\\nA[M=2] = 5 is solution\\n```\\n\\nInput: \\nnums=[2,7,9,3,1], k=2\\nStdout:\\n```\\nminCapability, k= 2\\nnums = 2,7,9,3,1,\\nA[i=0] = 1, kcnt(1) = 1\\nA[i=1] = 2, kcnt(2) = 2\\nA[i=2] = 3, kcnt(3) = 2\\nA[i=3] = 7, kcnt(7) = 2\\nA[i=4] = 9, kcnt(9) = 3\\nStart to binary search\\nL,M,R = 0,2,4\\nL,M,R = 0,0,1\\nL,M,R = 1,1,1\\nA[M=1] = 2 is solution\\n```\\n\\nInput: \\nnums=[2,7,9,3,1], k=3\\nStdout:\\n```\\nminCapability, k= 3\\nnums = 2,7,9,3,1,\\nA[i=0] = 1, kcnt(1) = 1\\nA[i=1] = 2, kcnt(2) = 2\\nA[i=2] = 3, kcnt(3) = 2\\nA[i=3] = 7, kcnt(7) = 2\\nA[i=4] = 9, kcnt(9) = 3\\nStart to binary search\\nL,M,R = 0,2,4\\nL,M,R = 3,3,4\\nL,M,R = 4,4,4\\nA[M=4] = 9 is solution\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        vector<int> A = nums;\\n\\t\\tsort(A.begin(), A.end());\\n        nums.push_back(INT_MAX);\\n        int n = nums.size();\\n        \\n        function<int(int)> kcnt =  [&](int v) {\\n            int cnt = 0, L = 0;\\n            for(int R = 0;R<n;R++) {\\n                if(nums[R] > v) {\\n                    cnt+=(R-L+1)/2;\\n                    L=R+1;\\n                }\\n            }\\n            return cnt;\\n        };\\n\\t\\t\\n        int L = 0, R=A.size()-1;\\n        vector<int> cnt = vector<int>(A.size(),-1);\\n        while(L<=R) {\\n            int M = L+(R-L)/2;            \\n            if( (M-1<0 || kcnt(A[M-1])<k) && kcnt(A[M]) == k ) \\n                return A[M];\\n            if(kcnt(A[M]) >= k) \\n                R=M-1;\\n            else \\n                L=M+1;\\n        }\\n        return -1;      \\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    #define DEBUG\\n    #ifndef DEBUG\\n        #define printf(...) empty_printf(__VA_ARGS__)\\n    #endif \\n    #define empty_printf(...)\\n    #define print_container(name) printf(\"%s = \",#name);for(auto &i:name)printf(\"%d,\",i);printf(\"\\\\n\");\\n    \\n\\n    int minCapability(vector<int>& nums, int k) {\\n        printf(\"\\\\nminCapability, k= %d\\\\n\",k);\\n        print_container(nums);\\n        vector<int> A = nums;\\n        nums.push_back(INT_MAX);\\n        int n = nums.size();\\n        \\n        function<int(int)> kcnt =  [&](int v) {\\n            //select all value that smaller or equal than v\\n            int cnt = 0;\\n            int L = 0;\\n            for(int R = 0;R<n;R++) {\\n                if(nums[R] > v) {//case of no select \\n                    int w = R-L;\\n                    cnt+=(w+1)/2;\\n                    L=R+1;\\n                }\\n            }\\n            return cnt;\\n        };\\n        sort(A.begin(), A.end());\\n        \\n        for(int i = 0; i<A.size();i++) \\n            printf(\"A[i=%d] = %d, kcnt(%d) = %d\\\\n\",  i,A[i], A[i], kcnt(A[i]));\\n        \\n        printf(\"Start to binary search\\\\n\");\\n        int L = 0, R=A.size()-1;\\n        while(L<=R) {\\n            int M = L+(R-L)/2;\\n            printf(\"L,M,R = %d,%d,%d\\\\n\", L,M,R);\\n            if( (M-1<0 || kcnt(A[M-1])<k) && kcnt(A[M]) == k ) {\\n                printf(\"A[M=%d] = %d is solution\\\\n\",M, A[M]);\\n                return A[M];\\n            } \\n            if(kcnt(A[M]) >= k) {\\n                R=M-1;\\n            } else {\\n                L=M+1;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```\n```\\nminCapability, k= 3\\nnums = 2,7,9,3,1,5,\\nA[i=0] = 1, kcnt(1) = 1\\nA[i=1] = 2, kcnt(2) = 2\\nA[i=2] = 3, kcnt(3) = 2\\nA[i=3] = 5, kcnt(5) = 3\\nA[i=4] = 7, kcnt(7) = 3\\nA[i=5] = 9, kcnt(9) = 3\\nStart to binary search\\nL,M,R = 0,2,5\\nL,M,R = 3,4,5\\nL,M,R = 3,3,3\\nA[M=3] = 5 is solution\\n```\n```\\nminCapability, k= 2\\nnums = 2,3,5,9,\\nA[i=0] = 2, kcnt(2) = 1\\nA[i=1] = 3, kcnt(3) = 1\\nA[i=2] = 5, kcnt(5) = 2\\nA[i=3] = 9, kcnt(9) = 2\\nStart to binary search\\nL,M,R = 0,1,3\\nL,M,R = 2,2,3\\nA[M=2] = 5 is solution\\n```\n```\\nminCapability, k= 2\\nnums = 2,7,9,3,1,\\nA[i=0] = 1, kcnt(1) = 1\\nA[i=1] = 2, kcnt(2) = 2\\nA[i=2] = 3, kcnt(3) = 2\\nA[i=3] = 7, kcnt(7) = 2\\nA[i=4] = 9, kcnt(9) = 3\\nStart to binary search\\nL,M,R = 0,2,4\\nL,M,R = 0,0,1\\nL,M,R = 1,1,1\\nA[M=1] = 2 is solution\\n```\n```\\nminCapability, k= 3\\nnums = 2,7,9,3,1,\\nA[i=0] = 1, kcnt(1) = 1\\nA[i=1] = 2, kcnt(2) = 2\\nA[i=2] = 3, kcnt(3) = 2\\nA[i=3] = 7, kcnt(7) = 2\\nA[i=4] = 9, kcnt(9) = 3\\nStart to binary search\\nL,M,R = 0,2,4\\nL,M,R = 3,3,4\\nL,M,R = 4,4,4\\nA[M=4] = 9 is solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156537,
                "title": "house-robber-iv-easy-understandable-simple-solution-c-solution-bs",
                "content": "```\\nclass Solution {\\n    bool check(vector<int> &nums,int x,int k)\\n    {\\n        int c = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=x)\\n            {\\n                c++;\\n                i++;\\n            }\\n        }\\n        return c>=k;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        \\n        int l=  INT_MAX;\\n        int h = INT_MIN;\\n        for(auto it : nums)\\n        {\\n            l = min(l,it);\\n            h = max(h,it);\\n        }\\n        \\n        int ans = h;\\n        \\n        while(l<=h)\\n        {\\n            int mid = (l+(h-l)/2);\\n            if(check(nums,mid,k))\\n            {\\n                ans = mid;\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool check(vector<int> &nums,int x,int k)\\n    {\\n        int c = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=x)\\n            {\\n                c++;\\n                i++;\\n            }\\n        }\\n        return c>=k;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        \\n        int l=  INT_MAX;\\n        int h = INT_MIN;\\n        for(auto it : nums)\\n        {\\n            l = min(l,it);\\n            h = max(h,it);\\n        }\\n        \\n        int ans = h;\\n        \\n        while(l<=h)\\n        {\\n            int mid = (l+(h-l)/2);\\n            if(check(nums,mid,k))\\n            {\\n                ans = mid;\\n                h = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154980,
                "title": "binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& a,int k,int m){\\n        int curr=0,cnt=0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]>m){\\n                cnt+=((curr+1)>>1);\\n                curr=0;\\n            }\\n            else\\n                curr++;\\n        }\\n        cnt+=((1+curr)>>1);\\n        return cnt>=k;\\n    }\\n    \\n    int minCapability(vector<int>& a, int k) {\\n        int l=a[0],r=a[0],n=a.size();\\n        for(int i=0;i<n;i++){\\n            l=min(l,a[i]);\\n            r=max(r,a[i]);\\n        }\\n        int ans=r;\\n        while(l<=r){\\n            int m=l+((r-l)>>1);\\n            if(check(a,k,m)){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else\\n                l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& a,int k,int m){\\n        int curr=0,cnt=0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]>m){\\n                cnt+=((curr+1)>>1);\\n                curr=0;\\n            }\\n            else\\n                curr++;\\n        }\\n        cnt+=((1+curr)>>1);\\n        return cnt>=k;\\n    }\\n    \\n    int minCapability(vector<int>& a, int k) {\\n        int l=a[0],r=a[0],n=a.size();\\n        for(int i=0;i<n;i++){\\n            l=min(l,a[i]);\\n            r=max(r,a[i]);\\n        }\\n        int ans=r;\\n        while(l<=r){\\n            int m=l+((r-l)>>1);\\n            if(check(a,k,m)){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else\\n                l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154321,
                "title": "c-binary-search-using-helper-func",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool solve(int mid,vector<int>& nums, int k){\\n    int i=0;\\n    int n=nums.size();\\n    while(i<n){\\n        if(nums[i]<=mid){\\n           k--;\\n           i+=2;\\n        }\\n        else{\\n            i++;\\n        }\\n        if(k==0){\\n            return true;\\n        }\\n    }\\n    return k==0;\\n}\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int s=1;\\n        int e= 1e9;\\n        int ans=-1;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(solve(mid,nums,k)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool solve(int mid,vector<int>& nums, int k){\\n    int i=0;\\n    int n=nums.size();\\n    while(i<n){\\n        if(nums[i]<=mid){\\n           k--;\\n           i+=2;\\n        }\\n        else{\\n            i++;\\n        }\\n        if(k==0){\\n            return true;\\n        }\\n    }\\n    return k==0;\\n}\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int s=1;\\n        int e= 1e9;\\n        int ans=-1;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(solve(mid,nums,k)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154018,
                "title": "why-dp-binary-search-is-very-slow-compared-to-greedy-binary-search-both-have-same-tc-o-nlogm",
                "content": "**If anyone have any idea, please share it to avoid confusion\\nIn the title N is the length of nums and M is the length of the search range.**\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3153970,
                "title": "python-clean-binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n\\n        def check(x):\\n            flag=False\\n            count=0\\n\\n            for val in nums:\\n                if flag==True:\\n                    flag=False\\n                    continue\\n                else:\\n                    if val<=x:\\n                        count+=1\\n                        flag=True\\n            \\n            return count>=k\\n\\n        \\n        low,high=min(nums),max(nums)\\n        ans=-1\\n        while low<=high:\\n            mid=(low+high)//2\\n            if check(mid):\\n                ans=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n\\n        return ans\\n\\n\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n\\n        def check(x):\\n            flag=False\\n            count=0\\n\\n            for val in nums:\\n                if flag==True:\\n                    flag=False\\n                    continue\\n                else:\\n                    if val<=x:\\n                        count+=1\\n                        flag=True\\n            \\n            return count>=k\\n\\n        \\n        low,high=min(nums),max(nums)\\n        ans=-1\\n        while low<=high:\\n            mid=(low+high)//2\\n            if check(mid):\\n                ans=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n\\n        return ans\\n\\n\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153751,
                "title": "rust-binary-search-greedy-algorithm",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_capability(nums: Vec<i32>, k: i32) -> i32 {\\n        let (mut l, mut r) = (0, i32::pow(10, 9) + 1);\\n        while l < r {\\n            let mid = (r - l) / 2 + l;\\n            if Solution::is_possible(mid, &nums, k) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        l\\n    }\\n    pub fn is_possible(max_capability: i32, nums: &Vec<i32>, k: i32) -> bool {\\n        let mut last_index = -10;\\n        let mut can_steal = 0;\\n        for (i, el) in nums.iter().enumerate() {\\n            if *el > max_capability {\\n                continue;\\n            }\\n            if i == last_index as usize + 1 {\\n                continue;\\n            }\\n            can_steal += 1;\\n            last_index = i as i32;\\n        }\\n        can_steal >= k\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_capability(nums: Vec<i32>, k: i32) -> i32 {\\n        let (mut l, mut r) = (0, i32::pow(10, 9) + 1);\\n        while l < r {\\n            let mid = (r - l) / 2 + l;\\n            if Solution::is_possible(mid, &nums, k) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        l\\n    }\\n    pub fn is_possible(max_capability: i32, nums: &Vec<i32>, k: i32) -> bool {\\n        let mut last_index = -10;\\n        let mut can_steal = 0;\\n        for (i, el) in nums.iter().enumerate() {\\n            if *el > max_capability {\\n                continue;\\n            }\\n            if i == last_index as usize + 1 {\\n                continue;\\n            }\\n            can_steal += 1;\\n            last_index = i as i32;\\n        }\\n        can_steal >= k\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3153167,
                "title": "python-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        left=min(nums)\\n        right=max(nums)\\n        \\n        while left<=right:\\n            mid=(left+right)//2\\n            \\n            if self.can_rob(nums,mid,k):\\n                right=mid-1\\n                ans=mid\\n            else:\\n                left=mid+1\\n        return ans \\n    \\n    def can_rob(self,nums,mid,k):\\n        i=0\\n        while i< len(nums):\\n            if nums[i]<=mid:\\n                k-=1\\n                i+=2\\n            else:\\n                i+=1\\n            if k==0:\\n                return True\\n                \\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        left=min(nums)\\n        right=max(nums)\\n        \\n        while left<=right:\\n            mid=(left+right)//2\\n            \\n            if self.can_rob(nums,mid,k):\\n                right=mid-1\\n                ans=mid\\n            else:\\n                left=mid+1\\n        return ans \\n    \\n    def can_rob(self,nums,mid,k):\\n        i=0\\n        while i< len(nums):\\n            if nums[i]<=mid:\\n                k-=1\\n                i+=2\\n            else:\\n                i+=1\\n            if k==0:\\n                return True\\n                \\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153047,
                "title": "a-few-solutions",
                "content": "Perform binary search, ie. we can make a logarithmic amount of guesses at a runtime validation cost of a linear scan per guess:\\n* Let `i..j` inclusive be the search space, initialized to `min..max` of the input array `A` correspondingly\\n* Let `k` be our guess\\n\\n**Notes:**\\n* We can safely validate each guess in linear O(N) time by greedily consuming each `i`<sup>th</sup> value of `A` (see the informal proof by contradiction in the image below, ie. for the use-case of sufficiently large amount of houses to rob (from which we `need` to `take`) we must make a sub-optimal decision (above the threshold `T`) regardless of greedy consumption.\\n\\n![image](https://assets.leetcode.com/users/images/44852df6-ce52-45d0-8d4f-4e51814aa9da_1675717673.126652.jpeg)\\n\\n**Supplemental:**\\n* Example 2 mentions there\\'s \"7 ways to rob the houses\" but I only count 6 ways (which pair am I missing?)\\n```\\nExample 2:\\nInput: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses.\\n```\\n\\n\\n---\\n\\n**Solutions:**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minCapability(A: IntArray, take: Int): Int {\\n        fun ok(T: Int, need_: Int = take): Boolean {\\n            var need = need_\\n            var (i, N) = Pair(0, A.size)\\n            while (i < N && 0 < need) {\\n                if (A[i] <= T) {\\n                    i += 2; --need\\n                } else {\\n                    i += 1\\n                }\\n            }\\n            return need == 0\\n        }\\n        var (i, j) = Pair(A.min()!!, A.max()!!)\\n        while (i < j) {\\n            var k = (i + j) / 2\\n            if (ok(k))\\n                j = k\\n            else\\n                i = k + 1\\n        }\\n        return i\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minCapability = (A, take) => {\\n    let ok = (T, need = take) => {\\n        let [i, N] = [0, A.length];\\n        while (i < N && need) {\\n            if (A[i] <= T)\\n                i += 2, --need;\\n            else\\n                i += 1;\\n        }\\n        return !need;\\n    };\\n    let [i, j] = [Math.min(...A), Math.max(...A)];\\n    while (i < j) {\\n        let k = Math.floor((i + j) / 2);\\n        if (ok(k))\\n            j = k;\\n        else\\n            i = k + 1;\\n    }\\n    return i;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minCapability(self, A: List[int], take: int) -> int:\\n        def ok(T, need = take):\\n            i, N = 0, len(A)\\n            while i < N and need:\\n                if A[i] <= T:\\n                    i += 2; need -= 1\\n                else:\\n                    i += 1\\n            return not need\\n        i, j = min(A), max(A)\\n        while i < j:\\n            k = (i + j) // 2\\n            if ok(k):\\n                j = k\\n            else:\\n                i = k + 1\\n        return i\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn min_capability(A: VI, take: i32) -> i32 {\\n        fn ok(A: &VI, T: i32, mut need: i32) -> bool {\\n            let (mut i, N) = (0, A.len());\\n            while i < N && 0 < need {\\n                if A[i] <= T {\\n                    i += 2; need -= 1;\\n                } else {\\n                    i += 1;\\n                }\\n            }\\n            need == 0\\n        }\\n        let (mut i, mut j) = (*A.iter().min().unwrap(), *A.iter().max().unwrap());\\n        while i < j {\\n            let k = (i + j) / 2;\\n            if ok(&A, k, take) {\\n                j = k;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n        i\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minCapability(VI& A, int take) {\\n        auto ok = [&](auto T, auto need) {\\n            auto [i, N] = make_pair(0, A.size());\\n            while (i < N && need) {\\n                if (A[i] <= T)\\n                    i += 2, --need;\\n                else\\n                    i += 1;\\n            }\\n            return !need;\\n        };\\n        auto [lo, hi] = minmax_element(A.begin(), A.end());\\n        auto [i, j] = make_pair(*lo, *hi);\\n        while (i < j) {\\n            auto k = (i + j) / 2;\\n            if (ok(k, take))\\n                j = k;\\n            else\\n                i = k + 1;\\n        };\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nExample 2:\\nInput: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses.\\n```\n```\\nclass Solution {\\n    fun minCapability(A: IntArray, take: Int): Int {\\n        fun ok(T: Int, need_: Int = take): Boolean {\\n            var need = need_\\n            var (i, N) = Pair(0, A.size)\\n            while (i < N && 0 < need) {\\n                if (A[i] <= T) {\\n                    i += 2; --need\\n                } else {\\n                    i += 1\\n                }\\n            }\\n            return need == 0\\n        }\\n        var (i, j) = Pair(A.min()!!, A.max()!!)\\n        while (i < j) {\\n            var k = (i + j) / 2\\n            if (ok(k))\\n                j = k\\n            else\\n                i = k + 1\\n        }\\n        return i\\n    }\\n}\\n```\n```\\nlet minCapability = (A, take) => {\\n    let ok = (T, need = take) => {\\n        let [i, N] = [0, A.length];\\n        while (i < N && need) {\\n            if (A[i] <= T)\\n                i += 2, --need;\\n            else\\n                i += 1;\\n        }\\n        return !need;\\n    };\\n    let [i, j] = [Math.min(...A), Math.max(...A)];\\n    while (i < j) {\\n        let k = Math.floor((i + j) / 2);\\n        if (ok(k))\\n            j = k;\\n        else\\n            i = k + 1;\\n    }\\n    return i;\\n};\\n```\n```\\nclass Solution:\\n    def minCapability(self, A: List[int], take: int) -> int:\\n        def ok(T, need = take):\\n            i, N = 0, len(A)\\n            while i < N and need:\\n                if A[i] <= T:\\n                    i += 2; need -= 1\\n                else:\\n                    i += 1\\n            return not need\\n        i, j = min(A), max(A)\\n        while i < j:\\n            k = (i + j) // 2\\n            if ok(k):\\n                j = k\\n            else:\\n                i = k + 1\\n        return i\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn min_capability(A: VI, take: i32) -> i32 {\\n        fn ok(A: &VI, T: i32, mut need: i32) -> bool {\\n            let (mut i, N) = (0, A.len());\\n            while i < N && 0 < need {\\n                if A[i] <= T {\\n                    i += 2; need -= 1;\\n                } else {\\n                    i += 1;\\n                }\\n            }\\n            need == 0\\n        }\\n        let (mut i, mut j) = (*A.iter().min().unwrap(), *A.iter().max().unwrap());\\n        while i < j {\\n            let k = (i + j) / 2;\\n            if ok(&A, k, take) {\\n                j = k;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n        i\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minCapability(VI& A, int take) {\\n        auto ok = [&](auto T, auto need) {\\n            auto [i, N] = make_pair(0, A.size());\\n            while (i < N && need) {\\n                if (A[i] <= T)\\n                    i += 2, --need;\\n                else\\n                    i += 1;\\n            }\\n            return !need;\\n        };\\n        auto [lo, hi] = minmax_element(A.begin(), A.end());\\n        auto [i, j] = make_pair(*lo, *hi);\\n        while (i < j) {\\n            auto k = (i + j) / 2;\\n            if (ok(k, take))\\n                j = k;\\n            else\\n                i = k + 1;\\n        };\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152564,
                "title": "c-solution-binary-search-100-time-and-space-complexity",
                "content": "# Intuition\\n![Screenshot 2023-02-06 234913.png](https://assets.leetcode.com/users/images/5799482d-6c36-4ecd-a715-b090d22ddfc6_1675707565.6742487.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbinary search in sample space of answer which can lie b?w 1-1e9 value range of nums[i]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinary search\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn*log(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // int f(int ind,int k,vector<int>& nums,vector<vector<int>>& dp){\\n    //     if(k==0) return 0;\\n    //     if(ind==nums.size()){\\n    //         return 1e8;\\n    //     }\\n    //     if(dp[ind][k]!=-1) return dp[ind][k];\\n    //     int ans=INT_MAX;\\n    //     for(int i=ind;i<nums.size()-2*(k-1);i++){\\n    //         if(nums[i]<ans) ans=min(ans,max(nums[i],f(i+2,k-1,nums,dp)));\\n    //     }\\n    //     return dp[ind][k]=ans;\\n    // }\\n    bool f(int tar,int k,vector<int>& nums){\\n        int i=0;\\n        while(i<nums.size() && k>0){\\n            if(nums[i]<=tar){\\n                i+=2;\\n                k--;\\n            }\\n            else i++;\\n        }\\n        return k==0;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int start=0,end=1e9;\\n        int ans=INT_MAX;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(f(mid,k,nums)){\\n                ans=min(ans,mid);\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int f(int ind,int k,vector<int>& nums,vector<vector<int>>& dp){\\n    //     if(k==0) return 0;\\n    //     if(ind==nums.size()){\\n    //         return 1e8;\\n    //     }\\n    //     if(dp[ind][k]!=-1) return dp[ind][k];\\n    //     int ans=INT_MAX;\\n    //     for(int i=ind;i<nums.size()-2*(k-1);i++){\\n    //         if(nums[i]<ans) ans=min(ans,max(nums[i],f(i+2,k-1,nums,dp)));\\n    //     }\\n    //     return dp[ind][k]=ans;\\n    // }\\n    bool f(int tar,int k,vector<int>& nums){\\n        int i=0;\\n        while(i<nums.size() && k>0){\\n            if(nums[i]<=tar){\\n                i+=2;\\n                k--;\\n            }\\n            else i++;\\n        }\\n        return k==0;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int start=0,end=1e9;\\n        int ans=INT_MAX;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(f(mid,k,nums)){\\n                ans=min(ans,mid);\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151983,
                "title": "c-easy-fast-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums,int val,int k)\\n    {\\n        int cnt=0,i=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<=val)\\n            {\\n                cnt++;\\n                i++;\\n            }\\n        }\\n        return  (cnt>=k);\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int mn=1e9,mx=-1e9;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=min(mn,nums[i]);\\n            mx=max(mx,nums[i]);\\n        }\\n        int ans;\\n        int mid;\\n        while(mn<=mx)\\n        {\\n            mid=(mn+mx)/2;\\n            if(solve(nums,mid,k))\\n            {\\n                ans=mid;\\n                mx=mid-1;\\n            }\\n            else\\n            {\\n                mn=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums,int val,int k)\\n    {\\n        int cnt=0,i=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<=val)\\n            {\\n                cnt++;\\n                i++;\\n            }\\n        }\\n        return  (cnt>=k);\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int mn=1e9,mx=-1e9;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mn=min(mn,nums[i]);\\n            mx=max(mx,nums[i]);\\n        }\\n        int ans;\\n        int mid;\\n        while(mn<=mx)\\n        {\\n            mid=(mn+mx)/2;\\n            if(solve(nums,mid,k))\\n            {\\n                ans=mid;\\n                mx=mid-1;\\n            }\\n            else\\n            {\\n                mn=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151772,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\n    \\n    bool solve(vector<int> &nums,int k,int mid)\\n    {\\n     int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<=mid)\\n            {\\n                k--;\\n                i+=2;\\n            }\\n            else\\n                i++;\\n            \\n            if(k==0)\\n                return true;\\n        }\\n        \\n        return false;\\n            \\n    }\\n    \\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n     int low=*min_element(nums.begin(),nums.end());\\n     int high=*max_element(nums.begin(),nums.end());\\n     \\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            \\n            if(!solve(nums,k,mid))\\n            {\\n                low=mid+1;\\n    \\n            }\\n            else\\n            {\\n              \\n                high=mid-1;\\n            }\\n            \\n        }\\n        return high+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    bool solve(vector<int> &nums,int k,int mid)\\n    {\\n     int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<=mid)\\n            {\\n                k--;\\n                i+=2;\\n            }\\n            else\\n                i++;\\n            \\n            if(k==0)\\n                return true;\\n        }\\n        \\n        return false;\\n            \\n    }\\n    \\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n     int low=*min_element(nums.begin(),nums.end());\\n     int high=*max_element(nums.begin(),nums.end());\\n     \\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            \\n            if(!solve(nums,k,mid))\\n            {\\n                low=mid+1;\\n    \\n            }\\n            else\\n            {\\n              \\n                high=mid-1;\\n            }\\n            \\n        }\\n        return high+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151740,
                "title": "swift-solution-using-binary-search-o-n-log-price-max-price-min",
                "content": "# Code\\n```\\nclass Solution {\\n    func minCapability(_ price: [Int], _ k: Int) -> Int {\\n        \\n        var left = price.min()!\\n        var right = price.max()!\\n        \\n        while left < right {\\n            let m = (right + left - 1) / 2\\n            var count = 0\\n            var i = 0\\n            while i < price.count {\\n                if price[i] <= m {\\n                    count += 1\\n                    i += 1\\n                }\\n                i += 1\\n            }\\n            \\n            if count >= k {\\n                right = m\\n            } else {\\n                left = m + 1\\n            }\\n        }\\n        \\n        return left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minCapability(_ price: [Int], _ k: Int) -> Int {\\n        \\n        var left = price.min()!\\n        var right = price.max()!\\n        \\n        while left < right {\\n            let m = (right + left - 1) / 2\\n            var count = 0\\n            var i = 0\\n            while i < price.count {\\n                if price[i] <= m {\\n                    count += 1\\n                    i += 1\\n                }\\n                i += 1\\n            }\\n            \\n            if count >= k {\\n                right = m\\n            } else {\\n                left = m + 1\\n            }\\n        }\\n        \\n        return left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151596,
                "title": "python-binary-search",
                "content": "# Intuition\\nCheck possible values between 0 and max value in array using binary search.\\n\\n# Approach\\nDo binary search between 0 and max value in the array, take minimum value that passes the check.\\nOn check go through array count items that are upto candidate value, count them with distance 2 and 3, if max seen count is at least k that passes the check.\\n\\n# Complexity\\n- Time complexity:\\nO(N log M), M is max value in array N is length of the array.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minCapability(self, A: List[int], k: int) -> int:\\n        def k_items_upto(value):\\n            max_seen_upto_value = curr = dp1 = dp2 = dp3 = 0\\n            for i in range(len(A)):\\n                curr = int(A[i] <= value) + max(dp2, dp3)\\n                dp3, dp2, dp1 = dp2, dp1, curr\\n                max_seen_upto_value = max(max_seen_upto_value, curr)\\n            return max_seen_upto_value >= k\\n\\n        lo, hi = 0, max(A)\\n        while lo < hi:\\n            value = (lo + hi) // 2\\n            if k_items_upto(value): hi = value\\n            else: lo = value + 1\\n        return hi\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, A: List[int], k: int) -> int:\\n        def k_items_upto(value):\\n            max_seen_upto_value = curr = dp1 = dp2 = dp3 = 0\\n            for i in range(len(A)):\\n                curr = int(A[i] <= value) + max(dp2, dp3)\\n                dp3, dp2, dp1 = dp2, dp1, curr\\n                max_seen_upto_value = max(max_seen_upto_value, curr)\\n            return max_seen_upto_value >= k\\n\\n        lo, hi = 0, max(A)\\n        while lo < hi:\\n            value = (lo + hi) // 2\\n            if k_items_upto(value): hi = value\\n            else: lo = value + 1\\n        return hi\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151083,
                "title": "super-easy-binary-search-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a function if robbery can happend to k houses if max rob capacity at one house is C. This can be achieved in O(n) time.\\n\\nFind min and max ranges of money in all houses. \\nAnd look for capacity between these ranges by applying above method and bisecting the range(binary search).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nN = no of houses. (10^5)\\nR = ranges of money (10^9)\\n**TC : O(N * log(R))**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**SC: O(1)**\\n# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        def robCapacity(C):\\n            \\'\\'\\'\\n            Finds if robbery can happend to k houses if max rob capacity at one house is C.\\n            \\'\\'\\'\\n            count = 0\\n            prev_idx = None\\n            for idx, num in enumerate(nums):\\n                if num > C:\\n                    continue\\n                if idx - 1 == prev_idx:\\n                    continue\\n                prev_idx = idx\\n                count += 1\\n                if count == k:\\n                    return True\\n            return False\\n        \\n        start, end = math.inf, -math.inf\\n        for num in nums:\\n            start = min(start, num)\\n            end = max(end, num)\\n        \\n        min_cap = start\\n        while start <= end:\\n            mid = (start + end) // 2\\n            \\n            if robCapacity(mid):\\n                min_cap = mid\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return min_cap\\n ```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        def robCapacity(C):\\n            \\'\\'\\'\\n            Finds if robbery can happend to k houses if max rob capacity at one house is C.\\n            \\'\\'\\'\\n            count = 0\\n            prev_idx = None\\n            for idx, num in enumerate(nums):\\n                if num > C:\\n                    continue\\n                if idx - 1 == prev_idx:\\n                    continue\\n                prev_idx = idx\\n                count += 1\\n                if count == k:\\n                    return True\\n            return False\\n        \\n        start, end = math.inf, -math.inf\\n        for num in nums:\\n            start = min(start, num)\\n            end = max(end, num)\\n        \\n        min_cap = start\\n        while start <= end:\\n            mid = (start + end) // 2\\n            \\n            if robCapacity(mid):\\n                min_cap = mid\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return min_cap\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3150906,
                "title": "c-binary-search-solution-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool stasify(vector<int>& nums,int k,int mid)\\n    {\\n        int curr = -1,count =0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=mid)\\n            {\\n                if(curr == -1)\\n                {\\n                    curr = i;\\n                    count++;\\n                }\\n                else\\n                {\\n                    if(curr != i-1)\\n                    {\\n                        curr = i;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int low = 1,high = 1e9;\\n        while(low<=high)\\n        {\\n            int mid = (long long)(low + high)>>1;\\n            if(stasify(nums,k,mid))\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool stasify(vector<int>& nums,int k,int mid)\\n    {\\n        int curr = -1,count =0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=mid)\\n            {\\n                if(curr == -1)\\n                {\\n                    curr = i;\\n                    count++;\\n                }\\n                else\\n                {\\n                    if(curr != i-1)\\n                    {\\n                        curr = i;\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int low = 1,high = 1e9;\\n        while(low<=high)\\n        {\\n            int mid = (long long)(low + high)>>1;\\n            if(stasify(nums,k,mid))\\n            {\\n                high = mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return low;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150374,
                "title": "java-clean-and-easy-solution-with-institution-binary-search-on-answers",
                "content": "As Soon as you lands on this question, you will definately think of rescursion or in terms of DP, which is good, but by looking at constraints you can get to know that DP or recursion with memo wont work, in any case. therefore we need to look at any other way.\\n\\nNow the question starts if not DP then what ???\\n\\nAns is binary search, if you would have read the question carefully the question itself giving the hint to use binary search notice in question capability is defined.\\n\\n\\n```\\npublic int minCapability(int[] nums, int k) {\\n        int n = nums.length;\\n        int left = 1;\\n        int right = (int) 1e9;\\n        int ans = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(helper(nums, k, mid)){\\n                ans = Math.min(ans, mid);\\n                right = mid-1;\\n            }else {\\n                left = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static boolean helper(int[] nums, int k, int cur){\\n        int i = 0;\\n        int n = nums.length;\\n        while (i < n){\\n            if(nums[i] <= cur){\\n                k--;\\n                i+=2;\\n            }else {\\n                i++;\\n            }\\n\\n            if(k==0){\\n                return true;\\n            }\\n        }\\n        return k==0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic int minCapability(int[] nums, int k) {\\n        int n = nums.length;\\n        int left = 1;\\n        int right = (int) 1e9;\\n        int ans = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(helper(nums, k, mid)){\\n                ans = Math.min(ans, mid);\\n                right = mid-1;\\n            }else {\\n                left = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static boolean helper(int[] nums, int k, int cur){\\n        int i = 0;\\n        int n = nums.length;\\n        while (i < n){\\n            if(nums[i] <= cur){\\n                k--;\\n                i+=2;\\n            }else {\\n                i++;\\n            }\\n\\n            if(k==0){\\n                return true;\\n            }\\n        }\\n        return k==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3150042,
                "title": "no-binary-search-much-better-than-o-nlog-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nit looks like a min-max but it is special. \\nI don\\'t think binary search is the best solution for this one.\\nSo I tried an other way.\\n\\nThis is a problem to find a special combination.\\nTo do it straight away, just pick the smaller numbers and find out if they could meet the condition to build the combination.\\n\\n\\ncompare to the submited fastest 1003 ms which use binary search\\nthis solution is 683 ms. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe condistion is \\'refuse the adjacent\\' equals \\'no two are adjacent\\' \\nif the smallest k numbers are not adjacent to each other, we could figure out the answer almost immediately. If some of them are connected, then pick more numbers. \\n\\nWith this approach, we will need calculate inadjacent items.\\nfor example XXX...XXXX.XX represent 3 connected and 3 others then 4 connected and 1 other then 2 connected.\\nThis could give 5. where the 3 and 4 contribute 2 and the 2 contibute 1.\\nIn another words, ODD will contribute (ODD+1)/2 and EVEN will contribute EVEN/2\\n\\nwhen more number is picked, it could fall into one of follwoing conditions\\nA: both left and right are not picked yet. \\nB: left ODD, right EVEN(or ZERO) or left EVEN(or ZERO), right ODD\\nC: both left and right are ODD\\nD: both left and right are EVEN\\nA,D will make one more while B,C will not\\n\\nAfter all, when K is special, there could be a trick.\\n k = 1 is obvious\\n k = (len(nums) +1) // 2 means there is only one choice for odd count of nums and just two choices for even\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(max(log(N),K,N))\\n\\nthe worst case could be O(K)\\nwhen the smallest 2*k numbers are sorted connected, the searching processs will repeat 2*k - 1 times.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        if k ==1:\\n            return min(nums)\\n        if k == (len(nums) + 1 ) // 2:\\n            if len(nums) % 2 == 1:\\n                return max(nums[::2])\\n            return min(max(nums[::2]), max(nums[1::2]))\\n        # ix = sorted(range(len(nums)), key = nums.__getitem__, reverse = True)\\n        ix = sorted(range(len(nums)), key = nums.__getitem__)\\n        # print(ix)\\n        t = [0]*(len(nums)+1)\\n        x = k\\n        # for i in ix[::-1]:\\n        for i in ix:\\n            t[i] = t[i+1] + t[i-1] + 1\\n            if t[i] > 1:\\n                y = ((t[i-1]%2)+1) + 4 *((t[i+1]%2)+1)\\n                if y == 5:\\n                    x -= 1\\n                if t[i-1]:\\n                    t[i-t[i-1]] = t[i]\\n                if t[i+1]:\\n                    t[i+t[i+1]] = t[i]\\n            else:\\n                x -= 1\\n            if x == 0:\\n                return nums[i]\\n            # print(nums[i], x, t, nums)\\n        \\n        return 0\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        if k ==1:\\n            return min(nums)\\n        if k == (len(nums) + 1 ) // 2:\\n            if len(nums) % 2 == 1:\\n                return max(nums[::2])\\n            return min(max(nums[::2]), max(nums[1::2]))\\n        # ix = sorted(range(len(nums)), key = nums.__getitem__, reverse = True)\\n        ix = sorted(range(len(nums)), key = nums.__getitem__)\\n        # print(ix)\\n        t = [0]*(len(nums)+1)\\n        x = k\\n        # for i in ix[::-1]:\\n        for i in ix:\\n            t[i] = t[i+1] + t[i-1] + 1\\n            if t[i] > 1:\\n                y = ((t[i-1]%2)+1) + 4 *((t[i+1]%2)+1)\\n                if y == 5:\\n                    x -= 1\\n                if t[i-1]:\\n                    t[i-t[i-1]] = t[i]\\n                if t[i+1]:\\n                    t[i+t[i+1]] = t[i]\\n            else:\\n                x -= 1\\n            if x == 0:\\n                return nums[i]\\n            # print(nums[i], x, t, nums)\\n        \\n        return 0\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150028,
                "title": "python3-o-nlogn-binary-search-and-greedily-check",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        lo, hi = min(nums), max(nums)\\n        ans = hi\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            cnt, last = 0, False\\n            for v in nums:\\n                if v > mid or v <= mid and last:\\n                    last = False\\n                    continue\\n                else:\\n                    cnt += 1\\n                    last = True\\n                    if cnt == k: break\\n            if cnt == k:\\n                ans = min(ans, mid)\\n                hi = mid - 1\\n            else: lo = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        lo, hi = min(nums), max(nums)\\n        ans = hi\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            cnt, last = 0, False\\n            for v in nums:\\n                if v > mid or v <= mid and last:\\n                    last = False\\n                    continue\\n                else:\\n                    cnt += 1\\n                    last = True\\n                    if cnt == k: break\\n            if cnt == k:\\n                ans = min(ans, mid)\\n                hi = mid - 1\\n            else: lo = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149621,
                "title": "python-binary-search-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        def check(m, k):\\n            prev = -2 \\n            for i,num in enumerate(nums):\\n                if num <= m and i > prev + 1:\\n                    k -= 1\\n                    prev = i\\n            return k <= 0\\n        left = 0\\n        right = max(nums)\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m, k):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        def check(m, k):\\n            prev = -2 \\n            for i,num in enumerate(nums):\\n                if num <= m and i > prev + 1:\\n                    k -= 1\\n                    prev = i\\n            return k <= 0\\n        left = 0\\n        right = max(nums)\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m, k):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149431,
                "title": "c-binary-search-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& A, int k) {\\n        int h = *max_element(begin(A), end(A)), l = *min_element(begin(A), end(A));\\n        auto check = [&](int t)->bool {\\n            for(int i = 0, sum = 0; i < A.size(); i++) {\\n                if(A[i] <= t) {\\n                    if(++sum >= k) return true;\\n                    i++;\\n                }\\n            }\\n            return false;\\n        };\\n        while(l < h) {\\n            int m = l + (h-l)/2;\\n            if(check(m)) h = m;\\n            else l = m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& A, int k) {\\n        int h = *max_element(begin(A), end(A)), l = *min_element(begin(A), end(A));\\n        auto check = [&](int t)->bool {\\n            for(int i = 0, sum = 0; i < A.size(); i++) {\\n                if(A[i] <= t) {\\n                    if(++sum >= k) return true;\\n                    i++;\\n                }\\n            }\\n            return false;\\n        };\\n        while(l < h) {\\n            int m = l + (h-l)/2;\\n            if(check(m)) h = m;\\n            else l = m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149366,
                "title": "java-binary-search-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nbinary search + dp\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        //binary search\\n        int start = 1;\\n        int end = (int)(Math.pow(10,9));\\n        while(start + 1 < end){\\n            int mid = start + (end - start)/2;\\n            if(canRob(nums,mid,k)){\\n                end = mid;\\n            }\\n            else{\\n                start = mid;\\n            }\\n        }\\n        if(canRob(nums,start,k)){\\n            return start;\\n        }else{\\n            return end;\\n        }\\n        \\n    }\\n    public boolean canRob(int[] nums, int maxCapacity, int k){\\n        // the number of houses robbed if start from the ith to the nth\\n        int[] dp = new int[nums.length + 2];\\n        for(int i = nums.length - 1 ; i >= 0; i--){\\n            //base case\\n            //dp[n] = 0;\\n            //if the ith is over capacity, can not rob\\n            if(nums[i] > maxCapacity){\\n                dp[i] = dp[i + 1];\\n            }\\n            else{\\n                dp[i] = Math.max(dp[i + 2] + 1, dp[i + 1]); \\n            }\\n            \\n            \\n        }\\n        return dp[0] >= k;\\n    }\\n    // private boolean canRob(int[] nums, int maxMoney, int k) {\\n    //     int houseStolen = 0, lastStolenIdx = -2;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] > maxMoney) {\\n    //             continue;\\n    //         }\\n    //         if (i == lastStolenIdx + 1) {\\n    //             continue;\\n    //         }\\n            \\n    //         houseStolen++;    \\n    //         lastStolenIdx = i; \\n    //     }\\n        \\n    //     return houseStolen >= k;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        //binary search\\n        int start = 1;\\n        int end = (int)(Math.pow(10,9));\\n        while(start + 1 < end){\\n            int mid = start + (end - start)/2;\\n            if(canRob(nums,mid,k)){\\n                end = mid;\\n            }\\n            else{\\n                start = mid;\\n            }\\n        }\\n        if(canRob(nums,start,k)){\\n            return start;\\n        }else{\\n            return end;\\n        }\\n        \\n    }\\n    public boolean canRob(int[] nums, int maxCapacity, int k){\\n        // the number of houses robbed if start from the ith to the nth\\n        int[] dp = new int[nums.length + 2];\\n        for(int i = nums.length - 1 ; i >= 0; i--){\\n            //base case\\n            //dp[n] = 0;\\n            //if the ith is over capacity, can not rob\\n            if(nums[i] > maxCapacity){\\n                dp[i] = dp[i + 1];\\n            }\\n            else{\\n                dp[i] = Math.max(dp[i + 2] + 1, dp[i + 1]); \\n            }\\n            \\n            \\n        }\\n        return dp[0] >= k;\\n    }\\n    // private boolean canRob(int[] nums, int maxMoney, int k) {\\n    //     int houseStolen = 0, lastStolenIdx = -2;\\n    //     for (int i = 0; i < nums.length; i++) {\\n    //         if (nums[i] > maxMoney) {\\n    //             continue;\\n    //         }\\n    //         if (i == lastStolenIdx + 1) {\\n    //             continue;\\n    //         }\\n            \\n    //         houseStolen++;    \\n    //         lastStolenIdx = i; \\n    //     }\\n        \\n    //     return houseStolen >= k;\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149237,
                "title": "can-someone-please-write-how-to-memoize-the-solution",
                "content": "# TLE\\n# Intution \\nFor every house we have two choices weather to rob or not rob.\\nApply simple Recursion.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int minCapability(vector<int>& nums, int k) {\\n        solve(nums,k,0,INT_MIN);\\n        return ans;\\n    }\\n    void solve(vector<int>&nums,int k,int i,int mn)\\n    {\\n        if(k==0)\\n        {\\n             ans=min(mn,ans);\\n            return ;\\n        }\\n        if(i>=nums.size())\\n            return ;\\n        solve(nums,k-1,i+2,max(mn,nums[i])); //rob the house.\\n        solve(nums,k,i+1,mn); //don\\'t rob the house.\\n        return ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int minCapability(vector<int>& nums, int k) {\\n        solve(nums,k,0,INT_MIN);\\n        return ans;\\n    }\\n    void solve(vector<int>&nums,int k,int i,int mn)\\n    {\\n        if(k==0)\\n        {\\n             ans=min(mn,ans);\\n            return ;\\n        }\\n        if(i>=nums.size())\\n            return ;\\n        solve(nums,k-1,i+2,max(mn,nums[i])); //rob the house.\\n        solve(nums,k,i+1,mn); //don\\'t rob the house.\\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149020,
                "title": "pythonic-one-liner-beats-99-binary-search-dp-tle",
                "content": "# Intuition\\n\\n- Instead of exploring non-adjacent combinations of houses to derive valid capability values, model \"capability\" as the independent variable. \\n- Start by establishing the full range of possible capability values as the search space, and then verify that a valid set of k or more non-adjacent houses can be found for each given capability value. \\n\\n# Approach\\n\\n- Perform binary search to find the minimum \"capability\" value that satisfies the constraint of robbing k or more non-adjacent houses. \\n- For each capability value, greedily rob from any non-adjacent house that satisfies the constraint of being lesser than or equal to the capability value. \\n\\n# Complexity\\n\\n- Time complexity: `O(nlog(m))`\\n    - `n := len(nums)`\\n    - `m := max(nums) - min(nums) + 1`\\n- Space complexity: `O(1)`\\n\\n# Code\\n\\n#### 1) Binary Search (beats 99.27%): `812ms` \\nhttps://leetcode.com/problems/house-robber-iv/submissions/892400769/\\n\\n```python\\ndef minCapability(self, nums: List[int], k: int) -> int:\\n    def is_valid(capability):\\n        cnt, skip = 0, False\\n        for num in nums:\\n            if skip:\\n                skip = False\\n                continue\\n            if num <= capability:\\n                cnt += 1\\n                skip = True\\n        return cnt >= k\\n\\n    return bisect_left(\\n        a=range(max(nums) + 1), \\n        lo=min(nums),\\n        x=True,\\n        key=lambda val: is_valid(val))\\n```\\n\\n#### 2) DP (TLE)\\n```python\\ndef minCapability(self, nums: List[int], k: int) -> int:\\n    @cache\\n    def dp(idx, take, cnt, val):\\n        if idx == len(nums) or cnt == k:\\n            return val if cnt == k else +math.inf\\n        if take:\\n            return dp(idx + 1, False, cnt + 1, max(val, nums[idx]))\\n        return min(dp(idx + 1, True, cnt, val), dp(idx + 1, False, cnt, val))\\n    return min(dp(0, True, 0, -math.inf), dp(0, False, 0, -math.inf))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef minCapability(self, nums: List[int], k: int) -> int:\\n    def is_valid(capability):\\n        cnt, skip = 0, False\\n        for num in nums:\\n            if skip:\\n                skip = False\\n                continue\\n            if num <= capability:\\n                cnt += 1\\n                skip = True\\n        return cnt >= k\\n\\n    return bisect_left(\\n        a=range(max(nums) + 1), \\n        lo=min(nums),\\n        x=True,\\n        key=lambda val: is_valid(val))\\n```\n```python\\ndef minCapability(self, nums: List[int], k: int) -> int:\\n    @cache\\n    def dp(idx, take, cnt, val):\\n        if idx == len(nums) or cnt == k:\\n            return val if cnt == k else +math.inf\\n        if take:\\n            return dp(idx + 1, False, cnt + 1, max(val, nums[idx]))\\n        return min(dp(idx + 1, True, cnt, val), dp(idx + 1, False, cnt, val))\\n    return min(dp(0, True, 0, -math.inf), dp(0, False, 0, -math.inf))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3149008,
                "title": "java-solution-brute-force-to-optimised-solution-dp-to-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//using dp\\nclass Solution {\\n    //time complexity O(N^2)\\n     long  solve(int ind,int k, int []nums,long dp[][]){\\n        if(k==0)\\n            return 0;\\n        if(ind>=nums.length){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(dp[ind][k]!=-1) {\\n           // System.out.println(\"feuhfhe\");\\n            return dp[ind][k];\\n        }\\n        long notPick=solve(ind+1,k,nums,dp);\\n        long pick=Math.max(nums[ind],solve(ind+2,k-1,nums,dp));\\n        return dp[ind][k]=Math.min(pick,notPick);\\n    }\\n      \\n//binary Search Solution\\n     public int minCapability(int[] nums, int k) {\\n      // time complexity O(nlogn)\\n        int left=1;\\n        int right=(int)1e9;\\n        while(left<right){\\n            int mid=(left+right)/2;\\n            int take=0;\\n            for(int i=0;i<nums.length;){\\n                if(nums[i]<=mid){\\n                    take++;\\n                    i+=2;\\n                }\\n                else{\\n                    i++;\\n                }\\n\\n            }\\n            if(take>=k){\\n\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//using dp\\nclass Solution {\\n    //time complexity O(N^2)\\n     long  solve(int ind,int k, int []nums,long dp[][]){\\n        if(k==0)\\n            return 0;\\n        if(ind>=nums.length){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(dp[ind][k]!=-1) {\\n           // System.out.println(\"feuhfhe\");\\n            return dp[ind][k];\\n        }\\n        long notPick=solve(ind+1,k,nums,dp);\\n        long pick=Math.max(nums[ind],solve(ind+2,k-1,nums,dp));\\n        return dp[ind][k]=Math.min(pick,notPick);\\n    }\\n      \\n//binary Search Solution\\n     public int minCapability(int[] nums, int k) {\\n      // time complexity O(nlogn)\\n        int left=1;\\n        int right=(int)1e9;\\n        while(left<right){\\n            int mid=(left+right)/2;\\n            int take=0;\\n            for(int i=0;i<nums.length;){\\n                if(nums[i]<=mid){\\n                    take++;\\n                    i+=2;\\n                }\\n                else{\\n                    i++;\\n                }\\n\\n            }\\n            if(take>=k){\\n\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148878,
                "title": "monotonic-increasing-function",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\n/*\\nReturn the minimum capability of the robber out of all the possible ways to steal at least k houses. -> here we have to return min of all solution so there is more solution which is bigger than this\\nso the solution is monotonic increasing function.\\nso we can apply binary search\\n*/\\nclass Solution {\\npublic:\\n    int predicateVal(vector<int>& nums, int mid){\\n       int res = 0;\\n\\n       for(int i = 0 ; i < nums.size() ; i++){\\n           if(nums[i] <= mid){\\n               res++;\\n               i++;  // cause we can\\'t take from consequetive houses\\n           }\\n       }\\n       return res;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int lo = *min_element(nums.begin(),nums.end());\\n        int hi = *max_element(nums.begin(),nums.end());\\n        int ans = INT_MAX;\\n        while(lo <= hi){\\n            int mid = (lo+hi)/2;\\n\\n            if(predicateVal(nums,mid) < k){\\n                lo = mid+1;\\n            }\\n            else{\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nReturn the minimum capability of the robber out of all the possible ways to steal at least k houses. -> here we have to return min of all solution so there is more solution which is bigger than this\\nso the solution is monotonic increasing function.\\nso we can apply binary search\\n*/\\nclass Solution {\\npublic:\\n    int predicateVal(vector<int>& nums, int mid){\\n       int res = 0;\\n\\n       for(int i = 0 ; i < nums.size() ; i++){\\n           if(nums[i] <= mid){\\n               res++;\\n               i++;  // cause we can\\'t take from consequetive houses\\n           }\\n       }\\n       return res;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int lo = *min_element(nums.begin(),nums.end());\\n        int hi = *max_element(nums.begin(),nums.end());\\n        int ans = INT_MAX;\\n        while(lo <= hi){\\n            int mid = (lo+hi)/2;\\n\\n            if(predicateVal(nums,mid) < k){\\n                lo = mid+1;\\n            }\\n            else{\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148872,
                "title": "c-solution-using-union-find",
                "content": "# Code\\n```\\nclass Dsu{\\n    public:\\n        int ans;\\n        vector<int> size;\\n        vector<int> head;\\n    \\n        Dsu(int n) :ans{0},size{vector<int>(n)},head{vector<int>(n+1,-1)}{\\n        }\\n    \\n        int getHead(int val){\\n            if(head[val] == -1)\\n                return -1;\\n            if(head[val] == val)\\n                return val;\\n            else return head[val] = getHead(head[val]);\\n        }\\n    \\n        void add(int a){\\n            head[a] = a;\\n            size[a] = 1;\\n            ans++;\\n            \\n            if(a > 0)\\n                join(a,a-1);\\n            join(a,a+1);\\n        }\\n    \\n        void join(int a, int b){\\n            int heada = getHead(a);\\n            int headb = getHead(b);\\n            \\n            if(heada == -1 || headb == -1)\\n                return;\\n            \\n            ans -= (size[heada]+1)/2;\\n            ans -= (size[headb]+1)/2;\\n            \\n            if(size[headb] > size[heada])\\n                swap(heada,headb);\\n            head[headb] = heada;\\n            size[heada] += size[headb];\\n            \\n            ans += (size[heada]+1)/2;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<int>> pairs;\\n        \\n        for(int i=0;i<n;i++){\\n            pairs.emplace_back((vector<int>){nums[i],i});\\n        }\\n        \\n        sort(pairs.begin(),pairs.end());\\n        \\n        Dsu dsu(n);\\n        \\n        for(int i=0;i<n;i++){\\n            dsu.add(pairs[i][1]);\\n            if(dsu.ans >= k)\\n                return pairs[i][0];\\n        }\\n        return pairs.back()[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Dsu{\\n    public:\\n        int ans;\\n        vector<int> size;\\n        vector<int> head;\\n    \\n        Dsu(int n) :ans{0},size{vector<int>(n)},head{vector<int>(n+1,-1)}{\\n        }\\n    \\n        int getHead(int val){\\n            if(head[val] == -1)\\n                return -1;\\n            if(head[val] == val)\\n                return val;\\n            else return head[val] = getHead(head[val]);\\n        }\\n    \\n        void add(int a){\\n            head[a] = a;\\n            size[a] = 1;\\n            ans++;\\n            \\n            if(a > 0)\\n                join(a,a-1);\\n            join(a,a+1);\\n        }\\n    \\n        void join(int a, int b){\\n            int heada = getHead(a);\\n            int headb = getHead(b);\\n            \\n            if(heada == -1 || headb == -1)\\n                return;\\n            \\n            ans -= (size[heada]+1)/2;\\n            ans -= (size[headb]+1)/2;\\n            \\n            if(size[headb] > size[heada])\\n                swap(heada,headb);\\n            head[headb] = heada;\\n            size[heada] += size[headb];\\n            \\n            ans += (size[heada]+1)/2;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<vector<int>> pairs;\\n        \\n        for(int i=0;i<n;i++){\\n            pairs.emplace_back((vector<int>){nums[i],i});\\n        }\\n        \\n        sort(pairs.begin(),pairs.end());\\n        \\n        Dsu dsu(n);\\n        \\n        for(int i=0;i<n;i++){\\n            dsu.add(pairs[i][1]);\\n            if(dsu.ans >= k)\\n                return pairs[i][0];\\n        }\\n        return pairs.back()[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148571,
                "title": "java-binary-search-nlogn",
                "content": "\\nBinary Search on `max` and `min` of possible ans.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        // steal at least k \\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        for (int x : nums) {\\n            max = Math.max(x, max);\\n            min = Math.min(x, min);\\n        }\\n        \\n        int l = min, r = max;\\n        \\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            if (ok(m, nums, k)) r = m;\\n            else l = m;\\n        }\\n        \\n        if (ok(l, nums, k)) return l;\\n        if (ok(r, nums, k)) return r;\\n        \\n        return -1;\\n    }\\n\\n    \\n    private boolean ok(int cap, int[] nums, int k) {\\n        int[][] dp = new int[nums.length][2];\\n        \\n        dp[0][0] = 0;\\n        if (cap >= nums[0]) dp[0][1] = 1;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\\n            if (nums[i] <= cap) {\\n                dp[i][1] = Math.max(dp[i][1], dp[i - 1][0] + 1); \\n            } else {\\n                dp[i][1] = dp[i - 1][1];\\n            }\\n        }\\n        \\n        return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]) >= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        // steal at least k \\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        for (int x : nums) {\\n            max = Math.max(x, max);\\n            min = Math.min(x, min);\\n        }\\n        \\n        int l = min, r = max;\\n        \\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            if (ok(m, nums, k)) r = m;\\n            else l = m;\\n        }\\n        \\n        if (ok(l, nums, k)) return l;\\n        if (ok(r, nums, k)) return r;\\n        \\n        return -1;\\n    }\\n\\n    \\n    private boolean ok(int cap, int[] nums, int k) {\\n        int[][] dp = new int[nums.length][2];\\n        \\n        dp[0][0] = 0;\\n        if (cap >= nums[0]) dp[0][1] = 1;\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\\n            if (nums[i] <= cap) {\\n                dp[i][1] = Math.max(dp[i][1], dp[i - 1][0] + 1); \\n            } else {\\n                dp[i][1] = dp[i - 1][1];\\n            }\\n        }\\n        \\n        return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]) >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148440,
                "title": "javascript-binary-search",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minCapability = function (nums, k) {\\n  let low = Infinity;\\n  let high = -Infinity;\\n  for (const num of nums) {\\n    low = Math.min(low, num);\\n    high = Math.max(high, num);\\n  }\\n\\n  let ans = null;\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    if (isOk(mid, nums, k)) {\\n      ans = mid;\\n      high = mid - 1;\\n    } else {\\n      low = mid + 1;\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\nfunction isOk(target, nums, k) {\\n  let i = 0;\\n  let count = 0;\\n  while (i < nums.length) {\\n    if (nums[i] <= target) {\\n      count++;\\n      i += 2;\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  return count >= k;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minCapability = function (nums, k) {\\n  let low = Infinity;\\n  let high = -Infinity;\\n  for (const num of nums) {\\n    low = Math.min(low, num);\\n    high = Math.max(high, num);\\n  }\\n\\n  let ans = null;\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    if (isOk(mid, nums, k)) {\\n      ans = mid;\\n      high = mid - 1;\\n    } else {\\n      low = mid + 1;\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\nfunction isOk(target, nums, k) {\\n  let i = 0;\\n  let count = 0;\\n  while (i < nums.length) {\\n    if (nums[i] <= target) {\\n      count++;\\n      i += 2;\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  return count >= k;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148202,
                "title": "go-python-o-n-log-m-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc minCapability(nums []int, k int) int {\\n    n := len(nums)\\n\\n\\n    var condition = func(val int) bool{\\n        takes := 0\\n        i := 0\\n        for i<n{\\n            if nums[i] <= val{\\n                i++\\n                takes+=1\\n            }\\n            i++\\n        }\\n        return takes >= k\\n    }\\n\\n    left := 0\\n    right := int(1e12)\\n    for left<=right{\\n        middle := (left+right) / 2\\n        if condition(middle){\\n            right = middle-1\\n        }else{\\n            left = middle+1\\n        }\\n    }\\n    return left\\n}\\n```\\n```python []\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n\\n        def condition(val):\\n            takes = 0\\n            i = 0\\n            while i<n:\\n                if nums[i] <= val:\\n                    i+=1\\n                    takes+=1\\n                i+=1\\n\\n            return takes >= k\\n\\n        left = 0\\n        right = int(1e12)\\n        while left<=right:\\n            middle = (left+right) // 2\\n            if condition(middle):\\n                right = middle-1\\n            else:\\n                left = middle+1\\n        return left\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```golang []\\nfunc minCapability(nums []int, k int) int {\\n    n := len(nums)\\n\\n\\n    var condition = func(val int) bool{\\n        takes := 0\\n        i := 0\\n        for i<n{\\n            if nums[i] <= val{\\n                i++\\n                takes+=1\\n            }\\n            i++\\n        }\\n        return takes >= k\\n    }\\n\\n    left := 0\\n    right := int(1e12)\\n    for left<=right{\\n        middle := (left+right) / 2\\n        if condition(middle){\\n            right = middle-1\\n        }else{\\n            left = middle+1\\n        }\\n    }\\n    return left\\n}\\n```\n```python []\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n\\n        def condition(val):\\n            takes = 0\\n            i = 0\\n            while i<n:\\n                if nums[i] <= val:\\n                    i+=1\\n                    takes+=1\\n                i+=1\\n\\n            return takes >= k\\n\\n        left = 0\\n        right = int(1e12)\\n        while left<=right:\\n            middle = (left+right) // 2\\n            if condition(middle):\\n                right = middle-1\\n            else:\\n                left = middle+1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148132,
                "title": "minimize-the-maximum-typical-bs-on-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    bool istrue(int mid , vector<int> nums , int k)\\n    {\\n        int i = 0;\\n        int count = 0;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] <= mid)\\n            {\\n                count++;\\n                i = i+2;\\n            }\\n            else i = i+1;\\n        }\\n        \\n        return count>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int s = 0;\\n        int e = *max_element(nums.begin() , nums.end());\\n        int ans = -1;\\n        while(s <= e)\\n        {\\n            int mid = e + (s-e)/2;\\n            \\n            if(istrue(mid,nums,k)) \\n            {\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else s = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool istrue(int mid , vector<int> nums , int k)\\n    {\\n        int i = 0;\\n        int count = 0;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] <= mid)\\n            {\\n                count++;\\n                i = i+2;\\n            }\\n            else i = i+1;\\n        }\\n        \\n        return count>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int s = 0;\\n        int e = *max_element(nums.begin() , nums.end());\\n        int ans = -1;\\n        while(s <= e)\\n        {\\n            int mid = e + (s-e)/2;\\n            \\n            if(istrue(mid,nums,k)) \\n            {\\n                ans = mid;\\n                e = mid-1;\\n            }\\n            else s = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147649,
                "title": "binary-search-c-minimize-the-maximum-problem",
                "content": "**1. Using Binary Search find the minimum value, which can be capability of robber to loot atleast \"k\" house.**\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, int k,int mx){\\n        int count=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<=mx){\\n                count++;\\n                i++;\\n            }\\n        }\\n        if(count>=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int start=1;\\n        int end=*max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(isPossible(nums,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, int k,int mx){\\n        int count=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<=mx){\\n                count++;\\n                i++;\\n            }\\n        }\\n        if(count>=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int start=1;\\n        int end=*max_element(nums.begin(),nums.end());\\n        int ans=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(isPossible(nums,k,mid)){\\n                ans=mid;\\n                end=mid-1;\\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147277,
                "title": "java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search - with greedy approach to taking\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI did not figure this during the contest. Then I saw @lee215 \\'s solution. Hard to better his explanation. Robber problem - so I blindly went with DP even though I saw the constraints and the 10^5 and that wont work with DP. That did work for small samples - so hard to get out of it - tried memoization etc., TLE.  Using Binary search you try different values for the min of max with k takes. If that works try a lower number and see if that number would work. And to make sure you dont pick two adjacent houses, increment the loop variable inside the for loop that already increments i automatically - to skip a house. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * log (10^5)) - since each time you traverse n elements, but the number of times you do that is determined by the possible size of bound.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    int rslt;\\n    int[] nums;\\n    int n, k;\\n    public int minCapability(int[] nums, int k) {\\n        this.nums = nums;\\n        this.n = nums.length;\\n        this.k = k;\\n        \\n        int rslt = 0;\\n        int lo = 0, hi = (int)(1e9);\\n        while (lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if (possibleLimit(mid)){\\n                // System.out.println(\"TRUE mid is \" + mid);\\n                rslt = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return rslt;\\n    }\\n    private boolean possibleLimit(int bound){\\n        int take = 0;\\n        for(int i = 0; i < n; i++){\\n            // if number less than bound take else skip ?\\n            if (nums[i] <= bound){\\n                take++;\\n                i++;\\n            }\\n        }\\n        // System.out.println(\"take = \" + take + \" k = \" + k);\\n        if (take >= k){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int rslt;\\n    int[] nums;\\n    int n, k;\\n    public int minCapability(int[] nums, int k) {\\n        this.nums = nums;\\n        this.n = nums.length;\\n        this.k = k;\\n        \\n        int rslt = 0;\\n        int lo = 0, hi = (int)(1e9);\\n        while (lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if (possibleLimit(mid)){\\n                // System.out.println(\"TRUE mid is \" + mid);\\n                rslt = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return rslt;\\n    }\\n    private boolean possibleLimit(int bound){\\n        int take = 0;\\n        for(int i = 0; i < n; i++){\\n            // if number less than bound take else skip ?\\n            if (nums[i] <= bound){\\n                take++;\\n                i++;\\n            }\\n        }\\n        // System.out.println(\"take = \" + take + \" k = \" + k);\\n        if (take >= k){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147127,
                "title": "python-clean-solution-binary-search",
                "content": "```\\ndef minCapability(self, nums: List[int], k: int) -> int:\\n\\tdef valid(x, k0=k, p=-2):\\n\\t\\tfor i, n in enumerate(nums):\\n\\t\\t\\tif n<=x and p+1!=i:\\n\\t\\t\\t\\tk0, p = k0-1, i\\n\\t\\t\\tif k0==0:\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\t# valid function used to check whether \\'x\\' can result \\'k\\' elements in nums\\n\\n\\tlo, hi = min(nums), max(nums)\\n\\twhile(lo<hi):\\n\\t\\tmid = (lo+hi)//2\\n\\t\\tif valid(mid):\\n\\t\\t\\thi = mid\\n\\t\\telse:\\n\\t\\t\\tlo = mid+1\\n\\treturn lo\\n```",
                "solutionTags": [],
                "code": "```\\ndef minCapability(self, nums: List[int], k: int) -> int:\\n\\tdef valid(x, k0=k, p=-2):\\n\\t\\tfor i, n in enumerate(nums):\\n\\t\\t\\tif n<=x and p+1!=i:\\n\\t\\t\\t\\tk0, p = k0-1, i\\n\\t\\t\\tif k0==0:\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\t# valid function used to check whether \\'x\\' can result \\'k\\' elements in nums\\n\\n\\tlo, hi = min(nums), max(nums)\\n\\twhile(lo<hi):\\n\\t\\tmid = (lo+hi)//2\\n\\t\\tif valid(mid):\\n\\t\\t\\thi = mid\\n\\t\\telse:\\n\\t\\t\\tlo = mid+1\\n\\treturn lo\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3146972,
                "title": "binary-search-c-cinch-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(vector<int>& nums, int mid, int k){\\n        int n = nums.size();\\n        int i=0;\\n        while(i<n){\\n            if(nums[i] <= mid)\\n                k--, i+=2;\\n            else \\n                i++;\\n            if(k == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int left = 1, right = *max_element(nums.begin(), nums.end());\\n        int ans=INT_MAX;\\n\\n        while(left <= right){\\n            int mid = (left+right)/2;\\n            if(solve(nums, mid, k)){\\n                ans = min(ans, mid);\\n                right = mid-1;\\n            }\\n            else \\n                left = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool solve(vector<int>& nums, int mid, int k){\\n        int n = nums.size();\\n        int i=0;\\n        while(i<n){\\n            if(nums[i] <= mid)\\n                k--, i+=2;\\n            else \\n                i++;\\n            if(k == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int left = 1, right = *max_element(nums.begin(), nums.end());\\n        int ans=INT_MAX;\\n\\n        while(left <= right){\\n            int mid = (left+right)/2;\\n            if(solve(nums, mid, k)){\\n                ans = min(ans, mid);\\n                right = mid-1;\\n            }\\n            else \\n                left = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146762,
                "title": "c-beats-100-easy-to-understand",
                "content": "# Approach\\nThe given description can be rephrased as:\\n\"*Given that ***1 <= nums[i] <= $$10^9$$***, we need to find the minimum possible number such that the condition `number of looted houses >= k` is satisfied.*\"\\n\\n---\\n\\n\\n***Linear Approach***\\n- Consider the array arr = `[1,2,3, ....., 10^9]`.\\n- Starting from the first `num`, i.e., `num = 1`, check if the condition `number of looted houses >= k` for each `num` in `arr` is satisfied.\\n- As soon as a `num` is found for which the condition is satisfied, return `num`.\\n\\n---\\n\\n\\n***Binary Approach (Optimal)***\\n- Consider the array `arr = [1,2,3, ....., 10^9]`.\\n- Starting from the middle number, i.e., ` num = (1+10^9)/2`, check if the condition `number of looted houses >= k` is satisfied.\\n- if `number of looted houses < k`, disregard the left half of `arr` as all numbers are smaller on the left of `num` and thus, condition can never be met for them. Check on the right half instead.\\n- As soon as a `num` is found for which the condition is satisfied, return `num`.\\n\\n\\n---\\n\\n\\n# ***Note***: \\nWe needn\\'t explicitly create an array `arr = [1,2,3, ....., 10^9]`. We can just play with numbers between 1 and $$10^9$$ instead.\\n\\n---\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n//Function to check if a number from arr satisifies the condition\\n    bool helper(vector<int> &nums, int k, int num){\\n        int i = 0, n = nums.size();\\n        while(i < n){\\n            if(nums[i] <= num){\\n                k--;\\n                i += 2;\\n            }else i++;\\n\\n//if k==0, condition is met and we return true for the given number \\n            if(!k) return true;\\n        }\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n//low is the first number in arr\\n//high is the last number in arr\\n        int low = 1, high = 1e9;\\n\\n//initially \\'high\\' satisfies the condition\\n        int ans = high;\\n\\n//binary search\\n        while(low <= high){\\n            int mid = (low+high)/2;\\n            if(helper(nums,k, mid)){//check if the middle number satisfies the condition\\n                ans = (ans,mid);\\n                high = mid-1;\\n            }else low = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Please upvote if it helped you!!! Cheers ;)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n//Function to check if a number from arr satisifies the condition\\n    bool helper(vector<int> &nums, int k, int num){\\n        int i = 0, n = nums.size();\\n        while(i < n){\\n            if(nums[i] <= num){\\n                k--;\\n                i += 2;\\n            }else i++;\\n\\n//if k==0, condition is met and we return true for the given number \\n            if(!k) return true;\\n        }\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n//low is the first number in arr\\n//high is the last number in arr\\n        int low = 1, high = 1e9;\\n\\n//initially \\'high\\' satisfies the condition\\n        int ans = high;\\n\\n//binary search\\n        while(low <= high){\\n            int mid = (low+high)/2;\\n            if(helper(nums,k, mid)){//check if the middle number satisfies the condition\\n                ans = (ans,mid);\\n                high = mid-1;\\n            }else low = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146526,
                "title": "simple-binary-search-on-answer-appraoch",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(vector<int>& nums, int k,int mid)\\n{\\n    int c=0;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]<=mid)\\n        {\\n            i++;\\n            c++;\\n            if(c==k)\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n       int low=0;\\n       int ans=0;\\n       int high=*max_element(nums.begin(),nums.end());\\n       while(low<=high)\\n       {\\n           int mid=low+(high-low)/2;\\n           if(check(nums,k,mid))\\n           {\\n               ans=mid;\\n               high=mid-1;\\n           }\\n           else\\n           low=mid+1;\\n       }\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(vector<int>& nums, int k,int mid)\\n{\\n    int c=0;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]<=mid)\\n        {\\n            i++;\\n            c++;\\n            if(c==k)\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n       int low=0;\\n       int ans=0;\\n       int high=*max_element(nums.begin(),nums.end());\\n       while(low<=high)\\n       {\\n           int mid=low+(high-low)/2;\\n           if(check(nums,k,mid))\\n           {\\n               ans=mid;\\n               high=mid-1;\\n           }\\n           else\\n           low=mid+1;\\n       }\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146522,
                "title": "understand-the-solution-from-a-novice-perspective",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is my first solution article. Hope it helps.\\n\\nThere is no chance that I can think of using **Binary Search** to solve this problem during the contest. I tried Dynamic Programming for almost one hour, struggling with balancing the memory and time, and it failed :)  I just hope to share my understanding about the correct solution.\\n\\nThere are three points that are difficult to understand after you read others\\' Binary Search solution:\\n\\n1. Why the result find by BS must be in the arr?\\nThe answer is not very intuitive. Assuming you got a slightly larger value(like 7, which is not in the arr) than the result(5). The value meet the condition, but it won\\'t stop at that value. **I think the essence of the BS is to help us finding the boundary value that meets some certain conditions** (in this problem, finding the smallest upper bound while choosing k unadjacent items from an arr). Meeting condition doesn\\'t stop the search, but getting the boundary value does. The condition in the search process (<= threshold) is actually trying to find the upper bound value **in the arr**.\\n\\n2. Why the greedy works when judging a single case? \\nWhen it comes to the judge function, let\\'s simplify it to another problem: If it\\'s possible to get at least k unadjacent items from the arr while the items\\'value are all less than a threshold. The Greedy works because choosing the value once you find it <= threshold actually leaves more items for later choice and will never make the result worse. \\nFor example:\\n    ```\\n    arr: 2, 3, 5, 1, .....\\n    threshold: 4\\n\\n    ```\\n    choosing the first item: 2, we have to give up the second item: 3. But we have (arr.length-2) items for future choice. Between the first two elements, we can select at most one item. And choosing the second item will left us (arr.length-3) items for future choice. **The result can\\'t be better**. Therefore, the Greedy works.\\n\\n\\n3. How can I think up that kind of solution while contesting?\\nThe most important point. Sorry I don\\'t know either.\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(N*log(M))$$\\nM is the value range of the arr\\nN is the length of the arr\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        // get the min/max value of the arr\\n        int left = nums[0];\\n        int right = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            left = Math.min(left, nums[i]);\\n            right = Math.max(right, nums[i]);\\n        }\\n        // Binary Search\\n        // find the value that meet a condition\\n        while(left < right){\\n            int mid = (left + right) / 2;\\n            if(isValid(nums, k, mid)){\\n                right = mid;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    // the judge function for BS\\n    private boolean isValid(int[] nums, int k, int threshold){\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            // this condition: <= threshold\\n            // actually means: getting the upper bound in the arr\\n            if(nums[i] <= threshold){\\n                count ++;\\n                i++; // take an extra step if use current item\\n            }\\n            if(count == k){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n    arr: 2, 3, 5, 1, .....\\n    threshold: 4\\n\\n    ```\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        // get the min/max value of the arr\\n        int left = nums[0];\\n        int right = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            left = Math.min(left, nums[i]);\\n            right = Math.max(right, nums[i]);\\n        }\\n        // Binary Search\\n        // find the value that meet a condition\\n        while(left < right){\\n            int mid = (left + right) / 2;\\n            if(isValid(nums, k, mid)){\\n                right = mid;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    // the judge function for BS\\n    private boolean isValid(int[] nums, int k, int threshold){\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            // this condition: <= threshold\\n            // actually means: getting the upper bound in the arr\\n            if(nums[i] <= threshold){\\n                count ++;\\n                i++; // take an extra step if use current item\\n            }\\n            if(count == k){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146475,
                "title": "c-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int l = 1, r = 1e9;\\n        while(l < r){\\n            int mid = (l+r)/2;\\n            if(able(nums, k, mid)) r = mid;\\n            else l = mid+1;\\n        }\\n        return l;\\n    }\\n\\n    bool able(vector<int>& nums, int k, int cap){\\n        int cnt = 0;\\n        bool pre = false;\\n        for(auto x:nums){\\n            if(pre) pre = false;\\n            else if(x<=cap){\\n                cnt++;\\n                pre = true;\\n            } \\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int l = 1, r = 1e9;\\n        while(l < r){\\n            int mid = (l+r)/2;\\n            if(able(nums, k, mid)) r = mid;\\n            else l = mid+1;\\n        }\\n        return l;\\n    }\\n\\n    bool able(vector<int>& nums, int k, int cap){\\n        int cnt = 0;\\n        bool pre = false;\\n        for(auto x:nums){\\n            if(pre) pre = false;\\n            else if(x<=cap){\\n                cnt++;\\n                pre = true;\\n            } \\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146456,
                "title": "easy-c-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool func(int k,int mid,vector<int>& nums)\\n    {\\n        int i=0,n=nums.size();\\n        while(i<n)\\n        {\\n            if(nums[i]<=mid)\\n            {k--; \\n            i+=2;}\\n            else\\n            i++;\\n            if(k == 0) \\n            return true;\\n        }\\n        return k == 0;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int s=0;\\n        int e=1e9+1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(func(k,mid,nums))\\n            e=mid;\\n            else\\n            s=mid+1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(int k,int mid,vector<int>& nums)\\n    {\\n        int i=0,n=nums.size();\\n        while(i<n)\\n        {\\n            if(nums[i]<=mid)\\n            {k--; \\n            i+=2;}\\n            else\\n            i++;\\n            if(k == 0) \\n            return true;\\n        }\\n        return k == 0;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int s=0;\\n        int e=1e9+1;\\n        while(s<e)\\n        {\\n            int mid=(s+e)/2;\\n            if(func(k,mid,nums))\\n            e=mid;\\n            else\\n            s=mid+1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146205,
                "title": "c-golang-binary-search",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    bool check(vector<int> &nums, int mid, int k) {\\n        int len = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= mid) \\n                len++;\\n            else {\\n                k -= ceil(len / 2.0);\\n                len = 0;\\n            }\\n        }\\n        k -= ceil(len / 2.0);\\n        return k <= 0;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int low = 0;\\n        // int high = 1e9;\\n        int high = *max_element(nums.begin(), nums.end());\\n        int ans = high;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(check(nums, mid, k)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc check(nums []int, mid, k int) bool {\\n    var length int = 0\\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] <= mid {\\n            length++\\n        } else {\\n            k -= int(math.Ceil(float64(length) / 2.0))\\n            length = 0\\n        }\\n    }\\n    k -= int(math.Ceil(float64(length) / 2.0))\\n    return k <= 0\\n}\\n\\nfunc minCapability(nums []int, k int) int {\\n    var low, high int = 0, 1e9\\n    var ans int = high\\n    for low <= high {\\n        var mid int = low + (high - low) / 2\\n        if check(nums, mid, k) {\\n            if mid < ans {\\n                ans = mid\\n            }\\n            high = mid - 1\\n        } else {\\n            low = mid + 1\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    bool check(vector<int> &nums, int mid, int k) {\\n        int len = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= mid) \\n                len++;\\n            else {\\n                k -= ceil(len / 2.0);\\n                len = 0;\\n            }\\n        }\\n        k -= ceil(len / 2.0);\\n        return k <= 0;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int low = 0;\\n        // int high = 1e9;\\n        int high = *max_element(nums.begin(), nums.end());\\n        int ans = high;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(check(nums, mid, k)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc check(nums []int, mid, k int) bool {\\n    var length int = 0\\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] <= mid {\\n            length++\\n        } else {\\n            k -= int(math.Ceil(float64(length) / 2.0))\\n            length = 0\\n        }\\n    }\\n    k -= int(math.Ceil(float64(length) / 2.0))\\n    return k <= 0\\n}\\n\\nfunc minCapability(nums []int, k int) int {\\n    var low, high int = 0, 1e9\\n    var ans int = high\\n    for low <= high {\\n        var mid int = low + (high - low) / 2\\n        if check(nums, mid, k) {\\n            if mid < ans {\\n                ans = mid\\n            }\\n            high = mid - 1\\n        } else {\\n            low = mid + 1\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146111,
                "title": "binary-search-dp",
                "content": "\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&nums, int cap, int k){\\n        int n=nums.size();\\n        vector<int>dp(n+1,0);\\n        if(nums[0]<=cap)\\n        dp[1]=1;\\n\\n        for(int i=1;i<n;i++){\\n            int notTake=dp[i];\\n            int take=0;\\n            if(i-1>=0 and nums[i]<=cap){\\n                take=1+dp[i-1];\\n            }\\n            \\n\\n            dp[i+1]=max(take,notTake);\\n        }\\n\\n        if(dp[n]>=k) return true;\\n        else return false;\\n\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        int l=1;\\n        int r=1e9;\\n\\n        while(l<=r){\\n            int mid=((l+r)>>1);\\n\\n\\n            if(isValid(nums,mid,k)) r=mid-1;\\n            else l=mid+1;\\n\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&nums, int cap, int k){\\n        int n=nums.size();\\n        vector<int>dp(n+1,0);\\n        if(nums[0]<=cap)\\n        dp[1]=1;\\n\\n        for(int i=1;i<n;i++){\\n            int notTake=dp[i];\\n            int take=0;\\n            if(i-1>=0 and nums[i]<=cap){\\n                take=1+dp[i-1];\\n            }\\n            \\n\\n            dp[i+1]=max(take,notTake);\\n        }\\n\\n        if(dp[n]>=k) return true;\\n        else return false;\\n\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        int l=1;\\n        int r=1e9;\\n\\n        while(l<=r){\\n            int mid=((l+r)>>1);\\n\\n\\n            if(isValid(nums,mid,k)) r=mid-1;\\n            else l=mid+1;\\n\\n        }\\n\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146055,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can try all possible solutions from `Min(nums) - 1` - we can never have it up to `Max(nums)` which we can ever get. Then we can use binary search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n * log(n))$$\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    private static bool CanDo(int[] nums, int k, int min) {\\n        for (int i = 0; i < nums.Length; ++i) \\n            if (nums[i] <= min) {\\n                i += 1;\\n                \\n                if (--k <= 0)\\n                    return true;\\n            }\\n        \\n        return false;\\n    }\\n\\n    public int MinCapability(int[] nums, int k) {\\n        int never = nums.Min() - 1;\\n        int ever = nums.Max();\\n\\n        while ((ever - never) > 1) {\\n            int middle = (never + ever) / 2;\\n\\n            if (CanDo(nums, k, middle))\\n                ever = middle;\\n            else\\n                never = middle;\\n        }    \\n\\n        return ever;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    private static bool CanDo(int[] nums, int k, int min) {\\n        for (int i = 0; i < nums.Length; ++i) \\n            if (nums[i] <= min) {\\n                i += 1;\\n                \\n                if (--k <= 0)\\n                    return true;\\n            }\\n        \\n        return false;\\n    }\\n\\n    public int MinCapability(int[] nums, int k) {\\n        int never = nums.Min() - 1;\\n        int ever = nums.Max();\\n\\n        while ((ever - never) > 1) {\\n            int middle = (never + ever) / 2;\\n\\n            if (CanDo(nums, k, middle))\\n                ever = middle;\\n            else\\n                never = middle;\\n        }    \\n\\n        return ever;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146023,
                "title": "solution",
                "content": "```C++ []\\nstatic const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();\\n\\ntypedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;\\ntypedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;\\ntypedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;\\ntypedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;\\n\\ntemplate<typename A> string to_string(A* ptr) { stringstream ss; ss << \"0x\" << std::setw(16) << std::setfill (\\'0\\') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }\\nstring to_string(char c) { return ((string)\"\\'\"+c)+ \"\\'\"; }\\ntemplate <typename A, typename B> string to_string(pair<A, B> p);\\ntemplate <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);\\ntemplate <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);\\nstring to_string(const string& s) { return \\'\"\\' + s + \\'\"\\'; }\\nstring to_string(const char* s) { return to_string((string) s); }\\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\\nstring to_string(vector<bool> v) {\\n    bool first = true; string res = \"{\";\\n\\tfor (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += \", \"; } first = false; res += to_string(v[i]); }\\n\\tres += \"}\"; return res;\\n}\\ntemplate <size_t N> string to_string(bitset<N> v) { string res = \"\"; for (size_t i = 0; i < N; i++) { res += static_cast<char>(\\'0\\' + v[i]); } return res; }\\ntemplate <typename A> string to_string(A v) {\\n\\tbool first = true; string res = \"{\";\\n\\tfor (const auto &x : v) {\\n\\t\\tif (!first) { res += \", \"; }\\n\\t\\tfirst = false; res += to_string(x);\\n\\t}\\n\\tres += \"}\"; return res;\\n}\\ntemplate <typename A, typename B> string to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\\ntemplate <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\"; }\\ntemplate <typename A, typename B, typename C, typename D>\\nstring to_string(tuple<A, B, C, D> p) { return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\"; }\\nvoid debug_out() { cout << endl; }\\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << \" \" << to_string(H); debug_out(T...); }\\n\\ninline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }\\ninline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }\\n\\ntemplate<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }\\ntemplate<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }\\n\\ntemplate<typename T>\\ninline T true_mod(T A, T B)\\n{\\n    assert(B>=1);\\n    A%=B;\\n    if(A<0) A+=B;\\n    return A;\\n}\\n\\ntemplate<typename T>\\ninline T div_down(T A, T B)\\n{\\n    return (A-true_mod(A,B))/B;\\n}\\n\\ntemplate<typename T>\\ninline T div_up(T A, T B)\\n{\\n    return div_down(A+B-1, B);\\n}\\n\\nclass Solution {\\n    bool ok(int x, vector<int>& a, int k) {\\n        bool prev=false;\\n        int cnt=0;\\n        for(int aa: a) {\\n            bool can_take=(aa<=x && !prev);   \\n            \\n            cnt+=can_take;\\n            prev=can_take;\\n        }\\n        return cnt>=k;\\n    }\\npublic:\\n    int minCapability(vector<int>& a, int k) {\\n        int l=0, r=1e9+100;\\n        while(l<r) {\\n            int m=(l+r+0)/2;\\n            \\n            if(ok(m, a, k)) r=m;\\n            else      l=m+1;\\n        \\n        }\\n        assert(l==r);\\n        return l;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        if k ==1:\\n            return min(nums)\\n        if k == (len(nums) + 1 ) // 2:\\n            if len(nums) % 2 == 1:\\n                return max(nums[::2])\\n            return min(max(nums[::2]), max(nums[1::2]))\\n        ix = sorted(range(len(nums)), key = nums.__getitem__)\\n        t = [0]*(len(nums)+1)\\n        x = k\\n        for i in ix:\\n            t[i] = t[i+1] + t[i-1] + 1\\n            if t[i] > 1:\\n                y = ((t[i-1]%2)+1) + 4 *((t[i+1]%2)+1)\\n                if y == 5:\\n                    x -= 1\\n                if t[i-1]:\\n                    t[i-t[i-1]] = t[i]\\n                if t[i+1]:\\n                    t[i+t[i+1]] = t[i]\\n            else:\\n                x -= 1\\n            if x == 0:\\n                return nums[i]\\n        \\n        return 0\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int min = nums[0], max = nums[0];\\n        for(int num : nums) {\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n        int l = min, r = max;\\n        while(l < r) {\\n            int taken = 0, mid = (l + r) / 2;\\n            for(int i = 0; i < nums.length; i ++) {\\n                if(nums[i] <= mid) {\\n                    taken++;\\n                    i++;\\n                }\\n            }\\n            if(taken >= k) {\\n                r = mid;\\n            }\\n            else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstatic const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();\\n\\ntypedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;\\ntypedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;\\ntypedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;\\ntypedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;\\n\\ntemplate<typename A> string to_string(A* ptr) { stringstream ss; ss << \"0x\" << std::setw(16) << std::setfill (\\'0\\') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }\\nstring to_string(char c) { return ((string)\"\\'\"+c)+ \"\\'\"; }\\ntemplate <typename A, typename B> string to_string(pair<A, B> p);\\ntemplate <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);\\ntemplate <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);\\nstring to_string(const string& s) { return \\'\"\\' + s + \\'\"\\'; }\\nstring to_string(const char* s) { return to_string((string) s); }\\nstring to_string(bool b) { return (b ? \"true\" : \"false\"); }\\nstring to_string(vector<bool> v) {\\n    bool first = true; string res = \"{\";\\n\\tfor (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += \", \"; } first = false; res += to_string(v[i]); }\\n\\tres += \"}\"; return res;\\n}\\ntemplate <size_t N> string to_string(bitset<N> v) { string res = \"\"; for (size_t i = 0; i < N; i++) { res += static_cast<char>(\\'0\\' + v[i]); } return res; }\\ntemplate <typename A> string to_string(A v) {\\n\\tbool first = true; string res = \"{\";\\n\\tfor (const auto &x : v) {\\n\\t\\tif (!first) { res += \", \"; }\\n\\t\\tfirst = false; res += to_string(x);\\n\\t}\\n\\tres += \"}\"; return res;\\n}\\ntemplate <typename A, typename B> string to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\\ntemplate <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\"; }\\ntemplate <typename A, typename B, typename C, typename D>\\nstring to_string(tuple<A, B, C, D> p) { return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\"; }\\nvoid debug_out() { cout << endl; }\\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << \" \" << to_string(H); debug_out(T...); }\\n\\ninline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }\\ninline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }\\n\\ntemplate<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }\\ntemplate<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }\\n\\ntemplate<typename T>\\ninline T true_mod(T A, T B)\\n{\\n    assert(B>=1);\\n    A%=B;\\n    if(A<0) A+=B;\\n    return A;\\n}\\n\\ntemplate<typename T>\\ninline T div_down(T A, T B)\\n{\\n    return (A-true_mod(A,B))/B;\\n}\\n\\ntemplate<typename T>\\ninline T div_up(T A, T B)\\n{\\n    return div_down(A+B-1, B);\\n}\\n\\nclass Solution {\\n    bool ok(int x, vector<int>& a, int k) {\\n        bool prev=false;\\n        int cnt=0;\\n        for(int aa: a) {\\n            bool can_take=(aa<=x && !prev);   \\n            \\n            cnt+=can_take;\\n            prev=can_take;\\n        }\\n        return cnt>=k;\\n    }\\npublic:\\n    int minCapability(vector<int>& a, int k) {\\n        int l=0, r=1e9+100;\\n        while(l<r) {\\n            int m=(l+r+0)/2;\\n            \\n            if(ok(m, a, k)) r=m;\\n            else      l=m+1;\\n        \\n        }\\n        assert(l==r);\\n        return l;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        if k ==1:\\n            return min(nums)\\n        if k == (len(nums) + 1 ) // 2:\\n            if len(nums) % 2 == 1:\\n                return max(nums[::2])\\n            return min(max(nums[::2]), max(nums[1::2]))\\n        ix = sorted(range(len(nums)), key = nums.__getitem__)\\n        t = [0]*(len(nums)+1)\\n        x = k\\n        for i in ix:\\n            t[i] = t[i+1] + t[i-1] + 1\\n            if t[i] > 1:\\n                y = ((t[i-1]%2)+1) + 4 *((t[i+1]%2)+1)\\n                if y == 5:\\n                    x -= 1\\n                if t[i-1]:\\n                    t[i-t[i-1]] = t[i]\\n                if t[i+1]:\\n                    t[i+t[i+1]] = t[i]\\n            else:\\n                x -= 1\\n            if x == 0:\\n                return nums[i]\\n        \\n        return 0\\n```\n```Java []\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int min = nums[0], max = nums[0];\\n        for(int num : nums) {\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n        int l = min, r = max;\\n        while(l < r) {\\n            int taken = 0, mid = (l + r) / 2;\\n            for(int i = 0; i < nums.length; i ++) {\\n                if(nums[i] <= mid) {\\n                    taken++;\\n                    i++;\\n                }\\n            }\\n            if(taken >= k) {\\n                r = mid;\\n            }\\n            else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3145955,
                "title": "java-binary-search-greedy-fast-and-concise-solution-with-explanation",
                "content": "1. Intuitively we know `1` is the min of all the capabilities for the robber to steal the houses\\n1. Assuming the capability to be `1`, following conditions has to be satisfied\\n\\t1. Should be able to rob at least `k` houses\\n\\t1. All `k` houses should not be adjacent\\n\\t1. All the `k` houses should be less than or equal to `1`\\n1. If capability `1` is not possible, we move to the next number i.e. `2` and continue till `10^9`.\\n1. If you see here the we are doing a linear search from `1` to `10^9`, this can be improved using binary search\\n1. With binary search, we start with mid number, and for any mid number I must satisfy all the above conditions.\\n\\t1. If it is satisfied, that means I can hope to bring down the capability and search in the 1st half by making `hi` to `mid`\\n\\t1. Else, if it is not possible then, I should search in the second half by making `lo` as `mid+1`\\n\\n\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int lo = 1, hi = 1000000000;\\n        while (lo < hi) {\\n            int x = lo+(hi-lo)/2;\\n\\t\\t\\t// if it is possible for x, then we hope to find a minimum x in the 1st half that has capability to steal atleast k houses\\n            if (possibleNoOfHouses(x, nums) >= k)\\n                hi = x;\\n\\t\\t\\t// Else, we search in the second half\\n            else\\n                lo = x+1;\\n        }\\n        return lo;\\n    }\\n    \\n    int possibleNoOfHouses(int x, int[] nums) {\\n        int prevSteal = -2;\\n\\t\\t// track number of houses can be stolen\\n        int canBeStolen = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t// ignore the ones that are greater than x, as our current maximum capability is x\\n            if (nums[i] > x)\\n                continue;\\n\\t\\t\\t// if adjacent skip and move to next\\n            if (prevSteal+1 == i)\\n                continue;\\n            canBeStolen++;\\n            prevSteal = i;\\n        }\\n        return canBeStolen;\\n    }\\n}\\n```\\n\\n`M` being our search space from `1` to `10^9`, `N` being the number of houses\\nTime complexity: `O(N*logM)`\\nSpace complexity: `O(1)`",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int lo = 1, hi = 1000000000;\\n        while (lo < hi) {\\n            int x = lo+(hi-lo)/2;\\n\\t\\t\\t// if it is possible for x, then we hope to find a minimum x in the 1st half that has capability to steal atleast k houses\\n            if (possibleNoOfHouses(x, nums) >= k)\\n                hi = x;\\n\\t\\t\\t// Else, we search in the second half\\n            else\\n                lo = x+1;\\n        }\\n        return lo;\\n    }\\n    \\n    int possibleNoOfHouses(int x, int[] nums) {\\n        int prevSteal = -2;\\n\\t\\t// track number of houses can be stolen\\n        int canBeStolen = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t// ignore the ones that are greater than x, as our current maximum capability is x\\n            if (nums[i] > x)\\n                continue;\\n\\t\\t\\t// if adjacent skip and move to next\\n            if (prevSteal+1 == i)\\n                continue;\\n            canBeStolen++;\\n            prevSteal = i;\\n        }\\n        return canBeStolen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145836,
                "title": "short-concise-binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &nums, int k) {\\n        int cnt = 0, n = nums.size(), i = 0;\\n        while(i < n) {\\n            if(nums[i] <= x) cnt++, i += 2;\\n            else i++;\\n        }\\n        return cnt >= k;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int s = 0, e = 1e9, ans = INT_MAX;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, nums, k)) e = m - 1, ans = m;\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &nums, int k) {\\n        int cnt = 0, n = nums.size(), i = 0;\\n        while(i < n) {\\n            if(nums[i] <= x) cnt++, i += 2;\\n            else i++;\\n        }\\n        return cnt >= k;\\n    }\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int s = 0, e = 1e9, ans = INT_MAX;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, nums, k)) e = m - 1, ans = m;\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145564,
                "title": "binary-search-solution-c",
                "content": "# Complexity\\n- Time complexity: O(n*logn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    \\n    bool capable(int mid,vector<int> &nums,int k) {\\n        int i = 0;\\n        int n = nums.size();\\n        while(i < n) {\\n            if(nums[i] <= mid) {\\n                k--;\\n                i += 2;\\n            } else {\\n                i+=1;\\n            }\\n\\n            if(k == 0)  return true;\\n        }\\n        return k == 0;\\n    }\\n    \\n    int minCapability(vector<int>& nums, int k) {\\n       \\n        int low = 1;\\n        int high = 1e9;\\n        while(low < high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(capable(mid,nums,k)) high = mid;\\n            else low = mid+1;\\n        }\\n\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    \\n    bool capable(int mid,vector<int> &nums,int k) {\\n        int i = 0;\\n        int n = nums.size();\\n        while(i < n) {\\n            if(nums[i] <= mid) {\\n                k--;\\n                i += 2;\\n            } else {\\n                i+=1;\\n            }\\n\\n            if(k == 0)  return true;\\n        }\\n        return k == 0;\\n    }\\n    \\n    int minCapability(vector<int>& nums, int k) {\\n       \\n        int low = 1;\\n        int high = 1e9;\\n        while(low < high) {\\n            int mid = low + (high-low)/2;\\n\\n            if(capable(mid,nums,k)) high = mid;\\n            else low = mid+1;\\n        }\\n\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145347,
                "title": "java-similar-questions-template",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse template: https://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template-solved-many-problems\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConduct binary search for solution space.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int max = 0;\\n        for(int n: nums){\\n            max = Math.max(max, n);\\n        }\\n\\n        int left = 0; \\n        int right = max;\\n\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(capable(nums, 0, k, mid) || capable(nums, 1, k, mid)){\\n                right = mid;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    public boolean capable(int[] nums, int start, int k, int cap){\\n        int count = 0;\\n        int i = start; //start from 0th or 1st house;\\n\\n        //greedy\\n        while(i < nums.length){\\n            if(nums[i] <= cap){\\n                count++;\\n                i += 2;\\n            }\\n            else{\\n                i++;\\n            }\\n            if(count == k){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minCapability(int[] nums, int k) {\\n        int max = 0;\\n        for(int n: nums){\\n            max = Math.max(max, n);\\n        }\\n\\n        int left = 0; \\n        int right = max;\\n\\n        while(left < right){\\n            int mid = left + (right - left) / 2;\\n            if(capable(nums, 0, k, mid) || capable(nums, 1, k, mid)){\\n                right = mid;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    public boolean capable(int[] nums, int start, int k, int cap){\\n        int count = 0;\\n        int i = start; //start from 0th or 1st house;\\n\\n        //greedy\\n        while(i < nums.length){\\n            if(nums[i] <= cap){\\n                count++;\\n                i += 2;\\n            }\\n            else{\\n                i++;\\n            }\\n            if(count == k){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145270,
                "title": "python-greedy-repeatedly-remove-highest-amount",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMany talented individuals have shared brilliant binary search solutions for this problem, but we can also solve it using a greedy approach. \\n(hope i\\'m not wrong)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem could be intepreted as follows:\\n\\'**given an array, we remove highest amount repeatly until remaining array doesn\\'t have at least k valid selections**\\', \\nthe key point is given the length of an array, we can calculate how many numbers can be selected from it. And the capability could be the maximum number of remaining array.\\n\\n- Basically, for an array with size n, there\\'re (n+1) / 2 valid selections.\\n\\n- Once a number is removed from original array, it could be split into 2 array. \\nFor example, \\n`1 2 8 4 3 6 5` --> valid selection is 4\\nafter we remove highest amount `8`, \\nremaining array is `1 2`  and `4 3 6 5`, the reason for split array into two is, we can then choose both `2` and `4` as there\\'s a number in between before.\\n\\nAs a result, the remaining arrays have capacities of 1 (for an array size of 2, capacity = (2 + 1) / 2 = 1) and 2 (for an array size of 4, capacity = (4 + 1) / 2 = 2) separately.\\n\\n\\n- There are some edge cases that need to be addressed, such as removing the first/last element of the array, or when the array only contains one element.\\n\\nIn summary, we can break down into few steps:\\n\\n1. Sorted number by it\\'s value and index. (so that we know position of  highest number in remaining arrays)\\n2. Set up a sorted list, each element inside represents [start_idx, end_idx], which means from start_idx to end_idx(inclusive) are all available houses.\\n3. Calculate capacity\\n4. Pop last from sorted array, to get index that need to be removed\\n5. Adjust remaining array, and calculate corresponding capacity.\\n6. If new capacity less than k, means we cannot remove current number, then that\\'s the answer we want!\\n7. Go back to step 4.\\n\\n\\nin this way we can repeatedly remove highest amount to minimize capacity, and in the same time check there\\'s still at least k valid house to be stole.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n\\n- There could be some redundant code, but it can make the code more understandable.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        arr = []\\n        \\n        for i,n in enumerate(nums):\\n            arr.append((n,i))\\n        arr.sort()\\n        \\n        def getValid(start,end):\\n            count = end-start + 1\\n            return (count+1) // 2\\n        \\n        segments = SortedList([[0,len(nums)-1]])\\n        can_pick_up = getValid(segments[0][0],segments[0][1])\\n        \\n        while True:\\n            num,idx = arr.pop()\\n            target_idx = segments.bisect_left([idx,float(\"inf\")]) - 1\\n            \\n            seg_start,seg_end = segments[target_idx]\\n            can_pick_up -= getValid(seg_start,seg_end)\\n            segments.remove([seg_start,seg_end])\\n            if idx == seg_start and idx == seg_end:\\n                # no need to insert new segment\\n                pass\\n            elif idx == seg_start:\\n                can_pick_up += getValid(idx+1,seg_end)\\n                segments.add([idx+1,seg_end])\\n            elif idx == seg_end:\\n                can_pick_up += getValid(seg_start,idx-1)\\n                segments.add([seg_start,idx-1])\\n            else:\\n                can_pick_up += getValid(seg_start,idx-1)\\n                can_pick_up += getValid(idx+1,seg_end)\\n                segments.add([seg_start,idx-1])\\n                segments.add([idx+1,seg_end])\\n            \\n            if can_pick_up < k:\\n                return num\\n                \\n        return -1\\n                \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        arr = []\\n        \\n        for i,n in enumerate(nums):\\n            arr.append((n,i))\\n        arr.sort()\\n        \\n        def getValid(start,end):\\n            count = end-start + 1\\n            return (count+1) // 2\\n        \\n        segments = SortedList([[0,len(nums)-1]])\\n        can_pick_up = getValid(segments[0][0],segments[0][1])\\n        \\n        while True:\\n            num,idx = arr.pop()\\n            target_idx = segments.bisect_left([idx,float(\"inf\")]) - 1\\n            \\n            seg_start,seg_end = segments[target_idx]\\n            can_pick_up -= getValid(seg_start,seg_end)\\n            segments.remove([seg_start,seg_end])\\n            if idx == seg_start and idx == seg_end:\\n                # no need to insert new segment\\n                pass\\n            elif idx == seg_start:\\n                can_pick_up += getValid(idx+1,seg_end)\\n                segments.add([idx+1,seg_end])\\n            elif idx == seg_end:\\n                can_pick_up += getValid(seg_start,idx-1)\\n                segments.add([seg_start,idx-1])\\n            else:\\n                can_pick_up += getValid(seg_start,idx-1)\\n                can_pick_up += getValid(idx+1,seg_end)\\n                segments.add([seg_start,idx-1])\\n                segments.add([idx+1,seg_end])\\n            \\n            if can_pick_up < k:\\n                return num\\n                \\n        return -1\\n                \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145239,
                "title": "intuitive-and-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI get the intuition of binary search here as i can guarantee that if i prove for a number that it can\\'t be an answer then all numbers less than that number would also be out of equation hence i divide my answer range in two. now the task left is to write a check function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso to write check function i go greedily in the array and if the number at my current pos is less than mid value for which i am searching than i reduce k and increase i by 2, as soon as you get your k==0 just break and return true, else return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(logn)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nconstant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums,int k,long long mid){\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=mid){\\n                count+=1;\\n                i+=1;\\n            }\\n        }\\n       return count>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        long long end=pow(10,9)+1;\\n        long long start=0;\\n        while(start<=end){\\n            long long mid=(start+end)/2;\\n            if(check(nums,k,mid)){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& nums,int k,long long mid){\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=mid){\\n                count+=1;\\n                i+=1;\\n            }\\n        }\\n       return count>=k;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        long long end=pow(10,9)+1;\\n        long long start=0;\\n        while(start<=end){\\n            long long mid=(start+end)/2;\\n            if(check(nums,k,mid)){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145213,
                "title": "c-faster-than-100-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &nums,int k,int mid){\\n        for(int i=0;i<nums.size() && k>0 ;i++){\\n            if(nums[i]<=mid){\\n                i++;\\n                k--;\\n            }\\n          \\n        }\\n        if(k==0)return true;\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int low=0;\\n        int high=1e9;\\n        int ans=0;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(check(nums,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &nums,int k,int mid){\\n        for(int i=0;i<nums.size() && k>0 ;i++){\\n            if(nums[i]<=mid){\\n                i++;\\n                k--;\\n            }\\n          \\n        }\\n        if(k==0)return true;\\n        return false;\\n    }\\n    int minCapability(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int low=0;\\n        int high=1e9;\\n        int ans=0;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(check(nums,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145206,
                "title": "python-binary-search-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWrite a function to check if it is possible to rob 2 non-adjacent houses for a `capability` equal to a given value. Then define a lower bound and upper bound of 1 and maximum element respectively and binary search the minimum such capability\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        def check(mid: int, k: int) -> bool:\\n            last = -1\\n            for idx in range(len(nums)):\\n                if k > 0 and (last == -1 or last != idx - 1) and nums[idx] <= mid:\\n                    k -= 1; last = idx\\n            return k == 0\\n        \\n        low, high, ans = 1, max(nums), -1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if check(mid, k):\\n                ans, high = mid, mid - 1\\n            else:\\n                low = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Simulation"
                ],
                "code": "```python []\\nclass Solution:\\n    def minCapability(self, nums: List[int], k: int) -> int:\\n        def check(mid: int, k: int) -> bool:\\n            last = -1\\n            for idx in range(len(nums)):\\n                if k > 0 and (last == -1 or last != idx - 1) and nums[idx] <= mid:\\n                    k -= 1; last = idx\\n            return k == 0\\n        \\n        low, high, ans = 1, max(nums), -1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if check(mid, k):\\n                ans, high = mid, mid - 1\\n            else:\\n                low = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145155,
                "title": "c-o-n-log-m-simple-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince there is a threshold `m\\'` such that when `m >= m\\'`, it is always possible to rob at least `k` houses with maximal value `m`. So doing binary search is intuitive.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search + Greedy.\\n\\nWith a given maximal value `m`, we will rob the houses with value `<= m` as long as we can when we visit each house from left to right. Noticing that we can\\'t rob two adjacent houses, we will use a cool-down flag to indicate whether we rob the previous house or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log M), where M is the maximal value in the array nums.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int l = 1, r = *max_element(begin(nums), end(nums));\\n        while (l < r) {\\n            int mid = (r+l)/2;\\n            if (ispossible(nums, mid, k)) { r = mid; }\\n            else                          { l = mid+1; }\\n        }\\n        return r;\\n    }\\n\\n    bool ispossible(vector<int> & A, int m, int k) {\\n        // Return if we can rob k houses with maximal\\n        // value less or equal to m\\n        bool cool = false;  // is cool down or not\\n        int cnt = 0;        // number of robbed houses\\n        for (int & a: A) {\\n            if (cool || a > m) {\\n                // Can\\'t take the current element\\n                // since the previous element is taken or\\n                // a is too large \\n                cool = false;\\n                continue;\\n            }\\n            // greedily take a when it\\'s possible\\n            ++cnt;\\n            cool = true;\\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minCapability(vector<int>& nums, int k) {\\n        int l = 1, r = *max_element(begin(nums), end(nums));\\n        while (l < r) {\\n            int mid = (r+l)/2;\\n            if (ispossible(nums, mid, k)) { r = mid; }\\n            else                          { l = mid+1; }\\n        }\\n        return r;\\n    }\\n\\n    bool ispossible(vector<int> & A, int m, int k) {\\n        // Return if we can rob k houses with maximal\\n        // value less or equal to m\\n        bool cool = false;  // is cool down or not\\n        int cnt = 0;        // number of robbed houses\\n        for (int & a: A) {\\n            if (cool || a > m) {\\n                // Can\\'t take the current element\\n                // since the previous element is taken or\\n                // a is too large \\n                cool = false;\\n                continue;\\n            }\\n            // greedily take a when it\\'s possible\\n            ++cnt;\\n            cool = true;\\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1788386,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788899,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788529,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788692,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788730,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1789015,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788489,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788429,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788633,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788613,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788386,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788899,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788529,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788692,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788730,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1789015,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788489,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788429,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788633,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 1788613,
                "content": [
                    {
                        "username": "sim0ns",
                        "content": "IMO prob shouldn\\'t be a medium, or if you want to keep medium, accept 2d dp."
                    },
                    {
                        "username": "stefan1096",
                        "content": "Binary search solution is similar to koko eating bananas.Once you are familiar with this pattern,it is not that hard."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "dp costs $$ N*K $$ which is alsmot $$ N^2 $$ (10<sup>10</sup>), not ideal apparently."
                    },
                    {
                        "username": "shivansh961",
                        "content": "True, 2d dp threw TLE, and couldn\\'t optimize it"
                    },
                    {
                        "username": "sim0ns",
                        "content": "[@CODEX47](/CODEX47) same haha unfortunate."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Yeah bro i was also trying 2d dp, From last 1hr."
                    },
                    {
                        "username": "msreenivasaprasad",
                        "content": "NEVER UNDERESTIMATE BINARY SEARCH !!!!!!!"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I didn\\'t realize for even once that it would require BS to solve this.\\n"
                    },
                    {
                        "username": "shivansh157",
                        "content": "Binary Search never ceases to amaze me."
                    },
                    {
                        "username": "mchim",
                        "content": "I understimated Binary Search."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "### There are 3 layers to crack this problem : \n\n1. Understand that DP will fail since number of states is quadratic.\n\n2. Think of binary search approach since its min-max.\n\n3. Realise that we can greedily check if a given capability is possible and based on it, shrink the search space for binary search."
                    },
                    {
                        "username": "harshakokkanti001",
                        "content": "can you please elaborate on point 1"
                    },
                    {
                        "username": "KingCoderHK",
                        "content": "How do people do this in 5 min!?"
                    },
                    {
                        "username": "boopathym",
                        "content": "For sure, they are just reading bold and italic words [ maybe checking constraint ] based on that they might be pulling the template code and edit it as per the problem.  "
                    },
                    {
                        "username": "sranbir304",
                        "content": "Insane people... I took 5 min to read a question only\\n"
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "How to know if this is a Binary Search Problem?"
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I would say there are two criteria for a problem to have a Binary Search solution:\\n\\n- You are searching for either a maximum value or a minimum value\\n- You can ask the question \"Is it possible with `x`?\", and get the yes/no answer in `O(n)` time "
                    },
                    {
                        "username": "Sagar_Sahu",
                        "content": "[@sudhakargoutam](/sudhakargoutam) okay, Got it"
                    },
                    {
                        "username": "sudhakargoutam",
                        "content": "if question asks you for min among max or vice versa , its mostly binary search (unless it needs to be solved in O(n) time)"
                    },
                    {
                        "username": "CODEX47",
                        "content": "There are similar problems on leetcode and although i have done them, I still couldn\\'t figure out"
                    },
                    {
                        "username": "zhuragat",
                        "content": "if there is a constraint 10^5 then most probably it\\'s a binary search/sorting problem. But if you don\\'t know constraints Idk how to know"
                    },
                    {
                        "username": "shrey_thakur09",
                        "content": "Same Doubt"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Can anyone walk through the thinking process and enlighten me how you come up with BS solution? This looks so much like DP to me and I didn't even think once about other approach, even after i saw TLE. I would never ever ever come up with this idea..."
                    },
                    {
                        "username": "sranbir304",
                        "content": "Just remember minimization maximization problems are solved with BS in most of the cases. Only tough Part in such problems is to make logic for handler fun"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who completed the problem, bother to offer a hint (not solution) that is not the 2D dp we already know?"
                    },
                    {
                        "username": "RjRahul003",
                        "content": "[@VILGAX5410](/VILGAX5410)  It\\'s binary search problem"
                    },
                    {
                        "username": "VILGAX5410",
                        "content": "its a typical dp problem of take,not take-type..the methods which we follow in subsequences. \\nso, the answer would be minimum(take,not_take)\\ni is the current index which you are at;\\nk is the number of elements which you have to take from now;\\ntake==max(current_elt, solve(i+2,k-1));\\nnot_take=solve(i+1,k);\\n\\nand finally min(take,not_take)\\n\\nanyways you\\'ll end up in TLE. :)"
                    }
                ]
            },
            {
                "id": 2022378,
                "content": [
                    {
                        "username": "jje-",
                        "content": "It broke the rule House Robber problem in LC can be solved by DP."
                    },
                    {
                        "username": "Mrdagger",
                        "content": "hi\\nCan anyone please explain that why testcase [4,22,11,14,25] k=3 has expected output as 25 and not 14?\\nActually I\\'m trying to solve this problem with two pointer approach ."
                    },
                    {
                        "username": "zorowin123",
                        "content": "can erveryone help me with the dp solutions? I have seen a few dp solutions although tle, but it lacks the explanation and i am fully confused about it.  i want to pratice my dp mind, my first sight on this problem is to use dp techniques but i can\\'t even implement a tle solutions, thx in advance\\n(I want to understand bottom-up dp)\\n"
                    },
                    {
                        "username": "prashik0",
                        "content": "is it only me who solved it using union find and sorting?"
                    },
                    {
                        "username": "lemaun",
                        "content": "Input: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\\n\\nare\\'nt 6 ways?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "What are the 7 ways a robber can rob the house in example 2? I can only come up with 6\\n"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "nvm i figured it out, it says that the robber can steal from at least k houses. so in example two, it is possible to steal from 3 houses i.e. (2, 9, 1)"
                    },
                    {
                        "username": "blahbalh",
                        "content": "For the given example 2, how can there be 7 ways to rob houses when n = 5, and k = 2?\\nShouldn\\'t it be 6 ways? We can rob the houses at indices (0,2), (0,3), (0, 4), (1,3), (1,4), (2,4). What\\'s the 7th way of robbing a house?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "(2, 9, 1)\n"
                    },
                    {
                        "username": "r_y_s",
                        "content": "Because of the \"house robber \" title , the only thing that strikes is DP during the context . But I feel this is one of the good binary search questions on Leetcode ."
                    },
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\n\\n     bool check(vector<int>&a,int k,int mx){\\n         vector<int>dp(a.size()+1,0);\\n         if(a[0]<=mx){\\n             dp[1]=1;\\n         }\\n         int n=a.size();\\n         for(int i=2;i<=n;i++){\\n             dp[i]=dp[i-1];\\n             if(a[i-1]<=mx){\\n                 dp[i]=max(dp[i],1+dp[i-2]);\\n             }\\n         }\\n\\n         if(dp[n]>=k)return true;\\n         else return false;\\n     }\\n    int minCapability(vector<int>& nums, int k) {\\n\\n         int l=1,r=1e9;\\n          int ans=0;\\n         while(l<=r){\\n             int mid=l+(r-l)/2;\\n\\n             if(check(nums,k,mid)){\\n                 ans=mid;\\n                 r=mid-1;\\n             }\\n             else{\\n                 l=mid+1;\\n             }\\n         }\\n     \\n     return ans;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Haaaleuluiggghaaa",
                        "content": "How do you cache this?\\nclass Solution {\\npublic:\\n    int res;\\n    void calMoney(vector<int>& nums, int& k, int i, int prev, priority_queue<int> pq, int curr){\\n        if(i >= nums.size()){\\n            if(curr >= k){\\n                res = min(res, pq.top());\\n            }\\n            return;\\n        }\\n\\n        calMoney(nums, k, i+1, prev, pq, curr);\\n\\n        if(prev == -1 || i-prev > 1){\\n            pq.push(nums[i]);\\n            calMoney(nums, k, i+1, i, pq, curr+1);\\n        }\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        res = INT_MAX;\\n\\n        priority_queue<int> pq;\\n        calMoney(nums, k, 0, -1, pq, 0);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2014086,
                "content": [
                    {
                        "username": "jje-",
                        "content": "It broke the rule House Robber problem in LC can be solved by DP."
                    },
                    {
                        "username": "Mrdagger",
                        "content": "hi\\nCan anyone please explain that why testcase [4,22,11,14,25] k=3 has expected output as 25 and not 14?\\nActually I\\'m trying to solve this problem with two pointer approach ."
                    },
                    {
                        "username": "zorowin123",
                        "content": "can erveryone help me with the dp solutions? I have seen a few dp solutions although tle, but it lacks the explanation and i am fully confused about it.  i want to pratice my dp mind, my first sight on this problem is to use dp techniques but i can\\'t even implement a tle solutions, thx in advance\\n(I want to understand bottom-up dp)\\n"
                    },
                    {
                        "username": "prashik0",
                        "content": "is it only me who solved it using union find and sorting?"
                    },
                    {
                        "username": "lemaun",
                        "content": "Input: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\\n\\nare\\'nt 6 ways?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "What are the 7 ways a robber can rob the house in example 2? I can only come up with 6\\n"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "nvm i figured it out, it says that the robber can steal from at least k houses. so in example two, it is possible to steal from 3 houses i.e. (2, 9, 1)"
                    },
                    {
                        "username": "blahbalh",
                        "content": "For the given example 2, how can there be 7 ways to rob houses when n = 5, and k = 2?\\nShouldn\\'t it be 6 ways? We can rob the houses at indices (0,2), (0,3), (0, 4), (1,3), (1,4), (2,4). What\\'s the 7th way of robbing a house?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "(2, 9, 1)\n"
                    },
                    {
                        "username": "r_y_s",
                        "content": "Because of the \"house robber \" title , the only thing that strikes is DP during the context . But I feel this is one of the good binary search questions on Leetcode ."
                    },
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\n\\n     bool check(vector<int>&a,int k,int mx){\\n         vector<int>dp(a.size()+1,0);\\n         if(a[0]<=mx){\\n             dp[1]=1;\\n         }\\n         int n=a.size();\\n         for(int i=2;i<=n;i++){\\n             dp[i]=dp[i-1];\\n             if(a[i-1]<=mx){\\n                 dp[i]=max(dp[i],1+dp[i-2]);\\n             }\\n         }\\n\\n         if(dp[n]>=k)return true;\\n         else return false;\\n     }\\n    int minCapability(vector<int>& nums, int k) {\\n\\n         int l=1,r=1e9;\\n          int ans=0;\\n         while(l<=r){\\n             int mid=l+(r-l)/2;\\n\\n             if(check(nums,k,mid)){\\n                 ans=mid;\\n                 r=mid-1;\\n             }\\n             else{\\n                 l=mid+1;\\n             }\\n         }\\n     \\n     return ans;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Haaaleuluiggghaaa",
                        "content": "How do you cache this?\\nclass Solution {\\npublic:\\n    int res;\\n    void calMoney(vector<int>& nums, int& k, int i, int prev, priority_queue<int> pq, int curr){\\n        if(i >= nums.size()){\\n            if(curr >= k){\\n                res = min(res, pq.top());\\n            }\\n            return;\\n        }\\n\\n        calMoney(nums, k, i+1, prev, pq, curr);\\n\\n        if(prev == -1 || i-prev > 1){\\n            pq.push(nums[i]);\\n            calMoney(nums, k, i+1, i, pq, curr+1);\\n        }\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        res = INT_MAX;\\n\\n        priority_queue<int> pq;\\n        calMoney(nums, k, 0, -1, pq, 0);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1815432,
                "content": [
                    {
                        "username": "jje-",
                        "content": "It broke the rule House Robber problem in LC can be solved by DP."
                    },
                    {
                        "username": "Mrdagger",
                        "content": "hi\\nCan anyone please explain that why testcase [4,22,11,14,25] k=3 has expected output as 25 and not 14?\\nActually I\\'m trying to solve this problem with two pointer approach ."
                    },
                    {
                        "username": "zorowin123",
                        "content": "can erveryone help me with the dp solutions? I have seen a few dp solutions although tle, but it lacks the explanation and i am fully confused about it.  i want to pratice my dp mind, my first sight on this problem is to use dp techniques but i can\\'t even implement a tle solutions, thx in advance\\n(I want to understand bottom-up dp)\\n"
                    },
                    {
                        "username": "prashik0",
                        "content": "is it only me who solved it using union find and sorting?"
                    },
                    {
                        "username": "lemaun",
                        "content": "Input: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\\n\\nare\\'nt 6 ways?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "What are the 7 ways a robber can rob the house in example 2? I can only come up with 6\\n"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "nvm i figured it out, it says that the robber can steal from at least k houses. so in example two, it is possible to steal from 3 houses i.e. (2, 9, 1)"
                    },
                    {
                        "username": "blahbalh",
                        "content": "For the given example 2, how can there be 7 ways to rob houses when n = 5, and k = 2?\\nShouldn\\'t it be 6 ways? We can rob the houses at indices (0,2), (0,3), (0, 4), (1,3), (1,4), (2,4). What\\'s the 7th way of robbing a house?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "(2, 9, 1)\n"
                    },
                    {
                        "username": "r_y_s",
                        "content": "Because of the \"house robber \" title , the only thing that strikes is DP during the context . But I feel this is one of the good binary search questions on Leetcode ."
                    },
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\n\\n     bool check(vector<int>&a,int k,int mx){\\n         vector<int>dp(a.size()+1,0);\\n         if(a[0]<=mx){\\n             dp[1]=1;\\n         }\\n         int n=a.size();\\n         for(int i=2;i<=n;i++){\\n             dp[i]=dp[i-1];\\n             if(a[i-1]<=mx){\\n                 dp[i]=max(dp[i],1+dp[i-2]);\\n             }\\n         }\\n\\n         if(dp[n]>=k)return true;\\n         else return false;\\n     }\\n    int minCapability(vector<int>& nums, int k) {\\n\\n         int l=1,r=1e9;\\n          int ans=0;\\n         while(l<=r){\\n             int mid=l+(r-l)/2;\\n\\n             if(check(nums,k,mid)){\\n                 ans=mid;\\n                 r=mid-1;\\n             }\\n             else{\\n                 l=mid+1;\\n             }\\n         }\\n     \\n     return ans;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Haaaleuluiggghaaa",
                        "content": "How do you cache this?\\nclass Solution {\\npublic:\\n    int res;\\n    void calMoney(vector<int>& nums, int& k, int i, int prev, priority_queue<int> pq, int curr){\\n        if(i >= nums.size()){\\n            if(curr >= k){\\n                res = min(res, pq.top());\\n            }\\n            return;\\n        }\\n\\n        calMoney(nums, k, i+1, prev, pq, curr);\\n\\n        if(prev == -1 || i-prev > 1){\\n            pq.push(nums[i]);\\n            calMoney(nums, k, i+1, i, pq, curr+1);\\n        }\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        res = INT_MAX;\\n\\n        priority_queue<int> pq;\\n        calMoney(nums, k, 0, -1, pq, 0);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1804567,
                "content": [
                    {
                        "username": "jje-",
                        "content": "It broke the rule House Robber problem in LC can be solved by DP."
                    },
                    {
                        "username": "Mrdagger",
                        "content": "hi\\nCan anyone please explain that why testcase [4,22,11,14,25] k=3 has expected output as 25 and not 14?\\nActually I\\'m trying to solve this problem with two pointer approach ."
                    },
                    {
                        "username": "zorowin123",
                        "content": "can erveryone help me with the dp solutions? I have seen a few dp solutions although tle, but it lacks the explanation and i am fully confused about it.  i want to pratice my dp mind, my first sight on this problem is to use dp techniques but i can\\'t even implement a tle solutions, thx in advance\\n(I want to understand bottom-up dp)\\n"
                    },
                    {
                        "username": "prashik0",
                        "content": "is it only me who solved it using union find and sorting?"
                    },
                    {
                        "username": "lemaun",
                        "content": "Input: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\\n\\nare\\'nt 6 ways?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "What are the 7 ways a robber can rob the house in example 2? I can only come up with 6\\n"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "nvm i figured it out, it says that the robber can steal from at least k houses. so in example two, it is possible to steal from 3 houses i.e. (2, 9, 1)"
                    },
                    {
                        "username": "blahbalh",
                        "content": "For the given example 2, how can there be 7 ways to rob houses when n = 5, and k = 2?\\nShouldn\\'t it be 6 ways? We can rob the houses at indices (0,2), (0,3), (0, 4), (1,3), (1,4), (2,4). What\\'s the 7th way of robbing a house?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "(2, 9, 1)\n"
                    },
                    {
                        "username": "r_y_s",
                        "content": "Because of the \"house robber \" title , the only thing that strikes is DP during the context . But I feel this is one of the good binary search questions on Leetcode ."
                    },
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\n\\n     bool check(vector<int>&a,int k,int mx){\\n         vector<int>dp(a.size()+1,0);\\n         if(a[0]<=mx){\\n             dp[1]=1;\\n         }\\n         int n=a.size();\\n         for(int i=2;i<=n;i++){\\n             dp[i]=dp[i-1];\\n             if(a[i-1]<=mx){\\n                 dp[i]=max(dp[i],1+dp[i-2]);\\n             }\\n         }\\n\\n         if(dp[n]>=k)return true;\\n         else return false;\\n     }\\n    int minCapability(vector<int>& nums, int k) {\\n\\n         int l=1,r=1e9;\\n          int ans=0;\\n         while(l<=r){\\n             int mid=l+(r-l)/2;\\n\\n             if(check(nums,k,mid)){\\n                 ans=mid;\\n                 r=mid-1;\\n             }\\n             else{\\n                 l=mid+1;\\n             }\\n         }\\n     \\n     return ans;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Haaaleuluiggghaaa",
                        "content": "How do you cache this?\\nclass Solution {\\npublic:\\n    int res;\\n    void calMoney(vector<int>& nums, int& k, int i, int prev, priority_queue<int> pq, int curr){\\n        if(i >= nums.size()){\\n            if(curr >= k){\\n                res = min(res, pq.top());\\n            }\\n            return;\\n        }\\n\\n        calMoney(nums, k, i+1, prev, pq, curr);\\n\\n        if(prev == -1 || i-prev > 1){\\n            pq.push(nums[i]);\\n            calMoney(nums, k, i+1, i, pq, curr+1);\\n        }\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        res = INT_MAX;\\n\\n        priority_queue<int> pq;\\n        calMoney(nums, k, 0, -1, pq, 0);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1801511,
                "content": [
                    {
                        "username": "jje-",
                        "content": "It broke the rule House Robber problem in LC can be solved by DP."
                    },
                    {
                        "username": "Mrdagger",
                        "content": "hi\\nCan anyone please explain that why testcase [4,22,11,14,25] k=3 has expected output as 25 and not 14?\\nActually I\\'m trying to solve this problem with two pointer approach ."
                    },
                    {
                        "username": "zorowin123",
                        "content": "can erveryone help me with the dp solutions? I have seen a few dp solutions although tle, but it lacks the explanation and i am fully confused about it.  i want to pratice my dp mind, my first sight on this problem is to use dp techniques but i can\\'t even implement a tle solutions, thx in advance\\n(I want to understand bottom-up dp)\\n"
                    },
                    {
                        "username": "prashik0",
                        "content": "is it only me who solved it using union find and sorting?"
                    },
                    {
                        "username": "lemaun",
                        "content": "Input: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\\n\\nare\\'nt 6 ways?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "What are the 7 ways a robber can rob the house in example 2? I can only come up with 6\\n"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "nvm i figured it out, it says that the robber can steal from at least k houses. so in example two, it is possible to steal from 3 houses i.e. (2, 9, 1)"
                    },
                    {
                        "username": "blahbalh",
                        "content": "For the given example 2, how can there be 7 ways to rob houses when n = 5, and k = 2?\\nShouldn\\'t it be 6 ways? We can rob the houses at indices (0,2), (0,3), (0, 4), (1,3), (1,4), (2,4). What\\'s the 7th way of robbing a house?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "(2, 9, 1)\n"
                    },
                    {
                        "username": "r_y_s",
                        "content": "Because of the \"house robber \" title , the only thing that strikes is DP during the context . But I feel this is one of the good binary search questions on Leetcode ."
                    },
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\n\\n     bool check(vector<int>&a,int k,int mx){\\n         vector<int>dp(a.size()+1,0);\\n         if(a[0]<=mx){\\n             dp[1]=1;\\n         }\\n         int n=a.size();\\n         for(int i=2;i<=n;i++){\\n             dp[i]=dp[i-1];\\n             if(a[i-1]<=mx){\\n                 dp[i]=max(dp[i],1+dp[i-2]);\\n             }\\n         }\\n\\n         if(dp[n]>=k)return true;\\n         else return false;\\n     }\\n    int minCapability(vector<int>& nums, int k) {\\n\\n         int l=1,r=1e9;\\n          int ans=0;\\n         while(l<=r){\\n             int mid=l+(r-l)/2;\\n\\n             if(check(nums,k,mid)){\\n                 ans=mid;\\n                 r=mid-1;\\n             }\\n             else{\\n                 l=mid+1;\\n             }\\n         }\\n     \\n     return ans;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Haaaleuluiggghaaa",
                        "content": "How do you cache this?\\nclass Solution {\\npublic:\\n    int res;\\n    void calMoney(vector<int>& nums, int& k, int i, int prev, priority_queue<int> pq, int curr){\\n        if(i >= nums.size()){\\n            if(curr >= k){\\n                res = min(res, pq.top());\\n            }\\n            return;\\n        }\\n\\n        calMoney(nums, k, i+1, prev, pq, curr);\\n\\n        if(prev == -1 || i-prev > 1){\\n            pq.push(nums[i]);\\n            calMoney(nums, k, i+1, i, pq, curr+1);\\n        }\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        res = INT_MAX;\\n\\n        priority_queue<int> pq;\\n        calMoney(nums, k, 0, -1, pq, 0);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1800074,
                "content": [
                    {
                        "username": "jje-",
                        "content": "It broke the rule House Robber problem in LC can be solved by DP."
                    },
                    {
                        "username": "Mrdagger",
                        "content": "hi\\nCan anyone please explain that why testcase [4,22,11,14,25] k=3 has expected output as 25 and not 14?\\nActually I\\'m trying to solve this problem with two pointer approach ."
                    },
                    {
                        "username": "zorowin123",
                        "content": "can erveryone help me with the dp solutions? I have seen a few dp solutions although tle, but it lacks the explanation and i am fully confused about it.  i want to pratice my dp mind, my first sight on this problem is to use dp techniques but i can\\'t even implement a tle solutions, thx in advance\\n(I want to understand bottom-up dp)\\n"
                    },
                    {
                        "username": "prashik0",
                        "content": "is it only me who solved it using union find and sorting?"
                    },
                    {
                        "username": "lemaun",
                        "content": "Input: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\\n\\nare\\'nt 6 ways?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "What are the 7 ways a robber can rob the house in example 2? I can only come up with 6\\n"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "nvm i figured it out, it says that the robber can steal from at least k houses. so in example two, it is possible to steal from 3 houses i.e. (2, 9, 1)"
                    },
                    {
                        "username": "blahbalh",
                        "content": "For the given example 2, how can there be 7 ways to rob houses when n = 5, and k = 2?\\nShouldn\\'t it be 6 ways? We can rob the houses at indices (0,2), (0,3), (0, 4), (1,3), (1,4), (2,4). What\\'s the 7th way of robbing a house?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "(2, 9, 1)\n"
                    },
                    {
                        "username": "r_y_s",
                        "content": "Because of the \"house robber \" title , the only thing that strikes is DP during the context . But I feel this is one of the good binary search questions on Leetcode ."
                    },
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\n\\n     bool check(vector<int>&a,int k,int mx){\\n         vector<int>dp(a.size()+1,0);\\n         if(a[0]<=mx){\\n             dp[1]=1;\\n         }\\n         int n=a.size();\\n         for(int i=2;i<=n;i++){\\n             dp[i]=dp[i-1];\\n             if(a[i-1]<=mx){\\n                 dp[i]=max(dp[i],1+dp[i-2]);\\n             }\\n         }\\n\\n         if(dp[n]>=k)return true;\\n         else return false;\\n     }\\n    int minCapability(vector<int>& nums, int k) {\\n\\n         int l=1,r=1e9;\\n          int ans=0;\\n         while(l<=r){\\n             int mid=l+(r-l)/2;\\n\\n             if(check(nums,k,mid)){\\n                 ans=mid;\\n                 r=mid-1;\\n             }\\n             else{\\n                 l=mid+1;\\n             }\\n         }\\n     \\n     return ans;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Haaaleuluiggghaaa",
                        "content": "How do you cache this?\\nclass Solution {\\npublic:\\n    int res;\\n    void calMoney(vector<int>& nums, int& k, int i, int prev, priority_queue<int> pq, int curr){\\n        if(i >= nums.size()){\\n            if(curr >= k){\\n                res = min(res, pq.top());\\n            }\\n            return;\\n        }\\n\\n        calMoney(nums, k, i+1, prev, pq, curr);\\n\\n        if(prev == -1 || i-prev > 1){\\n            pq.push(nums[i]);\\n            calMoney(nums, k, i+1, i, pq, curr+1);\\n        }\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        res = INT_MAX;\\n\\n        priority_queue<int> pq;\\n        calMoney(nums, k, 0, -1, pq, 0);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1798716,
                "content": [
                    {
                        "username": "jje-",
                        "content": "It broke the rule House Robber problem in LC can be solved by DP."
                    },
                    {
                        "username": "Mrdagger",
                        "content": "hi\\nCan anyone please explain that why testcase [4,22,11,14,25] k=3 has expected output as 25 and not 14?\\nActually I\\'m trying to solve this problem with two pointer approach ."
                    },
                    {
                        "username": "zorowin123",
                        "content": "can erveryone help me with the dp solutions? I have seen a few dp solutions although tle, but it lacks the explanation and i am fully confused about it.  i want to pratice my dp mind, my first sight on this problem is to use dp techniques but i can\\'t even implement a tle solutions, thx in advance\\n(I want to understand bottom-up dp)\\n"
                    },
                    {
                        "username": "prashik0",
                        "content": "is it only me who solved it using union find and sorting?"
                    },
                    {
                        "username": "lemaun",
                        "content": "Input: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\\n\\nare\\'nt 6 ways?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "What are the 7 ways a robber can rob the house in example 2? I can only come up with 6\\n"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "nvm i figured it out, it says that the robber can steal from at least k houses. so in example two, it is possible to steal from 3 houses i.e. (2, 9, 1)"
                    },
                    {
                        "username": "blahbalh",
                        "content": "For the given example 2, how can there be 7 ways to rob houses when n = 5, and k = 2?\\nShouldn\\'t it be 6 ways? We can rob the houses at indices (0,2), (0,3), (0, 4), (1,3), (1,4), (2,4). What\\'s the 7th way of robbing a house?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "(2, 9, 1)\n"
                    },
                    {
                        "username": "r_y_s",
                        "content": "Because of the \"house robber \" title , the only thing that strikes is DP during the context . But I feel this is one of the good binary search questions on Leetcode ."
                    },
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\n\\n     bool check(vector<int>&a,int k,int mx){\\n         vector<int>dp(a.size()+1,0);\\n         if(a[0]<=mx){\\n             dp[1]=1;\\n         }\\n         int n=a.size();\\n         for(int i=2;i<=n;i++){\\n             dp[i]=dp[i-1];\\n             if(a[i-1]<=mx){\\n                 dp[i]=max(dp[i],1+dp[i-2]);\\n             }\\n         }\\n\\n         if(dp[n]>=k)return true;\\n         else return false;\\n     }\\n    int minCapability(vector<int>& nums, int k) {\\n\\n         int l=1,r=1e9;\\n          int ans=0;\\n         while(l<=r){\\n             int mid=l+(r-l)/2;\\n\\n             if(check(nums,k,mid)){\\n                 ans=mid;\\n                 r=mid-1;\\n             }\\n             else{\\n                 l=mid+1;\\n             }\\n         }\\n     \\n     return ans;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Haaaleuluiggghaaa",
                        "content": "How do you cache this?\\nclass Solution {\\npublic:\\n    int res;\\n    void calMoney(vector<int>& nums, int& k, int i, int prev, priority_queue<int> pq, int curr){\\n        if(i >= nums.size()){\\n            if(curr >= k){\\n                res = min(res, pq.top());\\n            }\\n            return;\\n        }\\n\\n        calMoney(nums, k, i+1, prev, pq, curr);\\n\\n        if(prev == -1 || i-prev > 1){\\n            pq.push(nums[i]);\\n            calMoney(nums, k, i+1, i, pq, curr+1);\\n        }\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        res = INT_MAX;\\n\\n        priority_queue<int> pq;\\n        calMoney(nums, k, 0, -1, pq, 0);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1790773,
                "content": [
                    {
                        "username": "jje-",
                        "content": "It broke the rule House Robber problem in LC can be solved by DP."
                    },
                    {
                        "username": "Mrdagger",
                        "content": "hi\\nCan anyone please explain that why testcase [4,22,11,14,25] k=3 has expected output as 25 and not 14?\\nActually I\\'m trying to solve this problem with two pointer approach ."
                    },
                    {
                        "username": "zorowin123",
                        "content": "can erveryone help me with the dp solutions? I have seen a few dp solutions although tle, but it lacks the explanation and i am fully confused about it.  i want to pratice my dp mind, my first sight on this problem is to use dp techniques but i can\\'t even implement a tle solutions, thx in advance\\n(I want to understand bottom-up dp)\\n"
                    },
                    {
                        "username": "prashik0",
                        "content": "is it only me who solved it using union find and sorting?"
                    },
                    {
                        "username": "lemaun",
                        "content": "Input: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\\n\\nare\\'nt 6 ways?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "What are the 7 ways a robber can rob the house in example 2? I can only come up with 6\\n"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "nvm i figured it out, it says that the robber can steal from at least k houses. so in example two, it is possible to steal from 3 houses i.e. (2, 9, 1)"
                    },
                    {
                        "username": "blahbalh",
                        "content": "For the given example 2, how can there be 7 ways to rob houses when n = 5, and k = 2?\\nShouldn\\'t it be 6 ways? We can rob the houses at indices (0,2), (0,3), (0, 4), (1,3), (1,4), (2,4). What\\'s the 7th way of robbing a house?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "(2, 9, 1)\n"
                    },
                    {
                        "username": "r_y_s",
                        "content": "Because of the \"house robber \" title , the only thing that strikes is DP during the context . But I feel this is one of the good binary search questions on Leetcode ."
                    },
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\n\\n     bool check(vector<int>&a,int k,int mx){\\n         vector<int>dp(a.size()+1,0);\\n         if(a[0]<=mx){\\n             dp[1]=1;\\n         }\\n         int n=a.size();\\n         for(int i=2;i<=n;i++){\\n             dp[i]=dp[i-1];\\n             if(a[i-1]<=mx){\\n                 dp[i]=max(dp[i],1+dp[i-2]);\\n             }\\n         }\\n\\n         if(dp[n]>=k)return true;\\n         else return false;\\n     }\\n    int minCapability(vector<int>& nums, int k) {\\n\\n         int l=1,r=1e9;\\n          int ans=0;\\n         while(l<=r){\\n             int mid=l+(r-l)/2;\\n\\n             if(check(nums,k,mid)){\\n                 ans=mid;\\n                 r=mid-1;\\n             }\\n             else{\\n                 l=mid+1;\\n             }\\n         }\\n     \\n     return ans;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Haaaleuluiggghaaa",
                        "content": "How do you cache this?\\nclass Solution {\\npublic:\\n    int res;\\n    void calMoney(vector<int>& nums, int& k, int i, int prev, priority_queue<int> pq, int curr){\\n        if(i >= nums.size()){\\n            if(curr >= k){\\n                res = min(res, pq.top());\\n            }\\n            return;\\n        }\\n\\n        calMoney(nums, k, i+1, prev, pq, curr);\\n\\n        if(prev == -1 || i-prev > 1){\\n            pq.push(nums[i]);\\n            calMoney(nums, k, i+1, i, pq, curr+1);\\n        }\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        res = INT_MAX;\\n\\n        priority_queue<int> pq;\\n        calMoney(nums, k, 0, -1, pq, 0);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1790443,
                "content": [
                    {
                        "username": "jje-",
                        "content": "It broke the rule House Robber problem in LC can be solved by DP."
                    },
                    {
                        "username": "Mrdagger",
                        "content": "hi\\nCan anyone please explain that why testcase [4,22,11,14,25] k=3 has expected output as 25 and not 14?\\nActually I\\'m trying to solve this problem with two pointer approach ."
                    },
                    {
                        "username": "zorowin123",
                        "content": "can erveryone help me with the dp solutions? I have seen a few dp solutions although tle, but it lacks the explanation and i am fully confused about it.  i want to pratice my dp mind, my first sight on this problem is to use dp techniques but i can\\'t even implement a tle solutions, thx in advance\\n(I want to understand bottom-up dp)\\n"
                    },
                    {
                        "username": "prashik0",
                        "content": "is it only me who solved it using union find and sorting?"
                    },
                    {
                        "username": "lemaun",
                        "content": "Input: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\\n\\nare\\'nt 6 ways?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "What are the 7 ways a robber can rob the house in example 2? I can only come up with 6\\n"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "nvm i figured it out, it says that the robber can steal from at least k houses. so in example two, it is possible to steal from 3 houses i.e. (2, 9, 1)"
                    },
                    {
                        "username": "blahbalh",
                        "content": "For the given example 2, how can there be 7 ways to rob houses when n = 5, and k = 2?\\nShouldn\\'t it be 6 ways? We can rob the houses at indices (0,2), (0,3), (0, 4), (1,3), (1,4), (2,4). What\\'s the 7th way of robbing a house?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "(2, 9, 1)\n"
                    },
                    {
                        "username": "r_y_s",
                        "content": "Because of the \"house robber \" title , the only thing that strikes is DP during the context . But I feel this is one of the good binary search questions on Leetcode ."
                    },
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\n\\n     bool check(vector<int>&a,int k,int mx){\\n         vector<int>dp(a.size()+1,0);\\n         if(a[0]<=mx){\\n             dp[1]=1;\\n         }\\n         int n=a.size();\\n         for(int i=2;i<=n;i++){\\n             dp[i]=dp[i-1];\\n             if(a[i-1]<=mx){\\n                 dp[i]=max(dp[i],1+dp[i-2]);\\n             }\\n         }\\n\\n         if(dp[n]>=k)return true;\\n         else return false;\\n     }\\n    int minCapability(vector<int>& nums, int k) {\\n\\n         int l=1,r=1e9;\\n          int ans=0;\\n         while(l<=r){\\n             int mid=l+(r-l)/2;\\n\\n             if(check(nums,k,mid)){\\n                 ans=mid;\\n                 r=mid-1;\\n             }\\n             else{\\n                 l=mid+1;\\n             }\\n         }\\n     \\n     return ans;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Haaaleuluiggghaaa",
                        "content": "How do you cache this?\\nclass Solution {\\npublic:\\n    int res;\\n    void calMoney(vector<int>& nums, int& k, int i, int prev, priority_queue<int> pq, int curr){\\n        if(i >= nums.size()){\\n            if(curr >= k){\\n                res = min(res, pq.top());\\n            }\\n            return;\\n        }\\n\\n        calMoney(nums, k, i+1, prev, pq, curr);\\n\\n        if(prev == -1 || i-prev > 1){\\n            pq.push(nums[i]);\\n            calMoney(nums, k, i+1, i, pq, curr+1);\\n        }\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        res = INT_MAX;\\n\\n        priority_queue<int> pq;\\n        calMoney(nums, k, 0, -1, pq, 0);\\n        return res;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1790118,
                "content": [
                    {
                        "username": "jje-",
                        "content": "It broke the rule House Robber problem in LC can be solved by DP."
                    },
                    {
                        "username": "Mrdagger",
                        "content": "hi\\nCan anyone please explain that why testcase [4,22,11,14,25] k=3 has expected output as 25 and not 14?\\nActually I\\'m trying to solve this problem with two pointer approach ."
                    },
                    {
                        "username": "zorowin123",
                        "content": "can erveryone help me with the dp solutions? I have seen a few dp solutions although tle, but it lacks the explanation and i am fully confused about it.  i want to pratice my dp mind, my first sight on this problem is to use dp techniques but i can\\'t even implement a tle solutions, thx in advance\\n(I want to understand bottom-up dp)\\n"
                    },
                    {
                        "username": "prashik0",
                        "content": "is it only me who solved it using union find and sorting?"
                    },
                    {
                        "username": "lemaun",
                        "content": "Input: nums = [2,7,9,3,1], k = 2\\nOutput: 2\\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\\n\\nare\\'nt 6 ways?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "What are the 7 ways a robber can rob the house in example 2? I can only come up with 6\\n"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "nvm i figured it out, it says that the robber can steal from at least k houses. so in example two, it is possible to steal from 3 houses i.e. (2, 9, 1)"
                    },
                    {
                        "username": "blahbalh",
                        "content": "For the given example 2, how can there be 7 ways to rob houses when n = 5, and k = 2?\\nShouldn\\'t it be 6 ways? We can rob the houses at indices (0,2), (0,3), (0, 4), (1,3), (1,4), (2,4). What\\'s the 7th way of robbing a house?"
                    },
                    {
                        "username": "shishkabaab",
                        "content": "(2, 9, 1)\n"
                    },
                    {
                        "username": "r_y_s",
                        "content": "Because of the \"house robber \" title , the only thing that strikes is DP during the context . But I feel this is one of the good binary search questions on Leetcode ."
                    },
                    {
                        "username": "rajat397",
                        "content": "class Solution {\\npublic:\\n\\n     bool check(vector<int>&a,int k,int mx){\\n         vector<int>dp(a.size()+1,0);\\n         if(a[0]<=mx){\\n             dp[1]=1;\\n         }\\n         int n=a.size();\\n         for(int i=2;i<=n;i++){\\n             dp[i]=dp[i-1];\\n             if(a[i-1]<=mx){\\n                 dp[i]=max(dp[i],1+dp[i-2]);\\n             }\\n         }\\n\\n         if(dp[n]>=k)return true;\\n         else return false;\\n     }\\n    int minCapability(vector<int>& nums, int k) {\\n\\n         int l=1,r=1e9;\\n          int ans=0;\\n         while(l<=r){\\n             int mid=l+(r-l)/2;\\n\\n             if(check(nums,k,mid)){\\n                 ans=mid;\\n                 r=mid-1;\\n             }\\n             else{\\n                 l=mid+1;\\n             }\\n         }\\n     \\n     return ans;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Haaaleuluiggghaaa",
                        "content": "How do you cache this?\\nclass Solution {\\npublic:\\n    int res;\\n    void calMoney(vector<int>& nums, int& k, int i, int prev, priority_queue<int> pq, int curr){\\n        if(i >= nums.size()){\\n            if(curr >= k){\\n                res = min(res, pq.top());\\n            }\\n            return;\\n        }\\n\\n        calMoney(nums, k, i+1, prev, pq, curr);\\n\\n        if(prev == -1 || i-prev > 1){\\n            pq.push(nums[i]);\\n            calMoney(nums, k, i+1, i, pq, curr+1);\\n        }\\n    }\\n\\n    int minCapability(vector<int>& nums, int k) {\\n        res = INT_MAX;\\n\\n        priority_queue<int> pq;\\n        calMoney(nums, k, 0, -1, pq, 0);\\n        return res;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]