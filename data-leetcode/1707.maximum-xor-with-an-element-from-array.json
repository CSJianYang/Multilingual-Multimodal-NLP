[
    {
        "title": "Groups of Special-Equivalent Strings",
        "question_content": "You are given an array of strings of the same length words.\nIn one move, you can swap any two even indexed characters or any two odd indexed characters of a string words[i].\nTwo strings words[i] and words[j] are special-equivalent if after any number of moves, words[i] == words[j].\n\n\tFor example, words[i] = \"zzxy\" and words[j] = \"xyzz\" are special-equivalent because we may make the moves \"zzxy\" -> \"xzzy\" -> \"xyzz\".\n\nA group of special-equivalent strings from words is a non-empty subset of words such that:\n\n\tEvery pair of strings in the group are special equivalent, and\n\tThe group is the largest size possible (i.e., there is not a string words[i] not in the group such that words[i] is special-equivalent to every string in the group).\n\nReturn the number of groups of special-equivalent strings from words.\n&nbsp;\nExample 1:\n\nInput: words = [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\nOutput: 3\nExplanation: \nOne group is [\"abcd\", \"cdab\", \"cbad\"], since they are all pairwise special equivalent, and none of the other strings is all pairwise special equivalent to these.\nThe other two groups are [\"xyzz\", \"zzxy\"] and [\"zzyx\"].\nNote that in particular, \"zzxy\" is not special equivalent to \"zzyx\".\n\nExample 2:\n\nInput: words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 1000\n\t1 <= words[i].length <= 20\n\twords[i] consist of lowercase English letters.\n\tAll the strings are of the same length.",
        "solutions": [
            {
                "id": 163413,
                "title": "java-concise-set-solution",
                "content": "For each String, we generate it\\'s corresponding signature, and add it to the set.\\nIn the end, we return the size of the set.\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set= new HashSet<>();\\n        for (String s: A){\\n            int[] odd= new int[26];\\n            int[] even= new int[26];\\n            for (int i=0; i<s.length(); i++){\\n                if (i%2==1) odd[s.charAt(i)-\\'a\\']++;\\n                else even[s.charAt(i)-\\'a\\']++;\\n            }\\n            String sig= Arrays.toString(odd)+Arrays.toString(even);\\n            set.add(sig);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set= new HashSet<>();\\n        for (String s: A){\\n            int[] odd= new int[26];\\n            int[] even= new int[26];\\n            for (int i=0; i<s.length(); i++){\\n                if (i%2==1) odd[s.charAt(i)-\\'a\\']++;\\n                else even[s.charAt(i)-\\'a\\']++;\\n            }\\n            String sig= Arrays.toString(odd)+Arrays.toString(even);\\n            set.add(sig);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163547,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        return len(set(\"\".join(sorted(s[0::2])) + \"\".join(sorted(s[1::2])) for s in A))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        return len(set(\"\".join(sorted(s[0::2])) + \"\".join(sorted(s[1::2])) for s in A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163412,
                "title": "c-simple-solution",
                "content": "**General Idea:**\\n\\n1. Split strings in two to substrings, 1 with even indexed characters, and 1 with odd\\n2. Sort the two substrings (We do this because if you can swap on string with another, when sorted they will equal each other because they must have the same characters)\\n3. Insert your pair of strings into set, this will keep track of the unique \"groups\"\\n4. Rerturn the size of your set\\n\\nCheck out the video solution and explanation (for C++, Java, Python and BASH) here: https://youtu.be/WJ4NtyrakT0\\n```\\nint numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}",
                "solutionTags": [],
                "code": "**General Idea:**\\n\\n1. Split strings in two to substrings, 1 with even indexed characters, and 1 with odd\\n2. Sort the two substrings (We do this because if you can swap on string with another, when sorted they will equal each other because they must have the same characters)\\n3. Insert your pair of strings into set, this will keep track of the unique \"groups\"\\n4. Rerturn the size of your set\\n\\nCheck out the video solution and explanation (for C++, Java, Python and BASH) here: https://youtu.be/WJ4NtyrakT0\\n```\\nint numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 358795,
                "title": "python3-detail-explanation-of-special-equivalent",
                "content": "* The point here is to understand the following requirement:\\nA move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j].\\nDon\\'t trap your thoughts by the word \\'swap\\'.\\nYour goal is how to identify the equivalent strings. \\n* There are two possible outcomes of i%2: 1 or 0. i is the index of the input string.\\n\\tif i % 2 ==1: i = 1,3,5,7 ... in other words, i is odd number. In other words, the order of the odd index\\'s value doesn\\'t matter here. You can swap them.\\n\\tif i % 2 ==0: i = 0,2,4,6 ... in other words, i is even number. In other words, the order of the even index\\'s value doesn\\'t matter here. You can swap them.\\n*  So sort the string\\'s odd index elements, and sort the string\\'s even index elements and combine them to create a new string called \"sort_string.\" If two string has the same \"sort_string,\" they are the special-equivalent strings.\\n```\\nA = [\"abcd\",\"cdab\",\"adcb\",\"cbad\"]\\n      ### sort odd index element      | sort even index element\\n\"abcd\" :              bd              |               ac\\n\"cbad\" :              bd              |               ac\\n\"adcb\" :              bd              |               ac\\n\"cdab\" :              bd              |               ac\\n# so they are equivalent strings\\n```\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nA = [\"abcd\",\"cdab\",\"adcb\",\"cbad\"]\\n      ### sort odd index element      | sort even index element\\n\"abcd\" :              bd              |               ac\\n\"cbad\" :              bd              |               ac\\n\"adcb\" :              bd              |               ac\\n\"cdab\" :              bd              |               ac\\n# so they are equivalent strings\\n```\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163471,
                "title": "python-extremely-simple-solution",
                "content": "```\\nclass Solution:\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\td = collections.defaultdict(int)\\n\\t\\tfor w in A:\\n\\t\\t\\teven = \\'\\'.join(sorted(w[0::2]))\\n\\t\\t\\todd = \\'\\'.join(sorted(w[1::2]))\\n\\t\\t\\td[(even, odd)] += 1\\n\\t\\t\\n\\t\\treturn len(d)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\td = collections.defaultdict(int)\\n\\t\\tfor w in A:\\n\\t\\t\\teven = \\'\\'.join(sorted(w[0::2]))\\n\\t\\t\\todd = \\'\\'.join(sorted(w[1::2]))\\n\\t\\t\\td[(even, odd)] += 1\\n\\t\\t\\n\\t\\treturn len(d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163767,
                "title": "straightforward-java-solution",
                "content": "map1 - the distribution of counts of the characters at even positions\\nmap2 - the distribution of counts of the characters at odd positions\\nset - how many unique distributions\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            int[] map1 = new int[256];\\n            int[] map2 = new int[256];\\n            for (int i = 0; i < s.length(); i++) {\\n                if (i % 2 == 0) {\\n                    map1[s.charAt(i)]++;\\n                } else {\\n                    map2[s.charAt(i)]++;\\n                }\\n            }\\n            set.add(Arrays.toString(map1) + \" \" + Arrays.toString(map2));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            int[] map1 = new int[256];\\n            int[] map2 = new int[256];\\n            for (int i = 0; i < s.length(); i++) {\\n                if (i % 2 == 0) {\\n                    map1[s.charAt(i)]++;\\n                } else {\\n                    map2[s.charAt(i)]++;\\n                }\\n            }\\n            set.add(Arrays.toString(map1) + \" \" + Arrays.toString(map2));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536199,
                "title": "python-o-n-k-lg-k-sol-by-signature-90-w-hint",
                "content": "Python sol. by signature. \\n\\n---\\n\\n**Hint**:\\n\\nThink of the concept for  **anagram** judgement.\\n\\nWhat we need in this challenge is to verify the so-called \"**special equivalent**\", \\nwhich means even-indexed substring of input is anagram and odd-indexed substring of input is another anagram.\\n\\nWe can verify by signature checking.\\n\\nDefine **signature** as the **sorted even-indexed substring and odd-indexed substring** in alphabetic order.\\n\\nIf signature( s1 ) == signature( s2 ),\\nthen s1 and s2 are special equivalent.\\n\\n---\\n\\nFor example:\\ns1 = \\'**a**b**c**d\\', and s2 = \\'**c**d**a**b\\'\\n\\nThen, signature( s1 ) is \\'acbd\\', and signature( s2 ) is the same.\\nTherefore, s1 and s2 are special equivalent.\\n\\n---\\n\\n**Algorithm**:\\n\\nRearrange each input string into the form of signature.\\n\\nThe **number of unique signature** is the **number of grouping** for special equivalent.\\n\\n---\\n\\n**Implementation**:\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        \\n        signature = set()\\n        \\n        # Use pair of sorted even substring and odd substring as unique key\\n        \\n        for idx, s in enumerate(A):\\n            signature.add( \\'\\'.join( sorted( s[::2] ) ) + \\'\\'.join( sorted( s[1::2] ) )  )\\n        \\n        return len( signature )\\n```\\n\\n---\\n\\nRelated challenge:\\n\\n[Leetcode #49 Group Anagrms](https://leetcode.com/problems/group-anagrams/)\\n\\n[Leetcode #242 Valid Anagram](https://leetcode.com/problems/valid-anagram/)\\n\\n[Leetcode #438 Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about hash-set: set()](https://docs.python.org/3/tutorial/datastructures.html#sets)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        \\n        signature = set()\\n        \\n        # Use pair of sorted even substring and odd substring as unique key\\n        \\n        for idx, s in enumerate(A):\\n            signature.add( \\'\\'.join( sorted( s[::2] ) ) + \\'\\'.join( sorted( s[1::2] ) )  )\\n        \\n        return len( signature )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164481,
                "title": "python-1-liner-beats-100-of-other-submissions",
                "content": "The idea is to convert all strings to some sort of canonical representation. Since all characters at even and odd position can be shuffled in any way, sorting them will produce the desired result - strings like `cba` will be converted to `abc` and `dcba` to `badc`. Having all strings converted to their canonical form, a set can be used to remove the duplicates and its length will produce the desired result.\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        return len({tuple(sorted(s[0::2]) + sorted(s[1::2])) for s in A})\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        return len({tuple(sorted(s[0::2]) + sorted(s[1::2])) for s in A})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163891,
                "title": "c-create-a-signature-for-each-string",
                "content": "We can quickly notice that by grouping odd and even position, sorting them and concatenating them, all the special - equivalent string will have the same signature. We can then use a hash set to capture the signature (which automatically de-duplicates) and we can return the hashset size.\\nThe constraints of the problem easily allow this.\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> st;\\n        for(auto &w : A) {\\n            string odd, even;\\n            for(int i=0;i<w.size();i+=2) even.push_back(w[i]);\\n            for(int i=1;i<w.size();i+=2) odd.push_back(w[i]);\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> st;\\n        for(auto &w : A) {\\n            string odd, even;\\n            for(int i=0;i<w.size();i+=2) even.push_back(w[i]);\\n            for(int i=1;i<w.size();i+=2) odd.push_back(w[i]);\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431332,
                "title": "c-set-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words)\\n    {    \\n        set<pair<string,string>> s;\\n        for(auto &w:words)\\n        {\\n            string p,q;\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    p+=w[i];\\n                }\\n                else\\n                {\\n                    q+=w[i];\\n                }\\n            }\\n            sort(p.begin(),p.end());\\n            sort(q.begin(),q.end());\\n            s.insert({p,q});\\n        }\\n        return s.size();\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words)\\n    {    \\n        set<pair<string,string>> s;\\n        for(auto &w:words)\\n        {\\n            string p,q;\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    p+=w[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 512294,
                "title": "javascript-easy-solution",
                "content": "```javascript\\n/**\\n * @param {string[]} A\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(A) {\\n  const groupSet = new Set();\\n  A.forEach(a => groupSet.add(transform(a)));\\n  return groupSet.size;\\n};\\n\\nconst transform = S => {\\n  const even = S.split(\\'\\').filter((_, i) => i % 2 === 0);\\n  const odd = S.split(\\'\\').filter((_, i) => i % 2 === 1);\\n  even.sort();\\n  odd.sort();\\n  return `${even.join(\\'\\')}${odd.join(\\'\\')}`;\\n};\\n```\\n\\n* 36/36 cases passed (64 ms)\\n* Your runtime beats 100 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (37.5 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} A\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(A) {\\n  const groupSet = new Set();\\n  A.forEach(a => groupSet.add(transform(a)));\\n  return groupSet.size;\\n};\\n\\nconst transform = S => {\\n  const even = S.split(\\'\\').filter((_, i) => i % 2 === 0);\\n  const odd = S.split(\\'\\').filter((_, i) => i % 2 === 1);\\n  even.sort();\\n  odd.sort();\\n  return `${even.join(\\'\\')}${odd.join(\\'\\')}`;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359733,
                "title": "bug-in-leetcode-itself-check-it-out-lol",
                "content": "![image](https://assets.leetcode.com/users/ssemichev/image_1565936717.png)\\n![image](https://assets.leetcode.com/users/ssemichev/image_1565936718.png)\\nSubmission tab gives wrong answer and output 5. But Debug tab (and my IDE) has correct answer 1. \\n\\nSolution:\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] input) {\\n        int[] inx = new int[input.length];\\n        int group = 1;\\n        for(int i = 0; i < input.length; i++){\\n          if(inx[i] != 0) continue;\\n          inx[i] = group++;\\n          for(int j = i + 1; j < input.length; j++ ) {\\n            if (j != 0 && eq(input[i], input[j])) {\\n              inx[i] = group;\\n              inx[j] = group;\\n            }\\n          }\\n        }\\n        return group - 1;\\n    }\\n    \\n    private boolean eq(String a, String b){\\n        if(a.equals(b)) return true;\\n        \\n        char[] buff = b.toCharArray();\\n        for(int i = 0; i < buff.length; i++){\\n          int j = i + 2;\\n          while(j < buff.length && (i % 2 != j % 2)) j++;\\n          if(j < buff.length){\\n            if(buff[i] == a.charAt(i) && buff[j] == a.charAt(j)) continue;\\n            char t = buff[i];\\n            buff[i] = buff[j];\\n            buff[j] = t;\\n            if(a.equals(new String(buff)))\\n              return true;\\n          }\\n        }\\n        return false;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] input) {\\n        int[] inx = new int[input.length];\\n        int group = 1;\\n        for(int i = 0; i < input.length; i++){\\n          if(inx[i] != 0) continue;\\n          inx[i] = group++;\\n          for(int j = i + 1; j < input.length; j++ ) {\\n            if (j != 0 && eq(input[i], input[j])) {\\n              inx[i] = group;\\n              inx[j] = group;\\n            }\\n          }\\n        }\\n        return group - 1;\\n    }\\n    \\n    private boolean eq(String a, String b){\\n        if(a.equals(b)) return true;\\n        \\n        char[] buff = b.toCharArray();\\n        for(int i = 0; i < buff.length; i++){\\n          int j = i + 2;\\n          while(j < buff.length && (i % 2 != j % 2)) j++;\\n          if(j < buff.length){\\n            if(buff[i] == a.charAt(i) && buff[j] == a.charAt(j)) continue;\\n            char t = buff[i];\\n            buff[i] = buff[j];\\n            buff[j] = t;\\n            if(a.equals(new String(buff)))\\n              return true;\\n          }\\n        }\\n        return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173803,
                "title": "c-using-counting-sort-since-string-contains-english-letters",
                "content": "Sept. 23, 2018\\nIt is an easy level string algorithm. The swap of letters should be restricted to odd index or even index two groups. All letters in odd index can be swapped, likewise as even index. \\n\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] A)\\n        {\\n            if (A == null)\\n                return 0;\\n\\n            var keys = new HashSet<string>(); \\n\\n            foreach(var item in A)\\n            {\\n                var countLetterEven = new int[26];\\n                var countLetterOdd  = new int[26];\\n\\n                for (int i = 0; i < item.Length; i++ )\\n                {\\n                    var current = item[i];\\n                    var isEven = i % 2 == 0;\\n                    if (isEven)\\n                    {\\n                        countLetterEven[current - \\'a\\']++;\\n                    }\\n                    else\\n                        countLetterOdd[current - \\'a\\']++;                    \\n                }\\n\\n                var key = createKey(countLetterEven, countLetterOdd);\\n                if (!keys.Contains(key))\\n                    keys.Add(key);\\n            }\\n\\n            return keys.Count; \\n        }\\n\\n        private static string createKey(int[] even, int[] odd)\\n        {\\n            var key = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                key += even[i] + \" \" + odd[i] +\";\";\\n            }\\n\\n            return key; \\n        }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] A)\\n        {\\n            if (A == null)\\n                return 0;\\n\\n            var keys = new HashSet<string>(); \\n\\n            foreach(var item in A)\\n            {\\n                var countLetterEven = new int[26];\\n                var countLetterOdd  = new int[26];\\n\\n                for (int i = 0; i < item.Length; i++ )\\n                {\\n                    var current = item[i];\\n                    var isEven = i % 2 == 0;\\n                    if (isEven)\\n                    {\\n                        countLetterEven[current - \\'a\\']++;\\n                    }\\n                    else\\n                        countLetterOdd[current - \\'a\\']++;                    \\n                }\\n\\n                var key = createKey(countLetterEven, countLetterOdd);\\n                if (!keys.Contains(key))\\n                    keys.Add(key);\\n            }\\n\\n            return keys.Count; \\n        }\\n\\n        private static string createKey(int[] even, int[] odd)\\n        {\\n            var key = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                key += even[i] + \" \" + odd[i] +\";\";\\n            }\\n\\n            return key; \\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162198,
                "title": "c-893-groups-of-special-equivalent-strings",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> seen; \\n        for (auto word : A) {\\n            string even, odd; \\n            for (int i = 0; i < word.size(); ++i) {\\n                if (i&1) odd.push_back(word[i]); \\n                else even.push_back(word[i]); \\n            }\\n            sort(even.begin(), even.end()); \\n            sort(odd.begin(), odd.end()); \\n            seen.insert(even+odd); \\n        }\\n        return seen.size(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> seen; \\n        for (auto word : A) {\\n            string even, odd; \\n            for (int i = 0; i < word.size(); ++i) {\\n                if (i&1) odd.push_back(word[i]); \\n                else even.push_back(word[i]); \\n            }\\n            sort(even.begin(), even.end()); \\n            sort(odd.begin(), odd.end()); \\n            seen.insert(even+odd); \\n        }\\n        return seen.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860173,
                "title": "typescript-javascript-o-n-solution-w-detailed-comments-explanation",
                "content": "Forget what the problem is asking for a second. I\\'ll dumb it down. It took me too long and I overthought way too hard.\\n*Shout out to Fisher Coder (on youtube) for explaining the problem statement. He\\'s a legendary beast.*\\n\\nThe problem is **simply** asking how many strings are distinct, given you can swap any even-indexed characters, and swap any odd-indexed characters.\\n\\nExample: if you have **\"axbycz\"** and **\"czbyax\"**, these ARE specially EQUIVALENT. here is the reasoning: for odd index, we have counts {a: 1, b: 1, c:1} in both of them, and for even index we have {x: 1, y: 1, z: 1} for both of them.\\n\\n**solution:**\\n```\\nfunction numSpecialEquivGroups(A: string[]): number {\\n    // set to keep track of unique special equivalents\\n    const set: Set<string> = new Set();\\n    // iterate thru A\\n    for (let i = 0; i < A.length; i++) {\\n        // even and odd char counts\\n        const counts = [new Uint8Array(26), new Uint8Array(26)];\\n        // iterate thru this string, and fill counts\\n        for (let j = 0; j < A[i].length; j++) {\\n            // fill count on whether even or odd (0 index is even 1 is odd)\\n            counts[j % 2][A[i].charCodeAt(j) - 97]++;\\n        }\\n        // add to set as concatenation of both counts arrays\\n        set.add(counts[0].join(\\'\\') + counts[1].join(\\'\\'));\\n    }\\n\\n    // result is just size of set (number of unique special equivalents)\\n    return set.size;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction numSpecialEquivGroups(A: string[]): number {\\n    // set to keep track of unique special equivalents\\n    const set: Set<string> = new Set();\\n    // iterate thru A\\n    for (let i = 0; i < A.length; i++) {\\n        // even and odd char counts\\n        const counts = [new Uint8Array(26), new Uint8Array(26)];\\n        // iterate thru this string, and fill counts\\n        for (let j = 0; j < A[i].length; j++) {\\n            // fill count on whether even or odd (0 index is even 1 is odd)\\n            counts[j % 2][A[i].charCodeAt(j) - 97]++;\\n        }\\n        // add to set as concatenation of both counts arrays\\n        set.add(counts[0].join(\\'\\') + counts[1].join(\\'\\'));\\n    }\\n\\n    // result is just size of set (number of unique special equivalents)\\n    return set.size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425999,
                "title": "java-easy-to-understand-solution",
                "content": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tHashSet<String> s = new HashSet<>();\\n\\tfor(String a : A) {\\n\\t\\tint[] odd = new int[26], even = new int[26];\\n\\t\\tfor(int i=0; i<a.length(); i++) {\\n\\t\\t\\tif(i%2==0)\\n\\t\\t\\t\\teven[a.charAt(i)-\\'a\\']++;\\n\\t\\t\\telse\\n\\t\\t\\t\\todd[a.charAt(i)-\\'a\\']++;\\n\\t\\t}\\n\\t\\ts.add(Arrays.toString(odd)+Arrays.toString(even));\\n\\t}\\n\\treturn s.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tHashSet<String> s = new HashSet<>();\\n\\tfor(String a : A) {\\n\\t\\tint[] odd = new int[26], even = new int[26];\\n\\t\\tfor(int i=0; i<a.length(); i++) {\\n\\t\\t\\tif(i%2==0)\\n\\t\\t\\t\\teven[a.charAt(i)-\\'a\\']++;\\n\\t\\t\\telse\\n\\t\\t\\t\\todd[a.charAt(i)-\\'a\\']++;\\n\\t\\t}\\n\\t\\ts.add(Arrays.toString(odd)+Arrays.toString(even));\\n\\t}\\n\\treturn s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937150,
                "title": "python-3-5-lines-w-example-t-m-88-27",
                "content": "\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n                                                            #  Example: \\n        wSet = set()                                        #   words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\n\\n        for word in words:                                  #           sorted((enu-   \\n            word = tuple(sorted((enumerate(word)),          #  word     merate word)         wSet\\n                           key = lambda x: (x[0]%2,x[1])))  #  \\u2013\\u2013\\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013         \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            print(wSet)                                     #   abc     ((0,a),(2,c),(1,b))  {(a,c,b)}\\n            wSet.add(list(zip(*word))[1])                   #   acb     ((0,a),(2,b),(1,c))  {(a,c,b), (a,b,c)}\\n                                                            #   bac     ((0,b),(2,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n        return len(wSet)                                    #   bca     ((2,a),(0,b),(1,c))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cab     ((2,b),(0,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cba     ((2,a),(0,c),(1,b))  {(a,c,b), (a,b,c), (b,c,a)}\\n```\\n[https://leetcode.com/problems/groups-of-special-equivalent-strings/submissions/863479817/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*NlogN*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n                                                            #  Example: \\n        wSet = set()                                        #   words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\n\\n        for word in words:                                  #           sorted((enu-   \\n            word = tuple(sorted((enumerate(word)),          #  word     merate word)         wSet\\n                           key = lambda x: (x[0]%2,x[1])))  #  \\u2013\\u2013\\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013         \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            print(wSet)                                     #   abc     ((0,a),(2,c),(1,b))  {(a,c,b)}\\n            wSet.add(list(zip(*word))[1])                   #   acb     ((0,a),(2,b),(1,c))  {(a,c,b), (a,b,c)}\\n                                                            #   bac     ((0,b),(2,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n        return len(wSet)                                    #   bca     ((2,a),(0,b),(1,c))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cab     ((2,b),(0,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cba     ((2,a),(0,c),(1,b))  {(a,c,b), (a,b,c), (b,c,a)}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791670,
                "title": "c-easy-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176722,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<string, int> um;\\n        for(string &word : words)\\n        {\\n            vector<int> even(26,0);\\n            vector<int> odd(26,0);\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    even[word[i]-\\'a\\']++;\\n                }\\n                else\\n                {\\n                    odd[word[i]-\\'a\\']++;\\n                }\\n            }\\n            string str = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(even[i]);\\n            }\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(odd[i]);\\n            }\\n            um[str]++;\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<string, int> um;\\n        for(string &word : words)\\n        {\\n            vector<int> even(26,0);\\n            vector<int> odd(26,0);\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    even[word[i]-\\'a\\']++;\\n                }\\n                else\\n                {\\n                    odd[word[i]-\\'a\\']++;\\n                }\\n            }\\n            string str = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(even[i]);\\n            }\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(odd[i]);\\n            }\\n            um[str]++;\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074463,
                "title": "easy-fast-python-solution",
                "content": "```class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        dic={}\\n        for i in range(len(A)):\\n            x = \\'\\'.join(sorted(A[i][0::2]))\\n            y = \\'\\'.join(sorted(A[i][1::2]))     \\n            if (x+y) not in dic:\\n                dic[x+y]=1\\n            else:\\n                dic[x+y]+=1\\n        return len(dic)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        dic={}",
                "codeTag": "Java"
            },
            {
                "id": 962274,
                "title": "python-3-use-defaultdict-40ms-88-5",
                "content": "\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        #\\n        helper = defaultdict(int)\\n        for string in A:\\n            key = \"\".join(sorted(string[0::2])+sorted(string[1::2]))\\n            helper[key] += 1\\n        return len(helper)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        #\\n        helper = defaultdict(int)\\n        for string in A:\\n            key = \"\".join(sorted(string[0::2])+sorted(string[1::2]))\\n            helper[key] += 1\\n        return len(helper)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765248,
                "title": "simple-cpp-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\\n        unordered_set<string>mp;\\n        for(int i=0;i<A.size();i++)\\n        {\\n        string o=\"\";\\n        string e=\"\";\\n            for(int j=0;j<A[i].size();j++)\\n            {\\n                if(j%2==0)\\n                    e+=A[i][j];\\n                else\\n                    o+=A[i][j];\\n            }\\n            sort(o.begin(),o.end());\\n            sort(e.begin(),e.end());\\n            mp.insert(e+o);\\n        }\\n        return mp.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\\n        unordered_set<string>mp;\\n        for(int i=0;i<A.size();i++)\\n        {\\n        string o=\"\";\\n        string e=\"\";\\n            for(int j=0;j<A[i].size();j++)\\n            {\\n                if(j%2==0)\\n                    e+=A[i][j];\\n                else\\n                    o+=A[i][j];\\n            }\\n            sort(o.begin(),o.end());\\n            sort(e.begin(),e.end());\\n            mp.insert(e+o);\\n        }\\n        return mp.size();\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 641006,
                "title": "python-1-liner-and-5-liner-for-readability-explained",
                "content": "Since any even index can be switched with any other even index, and the same is true for any odd index pair, as long as two words share the same multiset of even-indexed letters and the same multiset of odd-indexed letters, then they are special-equivalent.  \\n\\nThat said, we can represent any multiset by the sorted even indexed letters concatenated with the sorted odd indexed letters:\\n\\n    \\'adcb\\' and \\'cdab\\'  represented by \\'bd\\' + \\'ac\\'  = \\'bdac\\'\\n\\t\\'abdc\\' respresented by \\'bc\\' + \\'ad\\' = \\'bcad\\'\\n\\nEncode each word (using the method above) and add it to a set.  The length of the set will then be equal the number of special equivalent families in A.\\n\\n### 5 Liner (for readability)\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        codes = set()\\n        for word in A:\\n            code = \\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2]))\\n            codes.add(code)\\n        return len(codes)\\n```\\n\\n### One Liner\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([\\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2])) for word in A]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        codes = set()\\n        for word in A:\\n            code = \\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2]))\\n            codes.add(code)\\n        return len(codes)\\n```\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([\\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2])) for word in A]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474747,
                "title": "runtime-8-ms-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_map<string, int> count;\\n        for(auto s : A)\\n        {\\n            string even = \"\", odd = \"\";\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(i % 2 == 0)\\n                    even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            string key = even + odd;\\n            count[key]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_map<string, int> count;\\n        for(auto s : A)\\n        {\\n            string even = \"\", odd = \"\";\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(i % 2 == 0)\\n                    even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            string key = even + odd;\\n            count[key]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377831,
                "title": "java-2ms-solution-with-hashset-with-explanation",
                "content": "/*\\nJava Solution Beat 100% runtime and 100% memory\\n\\nit is kind of anagram problem.\\ntwo strings can only be Special-Equivalent when BOTH their odd letters  AND even letters are anagrams.\\n\\nso based on above logic, \\n1. we build hash value for each string, we sort odd position letters, even position letters of each string , since string is short, here only use simple O(n^2) compare logic to sort them.\\n2. the odd and even sorted string will be the hash of the string.\\n3. we add the hash into HashSet.  (HashSet.add(value) will return true if it is added, and return falsle is already has the value  in HashSet ), count how many values we added.\\n4. return the count.\\n*/\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        int result = 0;\\n        for(String str: A){            \\n            if(set.add(getHashBySwap(str.toCharArray()))) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private String getHashBySwap(char[] chars){\\n        for(int i=0; i<chars.length;i++){            \\n            for(int j=i+2;j<chars.length;){\\n                if(chars[i] > chars[j]) {\\n                    char temp = chars[j];\\n                    chars[j] = chars[i];  \\n                    chars[i] = temp;\\n                }\\n                j+=2;\\n            }\\n        }\\n        \\n        return String.valueOf(chars);        \\n    }   \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        int result = 0;\\n        for(String str: A){            \\n            if(set.add(getHashBySwap(str.toCharArray()))) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private String getHashBySwap(char[] chars){\\n        for(int i=0; i<chars.length;i++){            \\n            for(int j=i+2;j<chars.length;){\\n                if(chars[i] > chars[j]) {\\n                    char temp = chars[j];\\n                    chars[j] = chars[i];  \\n                    chars[i] = temp;\\n                }\\n                j+=2;\\n            }\\n        }\\n        \\n        return String.valueOf(chars);        \\n    }   \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345036,
                "title": "python-solution",
                "content": "\\n```\\ndef numSpecialEquivGroups(self, A):\\n\\t\"\"\"\\n\\t:type A: List[str]\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tres = set()\\n\\tfor s in A:\\n\\t\\ts = \\'\\'.join(sorted(s[::2]) + sorted(s[1::2]))\\n\\t\\tres.add(s)\\n\\treturn len(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef numSpecialEquivGroups(self, A):\\n\\t\"\"\"\\n\\t:type A: List[str]\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tres = set()\\n\\tfor s in A:\\n\\t\\ts = \\'\\'.join(sorted(s[::2]) + sorted(s[1::2]))\\n\\t\\tres.add(s)\\n\\treturn len(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 271486,
                "title": "java-6ms-solution-easy-to-understand-with-explanation",
                "content": "The basic idea is putting the signature of each string to a set, then the size of set is the number of groups.\\nSince each string only contains lowercase letters, we can use two arrays ```odd[26]``` and ```even[26]``` to represents the frequency of 26 lowercase letters on odd place and even place of a string repectively. \\nThe signature of a string is apparently ```Arrays.toString(odd) + Arrays.toString(even)```.\\nThe code is as following:\\n```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tSet<String> group = new HashSet<String>();\\n\\tfor(int i = 0; i < A.length; i++) \\n\\t\\tgroup.add(getSignature(A[i]));\\n\\treturn group.size();\\n}\\n\\npublic String getSignature(String s) {\\n\\tint odd[] = new int[26];\\n\\tint even[] = new int[26];\\n\\tfor(int i = 0; i < s.length(); i += 2) \\n\\t\\teven[s.charAt(i) - \\'a\\']++;\\n\\tfor(int i = 1; i < s.length(); i += 2)\\n\\t\\todd[s.charAt(i) - \\'a\\']++;\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(odd[i]);\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(even[i]);\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```odd[26]```\n```even[26]```\n```Arrays.toString(odd) + Arrays.toString(even)```\n```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tSet<String> group = new HashSet<String>();\\n\\tfor(int i = 0; i < A.length; i++) \\n\\t\\tgroup.add(getSignature(A[i]));\\n\\treturn group.size();\\n}\\n\\npublic String getSignature(String s) {\\n\\tint odd[] = new int[26];\\n\\tint even[] = new int[26];\\n\\tfor(int i = 0; i < s.length(); i += 2) \\n\\t\\teven[s.charAt(i) - \\'a\\']++;\\n\\tfor(int i = 1; i < s.length(); i += 2)\\n\\t\\todd[s.charAt(i) - \\'a\\']++;\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(odd[i]);\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(even[i]);\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192733,
                "title": "my-c-solution",
                "content": "s1 is the substring containing only characters on odd position\\ns2 is the substring containing only characters on even position\\nsort s1 and s2, use s1 + s2 as the key of that string\\ncompare the key of each string\\n```\\n#include <unordered_set>\\n#include <algorithm>\\nusing std::unordered_set;\\nclass Solution {\\npublic:\\n    string key(string s)\\n    {\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(i % 2)\\n                s1 += s[i];\\n            else\\n                s2 += s[i];\\n        }\\n        std::sort(s1.begin(),s1.end());\\n        std::sort(s2.begin(),s2.end());\\n        return s1 + s2;\\n    }\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> sset;\\n        for(string s : A)\\n            sset.insert(key(s));\\n        return sset.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <unordered_set>\\n#include <algorithm>\\nusing std::unordered_set;\\nclass Solution {\\npublic:\\n    string key(string s)\\n    {\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(i % 2)\\n                s1 += s[i];\\n            else\\n                s2 += s[i];\\n        }\\n        std::sort(s1.begin(),s1.end());\\n        std::sort(s2.begin(),s2.end());\\n        return s1 + s2;\\n    }\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> sset;\\n        for(string s : A)\\n            sset.insert(key(s));\\n        return sset.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3227290,
                "title": "python-solution-run-time-77",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        lst=[]\\n        for i in words:\\n            evn=\\'\\'\\n            odd=\\'\\'\\n            for j in range(len(i)):\\n                if j%2==0:\\n                    evn+=i[j]\\n                else:\\n                    odd+=i[j]\\n            str=sorted(evn)+sorted(odd)\\n            lst.append(\"\".join(str))\\n        return len(Counter(lst))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        lst=[]\\n        for i in words:\\n            evn=\\'\\'\\n            odd=\\'\\'\\n            for j in range(len(i)):\\n                if j%2==0:\\n                    evn+=i[j]\\n                else:\\n                    odd+=i[j]\\n            str=sorted(evn)+sorted(odd)\\n            lst.append(\"\".join(str))\\n        return len(Counter(lst))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141695,
                "title": "c-solution-using-set-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>s;    // declare set of strings\\n        for(auto i:words){   \\n            string q=\"\";\\n            string w=\"\";\\n            for(int j=0;j<i.size();j++){\\n                if(j%2==0){\\n                    q+=i[j]; // form a string of even indices \\n                }\\n                else {\\n                    w+=i[j]; //form a string of odd indices \\n                }\\n            }\\n            sort(q.begin(),q.end()); // sort both strings separately\\n            sort(w.begin(),w.end());\\n            q+=w; // add them to form single string\\n            s.insert(q); // insert the added string to set \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>s;    // declare set of strings\\n        for(auto i:words){   \\n            string q=\"\";\\n            string w=\"\";\\n            for(int j=0;j<i.size();j++){\\n                if(j%2==0){\\n                    q+=i[j]; // form a string of even indices \\n                }\\n                else {\\n                    w+=i[j]; //form a string of odd indices \\n                }\\n            }\\n            sort(q.begin(),q.end()); // sort both strings separately\\n            sort(w.begin(),w.end());\\n            q+=w; // add them to form single string\\n            s.insert(q); // insert the added string to set \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249225,
                "title": "c-sol-using-set",
                "content": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(const auto& w : words){\\n            string odd, even;\\n            for(int i=0;i<w.length();i++){\\n                \\n                if(i%2!=0) odd += w[i];\\n                even += w[i];}\\n                sort(even.begin(), even.end());\\n                sort(odd.begin(), odd.end());\\n                s.insert(even+odd);\\n            \\n        }\\n        return s.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(const auto& w : words){\\n            string odd, even;\\n            for(int i=0;i<w.length();i++){\\n                \\n                if(i%2!=0) odd += w[i];\\n                even += w[i];}",
                "codeTag": "Java"
            },
            {
                "id": 1072832,
                "title": "easy-fast-understandable-c-solution",
                "content": "UPVOTE IF THE SOLUTION MAKES SENSE TO YOU\\n-> Solution to this problem as per this approach points to simple principle of dividing the string in to two parts - \\n - One string with characters from odd indexes.\\n - One string with characters from even indexes.\\n \\n Once we have these two individual parts, sort specific parts, combine them in to one and check for its existence in the hash map. If found increase frequency in hashmap else insert in hashmap.\\n\\n- Size of hashmap gives us the result to the problem.\\n- -> Alternatively we can just use a set since we just need number of unique strings.\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        int l = A.size();\\n\\t\\tunordered_map<string, int> map;               //  initialize hashmap\\n        for(int i=0;i<l;i++){\\n\\t\\t\\tstring cur = A[i];                                        // take current string from array\\n            int slen = cur.length();\\n            string os = \"\";\\n            string es = \"\";\\n            for(int j=0;j<slen;j++){\\n                if(j%2==0){                                         // check index is even or odd\\n                    os+=cur[j];\\n                }else{\\n                    es+=cur[j];\\n                }\\n            }\\n            sort(os.begin(),os.end());                       // sort by parts\\n            sort(es.begin(),es.end());\\n            cur = os+es;\\n            if(map.count(cur)>0){\\n                map[cur]+=1;\\n            }else{\\n                map[cur]=1;\\n            }\\n        }\\n        return map.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        int l = A.size();\\n\\t\\tunordered_map<string, int> map;               //  initialize hashmap\\n        for(int i=0;i<l;i++){\\n\\t\\t\\tstring cur = A[i];                                        // take current string from array\\n            int slen = cur.length();\\n            string os = \"\";\\n            string es = \"\";\\n            for(int j=0;j<slen;j++){\\n                if(j%2==0){                                         // check index is even or odd\\n                    os+=cur[j];\\n                }else{\\n                    es+=cur[j];\\n                }\\n            }\\n            sort(os.begin(),os.end());                       // sort by parts\\n            sort(es.begin(),es.end());\\n            cur = os+es;\\n            if(map.count(cur)>0){\\n                map[cur]+=1;\\n            }else{\\n                map[cur]=1;\\n            }\\n        }\\n        return map.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069262,
                "title": "python3-one-liner-solution-faster-than-69",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len({\\'\\'.join(sorted(a[::2]) + sorted(a[1::2])) for a in A})\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len({\\'\\'.join(sorted(a[::2]) + sorted(a[1::2])) for a in A})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717549,
                "title": "c-4-ms-without-sorting-beats-100-time-99-space",
                "content": "In this problem, it is understood that for a string if we maintain 2 hashsets for count of characters in odd and even places, and if both these hashsets match (corresponding) for 2 given strings, then both the strings can be grouped together i.e. are equivalent.\\n\\nBut to maintain a set of hashsets is a tedious job.\\n\\nSo to overcome that we maintain a unique identifier for these strings.( Example - we could have taken the sum of character values)\\n\\nBut then a simple sum wouldn\\'t give us a unique identifier. Eg -  \\'abad\\' and \\'acac\\' would map to same values i.e (0+0,1+3) = (0+0,2+2) i.e. (0,4)\\n\\nSo we look for a solution where sum of any 2 characters should not be equal to any other 2 characters.\\n\\nHence instead of labelling the characters from 0 to 25, we label them from 1 to 2^25.\\n```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        set<pair<long long, long long>> s;\\n        int arr[26];\\n        arr[0] = 1;\\n        for(int i=1;i<26;i++)\\n            arr[i] = 2*arr[i-1];\\n        for(int i=0;i<A.size();i++)\\n        {\\n            long long a = 0;\\n            long long b = 0;\\n            for(int j=0;j<A[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    a += arr[A[i][j]-\\'a\\'];\\n                else\\n                    b += arr[A[i][j]-\\'a\\'];\\n            }\\n            s.insert(make_pair(a,b));\\n        }\\n        return s.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        set<pair<long long, long long>> s;\\n        int arr[26];\\n        arr[0] = 1;\\n        for(int i=1;i<26;i++)\\n            arr[i] = 2*arr[i-1];\\n        for(int i=0;i<A.size();i++)\\n        {\\n            long long a = 0;\\n            long long b = 0;\\n            for(int j=0;j<A[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    a += arr[A[i][j]-\\'a\\'];\\n                else\\n                    b += arr[A[i][j]-\\'a\\'];\\n            }\\n            s.insert(make_pair(a,b));\\n        }\\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702121,
                "title": "ruby-solution-represent-word-as-array-of-52-elements-with-2-histograms-in-it",
                "content": "#### Leetcode: 893. Groups of Special-Equivalent Strings.\\n\\n\\n\\n##### Simplified approach.\\n\\n`thnx @quantumlexa`  \\n\\nTwo strings are special equivalent if their histograms for even and odd indices are equal. Histogram for a word can be represented as 52 elments array, 26 for even 26 for odd symbols. Array mapped from array of words to array of histograms. Then make array contain only uniq values and return it\\'s size.\\n\\nRuby code: \\n```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# thnx @quantumlexa\\n# Runtime: 92 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.3 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }.uniq.size\\nend\\n```\\n\\n##### Initial accepted approach.\\n\\nTwo strings are special equivalent if their histograms for even indexed chars and odd indexed chars are equal. Because there are only 26 different chars in this task, the both histograms could be represented as array of 52 elements. First map array of strings to array of histograms. Than create array name used to mark words that already in groups, and compare all words with each other by two loops external and internal one. External one iterates over all indexes, and internal start iteration from index after external one. Skip indexes already in groups for both arrays. When pointing on new index in external array if it is not used new group is started, during internal loop mark all words in this group as used. So on next iteration of external loop indices of this group will be skipped.\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# Runtime: 260 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.1 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }\\n    groups = 0\\n    used = Array.new(arr.size,false)\\n    (0...arr.size).each do |i|\\n        next if used[i]\\n        used[i] = true\\n        groups += 1\\n        (i+1...arr.size).each do |j|\\n            next if used[j]\\n            used[j] = true if arr[i] == arr[j] \\n        end\\n    end\\n    groups\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# thnx @quantumlexa\\n# Runtime: 92 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.3 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }.uniq.size\\nend\\n```\n```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# Runtime: 260 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.1 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }\\n    groups = 0\\n    used = Array.new(arr.size,false)\\n    (0...arr.size).each do |i|\\n        next if used[i]\\n        used[i] = true\\n        groups += 1\\n        (i+1...arr.size).each do |j|\\n            next if used[j]\\n            used[j] = true if arr[i] == arr[j] \\n        end\\n    end\\n    groups\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 574377,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        l=[]\\n        for s in A:\\n            even=\"\"\\n            odd=\"\"\\n            for i in range(len(s)):\\n                if i%2!=0:\\n                    odd+=s[i]\\n                    \\n                else:\\n                    even+=s[i]\\n                    \\n            odd = \\'\\'.join(sorted(odd))\\n            even = \\'\\'.join(sorted(even)) \\n            # odd=sorted(odd)\\n            # even=sorted(even)\\n            \\n            l.append(str(odd)+str(even))\\n            \\n        # print(l)    \\n            \\n        return len(set(l))     \\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        l=[]\\n        for s in A:\\n            even=\"\"\\n            odd=\"\"\\n            for i in range(len(s)):\\n                if i%2!=0:\\n                    odd+=s[i]\\n                    \\n                else:\\n                    even+=s[i]\\n                    \\n            odd = \\'\\'.join(sorted(odd))\\n            even = \\'\\'.join(sorted(even)) \\n            # odd=sorted(odd)\\n            # even=sorted(even)\\n            \\n            l.append(str(odd)+str(even))\\n            \\n        # print(l)    \\n            \\n        return len(set(l))     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 512298,
                "title": "python3-group-strings-by-sorting-characters-at-even-odd-indices",
                "content": "Algorithm:\\nHere, we need a way to group strings so that each group is a special-equivalent group. Counting is one way as suggested by the Solution. Here, I\\'ve used sorting-based approach. For a given string, sort the characters at even and odd indices respectively and join them. \\n\\n(36ms, 96.54%): \\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        fn = lambda s: \"\".join(sorted(s[::2]) + sorted(s[1::2]))\\n        return len(set(fn(s) for s in A))\\n```\\n\\nAnalysis:\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n\\nComment: Even though the time complexity is `O(NlogN)` in this approach, given `1 <= A[i].length <= 20`, it is still competative in terms of performance.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        fn = lambda s: \"\".join(sorted(s[::2]) + sorted(s[1::2]))\\n        return len(set(fn(s) for s in A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508798,
                "title": "go-0ms-map-solution",
                "content": "```go\\nfunc numSpecialEquivGroups(A []string) int {\\n    m := map[[52]int]interface{}{}\\n    for _, s := range A {\\n        array := [52]int{}\\n        for i, c := range s {\\n            if i % 2 == 0 {\\n                array[c-\\'a\\']++\\n            } else {\\n                array[c-\\'a\\'+26]++\\n            }\\n        }\\n        m[array] = nil\\n    }\\n    return len(m)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc numSpecialEquivGroups(A []string) int {\\n    m := map[[52]int]interface{}{}\\n    for _, s := range A {\\n        array := [52]int{}\\n        for i, c := range s {\\n            if i % 2 == 0 {\\n                array[c-\\'a\\']++\\n            } else {\\n                array[c-\\'a\\'+26]++\\n            }\\n        }\\n        m[array] = nil\\n    }\\n    return len(m)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289642,
                "title": "java-4ms-customized-hashing-algorithm-easy-to-understand",
                "content": "customized a hashing algorithm that:\\n1.split the string into 2 parts by index , the odd part and the even part\\n2.count each char (a ~ z) in each part\\n3.combine the count result into a hashing string\\n4.just add hashing string into a set\\n5.return the size of this set\\n```\\nclass Solution {\\n    \\n    private String hash(String a){\\n        char[][] count = new char[2][26];\\n        \\n        Arrays.fill(count[0],\\'a\\');\\n        Arrays.fill(count[1],\\'a\\');  \\n        \\n        int index =0;\\n        \\n        for(char c : a.toCharArray()){\\n            count[index%2][c-\\'a\\']++;\\n            index++;\\n        }\\n       return (new String(count[0]))+\"_\"+(new String(count[1]));\\n    }\\n    \\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String aString: A){\\n            set.add(hash(aString));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private String hash(String a){\\n        char[][] count = new char[2][26];\\n        \\n        Arrays.fill(count[0],\\'a\\');\\n        Arrays.fill(count[1],\\'a\\');  \\n        \\n        int index =0;\\n        \\n        for(char c : a.toCharArray()){\\n            count[index%2][c-\\'a\\']++;\\n            index++;\\n        }\\n       return (new String(count[0]))+\"_\"+(new String(count[1]));\\n    }\\n    \\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String aString: A){\\n            set.add(hash(aString));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287734,
                "title": "python-easy-to-understand-1-liner-other-faster-solution",
                "content": "In the one liner, you just return the length of the set of tuples. Each tuple contain (sorted letters of even indexed letters, sorted letters of odd indexed letters). This should be O(N*klogk), with k being the length of each word.\\n\\n`return len(set(tuple(sorted(word[::2])+sorted(word[1::2])) for word in A))`\\n\\nThis is the second solution, which is technically O(N*k), because each tup can only be length of 52, no matter how long k or N is. \\n\\nThey both run in 36 ms though, so a great example of when big O is not super helpful. \\n\\n```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        uniqueSet = set()\\n        for word in A:\\n            tup = [0]*52\\n            for i in range(len(word)):\\n                tup[(ord(word[i])-ord(\\'a\\')) + 26*(i %2)] += 1 \\n            uniqueSet.add(tuple(tup))\\n        return len(uniqueSet)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        uniqueSet = set()\\n        for word in A:\\n            tup = [0]*52\\n            for i in range(len(word)):\\n                tup[(ord(word[i])-ord(\\'a\\')) + 26*(i %2)] += 1 \\n            uniqueSet.add(tuple(tup))\\n        return len(uniqueSet)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190844,
                "title": "python3-one-liner",
                "content": "```\\n    def numSpecialEquivGroups(self, A):\\n        return len({\\'\\'.join(sorted(word[::2]))+\\'\\'.join(sorted(word[1::2])) for word in A})\\n```\\nuses letters at even positions, sorted, and letters at odd positions, also sorted, and combines them into a single string used as they key for a set, then returns the length of that set, e.g. the number of different unique keys. Each keys is a group.",
                "solutionTags": [],
                "code": "```\\n    def numSpecialEquivGroups(self, A):\\n        return len({\\'\\'.join(sorted(word[::2]))+\\'\\'.join(sorted(word[1::2])) for word in A})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 169447,
                "title": "possible-javascript-solution-with-map-and-sort",
                "content": "```\\nvar numSpecialEquivGroups = function(A) {\\n    var odd;\\n    var even;\\n    var key;\\n    var count = 0;\\n    var map = Object.create(null);\\n    for (var i = 0; i < A.length; i++) {\\n        odd = [];\\n        even = [];\\n        for (var j = 0; j < A[i].length; j++) {\\n            if (j % 2 === 0) {\\n                even.push(A[i][j]);\\n            } else {\\n                odd.push(A[i][j]);\\n            }\\n        }\\n        \\n        even.sort();\\n        odd.sort();\\n        \\n        key = even.join(\"\") + odd.join(\"\");\\n        if (!map[key]) {\\n            map[key] = true;\\n            count++;\\n        }\\n    }\\n        \\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numSpecialEquivGroups = function(A) {\\n    var odd;\\n    var even;\\n    var key;\\n    var count = 0;\\n    var map = Object.create(null);\\n    for (var i = 0; i < A.length; i++) {\\n        odd = [];\\n        even = [];\\n        for (var j = 0; j < A[i].length; j++) {\\n            if (j % 2 === 0) {\\n                even.push(A[i][j]);\\n            } else {\\n                odd.push(A[i][j]);\\n            }\\n        }\\n        \\n        even.sort();\\n        odd.sort();\\n        \\n        key = even.join(\"\") + odd.join(\"\");\\n        if (!map[key]) {\\n            map[key] = true;\\n            count++;\\n        }\\n    }\\n        \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164161,
                "title": "c-solution-beats-100",
                "content": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        set<string> s;\\n        \\n        for (auto &a : A) {\\n            string s1;\\n            string s2;\\n            for (int i = 0; i < a.size(); i++) {\\n                if (i % 2 == 0)\\n                    s1 += a[i];\\n                else\\n                    s2 += a[i];\\n            }\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            s.insert(s1 + s2);\\n        }\\n            \\n        return s.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        set<string> s;\\n        \\n        for (auto &a : A) {\\n            string s1;\\n            string s2;\\n            for (int i = 0; i < a.size(); i++) {\\n                if (i % 2 == 0)\\n                    s1 += a[i];\\n                else\\n                    s2 += a[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3888784,
                "title": "set-easy-c-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter **sorting** the **even and odd Position characters** of a string put it into a **unordered set** and finally return the **size** of the set.\\n\\n# Complexity\\n- Time complexity:O(N * 20 * 10 * Log(10))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        unordered_set<string> st;\\n        for(int i = 0;i<w.size();i++)\\n        {\\n            string even = \"\",odd = \"\";\\n            for(int j = 0;j<w[i].size();j++)\\n            {\\n                if(j%2) odd+=w[i][j];\\n                else even+=w[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            st.insert(even+odd);\\n        }\\n        return st.size();\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/a09140aa-537b-4890-9c3c-1f7ab2a60bab_1691642025.638834.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        unordered_set<string> st;\\n        for(int i = 0;i<w.size();i++)\\n        {\\n            string even = \"\",odd = \"\";\\n            for(int j = 0;j<w[i].size();j++)\\n            {\\n                if(j%2) odd+=w[i][j];\\n                else even+=w[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            st.insert(even+odd);\\n        }\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511728,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```\\n\\n```Java []\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<Integer> uniques = new HashSet<>();\\n        for (String word : words) uniques.add(customHash(word));\\n        return uniques.size();\\n    }\\n    private int customHash(String word) {\\n        int[] evenFreqs = new int[26], oddFreqs = new int[26];\\n        byte[] chars = word.getBytes();\\n\\n        int n = chars.length;\\n        for (int i = 0, limit = n / 2 * 2; i < limit; i += 2) {\\n            ++evenFreqs[chars[i] - \\'a\\'];\\n            ++oddFreqs[chars[i + 1] - \\'a\\'];\\n        }\\n        if (n % 2 == 1) ++evenFreqs[chars[n - 1] - \\'a\\'];\\n        int acc = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            acc = 31 * acc + evenFreqs[i];\\n            acc = 31 * acc + oddFreqs[i];\\n        }\\n        return acc;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```\n```Java []\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<Integer> uniques = new HashSet<>();\\n        for (String word : words) uniques.add(customHash(word));\\n        return uniques.size();\\n    }\\n    private int customHash(String word) {\\n        int[] evenFreqs = new int[26], oddFreqs = new int[26];\\n        byte[] chars = word.getBytes();\\n\\n        int n = chars.length;\\n        for (int i = 0, limit = n / 2 * 2; i < limit; i += 2) {\\n            ++evenFreqs[chars[i] - \\'a\\'];\\n            ++oddFreqs[chars[i + 1] - \\'a\\'];\\n        }\\n        if (n % 2 == 1) ++evenFreqs[chars[n - 1] - \\'a\\'];\\n        int acc = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            acc = 31 * acc + evenFreqs[i];\\n            acc = 31 * acc + oddFreqs[i];\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183359,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n       HashSet<String> h=new HashSet<>();\\n       for(String str:words){\\n           int[] odd=new int[26];\\n           int [] even=new int[26];\\n           for(int i=0;i<str.length();i++){\\n               if(i%2==0){\\n                   even[str.charAt(i)-\\'a\\']++;\\n               }else{\\n                   odd[str.charAt(i)-\\'a\\']++;\\n               }}\\n               String key=Arrays.toString(odd)+Arrays.toString(even);\\n               h.add(key);\\n           \\n       }\\n       return h.size(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n       HashSet<String> h=new HashSet<>();\\n       for(String str:words){\\n           int[] odd=new int[26];\\n           int [] even=new int[26];\\n           for(int i=0;i<str.length();i++){\\n               if(i%2==0){\\n                   even[str.charAt(i)-\\'a\\']++;\\n               }else{\\n                   odd[str.charAt(i)-\\'a\\']++;\\n               }}\\n               String key=Arrays.toString(odd)+Arrays.toString(even);\\n               h.add(key);\\n           \\n       }\\n       return h.size(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117083,
                "title": "pyton3-easy-to-understand-solution",
                "content": "# Approach\\nSort the odd indices and even indices of the word seperately. Then combine those 2 to get the key value which is the same for special equivalent strings.\\n\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = defaultdict(list)\\n        for word in words:\\n            odd , even = \"\",\\'\\'\\n            for idx,char in enumerate(word):\\n                if idx%2 == 0:\\n                    even += char\\n                else:\\n                    odd+= char\\n\\n            odd = sorted(odd)\\n            even = sorted(even)\\n            final = \"\".join(odd+even)\\n            \\n            d[final].append(word)\\n\\n        \\n        return len(d.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = defaultdict(list)\\n        for word in words:\\n            odd , even = \"\",\\'\\'\\n            for idx,char in enumerate(word):\\n                if idx%2 == 0:\\n                    even += char\\n                else:\\n                    odd+= char\\n\\n            odd = sorted(odd)\\n            even = sorted(even)\\n            final = \"\".join(odd+even)\\n            \\n            d[final].append(word)\\n\\n        \\n        return len(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008213,
                "title": "general-approach",
                "content": "# Intuition\\nOdd index characters should be same and even index characters should be same for 2 different strings\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2*(20+20log20)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        int n=a.size();\\n        vector<bool>check(n,false);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(check[i]) continue;\\n            string odda=\"\";\\n            string evena=\"\";\\n            for(int k=0;k<a[i].size();k++){\\n                if(k%2) odda+=a[i][k];\\n                else evena+=a[i][k];\\n            }\\n            sort(begin(odda),end(odda));\\n            sort(begin(evena),end(evena));\\n            ans++;\\n            check[i]=true;\\n            for(int j=i+1;j<n;j++){\\n                if(check[j]) continue;\\n                string oddb=\"\";\\n                string evenb=\"\";\\n                for(int k=0;k<a[i].size();k++){\\n                    if(k%2) oddb+=a[j][k];\\n                    else evenb+=a[j][k];\\n                }\\n                sort(begin(oddb),end(oddb));\\n                sort(begin(evenb),end(evenb));\\n                if(odda==oddb&&evena==evenb){\\n                    check[j]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        int n=a.size();\\n        vector<bool>check(n,false);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(check[i]) continue;\\n            string odda=\"\";\\n            string evena=\"\";\\n            for(int k=0;k<a[i].size();k++){\\n                if(k%2) odda+=a[i][k];\\n                else evena+=a[i][k];\\n            }\\n            sort(begin(odda),end(odda));\\n            sort(begin(evena),end(evena));\\n            ans++;\\n            check[i]=true;\\n            for(int j=i+1;j<n;j++){\\n                if(check[j]) continue;\\n                string oddb=\"\";\\n                string evenb=\"\";\\n                for(int k=0;k<a[i].size();k++){\\n                    if(k%2) oddb+=a[j][k];\\n                    else evenb+=a[j][k];\\n                }\\n                sort(begin(oddb),end(oddb));\\n                sort(begin(evenb),end(evenb));\\n                if(odda==oddb&&evena==evenb){\\n                    check[j]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931040,
                "title": "java-92-time-94-memory-solution",
                "content": "# Approach\\n1. To define groups I need to find smth common between strings, which belong to one group. So, I create 2 arrays with size of 26 (alph -> alphabet). Inside findAlphabet() I go through evenly indexed letters and increment the relevant index in the first alph array. The same applied to letters with odd indices.\\n2. Then I will use String as a key. For that I concatenate all numbers from both alph arrays. Then I use these strings to define uniqueness and put into the set.\\n3. Finally, just return the size of that set.\\n\\nCheers! \\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        if (words.length == 1) return 1;\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < words.length; i++) {\\n            set.add(findAlphabet(words[i]));\\n        }\\n        return set.size();\\n    }\\n\\n    private static String findAlphabet(String word) {\\n        byte[][] alph = new byte[2][26];\\n        for (int i = 0; i < word.length(); i+=2) {\\n            alph[0][word.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 1; i < word.length(); i+=2) {\\n            alph[1][word.charAt(i) - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            sb.append(alph[0][i]);\\n            sb.append(alph[1][i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        if (words.length == 1) return 1;\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < words.length; i++) {\\n            set.add(findAlphabet(words[i]));\\n        }\\n        return set.size();\\n    }\\n\\n    private static String findAlphabet(String word) {\\n        byte[][] alph = new byte[2][26];\\n        for (int i = 0; i < word.length(); i+=2) {\\n            alph[0][word.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 1; i < word.length(); i+=2) {\\n            alph[1][word.charAt(i) - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            sb.append(alph[0][i]);\\n            sb.append(alph[1][i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760511,
                "title": "solution-runtime-16-ms-faster-than-63-18-and-memory-8-8-mb-less-than-68-16-of-c-submissions",
                "content": "The idea is really very naive \\uD83D\\uDE05\\uD83D\\uDE05 .....the thought was if i create a unique key for a single group of equivalent strings\\n\\n-> Take even poisitioned characters and add them to form a string, then take odd poisitioned characters and add them to form a string.\\n-> Now, sort both the strings as the question mentioned only odd poisitioned characters can be swapped with odd poistioned characters (same for even ones) if we sort them they must be equal\\n->Append both the strings to form a key and put it into a map\\n->Size of the map is our anwser\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        map<string,int> mp;\\n        for(int i=0;i<w.size();i++)\\n            {\\n                string e=\"\",o=\"\",s=w[i];\\n                for(int j=0;j<s.size();j++)\\n                {\\n                    if(j%2==0)\\n                        e+=s[j];\\n                    else\\n                        o+=s[j];\\n                }\\n                sort(e.begin(),e.end());\\n                sort(o.begin(),o.end());\\n                mp[e+o]++;\\n            }\\n   return mp.size(); }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        map<string,int> mp;\\n        for(int i=0;i<w.size();i++)\\n            {\\n                string e=\"\",o=\"\",s=w[i];\\n                for(int j=0;j<s.size();j++)\\n                {\\n                    if(j%2==0)\\n                        e+=s[j];\\n                    else\\n                        o+=s[j];\\n                }\\n                sort(e.begin(),e.end());\\n                sort(o.begin(),o.end());\\n                mp[e+o]++;\\n            }\\n   return mp.size(); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491195,
                "title": "c-easy-solution-using-sets-and-hashmaps",
                "content": "\\n\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        vector<pair<string,string>>v;\\n        \\n        for(auto it:words)\\n        {\\n            string even=\"\";\\n            string odd=\"\";\\n            for(int i=0;i<it.size();i+=2)even+=it[i];\\n            for(int i=1;i<it.size();i+=2)odd+=it[i];\\n             sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            \\n            even+=odd;\\n            v.push_back({it,even});\\n        }\\n        \\n        map<string,int>m;\\n        for(auto it:v)\\n            m[it.second]++;\\n        \\n        for(auto it: m)\\n            cout<<it.first<<\" \";\\n        \\n        return m.size();\\n    }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        vector<pair<string,string>>v;\\n        \\n        for(auto it:words)\\n        {\\n            string even=\"\";\\n            string odd=\"\";\\n            for(int i=0;i<it.size();i+=2)even+=it[i];\\n            for(int i=1;i<it.size();i+=2)odd+=it[i];\\n             sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            \\n            even+=odd;\\n            v.push_back({it,even}",
                "codeTag": "Java"
            },
            {
                "id": 2488710,
                "title": "python-o-n-m-hashmap-83-04",
                "content": "```\\ndef numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n        for word in words:\\n            even = [0] * 26\\n            odd = [0] * 26\\n            for i, c in enumerate(word):\\n                if i % 2 == 0:\\n                    even[ord(c) - ord(\\'a\\')] += 1\\n                else:\\n                    odd[ord(c) - ord(\\'a\\')] += 1\\n            hsh = tuple(even) + tuple(odd)\\n            if hsh not in d:\\n                d[hsh] = set()\\n            d[hsh].add(word)\\n        return len(d)\\n```",
                "solutionTags": [
                    "Python",
                    "Counting Sort"
                ],
                "code": "```\\ndef numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n        for word in words:\\n            even = [0] * 26\\n            odd = [0] * 26\\n            for i, c in enumerate(word):\\n                if i % 2 == 0:\\n                    even[ord(c) - ord(\\'a\\')] += 1\\n                else:\\n                    odd[ord(c) - ord(\\'a\\')] += 1\\n            hsh = tuple(even) + tuple(odd)\\n            if hsh not in d:\\n                d[hsh] = set()\\n            d[hsh].add(word)\\n        return len(d)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2434743,
                "title": "python-1-line",
                "content": "```\\nreturn len(Counter(\\'\\'.join(sorted(w[::2])+sorted(w[1::2])) for w in words))\\n```",
                "solutionTags": [],
                "code": "```\\nreturn len(Counter(\\'\\'.join(sorted(w[::2])+sorted(w[1::2])) for w in words))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1927968,
                "title": "a-sort-and-simple-solution-in-c",
                "content": "```\\n\\t\\t\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        \\n        set<string> s;\\n        \\n        for(int i=0;i<words.size();i++){\\n            \\n            string st = words[i];\\n            string odd = \"\";\\n            string even = \"\";\\n            \\n            for(int j=0;j<st.size();j++){\\n                if(j%2==0)\\n                    even=even+st[j];\\n                else\\n                    odd=odd+st[j];\\n            }\\n            \\n            sort(odd.begin(),odd.end());\\n            sort(even.begin(),even.end());\\n            string t=even+odd;\\n            s.insert(t);\\n        }\\n        return s.size();\\n    }",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        \\n        set<string> s;\\n        \\n        for(int i=0;i<words.size();i++){\\n            \\n            string st = words[i];\\n            string odd = \"\";\\n            string even = \"\";\\n            \\n            for(int j=0;j<st.size();j++){\\n                if(j%2==0)\\n                    even=even+st[j];\\n                else\\n                    odd=odd+st[j];\\n            }\\n            \\n            sort(odd.begin(),odd.end());\\n            sort(even.begin(),even.end());\\n            string t=even+odd;\\n            s.insert(t);\\n        }\\n        return s.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1615905,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // This function stores the character frequency of the odd and even positions of a string\\n    void filler(string &str,vector<int>&odd,vector<int>&even) {\\n        for(int i=0;i<str.length();i++) {\\n            if(i%2==0) {\\n                even[str[i]-\\'a\\']++;\\n            }\\n            else {\\n                odd[str[i]-\\'a\\']++;\\n            }\\n        }\\n    }\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        \\n        // set is for grouping the strings.\\n        // The first element of pair is odd frequency\\n        // The second element of pair is even frequency\\n        set<pair<vector<int>,vector<int>>>dict;\\n        \\n        // odd vector stores the frequency at the odd positions of all the strings \\n        vector<vector<int>>odd(n,vector<int>(26,0));\\n        \\n        // even vector stores the frequency at the even positions of all the strings \\n        vector<vector<int>>even(n,vector<int>(26,0));\\n        for(int i=0;i<words.size();i++) {\\n            // calculate the frequency\\n            filler(words[i],odd[i],even[i]);\\n            \\n            // group the string \\n            dict.insert({odd[i],even[i]});\\n        }\\n        \\n        // finally set size will the group size\\n        return dict.size();\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // This function stores the character frequency of the odd and even positions of a string\\n    void filler(string &str,vector<int>&odd,vector<int>&even) {\\n        for(int i=0;i<str.length();i++) {\\n            if(i%2==0) {\\n                even[str[i]-\\'a\\']++;\\n            }\\n            else {\\n                odd[str[i]-\\'a\\']++;\\n            }\\n        }\\n    }\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        \\n        // set is for grouping the strings.\\n        // The first element of pair is odd frequency\\n        // The second element of pair is even frequency\\n        set<pair<vector<int>,vector<int>>>dict;\\n        \\n        // odd vector stores the frequency at the odd positions of all the strings \\n        vector<vector<int>>odd(n,vector<int>(26,0));\\n        \\n        // even vector stores the frequency at the even positions of all the strings \\n        vector<vector<int>>even(n,vector<int>(26,0));\\n        for(int i=0;i<words.size();i++) {\\n            // calculate the frequency\\n            filler(words[i],odd[i],even[i]);\\n            \\n            // group the string \\n            dict.insert({odd[i],even[i]});\\n        }\\n        \\n        // finally set size will the group size\\n        return dict.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413780,
                "title": "java-hashset-very-easy",
                "content": "```\\n public int numSpecialEquivGroups(String[] words) {\\n         HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int numSpecialEquivGroups(String[] words) {\\n         HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387210,
                "title": "python3-hashset",
                "content": "TIME COMPLEXITY - O ( n * len ( word[ i ] ) )\\nSPACE COMPLEXITY - O(N) in worst case\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        hset=set()\\n        for i in range(len(words)):\\n            even=[0]*26\\n            odd=[0]*26\\n            for j in range(len(words[i])):\\n                if j%2==0:\\n                    even[ord(words[i][j])-ord(\\'a\\')]+=1\\n                else:\\n                    odd[ord(words[i][j])-ord(\\'a\\')]+=1\\n            hset.add(\"\".join([str(even[i]) for i in range(len(even))])+\"\".join([str(odd[i]) for i in range(len(odd))]))\\n        return len(hset)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        hset=set()\\n        for i in range(len(words)):\\n            even=[0]*26\\n            odd=[0]*26\\n            for j in range(len(words[i])):\\n                if j%2==0:\\n                    even[ord(words[i][j])-ord(\\'a\\')]+=1\\n                else:\\n                    odd[ord(words[i][j])-ord(\\'a\\')]+=1\\n            hset.add(\"\".join([str(even[i]) for i in range(len(even))])+\"\".join([str(odd[i]) for i in range(len(odd))]))\\n        return len(hset)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369289,
                "title": "java-straight-forward-with-explanation-and-example",
                "content": "\\nQuestion is super convoluted. You just want the max number of string pair where if you can switch any even index char and/or odd index char, they match.\\n\\nUsing the given example, this is the mental mapping you want: \\n```\\n[\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\\nabcd -> ac | bd\\ncbad -> ac | bd\\nxyzz -> xz | yz\\nzzxy -> xz | yz\\nzzyz -> yz | xz\\n```\\n\\nApproach:\\n1. for each string, group the characters in the even index\\n2. group the characters in the odd index\\n3. sort the group from step 1 and 2\\n4. combine the sorted values from 3 `(e.g. (sorted chars from 1) | (sorted chars from 2)`\\n5. use a map to count the groups you encountered, and increment by 1\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            \\n            StringBuilder odd = new StringBuilder();\\n            StringBuilder even = new StringBuilder();\\n            \\n            String word = words[i];\\n            for (int j = 0; j < word.length(); j++) {\\n                if (j % 2 == 0) even.append(word.charAt(j));\\n                else odd.append(word.charAt(j));\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(sortString(odd.toString()));\\n            sb.append(sortString(even.toString()));\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0));\\n        }\\n        \\n        return map.size();\\n    }\\n    \\n    private String sortString(String str) {\\n        char[] chars = str.toCharArray();\\n        Arrays.sort(chars);\\n        return new String(chars);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\\nabcd -> ac | bd\\ncbad -> ac | bd\\nxyzz -> xz | yz\\nzzxy -> xz | yz\\nzzyz -> yz | xz\\n```\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            \\n            StringBuilder odd = new StringBuilder();\\n            StringBuilder even = new StringBuilder();\\n            \\n            String word = words[i];\\n            for (int j = 0; j < word.length(); j++) {\\n                if (j % 2 == 0) even.append(word.charAt(j));\\n                else odd.append(word.charAt(j));\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(sortString(odd.toString()));\\n            sb.append(sortString(even.toString()));\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0));\\n        }\\n        \\n        return map.size();\\n    }\\n    \\n    private String sortString(String str) {\\n        char[] chars = str.toCharArray();\\n        Arrays.sort(chars);\\n        return new String(chars);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366209,
                "title": "c-very-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, bool> umap;\\n        int ans = 0;\\n        for(int i=0; i<words.size(); i++){\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int j=0; j<words[i].length(); j++){\\n                if(j%2) odd += words[i][j];\\n                else even += words[i][j];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            string s = odd + even;\\n            if(umap[s] == 0){\\n                umap[s] = 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, bool> umap;\\n        int ans = 0;\\n        for(int i=0; i<words.size(); i++){\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int j=0; j<words[i].length(); j++){\\n                if(j%2) odd += words[i][j];\\n                else even += words[i][j];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            string s = odd + even;\\n            if(umap[s] == 0){\\n                umap[s] = 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315604,
                "title": "java-90-faster",
                "content": "```\\nclass Solution {\\n    String sortString(String str) {\\n        char []arr = str.toCharArray();\\n        Arrays.sort(arr);\\n        return (String.valueOf(arr));\\n    }\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String s:words){\\n            StringBuilder curr = new StringBuilder();\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            sb = new StringBuilder();\\n            for(int i=1;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            set.add(curr.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String sortString(String str) {\\n        char []arr = str.toCharArray();\\n        Arrays.sort(arr);\\n        return (String.valueOf(arr));\\n    }\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String s:words){\\n            StringBuilder curr = new StringBuilder();\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            sb = new StringBuilder();\\n            for(int i=1;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            set.add(curr.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312111,
                "title": "poor-description",
                "content": "This question has a simple solution. but it took alot of time to just understand the question\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n            int len=words[0].length();\\n            int max=0;\\n            Map<String, Integer> map=new HashMap();\\n            for(String s:words)\\n            {\\n                 StringBuilder sb=new StringBuilder();\\n                 for(int i=0;i<len;i+=2)\\n                 {\\n                    sb.append(s.charAt(i));\\n                 }\\n                 char[] c=sb.toString().toCharArray();\\n                 StringBuilder sb1=new StringBuilder();\\n                 for(int i=1;i<len;i+=2)\\n                 {\\n                    sb1.append(s.charAt(i));\\n                    \\n                 }\\n                 char[] b=sb1.toString().toCharArray();\\n                 Arrays.sort(c);\\n                 Arrays.sort(b);\\n                 String temp=new String(b)+\"#\"+new String(c);\\n                 map.put(temp,map.getOrDefault(temp,0)+1);\\n                 max=Math.max(max,map.get(temp));\\n            }\\n            return map.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n            int len=words[0].length();\\n            int max=0;\\n            Map<String, Integer> map=new HashMap();\\n            for(String s:words)\\n            {\\n                 StringBuilder sb=new StringBuilder();\\n                 for(int i=0;i<len;i+=2)\\n                 {\\n                    sb.append(s.charAt(i));\\n                 }\\n                 char[] c=sb.toString().toCharArray();\\n                 StringBuilder sb1=new StringBuilder();\\n                 for(int i=1;i<len;i+=2)\\n                 {\\n                    sb1.append(s.charAt(i));\\n                    \\n                 }\\n                 char[] b=sb1.toString().toCharArray();\\n                 Arrays.sort(c);\\n                 Arrays.sort(b);\\n                 String temp=new String(b)+\"#\"+new String(c);\\n                 map.put(temp,map.getOrDefault(temp,0)+1);\\n                 max=Math.max(max,map.get(temp));\\n            }\\n            return map.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285114,
                "title": "c-simple-aesy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n    int i=0,n=words.size();\\n    vector<vector<string>> res;\\n\\n    while(i<n){\\n        int j=0,m=words[i].length();\\n        string strt=words[i],t1=\"\",t2=\"\";\\n        while(j<m){\\n\\n            if(j%2==0){\\n                t1+=strt[j];\\n            }else{\\n                t2+=strt[j];\\n            }\\n            j++;\\n        }\\n        sort(t1.begin(),t1.end());\\n        sort(t2.begin(),t2.end());\\n        vector<string> temp;\\n        temp.push_back(t1);\\n        temp.push_back(t2);\\n        res.push_back(temp);\\n        temp.clear();\\n        i++;\\n    }\\n   \\n    i=0;\\n    sort(res.begin(),res.end());\\n    \\n    i=0;\\n    int r=0;\\n    while(i<n){\\n        vector<string> t=res[i];\\n        i++;\\n        while(i<n && res[i]==t){\\n            i++;\\n        }\\n        cout<<\" yes \"<<i;\\n        r++;\\n\\n    }\\n    return r;\\n\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n    int i=0,n=words.size();\\n    vector<vector<string>> res;\\n\\n    while(i<n){\\n        int j=0,m=words[i].length();\\n        string strt=words[i],t1=\"\",t2=\"\";\\n        while(j<m){\\n\\n            if(j%2==0){\\n                t1+=strt[j];\\n            }else{\\n                t2+=strt[j];\\n            }\\n            j++;\\n        }\\n        sort(t1.begin(),t1.end());\\n        sort(t2.begin(),t2.end());\\n        vector<string> temp;\\n        temp.push_back(t1);\\n        temp.push_back(t2);\\n        res.push_back(temp);\\n        temp.clear();\\n        i++;\\n    }\\n   \\n    i=0;\\n    sort(res.begin(),res.end());\\n    \\n    i=0;\\n    int r=0;\\n    while(i<n){\\n        vector<string> t=res[i];\\n        i++;\\n        while(i<n && res[i]==t){\\n            i++;\\n        }\\n        cout<<\" yes \"<<i;\\n        r++;\\n\\n    }\\n    return r;\\n\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1274117,
                "title": "c-4ms-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(std::vector<std::string>& words) {\\n    std::set<std::string> normed;\\n    for (auto && word : words) {\\n      sortStr(word);\\n      normed.insert(word);\\n    }\\n    return normed.size();\\n  }\\n\\n  void sortStr(std::string& word) {\\n    using std::swap;\\n    for (int i = 0; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (!(word[i] < word[j])) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n    for (int i = 1; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (word[i] < word[j]) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(std::vector<std::string>& words) {\\n    std::set<std::string> normed;\\n    for (auto && word : words) {\\n      sortStr(word);\\n      normed.insert(word);\\n    }\\n    return normed.size();\\n  }\\n\\n  void sortStr(std::string& word) {\\n    using std::swap;\\n    for (int i = 0; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (!(word[i] < word[j])) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n    for (int i = 1; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (word[i] < word[j]) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266077,
                "title": "with-explanation-python-40-ms-faster-than-80-and-easy-solution-and-one-liner-as-well",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        result = set()\\n        for i in words:\\n            i = \\'\\'.join(sorted(i[::2]) + sorted(i[1::2]))\\n            result.add(i)\\n        return (len(result))\\n\\n```\\n\\'\\'\\'\\t\\t\\nThe list indices which we have used ([::2]) and ([1::2]) ,\\nthis will give us odd and even elements respectively . \\nAnd as we have declared result = set() when we add result.add(i), \\nthe same elements won\\'t repeat and we will get the len. \\n\\n you can also use set at the return statement, however you are comfortable with. \\n Thank you please upvote if it helped :) \\n \\'\\'\\'\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        return len(set(\\'\\'.join(sorted(s[0::2]))+\\'\\'.join(sorted(s[1::2])) for s in words))\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        result = set()\\n        for i in words:\\n            i = \\'\\'.join(sorted(i[::2]) + sorted(i[1::2]))\\n            result.add(i)\\n        return (len(result))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216068,
                "title": "share-two-java-solutions",
                "content": "```java\\n// \\u65B9\\u6CD5\\u4E8C\\uFF1A\\u5F97\\u5230\\u6BCF\\u4E2A\\u5B57\\u7B26\\u4E32\\u7684\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EDF\\u8BA1\\u60C5\\u51B5\\u4EE5\\u540E\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u7279\\u5F81\\u5B57\\u7B26\\u4E32\\u5B58\\u5165 set\\uFF0C\\u7528 set \\u53BB\\u91CD\\n// AC: Runtime: 13 ms, faster than 55.72% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 38.7 MB, less than 80.98% of Java online submissions for Groups of Special-Equivalent Strings.\\n// \\u7565\\n// T:O(words.length * len(words[i])), S:O(words.length * len(words[i]))\\n//\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n}\\n\\n// \\u65B9\\u6CD5\\u4E00\\uFF1A\\u76F4\\u63A5\\u904D\\u5386\\uFF0C\\u9010\\u4E2A\\u5224\\u65AD\\u4E24\\u4E24\\u5B57\\u7B26\\u4E32\\u662F\\u5426\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EC4\\u6210\\u76F8\\u540C\\u3002\\n// AC: Runtime: 672 ms, faster than 5.05% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 39.8 MB, less than 6.57% of Java online submissions for Groups of Special-Equivalent Strings.\\n// T:O(words.length ^ 2 * len(words[i])), S:O(words.length * len(words[i]))\\n// \\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        int size = words.length;\\n        List<HashSet<String>> record = new LinkedList<>();\\n        HashSet<Integer> used = new HashSet<>();\\n        for (int i = 0; i < size; i++) {\\n            if (used.contains(i)) {\\n                continue;\\n            }\\n            HashSet<String> temp = new HashSet<>();\\n            temp.add(words[i]);\\n            for (int j = i + 1; j < size; j++) {\\n                if (check(words[i], words[j])) {\\n                    temp.add(words[j]);\\n                    used.add(j);\\n                }\\n            }\\n            record.add(temp);\\n        }\\n\\n        return record.size();\\n    }\\n\\n    private boolean check(String s1, String s2) {\\n        HashMap<Character, Integer> even1 = new HashMap<>();\\n        HashMap<Character, Integer> even2 = new HashMap<>();\\n        HashMap<Character, Integer> odd1 = new HashMap<>();\\n        HashMap<Character, Integer> odd2 = new HashMap<>();\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (i % 2 == 0) {\\n                even1.merge(s1.charAt(i), 1, Integer::sum);\\n                even2.merge(s2.charAt(i), 1, Integer::sum);\\n            } else {\\n                odd1.merge(s1.charAt(i), 1, Integer::sum);\\n                odd2.merge(s2.charAt(i), 1, Integer::sum);\\n            }\\n        }\\n        for (char c: even1.keySet()) {\\n            if (even2.get(c) == null || even1.get(c).intValue() != even2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        for (char c: odd1.keySet()) {\\n            if (odd2.get(c) == null || odd1.get(c).intValue() != odd2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// \\u65B9\\u6CD5\\u4E8C\\uFF1A\\u5F97\\u5230\\u6BCF\\u4E2A\\u5B57\\u7B26\\u4E32\\u7684\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EDF\\u8BA1\\u60C5\\u51B5\\u4EE5\\u540E\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u7279\\u5F81\\u5B57\\u7B26\\u4E32\\u5B58\\u5165 set\\uFF0C\\u7528 set \\u53BB\\u91CD\\n// AC: Runtime: 13 ms, faster than 55.72% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 38.7 MB, less than 80.98% of Java online submissions for Groups of Special-Equivalent Strings.\\n// \\u7565\\n// T:O(words.length * len(words[i])), S:O(words.length * len(words[i]))\\n//\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n}\\n\\n// \\u65B9\\u6CD5\\u4E00\\uFF1A\\u76F4\\u63A5\\u904D\\u5386\\uFF0C\\u9010\\u4E2A\\u5224\\u65AD\\u4E24\\u4E24\\u5B57\\u7B26\\u4E32\\u662F\\u5426\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EC4\\u6210\\u76F8\\u540C\\u3002\\n// AC: Runtime: 672 ms, faster than 5.05% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 39.8 MB, less than 6.57% of Java online submissions for Groups of Special-Equivalent Strings.\\n// T:O(words.length ^ 2 * len(words[i])), S:O(words.length * len(words[i]))\\n// \\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        int size = words.length;\\n        List<HashSet<String>> record = new LinkedList<>();\\n        HashSet<Integer> used = new HashSet<>();\\n        for (int i = 0; i < size; i++) {\\n            if (used.contains(i)) {\\n                continue;\\n            }\\n            HashSet<String> temp = new HashSet<>();\\n            temp.add(words[i]);\\n            for (int j = i + 1; j < size; j++) {\\n                if (check(words[i], words[j])) {\\n                    temp.add(words[j]);\\n                    used.add(j);\\n                }\\n            }\\n            record.add(temp);\\n        }\\n\\n        return record.size();\\n    }\\n\\n    private boolean check(String s1, String s2) {\\n        HashMap<Character, Integer> even1 = new HashMap<>();\\n        HashMap<Character, Integer> even2 = new HashMap<>();\\n        HashMap<Character, Integer> odd1 = new HashMap<>();\\n        HashMap<Character, Integer> odd2 = new HashMap<>();\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (i % 2 == 0) {\\n                even1.merge(s1.charAt(i), 1, Integer::sum);\\n                even2.merge(s2.charAt(i), 1, Integer::sum);\\n            } else {\\n                odd1.merge(s1.charAt(i), 1, Integer::sum);\\n                odd2.merge(s2.charAt(i), 1, Integer::sum);\\n            }\\n        }\\n        for (char c: even1.keySet()) {\\n            if (even2.get(c) == null || even1.get(c).intValue() != even2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        for (char c: odd1.keySet()) {\\n            if (odd2.get(c) == null || odd1.get(c).intValue() != odd2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115008,
                "title": "java",
                "content": "class Solution {\\n    public static int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : A) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n\\n            for (int i=0; i<s.length(); i++) {\\n                if (i%2 == 0) {\\n                    even[s.charAt(i) - \\'a\\']++;\\n                }\\n                else {\\n                    odd[s.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n\\n            set.add(Arrays.toString(even) + \"|\" + Arrays.toString(odd));\\n        }\\n\\n        return set.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : A) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n\\n            for (int i=0; i<s.length(); i++) {\\n                if (i%2 == 0) {\\n                    even[s.charAt(i) - \\'a\\']++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1041031,
                "title": "c-solution",
                "content": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n\\tset<string> sWords;\\n\\tfor (string w : A) {\\n\\t\\tstring even = \"\", odd = \"\";\\n\\t\\tfor (int i = 0; i < w.size(); i += 2) {\\n\\t\\t\\teven += w[i];\\n\\t\\t\\todd += w[i + 1];\\n\\t\\t}\\n\\t\\tsort(begin(even), end(even));\\n\\t\\tsort(begin(odd), end(odd));\\n\\t\\tw = even + odd;\\n\\t\\tsWords.insert(w);\\n\\t}\\n\\treturn sWords.size();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n\\tset<string> sWords;\\n\\tfor (string w : A) {\\n\\t\\tstring even = \"\", odd = \"\";\\n\\t\\tfor (int i = 0; i < w.size(); i += 2) {\\n\\t\\t\\teven += w[i];\\n\\t\\t\\todd += w[i + 1];\\n\\t\\t}\\n\\t\\tsort(begin(even), end(even));\\n\\t\\tsort(begin(odd), end(odd));\\n\\t\\tw = even + odd;\\n\\t\\tsWords.insert(w);\\n\\t}\\n\\treturn sWords.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992322,
                "title": "c-100-fast-simple-solution",
                "content": "```\\nclass Solution{\\n    public:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        //00 sort the letter in strings in A:\\n        for(auto& word : A) {\\n            string s1, s2;\\n            for(int i = 0; i < word.size(); i += 2) {\\n                s1 += word[i];\\n                s2 += word[i + 1];\\n            }\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            word = s1 + s2;\\n        }\\n        //01 sort the strings in A:\\n        sort(A.begin(), A.end());\\n        //02 count the group of strings:\\n        int cnt = 1;\\n        string temp = A[0];\\n        for(int i = 1; i < A.size(); ++i) {\\n            if(temp != A[i]) {\\n                ++cnt;\\n                temp = A[i];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        //00 sort the letter in strings in A:\\n        for(auto& word : A) {\\n            string s1, s2;\\n            for(int i = 0; i < word.size(); i += 2) {\\n                s1 += word[i];\\n                s2 += word[i + 1];\\n            }\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            word = s1 + s2;\\n        }\\n        //01 sort the strings in A:\\n        sort(A.begin(), A.end());\\n        //02 count the group of strings:\\n        int cnt = 1;\\n        string temp = A[0];\\n        for(int i = 1; i < A.size(); ++i) {\\n            if(temp != A[i]) {\\n                ++cnt;\\n                temp = A[i];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971744,
                "title": "c-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> groups;\\n        \\n        for (auto& s: A) {\\n            string odd, even;\\n            for (int i = 0; i < s.size(); ++i)\\n                if (i%2)\\n                    odd.push_back(s[i]);\\n                else\\n                    even.push_back(s[i]);\\n            \\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            groups.insert(odd + even);\\n        }\\n        \\n        return groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> groups;\\n        \\n        for (auto& s: A) {\\n            string odd, even;\\n            for (int i = 0; i < s.size(); ++i)\\n                if (i%2)\\n                    odd.push_back(s[i]);\\n                else\\n                    even.push_back(s[i]);\\n            \\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            groups.insert(odd + even);\\n        }\\n        \\n        return groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949096,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(const vector<string>& A) {\\n        unordered_set<string> us;\\n        for(const auto& s:A) {\\n            string s1,s2;\\n            for(int i=0; i<s.size(); ++++i) s1+=s[i];\\n            sort(s1.begin(),s1.end());\\n            for(int i=1; i<s.size(); ++++i) s2+=s[i];\\n            sort(s2.begin(),s2.end());\\n            us.insert(s1+s2);\\n        }\\n        return us.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(const vector<string>& A) {\\n        unordered_set<string> us;\\n        for(const auto& s:A) {\\n            string s1,s2;\\n            for(int i=0; i<s.size(); ++++i) s1+=s[i];\\n            sort(s1.begin(),s1.end());\\n            for(int i=1; i<s.size(); ++++i) s2+=s[i];\\n            sort(s2.begin(),s2.end());\\n            us.insert(s1+s2);\\n        }\\n        return us.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948159,
                "title": "easy-clean-javascript",
                "content": "```\\nconst numSpecialEquivGroups = A => {\\n   \\n  const sortChars = str => {\\n    const odd = [...str].filter((_,i) => i%2);\\n    const even = [...str].filter((_,i) => !(i%2));\\n    return `${odd.sort().join(\\'\\')}${even.sort().join(\\'\\')}`\\n  };\\n  \\n  const set = new Set();\\n  A.forEach(str => set.add(sortChars(str)));\\n  return set.size;\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst numSpecialEquivGroups = A => {\\n   \\n  const sortChars = str => {\\n    const odd = [...str].filter((_,i) => i%2);\\n    const even = [...str].filter((_,i) => !(i%2));\\n    return `${odd.sort().join(\\'\\')}${even.sort().join(\\'\\')}`\\n  };\\n  \\n  const set = new Set();\\n  A.forEach(str => set.add(sortChars(str)));\\n  return set.size;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947018,
                "title": "java-1-line",
                "content": "```\\npublic int numSpecialEquivGroups(String[] array) {\\n\\treturn Arrays.stream(array).map(s -> IntStream.range(0, s.length()).boxed().collect(Collectors.toMap(i -> s.charAt(i) + 26 * (i & 1), i -> 1, Integer::sum)).entrySet().stream().sorted(Map.Entry.comparingByKey()).map(Object::toString).collect(Collectors.joining())).collect(Collectors.toSet()).size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] array) {\\n\\treturn Arrays.stream(array).map(s -> IntStream.range(0, s.length()).boxed().collect(Collectors.toMap(i -> s.charAt(i) + 26 * (i & 1), i -> 1, Integer::sum)).entrySet().stream().sorted(Map.Entry.comparingByKey()).map(Object::toString).collect(Collectors.joining())).collect(Collectors.toSet()).size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 915840,
                "title": "easy-python-3",
                "content": "\\tclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ls=[]\\n        for i in A:\\n            odd=i[0::2]\\n            even=i[1::2]\\n            ls.append(tuple(sorted(odd)+sorted(even)))\\n\\n        return len(set(ls))",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ls=[]\\n        for i in A:\\n            odd=i[0::2]\\n            even=i[1::2]\\n            ls.append(tuple(sorted(odd)+sorted(even)))\\n\\n        return len(set(ls))",
                "codeTag": "Java"
            },
            {
                "id": 904284,
                "title": "easiest-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        unordered_set<string>s1;\\n        for(int i=0;i<a.size();i++){\\n            string s=a[i];\\n            string odd=\"\",even=\"\";\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0)\\n                    even+=s[i];\\n                else\\n                    odd+=s[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            s1.insert(even+odd);\\n            \\n        }\\n        return s1.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        unordered_set<string>s1;\\n        for(int i=0;i<a.size();i++){\\n            string s=a[i];\\n            string odd=\"\",even=\"\";\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0)\\n                    even+=s[i];\\n                else\\n                    odd+=s[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            s1.insert(even+odd);\\n            \\n        }\\n        return s1.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868195,
                "title": "well-prime-numbers-helped",
                "content": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n        int len = A.length;\\n        int[] firstTwentySixPrimes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\\n        Set<String> result = new HashSet<>();\\n        for(int i=0;i<len;i++) {\\n            int strLen = A[i].length();\\n            int oddIndicesNum = 1;\\n            int evenIndicesNum = 1;\\n            for(int j=0;j<strLen;j++) {\\n                char ch = A[i].charAt(j);\\n                if (j%2 != 0) oddIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n                else evenIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n            }\\n            result.add(\"\"+oddIndicesNum+\"-\"+evenIndicesNum);\\n        }\\n        return result.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n        int len = A.length;\\n        int[] firstTwentySixPrimes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\\n        Set<String> result = new HashSet<>();\\n        for(int i=0;i<len;i++) {\\n            int strLen = A[i].length();\\n            int oddIndicesNum = 1;\\n            int evenIndicesNum = 1;\\n            for(int j=0;j<strLen;j++) {\\n                char ch = A[i].charAt(j);\\n                if (j%2 != 0) oddIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n                else evenIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n            }\\n            result.add(\"\"+oddIndicesNum+\"-\"+evenIndicesNum);\\n        }\\n        return result.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815059,
                "title": "java-o-26-n",
                "content": "```\\nclass Solution {\\n    private String evenOdd(String str){\\n        int n = str.length();\\n        int [] even = new int[26];\\n        int [] odd = new int[26];\\n        for(int i=0;i<n;i++){\\n            char c = str.charAt(i);\\n            if(i%2==0){\\n                even[c-\\'a\\']++;\\n            }else{\\n                odd[c-\\'a\\']++;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int x:even)sb.append(x);\\n        for(int x:odd)sb.append(x);\\n        return sb.toString();\\n    }\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<String>();\\n        for(String str : A){\\n            String key = evenOdd(str);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private String evenOdd(String str){\\n        int n = str.length();\\n        int [] even = new int[26];\\n        int [] odd = new int[26];\\n        for(int i=0;i<n;i++){\\n            char c = str.charAt(i);\\n            if(i%2==0){\\n                even[c-\\'a\\']++;\\n            }else{\\n                odd[c-\\'a\\']++;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int x:even)sb.append(x);\\n        for(int x:odd)sb.append(x);\\n        return sb.toString();\\n    }\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<String>();\\n        for(String str : A){\\n            String key = evenOdd(str);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675000,
                "title": "easy-understanding-c-using-set-and-count-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string>s;\\n        for(int i=0;i<A.size();i++)\\n            s.insert(createhash(A[i]));\\n        return s.size();\\n    }\\n    static string createhash(string a)\\n    {\\n        string res=\"\";\\n        vector<int>even(26,0);\\n        vector<int>odd(26,0);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(i%2==0)\\n            {\\n                even[a[i]-\\'a\\']++;\\n            }\\n            else\\n            {\\n                odd[a[i]-\\'a\\']++;\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            while(even[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                even[i]--;\\n            }\\n        }\\n        res+=\\'.\\';\\n         for(int i=0;i<26;i++)\\n        {\\n            while(odd[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                odd[i]--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string>s;\\n        for(int i=0;i<A.size();i++)\\n            s.insert(createhash(A[i]));\\n        return s.size();\\n    }\\n    static string createhash(string a)\\n    {\\n        string res=\"\";\\n        vector<int>even(26,0);\\n        vector<int>odd(26,0);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(i%2==0)\\n            {\\n                even[a[i]-\\'a\\']++;\\n            }\\n            else\\n            {\\n                odd[a[i]-\\'a\\']++;\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            while(even[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                even[i]--;\\n            }\\n        }\\n        res+=\\'.\\';\\n         for(int i=0;i<26;i++)\\n        {\\n            while(odd[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                odd[i]--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633433,
                "title": "python-soln",
                "content": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        #https://leetcode.com/problems/groups-of-special-equivalent-strings/discuss/358795/python3-detail-explanation-of-special-equivalent\\n        \\n        if len(A) == 1:\\n            return 1\\n        \\n        res = set()\\n        for string in A:\\n            even_indexed_string = string[0::2]\\n            sorted_even_indexed_string = \"\".join(sorted(even_indexed_string))\\n            \\n            odd_indexed_string = string[1::2]\\n            sorted_odd_indexed_string = \"\".join(sorted(odd_indexed_string))\\n            \\n            sorted_odd_even = sorted_even_indexed_string + sorted_odd_indexed_string\\n            res.add(sorted_odd_even)\\n\\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        #https://leetcode.com/problems/groups-of-special-equivalent-strings/discuss/358795/python3-detail-explanation-of-special-equivalent\\n        \\n        if len(A) == 1:\\n            return 1\\n        \\n        res = set()\\n        for string in A:\\n            even_indexed_string = string[0::2]\\n            sorted_even_indexed_string = \"\".join(sorted(even_indexed_string))\\n            \\n            odd_indexed_string = string[1::2]\\n            sorted_odd_indexed_string = \"\".join(sorted(odd_indexed_string))\\n            \\n            sorted_odd_even = sorted_even_indexed_string + sorted_odd_indexed_string\\n            res.add(sorted_odd_even)\\n\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633140,
                "title": "groups-of-special-equivalent-strings",
                "content": "```\\n    // Runtime: 6 ms, faster than 82.18% of Java online submissions for Groups of Special-Equivalent Strings.\\n    // Memory Usage: 39.3 MB, less than 7.69% of Java online submissions for Groups of Special-Equivalent Strings.\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> uniqueSet = new HashSet<>();\\n\\n        for (String str : A) {\\n            StringBuilder evenIndStr = new StringBuilder();\\n            StringBuilder oddIndStr = new StringBuilder();\\n\\n            for (int i = 0; i < str.length(); ++i) {\\n                if (i % 2 == 0) \\n                    evenIndStr.append(str.charAt(i));\\n                else \\n                    oddIndStr.append(str.charAt(i));\\n            }\\n            char[] evenStr = evenIndStr.toString().toCharArray();\\n            char[] oddStr = oddIndStr.toString().toCharArray();\\n            Arrays.sort(evenStr);\\n            Arrays.sort(oddStr);\\n\\n            uniqueSet.add(new String(evenStr) + new String(oddStr));\\n        }\\n\\n        return uniqueSet.size(); \\n    }",
                "solutionTags": [],
                "code": "```\\n    // Runtime: 6 ms, faster than 82.18% of Java online submissions for Groups of Special-Equivalent Strings.\\n    // Memory Usage: 39.3 MB, less than 7.69% of Java online submissions for Groups of Special-Equivalent Strings.\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> uniqueSet = new HashSet<>();\\n\\n        for (String str : A) {\\n            StringBuilder evenIndStr = new StringBuilder();\\n            StringBuilder oddIndStr = new StringBuilder();\\n\\n            for (int i = 0; i < str.length(); ++i) {\\n                if (i % 2 == 0) \\n                    evenIndStr.append(str.charAt(i));\\n                else \\n                    oddIndStr.append(str.charAt(i));\\n            }\\n            char[] evenStr = evenIndStr.toString().toCharArray();\\n            char[] oddStr = oddIndStr.toString().toCharArray();\\n            Arrays.sort(evenStr);\\n            Arrays.sort(oddStr);\\n\\n            uniqueSet.add(new String(evenStr) + new String(oddStr));\\n        }\\n\\n        return uniqueSet.size(); \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 568323,
                "title": "python3-solution-sort",
                "content": "class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n\\n        # sort string by index  \\n        def F(s):\\n            odd, even = \"\", \"\"\\n            for i in range(len(s)):\\n                if i % 2 == 0: even += s[i]\\n                else: odd += s[i]\\n            return \"\".join(sorted(even) + sorted(odd))\\n        \\n        return len(set([F(s) for s in A]))",
                "solutionTags": [],
                "code": "class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n\\n        # sort string by index  \\n        def F(s):\\n            odd, even = \"\", \"\"\\n            for i in range(len(s)):\\n                if i % 2 == 0: even += s[i]\\n                else: odd += s[i]\\n            return \"\".join(sorted(even) + sorted(odd))\\n        \\n        return len(set([F(s) for s in A]))",
                "codeTag": "Java"
            },
            {
                "id": 541107,
                "title": "swift-character-counting",
                "content": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ A: [String]) -> Int {\\n        var set:Set<String> = Set()\\n        for item in A{\\n            let chars = Array(item)\\n            var arr:[Character] = Array(repeating: \"0\", count: 52)\\n            for i in 0..<chars.count{\\n                if i % 2 == 0{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97] = Character(val.description)\\n                }else{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97 + 26]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97 + 26] = Character(val.description)                \\n                }\\n            }\\n            set.insert(String(arr))\\n        }\\n        return set.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ A: [String]) -> Int {\\n        var set:Set<String> = Set()\\n        for item in A{\\n            let chars = Array(item)\\n            var arr:[Character] = Array(repeating: \"0\", count: 52)\\n            for i in 0..<chars.count{\\n                if i % 2 == 0{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97] = Character(val.description)\\n                }else{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97 + 26]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97 + 26] = Character(val.description)                \\n                }\\n            }\\n            set.insert(String(arr))\\n        }\\n        return set.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486870,
                "title": "python3-simple-solution",
                "content": "If two strings are special-equivalent,\\nthey share the following tuple:\\n\\n(sorted string made of characters of the original strings of even indices,\\nsorted str. made of chars. of the orig. strs. of odd indices)\\n\\nTherefore, if we make such tuples from each string and put into a set,\\nthe length of the set is the answer. \\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ans = set()\\n        ln = len(A[0])\\n        ceven, codd = [], []\\n        \\n        for i in A:\\n            for j in range(ln):\\n                if j % 2 == 0:\\n                    ceven.append(i[j])\\n                \\n                else:\\n                    codd.append(i[j])\\n                    \\n            ceven.sort()\\n            codd.sort()\\n            ans.add((\\'\\'.join(ceven), \\'\\'.join(codd)))\\n            ceven.clear()\\n            codd.clear()\\n            \\n        return len(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ans = set()\\n        ln = len(A[0])\\n        ceven, codd = [], []\\n        \\n        for i in A:\\n            for j in range(ln):\\n                if j % 2 == 0:\\n                    ceven.append(i[j])\\n                \\n                else:\\n                    codd.append(i[j])\\n                    \\n            ceven.sort()\\n            codd.sort()\\n            ans.add((\\'\\'.join(ceven), \\'\\'.join(codd)))\\n            ceven.clear()\\n            codd.clear()\\n            \\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465857,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set=new HashSet();\\n        for(String s:A){\\n            int[] evenChars=new int[26];\\n            int[] oddChars=new int[26];\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0){\\n                    evenChars[s.charAt(i)-\\'a\\']++;\\n                }\\n                else{\\n                    oddChars[s.charAt(i)-\\'a\\']++;\\n                }\\n            }\\n            set.add(Arrays.toString(evenChars)+Arrays.toString(oddChars));\\n        }\\n        return set.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set=new HashSet();\\n        for(String s:A){\\n            int[] evenChars=new int[26];\\n            int[] oddChars=new int[26];\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0){\\n                    evenChars[s.charAt(i)-\\'a\\']++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 458813,
                "title": "c-solution-with-linq",
                "content": "```\\npublic int NumSpecialEquivGroups(string[] A) {\\n\\treturn A.Select(Order).Distinct().Count();\\n\\n\\tstring Order(string s) {\\n\\t\\tvar chars = s.Select((c, i) => (i, c)).ToArray();\\n\\t\\tvar evens = chars.Where(t => t.i % 2 == 0).Select(t => t.c).OrderBy(c => c);\\n\\t\\tvar odds = chars.Where(t => t.i % 2 == 1).Select(t => t.c).OrderBy(c => c);\\n\\n\\t\\treturn new string(evens.Concat(odds).ToArray());\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumSpecialEquivGroups(string[] A) {\\n\\treturn A.Select(Order).Distinct().Count();\\n\\n\\tstring Order(string s) {\\n\\t\\tvar chars = s.Select((c, i) => (i, c)).ToArray();\\n\\t\\tvar evens = chars.Where(t => t.i % 2 == 0).Select(t => t.c).OrderBy(c => c);\\n\\t\\tvar odds = chars.Where(t => t.i % 2 == 1).Select(t => t.c).OrderBy(c => c);\\n\\n\\t\\treturn new string(evens.Concat(odds).ToArray());\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433339,
                "title": "count-the-characters-at-even-and-odd-positions",
                "content": "```csharp\\npublic int NumSpecialEquivGroups(string[] A)\\n{\\n\\tHashSet<string> groupCount = new HashSet<string>();\\n\\n\\tforeach (var a in A)\\n\\t{\\n\\t\\tint[] frequency = new int[26 * 2];\\n\\t\\tfor (int i = 0; i < a.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[26 + a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring key = string.Join(\",\", frequency);\\n\\t\\tgroupCount.Add(key);\\n\\t}\\n\\n\\treturn groupCount.Count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumSpecialEquivGroups(string[] A)\\n{\\n\\tHashSet<string> groupCount = new HashSet<string>();\\n\\n\\tforeach (var a in A)\\n\\t{\\n\\t\\tint[] frequency = new int[26 * 2];\\n\\t\\tfor (int i = 0; i < a.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[26 + a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring key = string.Join(\",\", frequency);\\n\\t\\tgroupCount.Add(key);\\n\\t}\\n\\n\\treturn groupCount.Count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410934,
                "title": "brute-force-and-optimized-solution-in-cpp",
                "content": "Here we have to sort substrings so nlogn!\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        map<string,vector<string>>m;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string odd=\"\";\\n            string even=\"\";\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    even=even+a[i][j];\\n                else\\n                    odd=odd+a[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            string res=even+odd;\\n            m[res].push_back(a[i]);\\n        }\\n        return m.size();\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        set<vector<int>>s;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>count(52,0);\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    count[a[i][j]-\\'a\\']++;\\n                else\\n                    count[a[i][j]-\\'a\\'+26]++;\\n            }\\n          s.insert(count);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        map<string,vector<string>>m;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string odd=\"\";\\n            string even=\"\";\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    even=even+a[i][j];\\n                else\\n                    odd=odd+a[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            string res=even+odd;\\n            m[res].push_back(a[i]);\\n        }\\n        return m.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        set<vector<int>>s;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>count(52,0);\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    count[a[i][j]-\\'a\\']++;\\n                else\\n                    count[a[i][j]-\\'a\\'+26]++;\\n            }\\n          s.insert(count);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353519,
                "title": "go-golang-clean-solution",
                "content": "Runtime: 4 ms, faster than 71.43% of Go online submissions for Groups of Special-Equivalent Strings.\\nMemory Usage: 4.3 MB, less than 100.00% of Go online submissions for Groups of Special-Equivalent Strings.\\n\\n```go\\nfunc numSpecialEquivGroups(A []string) int {\\n\\n\\ttmp := make(map[string]int)\\n    \\n\\tfor _, v := range A {\\n\\n\\t\\todd, even := []rune{}, []rune{}\\n\\n\\t\\tfor I, V := range v {\\n\\n\\t\\t\\tif I%2 == 0 {\\n\\t\\t\\t\\teven = append(even, V)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\todd = append(odd, V)\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tsort.Slice(even, func(i int, j int) bool { return even[i] < even[j] })\\n\\t\\tsort.Slice(odd, func(i int, j int) bool { return odd[i] < odd[j] })\\n\\t\\ttemp := append(even, odd...)\\n\\t\\ttmp[string(temp)]++\\n\\t}\\n\\n\\treturn len(tmp)\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc numSpecialEquivGroups(A []string) int {\\n\\n\\ttmp := make(map[string]int)\\n    \\n\\tfor _, v := range A {\\n\\n\\t\\todd, even := []rune{}, []rune{}\\n\\n\\t\\tfor I, V := range v {\\n\\n\\t\\t\\tif I%2 == 0 {\\n\\t\\t\\t\\teven = append(even, V)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\todd = append(odd, V)\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tsort.Slice(even, func(i int, j int) bool { return even[i] < even[j] })\\n\\t\\tsort.Slice(odd, func(i int, j int) bool { return odd[i] < odd[j] })\\n\\t\\ttemp := append(even, odd...)\\n\\t\\ttmp[string(temp)]++\\n\\t}\\n\\n\\treturn len(tmp)\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346580,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])) for w in A))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])) for w in A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336981,
                "title": "js-simple-solution-with-explanation",
                "content": "We can calculate the *signature* of each word in the word array, and see how many distinct *word signature* there are, which would be the result. The *signature* is defined as:\\n* extract all even-indexed chars and sort them\\n* extract all odd-indexed chars and sort them\\n* combine the above two\\n\\nTake the word \"abccba\" as example:\\n```\\noriginal word: abccba\\neven-indexed chars: a c b   --sort--> a b c --combine--> abc\\nodd-indexed chars: b c a --sort--> a b c --combine--> abc\\ncombine: abcabc\\n```\\n\"abcabc\" would be the signature for \"abccba\".\\n```\\n\\nvar numSpecialEquivGroups = function(A) {\\n    let s = new Set()\\n    for (let w of A) {\\n        let tmp = helper(w)\\n        s.add(tmp)\\n    }\\n    return s.size\\n};\\n\\nconst helper = function(s) {\\n    if (s.length <= 1)\\n        return s\\n    let fst = \\'\\', sec = \\'\\'\\n    for (let i = 0; i < s.length; i += 2)\\n        fst += s[i]\\n    fst = fst.split(\\'\\').sort().join(\\'\\')\\n    for (let i = 1; i < s.length; i += 2)\\n        sec += s[i]\\n    sec = sec.split(\\'\\').sort().join(\\'\\')\\n    return fst + sec\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\noriginal word: abccba\\neven-indexed chars: a c b   --sort--> a b c --combine--> abc\\nodd-indexed chars: b c a --sort--> a b c --combine--> abc\\ncombine: abcabc\\n```\n```\\n\\nvar numSpecialEquivGroups = function(A) {\\n    let s = new Set()\\n    for (let w of A) {\\n        let tmp = helper(w)\\n        s.add(tmp)\\n    }\\n    return s.size\\n};\\n\\nconst helper = function(s) {\\n    if (s.length <= 1)\\n        return s\\n    let fst = \\'\\', sec = \\'\\'\\n    for (let i = 0; i < s.length; i += 2)\\n        fst += s[i]\\n    fst = fst.split(\\'\\').sort().join(\\'\\')\\n    for (let i = 1; i < s.length; i += 2)\\n        sec += s[i]\\n    sec = sec.split(\\'\\').sort().join(\\'\\')\\n    return fst + sec\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311765,
                "title": "python-sol-for-starters-extremely-easy",
                "content": "```python\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        length = len(A)\\n        res = set()\\n        for item in A:\\n            odds = item[::2]\\n            evens = item[1::2]\\n            res.add((str(sorted(odds)),str(sorted(evens))))\\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        length = len(A)\\n        res = set()\\n        for item in A:\\n            odds = item[::2]\\n            evens = item[1::2]\\n            res.add((str(sorted(odds)),str(sorted(evens))))\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300132,
                "title": "c-beat-99-with-explanation",
                "content": "\\tafter realizing the question, all we have to do is the check if odd/even position pattern is the same between two string.\\n\\tfor instance : \"abcdefggyy\"\\n\\todd pattern : \"acegy\"\\n\\teven pattern : \"bdfgy\"\\n\\twe can simply check those pattern after sorting.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        map<std::pair<string,string>,int> mymap; // key:pattern pair\\n        for(int i = 0 ; i < A.size() ; i++){\\n            string s[2];\\n            for(int j = 0 ; j < A[i].length() ; j++)\\n                s[j%2]+= A[i][j];\\n            sort(s[0].begin(),s[0].end()),sort(s[1].begin(),s[1].end());\\n            mymap[{s[0],s[1]}]++;\\n        }\\n        return mymap.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        map<std::pair<string,string>,int> mymap; // key:pattern pair\\n        for(int i = 0 ; i < A.size() ; i++){\\n            string s[2];\\n            for(int j = 0 ; j < A[i].length() ; j++)\\n                s[j%2]+= A[i][j];\\n            sort(s[0].begin(),s[0].end()),sort(s[1].begin(),s[1].end());\\n            mymap[{s[0],s[1]}]++;\\n        }\\n        return mymap.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285486,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([(\\'\\'.join(sorted(i[::2])),\\'\\'.join(sorted(i[1::2]))) for i in A]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([(\\'\\'.join(sorted(i[::2])),\\'\\'.join(sorted(i[1::2]))) for i in A]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283634,
                "title": "why-the-answer-of-abcd-cdab-adcb-cbad-last-test-case-35-is-2-not-1-in-example-4",
                "content": "Below is my code. It passed the example 4 when testing but failed it after I submitted (the last test case). \\nI\\'ve checked many times and, if I am correct, found the 35-th test case should be the same as example 4. \\nIs there anyone who knows why it has two different answers? Thanks.\\n```\\n    def numSpecialEquivGroups(self, A):\\n        table = set()\\n        for string in A:\\n            set0 = frozenset(string[::2]) # mod 2 = 0\\n            set1 = frozenset(string[1::2]) # mod 2 = 1\\n            table.add((set0, set1))\\n        return len(table)\\n```\\n![image](https://assets.leetcode.com/users/victorchen1028/image_1556525968.png)\\n",
                "solutionTags": [],
                "code": "```\\n    def numSpecialEquivGroups(self, A):\\n        table = set()\\n        for string in A:\\n            set0 = frozenset(string[::2]) # mod 2 = 0\\n            set1 = frozenset(string[1::2]) # mod 2 = 1\\n            table.add((set0, set1))\\n        return len(table)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 261975,
                "title": "two-lines-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        # re-order string based on special equvilant\\n        lists = [ \\'\\'.join([\\'\\'.join(sorted(a[0::2])),\\'\\'.join(sorted(a[1::2]))]) for a in A ]\\n        return len(Counter(lists).keys())\\n```\\n\\nexplanation:\\n`a[0::2]` will give all the letters on the even number positions.\\n`a[1::2]` will give all the letters on the odd number positions.\\n`sorted` them to fix an order since we could achieve it with certain number of moves.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        # re-order string based on special equvilant\\n        lists = [ \\'\\'.join([\\'\\'.join(sorted(a[0::2])),\\'\\'.join(sorted(a[1::2]))]) for a in A ]\\n        return len(Counter(lists).keys())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254323,
                "title": "javascript-easy-solution",
                "content": "``` JavaScript\\nvar numSpecialEquivGroups = function(A) {\\n    const map = A.reduce((res, str) => {\\n    \\tconst key = transString(str);\\n    \\tif (key in res) {\\n    \\t\\tres[key] += 1;\\n    \\t} else {\\n    \\t\\tres[key] = 1;\\n    \\t}\\n    \\treturn res;\\n    }, {});\\n    return Object.keys(map).length;\\n};\\n\\nfunction transString(str) {\\n\\tconst odd = [], even = [];\\n\\tfor (let i = 0; i < str.length; i++) {\\n\\t\\tif (i % 2 === 0) {\\n\\t\\t\\teven.push(str[i]);\\n\\t\\t} else {\\n\\t\\t\\todd.push(str[i]);\\n\\t\\t}\\n\\t}\\n\\treturn odd.sort().join(\\'\\') + \\';\\' + even.sort().join(\\'\\');\\n}\\n```",
                "solutionTags": [],
                "code": "``` JavaScript\\nvar numSpecialEquivGroups = function(A) {\\n    const map = A.reduce((res, str) => {\\n    \\tconst key = transString(str);\\n    \\tif (key in res) {\\n    \\t\\tres[key] += 1;\\n    \\t} else {\\n    \\t\\tres[key] = 1;\\n    \\t}\\n    \\treturn res;\\n    }, {});\\n    return Object.keys(map).length;\\n};\\n\\nfunction transString(str) {\\n\\tconst odd = [], even = [];\\n\\tfor (let i = 0; i < str.length; i++) {\\n\\t\\tif (i % 2 === 0) {\\n\\t\\t\\teven.push(str[i]);\\n\\t\\t} else {\\n\\t\\t\\todd.push(str[i]);\\n\\t\\t}\\n\\t}\\n\\treturn odd.sort().join(\\'\\') + \\';\\' + even.sort().join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 191573,
                "title": "java-solution-using-set",
                "content": "The feature of Set is that there will be no duplicate elements, so as long as the size of the Set is counted, you can know how many different ones are. Plus, sort even and odd positions separately and save them into set.\\n```\\npublic int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for(String a : A){\\n            int n = a.length();\\n            char[] odd = new char[(n + 1)/2];\\n            char[] even = new char[(n + 1)/2];\\n            int to = 0, te = 0;\\n            for(int i = 0; i < a.length(); i++){\\n                if(i % 2 == 0) even[te++] = a.charAt(i);\\n                else odd[to++] = a.charAt(i);\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            set.add(String.valueOf(odd)+String.valueOf(even));\\n        }\\n        return set.size();\\n    }```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for(String a : A){\\n            int n = a.length();\\n            char[] odd = new char[(n + 1)/2];\\n            char[] even = new char[(n + 1)/2];\\n            int to = 0, te = 0;\\n            for(int i = 0; i < a.length(); i++){\\n                if(i % 2 == 0) even[te++] = a.charAt(i);\\n                else odd[to++] = a.charAt(i);\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            set.add(String.valueOf(odd)+String.valueOf(even));\\n        }\\n        return set.size();\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 187031,
                "title": "c-solution-based-on-sequential-multiplication-of-ascii-codes",
                "content": "the solution is based on multiplication of characters\\' ASCII codes, which don\\'t intersect in sense of  the following property: \\n```\\nascii(x) * ascii(y) != ascii(p) * ascii(q), where pairs of symbols (x, y) and (p, q) are different\\n```\\n\\ngiven the property, we can multiply over all the ascii codes of even- and odd-indexed (independently) characters in the string and then store them as unique pairs of result products in an _ordered_ set. Then, we count unique pairs\\nThe solution goes with O(n) time complexity and O(n) space complexity\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        std::set<std::pair<uint64_t, uint64_t>> s;\\n        for (auto &str : A) {\\n            std::pair<uint64_t, uint64_t> res{1, 1};\\n            for (int i = 0; i < str.size(); ++i) {\\n                if (0 == i % 2) res.first *= str[i];\\n                else res.second *= str[i];\\n            }\\n            s.insert(res);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nascii(x) * ascii(y) != ascii(p) * ascii(q), where pairs of symbols (x, y) and (p, q) are different\\n```\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        std::set<std::pair<uint64_t, uint64_t>> s;\\n        for (auto &str : A) {\\n            std::pair<uint64_t, uint64_t> res{1, 1};\\n            for (int i = 0; i < str.size(); ++i) {\\n                if (0 == i % 2) res.first *= str[i];\\n                else res.second *= str[i];\\n            }\\n            s.insert(res);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178368,
                "title": "python-very-simple-easy-to-read-using-dictionary",
                "content": "This implementation can also return no.of elements in each group by changing the `return` statement\n```\nclass Solution:\n    def numSpecialEquivGroups(self, A):\n        d = dict()\n        for i in A:\n            if len(i) >= 2:\n                key = (tuple(sorted(i[::2])), tuple(sorted(i[1::2])))\n                d[key] = d.get(key,0) + 1\n            else:\n                d[i] = d.get(i,0) + 1     \n        return len(d) \n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def numSpecialEquivGroups(self, A):\n        d = dict()\n        for i in A:\n            if len(i) >= 2:\n                key = (tuple(sorted(i[::2])), tuple(sorted(i[1::2])))\n                d[key] = d.get(key,0) + 1\n            else:\n                d[i] = d.get(i,0) + 1     \n        return len(d) \n```",
                "codeTag": "Java"
            },
            {
                "id": 169632,
                "title": "c-beat-100-use-both-unordered-map-and-unordered-set",
                "content": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        int res = 0;\\n        unordered_map<string,unordered_set<string>> table;// odd | evens\\n        for(int i = 0; i < A.size(); i++){\\n            int j = 0;\\n            string odds = \"\";\\n            string evens = \"\";\\n            while(j < A[i].size()){\\n                if(j%2 == 0)\\n                    evens = evens+A[i][j];\\n                if(j%2 == 1)\\n                    odds = odds+A[i][j];\\n                j++;\\n            }\\n            sort(evens.begin(),evens.end());\\n            sort(odds.begin(),odds.end());\\n            if(table[odds].find(evens) == table[odds].end()){\\n                res++;\\n                table[odds].insert(evens);\\n            }    \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        int res = 0;\\n        unordered_map<string,unordered_set<string>> table;// odd | evens\\n        for(int i = 0; i < A.size(); i++){\\n            int j = 0;\\n            string odds = \"\";\\n            string evens = \"\";\\n            while(j < A[i].size()){\\n                if(j%2 == 0)\\n                    evens = evens+A[i][j];\\n                if(j%2 == 1)\\n                    odds = odds+A[i][j];\\n                j++;\\n            }\\n            sort(evens.begin(),evens.end());\\n            sort(odds.begin(),odds.end());\\n            if(table[odds].find(evens) == table[odds].end()){\\n                res++;\\n                table[odds].insert(evens);\\n            }    \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165769,
                "title": "concise-java-solution-using-char",
                "content": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> groups = new HashSet<>();\\n        for (String str : A) {\\n            char[] chars = str.toCharArray();\\n            char[] odd = new char[20];\\n            char[] even = new char[20];\\n            for (int i = 0; i < chars.length; i++) {\\n                if (i % 2 == 0) {\\n                    odd[i] = chars[i];\\n                } else {\\n                    even[i] = chars[i];\\n                }\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            String unique = String.valueOf(odd) + String.valueOf(even);\\n            groups.add(unique);\\n        }\\n        return groups.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> groups = new HashSet<>();\\n        for (String str : A) {\\n            char[] chars = str.toCharArray();\\n            char[] odd = new char[20];\\n            char[] even = new char[20];\\n            for (int i = 0; i < chars.length; i++) {\\n                if (i % 2 == 0) {\\n                    odd[i] = chars[i];\\n                } else {\\n                    even[i] = chars[i];\\n                }\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            String unique = String.valueOf(odd) + String.valueOf(even);\\n            groups.add(unique);\\n        }\\n        return groups.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164241,
                "title": "javascript-not-the-fastest-but-i-like-it",
                "content": "```\\nvar numSpecialEquivGroups = function(A) {\\n    return A.reduce((prev, curr) => {\\n        let left = \"\"\\n        let right = \"\"\\n        for(let i=0; i<curr.length; i++){\\n            i%2===0 ? left += curr[i] : right += curr[i] \\n        }\\n        left = [...left].sort().join(\"\")\\n        right = [...right].sort().join(\"\")\\n        for(let i=0; i<prev.length; i++){\\n            if(prev[i][0] === left && prev[i][1] === right){\\n                return prev\\n            }\\n        }\\n        prev.push([left,right])\\n        return prev\\n    }, []).length\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numSpecialEquivGroups = function(A) {\\n    return A.reduce((prev, curr) => {\\n        let left = \"\"\\n        let right = \"\"\\n        for(let i=0; i<curr.length; i++){\\n            i%2===0 ? left += curr[i] : right += curr[i] \\n        }\\n        left = [...left].sort().join(\"\")\\n        right = [...right].sort().join(\"\")\\n        for(let i=0; i<prev.length; i++){\\n            if(prev[i][0] === left && prev[i][1] === right){\\n                return prev\\n            }\\n        }\\n        prev.push([left,right])\\n        return prev\\n    }, []).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163535,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution(object):\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\t\"\"\"\\n\\t\\t:type A: List[str]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tB = set()\\n\\t\\tfor string in A:\\n\\t\\t\\tC = list(string)\\n\\t\\t\\ta, b = C[::2], C[1::2]\\n\\t\\t\\tB.add((\\'\\'.join(sorted(a)), \\'\\'.join(sorted(b))))\\n\\t\\t\\t\\n\\t\\treturn len(B)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\t\"\"\"\\n\\t\\t:type A: List[str]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tB = set()\\n\\t\\tfor string in A:\\n\\t\\t\\tC = list(string)\\n\\t\\t\\ta, b = C[::2], C[1::2]\\n\\t\\t\\tB.add((\\'\\'.join(sorted(a)), \\'\\'.join(sorted(b))))\\n\\t\\t\\t\\n\\t\\treturn len(B)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163442,
                "title": "java-sorting-solution",
                "content": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            String key = sort(s);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n    private String sort(String s) {\\n        List<Character> l1 = new ArrayList<>();\\n        List<Character> l2 = new ArrayList<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i % 2 == 0) {\\n                l1.add(s.charAt(i));\\n            } else {\\n                l2.add(s.charAt(i));\\n            }\\n        }\\n        Collections.sort(l1);\\n        Collections.sort(l2);\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : l1) {\\n            sb.append(c);\\n        }\\n        for (char c : l2) {\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            String key = sort(s);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n    private String sort(String s) {\\n        List<Character> l1 = new ArrayList<>();\\n        List<Character> l2 = new ArrayList<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i % 2 == 0) {\\n                l1.add(s.charAt(i));\\n            } else {\\n                l2.add(s.charAt(i));\\n            }\\n        }\\n        Collections.sort(l1);\\n        Collections.sort(l2);\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : l1) {\\n            sb.append(c);\\n        }\\n        for (char c : l2) {\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102505,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n\\n        for i,word in enumerate(words):\\n            even, odd = \"\", \"\"\\n            for j in range(len(word)):\\n                if j % 2 == 0:\\n                    even += word[j]\\n                else:\\n                    odd += word[j]\\n            \\n            even = list(even)\\n            even.sort()\\n            even = \"\".join(even)\\n            odd = list(odd)\\n            odd.sort()\\n            odd = \"\".join(odd)\\n\\n            if even+odd in d:\\n                d[even+odd] += 1\\n            else:\\n                d[even+odd] = 1\\n\\n        return len(d)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n\\n        for i,word in enumerate(words):\\n            even, odd = \"\", \"\"\\n            for j in range(len(word)):\\n                if j % 2 == 0:\\n                    even += word[j]\\n                else:\\n                    odd += word[j]\\n            \\n            even = list(even)\\n            even.sort()\\n            even = \"\".join(even)\\n            odd = list(odd)\\n            odd.sort()\\n            odd = \"\".join(odd)\\n\\n            if even+odd in d:\\n                d[even+odd] += 1\\n            else:\\n                d[even+odd] = 1\\n\\n        return len(d)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081089,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023782,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n       let mut hashset:HashSet::<String> = HashSet::new(); \\n\\n        for word in words{\\n            let mut even:Vec<char> = Vec::new();\\n            let mut odd:Vec<char> = Vec::new();\\n            for (idx,w) in word.chars().enumerate(){\\n                if idx % 2 == 0{\\n                    even.push(w);\\n                }else{\\n                    odd.push(w);\\n                }\\n            }\\n            even.sort();\\n            odd.sort();\\n            let my_str  = format!(\"{}{}\",\\n            even.iter().collect::<String>(),\\n            odd.iter().collect::<String>());\\n            hashset.insert(my_str);\\n        }\\n        let out = hashset.len() as i32;\\n        out\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n       let mut hashset:HashSet::<String> = HashSet::new(); \\n\\n        for word in words{\\n            let mut even:Vec<char> = Vec::new();\\n            let mut odd:Vec<char> = Vec::new();\\n            for (idx,w) in word.chars().enumerate(){\\n                if idx % 2 == 0{\\n                    even.push(w);\\n                }else{\\n                    odd.push(w);\\n                }\\n            }\\n            even.sort();\\n            odd.sort();\\n            let my_str  = format!(\"{}{}\",\\n            even.iter().collect::<String>(),\\n            odd.iter().collect::<String>());\\n            hashset.insert(my_str);\\n        }\\n        let out = hashset.len() as i32;\\n        out\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009402,
                "title": "naive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>&w){\\n        unordered_set<string>st;\\n        vector<int>v;\\n        for(int i=0; i<w.size(); i++){\\n            if(st.find(w[i])!=st.end()){\\n                continue;\\n            }\\n            else{\\n                st.insert(w[i]);\\n                string s1,s2;\\n                for(int j=0; j<w[i].size(); j+=2){\\n                    s1+=w[i][j];\\n                }\\n                for(int j=1; j<w[i].size(); j+=2){\\n                    s2+=w[i][j];\\n                }\\n                sort(s1.begin(),s1.end());\\n                sort(s2.begin(),s2.end());\\n                int c=0;\\n                for(int j=i+1; j<w.size(); j++){\\n                    string t1 , t2;\\n                    for(int k=0; k<w[j].size(); k+=2){\\n                        t1+=w[j][k];\\n                    }\\n                    for(int k=1; k<w[j].size(); k+=2){\\n                        t2+=w[j][k];\\n                    }\\n                    sort(t1.begin(),t1.end());\\n                    sort(t2.begin(),t2.end());\\n                    if(t1==s1 && t2==s2){\\n                        c++;\\n                        st.insert(w[j]);\\n                    }\\n                }\\n                v.push_back(c);\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>&w){\\n        unordered_set<string>st;\\n        vector<int>v;\\n        for(int i=0; i<w.size(); i++){\\n            if(st.find(w[i])!=st.end()){\\n                continue;\\n            }\\n            else{\\n                st.insert(w[i]);\\n                string s1,s2;\\n                for(int j=0; j<w[i].size(); j+=2){\\n                    s1+=w[i][j];\\n                }\\n                for(int j=1; j<w[i].size(); j+=2){\\n                    s2+=w[i][j];\\n                }\\n                sort(s1.begin(),s1.end());\\n                sort(s2.begin(),s2.end());\\n                int c=0;\\n                for(int j=i+1; j<w.size(); j++){\\n                    string t1 , t2;\\n                    for(int k=0; k<w[j].size(); k+=2){\\n                        t1+=w[j][k];\\n                    }\\n                    for(int k=1; k<w[j].size(); k+=2){\\n                        t2+=w[j][k];\\n                    }\\n                    sort(t1.begin(),t1.end());\\n                    sort(t2.begin(),t2.end());\\n                    if(t1==s1 && t2==s2){\\n                        c++;\\n                        st.insert(w[j]);\\n                    }\\n                }\\n                v.push_back(c);\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006307,
                "title": "python-solution-using-hashmap-and-helper-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        #an array \\'words\\' of strings of the same length\\n        #in one move i can swap any two even indexed chars or any two odd indexed\\n        #chars in word in words\\n        #two words in array words are special equivalent if after any number of moves\\n        #they can be the same\\n        #return the number of groups of special equivalent strings from words\\n        #to group them i think i have to use a hashmap\\n        #i should also define a helper function that can help me compare two strings\\n        #based on whether if they are special equivalent\\n\\n\\n        def specialEquivalence(s1):\\n            odd_1 = \"\"\\n            even_1 = \"\"\\n            for i in range(len(s1)):\\n                if i % 2 == 0:\\n                    even_1 += s1[i]\\n                else:\\n                    odd_1 += s1[i]\\n            return \"\".join((sorted(even_1) + sorted(odd_1)))\\n        \\n        lookup = {}\\n\\n        for word in words:\\n            lookup[specialEquivalence(word)] = 1 + lookup.get(specialEquivalence(word), 0)\\n        \\n        return len(lookup.keys())\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        #an array \\'words\\' of strings of the same length\\n        #in one move i can swap any two even indexed chars or any two odd indexed\\n        #chars in word in words\\n        #two words in array words are special equivalent if after any number of moves\\n        #they can be the same\\n        #return the number of groups of special equivalent strings from words\\n        #to group them i think i have to use a hashmap\\n        #i should also define a helper function that can help me compare two strings\\n        #based on whether if they are special equivalent\\n\\n\\n        def specialEquivalence(s1):\\n            odd_1 = \"\"\\n            even_1 = \"\"\\n            for i in range(len(s1)):\\n                if i % 2 == 0:\\n                    even_1 += s1[i]\\n                else:\\n                    odd_1 += s1[i]\\n            return \"\".join((sorted(even_1) + sorted(odd_1)))\\n        \\n        lookup = {}\\n\\n        for word in words:\\n            lookup[specialEquivalence(word)] = 1 + lookup.get(specialEquivalence(word), 0)\\n        \\n        return len(lookup.keys())\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998269,
                "title": "easy-c-solution-using-set-5-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) \\n    {\\n        set<string>S ;\\n        for(auto& it : words)\\n        {\\n            string even , odd ;\\n            for(int i = 0 ; i < it.size() ; i++)\\n            {\\n                if(i%2 == 0)\\n                    even += it[i];\\n                else\\n                    odd+= it[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n\\n            even += odd ;\\n            if(S.find(even) == S.end())\\n                S.insert(even);\\n        }\\n        return S.size();    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) \\n    {\\n        set<string>S ;\\n        for(auto& it : words)\\n        {\\n            string even , odd ;\\n            for(int i = 0 ; i < it.size() ; i++)\\n            {\\n                if(i%2 == 0)\\n                    even += it[i];\\n                else\\n                    odd+= it[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n\\n            even += odd ;\\n            if(S.find(even) == S.end())\\n                S.insert(even);\\n        }\\n        return S.size();    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985024,
                "title": "python3-convert-characters-at-odd-and-even-indices-into-a-hash-count-unique-hashes",
                "content": "# Code\\n```\\nclass Solution:\\n    # Approach: Form a dictionary (h1, h2) -> [s1,s2...sn]\\n    # where h1 and h2 are two hashes -  sorted characters\\n    # at the odd and even indices respectively in the word.\\n    # So (h1,h2) will be the same for all special-equivalent strings.\\n    # Then count the number of unique hashes.\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n\\n        def build_hash(s:str) -> Tuple[str, str]:\\n            odd_chars = []\\n            even_chars = []\\n            for idx, c in enumerate(s):\\n                if idx % 2:\\n                    odd_chars.append(c)\\n                else:\\n                    even_chars.append(c)\\n            odd_chars.sort()\\n            even_chars.sort()\\n            return (\\'\\'.join(odd_chars), \\'\\'.join(even_chars))\\n\\n        word_hash_set = set()\\n        for w in words:\\n            word_hash_set.add(build_hash(w))\\n        return len(word_hash_set)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # Approach: Form a dictionary (h1, h2) -> [s1,s2...sn]\\n    # where h1 and h2 are two hashes -  sorted characters\\n    # at the odd and even indices respectively in the word.\\n    # So (h1,h2) will be the same for all special-equivalent strings.\\n    # Then count the number of unique hashes.\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n\\n        def build_hash(s:str) -> Tuple[str, str]:\\n            odd_chars = []\\n            even_chars = []\\n            for idx, c in enumerate(s):\\n                if idx % 2:\\n                    odd_chars.append(c)\\n                else:\\n                    even_chars.append(c)\\n            odd_chars.sort()\\n            even_chars.sort()\\n            return (\\'\\'.join(odd_chars), \\'\\'.join(even_chars))\\n\\n        word_hash_set = set()\\n        for w in words:\\n            word_hash_set.add(build_hash(w))\\n        return len(word_hash_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980595,
                "title": "c-simple-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966726,
                "title": "best-optimal-solution-linear",
                "content": "# Intuition\\nTricky Observation, if two strings have same characters then we can equate them using some swaps. No matter how many swaps we are going to use, but we can always equate them. Hence we are going to check characters present in odd and even places of two strings.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> mp ;\\n        for(auto x : words){\\n            string odd = \"\" , even = \"\" ;\\n            for(int i = 0; i <x.size() ; i++){\\n                if(i%2 == 0) even += x[i] ;\\n                else odd += x[i] ;\\n            }\\n            sort(odd.begin() , odd.end()) ;\\n            sort(even.begin(), even.end()) ;\\n            if(mp.find(odd+even) == mp.end()) mp.insert(odd+even) ;\\n        }\\n        return mp.size() ;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> mp ;\\n        for(auto x : words){\\n            string odd = \"\" , even = \"\" ;\\n            for(int i = 0; i <x.size() ; i++){\\n                if(i%2 == 0) even += x[i] ;\\n                else odd += x[i] ;\\n            }\\n            sort(odd.begin() , odd.end()) ;\\n            sort(even.begin(), even.end()) ;\\n            if(mp.find(odd+even) == mp.end()) mp.insert(odd+even) ;\\n        }\\n        return mp.size() ;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958495,
                "title": "best-easiest-solution-on-web-roght-now-i-am-a-genius",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        odd,even=\"\",\"\"\\n        final={}\\n        for i in words:\\n            for j in range(0,len(i)):\\n                if j%2==0:\\n                    even = even+i[j]\\n                else:\\n                    odd=odd+i[j]\\n            a = \"\".join(sorted(even)+sorted(odd))\\n            if a in final:\\n                final[a] = final[a]+1\\n            else:\\n                final[a]=1\\n            odd,even=\"\",\"\"\\n        return len(final)\\n                \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        odd,even=\"\",\"\"\\n        final={}\\n        for i in words:\\n            for j in range(0,len(i)):\\n                if j%2==0:\\n                    even = even+i[j]\\n                else:\\n                    odd=odd+i[j]\\n            a = \"\".join(sorted(even)+sorted(odd))\\n            if a in final:\\n                final[a] = final[a]+1\\n            else:\\n                final[a]=1\\n            odd,even=\"\",\"\"\\n        return len(final)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932744,
                "title": "straight-forward-solution-begineer-friendly-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String>st=new HashSet<>();\\n        for(String word:words){\\n            StringBuilder odd=new StringBuilder();\\n            StringBuilder even=new StringBuilder();\\n\\n\\n            for(int i=0;i<word.length();i++){\\n                if(i%2==0){\\n                    even.append(word.charAt(i));\\n                }\\n                else{\\n                    odd.append(word.charAt(i));\\n                }\\n            }\\n            String oddstr=odd.toString();\\n            String evenstr=even.toString();\\n\\n            char oddarr[]=oddstr.toCharArray();\\n            char evenarr[]=evenstr.toCharArray();\\n            Arrays.sort(oddarr);\\n            Arrays.sort(evenarr);\\n\\n\\n            StringBuilder oddsorted=new StringBuilder(new String(oddarr));\\n            StringBuilder evensorted=new StringBuilder(new String(evenarr));\\n\\n            StringBuilder str=new StringBuilder();\\n            str.append(oddsorted);\\n            str.append(evensorted);\\n\\n            st.add(str.toString());\\n\\n\\n\\n\\n\\n        }\\n\\n\\n        return st.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String>st=new HashSet<>();\\n        for(String word:words){\\n            StringBuilder odd=new StringBuilder();\\n            StringBuilder even=new StringBuilder();\\n\\n\\n            for(int i=0;i<word.length();i++){\\n                if(i%2==0){\\n                    even.append(word.charAt(i));\\n                }\\n                else{\\n                    odd.append(word.charAt(i));\\n                }\\n            }\\n            String oddstr=odd.toString();\\n            String evenstr=even.toString();\\n\\n            char oddarr[]=oddstr.toCharArray();\\n            char evenarr[]=evenstr.toCharArray();\\n            Arrays.sort(oddarr);\\n            Arrays.sort(evenarr);\\n\\n\\n            StringBuilder oddsorted=new StringBuilder(new String(oddarr));\\n            StringBuilder evensorted=new StringBuilder(new String(evenarr));\\n\\n            StringBuilder str=new StringBuilder();\\n            str.append(oddsorted);\\n            str.append(evensorted);\\n\\n            st.add(str.toString());\\n\\n\\n\\n\\n\\n        }\\n\\n\\n        return st.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882303,
                "title": "hashmap-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        gloss = {}\\n        answer = 0\\n        for w in words:\\n            ev = []\\n            od = []\\n            for i, ch in enumerate(w):\\n                if i%2==0:\\n                    ev.append(ch)\\n                else:\\n                    od.append(ch)\\n            k_ev = tuple(sorted(ev))\\n            v_ev = tuple(sorted(od))\\n            if k_ev in gloss:\\n                if v_ev not in gloss[k_ev]:\\n                    gloss[k_ev].append(v_ev)\\n                    answer += 1\\n            else:\\n                answer += 1\\n                gloss[k_ev] = [v_ev]\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        gloss = {}\\n        answer = 0\\n        for w in words:\\n            ev = []\\n            od = []\\n            for i, ch in enumerate(w):\\n                if i%2==0:\\n                    ev.append(ch)\\n                else:\\n                    od.append(ch)\\n            k_ev = tuple(sorted(ev))\\n            v_ev = tuple(sorted(od))\\n            if k_ev in gloss:\\n                if v_ev not in gloss[k_ev]:\\n                    gloss[k_ev].append(v_ev)\\n                    answer += 1\\n            else:\\n                answer += 1\\n                gloss[k_ev] = [v_ev]\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848562,
                "title": "c-hash-table",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> Map;\\n        for(string word: words) {\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int i = 0; i < word.length(); i++) {\\n                if(i % 2 == 0) even += word[i];\\n                else odd += word[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            ++Map[odd + even];\\n        }\\n        return Map.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> Map;\\n        for(string word: words) {\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int i = 0; i < word.length(); i++) {\\n                if(i % 2 == 0) even += word[i];\\n                else odd += word[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            ++Map[odd + even];\\n        }\\n        return Map.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796458,
                "title": "python-simple-set",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        res = set()\\n        for w in words: res.add(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])))\\n        return len(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        res = set()\\n        for w in words: res.add(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])))\\n        return len(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780585,
                "title": "java-beats-56",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736872,
                "title": "c-easy-solution-sorting-unordered-set-explanation",
                "content": "# EXPLANATION\\nCreated unordered set to store answer and deal with duplicates.\\nTraversed through words vector.\\nPushed the string in even position in **a** and odd positions in **b**.\\nSort string **a** and **b** and insert the combination of **a and b** in set.\\nFinally returned the size of set.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(auto x:words){\\n            string a,b;\\n            for(int i=0;i<x.size();i++){\\n                if(i%2==0)\\n                    a.push_back(x[i]);\\n                else\\n                    b.push_back(x[i]);\\n            }\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            s.insert(a+b);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(auto x:words){\\n            string a,b;\\n            for(int i=0;i<x.size();i++){\\n                if(i%2==0)\\n                    a.push_back(x[i]);\\n                else\\n                    b.push_back(x[i]);\\n            }\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            s.insert(a+b);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717598,
                "title": "groups-of-special-equivalent-strings-js-easy-solution",
                "content": "\\n\\n# JS Easy\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(words) {\\n    let set = new Set();\\n  let data = [];\\n  for (let i of words) {\\n    let temp = [...i];\\n    let even = [];\\n    let odd = [];\\n    temp.forEach((w, index) => {\\n      if (index % 2 == 0) {\\n        even.push(w);\\n      } else {\\n        odd.push(w);\\n      }\\n    });\\n    even.sort();\\n    odd.sort();\\n    let demo = [...even, ...odd];\\n    data.push(demo.join(\"\"));\\n  }\\n  data.forEach((a) => {\\n    set.add(a);\\n  });\\n  return set.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(words) {\\n    let set = new Set();\\n  let data = [];\\n  for (let i of words) {\\n    let temp = [...i];\\n    let even = [];\\n    let odd = [];\\n    temp.forEach((w, index) => {\\n      if (index % 2 == 0) {\\n        even.push(w);\\n      } else {\\n        odd.push(w);\\n      }\\n    });\\n    even.sort();\\n    odd.sort();\\n    let demo = [...even, ...odd];\\n    data.push(demo.join(\"\"));\\n  }\\n  data.forEach((a) => {\\n    set.add(a);\\n  });\\n  return set.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704853,
                "title": "quite-ordinary-approach",
                "content": "# Approach\\nSpecial-Equivalent strings have the same elements in even positions, as well as the same elements in odd positions.\\n\\n# Complexity\\n- Time complexity: $$O(n*wordlen*log(wordlen))$$.\\n\\n- Space complexity: $$O(n*wordlen)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        W = len(words[0])\\n        groups = set()\\n        for word in words:\\n            even, odd = [], []\\n            for i in range(0, W, 2):\\n                even.append(word[i])\\n            for i in range(1, W, 2):\\n                odd.append(word[i])\\n\\n            groups.add(\\'\\'.join(chain(sorted(even), sorted(odd))))\\n\\n        return len(groups)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        W = len(words[0])\\n        groups = set()\\n        for word in words:\\n            even, odd = [], []\\n            for i in range(0, W, 2):\\n                even.append(word[i])\\n            for i in range(1, W, 2):\\n                odd.append(word[i])\\n\\n            groups.add(\\'\\'.join(chain(sorted(even), sorted(odd))))\\n\\n        return len(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701491,
                "title": "c-easy-solution-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nw - words count\\nl - letters count\\n$$O(w * l)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        var set = new HashSet<string>();\\n        foreach(var word in words)\\n        {\\n            var odd = new int[26];\\n            var even = new int[26];\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0)\\n                    even[word[i] - \\'a\\']++;\\n                else\\n                    odd[word[i] - \\'a\\']++;\\n            }\\n            set.Add(string.Concat(odd) + string.Concat(even));\\n        }\\n        return set.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        var set = new HashSet<string>();\\n        foreach(var word in words)\\n        {\\n            var odd = new int[26];\\n            var even = new int[26];\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0)\\n                    even[word[i] - \\'a\\']++;\\n                else\\n                    odd[word[i] - \\'a\\']++;\\n            }\\n            set.Add(string.Concat(odd) + string.Concat(even));\\n        }\\n        return set.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646751,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groups = set()\\n\\n        for x in words:\\n            counts = [0]*52\\n\\n            for i,x in enumerate(x):\\n                counts[ord(x)-ord(\\'a\\')+(26 if i%2 else 0)] += 1\\n            \\n            groups.add(tuple(counts))\\n        \\n        return len(groups)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groups = set()\\n\\n        for x in words:\\n            counts = [0]*52\\n\\n            for i,x in enumerate(x):\\n                counts[ord(x)-ord(\\'a\\')+(26 if i%2 else 0)] += 1\\n            \\n            groups.add(tuple(counts))\\n        \\n        return len(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620807,
                "title": "java-simple-solution-using-stringbuilder-and-lists",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        for(String word: words){\\n            StringBuilder sortedString = new StringBuilder();\\n            StringBuilder evenList = new StringBuilder();\\n            StringBuilder oddList = new StringBuilder();\\n            for(int i =0;i<word.length(); i++){\\n                if(i%2 == 0){\\n                    evenList.append(word.charAt(i));\\n                }\\n                else{\\n                    oddList.append(word.charAt(i));\\n                }\\n            }\\n            char evenArray[] = evenList.toString().toCharArray();\\n            Arrays.sort(evenArray);\\n            sortedString.append(evenArray);\\n            char oddArray[] = oddList.toString().toCharArray();\\n            Arrays.sort(oddArray);\\n            sortedString.append(oddArray);\\n            list.add(sortedString.toString());\\n        }\\n        return (int)list.stream().distinct().count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        for(String word: words){\\n            StringBuilder sortedString = new StringBuilder();\\n            StringBuilder evenList = new StringBuilder();\\n            StringBuilder oddList = new StringBuilder();\\n            for(int i =0;i<word.length(); i++){\\n                if(i%2 == 0){\\n                    evenList.append(word.charAt(i));\\n                }\\n                else{\\n                    oddList.append(word.charAt(i));\\n                }\\n            }\\n            char evenArray[] = evenList.toString().toCharArray();\\n            Arrays.sort(evenArray);\\n            sortedString.append(evenArray);\\n            char oddArray[] = oddList.toString().toCharArray();\\n            Arrays.sort(oddArray);\\n            sortedString.append(oddArray);\\n            list.add(sortedString.toString());\\n        }\\n        return (int)list.stream().distinct().count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611903,
                "title": "c-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set <string> st;\\n        for (auto w : words) {\\n            string odd, ev;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i%2==1)\\n                { ev += w[i];}\\n                else {\\n                odd += w[i];}\\n            }\\n            sort(odd.begin(),odd.end());\\n            sort(ev.begin(),ev.end());\\n            st.insert(odd+ev);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set <string> st;\\n        for (auto w : words) {\\n            string odd, ev;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i%2==1)\\n                { ev += w[i];}\\n                else {\\n                odd += w[i];}\\n            }\\n            sort(odd.begin(),odd.end());\\n            sort(ev.begin(),ev.end());\\n            st.insert(odd+ev);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574430,
                "title": "typescript-solution-using-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numSpecialEquivGroups(words: string[]): number {\\n    const groups = {};\\n\\n    for (let word of words) {\\n        const map: Record<string, number> = {};\\n\\n        for (let i = 0; i < word.length; i++) {\\n            const hash = decode(word[i], i);\\n            map[hash] = map[hash] ?? 0;\\n            map[hash]++;\\n        }\\n\\n        const hash = decodeMappedWord(map)\\n\\n        groups[hash] = groups[hash] ?? true;\\n    }\\n\\n    return Object.keys(groups).length;\\n};\\n\\nfunction decode(letter: string, index: number): string {\\n    return `${letter}-${index % 2}`;\\n}\\n\\nfunction decodeMappedWord(map: Record<string,number>): string {\\n    return Object.keys(map).sort().reduce((acc, key) => acc + `${key}:${map[key]}`, \\'\\') \\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numSpecialEquivGroups(words: string[]): number {\\n    const groups = {};\\n\\n    for (let word of words) {\\n        const map: Record<string, number> = {};\\n\\n        for (let i = 0; i < word.length; i++) {\\n            const hash = decode(word[i], i);\\n            map[hash] = map[hash] ?? 0;\\n            map[hash]++;\\n        }\\n\\n        const hash = decodeMappedWord(map)\\n\\n        groups[hash] = groups[hash] ?? true;\\n    }\\n\\n    return Object.keys(groups).length;\\n};\\n\\nfunction decode(letter: string, index: number): string {\\n    return `${letter}-${index % 2}`;\\n}\\n\\nfunction decodeMappedWord(map: Record<string,number>): string {\\n    return Object.keys(map).sort().reduce((acc, key) => acc + `${key}:${map[key]}`, \\'\\') \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567739,
                "title": "clean-easy-solution-explained-only-set-no-sort",
                "content": "If 2 strings are eqiv, then thier respective freq at even and odd indices must be same for the swap condition to be held true\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<vector<int>,vector<int>>> s;\\n        for(auto &w:words)\\n        {\\n            vector<int> odd(26),even(26);\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2) even[w[i]-\\'a\\']++;\\n                else odd[w[i]-\\'a\\']++;\\n            }\\n            s.insert({odd,even});\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<vector<int>,vector<int>>> s;\\n        for(auto &w:words)\\n        {\\n            vector<int> odd(26),even(26);\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2) even[w[i]-\\'a\\']++;\\n                else odd[w[i]-\\'a\\']++;\\n            }\\n            s.insert({odd,even});\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497603,
                "title": "hashset-string-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int n = words.length;\\n        for(int i=0;i<n;i++){\\n            String t1=\"\",t2=\"\";\\n            List<Character> even = new ArrayList<>();\\n            List<Character> odd = new ArrayList<>();\\n            for(int j=0;j<words[i].length();j++){\\n               if(j%2==0) even.add(words[i].charAt(j));\\n               else odd.add(words[i].charAt(j));}\\n               Collections.sort(even);\\n               Collections.sort(odd);\\n               for(int k=0;k<even.size();k++){\\n                  t1 += even.get(k);\\n               }\\n               for(int k=0;k<odd.size();k++){\\n                  t2 += odd.get(k);\\n               }\\n           set.add(t1+t2);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int n = words.length;\\n        for(int i=0;i<n;i++){\\n            String t1=\"\",t2=\"\";\\n            List<Character> even = new ArrayList<>();\\n            List<Character> odd = new ArrayList<>();\\n            for(int j=0;j<words[i].length();j++){\\n               if(j%2==0) even.add(words[i].charAt(j));\\n               else odd.add(words[i].charAt(j));}\\n               Collections.sort(even);\\n               Collections.sort(odd);\\n               for(int k=0;k<even.size();k++){\\n                  t1 += even.get(k);\\n               }\\n               for(int k=0;k<odd.size();k++){\\n                  t2 += odd.get(k);\\n               }\\n           set.add(t1+t2);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466282,
                "title": "faster-than-100-hashset",
                "content": "# Intuition\\nadd every word charracters in different strings odd and even, then sort them and add to the hashset, if they\\'ve not been already added\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nn - words count \\nw - letters count (max 20 due to description)\\nO(n * w^2 * log(w))\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        HashSet<string> result = new HashSet<string>();\\n        foreach(string word in words)\\n        {\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0) even += word[i];\\n                else odd+=word[i];\\n            }\\n            char[] odds = odd.ToCharArray();\\n            Array.Sort(odds);\\n            char[] evends = even.ToCharArray();\\n            Array.Sort(evends);\\n            string s = new string(odds) + new string(evends);\\n            result.Add(s);\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        HashSet<string> result = new HashSet<string>();\\n        foreach(string word in words)\\n        {\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0) even += word[i];\\n                else odd+=word[i];\\n            }\\n            char[] odds = odd.ToCharArray();\\n            Array.Sort(odds);\\n            char[] evends = even.ToCharArray();\\n            Array.Sort(evends);\\n            string s = new string(odds) + new string(evends);\\n            result.Add(s);\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433479,
                "title": "java-simple-and-clear-solution-with-hash-table-implementation",
                "content": "# Complexity\\n- Time complexity: O(n + m)\\n  - n is number of words\\n  - m is total length of all words \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int[] odds = new int[26];\\n    private int[] evens = new int[26];\\n    private  StringBuilder sb = new StringBuilder();\\n\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();   \\n  \\n        for(String s : words){\\n            String key = generateKey(s);\\n            map.put(key, map.getOrDefault(key, 0) + 1);\\n        }\\n\\n        return map.keySet().size();\\n    }\\n\\n    private String generateKey(String s){\\n        boolean isOdd = true;\\n        sb.setLength(0);\\n        \\n        for(int i = 0; i < 26; i++){\\n            odds[i]=0;\\n            evens[i]=0;\\n        }\\n\\n        for(char c : s.toCharArray()){\\n            if(isOdd)\\n                odds[c-\\'a\\']++;\\n            else\\n                evens[c -\\'a\\']++;\\n            isOdd = !isOdd;\\n        }\\n\\n        for(int i = 0; i < 26; i++){\\n            sb.append(odds[i]);\\n            sb.append(evens[i]);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    private int[] odds = new int[26];\\n    private int[] evens = new int[26];\\n    private  StringBuilder sb = new StringBuilder();\\n\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();   \\n  \\n        for(String s : words){\\n            String key = generateKey(s);\\n            map.put(key, map.getOrDefault(key, 0) + 1);\\n        }\\n\\n        return map.keySet().size();\\n    }\\n\\n    private String generateKey(String s){\\n        boolean isOdd = true;\\n        sb.setLength(0);\\n        \\n        for(int i = 0; i < 26; i++){\\n            odds[i]=0;\\n            evens[i]=0;\\n        }\\n\\n        for(char c : s.toCharArray()){\\n            if(isOdd)\\n                odds[c-\\'a\\']++;\\n            else\\n                evens[c -\\'a\\']++;\\n            isOdd = !isOdd;\\n        }\\n\\n        for(int i = 0; i < 26; i++){\\n            sb.append(odds[i]);\\n            sb.append(evens[i]);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427024,
                "title": "not-very-good-solution-but-i-hope-it-ll-help-you",
                "content": "![Screenshot 2023-04-17 162629.png](https://assets.leetcode.com/users/images/d2ff9101-1e00-4fe8-be8f-1a1e83aeaa31_1681737995.5241587.png)\\n\\nAs there is no solution in c# yet I hope this will help you to understand the question better.\\n# Code\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        int res = 0;\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i] != \"\")\\n            {\\n                res++;\\n                List<char> evenCh = new();\\n                List<char> oddCh = new();\\n                for (int j = 0; j < words[i].Length; j++)\\n                {\\n                    if(j % 2 == 0)\\n                        evenCh.Add(words[i][j]);\\n                    else\\n                        oddCh.Add(words[i][j]);\\n                }\\n                for (int j = i + 1; j < words.Length; j++)\\n                {\\n                    List<char> tmp_evenCh = new List<char>(evenCh);\\n                    List<char> tmp_oddCh = new List<char>(oddCh);\\n                    bool add = true;\\n                    for (int k = 0; k < words[j].Length; k++)\\n                    {\\n                        if (k % 2 == 0 && tmp_evenCh.Contains(words[j][k]))\\n                        {\\n                            tmp_evenCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 0)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                        if(k % 2 == 1 && tmp_oddCh.Contains(words[j][k]))\\n                        {\\n                            tmp_oddCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 1)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                    }\\n                    if (add)\\n                    {\\n                        words[j] = \"\";\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        int res = 0;\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i] != \"\")\\n            {\\n                res++;\\n                List<char> evenCh = new();\\n                List<char> oddCh = new();\\n                for (int j = 0; j < words[i].Length; j++)\\n                {\\n                    if(j % 2 == 0)\\n                        evenCh.Add(words[i][j]);\\n                    else\\n                        oddCh.Add(words[i][j]);\\n                }\\n                for (int j = i + 1; j < words.Length; j++)\\n                {\\n                    List<char> tmp_evenCh = new List<char>(evenCh);\\n                    List<char> tmp_oddCh = new List<char>(oddCh);\\n                    bool add = true;\\n                    for (int k = 0; k < words[j].Length; k++)\\n                    {\\n                        if (k % 2 == 0 && tmp_evenCh.Contains(words[j][k]))\\n                        {\\n                            tmp_evenCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 0)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                        if(k % 2 == 1 && tmp_oddCh.Contains(words[j][k]))\\n                        {\\n                            tmp_oddCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 1)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                    }\\n                    if (add)\\n                    {\\n                        words[j] = \"\";\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386764,
                "title": "better-than-my-previous-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, I noticed that two words are special equivalent iff their even characters are \"count equivalent\" and odd characters are \"count equivalent\", where two strings are \"count equivalent\" iff they have the same multiset of characters.  Two strings are \"count equivalent\" iff they are identical when their characters are sorted.  Second, when you want to count a number of objects subject to equivalence,\\nyou can use a ```set```. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first step is for each \"word\", to separate the even and the odd characters.  Then, for each of the two resulting strings, sort the characters in each, since two strings are \"count equivalent\" if their character-sorted versions are identical.  Then, count the number of pairs of the split, sorted words using a Set.  The function ```canon``` converts a word into a *canonical form* by splitting, sorting, and pairing.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time is at least proportional to the number of words.  Further, the sort inside ```canon``` is proportional to $$O(c log c)$$ where $$c$$ is the number of characters in each word.  The comparison used to maintain the set is $$O(c)$$.  The overall time complexity is $$O(n * c * log c)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only storage that grows is the set of canonicalized representations, which is proportional in the worst case to $$O(n * c)$$.\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = set()\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            groupCanons.add( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the sorted\\n    # even characters and the sorted odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( \\'\\'.join( sorted( word[ 0::2] ) ), \\'\\'.join( sorted( word[1::2] ) ) )\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```set```\n```canon```\n```canon```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = set()\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            groupCanons.add( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the sorted\\n    # even characters and the sorted odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( \\'\\'.join( sorted( word[ 0::2] ) ), \\'\\'.join( sorted( word[1::2] ) ) )\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386492,
                "title": "simple-code-but-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing I looked at was the even<->even and odd<->odd aspect of the definition of special equivalence.  I realized that two words w1 and w2 were special equivalent iff their even characters were special equivalent *and* their odd characters were special equivalent, since even and odd characters could never be swapped.  Next, I realized that two strings are special equivalent iff their character frequencies are the same.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI defined a function ```canon``` that maps an original \"word\" into a 2-tuple consisting of the character frequencies of even characters and character frequencies of odd characters.  Two words were then special equivalent iff their canonical representations are equal (thanks! to Python for making it so easy to compare 2-tuples of Counters).  Then it was a matter of counting how many distinct canonical representations were found; this was a little painful, since it involved an $$O(n)$$ loop that results in quadratic time complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs noted above, the time complexity is proportional to $$O(n^2)$$.  There is an additional factor:  the canonicalization and comparisons in the counting loop are $$O(c)$$ where $$c$$ is the number of characters in each word.  Thus the overall time complexity is $$O(n^2*c)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe storage cost for one canonical representation is $$O(c)$$, and we may have to store up to $$O(n)$$ canonical representations if none of the words are special-equivalent, making the overall space complexity $$O(n*c)$$.\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = []\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            found = False\\n            for groupCanon in groupCanons:\\n                if groupCanon == wordCanon:\\n                    found = True\\n                    break\\n            if not found:\\n                groupCanons.append( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the letter\\n    # frequency of even characters and letter frequency of\\n    # odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( Counter( word[ 0::2] ), Counter( word[1::2] ) )\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```canon```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = []\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            found = False\\n            for groupCanon in groupCanons:\\n                if groupCanon == wordCanon:\\n                    found = True\\n                    break\\n            if not found:\\n                groupCanons.append( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the letter\\n    # frequency of even characters and letter frequency of\\n    # odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( Counter( word[ 0::2] ), Counter( word[1::2] ) )\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384648,
                "title": "c-unordered-set-hash-table-sort-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can group words that are special equivalent by sorting their even-indexed and odd-indexed characters separately and then concatenating them back together. We can use an unordered set to keep track of the unique groups of special equivalent words.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each word in the input vector, we can extract the even-indexed characters and odd-indexed characters separately using a for loop with a step of 2. We can then sort both substrings and concatenate them back together to form a unique key. We can insert this key into an unordered set to keep track of the unique groups of special equivalent words. Finally, we can return the size of the unordered set as the number of special equivalent groups.\\n\\n# Complexity\\n- Time complexity: $$O(n * k * log(k))$$\\nwhere n is the number of words in the input vector, and k is the maximum length of a word in the input vector. We iterate through the input vector once, and for each word, we sort the even-indexed characters and odd-indexed characters separately, which takes O(k*log(k)) time.\\n\\n- Space complexity: $$O(n * k)$$\\nwhere n is the number of words in the input vector, and k is the maximum length of a word in the input vector. We store each sorted key in the unordered set, which takes O(k) space, and we may have up to n unique keys in the unordered set.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373279,
                "title": "i-dare-you-to-read-this-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<map<char,pair<int,int>>,string> mp;\\n\\n        for(int i = 0; i<words.size(); i++){\\n            map<char,pair<int,int>> m1;\\n            for(int j = 0; j<words[0].size(); j++){\\n                if(j%2 == 0) m1[words[i][j]].first++;\\n                else m1[words[i][j]].second++;\\n            }\\n            mp[m1] = words[i];\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<map<char,pair<int,int>>,string> mp;\\n\\n        for(int i = 0; i<words.size(); i++){\\n            map<char,pair<int,int>> m1;\\n            for(int j = 0; j<words[0].size(); j++){\\n                if(j%2 == 0) m1[words[i][j]].first++;\\n                else m1[words[i][j]].second++;\\n            }\\n            mp[m1] = words[i];\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364646,
                "title": "c-set-with-explanation",
                "content": "# **Please upvote and give feedback into comment**\\n\\n---\\n\\n\\n# Approach\\n\\n---\\n\\n\\nwe take set for uniqueness and store the one element from the pair(\"abcd\", \"cdba\") and return the length of set \\n\\n1. we add all the even string even=a+c , even =c+a  and odd string odd=b+d,odd=d+b \\n2. sort even and odd string \\n3. total=even +odd and store total into set and return the length of set\\n\\n---\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>res;\\n       \\n        for(auto i:words)\\n        {\\n                string even=\"\",odd=\"\",tot=\"\";\\n                for (int j=0;j<i.size();j++)\\n                {\\n                    if(j%2==0)\\n                    {\\n                        even+=i[j];\\n                    }\\n                    else\\n                    {\\n                        odd+=i[j];\\n                    }\\n                }\\n                sort(even.begin(),even.end());\\n                sort(odd.begin(),odd.end());\\n            tot=even+odd;\\n            res.insert(tot);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>res;\\n       \\n        for(auto i:words)\\n        {\\n                string even=\"\",odd=\"\",tot=\"\";\\n                for (int j=0;j<i.size();j++)\\n                {\\n                    if(j%2==0)\\n                    {\\n                        even+=i[j];\\n                    }\\n                    else\\n                    {\\n                        odd+=i[j];\\n                    }\\n                }\\n                sort(even.begin(),even.end());\\n                sort(odd.begin(),odd.end());\\n            tot=even+odd;\\n            res.insert(tot);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326597,
                "title": "python-hashmap-set-tuple",
                "content": "The trick here is that we create an array of size 52 to count occurances the first half being our characters that are even and the second half characters that are odd.\\n\\nOnce we have this we need to convert it into a tuple so it can be used as a key and we add it to our map/set.\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        \\n        #solved using a tuple of size 52 to hold all of the alpha characters * 2 \\n        #the second half being used to hold odd and the first half to hold even\\n        mp = defaultdict(int)\\n        #tuple the size of 52\\n        for i in range(len(words)):\\n            a = [0] * 52\\n            for j in range(len(words[i])):\\n                char = words[i][j]\\n                if j % 2 == 0:\\n                    v = ord(char) - ord(\\'a\\')\\n                    a[v] += 1\\n                else:\\n                    v = ord(char) - ord(\\'a\\')\\n                    v += 26\\n                    a[v] +=1\\n            \\n            mp[tuple(a)] += 1\\n            \\n        \\n        \\n        return len(mp)\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "The trick here is that we create an array of size 52 to count occurances the first half being our characters that are even and the second half characters that are odd.\\n\\nOnce we have this we need to convert it into a tuple so it can be used as a key and we add it to our map/set.\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        \\n        #solved using a tuple of size 52 to hold all of the alpha characters * 2 \\n        #the second half being used to hold odd and the first half to hold even\\n        mp = defaultdict(int)\\n        #tuple the size of 52\\n        for i in range(len(words)):\\n            a = [0] * 52\\n            for j in range(len(words[i])):\\n                char = words[i][j]\\n                if j % 2 == 0:\\n                    v = ord(char) - ord(\\'a\\')\\n                    a[v] += 1\\n                else:\\n                    v = ord(char) - ord(\\'a\\')\\n                    v += 26\\n                    a[v] +=1\\n            \\n            mp[tuple(a)] += 1\\n            \\n        \\n        \\n        return len(mp)\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 3302555,
                "title": "simple-java-solution-runtime-11ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n     Set<String>set=new HashSet<>();\\n     \\n     for(String word:words)\\n     {\\n         String even=\"\",odd=\"\";\\n         for(int i=0;i<word.length();i++)\\n         {\\n             if(i%2==0)\\n             {\\n                 even+=word.charAt(i);\\n             }\\n             else{\\n                 odd+=word.charAt(i);\\n             }\\n\\n         }\\n\\n         odd=sorted(odd);\\n         even=sorted(even);\\n         set.add(odd+even);\\n     } \\n     return set.size();  \\n    }\\n\\n    public String sorted(String s )\\n    {\\n        char[] c=s.toCharArray();\\n        Arrays.sort(c);\\n        return String.valueOf(c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n     Set<String>set=new HashSet<>();\\n     \\n     for(String word:words)\\n     {\\n         String even=\"\",odd=\"\";\\n         for(int i=0;i<word.length();i++)\\n         {\\n             if(i%2==0)\\n             {\\n                 even+=word.charAt(i);\\n             }\\n             else{\\n                 odd+=word.charAt(i);\\n             }\\n\\n         }\\n\\n         odd=sorted(odd);\\n         even=sorted(even);\\n         set.add(odd+even);\\n     } \\n     return set.size();  \\n    }\\n\\n    public String sorted(String s )\\n    {\\n        char[] c=s.toCharArray();\\n        Arrays.sort(c);\\n        return String.valueOf(c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275835,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) \\n    {\\n        unordered_map<string ,int>u;\\n       for(int i=0;i<w.size();++i)\\n       {\\n           string s1=\"\",s2=\"\";\\n           for(int j=0;j<w[i].length();++j)\\n           {\\n               if(j%2!=0)\\n                   s2.push_back(w[i][j]);\\n               else\\n                   s1.push_back(w[i][j]);\\n           }\\n           sort(s1.begin(),s1.end());\\n           sort(s2.begin(),s2.end());\\n           int k=0;\\n           for(int j=0;j<w[i].length();++j)\\n           {\\n               if(j%2!=0)\\n                   w[i][j]=s2[k++];\\n               else\\n                 w[i][j]=s1[k];\\n           }\\n           ++u[w[i]];\\n       }\\n        int c=0;\\n        for(auto a:u)\\n        {\\n            ++c;\\n            \\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) \\n    {\\n        unordered_map<string ,int>u;\\n       for(int i=0;i<w.size();++i)\\n       {\\n           string s1=\"\",s2=\"\";\\n           for(int j=0;j<w[i].length();++j)\\n           {\\n               if(j%2!=0)\\n                   s2.push_back(w[i][j]);\\n               else\\n                   s1.push_back(w[i][j]);\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3255268,
                "title": "python3-one-liner-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        return len(Counter([\"\".join(sorted(w[1::2]) + sorted(w[::2])) for w in words]))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        return len(Counter([\"\".join(sorted(w[1::2]) + sorted(w[::2])) for w in words]))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238916,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string>Set ;\\n        for(auto& word : words)\\n        {\\n            string even, odd ;\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i % 2)\\n                    odd.push_back(word[i]) ;\\n                else\\n                    even.push_back(word[i]) ;\\n            }\\n            sort(even.begin(), even.end()) ;\\n            sort(odd.begin(), odd.end()) ;\\n            Set.insert(even + odd) ;\\n        }\\n        return Set.size() ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string>Set ;\\n        for(auto& word : words)\\n        {\\n            string even, odd ;\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i % 2)\\n                    odd.push_back(word[i]) ;\\n                else\\n                    even.push_back(word[i]) ;\\n            }\\n            sort(even.begin(), even.end()) ;\\n            sort(odd.begin(), odd.end()) ;\\n            Set.insert(even + odd) ;\\n        }\\n        return Set.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205327,
                "title": "rust-0ms",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        words\\n            .into_iter()\\n            .map(|w| {\\n                let (mut even, mut odd) = (vec![0; 26], vec![0; 26]);\\n                for (i, ch) in w.chars().enumerate() {\\n                    let idx = ch as usize - \\'a\\' as usize;\\n                    if i % 2 == 0 {\\n                        even[idx] += 1;\\n                    } else {\\n                        odd[idx] += 1;\\n                    }\\n                }\\n                (even, odd)\\n            })\\n            .fold(HashSet::new(), |mut acc, k| {\\n                acc.insert(k);\\n                acc\\n            })\\n            .len() as i32   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        words\\n            .into_iter()\\n            .map(|w| {\\n                let (mut even, mut odd) = (vec![0; 26], vec![0; 26]);\\n                for (i, ch) in w.chars().enumerate() {\\n                    let idx = ch as usize - \\'a\\' as usize;\\n                    if i % 2 == 0 {\\n                        even[idx] += 1;\\n                    } else {\\n                        odd[idx] += 1;\\n                    }\\n                }\\n                (even, odd)\\n            })\\n            .fold(HashSet::new(), |mut acc, k| {\\n                acc.insert(k);\\n                acc\\n            })\\n            .len() as i32   \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3192615,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ words: [String]) -> Int {\\n        Set(\\n            words\\n                .map { w -> String in\\n                    let cs = w.map { $0 }\\n                    let es = cs.indices.filter({ $0 % 2 == 0 }).map({ cs[$0] })\\n                    let os = cs.indices.filter({ $0 % 2 == 1 }).map({ cs[$0] })\\n                    return String(es.sorted() + os.sorted())\\n                }\\n        ).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ words: [String]) -> Int {\\n        Set(\\n            words\\n                .map { w -> String in\\n                    let cs = w.map { $0 }\\n                    let es = cs.indices.filter({ $0 % 2 == 0 }).map({ cs[$0] })\\n                    let os = cs.indices.filter({ $0 % 2 == 1 }).map({ cs[$0] })\\n                    return String(es.sorted() + os.sorted())\\n                }\\n        ).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169209,
                "title": "c-solution-using-map-and-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<pair<map<char,int>,map<char,int>>>s;\\n        for(int i=0;i<w.size();++i){\\n            map<char,int>odd;\\n            map<char,int>even;\\n            for(int j=0;j<w[i].size();++j){\\n                if(j%2==0)\\n                   even[w[i][j]]++;\\n                else\\n                   odd[w[i][j]]++;\\n            }\\n            s.insert({even,odd});\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<pair<map<char,int>,map<char,int>>>s;\\n        for(int i=0;i<w.size();++i){\\n            map<char,int>odd;\\n            map<char,int>even;\\n            for(int j=0;j<w[i].size();++j){\\n                if(j%2==0)\\n                   even[w[i][j]]++;\\n                else\\n                   odd[w[i][j]]++;\\n            }\\n            s.insert({even,odd});\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142211,
                "title": "simple-and-concise-beats-98-c-set-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string> res;\\n        for(auto s:words)\\n        {\\n            string ev = \"\";\\n            string od = \"\";\\n            for(int i = 0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ev = ev+s[i];\\n                }\\n                else\\n                    od = od+s[i];\\n            }\\n            sort(ev.begin(), ev.end());\\n            sort(od.begin(), od.end());\\n            string final_str = ev+od;\\n            if(res.count(final_str)==0)\\n                res.insert(final_str);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string> res;\\n        for(auto s:words)\\n        {\\n            string ev = \"\";\\n            string od = \"\";\\n            for(int i = 0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ev = ev+s[i];\\n                }\\n                else\\n                    od = od+s[i];\\n            }\\n            sort(ev.begin(), ev.end());\\n            sort(od.begin(), od.end());\\n            string final_str = ev+od;\\n            if(res.count(final_str)==0)\\n                res.insert(final_str);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140656,
                "title": "easy-direct-approach",
                "content": "# Approach\\nuse the brute force approach as the parameters are comfortable in doing that.\\nStore the map of even and odd words count of each words and compare them using a brute force method.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        vector<unordered_map<char,int>> a(words.size()),b(words.size());\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j = 0;j<words[i].size();j=j+2)\\n            {\\n                a[i][words[i][j]]++;\\n            }\\n            for(int j = 1;j<words[i].size();j=j+2)\\n            {\\n                b[i][words[i][j]]++;\\n            }\\n        }\\n        int ans = 0 ;\\n        for(int k = 0 ; k<words.size()-1;k++)\\n        {\\n            if(words[k]!=\" \")\\n            {\\n                for(int j=k+1;j<words.size();j++)\\n                {\\n                    if(words[j]!=\" \")\\n                    {\\n                        \\n                        if(a[k]==a[j] and b[k]==b[j])\\n                        {\\n                            ans++;\\n                            words[j] = \" \";\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return words.size() - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        vector<unordered_map<char,int>> a(words.size()),b(words.size());\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j = 0;j<words[i].size();j=j+2)\\n            {\\n                a[i][words[i][j]]++;\\n            }\\n            for(int j = 1;j<words[i].size();j=j+2)\\n            {\\n                b[i][words[i][j]]++;\\n            }\\n        }\\n        int ans = 0 ;\\n        for(int k = 0 ; k<words.size()-1;k++)\\n        {\\n            if(words[k]!=\" \")\\n            {\\n                for(int j=k+1;j<words.size();j++)\\n                {\\n                    if(words[j]!=\" \")\\n                    {\\n                        \\n                        if(a[k]==a[j] and b[k]==b[j])\\n                        {\\n                            ans++;\\n                            words[j] = \" \";\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return words.size() - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133726,
                "title": "c-map-and-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> m;\\n        for (auto& s : words){\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < s.size(); ++i){\\n                if (i % 2 == 0) even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            ++m[odd + even];\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> m;\\n        for (auto& s : words){\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < s.size(); ++i){\\n                if (i % 2 == 0) even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            ++m[odd + even];\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131918,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<pair<string,string>,int> mp;\\n        for(auto &i:words){\\n            string t = \"\",s=\"\";\\n            for(int j=0;j<i.length();j++){\\n                if(j%2) s+=i[j];\\n                else t+=i[j];\\n            }\\n            sort(t.begin(),t.end()),sort(s.begin(),s.end());\\n            pair<string,string> pr = {t,s};\\n            mp[pr]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<pair<string,string>,int> mp;\\n        for(auto &i:words){\\n            string t = \"\",s=\"\";\\n            for(int j=0;j<i.length();j++){\\n                if(j%2) s+=i[j];\\n                else t+=i[j];\\n            }\\n            sort(t.begin(),t.end()),sort(s.begin(),s.end());\\n            pair<string,string> pr = {t,s};\\n            mp[pr]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122297,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<string,string>>st;\\n        for(int i=0;i<words.size();i++){\\n            string emp=\"\",omp=\"\";\\n            for(int j=0;j<words[i].size();j+=2)\\n            emp+=words[i][j];\\n            for(int j=1;j<words[i].size();j+=2)\\n            omp+=words[i][j];\\n            sort(emp.begin(),emp.end());\\n            sort(omp.begin(),omp.end());\\n            st.insert({emp,omp});\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<string,string>>st;\\n        for(int i=0;i<words.size();i++){\\n            string emp=\"\",omp=\"\";\\n            for(int j=0;j<words[i].size();j+=2)\\n            emp+=words[i][j];\\n            for(int j=1;j<words[i].size();j+=2)\\n            omp+=words[i][j];\\n            sort(emp.begin(),emp.end());\\n            sort(omp.begin(),omp.end());\\n            st.insert({emp,omp});\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106915,
                "title": "c-short-easy-solution",
                "content": "Approach:-\\n\\nwe first keep odd and even indexes character seperate and the sort it and then put in set\\nso we get only unique words that is answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<string>s;\\n        for(int i=0;i<w.size();i++){\\n            string e=\"\",o=\"\";\\n            for(int j=0;j<w[i].size();j++){\\n                if(j%2==0)\\n                    e+=w[i][j];\\n                else\\n                    o+=w[i][j];\\n            }\\n            sort(e.begin(),e.end());\\n            sort(o.begin(),o.end());\\n            s.insert(o+e);\\n        }\\n        return s.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<string>s;\\n        for(int i=0;i<w.size();i++){\\n            string e=\"\",o=\"\";\\n            for(int j=0;j<w[i].size();j++){\\n                if(j%2==0)\\n                    e+=w[i][j];\\n                else\\n                    o+=w[i][j];\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564644,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1565190,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1573918,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568182,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1567392,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1569321,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568050,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572660,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572130,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572110,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1564644,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1565190,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1573918,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568182,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1567392,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1569321,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568050,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572660,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572130,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572110,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum of Mutated Array Closest to Target",
        "question_content": "<p>Given an integer array <code>arr</code> and a target value <code>target</code>, return the integer <code>value</code> such that when we change all the integers larger than <code>value</code> in the given array to be equal to <code>value</code>, the sum of the array gets as close as possible (in absolute difference) to <code>target</code>.</p>\n\n<p>In case of a tie, return the minimum such integer.</p>\n\n<p>Notice that the answer is not neccesarilly a number from <code>arr</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [4,9,3], target = 10\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> When using 3 arr converts to [3, 3, 3] which sums 9 and that&#39;s the optimal answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [2,3,5], target = 10\n<strong>Output:</strong> 5\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [60864,25176,27249,21296,20204], target = 56803\n<strong>Output:</strong> 11361\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= arr[i], target &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 463306,
                "title": "java-c-python-just-sort-o-nlogn",
                "content": "## **Explanation**\\nBinary search is `O(NlogMax(A))`.\\nIn order to ruduce the difficulty, it constrains `A[i] < 10 ^ 5`.\\n\\nIn this solution,\\nwe sort the input and compared `A[i]` with target one by one.\\n\\n1. Sort the array `A` in decreasing order.\\n2. We try to make all values in `A` to be the `min(A)` (the last element)\\n3. If `target >= min(A) * n`, we doesn\\'t hit our target yet.\\nWe should continue to try a value bigger.\\n4. So we pop the `min(A)` value.\\nConsider that it won\\'t be affected anymore,\\nwe can remove it from target by `target -= A.pop()`\\n5. We continue doing step 2-4, until the next number is too big for target.\\n6. We split the the target evenly, depending on the number of element left in `A`\\n\\n\\nAt this point, @bobalice help explain the round part:\\nif A is empty means its impossible to reach target so we just return maximum element.\\nIf A is not empty, intuitively the answer should be the nearest integer to `target / len(A)`.\\n\\nSince we need to return the minimum such integer if there is a tie,\\nif `target / len(A)` has `0.5` we should round down,\\n<br>\\n\\n## **Complexity**\\nTime `O(NlogN)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int findBestValue(int[] A, int target) {\\n        Arrays.sort(A);\\n        int n = A.length, i = 0;\\n        while (i < n && target > A[i] * (n - i)) {\\n            target -= A[i++];\\n        }\\n        if (i == n) return A[n - 1];\\n        int res = target / (n - i);\\n        if (target - res * (n - i) > (res + 1) * (n - i) - target)\\n            res++;\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int findBestValue(vector<int>& A, int target) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), i = 0;\\n        while (i < n && target > A[i] * (n - i))\\n            target -= A[i++];\\n        return i == n ? A[n - 1] : int(round((target - 0.0001) / (n - i)));\\n    }\\n```\\n**Python:**\\n```py\\n    def findBestValue(self, A, target):\\n        A.sort(reverse=1)\\n        maxA = A[0]\\n        while A and target >= A[-1] * len(A):\\n            target -= A.pop()\\n        return int(round((target - 0.0001) / len(A))) if A else maxA\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int findBestValue(int[] A, int target) {\\n        Arrays.sort(A);\\n        int n = A.length, i = 0;\\n        while (i < n && target > A[i] * (n - i)) {\\n            target -= A[i++];\\n        }\\n        if (i == n) return A[n - 1];\\n        int res = target / (n - i);\\n        if (target - res * (n - i) > (res + 1) * (n - i) - target)\\n            res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int findBestValue(vector<int>& A, int target) {\\n        sort(A.begin(), A.end());\\n        int n = A.size(), i = 0;\\n        while (i < n && target > A[i] * (n - i))\\n            target -= A[i++];\\n        return i == n ? A[n - 1] : int(round((target - 0.0001) / (n - i)));\\n    }\\n```\n```py\\n    def findBestValue(self, A, target):\\n        A.sort(reverse=1)\\n        maxA = A[0]\\n        while A and target >= A[-1] * len(A):\\n            target -= A.pop()\\n        return int(round((target - 0.0001) / len(A))) if A else maxA\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463268,
                "title": "java-c-4ms-binary-search-short-readable-code-sorting-solution",
                "content": "# Binary search solution\\nSee also a sorting solution below.\\n\\nThe value we are looking for is somewhere between 1 and maxValue (```m```).\\nNow use Binary search to speed up the process.\\n* go up if the sum is too small\\n* go down if the sum is too big\\n\\nWhen we are done with binary search, ```l``` and ```r``` are equal, but it might happen that we have not exactly reached the target.\\nCheck if ```l-1``` (should get us below the ```target```) leads to the ```sum``` closer to the ```target```.\\n\\nJava, 4ms:\\n```java\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int l, r, mi, s=0, m=-1;\\n        for(int v:arr) { s += v; m=Math.max(m,v); }\\n\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        for(l=1,r=m;l<r;) {\\n            mi=(l+r)/2;\\n            s=0;\\n            for(int v:arr) s += (v>mi)?mi:v;\\n            if(s>=target) r=mi;\\n            else          l=mi+1;\\n        }\\n        // check if we are 1 step off the target \\n        int s1=0,s2=0;\\n        for(int v:arr) {\\n            s1 += (v>l)?(l):v;\\n            s2 += (v>l-1)?(l-1):v;\\n        }\\n        \\n        return (Math.abs(s2-target) <= Math.abs(s1-target)) ? l-1 : l;\\n    }\\n}\\n```\\n\\nC++, 16ms\\n```cpp\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l, r, mi, s=0, m=-1;\\n        for(int v:arr) s += v, m=max(m,v);\\n\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        for(l=1,r=m;l<r;) {\\n            mi=(l+r)/2;\\n            s=0;\\n            for(int v:arr) s += (v>mi)?mi:v;\\n            if(s>=target) r=mi;\\n            else          l=mi+1;\\n        }\\n        // check if we are 1 step off the target \\n        int s1=0,s2=0;\\n        for(int v:arr) s1 += (v>l)?(l):v, s2 += (v>l-1)?(l-1):v;\\n        \\n        return (abs(s2-target) <= abs(s1-target)) ? l-1 : l;\\n    }\\n};\\n```\\n\\n**UPDATE:**\\n# Sorting solution\\n \\nI got comments that sorting solution can be more intuitive. It\\'s maybe shorter but binary search is easier to apply as a pattern (at least for me). \\nWell, sorting leads to O(NLogN) speed while binary search gives O(NLog(Max(A))) so it\\'s similar.\\nHowever, in practice It\\'s slightly slower on given tests. \\n\\nIntuition:\\n  - We will need to replace the highest values with some value ```v```\\n  - ```v``` must be >= the highest value of the array. In other words: ```v >= max(arr)```\\n  - We should pop the highest value from arr while the current result is above the target: \\n   ```while(target < sum + max(arr)*numOfRemoved)```\\n  - Sorting is done to speed up the search for the higest values\\n  - Then we simply calculate ```v``` to replace each removed element and get as close to the ```target``` as possible\\n\\nIn the end of \"pop high values\" process we will split the sorted array in 2 parts:\\n```cpp\\n          Splitted the sorted values to left and right parts:\\n          a,b,c,d   |   X,Y,Z\\n          -------       =====\\n          keep          replace each elem\\n          as is         with v\\n  sum:    =sum-X-Y-Z    =v*numOfElems \\n          left part + right part = target\\n```\\nValues in the left part will stay as is. Their sum is the ```total sum - sum of the removed```.\\nValues in the right part will be replaced with ```v``` and we keep their number in ```removed```.\\n```cpp\\nleft part + right part = target\\nleft part + v*removed  = target\\nv = (target - left part)/removed\\n``` \\nWhen we do the division, ```v``` is rounded down. I check also ```v+1``` to cover the undesired rounding though I\\'m pretty sure that a sophisticated formula can do the same shorter (I prefer simpler things).\\n\\nJava, 5ms\\n```java\\n    public int findBestValue(int[] arr, int target) {\\n        int s=0, m=-1;\\n        for(int v:arr) { s += v; m=Math.max(m,v); }\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        Arrays.sort(arr);\\n        \\n        int removed=0, lastIx=arr.length-1;\\n        while(lastIx>=0 && target < s + removed*arr[lastIx]) {\\n            removed++;\\n            s -= arr[lastIx];\\n            lastIx--;\\n        }\\n        int v=(target-s)/removed; // rounded down\\n        if(Math.abs(target-s-removed*v) <=\\n           Math.abs(target-s-removed*(v+1))) // check v+1 to compensate round down\\n            return v;\\n        return v+1;\\n    }\\n```\\n\\nC++, 24ms\\n```cpp\\n    int findBestValue(vector<int>& arr, int target) {\\n        int s=0, m=-1;\\n        for(int v:arr) s += v, m=max(m,v);\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        sort(arr.begin(),arr.end());\\n        \\n        int removed=0, lastIx=arr.size()-1;\\n        while(lastIx>=0 && target < s + removed*arr[lastIx]) {\\n            removed++;\\n            s -= arr[lastIx];\\n            lastIx--;\\n        }\\n        int v=(target-s)/removed; // rounded down\\n        if(abs(target-s-removed*v) <=\\n           abs(target-s-removed*(v+1))) // check v+1 to compensate round down\\n            return v;\\n        return v+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```m```\n```l```\n```r```\n```l-1```\n```target```\n```sum```\n```target```\n```java\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int l, r, mi, s=0, m=-1;\\n        for(int v:arr) { s += v; m=Math.max(m,v); }\\n\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        for(l=1,r=m;l<r;) {\\n            mi=(l+r)/2;\\n            s=0;\\n            for(int v:arr) s += (v>mi)?mi:v;\\n            if(s>=target) r=mi;\\n            else          l=mi+1;\\n        }\\n        // check if we are 1 step off the target \\n        int s1=0,s2=0;\\n        for(int v:arr) {\\n            s1 += (v>l)?(l):v;\\n            s2 += (v>l-1)?(l-1):v;\\n        }\\n        \\n        return (Math.abs(s2-target) <= Math.abs(s1-target)) ? l-1 : l;\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l, r, mi, s=0, m=-1;\\n        for(int v:arr) s += v, m=max(m,v);\\n\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        for(l=1,r=m;l<r;) {\\n            mi=(l+r)/2;\\n            s=0;\\n            for(int v:arr) s += (v>mi)?mi:v;\\n            if(s>=target) r=mi;\\n            else          l=mi+1;\\n        }\\n        // check if we are 1 step off the target \\n        int s1=0,s2=0;\\n        for(int v:arr) s1 += (v>l)?(l):v, s2 += (v>l-1)?(l-1):v;\\n        \\n        return (abs(s2-target) <= abs(s1-target)) ? l-1 : l;\\n    }\\n};\\n```\n```v```\n```v```\n```v >= max(arr)```\n```while(target < sum + max(arr)*numOfRemoved)```\n```v```\n```target```\n```cpp\\n          Splitted the sorted values to left and right parts:\\n          a,b,c,d   |   X,Y,Z\\n          -------       =====\\n          keep          replace each elem\\n          as is         with v\\n  sum:    =sum-X-Y-Z    =v*numOfElems \\n          left part + right part = target\\n```\n```total sum - sum of the removed```\n```v```\n```removed```\n```cpp\\nleft part + right part = target\\nleft part + v*removed  = target\\nv = (target - left part)/removed\\n```\n```v```\n```v+1```\n```java\\n    public int findBestValue(int[] arr, int target) {\\n        int s=0, m=-1;\\n        for(int v:arr) { s += v; m=Math.max(m,v); }\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        Arrays.sort(arr);\\n        \\n        int removed=0, lastIx=arr.length-1;\\n        while(lastIx>=0 && target < s + removed*arr[lastIx]) {\\n            removed++;\\n            s -= arr[lastIx];\\n            lastIx--;\\n        }\\n        int v=(target-s)/removed; // rounded down\\n        if(Math.abs(target-s-removed*v) <=\\n           Math.abs(target-s-removed*(v+1))) // check v+1 to compensate round down\\n            return v;\\n        return v+1;\\n    }\\n```\n```cpp\\n    int findBestValue(vector<int>& arr, int target) {\\n        int s=0, m=-1;\\n        for(int v:arr) s += v, m=max(m,v);\\n        if(s<=target) return m; // return the max value since we will keep all nums as is\\n\\n        sort(arr.begin(),arr.end());\\n        \\n        int removed=0, lastIx=arr.size()-1;\\n        while(lastIx>=0 && target < s + removed*arr[lastIx]) {\\n            removed++;\\n            s -= arr[lastIx];\\n            lastIx--;\\n        }\\n        int v=(target-s)/removed; // rounded down\\n        if(abs(target-s-removed*v) <=\\n           abs(target-s-removed*(v+1))) // check v+1 to compensate round down\\n            return v;\\n        return v+1;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464153,
                "title": "java-binary-search",
                "content": "```\\npublic int findBestValue(int[] arr, int target) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int a : arr) {\\n            sum += a;\\n            max = Math.max(max, a);\\n        }\\n        if (sum == target) return max;\\n        int min = 0, res = 1,diff = Integer.MAX_VALUE;\\n        // The answer would lie between 0 and maximum value in the array.\\n        while (min <= max) {\\n            int mid = min + (max - min) / 2;\\n            sum = getMutatedSum(arr, mid); \\n            if (sum > target) {\\n                max = mid - 1;\\n            } else {\\n                min = mid + 1;\\n            }\\n            // If current difference is less than diff || current difference==diff but mid < res.(choose the smaller one.)\\n            if (Math.abs(sum - target) < diff || (Math.abs(sum - target) == diff && mid < res)) { \\n                res = mid;\\n                diff = Math.abs(sum - target);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int getMutatedSum(int[] arr, int mid) {\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += (a > mid) ? mid : a;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findBestValue(int[] arr, int target) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int a : arr) {\\n            sum += a;\\n            max = Math.max(max, a);\\n        }\\n        if (sum == target) return max;\\n        int min = 0, res = 1,diff = Integer.MAX_VALUE;\\n        // The answer would lie between 0 and maximum value in the array.\\n        while (min <= max) {\\n            int mid = min + (max - min) / 2;\\n            sum = getMutatedSum(arr, mid); \\n            if (sum > target) {\\n                max = mid - 1;\\n            } else {\\n                min = mid + 1;\\n            }\\n            // If current difference is less than diff || current difference==diff but mid < res.(choose the smaller one.)\\n            if (Math.abs(sum - target) < diff || (Math.abs(sum - target) == diff && mid < res)) { \\n                res = mid;\\n                diff = Math.abs(sum - target);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int getMutatedSum(int[] arr, int mid) {\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += (a > mid) ? mid : a;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463222,
                "title": "java-binary-search-o-nlogk-k-is-the-max-value-in-arr",
                "content": "``` java\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = -1;\\n        for(int a : arr){\\n            max = Math.max(max, a);\\n        }\\n        \\n        int left = 0, right = max;\\n        int diff = target;\\n        int prevValue = max;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            int sum = getSum(arr, mid);\\n            int currentDiff = Math.abs(target - sum);\\n            if(currentDiff < diff){\\n                diff = currentDiff;\\n                prevValue = mid;\\n            }\\n            else if(currentDiff == diff){\\n                prevValue = Math.min(prevValue, mid);\\n            }\\n            if(sum > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return prevValue;\\n    }\\n    \\n    \\n    public int getSum(int[] arr, int value){\\n        int sum = 0;\\n        for(int a : arr){\\n            sum += a > value ? value : a;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = -1;\\n        for(int a : arr){\\n            max = Math.max(max, a);\\n        }\\n        \\n        int left = 0, right = max;\\n        int diff = target;\\n        int prevValue = max;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            int sum = getSum(arr, mid);\\n            int currentDiff = Math.abs(target - sum);\\n            if(currentDiff < diff){\\n                diff = currentDiff;\\n                prevValue = mid;\\n            }\\n            else if(currentDiff == diff){\\n                prevValue = Math.min(prevValue, mid);\\n            }\\n            if(sum > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return prevValue;\\n    }\\n    \\n    \\n    public int getSum(int[] arr, int value){\\n        int sum = 0;\\n        for(int a : arr){\\n            sum += a > value ? value : a;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228048,
                "title": "c-binary-search-easy-and-short-code",
                "content": "```\\nint diff(int mid, vector<int>& arr, int target)\\n    {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++)\\n            sum += min(mid, arr[i]);\\n        \\n        return abs(target - sum);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        int s = 0;\\n        int e = target;\\n        \\n        while(s < e)\\n        {\\n            int mid = s + (e - s)/2;\\n            if(diff(mid, arr, target) <= diff(mid + 1, arr, target))\\n                e = mid;\\n            else\\n                s = mid + 1;\\n        }\\n        \\n        return s;\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint diff(int mid, vector<int>& arr, int target)\\n    {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++)\\n            sum += min(mid, arr[i]);\\n        \\n        return abs(target - sum);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        int s = 0;\\n        int e = target;\\n        \\n        while(s < e)\\n        {\\n            int mid = s + (e - s)/2;\\n            if(diff(mid, arr, target) <= diff(mid + 1, arr, target))\\n                e = mid;\\n            else\\n                s = mid + 1;\\n        }\\n        \\n        return s;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463586,
                "title": "python3-sort-scan",
                "content": "Algorithm:\\nSort the array in ascending order. \\nAt each index `i`, compute the value to set `arr[i:]` to so that `sum(arr)` would be closest to `target`. If this value is smaller than `arr[i]`, return it; otherwise, return `arr[-1]`. \\n\\nImplementation (24ms, 100%):\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        s, n = 0, len(arr)\\n        \\n        for i in range(n):\\n            ans = round((target - s)/n)\\n            if ans <= arr[i]: return ans \\n            s += arr[i]\\n            n -= 1\\n            \\n        return arr[-1]\\n```\\n\\nAnalysis:\\nTime complexity `O(NlogN)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        s, n = 0, len(arr)\\n        \\n        for i in range(n):\\n            ans = round((target - s)/n)\\n            if ans <= arr[i]: return ans \\n            s += arr[i]\\n            n -= 1\\n            \\n        return arr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464434,
                "title": "classic-binary-search",
                "content": "```\\n    public int findBestValue(int[] arr, int target) {\\n        int low = 0;\\n        int high = target;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;            \\n            int sum = sum(arr,mid);         \\n            if(sum == target) return mid;\\n            else if(sum < target) low = mid + 1;\\n            else high = mid - 1;\\n            \\n            \\n        }\\n        // at this point, the solution is either low or low - 1;\\n        int first = sum(arr,low);\\n        int second = sum(arr,low-1);\\n        \\n        if(Math.abs(first-target) < Math.abs(second-target)) return low;\\n        \\n        return low-1;\\n    }\\n    \\n    private int sum(int[] arr, int mid){\\n        int sum = 0;\\n        for(int x: arr){\\n            sum += x > mid ? mid : x;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int findBestValue(int[] arr, int target) {\\n        int low = 0;\\n        int high = target;\\n        while(low <= high){\\n            int mid = low + (high-low)/2;            \\n            int sum = sum(arr,mid);         \\n            if(sum == target) return mid;\\n            else if(sum < target) low = mid + 1;\\n            else high = mid - 1;\\n            \\n            \\n        }\\n        // at this point, the solution is either low or low - 1;\\n        int first = sum(arr,low);\\n        int second = sum(arr,low-1);\\n        \\n        if(Math.abs(first-target) < Math.abs(second-target)) return low;\\n        \\n        return low-1;\\n    }\\n    \\n    private int sum(int[] arr, int mid){\\n        int sum = 0;\\n        for(int x: arr){\\n            sum += x > mid ? mid : x;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 532804,
                "title": "python-binary-search-python-really-intuitive",
                "content": "```\\nclass Solution(object):\\n    def getRes(self,arr,t):\\n        nums = [t if num >= t else num for num in arr]\\n        return sum(nums)\\n    \\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        l = 1\\n        h = max(arr)\\n        \\n        while l <= h:\\n            mid = (h-l)//2 + l\\n            curr = self.getRes(arr,mid)\\n            if curr == target:\\n                return mid\\n            elif curr < target:\\n                l = mid+1\\n            else:\\n                h = mid-1\\n        if abs(self.getRes(arr,l) - target) < abs(self.getRes(arr,h) - target):\\n            return l\\n        return h\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getRes(self,arr,t):\\n        nums = [t if num >= t else num for num in arr]\\n        return sum(nums)\\n    \\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        l = 1\\n        h = max(arr)\\n        \\n        while l <= h:\\n            mid = (h-l)//2 + l\\n            curr = self.getRes(arr,mid)\\n            if curr == target:\\n                return mid\\n            elif curr < target:\\n                l = mid+1\\n            else:\\n                h = mid-1\\n        if abs(self.getRes(arr,l) - target) < abs(self.getRes(arr,h) - target):\\n            return l\\n        return h\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253854,
                "title": "c-binary-search-peak-finding-o-nlogk-o-nlogn-logk-logn-prefix-sum",
                "content": "The idea is to use the fact that value `abs(target - valSum)` will be first decreasing and then increasing for val in range [0, 1e5], somewhat similar to below graph:\\n<p>*</p>\\n<p>&nbsp; &nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp;*</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</p>\\n\\nSo although valSum keep incresing for increase in val, the `abs(target - valSum)` will have minima as shown above. Using the above observation we can use standard peak finding algorithm using binary search(in this case we can because there is only one global and local minima).\\n\\n**Reference problem**: [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\\n\\n\\n    int check(int val, vector<int>& arr, int target) {\\n        int valSum = 0;\\n        for(auto ele: arr) {\\n            valSum += min(val, ele);\\n        }\\n        \\n        return abs(valSum - target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int low = 0, high = 1e5 + 2;\\n        \\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(check(mid, arr, target) > check(mid + 1, arr, target))\\n                low = mid + 1;\\n\\n            else \\n                high = mid;\\n        }\\n        \\n        return low;\\n    }\\n----------------------------------------------------------------------------\\n<br>\\n\\n**Optimisation**\\n\\t\\nTime complexity can be further improved to O(nlogn + logklogn) by sorting the array and using prefix sum.\\nHere we can improve complexity of check method from O(n) to O(logn) by binary searching/upperbound on the val in arr and using it to get index for prefix array whose elements will be less than val i.e. \"*binary search within binary search*\".\\n\\n    vector<int> pre;\\n    \\n    int check(int val, vector<int>& arr, int target) {\\n        int valSum = 0;\\n        int id = upper_bound(arr.begin(), arr.end(), val) - arr.begin() - 1;\\n        if(id > -1)\\n            valSum = pre[id];\\n        valSum += val*((int)arr.size() - (id + 1));\\n        \\n        return abs(valSum - target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        pre = arr;\\n        for(int i = 1; i < pre.size(); i++)\\n            pre[i] +=pre[i - 1];\\n        \\n        int low = 0, high = 1e5 + 2;\\n        \\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(check(mid, arr, target) > check(mid + 1, arr, target))\\n                low = mid + 1;\\n\\n            else \\n                high = mid;\\n        }\\n        \\n        return low;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "The idea is to use the fact that value `abs(target - valSum)` will be first decreasing and then increasing for val in range [0, 1e5], somewhat similar to below graph:\\n<p>*</p>\\n<p>&nbsp; &nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp;*</p>\\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^</p>\\n\\nSo although valSum keep incresing for increase in val, the `abs(target - valSum)` will have minima as shown above. Using the above observation we can use standard peak finding algorithm using binary search(in this case we can because there is only one global and local minima).\\n\\n**Reference problem**: [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\\n\\n\\n    int check(int val, vector<int>& arr, int target) {\\n        int valSum = 0;\\n        for(auto ele: arr) {\\n            valSum += min(val, ele);\\n        }\\n        \\n        return abs(valSum - target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int low = 0, high = 1e5 + 2;\\n        \\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(check(mid, arr, target) > check(mid + 1, arr, target))\\n                low = mid + 1;\\n\\n            else \\n                high = mid;\\n        }\\n        \\n        return low;\\n    }\\n----------------------------------------------------------------------------\\n<br>\\n\\n**Optimisation**\\n\\t\\nTime complexity can be further improved to O(nlogn + logklogn) by sorting the array and using prefix sum.\\nHere we can improve complexity of check method from O(n) to O(logn) by binary searching/upperbound on the val in arr and using it to get index for prefix array whose elements will be less than val i.e. \"*binary search within binary search*\".\\n\\n    vector<int> pre;\\n    \\n    int check(int val, vector<int>& arr, int target) {\\n        int valSum = 0;\\n        int id = upper_bound(arr.begin(), arr.end(), val) - arr.begin() - 1;\\n        if(id > -1)\\n            valSum = pre[id];\\n        valSum += val*((int)arr.size() - (id + 1));\\n        \\n        return abs(valSum - target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        pre = arr;\\n        for(int i = 1; i < pre.size(); i++)\\n            pre[i] +=pre[i - 1];\\n        \\n        int low = 0, high = 1e5 + 2;\\n        \\n        while(low < high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(check(mid, arr, target) > check(mid + 1, arr, target))\\n                low = mid + 1;\\n\\n            else \\n                high = mid;\\n        }\\n        \\n        return low;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 470114,
                "title": "c-binary-search-get-the-lowest-point",
                "content": "```\\n#include <cmath>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int eval(int m, vector<int>& arr, int target) {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++) {\\n            sum += min(arr[i], m);\\n        }\\n        return abs(sum-target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int l = 0, r = 100001;\\n        while(l<r) {\\n            int m = (l+r)>>1;\\n            if(eval(m, arr, target) <= eval(m+1, arr, target)) r = m;\\n            else l = m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <cmath>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int eval(int m, vector<int>& arr, int target) {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++) {\\n            sum += min(arr[i], m);\\n        }\\n        return abs(sum-target);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int l = 0, r = 100001;\\n        while(l<r) {\\n            int m = (l+r)>>1;\\n            if(eval(m, arr, target) <= eval(m+1, arr, target)) r = m;\\n            else l = m+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 463230,
                "title": "python-binary-search",
                "content": "```python\\ndef findBestValue(arr: List[int], target: int) -> int:\\n\\tdef get_sum(v):\\n\\t\\treturn sum(v if a > v else a for a in arr)\\n\\n\\t# Binary search to find the largest v (as the final lo) \\n\\t# such that the sum is smaller than or equal to target\\n\\tlo, hi = 0, max(arr)\\n\\twhile lo < hi:\\n\\t\\tmid = (lo + hi + 1) // 2\\n\\t\\tif get_sum(mid) <= target:\\n\\t\\t\\tlo = mid\\n\\t\\telse:\\n\\t\\t\\thi = mid - 1\\n\\n\\t# Check if (lo + 1) results in a smaller absolute difference\\n\\t# Note: get_sum(lo) <= target\\n\\t#       get_sum(lo + 1) > target if lo < max(arr)\\n\\tif target - get_sum(lo) <= abs(get_sum(lo + 1) - target):\\n\\t\\treturn lo\\n\\treturn lo + 1\\n```",
                "solutionTags": [],
                "code": "```python\\ndef findBestValue(arr: List[int], target: int) -> int:\\n\\tdef get_sum(v):\\n\\t\\treturn sum(v if a > v else a for a in arr)\\n\\n\\t# Binary search to find the largest v (as the final lo) \\n\\t# such that the sum is smaller than or equal to target\\n\\tlo, hi = 0, max(arr)\\n\\twhile lo < hi:\\n\\t\\tmid = (lo + hi + 1) // 2\\n\\t\\tif get_sum(mid) <= target:\\n\\t\\t\\tlo = mid\\n\\t\\telse:\\n\\t\\t\\thi = mid - 1\\n\\n\\t# Check if (lo + 1) results in a smaller absolute difference\\n\\t# Note: get_sum(lo) <= target\\n\\t#       get_sum(lo + 1) > target if lo < max(arr)\\n\\tif target - get_sum(lo) <= abs(get_sum(lo + 1) - target):\\n\\t\\treturn lo\\n\\treturn lo + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1028857,
                "title": "java-easy-understand-binary-search-beats-97",
                "content": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        \\n        int max = 0;\\n        int sum = 0;\\n        \\n        // Find the max value and the upper bound of the seach range.\\n        for(int num : arr) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        // If the sum is smaller than the target the greatest number is the answer.\\n        if(sum <= target) {\\n            return max;\\n        }\\n        \\n        // Prepare the binary search\\n        int left = 0;\\n        int right = sum;\\n        int leftSum = getSum(arr, left);\\n        int rightSum = getSum(arr, right);\\n        \\n        \\n        // Eventually it will narrow down to 2 Consecutive numbers.\\n        // The smaller one\\'s sum is smaller than the target while the greater one\\'s is greater than the target.\\n        // Unless we locate a middle value\\'s sum is equal to target.\\n        while(Math.abs(left - right) != 1) {\\n            \\n            int middle = left + (right - left) / 2;\\n            int midSum = getSum(arr, middle);\\n            \\n            if(midSum < target) {\\n                left = middle;\\n                leftSum = midSum;\\n            } else if(midSum > target) {\\n                right = middle;\\n                rightSum = midSum;\\n            } else {\\n                return middle;\\n            }\\n        }\\n        \\n        // Determine which one is closer to the target.\\n        if(Math.abs(leftSum - target) <= Math.abs(rightSum - target)) {\\n            return left;\\n        } else {\\n            return right;\\n        }\\n        \\n    }\\n    \\n    // Get the sum of the chosen number\\n    private int getSum(int[] arr, int number) {\\n        int sum = 0;\\n        \\n        for(int num : arr) {\\n            sum += Math.min(num, number);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        \\n        int max = 0;\\n        int sum = 0;\\n        \\n        // Find the max value and the upper bound of the seach range.\\n        for(int num : arr) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        // If the sum is smaller than the target the greatest number is the answer.\\n        if(sum <= target) {\\n            return max;\\n        }\\n        \\n        // Prepare the binary search\\n        int left = 0;\\n        int right = sum;\\n        int leftSum = getSum(arr, left);\\n        int rightSum = getSum(arr, right);\\n        \\n        \\n        // Eventually it will narrow down to 2 Consecutive numbers.\\n        // The smaller one\\'s sum is smaller than the target while the greater one\\'s is greater than the target.\\n        // Unless we locate a middle value\\'s sum is equal to target.\\n        while(Math.abs(left - right) != 1) {\\n            \\n            int middle = left + (right - left) / 2;\\n            int midSum = getSum(arr, middle);\\n            \\n            if(midSum < target) {\\n                left = middle;\\n                leftSum = midSum;\\n            } else if(midSum > target) {\\n                right = middle;\\n                rightSum = midSum;\\n            } else {\\n                return middle;\\n            }\\n        }\\n        \\n        // Determine which one is closer to the target.\\n        if(Math.abs(leftSum - target) <= Math.abs(rightSum - target)) {\\n            return left;\\n        } else {\\n            return right;\\n        }\\n        \\n    }\\n    \\n    // Get the sum of the chosen number\\n    private int getSum(int[] arr, int number) {\\n        int sum = 0;\\n        \\n        for(int num : arr) {\\n            sum += Math.min(num, number);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809821,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhey every one, i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search this question is the part of that playlist:\\nhttps://youtu.be/jbiDsInyTwA\\n\\n\\nPlaylist link: \\nhttps://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int map_fun(int val, vector<int> & arr,int target){\\n        int sum=0;\\n        for(auto num:arr){\\n            sum+= min(num,val);\\n        }\\n        return abs(sum-target);\\n    }\\n    bool predicate(int m, vector<int> & arr,int target){\\n        return map_fun(m,arr,target) <=map_fun(m+1,arr,target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0;\\n        int r=*max_element(arr.begin(), arr.end());\\n\\n        while(l<r){\\n            int m=l+ (r-l)/2;\\n            if(predicate(m,arr,target)){\\n                r=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int map_fun(int val, vector<int> & arr,int target){\\n        int sum=0;\\n        for(auto num:arr){\\n            sum+= min(num,val);\\n        }\\n        return abs(sum-target);\\n    }\\n    bool predicate(int m, vector<int> & arr,int target){\\n        return map_fun(m,arr,target) <=map_fun(m+1,arr,target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0;\\n        int r=*max_element(arr.begin(), arr.end());\\n\\n        while(l<r){\\n            int m=l+ (r-l)/2;\\n            if(predicate(m,arr,target)){\\n                r=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569251,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    int find(int mid,vector<int>&arr,int target)\\n    {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]>=mid)\\n                sum+=mid;\\n            else\\n                sum+=arr[i];\\n        }\\n        return abs(sum-target);\\n    }\\npublic:\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        int low=0;\\n        int high=1e8;\\n        sort(arr.begin(),arr.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)>>1;\\n            \\n            int e1=find(mid,arr,target);\\n            int e2=find(mid+1,arr,target);\\n            \\n            if(e1<=e2)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity : O ( nlogn ) \\nSpace Complexity : O ( 1 ) \\n\\n\\n**Please upvote if you found it helpful.**\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int find(int mid,vector<int>&arr,int target)\\n    {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]>=mid)\\n                sum+=mid;\\n            else\\n                sum+=arr[i];\\n        }\\n        return abs(sum-target);\\n    }\\npublic:\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        int low=0;\\n        int high=1e8;\\n        sort(arr.begin(),arr.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)>>1;\\n            \\n            int e1=find(mid,arr,target);\\n            int e2=find(mid+1,arr,target);\\n            \\n            if(e1<=e2)\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337622,
                "title": "c-simple-and-short-solution-7-lines-no-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            \\n            if (arr[i] * (n-i) >= target) \\n                return int(round((target - 0.0001) / (n - i)));\\n            \\n            target -= arr[i];\\n        }\\n        \\n        return arr[n-1];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            \\n            if (arr[i] * (n-i) >= target) \\n                return int(round((target - 0.0001) / (n - i)));\\n            \\n            target -= arr[i];\\n        }\\n        \\n        return arr[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231230,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& arr,int k)\\n    {\\n        int sum=0;\\n        for(auto x:arr)\\n        {\\n            if(x<=k)\\n                sum+=x;\\n            else\\n                sum+=k;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) \\n    {\\n        int i=0,j=*max_element(arr.begin(),arr.end());\\n        int res=INT_MAX,diff=INT_MAX;\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            int sum=find(arr,mid);\\n            int d=abs(sum-target);\\n            if(d<diff || (d==diff && mid<res))\\n            {\\n                res=mid;diff=d;\\n            }\\n            if(sum<target)\\n                i=mid+1;\\n            else\\n                j=mid-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& arr,int k)\\n    {\\n        int sum=0;\\n        for(auto x:arr)\\n        {\\n            if(x<=k)\\n                sum+=x;\\n            else\\n                sum+=k;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) \\n    {\\n        int i=0,j=*max_element(arr.begin(),arr.end());\\n        int res=INT_MAX,diff=INT_MAX;\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            int sum=find(arr,mid);\\n            int d=abs(sum-target);\\n            if(d<diff || (d==diff && mid<res))\\n            {\\n                res=mid;diff=d;\\n            }\\n            if(sum<target)\\n                i=mid+1;\\n            else\\n                j=mid-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749333,
                "title": "python-solution-with-video-explanation",
                "content": "[https://www.youtube.com/watch?v=j0KejYpI_Mc&feature=youtu.be]\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        length = len(arr)\\n        \\n        for x in range(length):\\n            sol = round(target / length)\\n            if arr[x] >= sol:\\n                return sol\\n            target -= arr[x]\\n            length -= 1\\n        \\n        return arr[-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        length = len(arr)\\n        \\n        for x in range(length):\\n            sol = round(target / length)\\n            if arr[x] >= sol:\\n                return sol\\n            target -= arr[x]\\n            length -= 1\\n        \\n        return arr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359402,
                "title": "very-easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991288,
                "title": "java-binary-search",
                "content": "``` java\\npublic int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int left = 0, right = arr[arr.length - 1];\\n        int minDifference = Integer.MAX_VALUE, result = 0;\\n\\n        while (left <= right) {\\n            int middle = (left + right) / 2;\\n            int sum = sumAfterChanges(arr, middle);\\n            if (sum > target)\\n                right = middle - 1;\\n            else\\n                left = middle + 1;\\n\\n            if ((Math.abs(sum - target) < minDifference) || (Math.abs(sum - target) == minDifference && middle < result)) {\\n                minDifference = Math.abs(sum - target);\\n                result = middle;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int sumAfterChanges(int[] array, int value) {\\n        int sum = 0;\\n        for (int number : array) {\\n            sum += Math.min(number, value);\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "``` java\\npublic int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int left = 0, right = arr[arr.length - 1];\\n        int minDifference = Integer.MAX_VALUE, result = 0;\\n\\n        while (left <= right) {\\n            int middle = (left + right) / 2;\\n            int sum = sumAfterChanges(arr, middle);\\n            if (sum > target)\\n                right = middle - 1;\\n            else\\n                left = middle + 1;\\n\\n            if ((Math.abs(sum - target) < minDifference) || (Math.abs(sum - target) == minDifference && middle < result)) {\\n                minDifference = Math.abs(sum - target);\\n                result = middle;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int sumAfterChanges(int[] array, int value) {\\n        int sum = 0;\\n        for (int number : array) {\\n            sum += Math.min(number, value);\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192814,
                "title": "c-binary-search-8-ms-faster-than-100",
                "content": "```\\n//low = 0  and high is going to be max element from the array\\n//It is monotonically increasing fn. \\n//Predicate is going to be FFFF...TTTT... so we can use Binary search;\\n\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int low = 0; \\n        int high = INT_MIN;\\n        for(auto i: arr){\\n            high = max(high, i);\\n        }\\n        \\n        int mid;\\n        int sum;\\n        while(low < high){\\n            sum = 0; \\n            mid = low + (high-low)/2;\\n            \\n            for(auto i: arr){\\n                if(i > mid){\\n                    sum += mid;\\n                    continue;\\n                }\\n                sum += i;\\n            }\\n            \\n            if(sum < target)\\n                low = mid+1;\\n            else\\n                high = mid;\\n        }\\n        \\n        int sum1 = 0;\\n        sum = 0;\\n   \\n        for(auto i: arr){\\n            if(i > low-1){\\n                sum += low-1;\\n                continue;\\n            }\\n            sum += i;\\n        }\\n        \\n        \\n        for(auto i: arr){\\n            if(i > low){\\n                sum1 += low;\\n                continue;\\n            }\\n            sum1 += i;\\n        }\\n\\n        \\n        sum = abs(target - sum);\\n        sum1 = abs(target - sum1);\\n        \\n        return (sum <= sum1)?(low-1):low;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n//low = 0  and high is going to be max element from the array\\n//It is monotonically increasing fn. \\n//Predicate is going to be FFFF...TTTT... so we can use Binary search;\\n\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int low = 0; \\n        int high = INT_MIN;\\n        for(auto i: arr){\\n            high = max(high, i);\\n        }\\n        \\n        int mid;\\n        int sum;\\n        while(low < high){\\n            sum = 0; \\n            mid = low + (high-low)/2;\\n            \\n            for(auto i: arr){\\n                if(i > mid){\\n                    sum += mid;\\n                    continue;\\n                }\\n                sum += i;\\n            }\\n            \\n            if(sum < target)\\n                low = mid+1;\\n            else\\n                high = mid;\\n        }\\n        \\n        int sum1 = 0;\\n        sum = 0;\\n   \\n        for(auto i: arr){\\n            if(i > low-1){\\n                sum += low-1;\\n                continue;\\n            }\\n            sum += i;\\n        }\\n        \\n        \\n        for(auto i: arr){\\n            if(i > low){\\n                sum1 += low;\\n                continue;\\n            }\\n            sum1 += i;\\n        }\\n\\n        \\n        sum = abs(target - sum);\\n        sum1 = abs(target - sum1);\\n        \\n        return (sum <= sum1)?(low-1):low;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462840,
                "title": "c-binary-search-on-answer-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We can think of Binary Serach on answer as`target`is given and operations need to be done accordingly.\\n- Used Sort, Prefix-Sum, Binary Search and Upper bound.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Firstly, we calculate prefix sum.\\n- Then, set`low=0`and`high=target` as these are edge conditions and answer will lie between these.\\n- Now, calculate upper bound of`mid=(low+high)/2`which is say`ind`so that elements after this`ind`will be converted to`mid` and so, final`sum`of new array will be`prefix[ind-1]+(mid)*(n-1-ind)`.\\n   (where`(n-1-ind)` is number of elements which are updated).\\n- Also, we maintain`diff` which stores how close the`sum`is to the`target`. \\n- `ans`stores the answer which will be`mid` if minimal of`diff`.\\n- Two conditions exists:\\n   1. If`upper bound`is at end, meaning`mid`is larger than the largest of the array, then`high=mid-1`as going ahead will lead to increase in`diff` which is not required.\\n   2. Else, `low`and`high`and updated based on required conditions.\\n# Complexity\\n- Time complexity:`O(n*log(n))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n=arr.size(), i;\\n        # Prefix Sum\\n        vector<int> presum;\\n        presum.push_back(arr[0]);\\n        for(i=1; i<n; ++i){\\n            presum.push_back(presum[i-1]+arr[i]);\\n        }\\n        int low=0, high=target;\\n        # ans and diff initialized to max value.\\n        int ans=target+1, diff=target+1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            auto ubound=upper_bound(arr.begin(), arr.end(), mid);\\n            if(ubound==arr.end()){\\n                int sum=presum[n-1];\\n                if(abs(target-sum)<diff){\\n                    diff=abs(target-sum);\\n                    ans=mid;\\n                }\\n                if(abs(target-sum)==diff){\\n                    ans=min(ans, mid);\\n                }\\n                # As upper bound is at end, no need to increase value of mid\\n                high=mid-1;\\n            }\\n            else{\\n                int sum;\\n                if(ubound==arr.begin()){\\n                    # Replace all elements of arr with mid.\\n                    sum=n*mid;\\n                }\\n                else{\\n                    int ind=ubound-arr.begin();\\n                    ind--;\\n                    sum=presum[ind]+((n-1-ind)*mid);\\n                }\\n                if(target-sum==0){\\n                    return mid;\\n                }\\n                if(target-sum>0){\\n                    if(target-sum<diff){\\n                        diff=target-sum;\\n                        ans=mid;\\n                    }\\n                    if(target-sum==diff){\\n                        ans=min(ans, mid);\\n                    }\\n                    # As target>sum, we move ahead.\\n                    low=mid+1;\\n                }\\n                else{\\n                    if(sum-target<diff){\\n                        diff=sum-target;\\n                        ans=mid;\\n                    }\\n                    if(sum-target==diff){\\n                        ans=min(ans, mid);\\n                    }\\n                    # As sum>target, we move backwards.\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n=arr.size(), i;\\n        # Prefix Sum\\n        vector<int> presum;\\n        presum.push_back(arr[0]);\\n        for(i=1; i<n; ++i){\\n            presum.push_back(presum[i-1]+arr[i]);\\n        }\\n        int low=0, high=target;\\n        # ans and diff initialized to max value.\\n        int ans=target+1, diff=target+1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            auto ubound=upper_bound(arr.begin(), arr.end(), mid);\\n            if(ubound==arr.end()){\\n                int sum=presum[n-1];\\n                if(abs(target-sum)<diff){\\n                    diff=abs(target-sum);\\n                    ans=mid;\\n                }\\n                if(abs(target-sum)==diff){\\n                    ans=min(ans, mid);\\n                }\\n                # As upper bound is at end, no need to increase value of mid\\n                high=mid-1;\\n            }\\n            else{\\n                int sum;\\n                if(ubound==arr.begin()){\\n                    # Replace all elements of arr with mid.\\n                    sum=n*mid;\\n                }\\n                else{\\n                    int ind=ubound-arr.begin();\\n                    ind--;\\n                    sum=presum[ind]+((n-1-ind)*mid);\\n                }\\n                if(target-sum==0){\\n                    return mid;\\n                }\\n                if(target-sum>0){\\n                    if(target-sum<diff){\\n                        diff=target-sum;\\n                        ans=mid;\\n                    }\\n                    if(target-sum==diff){\\n                        ans=min(ans, mid);\\n                    }\\n                    # As target>sum, we move ahead.\\n                    low=mid+1;\\n                }\\n                else{\\n                    if(sum-target<diff){\\n                        diff=sum-target;\\n                        ans=mid;\\n                    }\\n                    if(sum-target==diff){\\n                        ans=min(ans, mid);\\n                    }\\n                    # As sum>target, we move backwards.\\n                    high=mid-1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277249,
                "title": "c-binary-search-o-nlogn",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int i=0;\\n        int j=*max_element(arr.begin(),arr.end());\\n        int mid, ans, diff=INT_MAX, sum;\\n        while(i<=j){\\n            mid=i+(j-i)/2;\\n\\n            sum=0;\\n            for(int n:arr){\\n                if(n>mid){\\n                    sum+=mid;\\n                }else{\\n                    sum+=n;\\n                }\\n            }\\n\\n            if(diff>abs(sum-target)){\\n                diff=abs(sum-target);\\n                ans=mid;\\n            }else if(diff==abs(sum-target)){\\n                ans=min(ans,mid);\\n            }\\n\\n            if(sum>target){\\n                j=mid-1;\\n            }else if(sum<target){\\n                i=mid+1;\\n            }else{\\n                ans=mid;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int i=0;\\n        int j=*max_element(arr.begin(),arr.end());\\n        int mid, ans, diff=INT_MAX, sum;\\n        while(i<=j){\\n            mid=i+(j-i)/2;\\n\\n            sum=0;\\n            for(int n:arr){\\n                if(n>mid){\\n                    sum+=mid;\\n                }else{\\n                    sum+=n;\\n                }\\n            }\\n\\n            if(diff>abs(sum-target)){\\n                diff=abs(sum-target);\\n                ans=mid;\\n            }else if(diff==abs(sum-target)){\\n                ans=min(ans,mid);\\n            }\\n\\n            if(sum>target){\\n                j=mid-1;\\n            }else if(sum<target){\\n                i=mid+1;\\n            }else{\\n                ans=mid;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268479,
                "title": "easy-solutions-1300-in-java-python-and-c-look-at-once",
                "content": "# Intuition:\\nThe idea is to perform a binary search on the possible values of the answer. Let the answer be x, then we need to find the minimum value of x such that the sum of the modified array is greater than or equal to the target value.\\n# Approach:\\n1. Initialize the range of possible values of x as [0, max(arr)] where max(arr) is the maximum value in the input array arr.\\n2. Perform binary search on the range [lo, hi], where lo and hi are the lower and upper bounds of the range.\\n3. In each iteration of the binary search, calculate the sum of the modified array for the current value of x.\\n4. If the sum is greater than or equal to the target, set the upper bound of the range as the current value of x. Otherwise, set the lower bound of the range as the current value of x + 1.\\n5. After the binary search, calculate the sum of the modified array for the two possible values of x (lo and lo - 1) and return the value of x that minimizes the absolute difference between the sum and the target.\\n# Complexity:\\n- Time complexity: $$O(nlog(max(arr)))$$ where n is the length of the input array and max(arr) is the maximum value in the input array.\\n- Space complexity: $$O(1)$$ since we are only using constant extra space.\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```Python []\\nclass Solution(object):\\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left, right = 1, max(arr)\\n        best_value = 0\\n        min_diff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            total = sum(min(num, mid) for num in arr)\\n            diff = abs(total - target)\\n            \\n            if diff < min_diff:\\n                min_diff = diff\\n                best_value = mid\\n            \\n            if total >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return best_value\\n\\n```\\n``` Java []\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += min(arr[i], lo);\\n            sum2 += min(arr[i], lo - 1);\\n        }\\n        \\n        return abs(sum2 - target) <= abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```Python []\\nclass Solution(object):\\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left, right = 1, max(arr)\\n        best_value = 0\\n        min_diff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            total = sum(min(num, mid) for num in arr)\\n            diff = abs(total - target)\\n            \\n            if diff < min_diff:\\n                min_diff = diff\\n                best_value = mid\\n            \\n            if total >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        \\n        return best_value\\n\\n```\n``` Java []\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += min(arr[i], lo);\\n            sum2 += min(arr[i], lo - 1);\\n        }\\n        \\n        return abs(sum2 - target) <= abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278006,
                "title": "weeb-does-python-using-binary-search",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef findBestValue(self, arr: List[int], target: int) -> int:\\n\\t\\t\\tarr.sort()\\n\\t\\t\\tlow, high = 0, arr[-1]\\n\\t\\t\\tmemo = {}\\n\\t\\t\\twhile low<=high:\\n\\t\\t\\t\\tmid = low + (high-low) // 2\\n\\t\\t\\t\\tcount=0\\n\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tif arr[i]>mid:\\n\\t\\t\\t\\t\\t\\tcount+= mid * (len(arr)-i)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\telse: count+=arr[i]\\n\\n\\t\\t\\t\\tif count == target:\\n\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\tif count < target:\\n\\t\\t\\t\\t\\tlow = mid + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thigh = mid - 1 \\n\\n\\t\\t\\t\\tmemo[mid] = abs(count-target)\\n\\n\\t\\t\\treturn min(sorted(zip(memo.values(), memo.keys())))[1]\\n\\nAight coders, take a break, its time to watch some anime\\nCheck out **Hunter X Hunter**\\n\\n# Episodes: 148\\n# Genre: Action, Adventure, Shounen, Super Power\\n\\nClassic shounen, I highly recommend this if u are a shounen lover\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n\\t\\tdef findBestValue(self, arr: List[int], target: int) -> int:\\n\\t\\t\\tarr.sort()\\n\\t\\t\\tlow, high = 0, arr[-1]\\n\\t\\t\\tmemo = {}",
                "codeTag": "Java"
            },
            {
                "id": 1048694,
                "title": "java-count-sort-solution-time-space-o-max-element-in-array",
                "content": "Creating two array frequency and prefixSum.\\n\\nTime & Space complexity : O(Max element in Array)\\n\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int high=0;\\n        for(int i: arr) high=Math.max(high,i);\\n        int[] frq=new int[high+1];\\n        for(int i=0;i<arr.length;i++){\\n            frq[arr[i]]++;\\n        }\\n        for(int i=1;i<=high;i++){\\n            frq[i]=frq[i]+frq[i-1];\\n        }\\n       int[] prefixSum=new int[high+1];\\n        for(int i=0;i<arr.length;i++){\\n            prefixSum[arr[i]]=arr[i];\\n        }\\n        for(int i=1;i<=high;i++){\\n            prefixSum[i]=prefixSum[i]+prefixSum[i-1];\\n        }\\n        int curdiff=target;\\n        for(int i=1;i<=high;i++){\\n            int temp=prefixSum[i]+(frq[high]-frq[i])*i;\\n            int diff=Math.abs(target-temp);\\n            if(diff>=curdiff) return i-1;\\n            else{\\n                curdiff=diff;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int high=0;\\n        for(int i: arr) high=Math.max(high,i);\\n        int[] frq=new int[high+1];\\n        for(int i=0;i<arr.length;i++){\\n            frq[arr[i]]++;\\n        }\\n        for(int i=1;i<=high;i++){\\n            frq[i]=frq[i]+frq[i-1];\\n        }\\n       int[] prefixSum=new int[high+1];\\n        for(int i=0;i<arr.length;i++){\\n            prefixSum[arr[i]]=arr[i];\\n        }\\n        for(int i=1;i<=high;i++){\\n            prefixSum[i]=prefixSum[i]+prefixSum[i-1];\\n        }\\n        int curdiff=target;\\n        for(int i=1;i<=high;i++){\\n            int temp=prefixSum[i]+(frq[high]-frq[i])*i;\\n            int diff=Math.abs(target-temp);\\n            if(diff>=curdiff) return i-1;\\n            else{\\n                curdiff=diff;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824010,
                "title": "java-o-nlogn-without-binary-search",
                "content": "```\\n\\tpublic int findBestValue(int[] arr, int target) {\\n        int n = arr.length, sum = 0;\\n        Arrays.sort(arr);\\n        for (int i = 0; i < n; i++) {\\n            int x = target/(n-i);\\n            if (target-x*(n-i) > (x+1)*(n-i)-target) x = x+1;\\n            if (x < arr[i]) return x;\\n            target -= arr[i];\\n        }\\n        return arr[n-1];\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int findBestValue(int[] arr, int target) {\\n        int n = arr.length, sum = 0;\\n        Arrays.sort(arr);\\n        for (int i = 0; i < n; i++) {\\n            int x = target/(n-i);\\n            if (target-x*(n-i) > (x+1)*(n-i)-target) x = x+1;\\n            if (x < arr[i]) return x;\\n            target -= arr[i];\\n        }\\n        return arr[n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 736404,
                "title": "python-0-nlog-n-solution-using-prefix-sum-and-binary-search",
                "content": "```\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        \\n        n = len(arr)\\n        arr.sort()\\n        \\n        def check(sum_array, num):\\n            \\n            index = bisect_right(arr, num)\\n            \\n            pre_sum = 0\\n            \\n            if (index-1)>=0:\\n                \\n                pre_sum += sum_array[index-1]\\n                \\n            pre_sum += num*(n-index)\\n            \\n            return pre_sum\\n                \\n        prefix_sum = []\\n        \\n        for i in arr:\\n            \\n            if len(prefix_sum) == 0:\\n                prefix_sum.append(i)\\n                \\n            else:\\n                prefix_sum.append(prefix_sum[-1] + i)\\n                \\n                \\n        low = 0\\n        high = arr[-1]\\n        \\n        min_ans = high\\n        min_diff_seen = abs(target-prefix_sum[-1])\\n        \\n        for i in range(low, high+1):\\n            \\n            ans = check(prefix_sum, i)\\n            \\n            if abs(target-ans)<min_diff_seen:\\n                \\n                min_ans = i\\n                min_diff_seen = abs(target-ans)\\n                \\n        return min_ans\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        \\n        n = len(arr)\\n        arr.sort()\\n        \\n        def check(sum_array, num):\\n            \\n            index = bisect_right(arr, num)\\n            \\n            pre_sum = 0\\n            \\n            if (index-1)>=0:\\n                \\n                pre_sum += sum_array[index-1]\\n                \\n            pre_sum += num*(n-index)\\n            \\n            return pre_sum\\n                \\n        prefix_sum = []\\n        \\n        for i in arr:\\n            \\n            if len(prefix_sum) == 0:\\n                prefix_sum.append(i)\\n                \\n            else:\\n                prefix_sum.append(prefix_sum[-1] + i)\\n                \\n                \\n        low = 0\\n        high = arr[-1]\\n        \\n        min_ans = high\\n        min_diff_seen = abs(target-prefix_sum[-1])\\n        \\n        for i in range(low, high+1):\\n            \\n            ans = check(prefix_sum, i)\\n            \\n            if abs(target-ans)<min_diff_seen:\\n                \\n                min_ans = i\\n                min_diff_seen = abs(target-ans)\\n                \\n        return min_ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 500121,
                "title": "binary-search-nlogn",
                "content": "```\\npublic int findBestValue(int[] arr, int target) {\\n        int s=0;\\n        int lo=0,hi=0;\\n        for(int a:arr)\\n        {    \\n            hi=Math.max(hi,a);\\n            s+=a;\\n        }\\n        if(s<=target) return hi;\\n        \\n        int dif=Integer.MAX_VALUE;\\n        while(lo<hi){\\n            int mid=lo+(hi-lo)/2;\\n            int sum=0;\\n            int diff1=cal(arr,mid,target);\\n            int diff2=cal(arr,mid+1,target);\\n            \\n            if(diff1<=diff2){\\n                hi=mid;\\n            }\\n            else lo=mid+1;\\n        }\\n        return lo;\\n    }\\n    \\n    int cal(int[] arr,int value,int target){\\n        int sum=0;\\n        for(int a:arr)\\n        {\\n            if(a>value) sum+=value;\\n            else sum+=a;\\n        }\\n        return Math.abs(sum-target);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findBestValue(int[] arr, int target) {\\n        int s=0;\\n        int lo=0,hi=0;\\n        for(int a:arr)\\n        {    \\n            hi=Math.max(hi,a);\\n            s+=a;\\n        }\\n        if(s<=target) return hi;\\n        \\n        int dif=Integer.MAX_VALUE;\\n        while(lo<hi){\\n            int mid=lo+(hi-lo)/2;\\n            int sum=0;\\n            int diff1=cal(arr,mid,target);\\n            int diff2=cal(arr,mid+1,target);\\n            \\n            if(diff1<=diff2){\\n                hi=mid;\\n            }\\n            else lo=mid+1;\\n        }\\n        return lo;\\n    }\\n    \\n    int cal(int[] arr,int value,int target){\\n        int sum=0;\\n        for(int a:arr)\\n        {\\n            if(a>value) sum+=value;\\n            else sum+=a;\\n        }\\n        return Math.abs(sum-target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463262,
                "title": "concise-python-binary-search",
                "content": "```python3\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        l, h = 0, max(arr)\\n        def mySum(val):\\n            return sum(min(a, val) for a in arr)\\n        while l < h:\\n            m = (l + h) // 2\\n            if mySum(m) < target:\\n                l = m + 1\\n            else:\\n                h = m\\n        return min(l - 1, l, l + 1, key=lambda x: abs(mySum(x) - target))\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python3\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        l, h = 0, max(arr)\\n        def mySum(val):\\n            return sum(min(a, val) for a in arr)\\n        while l < h:\\n            m = (l + h) // 2\\n            if mySum(m) < target:\\n                l = m + 1\\n            else:\\n                h = m\\n        return min(l - 1, l, l + 1, key=lambda x: abs(mySum(x) - target))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463206,
                "title": "c-simple-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int l = 0, r = 100000;\\n        int ans = -1,minm = INT_MAX;\\n        \\n        while (l < r) {\\n            int mid = l + (r-l+1)/2;\\n            long long int sum = 0;\\n            for (int i = 0; i<n; i++){\\n                if (arr[i] < mid){\\n                    sum += arr[i];\\n                }\\n                else {\\n                    sum += mid;\\n                }\\n            }\\n            long long int diff = abs(target - sum);\\n            if (diff <= minm){\\n                minm = diff;\\n                ans = mid;\\n            }\\n            if (sum >= target){\\n                r = mid;\\n            }\\n            else {\\n                l = mid;\\n            }\\n            if (l+1 == r){\\n                sum = 0;\\n                for (int i = 0; i<n; i++){\\n                    if (arr[i] < l){\\n                        sum += arr[i];\\n                    }\\n                    else {\\n                        sum += l;\\n                    }\\n                }\\n                diff = abs(target - sum);\\n                if (diff <= minm){\\n                    minm = diff;\\n                    ans = l;\\n                }\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int l = 0, r = 100000;\\n        int ans = -1,minm = INT_MAX;\\n        \\n        while (l < r) {\\n            int mid = l + (r-l+1)/2;\\n            long long int sum = 0;\\n            for (int i = 0; i<n; i++){\\n                if (arr[i] < mid){\\n                    sum += arr[i];\\n                }\\n                else {\\n                    sum += mid;\\n                }\\n            }\\n            long long int diff = abs(target - sum);\\n            if (diff <= minm){\\n                minm = diff;\\n                ans = mid;\\n            }\\n            if (sum >= target){\\n                r = mid;\\n            }\\n            else {\\n                l = mid;\\n            }\\n            if (l+1 == r){\\n                sum = 0;\\n                for (int i = 0; i<n; i++){\\n                    if (arr[i] < l){\\n                        sum += arr[i];\\n                    }\\n                    else {\\n                        sum += l;\\n                    }\\n                }\\n                diff = abs(target - sum);\\n                if (diff <= minm){\\n                    minm = diff;\\n                    ans = l;\\n                }\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549536,
                "title": "python-easy-to-read-and-understand-binary-search",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        start, end = 0, max(arr)\\n        res, mn, val = float(\"inf\"), float(\"inf\"), -1\\n        while start <= end:\\n            mid = (start + end)//2\\n            sums = 0\\n            for i in arr:\\n                sums += min(mid, i)\\n            val = abs(sums-target)\\n            if val == mn:\\n                res = min(res, mid)\\n            if val < mn:\\n                mn = val\\n                res = mid\\n            if sums >= target:\\n                end = mid-1\\n            else:\\n                start = mid+1\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        start, end = 0, max(arr)\\n        res, mn, val = float(\"inf\"), float(\"inf\"), -1\\n        while start <= end:\\n            mid = (start + end)//2\\n            sums = 0\\n            for i in arr:\\n                sums += min(mid, i)\\n            val = abs(sums-target)\\n            if val == mn:\\n                res = min(res, mid)\\n            if val < mn:\\n                mn = val\\n                res = mid\\n            if sums >= target:\\n                end = mid-1\\n            else:\\n                start = mid+1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2331504,
                "title": "c-o-nlogn-binary-search-solution-97-faster",
                "content": "\\nclass Solution {\\npublic:\\n    \\n    int fun(int m, vector<int>& arr){\\n       int sum = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] >= m)\\n                sum += m;\\n            else \\n                sum += arr[i];\\n        }\\n        return sum;\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        \\n        int l = 0, h = *max_element(arr.begin(),arr.end());\\n        \\n        pair<int,int> left, right;\\n        \\n        left.second = right.second = INT_MAX;\\n        while(l <= h){\\n            int m = l + (h-l)/2;\\n            int sum = fun(m,arr);\\n            \\n            if(sum == target)\\n                return m;\\n            else if(sum < target){   // left half\\n                if(abs(target-sum) < left.second){\\n                    left.second = abs(target-sum);\\n                    left.first = m;\\n                }\\n                l = m+1;\\n            }\\n            else{                    // right half\\n                if(abs(target-sum) < right.second){\\n                    right.second = abs(target-sum);\\n                    right.first = m;\\n                }\\n                h = m-1;\\n            }\\n        }\\n        \\n        if(right.second == left.second)\\n            return left.first;\\n        else if(right.second < left.second)\\n            return right.first;\\n        else return left.first;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int fun(int m, vector<int>& arr){\\n       int sum = 0;\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] >= m)\\n                sum += m;\\n            else \\n                sum += arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2172759,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    int len;\\n    public int findBestValue(int[] arr, int target) {\\n        this.len = arr.length;\\n        \\n        for (int i = 0; i < len; i++)\\n            max = Math.max(max, arr[i]);\\n        \\n        int l = 0;\\n        int r = max;\\n        while(l < r){\\n            int mid = l + (r-l) / 2;\\n            \\n            if(check(arr, mid, target) <= check(arr, mid+1, target))\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int check(int[] arr, int value, int target){\\n        int sum = 0;\\n        for(int e : arr){\\n            if(e > value)\\n                sum += value;\\n            else\\n                sum += e;\\n        }\\n        \\n        return Math.abs(sum-target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    int len;\\n    public int findBestValue(int[] arr, int target) {\\n        this.len = arr.length;\\n        \\n        for (int i = 0; i < len; i++)\\n            max = Math.max(max, arr[i]);\\n        \\n        int l = 0;\\n        int r = max;\\n        while(l < r){\\n            int mid = l + (r-l) / 2;\\n            \\n            if(check(arr, mid, target) <= check(arr, mid+1, target))\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int check(int[] arr, int value, int target){\\n        int sum = 0;\\n        for(int e : arr){\\n            if(e > value)\\n                sum += value;\\n            else\\n                sum += e;\\n        }\\n        \\n        return Math.abs(sum-target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158495,
                "title": "java-binary-search-easy-to-understand-intuitive",
                "content": "```\\nclass Solution {\\n    int getArraySum(int[] nums, int value)\\n    {\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] <= value) sum = sum + nums[i];\\n            else sum = sum + value;\\n        }\\n        return sum;\\n    }\\n    public int findBestValue(int[] nums, int target) \\n    {\\n        int mx = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) mx = Math.max(mx, nums[i]); \\n        int low = 0, high = mx;\\n        int upperBestVal = -1, upperBestSum = -1;\\n        int lowerBestVal = -1, lowerBestSum = -1;\\n        //========================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            int newSum = getArraySum(nums, mid);\\n            if (newSum > target) \\n            { \\n                upperBestVal = mid; \\n                upperBestSum = newSum;\\n                high = mid - 1; \\n            }\\n            else if (newSum <= target) \\n            {\\n                lowerBestVal = mid; \\n                lowerBestSum = newSum;\\n                low = mid + 1; \\n            }\\n        }\\n        //===============================================\\n        int lowerDiff = Math.abs(target - lowerBestSum);\\n        int upperDiff = Math.abs(upperBestSum - target);\\n        if (lowerDiff < upperDiff) return lowerBestVal;\\n        else if (upperDiff < lowerDiff) return upperBestVal;\\n        else if (lowerDiff == upperDiff) return Math.min(upperBestVal, lowerBestVal);\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int getArraySum(int[] nums, int value)\\n    {\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (nums[i] <= value) sum = sum + nums[i];\\n            else sum = sum + value;\\n        }\\n        return sum;\\n    }\\n    public int findBestValue(int[] nums, int target) \\n    {\\n        int mx = 0, n = nums.length;\\n        for (int i = 0; i < n; i++) mx = Math.max(mx, nums[i]); \\n        int low = 0, high = mx;\\n        int upperBestVal = -1, upperBestSum = -1;\\n        int lowerBestVal = -1, lowerBestSum = -1;\\n        //========================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            int newSum = getArraySum(nums, mid);\\n            if (newSum > target) \\n            { \\n                upperBestVal = mid; \\n                upperBestSum = newSum;\\n                high = mid - 1; \\n            }\\n            else if (newSum <= target) \\n            {\\n                lowerBestVal = mid; \\n                lowerBestSum = newSum;\\n                low = mid + 1; \\n            }\\n        }\\n        //===============================================\\n        int lowerDiff = Math.abs(target - lowerBestSum);\\n        int upperDiff = Math.abs(upperBestSum - target);\\n        if (lowerDiff < upperDiff) return lowerBestVal;\\n        else if (upperDiff < lowerDiff) return upperBestVal;\\n        else if (lowerDiff == upperDiff) return Math.min(upperBestVal, lowerBestVal);\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809101,
                "title": "c-prefix-sum-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& nums, int target) {\\n        \\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>pref(n,0);\\n        pref[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            pref[i]=nums[i]+pref[i-1];\\n        }\\n        \\n            int mnDiff=INT_MAX;\\n           int diff,sum;\\n            int ans=-1;\\n            for(int i=0;i<=nums[n-1];i++){\\n\\n            int idx=upper_bound(nums.begin(),nums.end(),i)-nums.begin();\\n            \\n             if(idx==0)\\n            sum=n*i;\\n                else if(idx==n)\\n            sum=pref[n-1];\\n                else\\n            sum=pref[idx-1] + i*(n-idx);\\n            \\n            diff=abs(target-sum);\\n                \\n                if(diff<mnDiff){\\n                    mnDiff=diff;\\n                    ans=i;\\n                }\\n        }    \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int findBestValue(vector<int>& nums, int target) {\\n        \\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>pref(n,0);\\n        pref[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            pref[i]=nums[i]+pref[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1121369,
                "title": "javascript-solution-no-binary-search",
                "content": "* Runtime: 84 ms, faster than 89.66% of JavaScript online submissions for Sum of Mutated Array Closest to Target.\\n* Memory Usage: 40.8 MB, less than 43.10% of JavaScript online submissions for Sum of Mutated Array Closest to Target.\\n```\\nvar findBestValue = function(arr, target) {\\n    arr.sort((a, b) => a - b);\\n    let sum = 0;\\n    for (let i = 0; i < arr.length; i++) {\\n        const lengthOfNumsToRight = arr.length - i;\\n        const currentNum = arr[i];\\n        if (sum + (currentNum * lengthOfNumsToRight) > target) {\\n            return Math.ceil((target - sum) / lengthOfNumsToRight - 0.5);\\n        }\\n        sum += currentNum;\\n    }\\n\\n    return arr[arr.length - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findBestValue = function(arr, target) {\\n    arr.sort((a, b) => a - b);\\n    let sum = 0;\\n    for (let i = 0; i < arr.length; i++) {\\n        const lengthOfNumsToRight = arr.length - i;\\n        const currentNum = arr[i];\\n        if (sum + (currentNum * lengthOfNumsToRight) > target) {\\n            return Math.ceil((target - sum) / lengthOfNumsToRight - 0.5);\\n        }\\n        sum += currentNum;\\n    }\\n\\n    return arr[arr.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112038,
                "title": "simple-solution-with-explanation",
                "content": "Success\\n        Details \\n        Runtime: 96 ms, faster than 82.70% of Python3 online submissions for Sum of Mutated Array Closest to Target.\\n     Memory Usage: 15.3 MB, less than 69.58% of Python3 online submissions for Sum of Mutated Array Closest to    Target.\\n\\t \\n\\t \\n\\t \\n\\t\\t# SO BASICALLY THE LOGIC IS FIRSTLY \\'LL SORT THE ARR THAT WE ARE GONNA DIVIDE THE TARGET         WITH LEN(ARR)\\n        # AND CHECK IF THE ARR[I]>= SOL(TARGET /LEN(ARR)) IF THAT IS THE CASE THEN\\n        #WE WILL JUST RETURN THE SOL\\n        #OTHERWISE WE ARE GONNA SUBRATCT ARR[I] FROM TARGET AND DECREASE THE LEN\\n        #AT EACH ITERATION.\\n        #THE REASON WE ARE DOING THIS BEACUSE \\n        #SUPOOSE WE REACHED THE FIRST NO OF ARR i.e. 2 THEN WE WILL SEE IF TARGET=<ARR[I]\\n        #NEITHER 2 NOR 3 IS > SO DECREMENT THE COUNT OF LEN AND SUBRATCT ARR[I] FROM TARGET\\n        #ND AFTER ALL WE DON\\'T GET ANY THING THEN Wnums.sort(E SIMPLY RETURN THE LARGET VAL\\n        \\n        \\n        \\n        arr.sort()\\n        \\n        l = len(arr)\\n        \\n        for i in range(l):\\n            sol = round(target/l)\\n            if arr[i]>=sol:\\n                return sol\\n            else:\\n                target-=arr[i]\\n                l-=1\\n                \\n        return max(arr)\\n        \\n**If you find it helpful please upvote**\\n*Nd if you have any questions or suggestion please comment down. I will reply as soon as possible*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Success\\n        Details \\n        Runtime: 96 ms, faster than 82.70% of Python3 online submissions for Sum of Mutated Array Closest to Target.\\n     Memory Usage: 15.3 MB, less than 69.58% of Python3 online submissions for Sum of Mutated Array Closest to    Target.\\n\\t \\n\\t \\n\\t \\n\\t\\t# SO BASICALLY THE LOGIC IS FIRSTLY \\'LL SORT THE ARR THAT WE ARE GONNA DIVIDE THE TARGET         WITH LEN(ARR)\\n        # AND CHECK IF THE ARR[I]>= SOL(TARGET /LEN(ARR)) IF THAT IS THE CASE THEN\\n        #WE WILL JUST RETURN THE SOL\\n        #OTHERWISE WE ARE GONNA SUBRATCT ARR[I] FROM TARGET AND DECREASE THE LEN\\n        #AT EACH ITERATION.\\n        #THE REASON WE ARE DOING THIS BEACUSE \\n        #SUPOOSE WE REACHED THE FIRST NO OF ARR i.e. 2 THEN WE WILL SEE IF TARGET=<ARR[I]\\n        #NEITHER 2 NOR 3 IS > SO DECREMENT THE COUNT OF LEN AND SUBRATCT ARR[I] FROM TARGET\\n        #ND AFTER ALL WE DON\\'T GET ANY THING THEN Wnums.sort(E SIMPLY RETURN THE LARGET VAL\\n        \\n        \\n        \\n        arr.sort()\\n        \\n        l = len(arr)\\n        \\n        for i in range(l):\\n            sol = round(target/l)\\n            if arr[i]>=sol:\\n                return sol\\n            else:\\n                target-=arr[i]\\n                l-=1\\n                \\n        return max(arr)\\n        \\n**If you find it helpful please upvote**\\n*Nd if you have any questions or suggestion please comment down. I will reply as soon as possible*",
                "codeTag": "Unknown"
            },
            {
                "id": 842528,
                "title": "sort-python",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        \\n        \\n        arr.sort()\\n        \\n        length = len(arr)\\n        \\n        \\n        for i in range(length):\\n            \\n            sol = round(target / length)\\n            \\n            if(arr[i] >= sol):\\n                return sol\\n            \\n            target -= arr[i]\\n            length -=1\\n            \\n        return arr[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        \\n        \\n        arr.sort()\\n        \\n        length = len(arr)\\n        \\n        \\n        for i in range(length):\\n            \\n            sol = round(target / length)\\n            \\n            if(arr[i] >= sol):\\n                return sol\\n            \\n            target -= arr[i]\\n            length -=1\\n            \\n        return arr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478200,
                "title": "amazing-c-easy-to-understand-faster-than-99-5",
                "content": "I can not believe that my solution can work so well!\\nRuntime: 12 ms, faster than 99.52% of C++ online submissions for Sum of Mutated Array Closest to Target.\\nMemory Usage: 9.4 MB, less than 100.00% of C++ online submissions for Sum of Mutated Array Closest to Target.\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int res=0;\\n        int differ=INT_MAX;\\n        int left=0;\\n        int right=INT_MIN;\\n        for(int i=0; i<arr.size();++i){\\n            \\n            right=max(right,arr[i]);\\n            \\n        }\\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            int sum=0;\\n            for(int temp: arr){\\n                int curr=temp>mid?mid:temp;\\n                sum+=curr;\\n            }\\n            if(abs(sum-target)<differ){\\n                res=mid;\\n                differ=abs(sum-target);\\n                \\n            }\\n            if(abs(sum-target)==differ){\\n                res=min(res,mid);\\n            }\\n            if(sum>target){\\n                right=mid-1;\\n            }\\n            else if(sum==target){\\n                right--;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int res=0;\\n        int differ=INT_MAX;\\n        int left=0;\\n        int right=INT_MIN;\\n        for(int i=0; i<arr.size();++i){\\n            \\n            right=max(right,arr[i]);\\n            \\n        }\\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            int sum=0;\\n            for(int temp: arr){\\n                int curr=temp>mid?mid:temp;\\n                sum+=curr;\\n            }\\n            if(abs(sum-target)<differ){\\n                res=mid;\\n                differ=abs(sum-target);\\n                \\n            }\\n            if(abs(sum-target)==differ){\\n                res=min(res,mid);\\n            }\\n            if(sum>target){\\n                right=mid-1;\\n            }\\n            else if(sum==target){\\n                right--;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464286,
                "title": "python-binary-search",
                "content": "```python\\nclass Solution:\\n    def score(self, value):\\n        res = 0\\n        for e in self.arr:\\n            if e > value:\\n                res += value\\n            else:\\n                res += e\\n        return res\\n    \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        self.arr = arr[:]\\n        l, h = 1, max(arr)\\n        while l < h:\\n            m = (l+h) // 2\\n            if self.score(m) < target:\\n                l = m + 1\\n            else:\\n                h = m\\n        #print(l, h)        \\n        s1 = abs(self.score(h-1)-target)\\n        s2 = abs(self.score(h)-target)\\n        if s1 <= s2:\\n            return h-1\\n        return h\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def score(self, value):\\n        res = 0\\n        for e in self.arr:\\n            if e > value:\\n                res += value\\n            else:\\n                res += e\\n        return res\\n    \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        self.arr = arr[:]\\n        l, h = 1, max(arr)\\n        while l < h:\\n            m = (l+h) // 2\\n            if self.score(m) < target:\\n                l = m + 1\\n            else:\\n                h = m\\n        #print(l, h)        \\n        s1 = abs(self.score(h-1)-target)\\n        s2 = abs(self.score(h)-target)\\n        if s1 <= s2:\\n            return h-1\\n        return h\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463713,
                "title": "java-hashmap-linear-solution",
                "content": "```\\nclass Solution {\\n    public int findBestValue(int[] nums, int target) {\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int ans=0;\\n        int dif=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        \\n        int sum=0;int counter=0;\\n        for(int i=0;i<=target;i++){\\n            int total=0;\\n            if(map.containsKey(i)){\\n                counter+=map.get(i);\\n                sum=sum+(i*map.get(i));\\n                total=sum+(nums.length-counter)*i;    \\n            }else{\\n                total=sum+(nums.length-counter)*i; \\n            }\\n            if(dif>Math.abs(total-target)){\\n                dif=Math.abs(total-target);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] nums, int target) {\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int ans=0;\\n        int dif=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        \\n        int sum=0;int counter=0;\\n        for(int i=0;i<=target;i++){\\n            int total=0;\\n            if(map.containsKey(i)){\\n                counter+=map.get(i);\\n                sum=sum+(i*map.get(i));\\n                total=sum+(nums.length-counter)*i;    \\n            }else{\\n                total=sum+(nums.length-counter)*i; \\n            }\\n            if(dif>Math.abs(total-target)){\\n                dif=Math.abs(total-target);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463516,
                "title": "python-3-partitioning-no-binary-search-28ms-beats-100",
                "content": "Partition into greater and less than average* until everything above average or one element left.\\n\\\\* Edit: by average I mean the optimal case when each element is exactly `target / array size` rounded to the nearest integer.\\n\\n```py\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        if n == 1:\\n            return min(arr[0], target)\\n\\n        ravg = round(target / n)\\n        gt = []\\n        next_total = target\\n        for num in arr:\\n            if num <= ravg:\\n                next_total -= num\\n            else:\\n                gt.append(num)\\n        \\n\\t\\t# all elements greater than the average\\n        if next_total == target:\\n            return ravg\\n        \\n        return self.findBestValue(gt, next_total)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        if n == 1:\\n            return min(arr[0], target)\\n\\n        ravg = round(target / n)\\n        gt = []\\n        next_total = target\\n        for num in arr:\\n            if num <= ravg:\\n                next_total -= num\\n            else:\\n                gt.append(num)\\n        \\n\\t\\t# all elements greater than the average\\n        if next_total == target:\\n            return ravg\\n        \\n        return self.findBestValue(gt, next_total)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463377,
                "title": "python-solution-using-sorting",
                "content": "For any number in the array you need to know how many other numbers are bigger than or equal to it.\\nTherefore the first thing to do is sorting the array.\\n\\nFor every index and number in the sorted array:\\n- ```prefix_sum``` contains the sum of all previous numbers.\\n- There are ```suffix_length``` numbers left in the array including the ```current_number```.\\n- A value that would optimally reduce the difference to the target can be calculated if you divide the difference of the target and the ```prefix_sum``` by the ```suffix_length```.\\n- Such a value must be constrained so that it won\\'t be bigger than the ```current_number``` or smaller than the ```previous_number```.\\n- Then the array sum that is obtainable by replacing all numbers starting at the current index by ```value``` is easily calculated by multiplying ```value``` with ```suffix_length``` and adding the ```prefix_sum```.\\n- All that\\'s left to do is to update ```min_difference``` and ```min_value``` if the difference between that sum and the target is smaller than those previously found or if it is equal and ```value``` is smaller.\\n\\nTime complexity: ```O(n log n)``` (for sorting)\\nSpace complexity: ```O(n)``` (for sorting)\\n\\n```python\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        \\n        prefix_sum = 0\\n        suffix_length = len(arr)\\n        \\n        previous_number = 0\\n        min_value = 0\\n        min_difference = math.inf\\n        \\n        for index, current_number in enumerate(arr):\\n            value = round((target - prefix_sum) / suffix_length)\\n            value = max(previous_number, min(current_number, value))\\n            \\n            calculated_sum = prefix_sum + suffix_length * value\\n            \\n            difference = abs(calculated_sum - target)\\n            \\n            if difference < min_difference or (difference == min_difference and value < min_value):\\n                min_difference = difference\\n                min_value = value\\n            \\n            prefix_sum += current_number\\n            suffix_length -= 1\\n            previous_number = current_number\\n            \\n        return min_value\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```prefix_sum```\n```suffix_length```\n```current_number```\n```prefix_sum```\n```suffix_length```\n```current_number```\n```previous_number```\n```value```\n```value```\n```suffix_length```\n```prefix_sum```\n```min_difference```\n```min_value```\n```value```\n```O(n log n)```\n```O(n)```\n```python\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        \\n        prefix_sum = 0\\n        suffix_length = len(arr)\\n        \\n        previous_number = 0\\n        min_value = 0\\n        min_difference = math.inf\\n        \\n        for index, current_number in enumerate(arr):\\n            value = round((target - prefix_sum) / suffix_length)\\n            value = max(previous_number, min(current_number, value))\\n            \\n            calculated_sum = prefix_sum + suffix_length * value\\n            \\n            difference = abs(calculated_sum - target)\\n            \\n            if difference < min_difference or (difference == min_difference and value < min_value):\\n                min_difference = difference\\n                min_value = value\\n            \\n            prefix_sum += current_number\\n            suffix_length -= 1\\n            previous_number = current_number\\n            \\n        return min_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463296,
                "title": "c-sorting-binary-search-o-nlogn-simple-unoptimized-solution",
                "content": "The idea is to find the best answer, and it will always lie in the range [0, max-number]\\n\\nThe approach is to find to try for all possible numbers in the range and for each number, find the count of numbers which are greater than this (using `lower_bound` on sorted array)\\nand then find sum of numbers smaller than this number (using prefix sum). \\n\\nI know that this is an optimized solution and I use extra space(for `prefix-sum`), as well sorting and `binary-search` for every candidate number, but I could think of this only during contest. (But was not able to code it, due to less time).\\nThis problem confused me alot, to come up with a solution fast.\\n\\nTime complexity : `O(n logn)` and Space complexity : `O(n)`\\n\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& A, int target) {\\n        int n = A.size();\\n        if(n == 0)\\n            return 0;\\n        int h = *max_element(A.begin(), A.end());\\n        sort(A.begin(), A.end());\\n        \\n        vector<int> pre(n);\\n        for(int i = 0; i < n; i++)\\n            pre[i] = A[i] + (i - 1 >= 0 ? pre[i - 1] : 0);\\n        \\n        if(pre[n - 1] <= target)\\n            return h;\\n        int ans = h, diff = abs(pre[n - 1] - target);\\n        for(int v = 0; v <= h; v++)\\n        {\\n            int higherThanVid = lower_bound(A.begin(), A.end(), v) - A.begin();\\n            \\n            int lowerThanV = 0;\\n            if(higherThanVid > 0)\\n                lowerThanV = pre[ higherThanVid - 1 ];\\n            int higherSum = (n - higherThanVid)*v;\\n            int nsum = lowerThanV + higherSum;\\n            \\n            if(diff > abs(nsum - target) || (diff == abs(nsum - target) && ans > v))\\n            {\\n                ans = v;\\n                diff = abs(nsum - target);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& A, int target) {\\n        int n = A.size();\\n        if(n == 0)\\n            return 0;\\n        int h = *max_element(A.begin(), A.end());\\n        sort(A.begin(), A.end());\\n        \\n        vector<int> pre(n);\\n        for(int i = 0; i < n; i++)\\n            pre[i] = A[i] + (i - 1 >= 0 ? pre[i - 1] : 0);\\n        \\n        if(pre[n - 1] <= target)\\n            return h;\\n        int ans = h, diff = abs(pre[n - 1] - target);\\n        for(int v = 0; v <= h; v++)\\n        {\\n            int higherThanVid = lower_bound(A.begin(), A.end(), v) - A.begin();\\n            \\n            int lowerThanV = 0;\\n            if(higherThanVid > 0)\\n                lowerThanV = pre[ higherThanVid - 1 ];\\n            int higherSum = (n - higherThanVid)*v;\\n            int nsum = lowerThanV + higherSum;\\n            \\n            if(diff > abs(nsum - target) || (diff == abs(nsum - target) && ans > v))\\n            {\\n                ans = v;\\n                diff = abs(nsum - target);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163387,
                "title": "java-solution-1-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int arrSum = 0;\\n        for(int num: arr) {\\n            arrSum += num;\\n        }\\n        return binarySearch(0, target, arr, target, arrSum);\\n    }\\n\\n    private int getSum(int[] arr, int num) {\\n        int sum = 0;\\n        for(int curr: arr) {\\n            sum += Math.min(curr, num);\\n        }\\n        return sum;\\n    }\\n\\n    private int binarySearch(int begin, int end, int[] arr, int target, int arrSum) {\\n        if(begin == end) {\\n            return begin;\\n        }\\n        if(end == begin + 1) {\\n            int endSum = getSum(arr, end);\\n            int beginSum = getSum(arr, begin);\\n            if(Math.abs(target - beginSum) <= Math.abs(target - endSum)) {\\n                return begin;\\n            }\\n            return end;\\n        }\\n        int medium = begin + (end - begin) / 2;\\n        int mediumSum = getSum(arr, medium);\\n        if(mediumSum >= target || mediumSum == arrSum) {\\n            return binarySearch(begin, medium, arr, target, arrSum);\\n        }\\n        return binarySearch(medium, end, arr, target, arrSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int arrSum = 0;\\n        for(int num: arr) {\\n            arrSum += num;\\n        }\\n        return binarySearch(0, target, arr, target, arrSum);\\n    }\\n\\n    private int getSum(int[] arr, int num) {\\n        int sum = 0;\\n        for(int curr: arr) {\\n            sum += Math.min(curr, num);\\n        }\\n        return sum;\\n    }\\n\\n    private int binarySearch(int begin, int end, int[] arr, int target, int arrSum) {\\n        if(begin == end) {\\n            return begin;\\n        }\\n        if(end == begin + 1) {\\n            int endSum = getSum(arr, end);\\n            int beginSum = getSum(arr, begin);\\n            if(Math.abs(target - beginSum) <= Math.abs(target - endSum)) {\\n                return begin;\\n            }\\n            return end;\\n        }\\n        int medium = begin + (end - begin) / 2;\\n        int mediumSum = getSum(arr, medium);\\n        if(mediumSum >= target || mediumSum == arrSum) {\\n            return binarySearch(begin, medium, arr, target, arrSum);\\n        }\\n        return binarySearch(medium, end, arr, target, arrSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082819,
                "title": "prefix-sum-and-binary-search-with-comments",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int FindBestValue(int[] arr, int target) {\\n        var res = Int32.MaxValue;\\n        var diff = Int32.MaxValue;\\n\\n        var n = arr.Length;\\n        Array.Sort(arr);\\n\\n        var sums = new int[n];\\n        sums[0] = arr[0];\\n\\n        // prefix sum for further calculations\\n        for (var i = 1; i < n; i++) {\\n            sums[i] = arr[i] + sums[i - 1];\\n        }\\n\\n        var lo = 0;\\n        var hi = arr[n - 1];\\n\\n        while (lo <= hi) {\\n            // this is the value we are trying to guess\\n            var num = lo + (hi - lo) / 2;\\n\\n            var left = 0;\\n            var right = n - 1;\\n\\n            // with binary seach we search for index from\\n            // we need to correct sum\\n            while (left < right) {\\n                var mid = left + (right - left) / 2;\\n\\n                if (arr[mid] < num) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid;\\n                }\\n            }\\n\\n            if (arr[left] < num) left++;\\n\\n            // calc the new sum and the difference with target\\n            var sum = ((left == 0) ? 0 : sums[left - 1]) + num * (n - left);\\n            var difference = Math.Abs(sum - target);\\n\\n            // update result depending on the difference\\n            if (difference < diff) {\\n                res = num;\\n            } else if (difference == diff) {\\n                res = Math.Min(res, num);\\n            }\\n\\n            diff = Math.Min(difference, diff);\\n\\n            if (sum < target) {\\n                lo = num + 1;\\n            } else {\\n                hi = num - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindBestValue(int[] arr, int target) {\\n        var res = Int32.MaxValue;\\n        var diff = Int32.MaxValue;\\n\\n        var n = arr.Length;\\n        Array.Sort(arr);\\n\\n        var sums = new int[n];\\n        sums[0] = arr[0];\\n\\n        // prefix sum for further calculations\\n        for (var i = 1; i < n; i++) {\\n            sums[i] = arr[i] + sums[i - 1];\\n        }\\n\\n        var lo = 0;\\n        var hi = arr[n - 1];\\n\\n        while (lo <= hi) {\\n            // this is the value we are trying to guess\\n            var num = lo + (hi - lo) / 2;\\n\\n            var left = 0;\\n            var right = n - 1;\\n\\n            // with binary seach we search for index from\\n            // we need to correct sum\\n            while (left < right) {\\n                var mid = left + (right - left) / 2;\\n\\n                if (arr[mid] < num) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid;\\n                }\\n            }\\n\\n            if (arr[left] < num) left++;\\n\\n            // calc the new sum and the difference with target\\n            var sum = ((left == 0) ? 0 : sums[left - 1]) + num * (n - left);\\n            var difference = Math.Abs(sum - target);\\n\\n            // update result depending on the difference\\n            if (difference < diff) {\\n                res = num;\\n            } else if (difference == diff) {\\n                res = Math.Min(res, num);\\n            }\\n\\n            diff = Math.Min(difference, diff);\\n\\n            if (sum < target) {\\n                lo = num + 1;\\n            } else {\\n                hi = num - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029793,
                "title": "rust-solution-using-ternary-search",
                "content": "\\n# Code\\n```\\nfn helper(arr: &Vec<i32>, target:i32, mid:i32) -> i32 {\\n  let mut temp = 0;\\n  for &v in arr {\\n    temp += v.min(mid);\\n  }\\n  (target-temp).abs()\\n}\\n\\nimpl Solution {\\n    pub fn find_best_value(arr: Vec<i32>, target: i32) -> i32 {\\n      let mut left = 0;\\n      let mut right = 100010;\\n      while left + 2 < right {\\n        let lr1 = (left * 2 + right) / 3;\\n        let lr2 = (left + right * 2) / 3;\\n    \\n        let lr1v = helper(&arr, target, lr1);\\n        let lr2v = helper(&arr, target, lr2);\\n        \\n        if lr1v > lr2v {\\n          left = lr1;\\n        } else {\\n          right = lr2;\\n        }\\n      }\\n\\n      let mut min = i32::max_value();\\n      let mut result = 0;\\n      for mid in (left..=right).rev() {\\n        let v = helper(&arr, target, mid);\\n        if v <= min {\\n          min = v;\\n          result = mid;\\n        }\\n      }\\n\\n      result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn helper(arr: &Vec<i32>, target:i32, mid:i32) -> i32 {\\n  let mut temp = 0;\\n  for &v in arr {\\n    temp += v.min(mid);\\n  }\\n  (target-temp).abs()\\n}\\n\\nimpl Solution {\\n    pub fn find_best_value(arr: Vec<i32>, target: i32) -> i32 {\\n      let mut left = 0;\\n      let mut right = 100010;\\n      while left + 2 < right {\\n        let lr1 = (left * 2 + right) / 3;\\n        let lr2 = (left + right * 2) / 3;\\n    \\n        let lr1v = helper(&arr, target, lr1);\\n        let lr2v = helper(&arr, target, lr2);\\n        \\n        if lr1v > lr2v {\\n          left = lr1;\\n        } else {\\n          right = lr2;\\n        }\\n      }\\n\\n      let mut min = i32::max_value();\\n      let mut result = 0;\\n      for mid in (left..=right).rev() {\\n        let v = helper(&arr, target, mid);\\n        if v <= min {\\n          min = v;\\n          result = mid;\\n        }\\n      }\\n\\n      result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2780488,
                "title": "python-binary-search-approach-explained",
                "content": "We are asked for a \"value\" such that sum of the array after replacing all elements bigger than \"value\" by \"value\" is closest to the \"target\".\\n\\nNow think about it. What can be the closest sum? It can be the \"sum\" that is equal to \"target\", right? Because in that case, the difference will be 0 which is the smallest possible absolute difference.\\n\\n\\tThis is something you will see in test case arr = [2,3,5], target = 10\\n\\t\\n\\tBecause here, the sum of array is already equal to 10. So there is no need to replace any number.\\n\\t\\n\\tIn other words, in this case, the required value is \"5\" because only if value is \"5\" we will get sum = 10\\n\\t\\n\\tIf value is more than \"5\", then too we will get sum = 10 but we are asked for minimum value in case of tie.\\n\\n\\nTo understand it better, here is a graph of the \"sum\" and \"value\" - \\n\\n![image](https://assets.leetcode.com/users/images/22576c83-8cdf-44c3-b3eb-e1f22924bb57_1667635289.4486818.png)\\n\\n\\nIf you see, when value is 1, we get sum = 3 because we have to replace all values in array by 1 as all are greater. \\nBut when value is 2, we get a higher sum. So absolute difference will be smaller than before. \\nAnd so on when we reach value = 5, in that case, sum will be 10 which is the same as target. So this is the required value here.\\n\\n***HENCE, THE MAIN IDEA IS TO TRY TO FIND THE CLOSEST SUM, THAT IS, THE SUM THAT IS EQUAL TO TARGET!***\\n\\nEven if there exists no such value for a test case where sum of array becomes equal to target, then we will get two values that will give us two closest sums.\\n\\nTake a look at this graph as an example - \\n\\n![image](https://assets.leetcode.com/users/images/4f01b43a-d067-427d-a8d3-f5ab2ab38a86_1667635027.957436.png)\\n\\nAs we can see, at value 4, the sum will be 11. And since target = 10, absolute difference = 1\\nBut at value = 3, sum will be 9. And here as well, absolute difference is 1.\\n\\nSo we have a tie here. Hence, in this case, we will go for the minimum of two values, which is 3.\\n\\nHence, the basic idea of the Binary Search approach is that we try to find a value that results in \"sum == target\". If we can find such a value, we can simply return it. If the sum is less than target, we want a bigger sum hence we move to right side of mid. But if sum is greater than target, we want a smaller sum hence we move to left side of mid.\\n\\nAfter binary search ends, if we were not able to find a value that results in \"sum == target\", then  we will get two values that will result in the closest absolute difference that is, \"start\" and \"end\".\\n\\nAnd we have to choose one of them as the output, depending on whether absolute difference of one is smaller than the other.\\n\\n\\n```\\nclass Solution:\\n    \\n    # Helper method to find the sum off array\\n    # After replacing all elements larger than \"x\" with \"x\"\\n    def getSum(self, x, arr, target):\\n        currSum = 0\\n            \\n        for num in arr: currSum += num if num < x else x\\n            \\n        return currSum\\n    \\n    \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        # What is the smallest possible \"value\"? It can be \"1\"\\n        # Since range of values in the array is from 1 to 10^4   \\n        \\n        # And similarly, what is the largest possible \"value\"? \\n        # It is the max value in the array\\n        # because any value more than that will always give the same absolute difference\\n          \\n        # So we try to apply Binary Search on this range of 1 to max(arr) to find the required \"value\"\\n        # Because the range is in a sorted order\\n        start = 1\\n        end = max(arr)\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            # What is this mid?\\n            # This is a possible \"value\"\\n            # So we need to check if after changing all numbers > mid in the array to mid\\n            # The sum is equal to target or not\\n            currSum = self.getSum(mid, arr, target)\\n            \\n            # If the sum we get is same as target, it simply means this is the least possible absolute difference\\n            # Because the absolute difference between sum and target will be \"0\"\\n            # Hence we can simply return \"mid\" value\\n            if currSum == target: return mid\\n            \\n            # If the sum if still less than target, search on right of mid as we want a larger sum\\n            if currSum < target: start = mid + 1\\n                \\n            # If the sum becomes more than target, search on left of mid\\n            else: end = mid - 1\\n        \\n        # Here, \"start\" and \"end\" will be two values that will give us two closest absolute differences\\n        # So, we want the closest of the two values\\n        sum1 = self.getSum(start, arr, target)\\n        sum2 = self.getSum(end, arr, target) \\n        \\n        diff1 = abs(sum1 - target)\\n        diff2 = abs(sum2 - target)\\n        \\n        # Since \"end\" is less than \"start\", this will take care of the condition of a \"tie\"\\n        return start if diff1 < diff2 else end\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Helper method to find the sum off array\\n    # After replacing all elements larger than \"x\" with \"x\"\\n    def getSum(self, x, arr, target):\\n        currSum = 0\\n            \\n        for num in arr: currSum += num if num < x else x\\n            \\n        return currSum\\n    \\n    \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        # What is the smallest possible \"value\"? It can be \"1\"\\n        # Since range of values in the array is from 1 to 10^4   \\n        \\n        # And similarly, what is the largest possible \"value\"? \\n        # It is the max value in the array\\n        # because any value more than that will always give the same absolute difference\\n          \\n        # So we try to apply Binary Search on this range of 1 to max(arr) to find the required \"value\"\\n        # Because the range is in a sorted order\\n        start = 1\\n        end = max(arr)\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            # What is this mid?\\n            # This is a possible \"value\"\\n            # So we need to check if after changing all numbers > mid in the array to mid\\n            # The sum is equal to target or not\\n            currSum = self.getSum(mid, arr, target)\\n            \\n            # If the sum we get is same as target, it simply means this is the least possible absolute difference\\n            # Because the absolute difference between sum and target will be \"0\"\\n            # Hence we can simply return \"mid\" value\\n            if currSum == target: return mid\\n            \\n            # If the sum if still less than target, search on right of mid as we want a larger sum\\n            if currSum < target: start = mid + 1\\n                \\n            # If the sum becomes more than target, search on left of mid\\n            else: end = mid - 1\\n        \\n        # Here, \"start\" and \"end\" will be two values that will give us two closest absolute differences\\n        # So, we want the closest of the two values\\n        sum1 = self.getSum(start, arr, target)\\n        sum2 = self.getSum(end, arr, target) \\n        \\n        diff1 = abs(sum1 - target)\\n        diff2 = abs(sum2 - target)\\n        \\n        # Since \"end\" is less than \"start\", this will take care of the condition of a \"tie\"\\n        return start if diff1 < diff2 else end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768926,
                "title": "solution-with-simple-binary-search-in-c-cpp",
                "content": "# Pease Upvote if you like this solution \\nclass Solution {\\npublic:\\n    bool check(int target, vector<int>& arr, int mid){\\n        \\n        int sum = 0, sizeQ = arr.size();\\n        for(int i=0; i<sizeQ; i++){\\n           if(arr[i] > mid ) sum += mid;\\n            else sum += arr[i];\\n        }\\n        return (sum <= target) ? true : false;\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int low = 0, mid, ans, sizeQ = arr.size(), hi = *max_element(arr.begin(),arr.end());\\n        \\n        while(low <= hi){\\n            mid = low + (hi-low)/2;\\n            \\n            if(check(target, arr, mid)){\\n                ans = mid;\\n                low = mid+1;        \\n            }\\n            else hi = mid-1;\\n        }\\n        \\n        \\n        int s =0, ss=0;\\n        for(int i=0; i<sizeQ; i++)\\n            s+= (arr[i] > ans+1 ) ? ans+1 : arr[i];\\n        \\n         for(int i=0; i<sizeQ; i++)\\n            ss+= (arr[i] > ans) ? ans : arr[i];\\n        \\n        return abs(s-target) < abs(ss-target) ? ans+1 : ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool check(int target, vector<int>& arr, int mid){\\n        \\n        int sum = 0, sizeQ = arr.size();\\n        for(int i=0; i<sizeQ; i++){\\n           if(arr[i] > mid ) sum += mid;\\n            else sum += arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2450965,
                "title": "java-run-o-nlogn-space-o-n",
                "content": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = 0;\\n        for (int n : arr) {\\n            max = Math.max(max, n);\\n        }\\n        int left = 0, right = max;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (check(arr, mid, target) <= check(arr, mid + 1, target)) {\\n                right = mid;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    public int check(int[] arr, int value, int target) {\\n        int sum = 0;\\n        for (int n : arr) {\\n            if (n > value) {\\n                sum += value;\\n            }\\n            else {\\n                sum += n;\\n            }\\n        }\\n        return Math.abs(sum - target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = 0;\\n        for (int n : arr) {\\n            max = Math.max(max, n);\\n        }\\n        int left = 0, right = max;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (check(arr, mid, target) <= check(arr, mid + 1, target)) {\\n                right = mid;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n    public int check(int[] arr, int value, int target) {\\n        int sum = 0;\\n        for (int n : arr) {\\n            if (n > value) {\\n                sum += value;\\n            }\\n            else {\\n                sum += n;\\n            }\\n        }\\n        return Math.abs(sum - target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104180,
                "title": "simple-and-nice-javascript-solution",
                "content": "```\\nfunction findBestValue (A, target, n = A.length) {\\n    // sort first\\n    A.sort((a, b) => a - b)\\n    \\n    // set accumulate\\n    let a = 0\\n\\n    // loop\\n    for (let i in A) {\\n        // difference\\n        const x = (target - a) / (n - i)\\n\\n        // get integer\\n        if (x < A[i]) {\\n            return Math.round(x - 0.1)\\n        }\\n\\n        // sum\\n        a += A[i]\\n    }\\n\\t\\n\\t// result\\n    return A[n - 1]\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findBestValue (A, target, n = A.length) {\\n    // sort first\\n    A.sort((a, b) => a - b)\\n    \\n    // set accumulate\\n    let a = 0\\n\\n    // loop\\n    for (let i in A) {\\n        // difference\\n        const x = (target - a) / (n - i)\\n\\n        // get integer\\n        if (x < A[i]) {\\n            return Math.round(x - 0.1)\\n        }\\n\\n        // sum\\n        a += A[i]\\n    }\\n\\t\\n\\t// result\\n    return A[n - 1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081944,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int eval(vector<int> a,int m,int t)\\n    {\\n        int sum=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            sum+=min(a[i],m);\\n        }\\n        return abs(t-sum);\\n    }\\n    int findBestValue(vector<int>& arr, int target)\\n    {\\n        int low=0,high=100000;\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(eval(arr,mid,target)>eval(arr,mid+1,target))\\n                low=mid+1;\\n            else\\n                high=mid;\\n        }\\n        return low;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int eval(vector<int> a,int m,int t)\\n    {\\n        int sum=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            sum+=min(a[i],m);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1984416,
                "title": "python3-binary-search-o-nlogk",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        l,r=0,max(arr)\\n        while l<r:\\n            mid=(l+r)//2\\n            total=sum(el if el<=mid else mid for el in arr)\\n            if total<target:\\n                l=mid+1\\n            else:\\n                r=mid\\n        a=sum(el if el<=l else l for el in arr)\\n        b=sum(el if el<=l-1 else l-1 for el in arr)\\n        return l if abs(a-target)<abs(b-target) else l-1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        l,r=0,max(arr)\\n        while l<r:\\n            mid=(l+r)//2\\n            total=sum(el if el<=mid else mid for el in arr)\\n            if total<target:\\n                l=mid+1\\n            else:\\n                r=mid\\n        a=sum(el if el<=l else l for el in arr)\\n        b=sum(el if el<=l-1 else l-1 for el in arr)\\n        return l if abs(a-target)<abs(b-target) else l-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969519,
                "title": "c-easy-detail-explanation-binary",
                "content": "Please ask in the comment if you have any doubt in my code. I will try to reply to your query as soon as possible.\\n\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid, vector<int>& a, int x, int& sum, int& val){\\n        int total = 0;\\n        // Calculating sum according to the question\\n        for(auto i:a){\\n            total += min(i, mid);\\n        }\\n        \\n        // Updating closeness and value\\n        if(abs(total-x) < sum){\\n            sum = abs(total - x);\\n            val = mid;\\n        }\\n        \\n        // Because in case of tie we need minimum number\\n        else if(abs(total-x) == sum){\\n            val = min(val, mid);\\n        }\\n        \\n        return (total < x);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        // Calculating initial closeness to target and initial value\\n        int val = 0, sum = 0;\\n        for(auto i:arr){\\n            val = max(val, i);\\n            sum += i;\\n        }\\n        \\n        sum = abs(sum - target);\\n        int low = 0, high = target;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            \\n            // Checking if the sum is less than target and also\\n            // updating closeness(sum) and value(val) accordingly\\n            if(check(mid, arr, target, sum, val)){\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return val;\\n    }\\n};\\n```\\nUpvote if you found my solution helpful :-)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid, vector<int>& a, int x, int& sum, int& val){\\n        int total = 0;\\n        // Calculating sum according to the question\\n        for(auto i:a){\\n            total += min(i, mid);\\n        }\\n        \\n        // Updating closeness and value\\n        if(abs(total-x) < sum){\\n            sum = abs(total - x);\\n            val = mid;\\n        }\\n        \\n        // Because in case of tie we need minimum number\\n        else if(abs(total-x) == sum){\\n            val = min(val, mid);\\n        }\\n        \\n        return (total < x);\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        // Calculating initial closeness to target and initial value\\n        int val = 0, sum = 0;\\n        for(auto i:arr){\\n            val = max(val, i);\\n            sum += i;\\n        }\\n        \\n        sum = abs(sum - target);\\n        int low = 0, high = target;\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            \\n            // Checking if the sum is less than target and also\\n            // updating closeness(sum) and value(val) accordingly\\n            if(check(mid, arr, target, sum, val)){\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936278,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int summation(vector<int> &arr,int mid)\\n    {\\n        int n=arr.size(),sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<=mid)\\n            {\\n                sum+=arr[i];\\n            }\\n            else\\n            {\\n                sum+=mid;\\n            }\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        int low=0;\\n        int high=arr[n-1];\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            int sum=summation(arr,mid);\\n            if(target>sum)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        int sum_high=summation(arr,high);\\n        int sum_low=summation(arr,low);\\n        if(abs(target-sum_high)>abs(target-sum_low))\\n        {\\n            return low;\\n        }\\n        return high;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int summation(vector<int> &arr,int mid)\\n    {\\n        int n=arr.size(),sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]<=mid)\\n            {\\n                sum+=arr[i];\\n            }\\n            else\\n            {\\n                sum+=mid;\\n            }\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        int low=0;\\n        int high=arr[n-1];\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            int sum=summation(arr,mid);\\n            if(target>sum)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        int sum_high=summation(arr,high);\\n        int sum_low=summation(arr,low);\\n        if(abs(target-sum_high)>abs(target-sum_low))\\n        {\\n            return low;\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922344,
                "title": "simple-easy-c-binary-search-nlogn",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int findSum(vector<int> &arr, int mid)\\n    {\\n        int n = arr.size();\\n        int sum = 0;\\n        for (int i = 0; i < n; i++)\\n            if (arr[i] <= mid)\\n                sum += arr[i];\\n            else\\n                sum += mid;\\n        return sum;\\n    }\\n    int findBestValue(vector<int> &arr, int target)\\n    {\\n        int n = arr.size();\\n        int low = 0, high = 0;\\n\\n        for (int i = 0; i < n; i++)\\n            high = max(high, arr[i]);\\n\\n        sort(arr.begin(), arr.end());\\n\\n        while (low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            int sum = findSum(arr, mid);\\n\\n            if (sum >= target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n\\n        int s_low = abs(target - findSum(arr, low));\\n        int s_high = abs(target - findSum(arr, high));\\n\\n        if (s_high <= s_low)\\n            return high;\\n        else\\n            return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int findSum(vector<int> &arr, int mid)\\n    {\\n        int n = arr.size();\\n        int sum = 0;\\n        for (int i = 0; i < n; i++)\\n            if (arr[i] <= mid)\\n                sum += arr[i];\\n            else\\n                sum += mid;\\n        return sum;\\n    }\\n    int findBestValue(vector<int> &arr, int target)\\n    {\\n        int n = arr.size();\\n        int low = 0, high = 0;\\n\\n        for (int i = 0; i < n; i++)\\n            high = max(high, arr[i]);\\n\\n        sort(arr.begin(), arr.end());\\n\\n        while (low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            int sum = findSum(arr, mid);\\n\\n            if (sum >= target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n\\n        int s_low = abs(target - findSum(arr, low));\\n        int s_high = abs(target - findSum(arr, high));\\n\\n        if (s_high <= s_low)\\n            return high;\\n        else\\n            return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848331,
                "title": "binary-search-implementation-with-comments",
                "content": "**[Summary]**\\nThis is my implementation of this challenge using the binary search approach.\\nBreaking up the code in this manner helped me digest and understand the core concept.\\nHope it provides some clarity and guidance to others \\uD83D\\uDE4C\\n\\nBest of luck \\uD83C\\uDF40!\\n\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        // Initialize the binary search parameters with its bounds\\n        int low = 1;\\n        int high = 0;\\n        // O(n): Find the max value\\n        for (int entry : arr) {\\n            high = Math.max(high, entry);\\n        }\\n        // O(nlogn): Use binary search to find the target summation\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            // O(n): Calculate the sum of arrays at every iteration\\n            int sum = sumEntireArray(arr, mid);\\n            if (sum == target) {\\n                System.out.println(\"TARGET SUMMMATION WAS MET\");\\n                return mid;\\n            }\\n            else if (sum < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        \\n        System.out.println(\"NO EXACT SUMMATION WAS FOUND..CHECKING ABSOLUTE DIFFERENCE\");\\n        int lowerBound = target - sumEntireArray(arr, low-1);\\n        int upperBound = sumEntireArray(arr, low) - target;\\n        System.out.println(\"LOWER BOUND: \" + lowerBound + \"\\\\nUPPER BOUND: \" + upperBound);\\n                \\n        if (lowerBound > upperBound) {\\n            System.out.println(\"LOWER SUMMATION IS BETTER!\");\\n            return low;\\n        } else if (upperBound < lowerBound) {\\n            System.out.print(\"UPPER SUMMATION IS BETTER!\");\\n            return low-1;\\n        } else {\\n            System.out.print(\"BOTH SUMMATIONS ARE SAME!\");\\n            return low-1;\\n        }\\n    }\\n    \\n    // A summation helper to calculate the sum managed by a threshold\\n    private int sumEntireArray(int[] arr, int threshold) {\\n        int total_sum = 0;\\n        for (int entry : arr) {\\n            if (entry > threshold) {\\n                total_sum += threshold;\\n            } else {\\n                total_sum += entry;\\n            }\\n        }\\n        return total_sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        // Initialize the binary search parameters with its bounds\\n        int low = 1;\\n        int high = 0;\\n        // O(n): Find the max value\\n        for (int entry : arr) {\\n            high = Math.max(high, entry);\\n        }\\n        // O(nlogn): Use binary search to find the target summation\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            // O(n): Calculate the sum of arrays at every iteration\\n            int sum = sumEntireArray(arr, mid);\\n            if (sum == target) {\\n                System.out.println(\"TARGET SUMMMATION WAS MET\");\\n                return mid;\\n            }\\n            else if (sum < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        \\n        System.out.println(\"NO EXACT SUMMATION WAS FOUND..CHECKING ABSOLUTE DIFFERENCE\");\\n        int lowerBound = target - sumEntireArray(arr, low-1);\\n        int upperBound = sumEntireArray(arr, low) - target;\\n        System.out.println(\"LOWER BOUND: \" + lowerBound + \"\\\\nUPPER BOUND: \" + upperBound);\\n                \\n        if (lowerBound > upperBound) {\\n            System.out.println(\"LOWER SUMMATION IS BETTER!\");\\n            return low;\\n        } else if (upperBound < lowerBound) {\\n            System.out.print(\"UPPER SUMMATION IS BETTER!\");\\n            return low-1;\\n        } else {\\n            System.out.print(\"BOTH SUMMATIONS ARE SAME!\");\\n            return low-1;\\n        }\\n    }\\n    \\n    // A summation helper to calculate the sum managed by a threshold\\n    private int sumEntireArray(int[] arr, int threshold) {\\n        int total_sum = 0;\\n        for (int entry : arr) {\\n            if (entry > threshold) {\\n                total_sum += threshold;\\n            } else {\\n                total_sum += entry;\\n            }\\n        }\\n        return total_sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515242,
                "title": "double-binary-search-logk-logn",
                "content": "```\\nimport bisect\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        if not arr: return abs(target)\\n        \\n        arr.sort()\\n        n = len(arr)\\n        \\n        left, right = 0, arr[-1]\\n        \\n        prefixSum = [0]\\n        \\n        for v in arr:\\n            prefixSum.append(prefixSum[-1] + v)\\n        \\n        start, end = 0, len(arr) - 1\\n        ans = None\\n        minDiff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) >> 1\\n            \\n            left_most = bisect.bisect_left(arr, mid, lo = start, hi= end + 1)\\n            summ = prefixSum[left_most] + (n - left_most) * mid\\n            diff = summ - target\\n            \\n            if abs(diff) < minDiff or (abs(diff) == minDiff and mid < ans):\\n                minDiff = abs(diff)\\n                ans = mid\\n            \\n            if diff == 0:\\n                return mid\\n            elif diff < 0:\\n                left = mid + 1\\n                start = left_most\\n            else:\\n                right = mid - 1\\n                end = left_most\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        if not arr: return abs(target)\\n        \\n        arr.sort()\\n        n = len(arr)\\n        \\n        left, right = 0, arr[-1]\\n        \\n        prefixSum = [0]\\n        \\n        for v in arr:\\n            prefixSum.append(prefixSum[-1] + v)\\n        \\n        start, end = 0, len(arr) - 1\\n        ans = None\\n        minDiff = float(\\'inf\\')\\n        \\n        while left <= right:\\n            mid = (left + right) >> 1\\n            \\n            left_most = bisect.bisect_left(arr, mid, lo = start, hi= end + 1)\\n            summ = prefixSum[left_most] + (n - left_most) * mid\\n            diff = summ - target\\n            \\n            if abs(diff) < minDiff or (abs(diff) == minDiff and mid < ans):\\n                minDiff = abs(diff)\\n                ans = mid\\n            \\n            if diff == 0:\\n                return mid\\n            elif diff < 0:\\n                left = mid + 1\\n                start = left_most\\n            else:\\n                right = mid - 1\\n                end = left_most\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390461,
                "title": "python-average-o-n-solution",
                "content": "If we have the array sorted, we can easily find the solution to be near (target - left_sum)//(num of remaining number).\\n\\nAs a follow up, we actually don\\'t need to sort the entire array, but utilizing the idea of QuickSelect to find that break point.\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        # We use quickSelect to find a pivot at index i, such that:\\n        #   1. left_sum + arr[i]* (len(arr) -i) >= target\\n\\t\\t#   2. All the element on the left of arr are less than the pivot\\n\\t\\t#   3. We can\\'t find next pivot on the left of current pivot that satisfies 1&2\\n        n = len(arr)\\n        def quickSelect(start, end, left_sum):\\n            if start==end:\\n                return (start, left_sum)\\n            i = start\\n            j = end -1\\n            cur_sum = 0\\n            while i<j:\\n                if arr[i+1] < arr[i]:\\n                    cur_sum += arr[i+1]\\n                    tmp = arr[i+1]\\n                    arr[i+1] = arr[i]\\n                    arr[i] = tmp\\n                    i += 1\\n                else:\\n                    tmp = arr[i+1]\\n                    arr[i+1] = arr[j]\\n                    arr[j] = tmp\\n                    j -= 1\\n            if target > left_sum + cur_sum + (len(arr) - i ) * arr[i]:\\n                return quickSelect(i+1, end, left_sum + cur_sum + arr[i])\\n            else:\\n                return quickSelect(start, i, left_sum)\\n        k, left_sum = quickSelect(0, len(arr), 0)\\n        if k == len(arr):\\n            return arr[k-1]\\n        lower = (target - left_sum) // (n - k) \\n        if abs(target - left_sum - (n-k) * lower) <= abs(target- left_sum - (n-k)* (lower+1)):\\n            return lower\\n        else:\\n            return lower+1\\n                    \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        # We use quickSelect to find a pivot at index i, such that:\\n        #   1. left_sum + arr[i]* (len(arr) -i) >= target\\n\\t\\t#   2. All the element on the left of arr are less than the pivot\\n\\t\\t#   3. We can\\'t find next pivot on the left of current pivot that satisfies 1&2\\n        n = len(arr)\\n        def quickSelect(start, end, left_sum):\\n            if start==end:\\n                return (start, left_sum)\\n            i = start\\n            j = end -1\\n            cur_sum = 0\\n            while i<j:\\n                if arr[i+1] < arr[i]:\\n                    cur_sum += arr[i+1]\\n                    tmp = arr[i+1]\\n                    arr[i+1] = arr[i]\\n                    arr[i] = tmp\\n                    i += 1\\n                else:\\n                    tmp = arr[i+1]\\n                    arr[i+1] = arr[j]\\n                    arr[j] = tmp\\n                    j -= 1\\n            if target > left_sum + cur_sum + (len(arr) - i ) * arr[i]:\\n                return quickSelect(i+1, end, left_sum + cur_sum + arr[i])\\n            else:\\n                return quickSelect(start, i, left_sum)\\n        k, left_sum = quickSelect(0, len(arr), 0)\\n        if k == len(arr):\\n            return arr[k-1]\\n        lower = (target - left_sum) // (n - k) \\n        if abs(target - left_sum - (n-k) * lower) <= abs(target- left_sum - (n-k)* (lower+1)):\\n            return lower\\n        else:\\n            return lower+1\\n                    \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338117,
                "title": "c-heap-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int>pi;\\n    int check(int mid ,vector<int>&a)\\n    {\\n        int nq = a.size();\\n        int sum = 0 ;\\n        for(int i = 0 ; i < nq; i++)\\n        {\\n            if(a[i] >= mid)\\n                sum += mid;\\n            else\\n                sum += a[i];\\n        }\\n        return sum;\\n    }\\n\\n    int findBestValue(vector<int>& a, int t) {\\n        int n = a.size();\\n         int max = INT_MIN; \\n        for (int i : a){\\n            if (max <= i)\\n                max = i;\\n        }\\n        priority_queue<pi , vector<pi> , greater<pi>>p;\\n      //      vector<pair<int,int>>p;\\n        int l = 0 ; \\n        int h = max;\\n        int ans,id, tillclose = 1e9;\\n        while(l <= h)\\n        {\\n            int mid = l + (h-l)/2 ;\\n          //  cout<<mid<<\" \";\\n            int sum = check(mid , a ) ;\\n            ans = abs(t - sum);\\n            p.push({ans , mid});\\n            if(sum > t)\\n                h = mid - 1 ;\\n            else\\n                l = mid + 1 ;\\n        }\\n        return p.top().second ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    typedef pair<int,int>pi;\\n    int check(int mid ,vector<int>&a)\\n    {\\n        int nq = a.size();\\n        int sum = 0 ;\\n        for(int i = 0 ; i < nq; i++)\\n        {\\n            if(a[i] >= mid)\\n                sum += mid;\\n            else\\n                sum += a[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1319982,
                "title": "simple-and-easy-intuitive-c-solution-using-binary-search-monotonic-approach",
                "content": "```\\n bool check(vector<int> &arr,int target,int assumevalue){\\n        \\n        int sum=0;\\n        \\n        for(auto x: arr){\\n            \\n            if(x>assumevalue){\\n                sum+=assumevalue;\\n            }\\n            else{\\n                sum+=x;\\n            }\\n        }\\n       \\n        return sum>target;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        //FFFFFFFFFTTTTTT = > here mid =>integer assume value for which we will check for uor conditions,let\\'s do\\n        sort(arr.begin(),arr.end());\\n        \\n        int l=1,r=arr[arr.size() - 1];\\n        \\n        while(r>l){\\n            int mid= l + (r - l)/2;\\n            \\n            if(check(arr,target,mid)){\\n                r=mid;\\n            }\\n            else{\\n                l =  mid + 1;\\n            }\\n        }\\n         \\n          int sum1=0;\\n        \\n        for(auto x: arr){\\n            \\n            if(x>l-1){\\n                sum1+=l - 1;\\n            }\\n            else{ \\n                sum1+=x;\\n            }\\n        }\\n        \\n        int sum2=0;\\n        \\n        \\n        for(auto x: arr){\\n            if(x>l){\\n                sum2+=l;\\n            }\\n            else{\\n                sum2+=x;\\n            }\\n        }\\n        \\n        sum1=abs(target -sum1);\\n        sum2=abs(target- sum2);\\n        \\n        \\n        return sum1>sum2 ? l : l  - 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool check(vector<int> &arr,int target,int assumevalue){\\n        \\n        int sum=0;\\n        \\n        for(auto x: arr){\\n            \\n            if(x>assumevalue){\\n                sum+=assumevalue;\\n            }\\n            else{\\n                sum+=x;\\n            }\\n        }\\n       \\n        return sum>target;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        //FFFFFFFFFTTTTTT = > here mid =>integer assume value for which we will check for uor conditions,let\\'s do\\n        sort(arr.begin(),arr.end());\\n        \\n        int l=1,r=arr[arr.size() - 1];\\n        \\n        while(r>l){\\n            int mid= l + (r - l)/2;\\n            \\n            if(check(arr,target,mid)){\\n                r=mid;\\n            }\\n            else{\\n                l =  mid + 1;\\n            }\\n        }\\n         \\n          int sum1=0;\\n        \\n        for(auto x: arr){\\n            \\n            if(x>l-1){\\n                sum1+=l - 1;\\n            }\\n            else{ \\n                sum1+=x;\\n            }\\n        }\\n        \\n        int sum2=0;\\n        \\n        \\n        for(auto x: arr){\\n            if(x>l){\\n                sum2+=l;\\n            }\\n            else{\\n                sum2+=x;\\n            }\\n        }\\n        \\n        sum1=abs(target -sum1);\\n        sum2=abs(target- sum2);\\n        \\n        \\n        return sum1>sum2 ? l : l  - 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270070,
                "title": "c-o-nlogn-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        // Sum of arr[i] == target\\n        float n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        // 0.0000001 is subsracted to make round(4.5) = 4, bcz we need the smaller int\\n        int avg = round(target/n-0.00000001);\\n        int i=0;\\n        while (i<arr.size() && arr[i]<=avg){\\n            target -= arr[i];\\n            n -= 1;\\n            if (n==0)\\n                return arr[arr.size()-1];\\n            avg = round(target/n-0.00000001);\\n            i++;\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        // Sum of arr[i] == target\\n        float n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        // 0.0000001 is subsracted to make round(4.5) = 4, bcz we need the smaller int\\n        int avg = round(target/n-0.00000001);\\n        int i=0;\\n        while (i<arr.size() && arr[i]<=avg){\\n            target -= arr[i];\\n            n -= 1;\\n            if (n==0)\\n                return arr[arr.size()-1];\\n            avg = round(target/n-0.00000001);\\n            i++;\\n        }\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137723,
                "title": "simple-binary-search-on-answer-solution-using-sum-of-array-floor-and-ceil-technique",
                "content": "```\\n int findBestValue(vector<int>& arr, int target) {\\n        int low=1,high=0,mid,ans1,ans2,n=arr.size(),sum1,sum2,high2;\\n        for(int i=0;i<n;i++) {\\n            high=max(high,arr[i]);\\n        }\\n        high2=high;\\n        while(low<=high) {\\n            mid=low+(high-low)/2;\\n            int sum=0;\\n            for(auto x:arr) {\\n                if(x>mid) sum+=mid;\\n                else sum+=x;\\n            }\\n            if(sum>=target) {\\n                ans1=mid;\\n                sum1=sum;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        low=1;\\n        high=high2;\\n        while(low<=high) {\\n            mid=low+(high-low)/2;\\n            int sum=0;\\n            for(auto x:arr) {\\n                if(x>mid) sum+=mid;\\n                else sum+=x;\\n            }\\n            if(sum<=target) {\\n                ans2=mid;\\n                sum2=sum;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        if(abs(target-sum1)==abs(target-sum2)) return ans2;\\n        return (abs(target-sum1)>abs(target-sum2))?(ans2):(ans1);\\n    }\\n\\t```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n int findBestValue(vector<int>& arr, int target) {\\n        int low=1,high=0,mid,ans1,ans2,n=arr.size(),sum1,sum2,high2;\\n        for(int i=0;i<n;i++) {\\n            high=max(high,arr[i]);\\n        }\\n        high2=high;\\n        while(low<=high) {\\n            mid=low+(high-low)/2;\\n            int sum=0;\\n            for(auto x:arr) {\\n                if(x>mid) sum+=mid;\\n                else sum+=x;\\n            }\\n            if(sum>=target) {\\n                ans1=mid;\\n                sum1=sum;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        low=1;\\n        high=high2;\\n        while(low<=high) {\\n            mid=low+(high-low)/2;\\n            int sum=0;\\n            for(auto x:arr) {\\n                if(x>mid) sum+=mid;\\n                else sum+=x;\\n            }\\n            if(sum<=target) {\\n                ans2=mid;\\n                sum2=sum;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        if(abs(target-sum1)==abs(target-sum2)) return ans2;\\n        return (abs(target-sum1)>abs(target-sum2))?(ans2):(ans1);\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1106426,
                "title": "python3-binary-search",
                "content": "Straightforward but a little bit slow.\\n\\n```python\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def calculate(k):\\n            return sum([min(k, a) for a in arr])\\n        \\n        left, right = 0, max(arr)+1\\n        while left < right:\\n            mid = (left + right)//2\\n            if calculate(mid) <= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n        can1, can2 = calculate(right-1), calculate(right)\\n        if abs(can1-target) <= abs(can2-target):\\n            return right-1\\n        else:\\n            return right\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def calculate(k):\\n            return sum([min(k, a) for a in arr])\\n        \\n        left, right = 0, max(arr)+1\\n        while left < right:\\n            mid = (left + right)//2\\n            if calculate(mid) <= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n        can1, can2 = calculate(right-1), calculate(right)\\n        if abs(can1-target) <= abs(can2-target):\\n            return right-1\\n        else:\\n            return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030626,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int possible(int m, vector<int>& arr, int target)\\n    {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n            sum+=min(m,arr[i]);\\n        return abs(sum-target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n            sum+=arr[i];\\n        if(sum<=target)\\n            return *max_element(arr.begin(),arr.end());\\n        int l=0,r=*max_element(arr.begin(),arr.end())+1;\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            if(possible(m,arr,target)>possible(m+1,arr,target))\\n                l=m+1;\\n            else\\n                r=m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int possible(int m, vector<int>& arr, int target)\\n    {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n            sum+=min(m,arr[i]);\\n        return abs(sum-target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n            sum+=arr[i];\\n        if(sum<=target)\\n            return *max_element(arr.begin(),arr.end());\\n        int l=0,r=*max_element(arr.begin(),arr.end())+1;\\n        while(l<r)\\n        {\\n            int m=(l+r)/2;\\n            if(possible(m,arr,target)>possible(m+1,arr,target))\\n                l=m+1;\\n            else\\n                r=m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014527,
                "title": "very-easy-commented-solution-without-using-binary-search-faster-than-100-percent",
                "content": "class Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int i;\\n        int n=arr.size();\\n        int length=n;\\n        int sum=0;\\n        for(i=0;i<n;i++)// taking sum of array\\n        {\\n            sum+=arr[i];\\n        }\\n        if(sum==target)\\n        {\\n            return arr[n-1];\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            double k=(target x 0.1)/(length x 0.1);// rounding of decimal to integer\\n            double diff= ceil(k)-k;\\n            if(diff>=0.5)\\n            {\\n                k= floor(k);\\n            }\\n            else\\n            {\\n                k=ceil(k);\\n            }\\n            \\n            if(arr[i]>=k)//  if k is greater than the current element means we have have reached the ideal case.\\n            {\\n                return k;\\n            }\\n            else\\n            {\\n                target-=arr[i];\\n                length--;\\n            }\\n        }\\n        return arr[n-1];\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int i;\\n        int n=arr.size();\\n        int length=n;\\n        int sum=0;\\n        for(i=0;i<n;i++)// taking sum of array\\n        {\\n            sum+=arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 995111,
                "title": "simple-binary-search-with-explanation-2ms-beats-98",
                "content": "Idea: Min Value : 1\\n\\t\\t Max Value: Maximum value in the array\\nApply Binary Search between min Value and max value to find the number in range which satisfies the condition.\\nLet it be stored in lo. Let the diff between sum and target be x. \\nNow also check for lo+1 and the difference be y\\nif(x <= y) return lo ;\\nelse return lo+1;\\n\\n\\n\\n```\\npublic static  int findBestValue(int[] arr, int target) {\\n\\t\\tint lo = 1 ; \\n\\t\\tint hi = Integer.MIN_VALUE ;\\n\\t\\t\\n\\t\\tfor(int num : arr) {\\n\\t\\t\\thi = Math.max(hi, num);\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\twhile(lo <= hi) {\\n\\t\\t\\tint mid = lo + ((hi - lo)/2);\\n\\t\\t\\tif(isPossible(arr, mid, target) <= target) { \\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\thi = mid-1 ; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tint val1 = isPossible(arr, lo-1, target);\\n\\t\\tint val2 = isPossible(arr, lo, target);\\n\\t\\t\\n\\t\\tif(Math.abs(target-val1) > Math.abs(target-val2)) return lo;\\n\\t\\telse return lo+1 ; \\n\\t\\t\\n\\t\\t\\n\\n\\t}\\n\\t\\n\\tpublic static int isPossible(int[] arr, int val, int target) {\\n\\t\\t\\n\\t\\tint sum = 0; \\n\\t\\tfor(int num : arr) {\\n\\t\\t\\tsum += Math.min(num, val);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sum ;\\n\\t\\t\\n\\t}\\n```\\nIf you like the solution do upvote it!",
                "solutionTags": [],
                "code": "```\\npublic static  int findBestValue(int[] arr, int target) {\\n\\t\\tint lo = 1 ; \\n\\t\\tint hi = Integer.MIN_VALUE ;\\n\\t\\t\\n\\t\\tfor(int num : arr) {\\n\\t\\t\\thi = Math.max(hi, num);\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\twhile(lo <= hi) {\\n\\t\\t\\tint mid = lo + ((hi - lo)/2);\\n\\t\\t\\tif(isPossible(arr, mid, target) <= target) { \\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\thi = mid-1 ; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tint val1 = isPossible(arr, lo-1, target);\\n\\t\\tint val2 = isPossible(arr, lo, target);\\n\\t\\t\\n\\t\\tif(Math.abs(target-val1) > Math.abs(target-val2)) return lo;\\n\\t\\telse return lo+1 ; \\n\\t\\t\\n\\t\\t\\n\\n\\t}\\n\\t\\n\\tpublic static int isPossible(int[] arr, int val, int target) {\\n\\t\\t\\n\\t\\tint sum = 0; \\n\\t\\tfor(int num : arr) {\\n\\t\\t\\tsum += Math.min(num, val);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sum ;\\n\\t\\t\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891720,
                "title": "c-easy-to-understand-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum=accumulate(arr.begin(),arr.end(),0);\\n        if(sum<=target)\\n        {\\n            return *max_element(arr.begin(),arr.end());\\n            \\n        }\\n        int diff=sum-target;\\n        int ans=*max_element(arr.begin(),arr.end());\\n        int low=0;\\n        int high=ans-1;\\n        int n=arr.size();\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int sum1=0;\\n            int i;\\n            for(i=0;i<n;i++)\\n            {\\n                sum1+=min(arr[i],mid);\\n            }\\n            int diff1=abs(sum1-target);\\n            if(diff1<diff)\\n            {\\n                ans=mid;\\n                diff=diff1;\\n            }\\n            else if(diff1==diff)\\n            {\\n                ans=min(ans,mid);\\n            }\\n            if(sum1<=target)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum=accumulate(arr.begin(),arr.end(),0);\\n        if(sum<=target)\\n        {\\n            return *max_element(arr.begin(),arr.end());\\n            \\n        }\\n        int diff=sum-target;\\n        int ans=*max_element(arr.begin(),arr.end());\\n        int low=0;\\n        int high=ans-1;\\n        int n=arr.size();\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int sum1=0;\\n            int i;\\n            for(i=0;i<n;i++)\\n            {\\n                sum1+=min(arr[i],mid);\\n            }\\n            int diff1=abs(sum1-target);\\n            if(diff1<diff)\\n            {\\n                ans=mid;\\n                diff=diff1;\\n            }\\n            else if(diff1==diff)\\n            {\\n                ans=min(ans,mid);\\n            }\\n            if(sum1<=target)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694415,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int L = 0 , R = 0 , mid = 0 , ans = INT_MAX ;\\n        for(auto i : arr ) R = max( R , i ) ;\\n        int disp = INT_MAX ;\\n        while( L <= R )\\n        {\\n            mid = ( L + R ) / 2 ;\\n            int K = solve( mid , arr , target ) ;\\n            if( abs(target-K) < ans )\\n            {\\n                ans = abs(target-K) ;\\n                disp = mid ;\\n            }\\n            else if( abs(target-K) == ans ) disp = min(disp , mid ) ;\\n            (K>=target)?R=mid-1:L=mid+1;\\n        }\\n        return disp ;\\n    }\\n    int solve( int an , vector<int>&arr,  int target )\\n    {\\n        int all_ = 0 ;\\n        for( auto i : arr )\\n        {\\n            (i>=an)?all_+=an:all_+=i;\\n        }\\n        return all_ ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int L = 0 , R = 0 , mid = 0 , ans = INT_MAX ;\\n        for(auto i : arr ) R = max( R , i ) ;\\n        int disp = INT_MAX ;\\n        while( L <= R )\\n        {\\n            mid = ( L + R ) / 2 ;\\n            int K = solve( mid , arr , target ) ;\\n            if( abs(target-K) < ans )\\n            {\\n                ans = abs(target-K) ;\\n                disp = mid ;\\n            }\\n            else if( abs(target-K) == ans ) disp = min(disp , mid ) ;\\n            (K>=target)?R=mid-1:L=mid+1;\\n        }\\n        return disp ;\\n    }\\n    int solve( int an , vector<int>&arr,  int target )\\n    {\\n        int all_ = 0 ;\\n        for( auto i : arr )\\n        {\\n            (i>=an)?all_+=an:all_+=i;\\n        }\\n        return all_ ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691487,
                "title": "java-sort-1-loop-from-highest-to-lowest",
                "content": "1, sort  the array\\n2, loop from highest value, then gradually decrease, update the mult with the number of elements decreasing.\\n```\\n    public int findBestValue(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        Arrays.sort(arr);\\n        int sum = 0, n = arr.length;\\n        for (int i : arr) sum += i;\\n        if (target >= sum) return arr[n - 1];\\n        int diff = sum - target, mult = 1, prev = arr[n - 1];\\n        for (int i = n - 2; i >= 0; i--, mult++) {\\n            System.out.println(diff + \",\" + i + \",\" + prev);\\n            diff -= (prev - arr[i]) * mult;\\n            if (diff <= 0) return arr[i] + (-diff) / mult + ((-diff) % mult <= (mult - (-diff) % mult) ? 0 : 1);\\n            prev = arr[i];\\n        }\\n        diff -= prev * mult;\\n        return (-diff) / mult + ((-diff) % mult <= (mult - (-diff) % mult)  ? 0 : 1);\\n                                           \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findBestValue(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        Arrays.sort(arr);\\n        int sum = 0, n = arr.length;\\n        for (int i : arr) sum += i;\\n        if (target >= sum) return arr[n - 1];\\n        int diff = sum - target, mult = 1, prev = arr[n - 1];\\n        for (int i = n - 2; i >= 0; i--, mult++) {\\n            System.out.println(diff + \",\" + i + \",\" + prev);\\n            diff -= (prev - arr[i]) * mult;\\n            if (diff <= 0) return arr[i] + (-diff) / mult + ((-diff) % mult <= (mult - (-diff) % mult) ? 0 : 1);\\n            prev = arr[i];\\n        }\\n        diff -= prev * mult;\\n        return (-diff) / mult + ((-diff) % mult <= (mult - (-diff) % mult)  ? 0 : 1);\\n                                           \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 644439,
                "title": "java-binary-search-solution-explanation",
                "content": "Let\\'s assume that there\\'s exact target sum exists with value. (not close one)\\nBecause it makes problem more simpler because we only need to find value that sum is equals to target. \\nThen, it is just a simple binary search problem to find value from 1 to maximum value in array.\\n\\nThe problem is to the most CLOSEST value, so answer is one of two: \\n1. smaller or same one\\n2. bigger one\\n\\nSo we have to choose close one between above.\\ne.g.   \\n98, 100, 101, target  = 100, low-1 = 98, low = 101\\n101(low) is answer.\\n99, 100, 102, target = 100, low-1 = 99, low = 102\\n99(low-1) is answer.\\n100, 100, 101 target = 100, low-1 = 100, low = 101\\n100(low-1) is answer.\\n\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int low = 1, high = max(arr)+1;\\n        while (low < high) {\\n            int mid = low + (high-low)/2;\\n            int sum = sumArray(arr, mid);\\n            if (sum <= target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        if (target - sumArray(arr, low-1) > (sumArray(arr, low) - target)) {\\n            return low;\\n        }\\n        return low-1;\\n    }\\n    \\n    public int sumArray(int[] arr, int k) {\\n        int sum = 0;\\n        for (int num : arr) {\\n            if (num > k) sum += k;\\n            else sum += num;\\n        }\\n        return sum;\\n    }\\n    \\n    public int max(int[] arr) {\\n        int high = 1;\\n        for (int num : arr) {\\n            if (num > high) high = num;\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int low = 1, high = max(arr)+1;\\n        while (low < high) {\\n            int mid = low + (high-low)/2;\\n            int sum = sumArray(arr, mid);\\n            if (sum <= target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        if (target - sumArray(arr, low-1) > (sumArray(arr, low) - target)) {\\n            return low;\\n        }\\n        return low-1;\\n    }\\n    \\n    public int sumArray(int[] arr, int k) {\\n        int sum = 0;\\n        for (int num : arr) {\\n            if (num > k) sum += k;\\n            else sum += num;\\n        }\\n        return sum;\\n    }\\n    \\n    public int max(int[] arr) {\\n        int high = 1;\\n        for (int num : arr) {\\n            if (num > high) high = num;\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522016,
                "title": "straightforward-java-solution-binary-search",
                "content": "Time: O(nlogk), where `n` is length of `arr`, `k` is the max value of `arr`\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int high = 0;\\n        for (int i : arr) {\\n            high = Math.max(high, i);\\n        }\\n        int low = 0;\\n        while (low + 1 < high) {\\n            int mid = low + (high - low) / 2;\\n            if (getSum(arr, mid) > target) {\\n                high = mid;\\n            } else {\\n                low = mid;\\n            }\\n        }\\n        if (Math.abs(getSum(arr, high) - target) < Math.abs(getSum(arr, low) - target)) {\\n            return high;\\n        }\\n        return low;\\n    }\\n    \\n    public int getSum(int[] arr, int max) {\\n        int sum = 0;\\n        for (int i : arr) {\\n            sum += i > max ? max : i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int high = 0;\\n        for (int i : arr) {\\n            high = Math.max(high, i);\\n        }\\n        int low = 0;\\n        while (low + 1 < high) {\\n            int mid = low + (high - low) / 2;\\n            if (getSum(arr, mid) > target) {\\n                high = mid;\\n            } else {\\n                low = mid;\\n            }\\n        }\\n        if (Math.abs(getSum(arr, high) - target) < Math.abs(getSum(arr, low) - target)) {\\n            return high;\\n        }\\n        return low;\\n    }\\n    \\n    public int getSum(int[] arr, int max) {\\n        int sum = 0;\\n        for (int i : arr) {\\n            sum += i > max ? max : i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518151,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int l = 0, r = target;\\n        \\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (helper(arr, mid, target) <= helper(arr, mid + 1, target))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        \\n        return l;\\n    }\\n    \\n    private int helper(int[] arr, int t, int target) {\\n        int sum = 0;\\n        for (int a : arr) sum += a < t ? a : t;\\n        return Math.abs(sum - target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int l = 0, r = target;\\n        \\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (helper(arr, mid, target) <= helper(arr, mid + 1, target))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        \\n        return l;\\n    }\\n    \\n    private int helper(int[] arr, int t, int target) {\\n        int sum = 0;\\n        for (int a : arr) sum += a < t ? a : t;\\n        return Math.abs(sum - target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463665,
                "title": "c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        vector<pair<int, int>> possibleResults;\\n        for (int i = target/arr.size(); i <= *max_element(arr.begin(), arr.end()); i++)\\n        {\\n            int sum = std::accumulate(arr.begin(), arr.end(), 0, [&i](int currentSum, int n)\\n               {\\n                   return n > i ? currentSum + i : currentSum + n;\\n               });\\n            \\n            if (sum == target) return i;\\n            possibleResults.emplace_back(i, sum);\\n            if (sum > target) break;\\n        }        \\n        \\n        auto closestPair = min_element(possibleResults.begin(), possibleResults.end(),\\n        [&target](const pair<int,int>& p1, const pair<int,int>& p2){\\n            return (abs(target - p1.second)) < (abs(target - p2.second));\\n        });\\n        \\n        return closestPair->first;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        vector<pair<int, int>> possibleResults;\\n        for (int i = target/arr.size(); i <= *max_element(arr.begin(), arr.end()); i++)\\n        {\\n            int sum = std::accumulate(arr.begin(), arr.end(), 0, [&i](int currentSum, int n)\\n               {\\n                   return n > i ? currentSum + i : currentSum + n;\\n               });\\n            \\n            if (sum == target) return i;\\n            possibleResults.emplace_back(i, sum);\\n            if (sum > target) break;\\n        }        \\n        \\n        auto closestPair = min_element(possibleResults.begin(), possibleResults.end(),\\n        [&target](const pair<int,int>& p1, const pair<int,int>& p2){\\n            return (abs(target - p1.second)) < (abs(target - p2.second));\\n        });\\n        \\n        return closestPair->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463470,
                "title": "python-3-four-lines-math-solution-28-ms-beats-100-o-n-log-n-o-1-space",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, A: List[int], t: int) -> int:\\n        L, A, y = len(A), [0]+sorted(A), 0\\n        for i in range(L):\\n            y += (A[i+1]-A[i])*(L-i)\\n            if y >= t: return round(A[i+1] + (t-y)/(L-i) - 0.01)\\n\\t\\t\\t\\n\\t\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, A: List[int], t: int) -> int:\\n        L, A, y = len(A), [0]+sorted(A), 0\\n        for i in range(L):\\n            y += (A[i+1]-A[i])*(L-i)\\n            if y >= t: return round(A[i+1] + (t-y)/(L-i) - 0.01)\\n\\t\\t\\t\\n\\t\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 463272,
                "title": "binary-search-python",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        num, mindiff = 0, float(\\'Inf\\')\\n        left, right = 0, max(arr)\\n        while left <= right:\\n            middle = left+(right-left)//2\\n            su = 0\\n            for i in arr:\\n                if i > middle:su += middle\\n                else:su += i\\n            if abs(target-su) < mindiff:\\n                num = middle\\n                mindiff = abs(target-su)\\n            elif abs(target-su) == mindiff:\\n                if num > middle:\\n                    num = middle\\n            if su > target:\\n                right = middle-1\\n            else:\\n                left = middle+1\\n        return num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        num, mindiff = 0, float(\\'Inf\\')\\n        left, right = 0, max(arr)\\n        while left <= right:\\n            middle = left+(right-left)//2\\n            su = 0\\n            for i in arr:\\n                if i > middle:su += middle\\n                else:su += i\\n            if abs(target-su) < mindiff:\\n                num = middle\\n                mindiff = abs(target-su)\\n            elif abs(target-su) == mindiff:\\n                if num > middle:\\n                    num = middle\\n            if su > target:\\n                right = middle-1\\n            else:\\n                left = middle+1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463269,
                "title": "java-1ms-o-n-no-binary-search",
                "content": "we won\\'t change values less than average anyways, we can remove them from total sum. answer should be nearest int of rest / restCount\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        int average = target / arr.length;\\n        int sum = 0, count = 0;\\n        for (int num: arr) {\\n            if (num <= average) {\\n                sum += num;\\n                count += 1;\\n            }\\n        }\\n        if (target - sum == 0) return average;\\n        double val = (double)(target - sum) / (arr.length - count); \\n        double large = Math.ceil(val);\\n        double small = Math.floor(val);\\n        if (Math.abs(small - val) == Math.abs(large - val)) return (int)small;\\n        \\n        return (int)Math.round(val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        int average = target / arr.length;\\n        int sum = 0, count = 0;\\n        for (int num: arr) {\\n            if (num <= average) {\\n                sum += num;\\n                count += 1;\\n            }\\n        }\\n        if (target - sum == 0) return average;\\n        double val = (double)(target - sum) / (arr.length - count); \\n        double large = Math.ceil(val);\\n        double small = Math.floor(val);\\n        if (Math.abs(small - val) == Math.abs(large - val)) return (int)small;\\n        \\n        return (int)Math.round(val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463259,
                "title": "python-very-intuitive-o-nlogn-sorting-keep-optimal-value",
                "content": "Keep track of an optimal value that we would like, keep updating optimal value as we go through the array and return when we can sub in the optimal value.\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        n = len(arr)\\n        optimal = round(target/n)\\n        \\n        for i,a in enumerate(arr):\\n            if a >= optimal:\\n                return optimal\\n            elif i != n-1:\\n                target -= a\\n                optimal = round(target/(n-i-1))\\n            else:\\n                break\\n            \\n        return arr[-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        n = len(arr)\\n        optimal = round(target/n)\\n        \\n        for i,a in enumerate(arr):\\n            if a >= optimal:\\n                return optimal\\n            elif i != n-1:\\n                target -= a\\n                optimal = round(target/(n-i-1))\\n            else:\\n                break\\n            \\n        return arr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463234,
                "title": "java-7ms-sorting-and-bruteforce-naive-solution-less-than-30-lines-easy-to-follow",
                "content": "Let me know if you think this can be improved.\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int ans = 0;\\n        int lowestDiff = Integer.MAX_VALUE;    \\n        int sumTillNow = 0;\\n        int index = 0;\\n\\t\\t\\n        Arrays.sort(arr);\\n        for(int i : arr){\\n            int tans = (target-sumTillNow) / (arr.length - index);\\n            int tpans = tans + 1;\\n            \\n            if(((index > 0 && tans >= (arr[index - 1]) && tans <= i) || (index == 0 && tans <= i)) && \\n\\t\\t\\t\\tMath.abs(tans*(arr.length-index) - (target-sumTillNow)) < lowestDiff){\\n\\t\\t\\t\\t\\tlowestDiff = Math.abs(tans*(arr.length-index) - (target-sumTillNow));\\n\\t\\t\\t\\t\\tans = tans;\\n            }\\n\\n\\t\\t\\tif(((index > 0 && tpans >= (arr[index - 1]) && tpans <= i || (index == 0 && tans <= i)) && \\n\\t\\t\\t\\tMath.abs(tpans*(arr.length-index) - (target-sumTillNow)) < lowestDiff)){\\n\\t\\t\\t\\t\\tlowestDiff = Math.abs(tpans*(arr.length-index) - (target-sumTillNow));\\n\\t\\t\\t\\t\\tans = tpans;\\n            }\\n            \\n            sumTillNow += i;\\n            index++;\\n            if( Math.abs((sumTillNow + (i*(arr.length - index))) - target) < lowestDiff){\\n                lowestDiff = Math.abs((sumTillNow + (i*(arr.length - index))) - target);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int ans = 0;\\n        int lowestDiff = Integer.MAX_VALUE;    \\n        int sumTillNow = 0;\\n        int index = 0;\\n\\t\\t\\n        Arrays.sort(arr);\\n        for(int i : arr){\\n            int tans = (target-sumTillNow) / (arr.length - index);\\n            int tpans = tans + 1;\\n            \\n            if(((index > 0 && tans >= (arr[index - 1]) && tans <= i) || (index == 0 && tans <= i)) && \\n\\t\\t\\t\\tMath.abs(tans*(arr.length-index) - (target-sumTillNow)) < lowestDiff){\\n\\t\\t\\t\\t\\tlowestDiff = Math.abs(tans*(arr.length-index) - (target-sumTillNow));\\n\\t\\t\\t\\t\\tans = tans;\\n            }\\n\\n\\t\\t\\tif(((index > 0 && tpans >= (arr[index - 1]) && tpans <= i || (index == 0 && tans <= i)) && \\n\\t\\t\\t\\tMath.abs(tpans*(arr.length-index) - (target-sumTillNow)) < lowestDiff)){\\n\\t\\t\\t\\t\\tlowestDiff = Math.abs(tpans*(arr.length-index) - (target-sumTillNow));\\n\\t\\t\\t\\t\\tans = tpans;\\n            }\\n            \\n            sumTillNow += i;\\n            index++;\\n            if( Math.abs((sumTillNow + (i*(arr.length - index))) - target) < lowestDiff){\\n                lowestDiff = Math.abs((sumTillNow + (i*(arr.length - index))) - target);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463212,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& A, int target) {\\n        sort(A.begin(), A.end());\\n        vector<int> sum;\\n        int n = A.size();\\n        sum.push_back(A[0]);\\n        for(int i = 1; i < A.size(); i++) {\\n            sum.push_back(sum.back() + A[i]);\\n        }\\n        int ans = 0, diff = target;\\n        for(int i = 1; i <= target; i++) {\\n            auto pos = upper_bound(A.begin(), A.end(), i);\\n            int p, tot;\\n            if(pos != A.begin()) {\\n                pos--;\\n                p = pos - A.begin();\\n                tot = sum[p] + i * (n - 1 - p);\\n            }\\n            else {\\n                tot = i * n;\\n            }\\n            if(abs(tot - target) < diff) {\\n                ans = i;\\n                diff = abs(tot - target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& A, int target) {\\n        sort(A.begin(), A.end());\\n        vector<int> sum;\\n        int n = A.size();\\n        sum.push_back(A[0]);\\n        for(int i = 1; i < A.size(); i++) {\\n            sum.push_back(sum.back() + A[i]);\\n        }\\n        int ans = 0, diff = target;\\n        for(int i = 1; i <= target; i++) {\\n            auto pos = upper_bound(A.begin(), A.end(), i);\\n            int p, tot;\\n            if(pos != A.begin()) {\\n                pos--;\\n                p = pos - A.begin();\\n                tot = sum[p] + i * (n - 1 - p);\\n            }\\n            else {\\n                tot = i * n;\\n            }\\n            if(abs(tot - target) < diff) {\\n                ans = i;\\n                diff = abs(tot - target);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463203,
                "title": "python-binary-search-with-hashmap-dictionary",
                "content": "```py\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def getSum(val):\\n            total = 0\\n            for i in range(n):\\n                total += arr[i] if arr[i] <= val else val\\n            return total\\n\\n        lo, hi, n = 0, max(arr), len(arr)\\n        diff = collections.defaultdict(set)\\n        while lo <= hi:\\n            mid = (lo+hi) // 2\\n            total = getSum(mid)\\n            # store the absolute differences\\n            diff[abs(total - target)].add(mid)\\n            if total < target:\\n                lo = mid+1\\n            elif total > target:\\n                hi = mid-1\\n            else:\\n                break\\n        \\n        # Find the lowest diff\\n        cand = diff[sorted(diff.keys())[0]]\\n        # Return the minimum value among candidates\\n        return sorted(cand)[0]        \\n```\\t\\t",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def getSum(val):\\n            total = 0\\n            for i in range(n):\\n                total += arr[i] if arr[i] <= val else val\\n            return total\\n\\n        lo, hi, n = 0, max(arr), len(arr)\\n        diff = collections.defaultdict(set)\\n        while lo <= hi:\\n            mid = (lo+hi) // 2\\n            total = getSum(mid)\\n            # store the absolute differences\\n            diff[abs(total - target)].add(mid)\\n            if total < target:\\n                lo = mid+1\\n            elif total > target:\\n                hi = mid-1\\n            else:\\n                break\\n        \\n        # Find the lowest diff\\n        cand = diff[sorted(diff.keys())[0]]\\n        # Return the minimum value among candidates\\n        return sorted(cand)[0]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 463187,
                "title": "c-binary-search-approximation-solution-description-updated",
                "content": "Our goal is to find a threshold T which can be used to modify the array so that the numbers in the array greater than T are set to T. Also, the sum of the result array should be close to the specified target.\\n\\nLet\\'s see the given example, [4,9,3]. We can choose 3 as the threshold to modify the array. As a result, the array is changed to [3,3,3], and the array sum 9 is close to 10.\\n\\nFor this, we can use a linear scan to find such threshold T. That is, we can try the candidates from 0 to 9. However, a more efficient approach is using binary approximation on the candidates to find the best T.\\n\\nAgain, let\\'s check the same example:\\nin the first iteration, lower bound L is set to 0, and the upper bound R is set to 9. Now we can get a middle point M, which is 4. Then we try to change the array to [4,4,3] whose sum is 11. \\n\\nSince 11 is greater than 10, we can decrease the upper bound R to 4 and launch another iteration to find T.\\n\\nThus, in the second iteration, lower bound L is 0, and the upper bound R is 4. Now we can get a new middle point M, which is 2. Then we change the array to [2, 2, 2] whose sum is 6.\\n\\nSince 6 is less than 10, we can increase the lower bound L to 2 and launch the third iteration to find T.\\n\\nIn the third iteration, lower bound L is 2, and the upper bound R is 4. Now we get the middle point 3, and change the array to [3,3,3].\\n\\nFinally, we narrow down to 2 candidates, 3 and 4. According to the problem description, 3 is a better one. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int l = 0, r = arr[0];\\n        for (int num : arr) {\\n            r = std::max(r, num);\\n        }\\n        \\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            int sum = getSum(arr, m);\\n            if (sum > target) {\\n                r = m;\\n            } else {\\n                l = m;\\n            }\\n        }\\n        \\n        int sum_l = getSum(arr, l);\\n        int sum_r = getSum(arr, r);\\n        \\n        if (abs(sum_l - target) <= abs(sum_r - target)) {\\n            return l;\\n        } else {\\n            return r;\\n        }\\n    }\\n    \\nprivate:\\n    int getSum(const auto& nums, int k) {\\n        \\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += (num < k) ? num : k;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int l = 0, r = arr[0];\\n        for (int num : arr) {\\n            r = std::max(r, num);\\n        }\\n        \\n        while (l + 1 < r) {\\n            int m = l + (r - l) / 2;\\n            int sum = getSum(arr, m);\\n            if (sum > target) {\\n                r = m;\\n            } else {\\n                l = m;\\n            }\\n        }\\n        \\n        int sum_l = getSum(arr, l);\\n        int sum_r = getSum(arr, r);\\n        \\n        if (abs(sum_l - target) <= abs(sum_r - target)) {\\n            return l;\\n        } else {\\n            return r;\\n        }\\n    }\\n    \\nprivate:\\n    int getSum(const auto& nums, int k) {\\n        \\n        int sum = 0;\\n        for (int num : nums) {\\n            sum += (num < k) ? num : k;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048920,
                "title": "easy-c-solution-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int find_diff(int mid,vector<int>& arr,int target){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>mid)\\n            sum+=mid;\\n            else\\n            sum+=arr[i];\\n        }\\n        return abs(target-sum);\\n    }\\n\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=target;\\n\\n        //binary search\\n        while(start<end){\\n            int mid = start + (end - start)/2;\\n            int temp1 = find_diff(mid,arr,target);\\n            int temp2 = find_diff(mid+1,arr,target);\\n\\n            if(temp1<=temp2)\\n            end=mid;\\n\\n            else\\n            start=mid+1;\\n        }\\n\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_diff(int mid,vector<int>& arr,int target){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>mid)\\n            sum+=mid;\\n            else\\n            sum+=arr[i];\\n        }\\n        return abs(target-sum);\\n    }\\n\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=target;\\n\\n        //binary search\\n        while(start<end){\\n            int mid = start + (end - start)/2;\\n            int temp1 = find_diff(mid,arr,target);\\n            int temp2 = find_diff(mid+1,arr,target);\\n\\n            if(temp1<=temp2)\\n            end=mid;\\n\\n            else\\n            start=mid+1;\\n        }\\n\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942707,
                "title": "java-binary-serach-solution",
                "content": "# Approach\\nThe element can be between 0 and the max element of the array. So we can apply binary search from 0 to max element of the array\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int getSum(int arr[], int num)\\n    {\\n        int sum = 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>num)\\n            sum+=num;\\n            else\\n            sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n\\n    public int findBestValue(int[] arr, int target) {\\n        int start = 0, end = arr[0], max = arr[0];\\n        for(int i=0;i<arr.length;i++)\\n        max = Math.max(max,arr[i]);\\n\\n        end = max;\\n\\n        while(start<=end)\\n        {\\n            int mid = start + (end-start)/2;\\n            if(getSum(arr,mid) < target) start = mid+1;\\n            else end = mid-1;\\n        }\\n\\n        if(Math.abs(getSum(arr,start)-target) < Math.abs(target-getSum(arr,start-1)))\\n        return start;\\n        return start-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int getSum(int arr[], int num)\\n    {\\n        int sum = 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>num)\\n            sum+=num;\\n            else\\n            sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n\\n    public int findBestValue(int[] arr, int target) {\\n        int start = 0, end = arr[0], max = arr[0];\\n        for(int i=0;i<arr.length;i++)\\n        max = Math.max(max,arr[i]);\\n\\n        end = max;\\n\\n        while(start<=end)\\n        {\\n            int mid = start + (end-start)/2;\\n            if(getSum(arr,mid) < target) start = mid+1;\\n            else end = mid-1;\\n        }\\n\\n        if(Math.abs(getSum(arr,start)-target) < Math.abs(target-getSum(arr,start-1)))\\n        return start;\\n        return start-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888019,
                "title": "golden-section-search",
                "content": "# Intuition\\nIt use golden-section search\\n\\n# Approach\\nThe critical is figuring out base rage for golden-section search\\n\\n# Complexity\\nGiven `N` as size of incoming array and `T` as min between `target` and max element in the array\\n- Time complexity for `calculateDeltaForCandidate`:\\n$$O(N)$$\\n- Time complexity for `findBestValue` **(final)**:\\n$$O(N*logN)$$ for initial sorting plus $$O(logT)*O(N)$$ for golden-section search\\n\\n- Space complexity:\\n$$O(N)$$ to keep sorted array\\n$$O(N)$$ to cover `sArr.slice(0, i)` in `calculateDeltaForCandidate`, can be optimazed\\n$$O(1)$$ for other variables\\n$$O(3*N)$$ **in general**\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nvar findBestValue = function(arr, target) {\\n    const sortedArr = [...arr].sort(function (a, b) {  return a - b;  });\\n    var lowestValue = Math.min(sortedArr[arr.length-1], Math.floor(target/arr.length));\\n    var higestValue = Math.min(sortedArr[arr.length-1], target);\\n    var value, deltaLeft, deltaRight;\\n    \\n    while (true) {\\n        candidateRight = Math.ceil((lowestValue + higestValue)/2)\\n        candidateLeft = candidateRight - 1\\n        deltaLeft = calculateDeltaForCandidate(sortedArr, target, candidateLeft)\\n        if (deltaLeft == 0) {\\n            return candidateLeft\\n        }\\n        deltaRight = calculateDeltaForCandidate(sortedArr, target, candidateRight)\\n        if (deltaRight == 0) {\\n            return candidateRight\\n        }\\n        if (deltaRight == 0) {\\n            return candidateRight\\n        }\\n        if (candidateRight == higestValue) {\\n            return deltaLeft <= deltaRight ? candidateLeft : candidateRight;\\n        }\\n        if (deltaLeft <= deltaRight) {\\n            higestValue = candidateLeft\\n        } else {\\n            lowestValue = candidateRight\\n        }\\n    }\\n};\\n\\nvar calculateDeltaForCandidate = function(sArr, target, candidate) {\\n    var sum\\n    //find idx lover then candidate\\n    for (var i=0; i < sArr.length; i++) {\\n        if (sArr[i] >= candidate) {\\n            sum = sArr.slice(0, i).reduce((partialSum, a) => partialSum + a, 0) + (sArr.length - i) * candidate;\\n            return Math.abs(sum - target)\\n        };\\n    }\\n    return NaN\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nvar findBestValue = function(arr, target) {\\n    const sortedArr = [...arr].sort(function (a, b) {  return a - b;  });\\n    var lowestValue = Math.min(sortedArr[arr.length-1], Math.floor(target/arr.length));\\n    var higestValue = Math.min(sortedArr[arr.length-1], target);\\n    var value, deltaLeft, deltaRight;\\n    \\n    while (true) {\\n        candidateRight = Math.ceil((lowestValue + higestValue)/2)\\n        candidateLeft = candidateRight - 1\\n        deltaLeft = calculateDeltaForCandidate(sortedArr, target, candidateLeft)\\n        if (deltaLeft == 0) {\\n            return candidateLeft\\n        }\\n        deltaRight = calculateDeltaForCandidate(sortedArr, target, candidateRight)\\n        if (deltaRight == 0) {\\n            return candidateRight\\n        }\\n        if (deltaRight == 0) {\\n            return candidateRight\\n        }\\n        if (candidateRight == higestValue) {\\n            return deltaLeft <= deltaRight ? candidateLeft : candidateRight;\\n        }\\n        if (deltaLeft <= deltaRight) {\\n            higestValue = candidateLeft\\n        } else {\\n            lowestValue = candidateRight\\n        }\\n    }\\n};\\n\\nvar calculateDeltaForCandidate = function(sArr, target, candidate) {\\n    var sum\\n    //find idx lover then candidate\\n    for (var i=0; i < sArr.length; i++) {\\n        if (sArr[i] >= candidate) {\\n            sum = sArr.slice(0, i).reduce((partialSum, a) => partialSum + a, 0) + (sArr.length - i) * candidate;\\n            return Math.abs(sum - target)\\n        };\\n    }\\n    return NaN\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855332,
                "title": "c-binary-search-short-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint diff(vector<int>& arr,int mid, int target){\\n    int sum=0;\\n    for(int a: arr){\\n        a>mid? sum+=mid: sum+=a;\\n    }\\n   return abs(target -sum);\\n}\\nint findBestValue(vector<int>& arr, int target) {\\n    int start=0;\\n    int end=target;\\n    int mid;\\n    while(start<end){\\n        mid=start+(end-start)/2;\\n        if(diff(arr,mid,target)<=diff(arr,mid+1,target)) end=mid;\\n        else start=mid+1;\\n}\\nreturn start;\\n }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint diff(vector<int>& arr,int mid, int target){\\n    int sum=0;\\n    for(int a: arr){\\n        a>mid? sum+=mid: sum+=a;\\n    }\\n   return abs(target -sum);\\n}\\nint findBestValue(vector<int>& arr, int target) {\\n    int start=0;\\n    int end=target;\\n    int mid;\\n    while(start<end){\\n        mid=start+(end-start)/2;\\n        if(diff(arr,mid,target)<=diff(arr,mid+1,target)) end=mid;\\n        else start=mid+1;\\n}\\nreturn start;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834325,
                "title": "easy-solution-using-binary-search-c",
                "content": "\\nExplaination:\\nIt initializes start to 0 and end to the maximum element in the input vector arr.\\nIt sets leftdiff and rightdiff to INT_MAX, which will be used to keep track of the minimum absolute differences found in the left and right halves of the binary search.\\nIt initializes variables lb and rb to store the best values found for the left and right halves, respectively.\\nThe function enters a binary search loop, where it calculates the mid point between start and end.\\nIt then calculates the sum using the result function with mid as the parameter.\\nDepending on whether the sum is less than or greater than the target value, it updates the leftdiff and rightdiff variables and the corresponding best value (lb or rb).\\nThe binary search is narrowed down based on the comparison between the sum and the target value.\\nAfter the binary search, it returns the best value (lb or rb) with the smaller absolute difference from the target value\\n\\n\\nCODE:\\n\"\"\"\\nint result(int start,vector<int>& arr)\\n    {\\n      int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            sum=sum+min(start,arr[i]);\\n\\n        \\n        }\\n        return sum;\\n    \\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n    int start = 0;\\n    int end = *max_element(arr.begin(), arr.end());\\n    int rightdiff = INT_MAX;\\n    int leftdiff=INT_MAX;\\n        int lb;\\n        int rb;\\n    \\n    while (start <= end) {\\n         // Use binary search to narrow down the range\\n        int mid=(start+end)/2;\\n        int sum = result(mid,arr);\\n        if(sum<target)\\n        {\\n            int left=abs(sum-target);\\n            if(min(leftdiff,left)==left)\\n            {\\n                leftdiff=left;\\n                lb=mid;\\n            }\\n           start=mid+1;\\n        \\n        }\\n        else\\n        {\\n            int right=abs(sum-target);\\n            if(min(rightdiff,right)==right)\\n            {\\n                         rightdiff=right;\\n                             rb=mid;\\n            }\\n                 end=mid-1;\\n        }\\n        \\n    }\\n    \\n    if(leftdiff<=rightdiff)//even both diff are same we take ans as smalest possible value\\n        return lb;\\n        return rb;\\n}\\n\"\"\"\\n<<<HOPE IT HELPS>>>",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "\\nExplaination:\\nIt initializes start to 0 and end to the maximum element in the input vector arr.\\nIt sets leftdiff and rightdiff to INT_MAX, which will be used to keep track of the minimum absolute differences found in the left and right halves of the binary search.\\nIt initializes variables lb and rb to store the best values found for the left and right halves, respectively.\\nThe function enters a binary search loop, where it calculates the mid point between start and end.\\nIt then calculates the sum using the result function with mid as the parameter.\\nDepending on whether the sum is less than or greater than the target value, it updates the leftdiff and rightdiff variables and the corresponding best value (lb or rb).\\nThe binary search is narrowed down based on the comparison between the sum and the target value.\\nAfter the binary search, it returns the best value (lb or rb) with the smaller absolute difference from the target value\\n\\n\\nCODE:\\n\"\"\"\\nint result(int start,vector<int>& arr)\\n    {\\n      int sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            sum=sum+min(start,arr[i]);\\n\\n        \\n        }\\n        return sum;\\n    \\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n    int start = 0;\\n    int end = *max_element(arr.begin(), arr.end());\\n    int rightdiff = INT_MAX;\\n    int leftdiff=INT_MAX;\\n        int lb;\\n        int rb;\\n    \\n    while (start <= end) {\\n         // Use binary search to narrow down the range\\n        int mid=(start+end)/2;\\n        int sum = result(mid,arr);\\n        if(sum<target)\\n        {\\n            int left=abs(sum-target);\\n            if(min(leftdiff,left)==left)\\n            {\\n                leftdiff=left;\\n                lb=mid;\\n            }\\n           start=mid+1;\\n        \\n        }\\n        else\\n        {\\n            int right=abs(sum-target);\\n            if(min(rightdiff,right)==right)\\n            {\\n                         rightdiff=right;\\n                             rb=mid;\\n            }\\n                 end=mid-1;\\n        }\\n        \\n    }\\n    \\n    if(leftdiff<=rightdiff)//even both diff are same we take ans as smalest possible value\\n        return lb;\\n        return rb;\\n}\\n\"\"\"\\n<<<HOPE IT HELPS>>>",
                "codeTag": "Unknown"
            },
            {
                "id": 3824465,
                "title": "binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int mid,vector<int> &arr,int target){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] > mid) sum+=mid;\\n            else sum+=arr[i];\\n        }\\n        return abs(target-sum);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0,r=*max_element(arr.begin(),arr.end()),ans;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(solve(mid,arr,target) <= solve(mid+1,arr,target)) {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int mid,vector<int> &arr,int target){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] > mid) sum+=mid;\\n            else sum+=arr[i];\\n        }\\n        return abs(target-sum);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0,r=*max_element(arr.begin(),arr.end()),ans;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(solve(mid,arr,target) <= solve(mid+1,arr,target)) {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788320,
                "title": "c-no-binary-search",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nC++ method without using binary search \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n  \\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int s=0;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++){\\n            if(arr[i]*(n-i)>=target){\\n                return int(round((target-0.0001)/(n-i)));\\n            }\\n            target-=arr[i];\\n        }\\n        \\n        return arr[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n  \\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int s=0;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++){\\n            if(arr[i]*(n-i)>=target){\\n                return int(round((target-0.0001)/(n-i)));\\n            }\\n            target-=arr[i];\\n        }\\n        \\n        return arr[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778839,
                "title": "sort-and-control-the-rolling-sum-as-compared-to-averaged-target-hit-if-all-elements-x",
                "content": "# Intuition\\nNote the constraint that the elements are never less than 1 or negatie. This significantly simplifies the task.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe array is sorted first (as with unsorted one, you never know what the next element brings). In the sorted array for each element, we divide the difference between target and the sum of the elements that have already passed by the number of remaining elements (and round the result). The result of this operation is essentially \"if all remaining numbers are equal to it, we will hit the target\". If the current element is greater than this number - we got our response. If not, once the loop is over, we simply return the last (largest) element of array.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n) )$$ because of sorting. $$O(n)$$ otherwise.\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int target_mem, rolling_sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            target_mem=(target-rolling_sum)/(arr.size()-i);\\n            if((target-rolling_sum)%(arr.size()-i)>0.5*(arr.size()-i))//>= would also fly, but hits an invalid test case\\n            {\\n                target_mem++;\\n            }\\n            if(arr[i]>target_mem)\\n            {\\n                return target_mem;\\n            }\\n            rolling_sum+=arr[i];\\n        }\\n        return arr[arr.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int target_mem, rolling_sum=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            target_mem=(target-rolling_sum)/(arr.size()-i);\\n            if((target-rolling_sum)%(arr.size()-i)>0.5*(arr.size()-i))//>= would also fly, but hits an invalid test case\\n            {\\n                target_mem++;\\n            }\\n            if(arr[i]>target_mem)\\n            {\\n                return target_mem;\\n            }\\n            rolling_sum+=arr[i];\\n        }\\n        return arr[arr.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775423,
                "title": "java-very-slow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n     \\n\\n        int lastIndex = 0;\\n        int minDiff = Integer.MAX_VALUE;\\n        int result = -1;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            int currentElement = arr[i];\\n            for (int j = lastIndex; j < currentElement; j++) {\\n                int currentDiff = Math.abs(target - j * (arr.length - i));\\n                if (currentDiff < minDiff) {\\n                    minDiff = currentDiff;\\n                    result = j;\\n                }\\n            }\\n            int currentDiff = Math.abs(target - currentElement * (arr.length - i));\\n            if (currentDiff < minDiff) {\\n                minDiff = currentDiff;\\n                result = currentElement;\\n            }\\n            target -= currentElement;\\n            lastIndex = currentElement;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n     \\n\\n        int lastIndex = 0;\\n        int minDiff = Integer.MAX_VALUE;\\n        int result = -1;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            int currentElement = arr[i];\\n            for (int j = lastIndex; j < currentElement; j++) {\\n                int currentDiff = Math.abs(target - j * (arr.length - i));\\n                if (currentDiff < minDiff) {\\n                    minDiff = currentDiff;\\n                    result = j;\\n                }\\n            }\\n            int currentDiff = Math.abs(target - currentElement * (arr.length - i));\\n            if (currentDiff < minDiff) {\\n                minDiff = currentDiff;\\n                result = currentElement;\\n            }\\n            target -= currentElement;\\n            lastIndex = currentElement;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751649,
                "title": "easy-java-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSelf explanatory.!!,.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int[] pre = new int[arr.length+1];\\n        pre[0]=0;\\n        for(int i=1;i<=arr.length;i++){\\n            pre[i]=arr[i-1]+pre[i-1];\\n        }\\n        int n = arr.length-1;\\n        if(pre[n+1]==target)return arr[n];\\n        int l=0,r=target;\\n        while(l<r){\\n            int m = (l+r)/2;\\n            int j=0;\\n            for(j=0;j<=n;j++){\\n                if(arr[j]>=m)break;\\n            }\\n            int val = pre[j]+(n-j+1)*m;\\n            for(;j<=n;j++){\\n                if(arr[j]>=m+1)break;\\n            }\\n            int val2 = pre[j]+(n-j+1)*(m+1);\\n            if(Math.abs(target-val)<=Math.abs(target-val2))r=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int[] pre = new int[arr.length+1];\\n        pre[0]=0;\\n        for(int i=1;i<=arr.length;i++){\\n            pre[i]=arr[i-1]+pre[i-1];\\n        }\\n        int n = arr.length-1;\\n        if(pre[n+1]==target)return arr[n];\\n        int l=0,r=target;\\n        while(l<r){\\n            int m = (l+r)/2;\\n            int j=0;\\n            for(j=0;j<=n;j++){\\n                if(arr[j]>=m)break;\\n            }\\n            int val = pre[j]+(n-j+1)*m;\\n            for(;j<=n;j++){\\n                if(arr[j]>=m+1)break;\\n            }\\n            int val2 = pre[j]+(n-j+1)*(m+1);\\n            if(Math.abs(target-val)<=Math.abs(target-val2))r=m;\\n            else l=m+1;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736569,
                "title": "c-solution-using-binary-search-find-the-peak-element-in-bitonic-array",
                "content": "```\\nquestion is reduced to find the first element (cur) where abs(target-mutatedSum(cur)) <= abs(target-mutatedSum(cur+1))\\n```\\n```\\n//literally same as the peak element or else we can do it by normally also\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int lo = 0,hi = *max_element(arr.begin(),arr.end());\\n        int ans = hi;\\n        function<bool(int)> check = [&](int cur)->bool{\\n            int next = cur+1;\\n            int curSum = 0,nextSum = 0;\\n            for(auto & i : arr){\\n                curSum += i > cur ? cur : i;\\n                nextSum += i > next ? next : i;\\n            }\\n            return abs(target-curSum) <= abs(target-nextSum);\\n        };\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(mid)){\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else lo = mid+1;\\n        }\\n        return ans;\\n    }\\n```\\nupvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nquestion is reduced to find the first element (cur) where abs(target-mutatedSum(cur)) <= abs(target-mutatedSum(cur+1))\\n```\n```\\n//literally same as the peak element or else we can do it by normally also\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int lo = 0,hi = *max_element(arr.begin(),arr.end());\\n        int ans = hi;\\n        function<bool(int)> check = [&](int cur)->bool{\\n            int next = cur+1;\\n            int curSum = 0,nextSum = 0;\\n            for(auto & i : arr){\\n                curSum += i > cur ? cur : i;\\n                nextSum += i > next ? next : i;\\n            }\\n            return abs(target-curSum) <= abs(target-nextSum);\\n        };\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(mid)){\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else lo = mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3718579,
                "title": "clever-solution-in-c-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<int> sum(arr.begin(),arr.end());\\n        int n=arr.size();\\n        int maxi=-1;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,arr[i]);\\n        }\\n        for(int i=1;i<n;i++){\\n            sum[i]+=sum[i-1];\\n        }\\n        int val=-1,dif=INT_MAX;\\n        vector<int>::iterator upper1;\\n        for(int i=0;i<=maxi;i++){\\n           upper1=upper_bound(arr.begin(),arr.end(),i);\\n           int ap=upper1-arr.begin();\\n           if(ap!=0){\\n             int vali=(n-ap)*i+sum[ap-1];\\n             if(abs(vali-target)<dif){\\n                 dif=abs(vali-target); val=i;\\n             }\\n           }\\n           else{\\n               int vali=(n)*i;\\n               if(abs(vali-target)<dif) {dif=abs(vali-target); val=i;}\\n           }\\n           \\n        }\\n        return val;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<int> sum(arr.begin(),arr.end());\\n        int n=arr.size();\\n        int maxi=-1;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,arr[i]);\\n        }\\n        for(int i=1;i<n;i++){\\n            sum[i]+=sum[i-1];\\n        }\\n        int val=-1,dif=INT_MAX;\\n        vector<int>::iterator upper1;\\n        for(int i=0;i<=maxi;i++){\\n           upper1=upper_bound(arr.begin(),arr.end(),i);\\n           int ap=upper1-arr.begin();\\n           if(ap!=0){\\n             int vali=(n-ap)*i+sum[ap-1];\\n             if(abs(vali-target)<dif){\\n                 dif=abs(vali-target); val=i;\\n             }\\n           }\\n           else{\\n               int vali=(n)*i;\\n               if(abs(vali-target)<dif) {dif=abs(vali-target); val=i;}\\n           }\\n           \\n        }\\n        return val;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702616,
                "title": "solution-usign-binary-search-c",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nbased on binary search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& arr,int m){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>m){\\n                sum=sum+m;\\n            }\\n            else{\\n                sum=sum+arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int mm=0;\\n        for(auto x:arr){\\n            if(x>mm){\\n                mm=x;\\n            }\\n        }\\n        int l=0,r=mm,m;\\n        int maxi=-1,mini=-1;\\n        int max=INT_MAX,min=INT_MAX;\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            int k=fun(arr,m);\\n            \\n            if(k>=target){\\n                max=k;\\n                maxi=m;\\n                r=m-1;\\n            }\\n            else{\\n                min=k;\\n                mini=m;\\n                l=m+1;\\n            }\\n        }\\n        if((target-min)<=(max-target)){\\n            return mini;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& arr,int m){\\n        int sum=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>m){\\n                sum=sum+m;\\n            }\\n            else{\\n                sum=sum+arr[i];\\n            }\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int mm=0;\\n        for(auto x:arr){\\n            if(x>mm){\\n                mm=x;\\n            }\\n        }\\n        int l=0,r=mm,m;\\n        int maxi=-1,mini=-1;\\n        int max=INT_MAX,min=INT_MAX;\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            int k=fun(arr,m);\\n            \\n            if(k>=target){\\n                max=k;\\n                maxi=m;\\n                r=m-1;\\n            }\\n            else{\\n                min=k;\\n                mini=m;\\n                l=m+1;\\n            }\\n        }\\n        if((target-min)<=(max-target)){\\n            return mini;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679875,
                "title": "binary-search-with-two-edge-cases",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        total = sum(arr)\\n        beg = min(arr)\\n        end = max(arr)\\n        res = (float(\\'inf\\'), -1)\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            curr = 0\\n            for el in arr:\\n                curr += el if el < mid else mid\\n            if curr >= target:\\n                res = min(res, (curr - target, mid))\\n                end = mid - 1\\n            else:\\n                res = min(res, (target - curr, mid))\\n                beg = mid + 1\\n        for extra in [target // n, target // n + 1]:\\n            curr = 0\\n            for el in arr:\\n                curr += el if el < extra else extra\\n            res = min(res, (abs(curr - target), extra))\\n        return res[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        total = sum(arr)\\n        beg = min(arr)\\n        end = max(arr)\\n        res = (float(\\'inf\\'), -1)\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            curr = 0\\n            for el in arr:\\n                curr += el if el < mid else mid\\n            if curr >= target:\\n                res = min(res, (curr - target, mid))\\n                end = mid - 1\\n            else:\\n                res = min(res, (target - curr, mid))\\n                beg = mid + 1\\n        for extra in [target // n, target // n + 1]:\\n            curr = 0\\n            for el in arr:\\n                curr += el if el < extra else extra\\n            res = min(res, (abs(curr - target), extra))\\n        return res[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645398,
                "title": "prefix-sum-binary-search-python3-solution",
                "content": "```\\nclass Solution:\\n    \\n    def findDiffAfterMutation(self, value: int, arr: List[int], prefix_sum: List[int]) -> int:\\n        \\n        lo, hi = 0, len(arr)-1\\n        index = -1\\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            if arr[mid] <= value:\\n                index = mid\\n                lo = mid+1\\n            else:\\n                hi = mid-1\\n                \\n        tot = prefix_sum[index+1]\\n        mutated_len = len(arr)-index-1\\n        tot += (value*mutated_len)\\n        \\n        return tot\\n                \\n    \\n    # O(nlogn) time,\\n    # O(n) space,\\n    # Approach: prefix sum, binary search, sorting, \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        prefix_sum = [0]\\n        tot = 0\\n        for num in arr:\\n            tot += num\\n            prefix_sum.append(tot)\\n        \\n        min_diff = float(\\'inf\\')\\n        ans = arr[-1]\\n        for i in range(0, arr[-1]+1):\\n            curr_diff = abs(target-self.findDiffAfterMutation(i, arr, prefix_sum))\\n            if curr_diff > min_diff:\\n                break\\n            elif curr_diff < min_diff:\\n                ans = i\\n                min_diff = curr_diff\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def findDiffAfterMutation(self, value: int, arr: List[int], prefix_sum: List[int]) -> int:\\n        \\n        lo, hi = 0, len(arr)-1\\n        index = -1\\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            if arr[mid] <= value:\\n                index = mid\\n                lo = mid+1\\n            else:\\n                hi = mid-1\\n                \\n        tot = prefix_sum[index+1]\\n        mutated_len = len(arr)-index-1\\n        tot += (value*mutated_len)\\n        \\n        return tot\\n                \\n    \\n    # O(nlogn) time,\\n    # O(n) space,\\n    # Approach: prefix sum, binary search, sorting, \\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        prefix_sum = [0]\\n        tot = 0\\n        for num in arr:\\n            tot += num\\n            prefix_sum.append(tot)\\n        \\n        min_diff = float(\\'inf\\')\\n        ans = arr[-1]\\n        for i in range(0, arr[-1]+1):\\n            curr_diff = abs(target-self.findDiffAfterMutation(i, arr, prefix_sum))\\n            if curr_diff > min_diff:\\n                break\\n            elif curr_diff < min_diff:\\n                ans = i\\n                min_diff = curr_diff\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637477,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   int getsum(vector<int>&arr,int mid){//can be calculated using prefix sum\\n        long long sum=0;\\n        for(auto x:arr){\\n          sum+=(x>mid)?mid:x;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int low=0,high=*max_element(arr.begin(),arr.end());\\n        int mnvalue=0;\\n        for(auto x:arr){mnvalue+=x;}\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n             int sum=getsum(arr,mid);\\n            if((target-sum)<=0){\\n                  if(mnvalue>=abs(target-sum)){\\n                      ans=(mnvalue==abs(target-sum))?min(ans,mid):mid;\\n                    mnvalue=min(mnvalue,abs(target-sum));\\n                     \\n                }\\n                high=mid-1;\\n            }else{\\n                   if(mnvalue>=abs(target-sum)){\\n                        ans=(mnvalue==abs(target-sum))?min(ans,mid):mid;\\n                    mnvalue=min(mnvalue,abs(target-sum));\\n                    \\n                }\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int getsum(vector<int>&arr,int mid){//can be calculated using prefix sum\\n        long long sum=0;\\n        for(auto x:arr){\\n          sum+=(x>mid)?mid:x;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int low=0,high=*max_element(arr.begin(),arr.end());\\n        int mnvalue=0;\\n        for(auto x:arr){mnvalue+=x;}\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n             int sum=getsum(arr,mid);\\n            if((target-sum)<=0){\\n                  if(mnvalue>=abs(target-sum)){\\n                      ans=(mnvalue==abs(target-sum))?min(ans,mid):mid;\\n                    mnvalue=min(mnvalue,abs(target-sum));\\n                     \\n                }\\n                high=mid-1;\\n            }else{\\n                   if(mnvalue>=abs(target-sum)){\\n                        ans=(mnvalue==abs(target-sum))?min(ans,mid):mid;\\n                    mnvalue=min(mnvalue,abs(target-sum));\\n                    \\n                }\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613132,
                "title": "simple-c-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint bs(vector<int>& arr,int number){\\n    int l=0;\\n    int r=arr.size()-1;\\n    int index=-1;\\n    while(l<=r){\\n        int mid=(l+r)/2;\\n        if(arr[mid]>number){\\n            index=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]<=number){\\n            l=mid+1;\\n        }\\n    }\\n    return index;\\n}\\n    int findBestValue(vector<int>& arr, int target) {\\n     sort(arr.begin(),arr.end());\\n     vector<int>prefix;\\n     prefix.push_back(arr[0]);\\n     for(int i=1;i<arr.size();i++){\\n         prefix.push_back(arr[i]+prefix[i-1]);\\n     }\\n     int ans=INT_MAX;\\n     int hope=0;\\n     for(int i=0;i<=target;i++){\\n         int index=bs(arr,i);\\n         int res;\\n         if(index>0) res=prefix[index-1]+(arr.size()-index)*i;\\n         if(index==0)res=(arr.size()-index)*i;\\n         if(index==-1)res=prefix[arr.size()-1];\\n         if(ans>abs(res-target)){\\n             ans=abs(res-target);\\n             hope=i;\\n         }\\n     }\\n     return hope;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint bs(vector<int>& arr,int number){\\n    int l=0;\\n    int r=arr.size()-1;\\n    int index=-1;\\n    while(l<=r){\\n        int mid=(l+r)/2;\\n        if(arr[mid]>number){\\n            index=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]<=number){\\n            l=mid+1;\\n        }\\n    }\\n    return index;\\n}\\n    int findBestValue(vector<int>& arr, int target) {\\n     sort(arr.begin(),arr.end());\\n     vector<int>prefix;\\n     prefix.push_back(arr[0]);\\n     for(int i=1;i<arr.size();i++){\\n         prefix.push_back(arr[i]+prefix[i-1]);\\n     }\\n     int ans=INT_MAX;\\n     int hope=0;\\n     for(int i=0;i<=target;i++){\\n         int index=bs(arr,i);\\n         int res;\\n         if(index>0) res=prefix[index-1]+(arr.size()-index)*i;\\n         if(index==0)res=(arr.size()-index)*i;\\n         if(index==-1)res=prefix[arr.size()-1];\\n         if(ans>abs(res-target)){\\n             ans=abs(res-target);\\n             hope=i;\\n         }\\n     }\\n     return hope;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559290,
                "title": "a-simple-and-easy-to-understand-o-log-n-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe sum of array that we get after replacing all the values larger than a $$num$$ by $$num$$ is non-decreasing with respect to $$num$$. So, we can use binary search for this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo calculate the sum easily, we can pre-calulate the cumulative sum array $$pre$$, where $$pre[i] = arr[0] + arr[1] + ... + arr[i]$$.\\n\\nNow we use binary search to find the number. The lowest such number can be $$0$$, because if we replace all numbers by $$0$$, we will get sum as $$0$$. So, we will set the lower bound of our solution space as $$0$$. Our upper bound can be the largest number in the array, since any $$mid$$ greater than $$max(arr)$$ will lead to no replacement, so that will be as good as $$max(arr)$$.\\n\\nWe also sort the array to easily find the elements larger than $$mid$$.\\n\\nFor a given $$num$$, we find the index $$ub$$ so that $$ub$$ is the minimum index at which $$arr[ub] > mid$$. So, we know that all elements at $$ub$$ and after it are greater than $$mid$$. So, sum of all such elements after replacing them with $$mid$$ will be $$mid * (n - ub)$$. All the elements at indices less than $$ub$$ will be less than or equal to $$mid$$, so sum of all such elements will be $$pre[ub - 1]$$. So, total sum $$sum$$ will be equal to sum of both parts: $$pre[ub - 1] + mid * (n - ub)$$.\\n\\nWe compare $$sum$$ with $$target$$ and adjust our solution space according to that. We also update our answer based on $$abs(sum - target)$$.\\n\\n# Complexity\\n- Time complexity: $$O(n log(n))$$, since the most expensive operation is sorting. Our binary search loop takes $$O((log(n))^2)$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for storing cumulative sum.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n        int lo = 0, hi = arr[n - 1];\\n        vector<long long int> pre(n);\\n        pre[0] = arr[0];\\n        for (int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1] + arr[i];\\n        }\\n        int ans;\\n        long long int minmDiff = INT_MAX;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int ub = upper_bound(arr.begin(), arr.end(), mid) - arr.begin();\\n            long long int sum = (ub > 0 ? pre[ub - 1] : 0) + mid * (n - ub);\\n            long long int diff = abs(sum - target);\\n            if (diff < minmDiff || (minmDiff == diff && mid < ans)) {\\n                minmDiff = diff;\\n                ans = mid;\\n            }\\n            if (sum >= target) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(), arr.end());\\n        int n = arr.size();\\n        int lo = 0, hi = arr[n - 1];\\n        vector<long long int> pre(n);\\n        pre[0] = arr[0];\\n        for (int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1] + arr[i];\\n        }\\n        int ans;\\n        long long int minmDiff = INT_MAX;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int ub = upper_bound(arr.begin(), arr.end(), mid) - arr.begin();\\n            long long int sum = (ub > 0 ? pre[ub - 1] : 0) + mid * (n - ub);\\n            long long int diff = abs(sum - target);\\n            if (diff < minmDiff || (minmDiff == diff && mid < ans)) {\\n                minmDiff = diff;\\n                ans = mid;\\n            }\\n            if (sum >= target) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534255,
                "title": "easy-c-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum = accumulate(arr.begin(), arr.end(), 0);\\n        if(target >= sum){\\n            auto it = max_element(arr.begin(), arr.end());\\n            return *it;\\n        }\\n        int minNumber = 0;\\n        int prevDiff = INT_MAX;\\n        int result = 0;\\n        \\n        while(1){\\n            int currentSum = 0;\\n            for(int i=0; i<arr.size(); i++){\\n                if(arr[i] > minNumber){\\n                    currentSum += minNumber;\\n                }else{\\n                    currentSum += arr[i];\\n                }\\n            }\\n\\n            int currentDiff = abs(target - currentSum);\\n            if(currentDiff < prevDiff){\\n                prevDiff = currentDiff;\\n                result = minNumber;\\n            }else{\\n                break;\\n            }\\n\\n            minNumber++;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int sum = accumulate(arr.begin(), arr.end(), 0);\\n        if(target >= sum){\\n            auto it = max_element(arr.begin(), arr.end());\\n            return *it;\\n        }\\n        int minNumber = 0;\\n        int prevDiff = INT_MAX;\\n        int result = 0;\\n        \\n        while(1){\\n            int currentSum = 0;\\n            for(int i=0; i<arr.size(); i++){\\n                if(arr[i] > minNumber){\\n                    currentSum += minNumber;\\n                }else{\\n                    currentSum += arr[i];\\n                }\\n            }\\n\\n            int currentDiff = abs(target - currentSum);\\n            if(currentDiff < prevDiff){\\n                prevDiff = currentDiff;\\n                result = minNumber;\\n            }else{\\n                break;\\n            }\\n\\n            minNumber++;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518776,
                "title": "readable-swift-binary-search",
                "content": "# Complexity\\n- Time complexity: $$O(nlog * max(arr))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func findBestValue(_ arr: [Int], _ target: Int) -> Int {\\n        var l = target / arr.count\\n        var r = arr.max()!\\n\\n        var ans = r\\n        var total = arr.reduce(0, +)\\n        var diff = abs(total - target)\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n\\n            var sum = 0\\n            for num in arr {\\n                sum += num <= mid ? num : mid\\n            }\\n\\n            if sum > target {\\n                r = mid - 1\\n            } else {\\n                l = mid + 1\\n            }\\n\\n            if abs(sum - target) < diff || abs(sum - target) == diff && mid < ans  {\\n                diff = abs(sum - target)\\n                ans = mid\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findBestValue(_ arr: [Int], _ target: Int) -> Int {\\n        var l = target / arr.count\\n        var r = arr.max()!\\n\\n        var ans = r\\n        var total = arr.reduce(0, +)\\n        var diff = abs(total - target)\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n\\n            var sum = 0\\n            for num in arr {\\n                sum += num <= mid ? num : mid\\n            }\\n\\n            if sum > target {\\n                r = mid - 1\\n            } else {\\n                l = mid + 1\\n            }\\n\\n            if abs(sum - target) < diff || abs(sum - target) == diff && mid < ans  {\\n                diff = abs(sum - target)\\n                ans = mid\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483867,
                "title": "c-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        std::sort(arr.begin(), arr.end());\\n        int l = 0, r = arr[arr.size() - 1];\\n        while (l + 1 < r) {\\n            int mid = (l + r) / 2;\\n            int diff = getDiff(arr, target, mid);\\n            if (diff >= 0) r = mid;\\n            else l = mid;\\n        }\\n        if (abs(getDiff(arr, target, l)) <= abs(getDiff(arr, target, r))) return l;\\n        else return r;\\n    }\\n\\n    int getDiff(vector<int>& arr, int target, int value) {\\n        int diff;\\n        if (arr[0] >= value) {\\n            diff = value * arr.size() - target;\\n        } else if (arr[arr.size() - 1] <= value) {\\n            diff = std::accumulate(arr.begin(), arr.end(), 0) - target;\\n        } else {\\n            int sum = 0;\\n            for (int i = 0; i < arr.size() - 1; i++) {\\n                sum = sum + arr[i];\\n                if (arr[i] <= value && arr[i + 1] >= value) {\\n                    diff = sum + (arr.size() - i - 1) * value - target;\\n                    break;\\n                }\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        std::sort(arr.begin(), arr.end());\\n        int l = 0, r = arr[arr.size() - 1];\\n        while (l + 1 < r) {\\n            int mid = (l + r) / 2;\\n            int diff = getDiff(arr, target, mid);\\n            if (diff >= 0) r = mid;\\n            else l = mid;\\n        }\\n        if (abs(getDiff(arr, target, l)) <= abs(getDiff(arr, target, r))) return l;\\n        else return r;\\n    }\\n\\n    int getDiff(vector<int>& arr, int target, int value) {\\n        int diff;\\n        if (arr[0] >= value) {\\n            diff = value * arr.size() - target;\\n        } else if (arr[arr.size() - 1] <= value) {\\n            diff = std::accumulate(arr.begin(), arr.end(), 0) - target;\\n        } else {\\n            int sum = 0;\\n            for (int i = 0; i < arr.size() - 1; i++) {\\n                sum = sum + arr[i];\\n                if (arr[i] <= value && arr[i + 1] >= value) {\\n                    diff = sum + (arr.size() - i - 1) * value - target;\\n                    break;\\n                }\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389914,
                "title": "c-easy-to-understand-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int low =0,high =0;\\n        for(int i=0;i<n;i++){\\n            high = max(high,arr[i]);\\n        }\\n        while(low<high){\\n            int mid = low+(high-low)/2;\\n            int sum =0;\\n            for(int i=0;i<n;i++){\\n                sum+=min(arr[i],mid);\\n            }\\n\\n            if(sum>=target){\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        int sum1 =0,sum2 =0;\\n        for(int i=0;i<n;i++){\\n            sum1 += min(arr[i],low);\\n            sum2 += min(arr[i],low-1);\\n\\n        }\\n        return abs(sum2-target)<=abs(sum1-target)? low-1:low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int low =0,high =0;\\n        for(int i=0;i<n;i++){\\n            high = max(high,arr[i]);\\n        }\\n        while(low<high){\\n            int mid = low+(high-low)/2;\\n            int sum =0;\\n            for(int i=0;i<n;i++){\\n                sum+=min(arr[i],mid);\\n            }\\n\\n            if(sum>=target){\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n\\n        int sum1 =0,sum2 =0;\\n        for(int i=0;i<n;i++){\\n            sum1 += min(arr[i],low);\\n            sum2 += min(arr[i],low-1);\\n\\n        }\\n        return abs(sum2-target)<=abs(sum1-target)? low-1:low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361907,
                "title": "binary-search",
                "content": "\\n```\\n\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        low,high = 0,max(max(arr),target//len(arr))\\n        diff = float(\\'inf\\')\\n        ans = 0\\n\\n        def solve(num):\\n            sumi = 0\\n            for i in range(len(arr)):\\n                if arr[i]>num:\\n                    sumi+=num\\n                else:\\n                    sumi+=arr[i]\\n            \\n            return sumi\\n\\n        while low<=high:\\n            mid = (low+high)//2\\n            val = solve(mid)\\n            if abs(val-target)==diff:\\n                ans = min(ans,mid)\\n            if abs(val-target)<diff:\\n                diff = abs(val-target)\\n                ans = mid\\n            if val>=target:\\n                high = mid-1\\n\\n            else:\\n                low = mid+1\\n\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        low,high = 0,max(max(arr),target//len(arr))\\n        diff = float(\\'inf\\')\\n        ans = 0\\n\\n        def solve(num):\\n            sumi = 0\\n            for i in range(len(arr)):\\n                if arr[i]>num:\\n                    sumi+=num\\n                else:\\n                    sumi+=arr[i]\\n            \\n            return sumi\\n\\n        while low<=high:\\n            mid = (low+high)//2\\n            val = solve(mid)\\n            if abs(val-target)==diff:\\n                ans = min(ans,mid)\\n            if abs(val-target)<diff:\\n                diff = abs(val-target)\\n                ans = mid\\n            if val>=target:\\n                high = mid-1\\n\\n            else:\\n                low = mid+1\\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349806,
                "title": "classic-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(vector<int>nums,int target,int mid)\\n    {   int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>mid)\\n            {\\n                sum+=mid;\\n            }else\\n            {\\n                sum+=nums[i];\\n            }\\n        }\\n       return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=*max_element(arr.begin(),arr.end());\\n        int diff=INT_MAX;\\n        int ans=0;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start + (end-start)/2;\\n            int sum=func(arr,target,mid);\\n            if(sum==target)\\n            return mid;\\n            if(sum<target)\\n            {\\n                start=mid+1;\\n                if(abs(sum-target)<diff)\\n                {\\n                    diff=abs(sum-target);\\n                    ans=mid;\\n                }else if(abs(target-sum)==diff)\\n                ans=min(ans,mid);\\n\\n            }else\\n            {\\n                end=mid-1;\\n                 if(abs(sum-target)<diff)\\n                {\\n                    diff=abs(sum-target);\\n                    ans=mid;\\n                }else if(abs(target-sum)==diff)\\n                ans=min(ans,mid);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n//4 , 9,3\\n//diff=1\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<int>nums,int target,int mid)\\n    {   int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>mid)\\n            {\\n                sum+=mid;\\n            }else\\n            {\\n                sum+=nums[i];\\n            }\\n        }\\n       return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=*max_element(arr.begin(),arr.end());\\n        int diff=INT_MAX;\\n        int ans=0;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start + (end-start)/2;\\n            int sum=func(arr,target,mid);\\n            if(sum==target)\\n            return mid;\\n            if(sum<target)\\n            {\\n                start=mid+1;\\n                if(abs(sum-target)<diff)\\n                {\\n                    diff=abs(sum-target);\\n                    ans=mid;\\n                }else if(abs(target-sum)==diff)\\n                ans=min(ans,mid);\\n\\n            }else\\n            {\\n                end=mid-1;\\n                 if(abs(sum-target)<diff)\\n                {\\n                    diff=abs(sum-target);\\n                    ans=mid;\\n                }else if(abs(target-sum)==diff)\\n                ans=min(ans,mid);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n//4 , 9,3\\n//diff=1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336309,
                "title": "binary-search-solution-faster-than-100-java",
                "content": "\\n# Binary Search Solution\\nThe value we are looking for is somewhere between 0 and maxValue (m).\\nNow use Binary search to speed up the process.\\n\\n- go up if the sum is too small\\n- go down if the sum is too big\\n- \\nWhen we are done with binary search, left and right are equal, but it might happen that we have not exactly reached the target.\\nCheck if left - 1 (should get us below the target) leads to the sum closer to the target.\\n\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = arr[0], sum = arr[0], n = arr.length;\\n\\n        for (int i = 1; i < n; i++) {\\n            sum += arr[i];\\n            max = Math.max(arr[i], max);\\n        }\\n\\n        if (sum <= target) return max;\\n\\n        int left = 0, right = max;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            sum = 0;\\n            for (int num : arr) {\\n                sum += (num > mid) ? mid : num;\\n            }\\n            if (sum >= target) right = mid;\\n            else left = mid + 1;\\n        }\\n\\n        int sum1 = 0, sum2 = 0;\\n\\n        for (int num : arr) {\\n            sum1 += (num > left) ? left : num;\\n            sum2 += (num > left - 1) ? left - 1 : num;\\n        }\\n\\n        return (Math.abs(sum2 - target) <= Math.abs(sum1 - target)) ? left - 1: left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max = arr[0], sum = arr[0], n = arr.length;\\n\\n        for (int i = 1; i < n; i++) {\\n            sum += arr[i];\\n            max = Math.max(arr[i], max);\\n        }\\n\\n        if (sum <= target) return max;\\n\\n        int left = 0, right = max;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            sum = 0;\\n            for (int num : arr) {\\n                sum += (num > mid) ? mid : num;\\n            }\\n            if (sum >= target) right = mid;\\n            else left = mid + 1;\\n        }\\n\\n        int sum1 = 0, sum2 = 0;\\n\\n        for (int num : arr) {\\n            sum1 += (num > left) ? left : num;\\n            sum2 += (num > left - 1) ? left - 1 : num;\\n        }\\n\\n        return (Math.abs(sum2 - target) <= Math.abs(sum1 - target)) ? left - 1: left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332144,
                "title": "scala-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def findBestValue(arr: Array[Int], target: Int): Int = {\\n      var sum = 0\\n      var max = Int.MinValue\\n      for (i<-arr) {\\n        sum += i\\n        max = math.max(max, i)\\n      }\\n      \\n      def getMutSum(tmp: Array[Int], mid: Int) = {\\n        var sum = 0\\n        for (i<-tmp) sum += (if (i > mid) mid else i)\\n        sum\\n      }\\n\\n      if (sum == target) max\\n      else {\\n        var min = 0\\n        var res = 1\\n        var diff = Int.MaxValue\\n        while(min <= max) {\\n          val mid = min + (max - min)/2\\n          sum = getMutSum(arr, mid)\\n          if (sum>target) max = mid -1\\n          else min = mid + 1\\n          if (math.abs(sum-target)<diff || (math.abs(sum-target) == diff && mid < res)) {\\n            res = mid\\n            diff = math.abs(sum - target)\\n          }\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def findBestValue(arr: Array[Int], target: Int): Int = {\\n      var sum = 0\\n      var max = Int.MinValue\\n      for (i<-arr) {\\n        sum += i\\n        max = math.max(max, i)\\n      }\\n      \\n      def getMutSum(tmp: Array[Int], mid: Int) = {\\n        var sum = 0\\n        for (i<-tmp) sum += (if (i > mid) mid else i)\\n        sum\\n      }\\n\\n      if (sum == target) max\\n      else {\\n        var min = 0\\n        var res = 1\\n        var diff = Int.MaxValue\\n        while(min <= max) {\\n          val mid = min + (max - min)/2\\n          sum = getMutSum(arr, mid)\\n          if (sum>target) max = mid -1\\n          else min = mid + 1\\n          if (math.abs(sum-target)<diff || (math.abs(sum-target) == diff && mid < res)) {\\n            res = mid\\n            diff = math.abs(sum - target)\\n          }\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3329832,
                "title": "java-solution-prefix-sum-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity:O(n)\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int presum[]=new int[arr.length];\\n        presum[0]=arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            presum[i]=presum[i-1]+arr[i];\\n        }\\n        int i=0;\\n        int min=Integer.MAX_VALUE;\\n        int j=arr[arr.length-1];\\n        int ans=0;\\n        while(i<=j){\\n            int sum=findsum(i,presum,arr,i);\\n            if(min>((int)Math.abs(target-sum))){\\n                min=(int)Math.abs(target-sum);\\n                ans=i;\\n            }\\n            i++;\\n\\n        }\\n        return ans;\\n    }\\n    public static int findsum(int i,int presum[],int arr[],int target){\\n        int index=0;\\n        int start = 0, end = arr.length - 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                break;\\n            };\\n            if (arr[mid] <= target) {\\n                start = mid + 1;\\n            }\\n            else {\\n                index = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        int sum=(arr.length-index)*i;\\n        if(index!=0)\\n        sum+=presum[index-1];\\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        Arrays.sort(arr);\\n        int presum[]=new int[arr.length];\\n        presum[0]=arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            presum[i]=presum[i-1]+arr[i];\\n        }\\n        int i=0;\\n        int min=Integer.MAX_VALUE;\\n        int j=arr[arr.length-1];\\n        int ans=0;\\n        while(i<=j){\\n            int sum=findsum(i,presum,arr,i);\\n            if(min>((int)Math.abs(target-sum))){\\n                min=(int)Math.abs(target-sum);\\n                ans=i;\\n            }\\n            i++;\\n\\n        }\\n        return ans;\\n    }\\n    public static int findsum(int i,int presum[],int arr[],int target){\\n        int index=0;\\n        int start = 0, end = arr.length - 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                break;\\n            };\\n            if (arr[mid] <= target) {\\n                start = mid + 1;\\n            }\\n            else {\\n                index = mid;\\n                end = mid - 1;\\n            }\\n        }\\n        int sum=(arr.length-index)*i;\\n        if(index!=0)\\n        sum+=presum[index-1];\\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280976,
                "title": "o-log-n-2-approach-explained-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nyou can see the code plus a little imporovement on your side could be that rather then summing up in the diff func by iterating over the whole arr you could sort the array pre hand and then precompute the prefix sum of the entire array and then you can just easily do a quick bianry search over the array and then calculate the sum as following:\\n```\\nsum = (size_of_arr - index_just_smaller_than_mid)*mid + pre[index_just_smaller_than_mid]; \\n```\\nand this would just give you what you are trying to find out int the for loop. \\n\\nhere a good thing to notice would be that the time complexity in both the approaches would be same for the simple reason that in the optmized approach you would have to sort the array beforehand and that would cost around nlogn but the 2nd apporach as is described above would be so much better if you are given a sorted array and that could be the case in other problems\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn) can be reduced to O((log(n))^2) + sort\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int diff(int mid, vector<int>& arr, int target)\\n    {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++) sum += min(mid, arr[i]);\\n        return abs(target - sum);\\n    }\\n    int findBestValue(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        int s = 0;\\n        int e = target;\\n        while(s < e)\\n        {\\n            int mid = s + (e - s)/2;\\n            if(diff(mid, arr, target) <= diff(mid + 1, arr, target)) e = mid;\\n            else s = mid + 1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nsum = (size_of_arr - index_just_smaller_than_mid)*mid + pre[index_just_smaller_than_mid]; \\n```\n```\\nclass Solution {\\npublic:\\n    int diff(int mid, vector<int>& arr, int target)\\n    {\\n        int sum = 0;\\n        for(int i = 0; i < arr.size(); i++) sum += min(mid, arr[i]);\\n        return abs(target - sum);\\n    }\\n    int findBestValue(vector<int>& arr, int target)\\n    {\\n        int n = arr.size();\\n        int s = 0;\\n        int e = target;\\n        while(s < e)\\n        {\\n            int mid = s + (e - s)/2;\\n            if(diff(mid, arr, target) <= diff(mid + 1, arr, target)) e = mid;\\n            else s = mid + 1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260972,
                "title": "c-binary-search-16ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=1e5;\\n        int mid=start+(end-start)/2;\\n        int ans=-1;\\n        int diff=INT_MAX;\\n        while(start<=end){\\n            mid=start+(end-start)/2;\\n            int sum=0;\\n            bool temp=0;\\n            for(int i: arr){\\n                if(i>mid) temp=1;\\n                sum+=min(i,mid);    \\n            }\\n            int curr_diff=target-sum;\\n            if(abs(curr_diff)<diff){\\n                diff=abs(curr_diff);\\n                ans=mid;\\n            }\\n            else if(abs(curr_diff)==diff && mid<ans){\\n                ans=mid;\\n            }\\n            if(temp==0 || curr_diff<=0){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int start=0;\\n        int end=1e5;\\n        int mid=start+(end-start)/2;\\n        int ans=-1;\\n        int diff=INT_MAX;\\n        while(start<=end){\\n            mid=start+(end-start)/2;\\n            int sum=0;\\n            bool temp=0;\\n            for(int i: arr){\\n                if(i>mid) temp=1;\\n                sum+=min(i,mid);    \\n            }\\n            int curr_diff=target-sum;\\n            if(abs(curr_diff)<diff){\\n                diff=abs(curr_diff);\\n                ans=mid;\\n            }\\n            else if(abs(curr_diff)==diff && mid<ans){\\n                ans=mid;\\n            }\\n            if(temp==0 || curr_diff<=0){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247009,
                "title": "ordinary-binary-search-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$.\\n\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        self.arr = arr\\n        self.arr.sort()\\n        self.arr.insert(0, 0)\\n        self.prefixSum = [0]*len(self.arr)\\n        for i in range(1, len(self.arr)):\\n            self.prefixSum[i] = self.prefixSum[i-1] + self.arr[i]\\n        \\n        value = None\\n        lValue, rValue = 0, self.arr[-1]\\n        minDiff = math.inf\\n        while lValue <= rValue:\\n            mValue = lValue + (rValue - lValue)//2\\n            diff = self.calcSum(mValue) - target\\n            if abs(diff) < minDiff:\\n                minDiff = abs(diff)\\n                value = mValue\\n            elif abs(diff) == minDiff:\\n                value = min(value, mValue)\\n\\n            if diff == 0:\\n                break\\n            elif diff > 0:\\n                rValue = mValue - 1\\n            else:\\n                lValue = mValue + 1\\n        \\n        return value\\n    \\n\\n    def calcSum(self, value):\\n        ind = None\\n        lInd, rInd = 0, len(self.arr)-1\\n        while lInd <= rInd:\\n            mInd = lInd + (rInd - lInd)//2\\n            if self.arr[mInd] <= value:\\n                ind = mInd\\n                lInd = mInd + 1\\n            else:\\n                rInd = mInd - 1\\n        \\n        return self.prefixSum[ind] + value*(len(self.arr) - ind - 1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        self.arr = arr\\n        self.arr.sort()\\n        self.arr.insert(0, 0)\\n        self.prefixSum = [0]*len(self.arr)\\n        for i in range(1, len(self.arr)):\\n            self.prefixSum[i] = self.prefixSum[i-1] + self.arr[i]\\n        \\n        value = None\\n        lValue, rValue = 0, self.arr[-1]\\n        minDiff = math.inf\\n        while lValue <= rValue:\\n            mValue = lValue + (rValue - lValue)//2\\n            diff = self.calcSum(mValue) - target\\n            if abs(diff) < minDiff:\\n                minDiff = abs(diff)\\n                value = mValue\\n            elif abs(diff) == minDiff:\\n                value = min(value, mValue)\\n\\n            if diff == 0:\\n                break\\n            elif diff > 0:\\n                rValue = mValue - 1\\n            else:\\n                lValue = mValue + 1\\n        \\n        return value\\n    \\n\\n    def calcSum(self, value):\\n        ind = None\\n        lInd, rInd = 0, len(self.arr)-1\\n        while lInd <= rInd:\\n            mInd = lInd + (rInd - lInd)//2\\n            if self.arr[mInd] <= value:\\n                ind = mInd\\n                lInd = mInd + 1\\n            else:\\n                rInd = mInd - 1\\n        \\n        return self.prefixSum[ind] + value*(len(self.arr) - ind - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206677,
                "title": "java-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n   public int findBestValue(int[] arr, int target) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int a : arr) {\\n            sum += a;\\n            max = Math.max(max, a);\\n        }\\n        if (sum == target) return max;\\n        int min = 0, res = 1,diff = Integer.MAX_VALUE;\\n        // The answer would lie between 0 and maximum value in the array.\\n        while (min <= max) {\\n            int mid = min + (max - min) / 2;\\n            sum = getMutatedSum(arr, mid); \\n            if (sum > target) {\\n                max = mid - 1;\\n            } else {\\n                min = mid + 1;\\n            }\\n            // If current difference is less than diff || current difference==diff but mid < res.(choose the smaller one.)\\n            if (Math.abs(sum - target) < diff || (Math.abs(sum - target) == diff && mid < res)) { \\n                res = mid;\\n                diff = Math.abs(sum - target);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int getMutatedSum(int[] arr, int mid) {\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += (a > mid) ? mid : a;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int findBestValue(int[] arr, int target) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int a : arr) {\\n            sum += a;\\n            max = Math.max(max, a);\\n        }\\n        if (sum == target) return max;\\n        int min = 0, res = 1,diff = Integer.MAX_VALUE;\\n        // The answer would lie between 0 and maximum value in the array.\\n        while (min <= max) {\\n            int mid = min + (max - min) / 2;\\n            sum = getMutatedSum(arr, mid); \\n            if (sum > target) {\\n                max = mid - 1;\\n            } else {\\n                min = mid + 1;\\n            }\\n            // If current difference is less than diff || current difference==diff but mid < res.(choose the smaller one.)\\n            if (Math.abs(sum - target) < diff || (Math.abs(sum - target) == diff && mid < res)) { \\n                res = mid;\\n                diff = Math.abs(sum - target);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int getMutatedSum(int[] arr, int mid) {\\n        int sum = 0;\\n        for (int a : arr) {\\n            sum += (a > mid) ? mid : a;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201012,
                "title": "c-binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findSum(vector<int> &arr, int val) {\\n        long long sum = 0;\\n        for(auto &x: arr) sum += min(x, val);\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l =0, r = *max_element(arr.begin(), arr.end());\\n        int left_diff = INT_MAX, right_diff = INT_MAX;\\n        int left_val, right_val;\\n        while(l<=r) {\\n            int mid = (l+r)/2;\\n            \\n            long long sum = findSum(arr, mid);\\n            long long diff = abs(target - sum);\\n            \\n            if(sum < target) {\\n                if(diff < left_diff) {\\n                    left_diff = diff;\\n                    left_val = mid;\\n                }\\n                l = mid+1;\\n            } else {\\n                if(diff < right_diff) {\\n                    right_diff = diff;\\n                    right_val = mid;\\n                }\\n                r = mid-1;\\n            }\\n        }\\n        return (left_diff <= right_diff) ? left_val : right_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findSum(vector<int> &arr, int val) {\\n        long long sum = 0;\\n        for(auto &x: arr) sum += min(x, val);\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l =0, r = *max_element(arr.begin(), arr.end());\\n        int left_diff = INT_MAX, right_diff = INT_MAX;\\n        int left_val, right_val;\\n        while(l<=r) {\\n            int mid = (l+r)/2;\\n            \\n            long long sum = findSum(arr, mid);\\n            long long diff = abs(target - sum);\\n            \\n            if(sum < target) {\\n                if(diff < left_diff) {\\n                    left_diff = diff;\\n                    left_val = mid;\\n                }\\n                l = mid+1;\\n            } else {\\n                if(diff < right_diff) {\\n                    right_diff = diff;\\n                    right_val = mid;\\n                }\\n                r = mid-1;\\n            }\\n        }\\n        return (left_diff <= right_diff) ? left_val : right_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194750,
                "title": "c-binary-search-sorting-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint Sum(vector<int>& arr, int n, int val)\\n{\\n    int s = 0;\\n    for(int i=0 ;i<n ;i++)\\n    s+= min(arr[i],val);\\n    return s;\\n}\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        sort(arr.begin() , arr.end());\\n        int n = arr.size(), mn = INT_MAX, ans = 0;\\n\\n        int sum = 0;\\n        for(int i=0 ;i<n;i++)\\n        sum+=arr[i];\\n        if(sum<=target)\\n        return arr[n-1];\\n\\n        int s = 0 , e = target;\\n        int mid = s+(e-s)/2;\\n\\n        while(s<e)\\n        {\\n            int sm1 = Sum(arr, n, mid);\\n            int sm2 = Sum(arr, n, mid+1);\\n            if(abs(target-sm1) <= abs(target-sm2))\\n            e = mid;\\n            else \\n            s = mid+1;\\n            mid = s+(e-s)/2;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint Sum(vector<int>& arr, int n, int val)\\n{\\n    int s = 0;\\n    for(int i=0 ;i<n ;i++)\\n    s+= min(arr[i],val);\\n    return s;\\n}\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        sort(arr.begin() , arr.end());\\n        int n = arr.size(), mn = INT_MAX, ans = 0;\\n\\n        int sum = 0;\\n        for(int i=0 ;i<n;i++)\\n        sum+=arr[i];\\n        if(sum<=target)\\n        return arr[n-1];\\n\\n        int s = 0 , e = target;\\n        int mid = s+(e-s)/2;\\n\\n        while(s<e)\\n        {\\n            int sm1 = Sum(arr, n, mid);\\n            int sm2 = Sum(arr, n, mid+1);\\n            if(abs(target-sm1) <= abs(target-sm2))\\n            e = mid;\\n            else \\n            s = mid+1;\\n            mid = s+(e-s)/2;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190008,
                "title": "easy-c-o-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int k=0;\\n        int currSum=0;\\n        int len=arr.size();\\n        int j=arr[len-1];\\n        int minDiff=INT_MAX;\\n        int ans=-1;\\n        for(int i=0;i<=j;i++)\\n        {\\n            while(k<len && arr[k]==i){\\n                currSum+=arr[k];\\n                k++;\\n            }\\n            int curr=currSum+(len-k)*i;\\n            if(abs(target-curr)<minDiff)\\n            {\\n                minDiff=abs(target-curr);\\n                ans=i;\\n            }\\n                        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int k=0;\\n        int currSum=0;\\n        int len=arr.size();\\n        int j=arr[len-1];\\n        int minDiff=INT_MAX;\\n        int ans=-1;\\n        for(int i=0;i<=j;i++)\\n        {\\n            while(k<len && arr[k]==i){\\n                currSum+=arr[k];\\n                k++;\\n            }\\n            int curr=currSum+(len-k)*i;\\n            if(abs(target-curr)<minDiff)\\n            {\\n                minDiff=abs(target-curr);\\n                ans=i;\\n            }\\n                        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155973,
                "title": "binary-search-prefix-sum-sorting-python-solution-readable-code",
                "content": "# Complexity\\n- Time complexity: O(nlog(n)) + O(log(n) * log(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        diff_min = (inf, inf)\\n        n = len(arr)\\n        psum = list(itertools.accumulate(arr)) + [0]\\n\\n        left, right = 0 , max(arr)\\n        while left <= right:\\n            mid = (left + right)//2\\n            mid_ind_in_arr = bisect.bisect_left(arr, mid)\\n\\n            \\n            sum_till_mid = psum[mid_ind_in_arr - 1] \\n            right_sum = (n - mid_ind_in_arr) * mid\\n            total = right_sum + sum_till_mid\\n            diff = total - target\\n            \\n            diff_min = min(diff_min, (abs(diff),mid))\\n            if total >= target:\\n                right =  mid -1\\n            else:\\n                left = mid + 1\\n        \\n        return diff_min[1]\\n\\n        \\n       \\n\\n       \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        diff_min = (inf, inf)\\n        n = len(arr)\\n        psum = list(itertools.accumulate(arr)) + [0]\\n\\n        left, right = 0 , max(arr)\\n        while left <= right:\\n            mid = (left + right)//2\\n            mid_ind_in_arr = bisect.bisect_left(arr, mid)\\n\\n            \\n            sum_till_mid = psum[mid_ind_in_arr - 1] \\n            right_sum = (n - mid_ind_in_arr) * mid\\n            total = right_sum + sum_till_mid\\n            diff = total - target\\n            \\n            diff_min = min(diff_min, (abs(diff),mid))\\n            if total >= target:\\n                right =  mid -1\\n            else:\\n                left = mid + 1\\n        \\n        return diff_min[1]\\n\\n        \\n       \\n\\n       \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130533,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0,r=*max_element(arr.begin(), arr.end()),sum=accumulate(arr.begin(), arr.end(), 0);\\n        if(sum<=target){\\n            return r;\\n        }    \\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            int csum=0;\\n            for(auto i:arr){\\n                csum+=(i>mid)?mid:i;\\n            }\\n            if(csum>=target){\\n                r=mid;\\n            } else {\\n                l=mid+1;\\n            }\\n        }\\n        sum=0;\\n        for(auto i:arr){\\n            sum+=(i>l)?l:i;\\n        }\\n        int csum=0;\\n        for(auto i:arr){\\n            csum+=(i>(l-1))?(l-1):i;\\n        }\\n        if(abs(csum-target)<=abs(sum-target)){\\n            return l-1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        curr_sum = 0\\n        n = len(arr)\\n        for i, num in enumerate(arr):\\n            if num*(n-i)+curr_sum > target:\\n                return ceil((target-curr_sum)/(n-i) - 0.5)\\n            curr_sum += num\\n        return arr[-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int arrSum = 0;\\n        for(int num: arr) {\\n            arrSum += num;\\n        }\\n        return binarySearch(0, target, arr, target, arrSum);\\n    }\\n\\n    private int getSum(int[] arr, int num) {\\n        int sum = 0;\\n        for(int curr: arr) {\\n            sum += Math.min(curr, num);\\n        }\\n        return sum;\\n    }\\n\\n    private int binarySearch(int begin, int end, int[] arr, int target, int arrSum) {\\n        if(begin == end) {\\n            return begin;\\n        }\\n        if(end == begin + 1) {\\n            int endSum = getSum(arr, end);\\n            int beginSum = getSum(arr, begin);\\n            if(Math.abs(target - beginSum) <= Math.abs(target - endSum)) {\\n                return begin;\\n            }\\n            return end;\\n        }\\n        int medium = begin + (end - begin) / 2;\\n        int mediumSum = getSum(arr, medium);\\n        if(mediumSum >= target || mediumSum == arrSum) {\\n            return binarySearch(begin, medium, arr, target, arrSum);\\n        }\\n        return binarySearch(medium, end, arr, target, arrSum);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=0,r=*max_element(arr.begin(), arr.end()),sum=accumulate(arr.begin(), arr.end(), 0);\\n        if(sum<=target){\\n            return r;\\n        }    \\n        while(l<r){\\n            int mid=l+(r-l)/2;\\n            int csum=0;\\n            for(auto i:arr){\\n                csum+=(i>mid)?mid:i;\\n            }\\n            if(csum>=target){\\n                r=mid;\\n            } else {\\n                l=mid+1;\\n            }\\n        }\\n        sum=0;\\n        for(auto i:arr){\\n            sum+=(i>l)?l:i;\\n        }\\n        int csum=0;\\n        for(auto i:arr){\\n            csum+=(i>(l-1))?(l-1):i;\\n        }\\n        if(abs(csum-target)<=abs(sum-target)){\\n            return l-1;\\n        }\\n        return l;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        curr_sum = 0\\n        n = len(arr)\\n        for i, num in enumerate(arr):\\n            if num*(n-i)+curr_sum > target:\\n                return ceil((target-curr_sum)/(n-i) - 0.5)\\n            curr_sum += num\\n        return arr[-1]\\n```\n```Java []\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int arrSum = 0;\\n        for(int num: arr) {\\n            arrSum += num;\\n        }\\n        return binarySearch(0, target, arr, target, arrSum);\\n    }\\n\\n    private int getSum(int[] arr, int num) {\\n        int sum = 0;\\n        for(int curr: arr) {\\n            sum += Math.min(curr, num);\\n        }\\n        return sum;\\n    }\\n\\n    private int binarySearch(int begin, int end, int[] arr, int target, int arrSum) {\\n        if(begin == end) {\\n            return begin;\\n        }\\n        if(end == begin + 1) {\\n            int endSum = getSum(arr, end);\\n            int beginSum = getSum(arr, begin);\\n            if(Math.abs(target - beginSum) <= Math.abs(target - endSum)) {\\n                return begin;\\n            }\\n            return end;\\n        }\\n        int medium = begin + (end - begin) / 2;\\n        int mediumSum = getSum(arr, medium);\\n        if(mediumSum >= target || mediumSum == arrSum) {\\n            return binarySearch(begin, medium, arr, target, arrSum);\\n        }\\n        return binarySearch(medium, end, arr, target, arrSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123038,
                "title": "python-binary-search-on-values-beats-97-runtimes-96-in-space",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def bs(self, nums, target, left = None, right = None):\\n        if left is None or right is None:\\n            left, right = 0, len(nums)\\n        while left< right:\\n            mid = (left+right)//2\\n            if nums[mid] < target: left = mid+1\\n            else: right = mid \\n        return left\\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(arr)\\n        mem = [0]*len(nums)\\n        prefix_sum = [0]*len(nums)\\n        prefix_sum[0] = 0\\n        for i in range(1,len(nums)):\\n            prefix_sum[i] = prefix_sum[i-1]+ nums[i-1]\\n\\n        left = 0 \\n        right = max(arr)\\n        res = [right,float(\\'inf\\')]\\n        while left <= right:\\n            mid = (left+right)//2\\n            curr_sum = 0\\n            index = self.bs(nums,mid)\\n            \\n            if index == 0: curr_sum = len(nums)*mid\\n            if index == len(nums): curr_sum = prefix_sum[-1] + nums[-1]\\n            else: curr_sum = prefix_sum[index]+ (len(nums)-index)* mid\\n\\n            curr_res = abs(curr_sum - target)\\n            if curr_res<res[1]:\\n                res = [mid,curr_res]\\n            if curr_res == res[1]:\\n                res[0] = min(res[0],mid)\\n            if curr_sum>=target:\\n                right = mid-1\\n            else: left = mid+1\\n        return res[0]\\n        \\n\\n\\n        \\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def bs(self, nums, target, left = None, right = None):\\n        if left is None or right is None:\\n            left, right = 0, len(nums)\\n        while left< right:\\n            mid = (left+right)//2\\n            if nums[mid] < target: left = mid+1\\n            else: right = mid \\n        return left\\n    def findBestValue(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(arr)\\n        mem = [0]*len(nums)\\n        prefix_sum = [0]*len(nums)\\n        prefix_sum[0] = 0\\n        for i in range(1,len(nums)):\\n            prefix_sum[i] = prefix_sum[i-1]+ nums[i-1]\\n\\n        left = 0 \\n        right = max(arr)\\n        res = [right,float(\\'inf\\')]\\n        while left <= right:\\n            mid = (left+right)//2\\n            curr_sum = 0\\n            index = self.bs(nums,mid)\\n            \\n            if index == 0: curr_sum = len(nums)*mid\\n            if index == len(nums): curr_sum = prefix_sum[-1] + nums[-1]\\n            else: curr_sum = prefix_sum[index]+ (len(nums)-index)* mid\\n\\n            curr_res = abs(curr_sum - target)\\n            if curr_res<res[1]:\\n                res = [mid,curr_res]\\n            if curr_res == res[1]:\\n                res[0] = min(res[0],mid)\\n            if curr_sum>=target:\\n                right = mid-1\\n            else: left = mid+1\\n        return res[0]\\n        \\n\\n\\n        \\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111422,
                "title": "c-brute-force-with-speed-up-22ms",
                "content": "# Intuition\\nSort arr and try value[0, target]. If found the closest value, break out of the loop (the speed up). \\n\\n# Approach\\nFor the speedup part, we maintain a bool \\'smaller\\' initilized to true meaning the current sum is smaller than target. If we found the turning point (i.e. curr sum > target), meaning we have seen the value that\\'s cloest to target (because curr sum will only get bigger as we procedd), thus we stop looping. \\n\\n# Complexity\\n- Time complexity:\\nO(target * len(arr)) worst case\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int ret =0;\\n        int diff =INT_MAX;\\n        bool smaller = true;\\n\\n        sort(arr.begin(), arr.end());\\n\\n        for(int i=0; i<=target; i++){\\n            int sum=0;\\n            for(auto num:arr){\\n                if(num>i) sum+=i;\\n                else sum+=num;\\n            }\\n            if(abs(sum-target) < diff){\\n                diff = abs(sum-target);\\n                ret = i;\\n            }\\n            if(sum < target) smaller = true;\\n            else if(smaller && sum>=target) break;\\n        }\\n        return ret;\\n    }\\n};\\n/*\\nsort \\n{3,4,9}\\ntarget = 10\\n\\nbrute force:\\n1-10\\n1: 1+1+1\\n2: 2+2+2\\n3: 3+3+3=9 -> curr<target \\n4: 3+4+4=11 -> curr>target: turning point! result must be either 3 or 4.\\n5: 3+4+5=12\\n6: 3+4+6=13\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int ret =0;\\n        int diff =INT_MAX;\\n        bool smaller = true;\\n\\n        sort(arr.begin(), arr.end());\\n\\n        for(int i=0; i<=target; i++){\\n            int sum=0;\\n            for(auto num:arr){\\n                if(num>i) sum+=i;\\n                else sum+=num;\\n            }\\n            if(abs(sum-target) < diff){\\n                diff = abs(sum-target);\\n                ret = i;\\n            }\\n            if(sum < target) smaller = true;\\n            else if(smaller && sum>=target) break;\\n        }\\n        return ret;\\n    }\\n};\\n/*\\nsort \\n{3,4,9}\\ntarget = 10\\n\\nbrute force:\\n1-10\\n1: 1+1+1\\n2: 2+2+2\\n3: 3+3+3=9 -> curr<target \\n4: 3+4+4=11 -> curr>target: turning point! result must be either 3 or 4.\\n5: 3+4+5=12\\n6: 3+4+6=13\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111420,
                "title": "c-brute-force-with-speed-up-22ms",
                "content": "# Intuition\\nSort arr and try value[0, target]. If found the closest value, break out of the loop (the speed up). \\n\\n# Approach\\nFor the speedup part, we maintain a bool \\'smaller\\' initilized to true meaning the current sum is smaller than target. If we found the turning point (i.e. curr sum > target), meaning we have seen the value that\\'s cloest to target (because curr sum will only get bigger as we procedd), thus we stop looping. \\n\\n# Complexity\\n- Time complexity:\\nO(target * len(arr)) worst case\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int ret =0;\\n        int diff =INT_MAX;\\n        bool smaller = true;\\n\\n        sort(arr.begin(), arr.end());\\n\\n        for(int i=0; i<=target; i++){\\n            int sum=0;\\n            for(auto num:arr){\\n                if(num>i) sum+=i;\\n                else sum+=num;\\n            }\\n            if(abs(sum-target) < diff){\\n                diff = abs(sum-target);\\n                ret = i;\\n            }\\n            if(sum < target) smaller = true;\\n            else if(smaller && sum>=target) break;\\n        }\\n        return ret;\\n    }\\n};\\n/*\\nsort \\n{3,4,9}\\ntarget = 10\\n\\nbrute force:\\n1-10\\n1: 1+1+1\\n2: 2+2+2\\n3: 3+3+3=9 -> curr<target \\n4: 3+4+4=11 -> curr>target: turning point! result must be either 3 or 4.\\n5: 3+4+5=12\\n6: 3+4+6=13\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int ret =0;\\n        int diff =INT_MAX;\\n        bool smaller = true;\\n\\n        sort(arr.begin(), arr.end());\\n\\n        for(int i=0; i<=target; i++){\\n            int sum=0;\\n            for(auto num:arr){\\n                if(num>i) sum+=i;\\n                else sum+=num;\\n            }\\n            if(abs(sum-target) < diff){\\n                diff = abs(sum-target);\\n                ret = i;\\n            }\\n            if(sum < target) smaller = true;\\n            else if(smaller && sum>=target) break;\\n        }\\n        return ret;\\n    }\\n};\\n/*\\nsort \\n{3,4,9}\\ntarget = 10\\n\\nbrute force:\\n1-10\\n1: 1+1+1\\n2: 2+2+2\\n3: 3+3+3=9 -> curr<target \\n4: 3+4+4=11 -> curr>target: turning point! result must be either 3 or 4.\\n5: 3+4+5=12\\n6: 3+4+6=13\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080079,
                "title": "c-sorting-prefix-sum-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int tar) {\\n        sort(arr.begin(),arr.end());\\n        int tsum=0;\\n        int n = arr.size();\\n        for(auto i:arr)\\n        tsum+=i;\\n        vector<int> pref(n);\\n        pref[0] = arr[0];\\n        for(int i=1;i<n;i++)\\n        pref[i] = pref[i-1]+arr[i];\\n        int l = 0,r = arr[n-1];\\n        int ans=INT_MAX;\\n        int fans=0;\\n        for(int i=l;i<=r;i++)\\n        {\\n            int idx = upper_bound(arr.begin(),arr.end(),i)-arr.begin();\\n            if(idx==n)\\n            {\\n                if(tsum>tar)\\n                {\\n                    if(ans>tsum-tar)\\n                    {\\n                        ans = tsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tsum)\\n                    {\\n                        ans = tar-tsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n            else if(idx==0)\\n            {\\n                int tmpsum = n*i;\\n                if(tmpsum>tar)\\n                {\\n                    if(ans>tmpsum-tar)\\n                    {\\n                        ans = tmpsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tmpsum)\\n                    {\\n                        ans = tar-tmpsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                int tmp = pref[n-1]-pref[idx-1];\\n                int tmpsum = tsum-tmp;\\n                tmpsum+=(n-idx)*i;\\n                if(tmpsum>tar)\\n                {\\n                    if(ans>tmpsum-tar)\\n                    {\\n                        ans = tmpsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tmpsum)\\n                    {\\n                        ans = tar-tmpsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n        }\\n        return fans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int tar) {\\n        sort(arr.begin(),arr.end());\\n        int tsum=0;\\n        int n = arr.size();\\n        for(auto i:arr)\\n        tsum+=i;\\n        vector<int> pref(n);\\n        pref[0] = arr[0];\\n        for(int i=1;i<n;i++)\\n        pref[i] = pref[i-1]+arr[i];\\n        int l = 0,r = arr[n-1];\\n        int ans=INT_MAX;\\n        int fans=0;\\n        for(int i=l;i<=r;i++)\\n        {\\n            int idx = upper_bound(arr.begin(),arr.end(),i)-arr.begin();\\n            if(idx==n)\\n            {\\n                if(tsum>tar)\\n                {\\n                    if(ans>tsum-tar)\\n                    {\\n                        ans = tsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tsum)\\n                    {\\n                        ans = tar-tsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n            else if(idx==0)\\n            {\\n                int tmpsum = n*i;\\n                if(tmpsum>tar)\\n                {\\n                    if(ans>tmpsum-tar)\\n                    {\\n                        ans = tmpsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tmpsum)\\n                    {\\n                        ans = tar-tmpsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                int tmp = pref[n-1]-pref[idx-1];\\n                int tmpsum = tsum-tmp;\\n                tmpsum+=(n-idx)*i;\\n                if(tmpsum>tar)\\n                {\\n                    if(ans>tmpsum-tar)\\n                    {\\n                        ans = tmpsum-tar;\\n                        fans = i;\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans>tar-tmpsum)\\n                    {\\n                        ans = tar-tmpsum;\\n                        fans = i;\\n                    }\\n                }\\n            }\\n        }\\n        return fans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078385,
                "title": "python-solution-beats-99-with-explanation-and-complexities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The problem is asking to find the value that minimizes the absolute difference between the sum of elements in the array that are less or equal to that value, and the given target value.\\n- The first thought would be to iterate through all possible values and check the absolute difference for each one, and return the value that results in the minimum difference.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The approach used in the provided code is a binary search algorithm.\\n- It starts by sorting the array, and then using bisect_right to find the index of the first element that is greater than the mid value.\\n- Then it calculates the sum of elements in the array that are less than or equal to the mid value and the difference between that sum and the target.\\n- It compares this difference with the previous minimum difference and updates the result if necessary.\\n- The process is repeated until the left pointer is greater than the right pointer.\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nas the bisect.bisect_right has logarithmic time complexity and it is called n times in the while loop.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nas it uses only a few variables and the algorithm is in-place.\\n# Code\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        n = len(arr)\\n        diff = float(\\'inf\\')\\n        res = -1\\n        l = 0\\n        r = arr[-1]\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            idx = bisect.bisect_right(arr, mid)\\n            sum1 = sum(arr[:idx]) + ((n - idx) * mid)\\n            \\n            if sum1 < target:\\n                l = mid + 1\\n            elif sum1 >= target:\\n                r = mid - 1\\n                \\n            d = abs(sum1 - target)\\n            if d < diff or (d == diff and mid < res):\\n                diff = d\\n                res = mid\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr.sort()\\n        n = len(arr)\\n        diff = float(\\'inf\\')\\n        res = -1\\n        l = 0\\n        r = arr[-1]\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            idx = bisect.bisect_right(arr, mid)\\n            sum1 = sum(arr[:idx]) + ((n - idx) * mid)\\n            \\n            if sum1 < target:\\n                l = mid + 1\\n            elif sum1 >= target:\\n                r = mid - 1\\n                \\n            d = abs(sum1 - target)\\n            if d < diff or (d == diff and mid < res):\\n                diff = d\\n                res = mid\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069859,
                "title": "my-thoughts-for-this-question-in-binary-search",
                "content": "\\n# Intuition\\nFinding value one by one untill I find sum of modified array is as closest as target seems to be a costly affair.\\n\\nBut think like this \\nvalue \\u221D currSum that means monotonic\\n\\n# Terminology:\\nvalue,target,arr -> explained in question\\ns -> start index\\ne -> end index\\nmaxm -> maximum value possible\\nmid -> value considered as of now to calculate currSum\\ncurrSum -> current sum of the array for current mid\\n\\n# Approach\\nnow when we have to replace all that are greater so in the array\\n[2, 3, 5] going to 6, does it make sense?\\n\\nnow our answer must lie in 0 to maximum of the array, as value is replacing all that is greater in the array.\\n\\nFind mid from 0 to maximumElement and check of nearest possible from target.\\n\\nif I get currSum < target -> increase currSum by s = mid+1 & vice versa.\\n\\nAt last only competitor is s and s - 1 -> check them seperatly.\\n\\n# Complexity\\n- Time complexity: $$O(nlog(maxmEle))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNote: I am solving january daily leetcode challange\\'23, every day on my youtube channel. link: https://www.youtube.com/@hemantranjan2297/videos\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum(vector<int>&a,int m){\\n        int sum = 0;\\n        for(auto ele:a){\\n            if(ele>m){\\n                sum += m;\\n            }else sum += ele;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int n =arr.size(), maxm =-1;\\n        //finding max in array\\n        for(int i =0;i<n;i++){\\n            maxm = max(maxm,arr[i]);\\n        }\\n        \\n        //the momnet I thought value is directly proportion \\n        //to currSum and that\\'s a monotnous relation\\n        so value must be found via binary search\\n        */\\n        int s = 0, e = maxm;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            int currSum = sum(arr,mid);//curr sum for current value if taken.\\n            if(currSum == target)return mid;//if(currSum == target) that is nearest, so return that value\\n            else if(currSum>target) e = mid-1;//if(currSum > target) then reduse value to get smaller currSum\\n            else s = mid+1; // at last value should increase to currSum\\n        }\\n        if(abs(target-sum(arr,s-1))>abs(target-sum(arr,s)))return s;\\n        return s-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(vector<int>&a,int m){\\n        int sum = 0;\\n        for(auto ele:a){\\n            if(ele>m){\\n                sum += m;\\n            }else sum += ele;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        \\n        int n =arr.size(), maxm =-1;\\n        //finding max in array\\n        for(int i =0;i<n;i++){\\n            maxm = max(maxm,arr[i]);\\n        }\\n        \\n        //the momnet I thought value is directly proportion \\n        //to currSum and that\\'s a monotnous relation\\n        so value must be found via binary search\\n        */\\n        int s = 0, e = maxm;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            int currSum = sum(arr,mid);//curr sum for current value if taken.\\n            if(currSum == target)return mid;//if(currSum == target) that is nearest, so return that value\\n            else if(currSum>target) e = mid-1;//if(currSum > target) then reduse value to get smaller currSum\\n            else s = mid+1; // at last value should increase to currSum\\n        }\\n        if(abs(target-sum(arr,s-1))>abs(target-sum(arr,s)))return s;\\n        return s-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045656,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&arr,int &mid)\\n    {\\n        int sum=0;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            if (arr[i]>mid)\\n            sum+=mid;\\n            else sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) \\n    {\\n        int mini;\\n        int sum=0;\\n        int ans=INT_MIN;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            sum+=arr[i];\\n            ans=max(ans,arr[i]);\\n        }\\n        //cout<<sum;\\n        mini=abs(sum-target);\\n        int low=0;\\n        int high=target;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int val=helper(arr,mid);\\n            if (val>=target)\\n           {\\n               high=mid-1;\\n           }\\n           else\\n           {\\n               low=mid+1;\\n           }\\n           if (mini>abs(target-val))\\n           {\\n           ans=mid;\\n           mini=abs(target-val);\\n           }\\n           if (mini==abs(target-val) && mid<ans) // so that we get   minimum value \\n           ans=mid;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&arr,int &mid)\\n    {\\n        int sum=0;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            if (arr[i]>mid)\\n            sum+=mid;\\n            else sum+=arr[i];\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) \\n    {\\n        int mini;\\n        int sum=0;\\n        int ans=INT_MIN;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            sum+=arr[i];\\n            ans=max(ans,arr[i]);\\n        }\\n        //cout<<sum;\\n        mini=abs(sum-target);\\n        int low=0;\\n        int high=target;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int val=helper(arr,mid);\\n            if (val>=target)\\n           {\\n               high=mid-1;\\n           }\\n           else\\n           {\\n               low=mid+1;\\n           }\\n           if (mini>abs(target-val))\\n           {\\n           ans=mid;\\n           mini=abs(target-val);\\n           }\\n           if (mini==abs(target-val) && mid<ans) // so that we get   minimum value \\n           ans=mid;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3032284,
                "title": "binary-search-solution-with-intuition-c-beats-99-69",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe answer will lie on the range L = 1 to R = (max element of the array).\\nSo, we will apply binary search on this range taking mid as the ```\\nvalue```.\\n\\nOur predicate function will check if the difference = ```target``` - (sum of the elements of the array after replacing all the values with mid if mid<arr[i]) is positive or negative. If the difference is equal to zero, we will return the mid as it is the best possible answer.\\n\\nThis will finally divide the array into two parts:\\n```\\n// Initially\\nL                                                            R\\nv                                                            v\\n[      predicate==false      ] [       predicate==true       ]\\n\\n// Finally\\n                             R L                                \\n                             v v                               \\n[      predicate==false      ] [       predicate==true       ]\\n```\\nFinally, we need to check if the value at R or L is the best possible answer. If a tie occurs, we need to return R(minimum answer).\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int predicate(vector<int>& arr, int target, int m){\\n        int sum=0;\\n        for(auto i:arr){\\n            if(i>m) sum+=m;\\n            else sum+=i;\\n        }\\n        return sum - target;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=1,r=INT_MIN;\\n        for(auto i:arr) r=max(r,i);\\n        while(l<=r){\\n            int m = l + (r-l)/2;\\n            if(predicate(arr,target,m)>0) r=m-1; \\n            else if(predicate(arr,target,m)==0) return m; //Return this mid as this is the best possible answer.\\n            else l=m+1;\\n        }\\n        int sum_l=0;\\n        int sum_r=0;\\n        for(auto i:arr){\\n            if(i>l) sum_l+=l;\\n            else sum_l+=i;\\n            if(i>r) sum_r+=r;\\n            else sum_r+=i;\\n        }\\n        if(abs(target-sum_l)>=abs(target-sum_r) ) return r;\\n        else return l;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvalue```\n```target```\n```\\n// Initially\\nL                                                            R\\nv                                                            v\\n[      predicate==false      ] [       predicate==true       ]\\n\\n// Finally\\n                             R L                                \\n                             v v                               \\n[      predicate==false      ] [       predicate==true       ]\\n```\n```\\nclass Solution {\\npublic:\\n    int predicate(vector<int>& arr, int target, int m){\\n        int sum=0;\\n        for(auto i:arr){\\n            if(i>m) sum+=m;\\n            else sum+=i;\\n        }\\n        return sum - target;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l=1,r=INT_MIN;\\n        for(auto i:arr) r=max(r,i);\\n        while(l<=r){\\n            int m = l + (r-l)/2;\\n            if(predicate(arr,target,m)>0) r=m-1; \\n            else if(predicate(arr,target,m)==0) return m; //Return this mid as this is the best possible answer.\\n            else l=m+1;\\n        }\\n        int sum_l=0;\\n        int sum_r=0;\\n        for(auto i:arr){\\n            if(i>l) sum_l+=l;\\n            else sum_l+=i;\\n            if(i>r) sum_r+=r;\\n            else sum_r+=i;\\n        }\\n        if(abs(target-sum_l)>=abs(target-sum_r) ) return r;\\n        else return l;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002758,
                "title": "python-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def count(num):\\n            res = 0\\n            for i in range(len(arr)):res += min(num,arr[i])\\n            return res\\n\\n        l = 0\\n        r = target\\n        last_m = float(\"inf\")\\n        min_diff = float(\"inf\")\\n        res = 0\\n\\n        while l <= r:\\n            m = int((l+r)/2)\\n            diff = target-count(m)\\n            \\n            if diff > 0:\\n                l = m+1\\n            elif diff < 0:\\n                r = m-1\\n                \\n            if abs(diff) < min_diff:\\n                res = m\\n                min_diff = abs(diff)\\n            elif abs(diff) == min_diff:\\n                if m > res:res = m\\n                \\n            if last_m == m: break\\n            last_m = m\\n        \\n        cur = res\\n        while True:\\n            cur -=1\\n            diff = target-count(cur)\\n            if abs(diff) <= min_diff:\\n                min_diff = abs(diff)\\n                res = cur\\n            else:break\\n            \\n        cur = res\\n        while True:\\n            cur +=1\\n            diff = target-count(cur)\\n            if abs(diff) < min_diff:\\n                min_diff = abs(diff)\\n                res = cur\\n            else:break\\n        \\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        def count(num):\\n            res = 0\\n            for i in range(len(arr)):res += min(num,arr[i])\\n            return res\\n\\n        l = 0\\n        r = target\\n        last_m = float(\"inf\")\\n        min_diff = float(\"inf\")\\n        res = 0\\n\\n        while l <= r:\\n            m = int((l+r)/2)\\n            diff = target-count(m)\\n            \\n            if diff > 0:\\n                l = m+1\\n            elif diff < 0:\\n                r = m-1\\n                \\n            if abs(diff) < min_diff:\\n                res = m\\n                min_diff = abs(diff)\\n            elif abs(diff) == min_diff:\\n                if m > res:res = m\\n                \\n            if last_m == m: break\\n            last_m = m\\n        \\n        cur = res\\n        while True:\\n            cur -=1\\n            diff = target-count(cur)\\n            if abs(diff) <= min_diff:\\n                min_diff = abs(diff)\\n                res = cur\\n            else:break\\n            \\n        cur = res\\n        while True:\\n            cur +=1\\n            diff = target-count(cur)\\n            if abs(diff) < min_diff:\\n                min_diff = abs(diff)\\n                res = cur\\n            else:break\\n        \\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969866,
                "title": "bs",
                "content": "**Linearithmic time / range binary search**\\n**time: `O(N log R)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/19f95818-d839-4568-b1e3-ae4656ebe55e_1672411558.8841085.png)\\n\\n![image](https://assets.leetcode.com/users/images/1c96edbe-68f3-4e47-8a08-c6733bba9f0b_1672411937.3978314.png)\\n\\n```\\nint findBestValue(vector<int>& aa, int t)\\n{\\n\\tint l{};\\n\\tfor(int h{100001}; l+1<h; )\\n\\t{\\n\\t\\tint m=(l+h)/2;\\n\\t\\tint x{}, y{};\\n\\t\\tfor(const auto & a : aa) x+=min(a,m-1), y+=min(a,m); \\n\\t\\t(abs(t-y)<abs(t-x) ? l : h) = m;\\n\\t}\\n\\treturn l;  \\n}\\n```\\n||\\n```\\nint findBestValue(vector<int>& a, int t)\\n{\\n\\tint l{};\\n    const int & (*_min)(const int &, const int &) = min<int>; // c++ facepalm\\n\\tauto f = [&](int x){ return abs(t-transform_reduce(begin(a), end(a), 0, plus{}, bind(_min, placeholders::_1, x))); };\\n\\tfor(int h{100001}; l+1<h; )\\n\\t{\\n\\t\\tint m=(l+h)/2;\\n\\t\\t(f(m)<f(m-1) ? l : h) = m;\\n\\t}\\n\\treturn l;  \\n}\\n```\\n`c++ facepalm =` https://stackoverflow.com/questions/47109317/cant-pass-stdmin-to-function-copy-of-stdmin-works\\n\\n**Explanation:**\\nSuch problems follow the following scheme:\\n\\n![image](https://assets.leetcode.com/users/images/c975b436-a7d8-4ec0-a31d-503d0e666ea0_1672413842.145775.png)\\n\\n\\n**Similar problems:**\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/2053517/bs?currentPage=1&orderBy=most_relevant&query=android)\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2963593/bs)\\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/discuss/2127417/binary-search)\\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/discuss/1676227/binary-search)\\n[1300. Sum of Mutated Array Closest to Target](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/discuss/2969866/bs)\\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/3251398/ok)\\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/discuss/3251393/ok)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/3253585/bs)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/3254564/bs)\\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/3807049/bs)\\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/3808940/bs)\\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/discuss/3945204/range-bs)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findBestValue(vector<int>& aa, int t)\\n{\\n\\tint l{};\\n\\tfor(int h{100001}; l+1<h; )\\n\\t{\\n\\t\\tint m=(l+h)/2;\\n\\t\\tint x{}, y{};\\n\\t\\tfor(const auto & a : aa) x+=min(a,m-1), y+=min(a,m); \\n\\t\\t(abs(t-y)<abs(t-x) ? l : h) = m;\\n\\t}\\n\\treturn l;  \\n}\\n```\n```\\nint findBestValue(vector<int>& a, int t)\\n{\\n\\tint l{};\\n    const int & (*_min)(const int &, const int &) = min<int>; // c++ facepalm\\n\\tauto f = [&](int x){ return abs(t-transform_reduce(begin(a), end(a), 0, plus{}, bind(_min, placeholders::_1, x))); };\\n\\tfor(int h{100001}; l+1<h; )\\n\\t{\\n\\t\\tint m=(l+h)/2;\\n\\t\\t(f(m)<f(m-1) ? l : h) = m;\\n\\t}\\n\\treturn l;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2963091,
                "title": "python-binary-search-solution-faster-than-82-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefine a lower limit ```left``` and upper limit ```right```, check if all numbers larger than ```mid = (left + right) / 2``` are changed to ```mid```, can we achieve a sum closer to target. Then adjust the ```mid``` according to if the given sum is bigger or smaller than ```target```. Update ```left``` and ```right``` by Binary Search logic\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        sm, ans = sum(arr), max(arr)\\n        diff, ideal = abs(sm - target), target // len(arr)\\n        if sm <= target:\\n            return ans\\n        left, right = ideal, ans\\n        while left <= right:\\n            mid, tempSum = (left + right) // 2, 0\\n            for num in arr:\\n                if num > mid: tempSum += mid\\n                else: tempSum += num\\n            if diff > abs(target - tempSum):\\n                ans, diff = mid, abs(target - tempSum)\\n            elif diff == abs(target - tempSum):\\n                ans = min(ans, mid)\\n            if tempSum >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```left```\n```right```\n```mid = (left + right) / 2```\n```mid```\n```mid```\n```target```\n```left```\n```right```\n```python []\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        sm, ans = sum(arr), max(arr)\\n        diff, ideal = abs(sm - target), target // len(arr)\\n        if sm <= target:\\n            return ans\\n        left, right = ideal, ans\\n        while left <= right:\\n            mid, tempSum = (left + right) // 2, 0\\n            for num in arr:\\n                if num > mid: tempSum += mid\\n                else: tempSum += num\\n            if diff > abs(target - tempSum):\\n                ans, diff = mid, abs(target - tempSum)\\n            elif diff == abs(target - tempSum):\\n                ans = min(ans, mid)\\n            if tempSum >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903564,
                "title": "ruby-with-binary-search",
                "content": "```ruby\\ndef find_best_value(arr, target)\\n  right = arr.max\\n  left = (1..right).bsearch { |mid| val_sum(arr, mid) >= target } || right\\n\\n  left_val_sum_diff = (val_sum(arr, left) - target).abs\\n  # left - 1 might have a difference smaller than left\\n  cand_val_sum_diff = (val_sum(arr, left - 1) - target).abs\\n   \\n  # if so, return left - 1 instead\\n  cand_val_sum_diff <= left_val_sum_diff ? left - 1 : left\\nend\\n\\ndef val_sum(arr, val)\\n  arr.map { |num| num > val ? val : num }.sum\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```ruby\\ndef find_best_value(arr, target)\\n  right = arr.max\\n  left = (1..right).bsearch { |mid| val_sum(arr, mid) >= target } || right\\n\\n  left_val_sum_diff = (val_sum(arr, left) - target).abs\\n  # left - 1 might have a difference smaller than left\\n  cand_val_sum_diff = (val_sum(arr, left - 1) - target).abs\\n   \\n  # if so, return left - 1 instead\\n  cand_val_sum_diff <= left_val_sum_diff ? left - 1 : left\\nend\\n\\ndef val_sum(arr, val)\\n  arr.map { |num| num > val ? val : num }.sum\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2863550,
                "title": "simple-solution-using-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        // the idea is to decrease numbers so that we get sum near to target\\n        int ans = 0;\\n        int dif = 0;\\n        int sum = 0;\\n        for(int x: arr){ sum += x; ans = max(ans,x); }\\n        dif = abs(sum - target);\\n        if(sum <= target) return ans;\\n        int right = ans;\\n        int ideal = target/arr.size();\\n        int left = ideal;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            // cout<<mid<<endl;\\n            int lsum = 0;\\n            for(int x: arr){\\n                if(x > mid) lsum += mid;\\n                else lsum += x;\\n            }\\n            if(dif > abs(target - lsum)){ \\n                dif = abs(target - lsum);\\n                ans = mid;\\n            }\\n            if(dif == abs(target - lsum)) ans = min(ans,mid);\\n            if(lsum >= target){\\n                right = mid - 1;\\n            }else{\\n                \\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        // the idea is to decrease numbers so that we get sum near to target\\n        int ans = 0;\\n        int dif = 0;\\n        int sum = 0;\\n        for(int x: arr){ sum += x; ans = max(ans,x); }\\n        dif = abs(sum - target);\\n        if(sum <= target) return ans;\\n        int right = ans;\\n        int ideal = target/arr.size();\\n        int left = ideal;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            // cout<<mid<<endl;\\n            int lsum = 0;\\n            for(int x: arr){\\n                if(x > mid) lsum += mid;\\n                else lsum += x;\\n            }\\n            if(dif > abs(target - lsum)){ \\n                dif = abs(target - lsum);\\n                ans = mid;\\n            }\\n            if(dif == abs(target - lsum)) ans = min(ans,mid);\\n            if(lsum >= target){\\n                right = mid - 1;\\n            }else{\\n                \\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2852386,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n\\n        def getSum(arr, threshold):\\n            res = count = 0\\n            value = inf\\n            for n in arr:\\n                if n > threshold:\\n                    res += threshold\\n                else:\\n                    res += n\\n            return res\\n\\n        left, right = target // len(arr) - 1, max(arr)\\n        larger_dis = inf\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            val = getSum(arr, mid)\\n            if val >= target:\\n                right = mid\\n                larger_dis = val - target\\n            else:\\n                left  = mid + 1\\n        larger_val = right\\n\\n        left, right = target // len(arr) - 1, max(arr)\\n        smaller_dis = inf\\n        while left < right:\\n            mid = left + (right - left + 1) // 2\\n            val = getSum(arr, mid)\\n            if val <= target:\\n                left = mid\\n                smaller_dis = target - val\\n            else:\\n                right = mid - 1\\n        smaller_val = left\\n\\n        if larger_dis == smaller_dis:\\n            return min(smaller_val, larger_val)\\n        elif larger_dis < smaller_dis:\\n            return larger_val\\n        else:\\n            return smaller_val\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n\\n        def getSum(arr, threshold):\\n            res = count = 0\\n            value = inf\\n            for n in arr:\\n                if n > threshold:\\n                    res += threshold\\n                else:\\n                    res += n\\n            return res\\n\\n        left, right = target // len(arr) - 1, max(arr)\\n        larger_dis = inf\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            val = getSum(arr, mid)\\n            if val >= target:\\n                right = mid\\n                larger_dis = val - target\\n            else:\\n                left  = mid + 1\\n        larger_val = right\\n\\n        left, right = target // len(arr) - 1, max(arr)\\n        smaller_dis = inf\\n        while left < right:\\n            mid = left + (right - left + 1) // 2\\n            val = getSum(arr, mid)\\n            if val <= target:\\n                left = mid\\n                smaller_dis = target - val\\n            else:\\n                right = mid - 1\\n        smaller_val = left\\n\\n        if larger_dis == smaller_dis:\\n            return min(smaller_val, larger_val)\\n        elif larger_dis < smaller_dis:\\n            return larger_val\\n        else:\\n            return smaller_val\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825155,
                "title": "python3-sorting-binary-search",
                "content": "\\n```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr = sorted(arr)\\n        n = len(arr)\\n        suffixSum = [0 for i in range(n)]\\n        totalSum = 0\\n        for i in range(n-1,-1,-1):\\n            suffixSum[i] = suffixSum[i+1] + arr[i] if i < n-1 else arr[i]\\n            totalSum += arr[i]\\n        low,high = 0,max(arr)\\n        ans = math.inf\\n        diff = math.inf\\n        while low <= high:\\n            mid = (low+high)//2\\n            ind = bisect.bisect_right(arr,mid)\\n            currentSum = totalSum - suffixSum[ind] + (n-ind) * mid if ind < n else totalSum\\n            if currentSum >= target:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n            if abs(currentSum - target) < diff:\\n                ans = mid\\n                diff = abs(currentSum - target)\\n            elif abs(currentSum - target) == diff:\\n                ans = min(mid,ans)\\n        return ans\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Suffix Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findBestValue(self, arr: List[int], target: int) -> int:\\n        arr = sorted(arr)\\n        n = len(arr)\\n        suffixSum = [0 for i in range(n)]\\n        totalSum = 0\\n        for i in range(n-1,-1,-1):\\n            suffixSum[i] = suffixSum[i+1] + arr[i] if i < n-1 else arr[i]\\n            totalSum += arr[i]\\n        low,high = 0,max(arr)\\n        ans = math.inf\\n        diff = math.inf\\n        while low <= high:\\n            mid = (low+high)//2\\n            ind = bisect.bisect_right(arr,mid)\\n            currentSum = totalSum - suffixSum[ind] + (n-ind) * mid if ind < n else totalSum\\n            if currentSum >= target:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n            if abs(currentSum - target) < diff:\\n                ans = mid\\n                diff = abs(currentSum - target)\\n            elif abs(currentSum - target) == diff:\\n                ans = min(mid,ans)\\n        return ans\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814034,
                "title": "c-simple-binary-search-easy-to-understand",
                "content": "### *Upvote*\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr,int& target,int mid){\\n        int sum = 0;\\n        for(auto & it : arr){\\n            sum += min(it,mid);\\n        }\\n        return abs(sum - target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int diff = INT_MAX;\\n        int start = 0;\\n        int end = target;\\n        int ans = -1;\\n        while(start <= end){\\n            int mid = start + ((end - start) >> 1);\\n            if(solve(arr,target,mid) <= solve(arr,target,mid+1)){\\n                end = mid-1;\\n                ans = mid;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr,int& target,int mid){\\n        int sum = 0;\\n        for(auto & it : arr){\\n            sum += min(it,mid);\\n        }\\n        return abs(sum - target);\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int diff = INT_MAX;\\n        int start = 0;\\n        int end = target;\\n        int ans = -1;\\n        while(start <= end){\\n            int mid = start + ((end - start) >> 1);\\n            if(solve(arr,target,mid) <= solve(arr,target,mid+1)){\\n                end = mid-1;\\n                ans = mid;\\n            }else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786633,
                "title": "typescript-solution-commented",
                "content": "# Intuition\\nIt wasn\\'t very intuitive. It took me like an hour to end up with a solution. After 30mins of trying different techniques, I decided to evaluate this problem as a function to optimize because we have a target and a variable to find.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI defined variables to formulate an objective function:\\n- m: variable that we are looking for\\n- changes: number of variables in the array that are bigger than \"m\"\\n- restSum: sum of the variables of the array that are less or equal to \"m\"\\n- target: target variable used to evaluate \"m\"\\n\\nObjective function: (changes * m) + restSum <= target\\n\\nIn each loop I calculate a new \"m\" to see if the number of changes available decreases or not. In case where the number of changes decrease, then I calculate a new \"m\" otherwise I procede to evaluate the end result of my equation.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ / $$O(n^2)$$\\n\\nThe loops to get the best \"m\" nevers gonna be equal to the length of the array so it cannot be O(n^2) but it can be close to it in the worst cases. If I\\'m wrong please let me know.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Results\\n- 132 ms / 44.6mb\\n\\n# Code\\n```\\nfunction findBestValue(arr: number[], target: number): number {\\n    // Using Least Common Multiple as basis\\n    let m = Math.floor(target/arr.length)\\n    let changes = 0\\n    \\n    while(true){\\n        // Define and clear variables\\n        let prevChanges = changes\\n        let restSum = 0\\n        let totalSum = 0\\n        changes = 0\\n\\n        // Calculate number of possible changes, restSum and totalSum\\n        for(let i = 0; i< arr.length; i++) {\\n            // if m > arr[i], means that arr[i] can be changed by m\\n            if(arr[i] > m) {\\n                changes++\\n            } else {\\n                // if cannot be changed, then I accumulate the number\\n                restSum += arr[i]\\n            }\\n            // totalSum is only used when there is only one change available\\n            totalSum += arr[i]\\n        }\\n\\n        // If there aren\\'t changes available return the biggest number of the array\\n        if(changes === 0) {\\n            return Math.max(...arr)\\n        }\\n\\n        // If there is only one change available\\n        if(changes === 1) {\\n            let x = target - restSum\\n            let y = totalSum - restSum\\n            if(x > y) return y\\n            return x\\n        }\\n\\n        // If the number of changes available is the same with the prevChanges, \\n        //then I it means that m is a candidate.\\n        if(prevChanges === changes) {\\n            // Because m is calculated with a division and I use only the integer, there is a \\n            // posibility that the value was closer to the next integer, so I try both cases.\\n            let result1 = Math.abs((m * changes) + restSum - target)\\n            let result2 = Math.abs(((m+1) * changes) + restSum - target)\\n\\n            return result2 >= result1 ? m : m + 1\\n        }\\n\\n        // update the value to minimize the result\\n        m = Math.floor((target - restSum)/changes)\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findBestValue(arr: number[], target: number): number {\\n    // Using Least Common Multiple as basis\\n    let m = Math.floor(target/arr.length)\\n    let changes = 0\\n    \\n    while(true){\\n        // Define and clear variables\\n        let prevChanges = changes\\n        let restSum = 0\\n        let totalSum = 0\\n        changes = 0\\n\\n        // Calculate number of possible changes, restSum and totalSum\\n        for(let i = 0; i< arr.length; i++) {\\n            // if m > arr[i], means that arr[i] can be changed by m\\n            if(arr[i] > m) {\\n                changes++\\n            } else {\\n                // if cannot be changed, then I accumulate the number\\n                restSum += arr[i]\\n            }\\n            // totalSum is only used when there is only one change available\\n            totalSum += arr[i]\\n        }\\n\\n        // If there aren\\'t changes available return the biggest number of the array\\n        if(changes === 0) {\\n            return Math.max(...arr)\\n        }\\n\\n        // If there is only one change available\\n        if(changes === 1) {\\n            let x = target - restSum\\n            let y = totalSum - restSum\\n            if(x > y) return y\\n            return x\\n        }\\n\\n        // If the number of changes available is the same with the prevChanges, \\n        //then I it means that m is a candidate.\\n        if(prevChanges === changes) {\\n            // Because m is calculated with a division and I use only the integer, there is a \\n            // posibility that the value was closer to the next integer, so I try both cases.\\n            let result1 = Math.abs((m * changes) + restSum - target)\\n            let result2 = Math.abs(((m+1) * changes) + restSum - target)\\n\\n            return result2 >= result1 ? m : m + 1\\n        }\\n\\n        // update the value to minimize the result\\n        m = Math.floor((target - restSum)/changes)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2723079,
                "title": "simple-binary-search-js-solution",
                "content": "\\n# Code\\n```\\n/*\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar findBestValue = function(arr, target) {\\n       const addSum = (mid) =>{\\n             let addsum = 0;\\n             for (let i=0; i<arr.length; i++){\\n                   addsum += (arr[i]>mid)? mid : arr[i]; \\n             }  \\n             return addsum;\\n       }   \\n\\n       let l = 0, r = Math.max(...arr);\\n       let ans = 1;\\n       let diff = +Infinity;\\n\\n       while (l<=r) {\\n            let mid = Math.floor((l+r)/2);\\n           if (addSum(mid) > target){\\n                r = mid-1;\\n           } else {\\n                l = mid+1;\\n           }\\n\\n           if (Math.abs(addSum(mid)-target) < diff || Math.abs(addSum(mid)-target) === diff && mid<ans){\\n                  ans = mid;\\n                  diff = Math.abs(addSum(mid)-target);\\n           }\\n\\n       }\\n\\n       return ans;\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar findBestValue = function(arr, target) {\\n       const addSum = (mid) =>{\\n             let addsum = 0;\\n             for (let i=0; i<arr.length; i++){\\n                   addsum += (arr[i]>mid)? mid : arr[i]; \\n             }  \\n             return addsum;\\n       }   \\n\\n       let l = 0, r = Math.max(...arr);\\n       let ans = 1;\\n       let diff = +Infinity;\\n\\n       while (l<=r) {\\n            let mid = Math.floor((l+r)/2);\\n           if (addSum(mid) > target){\\n                r = mid-1;\\n           } else {\\n                l = mid+1;\\n           }\\n\\n           if (Math.abs(addSum(mid)-target) < diff || Math.abs(addSum(mid)-target) === diff && mid<ans){\\n                  ans = mid;\\n                  diff = Math.abs(addSum(mid)-target);\\n           }\\n\\n       }\\n\\n       return ans;\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676347,
                "title": "c",
                "content": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint findBestValue(int* arr, int arrSize, int target){\\n    int n = arrSize; \\n    qsort(arr, n, sizeof(int), cmpfunc);\\n    long long*  preSum = malloc(n * sizeof(long long));\\n    preSum[0] = arr[0];\\n    for(int i = 1; i < n; i++){\\n        preSum[i] = preSum[i-1] + arr[i];\\n    }\\n    //special case >>>\\n    if(preSum[n-1] == target)\\n        return arr[n-1];\\n    \\n    if(preSum[0]*n > target){\\n        int a = target/n;\\n        if(abs(target - a*n) <= abs(target - (a+1)*n))\\n            return a;\\n        else\\n            return a+1;\\n    }\\n\\n    if(preSum[n-1] < target)\\n        return arr[n-1];\\n    //<<<<\\n    \\n    int left = 0, right = n-1;\\n    int mid, sum ;\\n    while(left < right){\\n        mid = left + (right - left)/2;\\n        sum = preSum[mid] + (n-mid-1) * arr[mid];\\n        if(sum == target)\\n            return arr[mid];\\n        if(sum < target)\\n            left = mid + 1;\\n        else\\n            right = mid;\\n    }\\n    \\n    sum = preSum[left] + (n-left-1) * arr[left];\\n    if(sum == target || left == 0)\\n        return arr[left];\\n    \\n    int L = arr[left-1], R = arr[left];\\n    int M;\\n    \\n    while(L < R){        \\n        M = L + (R-L)/2;        \\n        sum = preSum[left-1] + M*(n-left);\\n        //printf(\"L = %d, R=%d, M=%d, sum=%d \", L, R, M, sum);\\n        if(sum == target)\\n            return M;\\n        if(sum < target)\\n            L = M + 1;\\n        else\\n            R = M;\\n    }\\n    \\n    int sum1 = preSum[left-1] + L*(n-left);\\n    int sum2 = preSum[left-1] + (L-1)*(n-left);\\n    if( abs(target - sum2)  <=  abs(target - sum1) )\\n        return L-1;\\n    else\\n        return L;\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint findBestValue(int* arr, int arrSize, int target){\\n    int n = arrSize; \\n    qsort(arr, n, sizeof(int), cmpfunc);\\n    long long*  preSum = malloc(n * sizeof(long long));\\n    preSum[0] = arr[0];\\n    for(int i = 1; i < n; i++){\\n        preSum[i] = preSum[i-1] + arr[i];\\n    }\\n    //special case >>>\\n    if(preSum[n-1] == target)\\n        return arr[n-1];\\n    \\n    if(preSum[0]*n > target){\\n        int a = target/n;\\n        if(abs(target - a*n) <= abs(target - (a+1)*n))\\n            return a;\\n        else\\n            return a+1;\\n    }\\n\\n    if(preSum[n-1] < target)\\n        return arr[n-1];\\n    //<<<<\\n    \\n    int left = 0, right = n-1;\\n    int mid, sum ;\\n    while(left < right){\\n        mid = left + (right - left)/2;\\n        sum = preSum[mid] + (n-mid-1) * arr[mid];\\n        if(sum == target)\\n            return arr[mid];\\n        if(sum < target)\\n            left = mid + 1;\\n        else\\n            right = mid;\\n    }\\n    \\n    sum = preSum[left] + (n-left-1) * arr[left];\\n    if(sum == target || left == 0)\\n        return arr[left];\\n    \\n    int L = arr[left-1], R = arr[left];\\n    int M;\\n    \\n    while(L < R){        \\n        M = L + (R-L)/2;        \\n        sum = preSum[left-1] + M*(n-left);\\n        //printf(\"L = %d, R=%d, M=%d, sum=%d \", L, R, M, sum);\\n        if(sum == target)\\n            return M;\\n        if(sum < target)\\n            L = M + 1;\\n        else\\n            R = M;\\n    }\\n    \\n    int sum1 = preSum[left-1] + L*(n-left);\\n    int sum2 = preSum[left-1] + (L-1)*(n-left);\\n    if( abs(target - sum2)  <=  abs(target - sum1) )\\n        return L-1;\\n    else\\n        return L;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664503,
                "title": "c-standard-binary-search-problem-must-know-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int low=0,high=INT_MIN,mid;\\n        for(int i=0;i<n;i++)\\n        {\\n            high=max(high,arr[i]);\\n        }\\n        int res=INT_MAX,sum=0,close=INT_MAX;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(arr[i]>mid)\\n                    sum+=mid;\\n                else\\n                    sum+=arr[i];\\n            }\\n            if(abs(sum-target)<=close)\\n            {\\n                if(close==abs(sum-target))\\n                    res=min(res,mid);\\n                else\\n                    res=mid;\\n                close=abs(sum-target);\\n            }\\n            if(sum>=target)\\n                high=mid-1;\\n            else if(sum<target)\\n                low=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\nAN UPVOTE FROM YOUR SIDE IS HIGHLY APPRECIATED :)",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        int low=0,high=INT_MIN,mid;\\n        for(int i=0;i<n;i++)\\n        {\\n            high=max(high,arr[i]);\\n        }\\n        int res=INT_MAX,sum=0,close=INT_MAX;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(arr[i]>mid)\\n                    sum+=mid;\\n                else\\n                    sum+=arr[i];\\n            }\\n            if(abs(sum-target)<=close)\\n            {\\n                if(close==abs(sum-target))\\n                    res=min(res,mid);\\n                else\\n                    res=mid;\\n                close=abs(sum-target);\\n            }\\n            if(sum>=target)\\n                high=mid-1;\\n            else if(sum<target)\\n                low=mid+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664156,
                "title": "easy-c-binary-search",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        \\n        int low=0, high=*max_element(arr.begin(), arr.end()), mid, sum, ans, prevDiff=INT_MAX;\\n        \\n        while(low<=high) {\\n            mid = low + ((high-low)>>1);\\n            sum=0;\\n            \\n            for(int i=0; i<n; i++) {\\n                if(arr[i]<=mid) sum+=arr[i];\\n                else sum+=mid;\\n            }\\n            \\n            if(prevDiff >= abs(target-sum)) {\\n                if(prevDiff == abs(target-sum))\\n                    ans=min(mid, ans);\\n                else \\n                    ans=mid;\\n                prevDiff=abs(target-sum);\\n            }\\n            \\n            if(sum>=target) {\\n                high=mid-1;\\n            } else {\\n                low=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        \\n        int low=0, high=*max_element(arr.begin(), arr.end()), mid, sum, ans, prevDiff=INT_MAX;\\n        \\n        while(low<=high) {\\n            mid = low + ((high-low)>>1);\\n            sum=0;\\n            \\n            for(int i=0; i<n; i++) {\\n                if(arr[i]<=mid) sum+=arr[i];\\n                else sum+=mid;\\n            }\\n            \\n            if(prevDiff >= abs(target-sum)) {\\n                if(prevDiff == abs(target-sum))\\n                    ans=min(mid, ans);\\n                else \\n                    ans=mid;\\n                prevDiff=abs(target-sum);\\n            }\\n            \\n            if(sum>=target) {\\n                high=mid-1;\\n            } else {\\n                low=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641217,
                "title": "java-binary-search",
                "content": "\\tclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i: arr)\\n        {\\n            max=Math.max(max, i);\\n        }\\n        \\n        int l=0;\\n        int h=max;\\n        int ret=Integer.MAX_VALUE;\\n        int diff=Integer.MAX_VALUE;\\n        while(l<=h)\\n        {\\n            int m=l+(h-l)/2;\\n            int ans=call(arr, m);\\n            if(diff>Math.abs(target-ans))\\n            {\\n                System.out.println(diff+\" \"+m+\" \"+ans);\\n                diff=Math.abs(target-ans);\\n                ret=m;\\n            }\\n            else if(diff==Math.abs(target-ans))\\n            {\\n                ret=Math.min(ret, m);\\n            }\\n            \\n            \\n            if(target-ans>0)\\n            {\\n                l=m+1;\\n            }\\n            else \\n            {\\n                h=m-1;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    public int call(int[]arr, int m)\\n    {\\n        int s=0;\\n        for(int i: arr)\\n        {\\n            s+=i>m?m:i;\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findBestValue(int[] arr, int target) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i: arr)\\n        {\\n            max=Math.max(max, i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2619200,
                "title": "c-binary-search-easyy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> v,int mid){\\n        int s=0;\\n        for(int x : v){\\n            if(x > mid)\\n                s += mid;\\n            else\\n               s += x; \\n        }\\n        return s;\\n    }\\n    \\n    int findBestValue(vector<int>& a, int t) {\\n        int l=0,n=a.size(),h = *max_element(a.begin(),a.end()),ans=0;\\n        int minDiff=INT_MAX;\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n            int k = solve(a,mid);\\n            if(k==t)\\n                return mid;\\n            else if(k > t)\\n                h=mid-1;\\n            else \\n                l=mid+1;\\n            \\n           int diff = abs(k-t);\\n            if(diff<minDiff){\\n                minDiff=diff;\\n                ans=mid;\\n            }\\n            else if(diff == minDiff){\\n                ans=min(ans,mid);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> v,int mid){\\n        int s=0;\\n        for(int x : v){\\n            if(x > mid)\\n                s += mid;\\n            else\\n               s += x; \\n        }\\n        return s;\\n    }\\n    \\n    int findBestValue(vector<int>& a, int t) {\\n        int l=0,n=a.size(),h = *max_element(a.begin(),a.end()),ans=0;\\n        int minDiff=INT_MAX;\\n        while(l<=h){\\n            int mid = (l+h)/2;\\n            int k = solve(a,mid);\\n            if(k==t)\\n                return mid;\\n            else if(k > t)\\n                h=mid-1;\\n            else \\n                l=mid+1;\\n            \\n           int diff = abs(k-t);\\n            if(diff<minDiff){\\n                minDiff=diff;\\n                ans=mid;\\n            }\\n            else if(diff == minDiff){\\n                ans=min(ans,mid);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602622,
                "title": "all-of-my-testcases-do-not-pass-help",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int length = arr.size();\\n        for(int i =0;i<=length;i++){\\n            int sol = target/length;\\n            if(arr[i]>=sol){\\n                return sol;\\n            }\\n        \\n                target -=arr[i];\\n                length-=1;\\n            \\n              \\n        }\\n        return arr.back(); //nothing is true return the last number\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int length = arr.size();\\n        for(int i =0;i<=length;i++){\\n            int sol = target/length;\\n            if(arr[i]>=sol){\\n                return sol;\\n            }\\n        \\n                target -=arr[i];\\n                length-=1;\\n            \\n              \\n        }\\n        return arr.back(); //nothing is true return the last number\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551287,
                "title": "c-binary-search-easy-and-readable-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(int mid,vector<int>& arr){\\n        int sum=0;\\n        for(auto &it: arr){\\n            if(it<=mid){\\n                sum+= it;\\n            }\\n            else{\\n                sum+= mid;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n          sort(arr.begin(),arr.end());\\n        int n= arr.size();\\n        int l=0,r= target;\\n        if(check(arr[n-1],arr)<=target){\\n            return arr[n-1];\\n        }\\n        while(l<=r){\\n            int mid= l+ (r-l)/2;\\n            int sum= check(mid,arr);\\n            if(sum==target){\\n                l= mid;\\n                break;\\n            }\\n            else if(sum<target){\\n                l= mid+1;\\n            }\\n            else{\\n                r= mid-1;\\n            }\\n        }\\n        \\n        int m=l-1;\\n        \\n        if(abs(target-check(l,arr))>=abs(target-check(m,arr))){\\n            return m;\\n        }\\n        else{\\n            return l;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int check(int mid,vector<int>& arr){\\n        int sum=0;\\n        for(auto &it: arr){\\n            if(it<=mid){\\n                sum+= it;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2548330,
                "title": "python-sorting-solution",
                "content": "```\\ndef findBestValue(self, arr: List[int], x: int) -> int:\\n\\tleft, arr, k = 0, sorted(arr), 0\\n\\tfor i in range(len(arr)):\\n\\t\\tk = round((x-left)/(len(arr)-i))\\n\\t\\tif k<arr[i]:\\n\\t\\t\\treturn k\\n\\t\\tleft += arr[i]\\n\\treturn arr[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef findBestValue(self, arr: List[int], x: int) -> int:\\n\\tleft, arr, k = 0, sorted(arr), 0\\n\\tfor i in range(len(arr)):\\n\\t\\tk = round((x-left)/(len(arr)-i))\\n\\t\\tif k<arr[i]:\\n\\t\\t\\treturn k\\n\\t\\tleft += arr[i]\\n\\treturn arr[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2530875,
                "title": "c-reduce-possibilities",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findBestValue(vector<int>& a, int target) {\\n\\t\\t\\tint mx=0,res=0;\\n\\t\\t\\tfor(int i=0;i<a.size();i++)  {\\n\\t\\t\\t\\tmx=max(mx,a[i]);\\n\\t\\t\\t\\tres+=a[i];\\n\\t\\t\\t}\\n\\t\\t\\tif(res<=target) return mx;\\n\\t\\t\\tint l=0,r=1e9+1;\\n\\t\\t\\twhile(l<r)  {\\n\\t\\t\\t\\tint m=(l+r)/2;\\n\\t\\t\\t\\tint sum=0;\\n\\t\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\t\\tsum+=(a[i]>m?m:a[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(sum-target>=0) {\\n\\t\\t\\t\\t\\tr=m;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse l=m+1;\\n\\t\\t\\t}\\n\\t\\t\\tint sum1=0,sum2=0;\\n\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\tsum1+=(a[i]>r?r:a[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<a.size();i++) {\\n\\t\\t\\t\\tsum2+=(a[i]>r-1?r-1:a[i]);\\n\\t\\t\\t}\\n\\t\\t\\tif(abs(sum1-target)>=abs(sum2-target)) return r-1;\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findBestValue(vector<int>& a, int target) {\\n\\t\\t\\tint mx=0,res=0;\\n\\t\\t\\tfor(int i=0;i<a.size();i++)  {\\n\\t\\t\\t\\tmx=max(mx,a[i]);\\n\\t\\t\\t\\tres+=a[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2513778,
                "title": "binary-search-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNewSum(vector <int> &arr, int m) {\\n        int sum = 0;\\n        \\n        for(const int &num : arr) {\\n            if(num > m) {\\n                sum += m;\\n            }\\n            else {\\n                sum += num;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        int low = 0; int high = arr[n-1];\\n        int minDiff = INT_MAX; int ans=0;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            int sum = getNewSum(arr,mid);\\n            int diff = abs(sum-target);\\n            if(diff<minDiff){\\n                minDiff=diff;\\n                ans=mid;\\n            }\\n            else if(diff == minDiff){\\n                ans=min(ans,mid);\\n            }\\n            \\n            if(sum>target){\\n                high = mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNewSum(vector <int> &arr, int m) {\\n        int sum = 0;\\n        \\n        for(const int &num : arr) {\\n            if(num > m) {\\n                sum += m;\\n            }\\n            else {\\n                sum += num;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        int low = 0; int high = arr[n-1];\\n        int minDiff = INT_MAX; int ans=0;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            int sum = getNewSum(arr,mid);\\n            int diff = abs(sum-target);\\n            if(diff<minDiff){\\n                minDiff=diff;\\n                ans=mid;\\n            }\\n            else if(diff == minDiff){\\n                ans=min(ans,mid);\\n            }\\n            \\n            if(sum>target){\\n                high = mid-1;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500813,
                "title": "2-solutions-in-c-binary-search-sorting-binary-search-prefix-sum",
                "content": "**Solution 1 : [Binary-search]**\\n\\n```\\nclass Solution {\\npublic:\\n    int getNewSum(vector <int> &arr, int m) {\\n        int sum = 0;\\n        \\n        for(const int &num : arr) {\\n            if(num > m) {\\n                sum += m;\\n            }\\n            else {\\n                sum += num;\\n            }\\n        }\\n        \\n        return sum;\\n    }  \\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int max_e = INT_MIN;\\n        \\n        for(const int &num : arr) {\\n            max_e = max(num, max_e);\\n        }\\n        \\n        int l = 0, r = max_e, res = 0, minDiff = INT_MAX;\\n        \\n        while(l <= r) {\\n            int m = l + (r - l) / 2, sum = getNewSum(arr, m);\\n            \\n            int diff = abs(sum - target);\\n            \\n            if(diff < minDiff) {\\n                minDiff = diff;\\n                res = m;\\n            } \\n            else if(diff == minDiff) {\\n                res = min(res, m);\\n            } \\n            \\n            if(sum > target) {\\n                r = m - 1;\\n            }\\n            else {\\n                l = m + 1;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Solution 2 : [Sorting + Binary-search + prefix sum]**\\n\\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int N = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int min_e = 0, max_e = arr.back();\\n        \\n        vector <int> ps(N, 0);\\n        ps[0] = arr[0];\\n        \\n        for(int i = 1; i < N; i++) {\\n            ps[i] = ps[i - 1] + arr[i];\\n        }\\n        \\n        int minDiff = INT_MAX, res = 0;\\n        for(int i = min_e; i <= max_e; i++) {\\n            int idx = upper_bound(arr.begin(), arr.end(), i) - arr.begin();\\n            \\n            int sum = idx > 0 ? ps[idx - 1] : 0;\\n            \\n            // convert integers larger than i to i\\n            sum += (i * (N - idx));\\n            \\n            int diff = abs(sum - target);\\n            \\n            if(diff < minDiff) {\\n                minDiff = diff;\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNewSum(vector <int> &arr, int m) {\\n        int sum = 0;\\n        \\n        for(const int &num : arr) {\\n            if(num > m) {\\n                sum += m;\\n            }\\n            else {\\n                sum += num;\\n            }\\n        }\\n        \\n        return sum;\\n    }  \\n    \\n    int findBestValue(vector<int>& arr, int target) {\\n        int max_e = INT_MIN;\\n        \\n        for(const int &num : arr) {\\n            max_e = max(num, max_e);\\n        }\\n        \\n        int l = 0, r = max_e, res = 0, minDiff = INT_MAX;\\n        \\n        while(l <= r) {\\n            int m = l + (r - l) / 2, sum = getNewSum(arr, m);\\n            \\n            int diff = abs(sum - target);\\n            \\n            if(diff < minDiff) {\\n                minDiff = diff;\\n                res = m;\\n            } \\n            else if(diff == minDiff) {\\n                res = min(res, m);\\n            } \\n            \\n            if(sum > target) {\\n                r = m - 1;\\n            }\\n            else {\\n                l = m + 1;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int N = arr.size();\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int min_e = 0, max_e = arr.back();\\n        \\n        vector <int> ps(N, 0);\\n        ps[0] = arr[0];\\n        \\n        for(int i = 1; i < N; i++) {\\n            ps[i] = ps[i - 1] + arr[i];\\n        }\\n        \\n        int minDiff = INT_MAX, res = 0;\\n        for(int i = min_e; i <= max_e; i++) {\\n            int idx = upper_bound(arr.begin(), arr.end(), i) - arr.begin();\\n            \\n            int sum = idx > 0 ? ps[idx - 1] : 0;\\n            \\n            // convert integers larger than i to i\\n            sum += (i * (N - idx));\\n            \\n            int diff = abs(sum - target);\\n            \\n            if(diff < minDiff) {\\n                minDiff = diff;\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480044,
                "title": "simple-c-solution-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l = 0;\\n        int h = *max_element(begin(arr), end(arr));\\n        int ans = h, diff = target;\\n        while(l<=h)\\n        {\\n            int mid = (h+l)/2;\\n            int sum = getSum(arr,mid);\\n            int currDiff = abs(target-sum);\\n            if(currDiff< diff)\\n                diff = currDiff , ans = mid;\\n            if(currDiff == diff) \\n                ans = min(ans, mid);\\n            if(sum > target)\\n                h = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n    \\n    int getSum(vector<int>& arr, int &mid)\\n    {\\n        int sum = 0;\\n        for(int x : arr)\\n            sum += x > mid ? mid : x;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findBestValue(vector<int>& arr, int target) {\\n        int l = 0;\\n        int h = *max_element(begin(arr), end(arr));\\n        int ans = h, diff = target;\\n        while(l<=h)\\n        {\\n            int mid = (h+l)/2;\\n            int sum = getSum(arr,mid);\\n            int currDiff = abs(target-sum);\\n            if(currDiff< diff)\\n                diff = currDiff , ans = mid;\\n            if(currDiff == diff) \\n                ans = min(ans, mid);\\n            if(sum > target)\\n                h = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n    \\n    int getSum(vector<int>& arr, int &mid)\\n    {\\n        int sum = 0;\\n        for(int x : arr)\\n            sum += x > mid ? mid : x;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472255,
                "title": "c-code",
                "content": "class Solution {\\npublic:\\n    long long cal(int num, vector<int> &nums) {\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= num) sum += nums[i];\\n            else sum += num;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        if(cal(arr[n-1], arr) <= target) return arr[n-1];\\n        int lo = 0, hi = 1e5;\\n        while(lo < hi) {\\n            int mid = lo + (hi-lo+1)/2;\\n            long long sum = cal(mid, arr);\\n            if(sum <= target) lo = mid;\\n            else hi = mid-1;\\n        }\\n        if(abs(cal(lo, arr)-target) <= abs(cal(lo+1, arr)-target))\\n            return lo;\\n        return lo+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long cal(int num, vector<int> &nums) {\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= num) sum += nums[i];\\n            else sum += num;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2448721,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long cal(int num, vector<int> &nums) {\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= num) sum += nums[i];\\n            else sum += num;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        if(cal(arr[n-1], arr) <= target) return arr[n-1];\\n        int lo = 0, hi = 1e5;\\n        while(lo < hi) {\\n            int mid = lo + (hi-lo+1)/2;\\n            long long sum = cal(mid, arr);\\n            if(sum <= target) lo = mid;\\n            else hi = mid-1;\\n        }\\n        if(abs(cal(lo, arr)-target) <= abs(cal(lo+1, arr)-target))\\n            return lo;\\n        return lo+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long cal(int num, vector<int> &nums) {\\n        long long sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] <= num) sum += nums[i];\\n            else sum += num;\\n        }\\n        return sum;\\n    }\\n    int findBestValue(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        if(cal(arr[n-1], arr) <= target) return arr[n-1];\\n        int lo = 0, hi = 1e5;\\n        while(lo < hi) {\\n            int mid = lo + (hi-lo+1)/2;\\n            long long sum = cal(mid, arr);\\n            if(sum <= target) lo = mid;\\n            else hi = mid-1;\\n        }\\n        if(abs(cal(lo, arr)-target) <= abs(cal(lo+1, arr)-target))\\n            return lo;\\n        return lo+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2073401,
                "content": [
                    {
                        "username": "arvin_draj",
                        "content": "A little catch in the example 2...\\nI just wonder why the answer is  not 3"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Example 2:\\n\\nInput: arr = [2,3,5], target = 10\\nOutput: 5\\nWhy not in example 2 the answer is 3, since if we convert all elements to 3 then sum would be 9.\\nIncase we convert all to 5 then sum of array would be 15.\\nNow 9 is close to 10 than 15 does right? ..\\nPlease help if i am wrong or misunderstood the question."
                    },
                    {
                        "username": "gauravbharti",
                        "content": "You understood it wrong, you can only update the ones which are smaller, so here in 2,3,5 -> if  you choose 3 then it will be 2,3,3 which totals for 8, and if you leave it as it is, it totals for 10"
                    }
                ]
            },
            {
                "id": 1972692,
                "content": [
                    {
                        "username": "arvin_draj",
                        "content": "A little catch in the example 2...\\nI just wonder why the answer is  not 3"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Example 2:\\n\\nInput: arr = [2,3,5], target = 10\\nOutput: 5\\nWhy not in example 2 the answer is 3, since if we convert all elements to 3 then sum would be 9.\\nIncase we convert all to 5 then sum of array would be 15.\\nNow 9 is close to 10 than 15 does right? ..\\nPlease help if i am wrong or misunderstood the question."
                    },
                    {
                        "username": "gauravbharti",
                        "content": "You understood it wrong, you can only update the ones which are smaller, so here in 2,3,5 -> if  you choose 3 then it will be 2,3,3 which totals for 8, and if you leave it as it is, it totals for 10"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum XOR With an Element From Array",
        "question_content": "<p>You are given an array <code>nums</code> consisting of non-negative integers. You are also given a <code>queries</code> array, where <code>queries[i] = [x<sub>i</sub>, m<sub>i</sub>]</code>.</p>\n\n<p>The answer to the <code>i<sup>th</sup></code> query is the maximum bitwise <code>XOR</code> value of <code>x<sub>i</sub></code> and any element of <code>nums</code> that does not exceed <code>m<sub>i</sub></code>. In other words, the answer is <code>max(nums[j] XOR x<sub>i</sub>)</code> for all <code>j</code> such that <code>nums[j] &lt;= m<sub>i</sub></code>. If all elements in <code>nums</code> are larger than <code>m<sub>i</sub></code>, then the answer is <code>-1</code>.</p>\n\n<p>Return <em>an integer array </em><code>answer</code><em> where </em><code>answer.length == queries.length</code><em> and </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\n<strong>Output:</strong> [3,3,7]\n<strong>Explanation:</strong>\n1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.\n2) 1 XOR 2 = 3.\n3) 5 XOR 2 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\n<strong>Output:</strong> [15,-1,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>0 &lt;= nums[j], x<sub>i</sub>, m<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 988132,
                "title": "python-clean-trie-two-pointers-solution-o-sort",
                "content": "**Idea**\\n\\nThe idea behind this problem comes from [LC 421](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) and [LC 1697](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/).\\n\\nSimilar to [LC 421](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/), we can convert each number to binary format and construct a trie that has children of `0` and `1`. In this way, we can query the maximum bitwise XOR value in `O(32)` time. \\n\\nSimilar to [LC 1697](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/), we can sort queries and construct the trie on the fly. We use a two pointer approach to make sure only elements that do not exceed `m_i` are added to the trie.\\n\\nPutting these thoughts together, we arrive at the solution below. Please refer to the code for more details.\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(sort)`, or `O(NlogN + MlogM)`\\n- Space complexity: `O(N)`\\n\\n</br>\\n\\n**Python**\\n\\n```Python\\nclass Trie:\\n    def __init__(self):\\n        self.root = {}\\n        \\n    def insert(self, num):\\n        p = self.root\\n        for i in range(31, -1, -1):\\n            cur = (num >> i) & 1\\n            if cur not in p:\\n                p[cur] = {}\\n            p = p[cur]\\n                \\n    def query(self, num):\\n        if not self.root: \\n            return -1\\n        p, ans = self.root, 0\\n        for i in range(31, -1, -1):\\n            cur = (num >> i) & 1\\n            if 1 - cur in p:\\n                p = p[1 - cur]\\n                ans |= (1 << i)\\n            else:\\n                p = p[cur]\\n        return ans\\n\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        queries = sorted(enumerate(queries), key=lambda x: x[1][1])\\n        trie = Trie()\\n        ans = [-1] * len(queries)\\n        j = 0\\n        for i, (x, m) in queries:\\n            while j < len(nums) and nums[j] <= m:\\n                trie.insert(nums[j])\\n                j += 1\\n            ans[i] = trie.query(x)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Trie:\\n    def __init__(self):\\n        self.root = {}\\n        \\n    def insert(self, num):\\n        p = self.root\\n        for i in range(31, -1, -1):\\n            cur = (num >> i) & 1\\n            if cur not in p:\\n                p[cur] = {}\\n            p = p[cur]\\n                \\n    def query(self, num):\\n        if not self.root: \\n            return -1\\n        p, ans = self.root, 0\\n        for i in range(31, -1, -1):\\n            cur = (num >> i) & 1\\n            if 1 - cur in p:\\n                p = p[1 - cur]\\n                ans |= (1 << i)\\n            else:\\n                p = p[cur]\\n        return ans\\n\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        queries = sorted(enumerate(queries), key=lambda x: x[1][1])\\n        trie = Trie()\\n        ans = [-1] * len(queries)\\n        j = 0\\n        for i, (x, m) in queries:\\n            while j < len(nums) and nums[j] <= m:\\n                trie.insert(nums[j])\\n                j += 1\\n            ans[i] = trie.query(x)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988811,
                "title": "java-trie-array-sort-detailed-explanation",
                "content": "***Kindly upvote if you find this solution useful.***\\n\\nThis question is an extension of the following question on XOR. \\n\\n[Maximum XOR of two numbers in an array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)\\n\\nThe above question can be solved using trie in O(N) time complexity .\\n\\nNow coming to this question, the key point to note is there is an extra parameter you need to consider while fetching the query and that is **mi**. \\n\\nTo prevent creation of a seperate trie for every query, what we are going to do is that : \\n\\n1. Take a temporary array *temp[][3]* and copy the queries array into it. The third column of temp array will hold the position of the respective query in the original list. (Since we need to note the order of the queries).\\n\\n2. Next we sort the *temp* array on basis of its second parameter i.e, *mi*.\\n3. We sort the original *nums* array and initailize a variable (index) to 0.\\n4. Now we loop through the temp array .\\n5. At every iteration we add the elements in the trie which are <= mi for that query.\\n6. This ensures at every point all the elements present in the trie is <= mi.\\n7. The third parameter in temp array helps us to map the answer for every query to its correct position.\\n8. Rest of the problem is same as [Maximum XOR of two elements in an array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/).\\n\\n**Time Complexity : O (N log(N) + K log(K) )**\\nwhere N is the number of elements in the nums array and K is the total number of queries.\\nHere we need to note that every element is added to the trie atmost once. For adding each element in the trie constant time is required (c = 32). The log(n) factor gets added because we are sorting both the nums array and queries array.\\n\\n```\\nclass TrieNode {\\n        TrieNode nums[] = new TrieNode[2];\\n        int prefixValue;\\n    }\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int queriesLength = queries.length;\\n        int[] ans = new int[queriesLength];\\n        int[][] temp = new int[queriesLength][3];\\n        for (int i = 0; i < queriesLength; i++) {\\n            temp[i][0] = queries[i][0];\\n            temp[i][1] = queries[i][1];\\n            temp[i][2] = i;\\n        }\\n\\n        Arrays.sort(temp, (a, b) -> {\\n            return a[1] - b[1];\\n        });\\n        int index = 0;\\n        Arrays.sort(nums);\\n        TrieNode root = new TrieNode();\\n\\n        for (int query[] : temp) {\\n            while (index < nums.length && nums[index] <= query[1]) {\\n                insert(root, nums[index]);\\n                index++;\\n            }\\n            int tempAns = -1;\\n            if (index != 0) {\\n                tempAns = search(root, query[0]);\\n            }\\n            ans[query[2]] = tempAns;\\n        }\\n\\n        return ans;\\n    }\\n\\n    public void insert(TrieNode root, int n) {\\n        TrieNode node = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (n >> i) & 1;\\n            if (node.nums[bit] == null) {\\n                node.nums[bit] = new TrieNode();\\n            }\\n            node = node.nums[bit];\\n        }\\n        node.prefixValue = n;\\n    }\\n\\n    public int search(TrieNode root, int n) {\\n        TrieNode node = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (n >> i) & 1;\\n            int requiredBit = bit == 1 ? 0 : 1;\\n            if (node.nums[requiredBit] != null) {\\n                node = node.nums[requiredBit];\\n            } else {\\n                node = node.nums[bit];\\n            }\\n        }\\n        return node.prefixValue ^ n;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nclass TrieNode {\\n        TrieNode nums[] = new TrieNode[2];\\n        int prefixValue;\\n    }\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int queriesLength = queries.length;\\n        int[] ans = new int[queriesLength];\\n        int[][] temp = new int[queriesLength][3];\\n        for (int i = 0; i < queriesLength; i++) {\\n            temp[i][0] = queries[i][0];\\n            temp[i][1] = queries[i][1];\\n            temp[i][2] = i;\\n        }\\n\\n        Arrays.sort(temp, (a, b) -> {\\n            return a[1] - b[1];\\n        });\\n        int index = 0;\\n        Arrays.sort(nums);\\n        TrieNode root = new TrieNode();\\n\\n        for (int query[] : temp) {\\n            while (index < nums.length && nums[index] <= query[1]) {\\n                insert(root, nums[index]);\\n                index++;\\n            }\\n            int tempAns = -1;\\n            if (index != 0) {\\n                tempAns = search(root, query[0]);\\n            }\\n            ans[query[2]] = tempAns;\\n        }\\n\\n        return ans;\\n    }\\n\\n    public void insert(TrieNode root, int n) {\\n        TrieNode node = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (n >> i) & 1;\\n            if (node.nums[bit] == null) {\\n                node.nums[bit] = new TrieNode();\\n            }\\n            node = node.nums[bit];\\n        }\\n        node.prefixValue = n;\\n    }\\n\\n    public int search(TrieNode root, int n) {\\n        TrieNode node = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (n >> i) & 1;\\n            int requiredBit = bit == 1 ? 0 : 1;\\n            if (node.nums[requiredBit] != null) {\\n                node = node.nums[requiredBit];\\n            } else {\\n                node = node.nums[bit];\\n            }\\n        }\\n        return node.prefixValue ^ n;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988329,
                "title": "another-solution-two-pointers-binary-search-c-no-trie-shorter-code",
                "content": "Hope my solution will inspire you. :D\\n\\n**Idea**\\nWe sort the nums, for each query, we maintain two pointers `left` and `right`, `[Left, right)`\\n\\nWe enumerate for each `xi` from MSB to LSB.\\nIn this enumerate order, if the prefix is determined, the next bit will be `0` and `1`, and `0` comes before `1` because we sorted the array at the beginning, we can apply binary-search strategy for this.\\n\\nif the bit of `xi` is 0, we hope that there exist a number with a bit 1 in that position in range `[left, right)`, we try to find the bound using the lower_bound function in `logn` time\\nif the bit of `xi` is 1, we hope that there exist a number with a bit 0 in that position in range `[left, right)`, we try to find the bound using the lower_bound function in `logn` time\\n\\nWe repeat the actions untill all bits are enumerated\\n\\n**Code**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        const int n = nums.size(), q = queries.size();\\n        vector<int> ans(q, -1);\\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < q; i++) {\\n            const int x = queries[i][0], m = queries[i][1];\\n            if (m < nums[0]) continue;\\n            \\n            int end = upper_bound(nums.begin(), nums.end(), m) - nums.begin();\\n            int start = 0;\\n            \\n            int k = 0, cur = 0;\\n            for (int bit = 31; bit >= 0; bit--) {\\n                if (x & (1 << bit)) { // hope A[i] this bit == 0\\n                    if (!(nums[start] & (1 << bit))) {\\n                        k |= 1 << bit;\\n                        end = lower_bound(nums.begin() + start, nums.begin() + end, cur | (1 << bit)) - nums.begin();\\n                    } else {\\n                        cur |= 1 << bit;\\n                    }\\n                } else { // hope: A[i] this bit == 1\\n                    if (start <= end - 1 && (nums[end - 1] & (1 << bit))) {\\n                        k |= 1 << bit;\\n                        cur |= 1 << bit;\\n                        start = lower_bound(nums.begin() + start, nums.begin() + end, cur) - nums.begin();\\n                    }\\n                }\\n            }\\n            ans[i] = k;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Analysis**\\nTC: `O(NlogN + QlogMlogN)` (logM = 32) = `O(NlogN + QlogN)`\\nSC: `O(N + Q)`",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        const int n = nums.size(), q = queries.size();\\n        vector<int> ans(q, -1);\\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < q; i++) {\\n            const int x = queries[i][0], m = queries[i][1];\\n            if (m < nums[0]) continue;\\n            \\n            int end = upper_bound(nums.begin(), nums.end(), m) - nums.begin();\\n            int start = 0;\\n            \\n            int k = 0, cur = 0;\\n            for (int bit = 31; bit >= 0; bit--) {\\n                if (x & (1 << bit)) { // hope A[i] this bit == 0\\n                    if (!(nums[start] & (1 << bit))) {\\n                        k |= 1 << bit;\\n                        end = lower_bound(nums.begin() + start, nums.begin() + end, cur | (1 << bit)) - nums.begin();\\n                    } else {\\n                        cur |= 1 << bit;\\n                    }\\n                } else { // hope: A[i] this bit == 1\\n                    if (start <= end - 1 && (nums[end - 1] & (1 << bit))) {\\n                        k |= 1 << bit;\\n                        cur |= 1 << bit;\\n                        start = lower_bound(nums.begin() + start, nums.begin() + end, cur) - nums.begin();\\n                    }\\n                }\\n            }\\n            ans[i] = k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989454,
                "title": "python-14-lines-or-2144-ms",
                "content": "Sort `nums` and then for each query use `m` to get the range `nums[0:stop]` to find the best `num`. Cut that range into the part *without* the highest bit set and the part *with* the highest bit set. Continue in one of those parts, depending on which parts exist and on whether we want that bit set or not (we want it to differ from `x`\\'s bit). Got through all possible bits from high to low. Takes about 4900 ms, \"faster than 85%\" of the so far 13 successful submissions in the distribution (so that percentage is not very meaningful).\\n```\\ndef maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n    nums.sort()\\n    answer = []\\n    for x, m in queries:\\n        start, stop = 0, bisect_right(nums, m)\\n        num = 0\\n        for i in range(30)[::-1]:\\n            cut = bisect_left(nums, num + 2**i, start, stop)\\n            if cut > start and x & 2**i:\\n                stop = cut\\n            elif cut < stop:\\n                start = cut\\n                num += 2**i\\n        answer.append(num ^ x if start < stop else -1)\\n    return answer\\n```\\nOptimized version with \"2240 ms, faster than 100.00%\" (edit: now there seem to be 268 successful submissions in the current distribution, ranging from 2456 to 9240 ms):\\n```\\ndef maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n    nums.sort()\\n    answer = []\\n    for x, m in queries:\\n        start, stop = 0, bisect_right(nums, m)\\n        num = 0\\n        bit = 2 ** m.bit_length()\\n        while bit:\\n            cut = bisect_left(nums, num + bit, start, stop)\\n            if cut != stop:\\n                if cut != start and x & bit:\\n                    stop = cut\\n                else:\\n                    start = cut\\n                    num += bit\\n            bit //= 2\\n        answer.append(num ^ x if start < stop else -1)\\n    return answer\\n```\\nFurther optimized, 2144 ms:\\n```\\ndef maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n    nums.sort()\\n    answer = []\\n    append = answer.append\\n    for x, m in queries:\\n        if nums[0] > m:\\n            append(-1)\\n            continue\\n        start, stop = 0, bisect_right(nums, m)\\n        num = 0\\n        bit = 2 ** m.bit_length()\\n        while bit:\\n            plus = num + bit\\n            if nums[start] >= plus:\\n                num = plus\\n            elif nums[stop-1] >= plus:\\n                cut = bisect_left(nums, plus, start, stop)\\n                if x & bit:\\n                    stop = cut\\n                else:\\n                    start = cut\\n                    num = plus\\n            bit //= 2\\n        append(num ^ x)\\n    return answer\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n    nums.sort()\\n    answer = []\\n    for x, m in queries:\\n        start, stop = 0, bisect_right(nums, m)\\n        num = 0\\n        for i in range(30)[::-1]:\\n            cut = bisect_left(nums, num + 2**i, start, stop)\\n            if cut > start and x & 2**i:\\n                stop = cut\\n            elif cut < stop:\\n                start = cut\\n                num += 2**i\\n        answer.append(num ^ x if start < stop else -1)\\n    return answer\\n```\n```\\ndef maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n    nums.sort()\\n    answer = []\\n    for x, m in queries:\\n        start, stop = 0, bisect_right(nums, m)\\n        num = 0\\n        bit = 2 ** m.bit_length()\\n        while bit:\\n            cut = bisect_left(nums, num + bit, start, stop)\\n            if cut != stop:\\n                if cut != start and x & bit:\\n                    stop = cut\\n                else:\\n                    start = cut\\n                    num += bit\\n            bit //= 2\\n        answer.append(num ^ x if start < stop else -1)\\n    return answer\\n```\n```\\ndef maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n    nums.sort()\\n    answer = []\\n    append = answer.append\\n    for x, m in queries:\\n        if nums[0] > m:\\n            append(-1)\\n            continue\\n        start, stop = 0, bisect_right(nums, m)\\n        num = 0\\n        bit = 2 ** m.bit_length()\\n        while bit:\\n            plus = num + bit\\n            if nums[start] >= plus:\\n                num = plus\\n            elif nums[stop-1] >= plus:\\n                cut = bisect_left(nums, plus, start, stop)\\n                if x & bit:\\n                    stop = cut\\n                else:\\n                    start = cut\\n                    num = plus\\n            bit //= 2\\n        append(num ^ x)\\n    return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 988468,
                "title": "python3-trie",
                "content": "**Algo**\\nThis problem is similar to [421. Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) which can be solved efficiently via a trie. \\n\\n**Implementation** (100%)\\n```\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))\\n        ans = [-1]*len(queries)\\n        \\n        trie = {}\\n        k = 0\\n        for m, x, i in queries: \\n            while k < len(nums) and nums[k] <= m: \\n                node = trie\\n                val = bin(nums[k])[2:].zfill(32)\\n                for c in val: node = node.setdefault(int(c), {})\\n                node[\"#\"] = nums[k]\\n                k += 1\\n            if trie: \\n                node = trie\\n                val = bin(x)[2:].zfill(32)\\n                for c in val: node = node.get(1-int(c)) or node.get(int(c))\\n                ans[i] = x ^ node[\"#\"]\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n\\nEdited on 12/27/2020\\nAdding a refactored version below for clarity \\n```\\nclass Trie: \\n    def __init__(self):\\n        self.root = {}\\n        \\n    def __bool__(self):\\n        return bool(self.root)\\n    \\n    def insert(self, num):\\n        node = self.root \\n        for x in bin(num)[2:].zfill(32): \\n            node = node.setdefault(int(x), {})\\n        node[\"#\"] = num\\n    \\n    def query(self, num): \\n        node = self.root\\n        for x in bin(num)[2:].zfill(32):\\n            node = node.get(1 - int(x)) or node.get(int(x))\\n        return num ^ node[\"#\"]\\n\\n\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))\\n        \\n        ans = [-1]*len(queries)\\n        k = 0\\n        trie = Trie()\\n        for m, x, i in queries: \\n            while k < len(nums) and nums[k] <= m: \\n                trie.insert(nums[k])\\n                k += 1\\n            if trie: ans[i] = trie.query(x)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))\\n        ans = [-1]*len(queries)\\n        \\n        trie = {}\\n        k = 0\\n        for m, x, i in queries: \\n            while k < len(nums) and nums[k] <= m: \\n                node = trie\\n                val = bin(nums[k])[2:].zfill(32)\\n                for c in val: node = node.setdefault(int(c), {})\\n                node[\"#\"] = nums[k]\\n                k += 1\\n            if trie: \\n                node = trie\\n                val = bin(x)[2:].zfill(32)\\n                for c in val: node = node.get(1-int(c)) or node.get(int(c))\\n                ans[i] = x ^ node[\"#\"]\\n        return ans \\n```\n```\\nclass Trie: \\n    def __init__(self):\\n        self.root = {}\\n        \\n    def __bool__(self):\\n        return bool(self.root)\\n    \\n    def insert(self, num):\\n        node = self.root \\n        for x in bin(num)[2:].zfill(32): \\n            node = node.setdefault(int(x), {})\\n        node[\"#\"] = num\\n    \\n    def query(self, num): \\n        node = self.root\\n        for x in bin(num)[2:].zfill(32):\\n            node = node.get(1 - int(x)) or node.get(int(x))\\n        return num ^ node[\"#\"]\\n\\n\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))\\n        \\n        ans = [-1]*len(queries)\\n        k = 0\\n        trie = Trie()\\n        for m, x, i in queries: \\n            while k < len(nums) and nums[k] <= m: \\n                trie.insert(nums[k])\\n                k += 1\\n            if trie: ans[i] = trie.query(x)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 988142,
                "title": "c-trie-based-solution-with-explanation",
                "content": "First if you attended last week\\'s weekly contest, you should smell the similar pattern for this kind of \"offline\" query question. Yes, you will need to sort the queries based on the `mi` (let\\'s call it threshold later) from small to large. Then as we process the queries from small threshold to large threshold, we gradually add the numbers in nums that are <= the current thresold to \"something\" (this something is a DSU in last week\\'s Q4, while in this question, it is a Trie and we will talk about it later). Then we perform some quick look-up or calcuation (either O(1) or O(log)) to find the answer we need for the current query.\\n\\nNow if we comes to this step, the question naturally boils down to, given a list of numbers, (lets call this list A, and these numbers come from nums array, and all <= the threshold in current query), we want to find the largest XOR value between any one of the numbers in A and the `x` in the current query. How can we get to know this result fast enough instead of scanning A from begin to end? Well if you have good memory, this is actually a small variant of `LC - 421. Maximum XOR of Two Numbers in an Array`. The trick here is that we build a (binary) Trie based on list A, with each node\\'s child either 0 or 1. For each number in A, we can represent it with a path of this Trie from the root to some leaf. Now given `x`, if we want the result of XOR to be as large as possible, we want the number that XOR with `x` to be as \"different\"-bitwise as possible (simply because 1^0 = 1, and 0^0 = 0, 1^1=0). Specifically, say highest bit of `x` is 1, then we try to find if node = 0 is there. If so, we travel down along that direction; if not, then we have to just travel along the same direction with value = 1. Now we go to the second to highest bit, and we will run the same logic. With this process, we can just use O(32) (32 bit) of time to find the largest XOR for `x`.\\n\\nHere is the code:\\n```\\nclass Solution {\\npublic:\\n    struct Node {\\n        Node* zero_bit = nullptr;\\n        Node* one_bit = nullptr;\\n    };\\n    Node* root = new Node();\\n  \\n    void insert(const int& num) {\\n        Node* ptr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            if ((num >> i) & 1) {\\n                if (!ptr->one_bit) ptr->one_bit = new Node();\\n                ptr = ptr->one_bit;\\n            } else {\\n                if (!ptr->zero_bit) ptr->zero_bit = new Node();\\n                ptr = ptr->zero_bit;\\n            }\\n        }\\n    }\\n  \\n    int getMaxXOR(const int& num) {\\n        if (root->zero_bit == nullptr && root->one_bit == nullptr) return -1;\\n        Node* ptr = root;\\n        int temp = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            if ((num >> i) & 1) {\\n                if (ptr->zero_bit) {\\n                    temp += pow(2,i);\\n                    ptr = ptr->zero_bit;\\n                } else {\\n                    ptr = ptr->one_bit;\\n                }\\n            } else {\\n                if (ptr->one_bit) {\\n                    temp += pow(2,i);\\n                    ptr = ptr->one_bit;\\n                } else {\\n                    ptr = ptr->zero_bit;\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<vector<int>> q;\\n        for (int i = 0; i < queries.size(); i++) {\\n            auto v = queries[i];\\n            q.push_back({v[1], v[0], i});\\n        }\\n        sort(q.begin(), q.end());\\n        sort(nums.begin(), nums.end());\\n        \\n        int j = 0;\\n        vector<int> res(queries.size());\\n        \\n        for (const auto& p : q) {\\n            int x = p[1];\\n            int threshold = p[0];\\n            while (j < nums.size() && nums[j] <= threshold) {\\n                insert(nums[j]);\\n                j++;\\n            }\\n            res[p[2]] = getMaxXOR(x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n        Node* zero_bit = nullptr;\\n        Node* one_bit = nullptr;\\n    };\\n    Node* root = new Node();\\n  \\n    void insert(const int& num) {\\n        Node* ptr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            if ((num >> i) & 1) {\\n                if (!ptr->one_bit) ptr->one_bit = new Node();\\n                ptr = ptr->one_bit;\\n            } else {\\n                if (!ptr->zero_bit) ptr->zero_bit = new Node();\\n                ptr = ptr->zero_bit;\\n            }\\n        }\\n    }\\n  \\n    int getMaxXOR(const int& num) {\\n        if (root->zero_bit == nullptr && root->one_bit == nullptr) return -1;\\n        Node* ptr = root;\\n        int temp = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            if ((num >> i) & 1) {\\n                if (ptr->zero_bit) {\\n                    temp += pow(2,i);\\n                    ptr = ptr->zero_bit;\\n                } else {\\n                    ptr = ptr->one_bit;\\n                }\\n            } else {\\n                if (ptr->one_bit) {\\n                    temp += pow(2,i);\\n                    ptr = ptr->one_bit;\\n                } else {\\n                    ptr = ptr->zero_bit;\\n                }\\n            }\\n        }\\n        return temp;\\n    }\\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<vector<int>> q;\\n        for (int i = 0; i < queries.size(); i++) {\\n            auto v = queries[i];\\n            q.push_back({v[1], v[0], i});\\n        }\\n        sort(q.begin(), q.end());\\n        sort(nums.begin(), nums.end());\\n        \\n        int j = 0;\\n        vector<int> res(queries.size());\\n        \\n        for (const auto& p : q) {\\n            int x = p[1];\\n            int threshold = p[0];\\n            while (j < nums.size() && nums[j] <= threshold) {\\n                insert(nums[j]);\\n                j++;\\n            }\\n            res[p[2]] = getMaxXOR(x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988604,
                "title": "c-no-sort",
                "content": "The solution to sort numbers and queues, and populate Trie as we go is simpler. But this No Sort solution is faster.\\n\\nWe populate Trie with all numbers and process queries in the original order. As we search in our Trie, we track the current number and prune when it gets larger than `mi`. In case we have a choice (both zero and one paths are available), we first try a \"preferred\" path. If the number gets larger than `mi`, only in that case we need to try the other path.\\n\\n```cpp\\nstruct bitTree {\\n    bitTree* p[2] = {};\\n    void insert(int num, int bit) {\\n        if (bit > 0) {\\n            auto res = (num & bit) > 0;\\n            if (p[res] == nullptr)\\n                p[res] = new bitTree();\\n            p[res]->insert(num, bit / 2);\\n        }\\n    }\\n    int getMax(int xi, int mi, int bit, int bitSum) {\\n        if (bitSum > mi)\\n            return INT_MIN;            \\n        if (bit == 0)\\n            return 0;\\n        if (p[0] == nullptr)\\n            return ((xi & bit) ? 0 : bit) + p[1]->getMax(xi, mi, bit / 2, bitSum + bit);\\n        if (p[1] == nullptr)\\n            return ((xi & bit) ? bit : 0) + p[0]->getMax(xi, mi, bit / 2, bitSum);\\n        int pos = (xi & bit) == 0; // preferred path.\\n        int res = bit + p[pos]->getMax(xi, mi, bit / 2, bitSum + pos * bit);\\n        if (res < 0) // preferred choice numbers are too large.\\n            res = p[!pos]->getMax(xi, mi, bit / 2, bitSum + !pos * bit);\\n        return res;\\n    }\\n};\\nvector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& qs) {\\n    int max_mi = 0;\\n    for (auto &q : qs)\\n        max_mi = max({max_mi, q[0], q[1]});\\n    int bits = 1 << (int)log2(max_mi);\\n    bitTree root;\\n    for (auto n : nums)\\n        root.insert(n, bits);\\n    vector<int> res;\\n    for (auto &q : qs) {\\n        auto max = root.getMax(q[0], q[1], bits, 0);\\n        res.push_back(max < 0 ? -1 : max);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct bitTree {\\n    bitTree* p[2] = {};\\n    void insert(int num, int bit) {\\n        if (bit > 0) {\\n            auto res = (num & bit) > 0;\\n            if (p[res] == nullptr)\\n                p[res] = new bitTree();\\n            p[res]->insert(num, bit / 2);\\n        }\\n    }\\n    int getMax(int xi, int mi, int bit, int bitSum) {\\n        if (bitSum > mi)\\n            return INT_MIN;            \\n        if (bit == 0)\\n            return 0;\\n        if (p[0] == nullptr)\\n            return ((xi & bit) ? 0 : bit) + p[1]->getMax(xi, mi, bit / 2, bitSum + bit);\\n        if (p[1] == nullptr)\\n            return ((xi & bit) ? bit : 0) + p[0]->getMax(xi, mi, bit / 2, bitSum);\\n        int pos = (xi & bit) == 0; // preferred path.\\n        int res = bit + p[pos]->getMax(xi, mi, bit / 2, bitSum + pos * bit);\\n        if (res < 0) // preferred choice numbers are too large.\\n            res = p[!pos]->getMax(xi, mi, bit / 2, bitSum + !pos * bit);\\n        return res;\\n    }\\n};\\nvector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& qs) {\\n    int max_mi = 0;\\n    for (auto &q : qs)\\n        max_mi = max({max_mi, q[0], q[1]});\\n    int bits = 1 << (int)log2(max_mi);\\n    bitTree root;\\n    for (auto n : nums)\\n        root.insert(n, bits);\\n    vector<int> res;\\n    for (auto &q : qs) {\\n        auto max = root.getMax(q[0], q[1], bits, 0);\\n        res.push_back(max < 0 ? -1 : max);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 988385,
                "title": "c-simple-trie-solution-beats-100-no-sort",
                "content": "```\\nclass Solution {\\n    \\n    class TreeNode {\\n    public:\\n        TreeNode* next[2];\\n        TreeNode () {next[0] = nullptr; next[1] = nullptr;};\\n    };\\n    TreeNode* buildTree(vector<int>& nums) {\\n        TreeNode* root = new TreeNode(), *cur;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            cur = root;\\n            for (int j = 31; j >= 0; j--) {\\n                int index = ((num >> j) & 1);\\n                if (cur->next[index] == nullptr)\\n                    cur->next[index] = new TreeNode();\\n                cur = cur->next[index];\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    int dfs(TreeNode* root, int x, int limit, int value, int height) {\\n        if (value > limit) return -1;\\n        \\n        if (height == -1) return x^value;\\n        \\n        int bit_x = (x >> height) & 1;\\n        \\n        if (root->next[1-bit_x] != nullptr) {\\n            int v = dfs(root->next[1-bit_x], x, limit, (value | ((1-bit_x) << height)), height-1);\\n            if (v >= 0) return v;\\n        }\\n        if (root->next[bit_x] != nullptr) {\\n            int v = dfs(root->next[bit_x], x, limit, (value | (bit_x << height)), height-1);\\n            if (v >= 0) return v;\\n        }\\n        \\n        return -1;\\n    }\\n    \\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        TreeNode* root = buildTree(nums);\\n        \\n        for (const vector<int>& query : queries) {            \\n            int tmp = dfs(root, query[0], query[1], 0, 31);\\n            ans.push_back(tmp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class TreeNode {\\n    public:\\n        TreeNode* next[2];\\n        TreeNode () {next[0] = nullptr; next[1] = nullptr;};\\n    };\\n    TreeNode* buildTree(vector<int>& nums) {\\n        TreeNode* root = new TreeNode(), *cur;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            cur = root;\\n            for (int j = 31; j >= 0; j--) {\\n                int index = ((num >> j) & 1);\\n                if (cur->next[index] == nullptr)\\n                    cur->next[index] = new TreeNode();\\n                cur = cur->next[index];\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    int dfs(TreeNode* root, int x, int limit, int value, int height) {\\n        if (value > limit) return -1;\\n        \\n        if (height == -1) return x^value;\\n        \\n        int bit_x = (x >> height) & 1;\\n        \\n        if (root->next[1-bit_x] != nullptr) {\\n            int v = dfs(root->next[1-bit_x], x, limit, (value | ((1-bit_x) << height)), height-1);\\n            if (v >= 0) return v;\\n        }\\n        if (root->next[bit_x] != nullptr) {\\n            int v = dfs(root->next[bit_x], x, limit, (value | (bit_x << height)), height-1);\\n            if (v >= 0) return v;\\n        }\\n        \\n        return -1;\\n    }\\n    \\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        TreeNode* root = buildTree(nums);\\n        \\n        for (const vector<int>& query : queries) {            \\n            int tmp = dfs(root, query[0], query[1], 0, 31);\\n            ans.push_back(tmp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988312,
                "title": "explanation-and-code-sorting-trie-c",
                "content": "\\n1. I first sort the queries array on the number we need to do comparisons with, this time saving the original indices.\\n2. Then I sort the nums array. There\\'s no need to save indices this time because they don\\'t matter.\\n3. Then I iterate through the queries. At each step (query = (num, lim)), i add any number from the nums array to a trie if that number hasn\\'t been added yet and it is less than or equal to the limit allowed for this query (indicated by the variable lim).\\n4. Each trie node contains two children - the child z is non-null if a zero bit exists at this position, and the child o is non-null if a one bit exists at this position. The root of the trie structure represents the 31st bit (i.e. the most significant bit in the 32 bit representation of any number). The direct children of the root node represent the 30th bit, and so on until the 0th bit.\\n5. Then for a query, we want to maximise the num\\'s xor with any number that has already been inserted in the trie. For this we start by comparing the most significant bit (31st) and go downwards in the trie. At any step, if the num\\'s bit is 0, then we first want to look for a one-bit in the trie. If it exists, great! Otherwise, we can compromise and rest assured that zero-bit must exist for this position. Similarly,  if the num\\'s bit is 1, then we first look for zero-bit in the trie. This is a greedy way to get the maximum xor possible.\\n\\nTime complexity:\\nSorting: O(nlogn + mlogm)\\nTrie insertion and querying: O(n + m) because the trie\\'s depth is fixed to 32.\\nOverall: O(nlogn + mlogm) dominated by the sorting step\\n\\n```\\nstruct Trie {\\n    Trie *z;\\n    Trie *o;\\n    Trie() {\\n        z = NULL;\\n        o = NULL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    Trie* insert(Trie* node, int k, int num) {\\n        if(node == NULL) {\\n            node = new Trie();\\n        }\\n        if(k < 0) return node;\\n        if(((num >> k) & 1) == 1) {\\n            node -> o = insert(node->o, k - 1, num);\\n        }\\n        else {\\n            node -> z = insert(node->z, k - 1, num);\\n        }\\n        return node;\\n    }\\n    \\n    int getmax(Trie* node, int k, int num) {\\n        if(k < 0) return 0;\\n        int res = 0;\\n        bool bit = ((num >> k) & 1);\\n        if(bit == 1) {\\n            if(node->z) {\\n                res = pow(2, k) + getmax(node->z, k - 1, num);\\n            }\\n            else {\\n                res = getmax(node->o, k - 1, num);\\n            }\\n        }\\n        else {\\n            if(node->o) {\\n                res = pow(2, k) + getmax(node->o, k - 1, num);\\n            }\\n            else {\\n                res = getmax(node->z, k - 1, num);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size();\\n        int m = queries.size();\\n        vector<int> ans(m, -1);\\n        vector<pair<pair<int, int>, int> > q;\\n        for(int i = 0; i < m; i++) {\\n            q.push_back({{queries[i][0], queries[i][1]}, i});\\n        }\\n        sort(q.begin(), q.end(), [](pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\\n            return a.first.second < b.first.second;\\n        });\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int j = 0;\\n        \\n        Trie *root = new Trie();\\n        \\n        for(int i = 0; i < m; i++) {\\n            pair<pair<int, int>, int> p = q[i];\\n            int num = p.first.first;\\n            int lim = p.first.second;\\n            int idx = p.second;\\n            \\n            while(j < n && nums[j] <= lim) {\\n                root = insert(root, 31, nums[j]);\\n                j++;\\n            }\\n            \\n            if(j > 0) {\\n                ans[idx] = getmax(root, 31, num);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nstruct Trie {\\n    Trie *z;\\n    Trie *o;\\n    Trie() {\\n        z = NULL;\\n        o = NULL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    Trie* insert(Trie* node, int k, int num) {\\n        if(node == NULL) {\\n            node = new Trie();\\n        }\\n        if(k < 0) return node;\\n        if(((num >> k) & 1) == 1) {\\n            node -> o = insert(node->o, k - 1, num);\\n        }\\n        else {\\n            node -> z = insert(node->z, k - 1, num);\\n        }\\n        return node;\\n    }\\n    \\n    int getmax(Trie* node, int k, int num) {\\n        if(k < 0) return 0;\\n        int res = 0;\\n        bool bit = ((num >> k) & 1);\\n        if(bit == 1) {\\n            if(node->z) {\\n                res = pow(2, k) + getmax(node->z, k - 1, num);\\n            }\\n            else {\\n                res = getmax(node->o, k - 1, num);\\n            }\\n        }\\n        else {\\n            if(node->o) {\\n                res = pow(2, k) + getmax(node->o, k - 1, num);\\n            }\\n            else {\\n                res = getmax(node->z, k - 1, num);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size();\\n        int m = queries.size();\\n        vector<int> ans(m, -1);\\n        vector<pair<pair<int, int>, int> > q;\\n        for(int i = 0; i < m; i++) {\\n            q.push_back({{queries[i][0], queries[i][1]}, i});\\n        }\\n        sort(q.begin(), q.end(), [](pair<pair<int, int>, int> a, pair<pair<int, int>, int> b) {\\n            return a.first.second < b.first.second;\\n        });\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int j = 0;\\n        \\n        Trie *root = new Trie();\\n        \\n        for(int i = 0; i < m; i++) {\\n            pair<pair<int, int>, int> p = q[i];\\n            int num = p.first.first;\\n            int lim = p.first.second;\\n            int idx = p.second;\\n            \\n            while(j < n && nums[j] <= lim) {\\n                root = insert(root, 31, nums[j]);\\n                j++;\\n            }\\n            \\n            if(j > 0) {\\n                ans[idx] = getmax(root, 31, num);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988230,
                "title": "java-trie-solution",
                "content": "The Idea is similar to problem https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/\\n\\n```\\n\\nclass Solution {\\n\\n    class Trie {\\n        Trie[] children;\\n        public Trie() {\\n            children = new Trie[2];\\n        }\\n    }\\n\\n    Trie root;\\n\\n    public int[] maximizeXor(int[] nums, int[][] q) {\\n\\n        int n = nums.length;\\n        int idx=0;\\n        root = new Trie();\\n        int[][] queries = new int[q.length][3];\\n\\n        for(int i=0;i<q.length;++i){\\n            queries[i][0] = q[i][0];\\n            queries[i][1] = q[i][1];\\n            queries[i][2] = i;\\n        }\\n\\n        int[] ans = new int[queries.length];\\n        Arrays.sort(nums);\\n        Arrays.sort(queries, (o1, o2) -> o1[1]-o2[1]);\\n\\n\\n        for(int i=0;i<queries.length;++i){\\n\\n            while(idx<n && nums[idx]<=queries[i][1]){\\n                add(nums[idx]);\\n                idx++;\\n            }\\n            if(nums[0]>queries[i][1])\\n                ans[queries[i][2]] = -1;\\n            else \\n                ans[queries[i][2]] = max_ans(queries[i][0]);\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n    public void add(int num){\\n        Trie curNode = root;\\n        for(int i = 31; i >= 0; i --) {\\n            int curBit = (num >>> i) & 1;\\n            if(curNode.children[curBit] == null) {\\n                curNode.children[curBit] = new Trie();\\n            }\\n            curNode = curNode.children[curBit];\\n        }\\n    }\\n\\n\\n    public int max_ans(int num){\\n        Trie curNode = root;\\n        int curSum = 0;\\n        for(int i = 31; i >= 0; i --) {\\n            int curBit = (num >>> i) & 1;\\n            if(curNode ==null || curNode.children==null)\\n                break;\\n            if(curNode.children[curBit ^ 1] != null) {\\n                curSum += (1 << i);\\n                curNode = curNode.children[curBit ^ 1];\\n            }else {\\n                curNode = curNode.children[curBit];\\n            }\\n        }\\n\\n        return curSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n\\n    class Trie {\\n        Trie[] children;\\n        public Trie() {\\n            children = new Trie[2];\\n        }\\n    }\\n\\n    Trie root;\\n\\n    public int[] maximizeXor(int[] nums, int[][] q) {\\n\\n        int n = nums.length;\\n        int idx=0;\\n        root = new Trie();\\n        int[][] queries = new int[q.length][3];\\n\\n        for(int i=0;i<q.length;++i){\\n            queries[i][0] = q[i][0];\\n            queries[i][1] = q[i][1];\\n            queries[i][2] = i;\\n        }\\n\\n        int[] ans = new int[queries.length];\\n        Arrays.sort(nums);\\n        Arrays.sort(queries, (o1, o2) -> o1[1]-o2[1]);\\n\\n\\n        for(int i=0;i<queries.length;++i){\\n\\n            while(idx<n && nums[idx]<=queries[i][1]){\\n                add(nums[idx]);\\n                idx++;\\n            }\\n            if(nums[0]>queries[i][1])\\n                ans[queries[i][2]] = -1;\\n            else \\n                ans[queries[i][2]] = max_ans(queries[i][0]);\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n    public void add(int num){\\n        Trie curNode = root;\\n        for(int i = 31; i >= 0; i --) {\\n            int curBit = (num >>> i) & 1;\\n            if(curNode.children[curBit] == null) {\\n                curNode.children[curBit] = new Trie();\\n            }\\n            curNode = curNode.children[curBit];\\n        }\\n    }\\n\\n\\n    public int max_ans(int num){\\n        Trie curNode = root;\\n        int curSum = 0;\\n        for(int i = 31; i >= 0; i --) {\\n            int curBit = (num >>> i) & 1;\\n            if(curNode ==null || curNode.children==null)\\n                break;\\n            if(curNode.children[curBit ^ 1] != null) {\\n                curSum += (1 << i);\\n                curNode = curNode.children[curBit ^ 1];\\n            }else {\\n                curNode = curNode.children[curBit];\\n            }\\n        }\\n\\n        return curSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392941,
                "title": "c-clean-solution-with-explanation-trie-without-sorting-o-n",
                "content": "I approached this question same as **Maximum XOR of Two Numbers in an Array** this question with a slight modification. I just added a small information in every Trie node about the minimum element that I can get by going in the direction of that bit. This helped me to implement the code with a time complexity of O(32n) which is almost same as **O(n)**.\\n\\n```\\nclass Node{\\npublic:\\n    Node* links[2];\\n    int mini[2];\\n    \\n    Node(){\\n        links[0]=NULL,links[1]=NULL;\\n        mini[0]=INT_MAX,mini[1]=INT_MAX;\\n    }\\n    bool containsKey(int i){\\n        return links[i]!=NULL;\\n    }\\n    void put(int i, Node* node){\\n        links[i]=node;\\n    }\\n    Node* get(int i){\\n        return links[i];\\n    }\\n    void putMin(int bit, int x){\\n        mini[bit]=min(mini[bit],x);\\n    }\\n    int getMin(int bit){\\n        return mini[bit];\\n    }\\n};\\nclass Solution {\\npublic:\\n    Node* root;\\n    void insert(int x)\\n    {\\n        Node* curr=root;\\n        int k=32;\\n        while(k--)\\n        {\\n            int bit=((x>>k)&1);\\n            if(!curr->containsKey(bit))\\n                curr->put(bit,new Node());\\n            curr->putMin(bit,x);\\n            curr=curr->get(bit);\\n        }\\n    }\\n    int searchMaxXOR(int x, int m)\\n    {\\n        Node* curr=root;\\n        int ans=0,k=32;\\n        while(k--)\\n        {\\n            ans=ans*2;\\n            \\n            int bit=((x>>k)&1);\\n            if(curr->containsKey(1-bit) && curr->getMin(1-bit)<=m)\\n            {\\n                curr=curr->get(1-bit);\\n                ans++;\\n            }\\n            else\\n                curr=curr->get(bit);\\n        }\\n        return ans;\\n    }\\n    vector<int> maximizeXor(vector<int>& v, vector<vector<int>>& q) {\\n        int n=v.size();\\n        root=new Node();\\n        for(int i=0;i<n;i++)\\n            insert(v[i]);\\n        int minEle=*min_element(v.begin(),v.end());\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int x=q[i][0],m=q[i][1];\\n            if(minEle<=m)\\n                ans.push_back(searchMaxXOR(x,m));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\npublic:\\n    Node* links[2];\\n    int mini[2];\\n    \\n    Node(){\\n        links[0]=NULL,links[1]=NULL;\\n        mini[0]=INT_MAX,mini[1]=INT_MAX;\\n    }\\n    bool containsKey(int i){\\n        return links[i]!=NULL;\\n    }\\n    void put(int i, Node* node){\\n        links[i]=node;\\n    }\\n    Node* get(int i){\\n        return links[i];\\n    }\\n    void putMin(int bit, int x){\\n        mini[bit]=min(mini[bit],x);\\n    }\\n    int getMin(int bit){\\n        return mini[bit];\\n    }\\n};\\nclass Solution {\\npublic:\\n    Node* root;\\n    void insert(int x)\\n    {\\n        Node* curr=root;\\n        int k=32;\\n        while(k--)\\n        {\\n            int bit=((x>>k)&1);\\n            if(!curr->containsKey(bit))\\n                curr->put(bit,new Node());\\n            curr->putMin(bit,x);\\n            curr=curr->get(bit);\\n        }\\n    }\\n    int searchMaxXOR(int x, int m)\\n    {\\n        Node* curr=root;\\n        int ans=0,k=32;\\n        while(k--)\\n        {\\n            ans=ans*2;\\n            \\n            int bit=((x>>k)&1);\\n            if(curr->containsKey(1-bit) && curr->getMin(1-bit)<=m)\\n            {\\n                curr=curr->get(1-bit);\\n                ans++;\\n            }\\n            else\\n                curr=curr->get(bit);\\n        }\\n        return ans;\\n    }\\n    vector<int> maximizeXor(vector<int>& v, vector<vector<int>>& q) {\\n        int n=v.size();\\n        root=new Node();\\n        for(int i=0;i<n;i++)\\n            insert(v[i]);\\n        int minEle=*min_element(v.begin(),v.end());\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int x=q[i][0],m=q[i][1];\\n            if(minEle<=m)\\n                ans.push_back(searchMaxXOR(x,m));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910287,
                "title": "simple-and-clean-code-trie",
                "content": "```\\nclass Node {\\nprivate:\\n    Node *links[2];\\n\\npublic:\\n    bool containsKey(int bit) {\\n        return (links[bit] != NULL);\\n    }\\n\\n    Node *get(int bit) {\\n        return links[bit];\\n    }\\n\\n    void put(int bit, Node *node) {\\n        links[bit] = node;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node *root;\\n\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n\\n    void insert(int num) {\\n        Node *node = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!node->containsKey(bit)) {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n\\n    int getMax(int num) {\\n        Node *node = root;\\n        int maxNum = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (node->containsKey(1 - bit)) {\\n                maxNum = maxNum | (1 << i);\\n                node = node->get(1 - bit);\\n            }\\n            else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, pair<int, int> > > offlineQueries;\\n        vector<int> ans(queries.size(), 0);\\n\\n        for (int i = 0; i < queries.size(); i++)\\n            offlineQueries.push_back({queries[i][1], {queries[i][0], i}});\\n\\n        sort(offlineQueries.begin(), offlineQueries.end());\\n\\n        int i = 0, n = nums.size();\\n        Trie t;\\n\\n        for (int k = 0; k < queries.size(); k++) {\\n            int ai = offlineQueries[k].first;\\n            int xi = offlineQueries[k].second.first;\\n            int qIndx = offlineQueries[k].second.second;\\n\\n            while (i < n && nums[i] <= ai) {\\n                t.insert(nums[i]);\\n                i++;\\n            }\\n\\n            if (i == 0)  ans[qIndx] = -1;\\n            else    ans[qIndx] = t.getMax(xi);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nclass Node {\\nprivate:\\n    Node *links[2];\\n\\npublic:\\n    bool containsKey(int bit) {\\n        return (links[bit] != NULL);\\n    }\\n\\n    Node *get(int bit) {\\n        return links[bit];\\n    }\\n\\n    void put(int bit, Node *node) {\\n        links[bit] = node;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node *root;\\n\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n\\n    void insert(int num) {\\n        Node *node = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!node->containsKey(bit)) {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n\\n    int getMax(int num) {\\n        Node *node = root;\\n        int maxNum = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (node->containsKey(1 - bit)) {\\n                maxNum = maxNum | (1 << i);\\n                node = node->get(1 - bit);\\n            }\\n            else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, pair<int, int> > > offlineQueries;\\n        vector<int> ans(queries.size(), 0);\\n\\n        for (int i = 0; i < queries.size(); i++)\\n            offlineQueries.push_back({queries[i][1], {queries[i][0], i}});\\n\\n        sort(offlineQueries.begin(), offlineQueries.end());\\n\\n        int i = 0, n = nums.size();\\n        Trie t;\\n\\n        for (int k = 0; k < queries.size(); k++) {\\n            int ai = offlineQueries[k].first;\\n            int xi = offlineQueries[k].second.first;\\n            int qIndx = offlineQueries[k].second.second;\\n\\n            while (i < n && nums[i] <= ai) {\\n                t.insert(nums[i]);\\n                i++;\\n            }\\n\\n            if (i == 0)  ans[qIndx] = -1;\\n            else    ans[qIndx] = t.getMax(xi);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080060,
                "title": "java-trie-sort-bit-manipulation-o-n-logn-k-logk",
                "content": "\\n    public class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tint data;\\n\\t\\t\\tNode[] children;\\n\\n\\t\\t\\tpublic Node(int data) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.children = new Node[2];\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\t\\tint count;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(-1);\\n\\t\\t\\tthis.count = 0;\\n\\t\\t}\\n\\n\\t\\t// O(32)\\n\\t\\tpublic void addWord(int num) {\\n            this.count++;\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = 30; i >= 0; i--) {\\n\\t\\t\\t\\tint mask = 1 << i;\\n\\t\\t\\t\\tint bit = num & mask;\\n\\t\\t\\t\\tbit = (bit != 0) ? 1 : 0;\\n\\t\\t\\t\\tNode temp = curr.children[bit];\\n\\t\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\t\\ttemp = new Node(bit);\\n\\t\\t\\t\\t\\tcurr.children[bit] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// O(32)\\n\\t\\tpublic int searchWord(int num) {\\n\\n\\t\\t\\tif (count == 0)\\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor (int i = 30; i >= 0; i--) {\\n\\t\\t\\t\\tint mask = 1 << i;\\n\\t\\t\\t\\tint bit = num & mask;\\n\\t\\t\\t\\tbit = (bit != 0) ? 1 : 0;\\n\\t\\t\\t\\tint toggle = bit ^ 1;\\n\\t\\t\\t\\tNode temp = curr.children[toggle];\\n\\t\\t\\t\\tif (temp != null) {\\n\\t\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t\\t\\tans |= mask;\\n\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\tcurr = curr.children[bit];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// O(nums.length*log(nums.length) + queries.length*log(queries.length))\\n\\tpublic int[] maximizeXor(int[] nums, int[][] queries) {\\n\\n\\t\\tTrie trie = new Trie();\\n\\t\\tint len = queries.length;\\n\\t\\tint len2 = nums.length;\\n\\t\\tint[] ans = new int[len];\\n\\n\\t\\tint[][] temp = new int[len][3];\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\ttemp[i][0] = queries[i][0];\\n\\t\\t\\ttemp[i][1] = queries[i][1];\\n\\t\\t\\ttemp[i][2] = i;\\n\\t\\t}\\n\\n\\t\\tArrays.sort(nums);\\n\\t\\tArrays.sort(temp, new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[1] - o2[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tint index = 0;\\n\\t\\tfor (int[] query : temp) {\\n\\t\\t\\twhile (index < len2 && nums[index] <= query[1]) {\\n\\t\\t\\t\\ttrie.addWord(nums[index]);\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tans[query[2]] = trie.searchWord(query[0]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    public class Trie {\\n\\n\\t\\tprivate class Node {\\n\\n\\t\\t\\tint data;\\n\\t\\t\\tNode[] children;\\n\\n\\t\\t\\tpublic Node(int data) {\\n\\t\\t\\t\\tthis.data = data;\\n\\t\\t\\t\\tthis.children = new Node[2];\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate Node root;\\n\\t\\tint count;\\n\\n\\t\\t// O(1)\\n\\t\\tpublic Trie() {\\n\\t\\t\\tthis.root = new Node(-1);\\n\\t\\t\\tthis.count = 0;\\n\\t\\t}\\n\\n\\t\\t// O(32)\\n\\t\\tpublic void addWord(int num) {\\n            this.count++;\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tfor (int i = 30; i >= 0; i--) {\\n\\t\\t\\t\\tint mask = 1 << i;\\n\\t\\t\\t\\tint bit = num & mask;\\n\\t\\t\\t\\tbit = (bit != 0) ? 1 : 0;\\n\\t\\t\\t\\tNode temp = curr.children[bit];\\n\\t\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\t\\ttemp = new Node(bit);\\n\\t\\t\\t\\t\\tcurr.children[bit] = temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// O(32)\\n\\t\\tpublic int searchWord(int num) {\\n\\n\\t\\t\\tif (count == 0)\\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor (int i = 30; i >= 0; i--) {\\n\\t\\t\\t\\tint mask = 1 << i;\\n\\t\\t\\t\\tint bit = num & mask;\\n\\t\\t\\t\\tbit = (bit != 0) ? 1 : 0;\\n\\t\\t\\t\\tint toggle = bit ^ 1;\\n\\t\\t\\t\\tNode temp = curr.children[toggle];\\n\\t\\t\\t\\tif (temp != null) {\\n\\t\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t\\t\\tans |= mask;\\n\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\tcurr = curr.children[bit];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// O(nums.length*log(nums.length) + queries.length*log(queries.length))\\n\\tpublic int[] maximizeXor(int[] nums, int[][] queries) {\\n\\n\\t\\tTrie trie = new Trie();\\n\\t\\tint len = queries.length;\\n\\t\\tint len2 = nums.length;\\n\\t\\tint[] ans = new int[len];\\n\\n\\t\\tint[][] temp = new int[len][3];\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\ttemp[i][0] = queries[i][0];\\n\\t\\t\\ttemp[i][1] = queries[i][1];\\n\\t\\t\\ttemp[i][2] = i;\\n\\t\\t}\\n\\n\\t\\tArrays.sort(nums);\\n\\t\\tArrays.sort(temp, new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[1] - o2[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tint index = 0;\\n\\t\\tfor (int[] query : temp) {\\n\\t\\t\\twhile (index < len2 && nums[index] <= query[1]) {\\n\\t\\t\\t\\ttrie.addWord(nums[index]);\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tans[query[2]] = trie.searchWord(query[0]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 996533,
                "title": "c-simple-full-trie-solution-with-detailed-explanation-comments-in-the-code",
                "content": "1) Sort queries in increasing order of mi values.\\n2) Sort nums array\\n3) Iterate over queries and keep inserting values in the trie which are lesser than the current mi value.\\n4) Look for the max xor we can get in the trie\\n\\n```\\nclass Solution {\\n    class TreeNode{\\n        public : \\n          TreeNode * next[2];\\n          int storeVal;\\n          TreeNode() {next[0] = NULL, next[1] = NULL, storeVal = 0;}\\n    };\\n    void insert(TreeNode *root, int val)\\n    {\\n        for(int i=31;i>=0;i--)\\n        {\\n            bool res= (val & (1 << i));\\n            if(root->next[res] == NULL) \\n               root->next[res]=new TreeNode();\\n            root=root->next[res];\\n        }\\n        root->storeVal = val;\\n    }\\n    int search(TreeNode *root, int val)\\n    {\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            bool res = (val & (1 << i));\\n            if(root->next[1 - res] != NULL)\\n                root = root->next[1 - res];\\n            else\\n                root=root->next[res];\\n        }\\n       return (root->storeVal ^ val); \\n    }\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n          int n = nums.size();\\n          // To get the correct order after sorting\\n          for(int i = 0; i < queries.size() ; i++)\\n              queries[i].push_back(i);\\n          // Sort the queries according to accending mi values     \\n          sort(queries.begin(),queries.end(), [](auto &a, auto &b){ return a[1] < b[1];});\\n          sort(nums.begin(), nums.end());\\n          int index = 0;\\n          TreeNode * root = new TreeNode();\\n          \\n          vector<int>res(queries.size(),-1);\\n          for(auto q : queries)\\n          {\\n              //keep inserting all the values which are lesser than mi in the trie\\n              while(index < n && nums[index] <= q[1])\\n              {\\n                  insert(root, nums[index]);\\n                  index ++;\\n              }\\n              // if any value inserted then we are now in a state of taking xor with atleast any number which satifies the limit                  condition\\n              if(index)\\n                res[q[2]] =  search(root, q[0]); \\n          }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TreeNode{\\n        public : \\n          TreeNode * next[2];\\n          int storeVal;\\n          TreeNode() {next[0] = NULL, next[1] = NULL, storeVal = 0;}\\n    };\\n    void insert(TreeNode *root, int val)\\n    {\\n        for(int i=31;i>=0;i--)\\n        {\\n            bool res= (val & (1 << i));\\n            if(root->next[res] == NULL) \\n               root->next[res]=new TreeNode();\\n            root=root->next[res];\\n        }\\n        root->storeVal = val;\\n    }\\n    int search(TreeNode *root, int val)\\n    {\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            bool res = (val & (1 << i));\\n            if(root->next[1 - res] != NULL)\\n                root = root->next[1 - res];\\n            else\\n                root=root->next[res];\\n        }\\n       return (root->storeVal ^ val); \\n    }\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n          int n = nums.size();\\n          // To get the correct order after sorting\\n          for(int i = 0; i < queries.size() ; i++)\\n              queries[i].push_back(i);\\n          // Sort the queries according to accending mi values     \\n          sort(queries.begin(),queries.end(), [](auto &a, auto &b){ return a[1] < b[1];});\\n          sort(nums.begin(), nums.end());\\n          int index = 0;\\n          TreeNode * root = new TreeNode();\\n          \\n          vector<int>res(queries.size(),-1);\\n          for(auto q : queries)\\n          {\\n              //keep inserting all the values which are lesser than mi in the trie\\n              while(index < n && nums[index] <= q[1])\\n              {\\n                  insert(root, nums[index]);\\n                  index ++;\\n              }\\n              // if any value inserted then we are now in a state of taking xor with atleast any number which satifies the limit                  condition\\n              if(index)\\n                res[q[2]] =  search(root, q[0]); \\n          }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989181,
                "title": "c-trie-propagation-no-sort-faster",
                "content": "Keep tracking the minimum value under each Trie node. Something like propagation in the segment tree.\\n\\n```\\nclass Trie\\n{\\npublic:    \\n    \\n    Trie()\\n    {\\n        Nexts[0] = NULL;\\n        Nexts[1] = NULL;\\n        MinVal = INT_MAX;\\n    }\\n    \\n    Trie* Nexts[2];      \\n    int MinVal;\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int m;\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        \\n        int n = queries.size();\\n        vector<int> ans(n, -1);       \\n        \\n        Trie root;\\n        for (int i = 0; i < nums.size(); ++i)\\n        {\\n            bitset<32> bits( nums[i] );               \\n            Insert(&root, bits, 32);\\n        }              \\n                \\n        for (int i = 0; i < queries.size(); ++i)\\n        {           \\n            bitset<32> bits( queries[i][0] );            \\n            m = queries[i][1];\\n            int ret = Search(&root, bits, 32, 0, 0);              \\n            if (ret != -1) ans[i] = ret ^ queries[i][0];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int Search(Trie* pNode, bitset<32>& num, int index, int diff, int val)\\n    {                       \\n        if (val > m) return -1;\\n        \\n        \\n        if (index < 0)\\n        {\\n            return val;\\n        }\\n        else\\n        {\\n            if (pNode->MinVal > m) return -1;\\n            \\n            if (num[index] == 0)\\n            {    \\n                int ret = -1;\\n                if (pNode->Nexts[1] != NULL) \\n                {\\n                    ret = Search(pNode->Nexts[1], num, index - 1, diff * 2 + 1, val * 2 + 1);\\n                    if (ret != -1) return ret;\\n                }\\n                if (pNode->Nexts[0] != NULL) \\n                {\\n                    ret = max(ret, Search(pNode->Nexts[0], num, index - 1, diff * 2, val * 2));\\n                }\\n                return ret;\\n            }\\n            else //1\\n            {\\n                int ret = -1;\\n                if (pNode->Nexts[0] != NULL) \\n                {\\n                    ret = Search(pNode->Nexts[0], num, index - 1, diff * 2 + 1, val * 2);\\n                    if (ret != -1) return ret;\\n                }\\n                if (pNode->Nexts[1] != NULL) \\n                {\\n                    ret = Search(pNode->Nexts[1], num, index - 1, diff * 2, val * 2 + 1);\\n                }\\n                return ret;\\n            }\\n        }\\n    }\\n    \\n    int Insert(Trie* pNode, bitset<32>& num, int index)\\n    {\\n        if (index < 0)\\n        {\\n            return num.to_ulong();\\n        }\\n        \\n        if (pNode->Nexts[ num[index] ] == NULL)\\n        {\\n            pNode->Nexts[ num[index] ] = new Trie();\\n        }\\n                \\n        pNode->MinVal = min(pNode->MinVal, Insert(pNode->Nexts[ num[index] ], num, index - 1));\\n        return pNode->MinVal;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie\\n{\\npublic:    \\n    \\n    Trie()\\n    {\\n        Nexts[0] = NULL;\\n        Nexts[1] = NULL;\\n        MinVal = INT_MAX;\\n    }\\n    \\n    Trie* Nexts[2];      \\n    int MinVal;\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int m;\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        \\n        int n = queries.size();\\n        vector<int> ans(n, -1);       \\n        \\n        Trie root;\\n        for (int i = 0; i < nums.size(); ++i)\\n        {\\n            bitset<32> bits( nums[i] );               \\n            Insert(&root, bits, 32);\\n        }              \\n                \\n        for (int i = 0; i < queries.size(); ++i)\\n        {           \\n            bitset<32> bits( queries[i][0] );            \\n            m = queries[i][1];\\n            int ret = Search(&root, bits, 32, 0, 0);              \\n            if (ret != -1) ans[i] = ret ^ queries[i][0];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int Search(Trie* pNode, bitset<32>& num, int index, int diff, int val)\\n    {                       \\n        if (val > m) return -1;\\n        \\n        \\n        if (index < 0)\\n        {\\n            return val;\\n        }\\n        else\\n        {\\n            if (pNode->MinVal > m) return -1;\\n            \\n            if (num[index] == 0)\\n            {    \\n                int ret = -1;\\n                if (pNode->Nexts[1] != NULL) \\n                {\\n                    ret = Search(pNode->Nexts[1], num, index - 1, diff * 2 + 1, val * 2 + 1);\\n                    if (ret != -1) return ret;\\n                }\\n                if (pNode->Nexts[0] != NULL) \\n                {\\n                    ret = max(ret, Search(pNode->Nexts[0], num, index - 1, diff * 2, val * 2));\\n                }\\n                return ret;\\n            }\\n            else //1\\n            {\\n                int ret = -1;\\n                if (pNode->Nexts[0] != NULL) \\n                {\\n                    ret = Search(pNode->Nexts[0], num, index - 1, diff * 2 + 1, val * 2);\\n                    if (ret != -1) return ret;\\n                }\\n                if (pNode->Nexts[1] != NULL) \\n                {\\n                    ret = Search(pNode->Nexts[1], num, index - 1, diff * 2, val * 2 + 1);\\n                }\\n                return ret;\\n            }\\n        }\\n    }\\n    \\n    int Insert(Trie* pNode, bitset<32>& num, int index)\\n    {\\n        if (index < 0)\\n        {\\n            return num.to_ulong();\\n        }\\n        \\n        if (pNode->Nexts[ num[index] ] == NULL)\\n        {\\n            pNode->Nexts[ num[index] ] = new Trie();\\n        }\\n                \\n        pNode->MinVal = min(pNode->MinVal, Insert(pNode->Nexts[ num[index] ], num, index - 1));\\n        return pNode->MinVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785745,
                "title": "c-trie-data-structure-easy-approach",
                "content": "Here is my code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Node{\\n\\t\\tpublic:\\n\\n\\t\\tNode* links[2];\\n\\t};\\n\\tclass Trie{\\n\\t\\tpublic:\\n\\n\\t\\tNode* root;\\n\\t\\tTrie(){\\n\\t\\t\\troot=new Node();\\n\\t\\t}\\n\\t\\tvoid insert(int num){\\n\\t\\t\\tNode* node=root;\\n\\t\\t\\tfor(int i=31; i>=0; i--){\\n\\t\\t\\t\\tint bit=(num>>i)&1;\\n\\t\\t\\t\\tif(!node->links[bit]){\\n\\t\\t\\t\\t\\tnode->links[bit]=new Node();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnode=node->links[bit];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxnum(int num){\\n\\t\\t\\tint maxi=0;\\n\\t\\t\\tNode* node=root;\\n\\t\\t\\tfor(int i=31; i>=0; i--){\\n\\t\\t\\t\\tint bit=(num>>i)&1;\\n\\t\\t\\t\\tif(node->links[1-bit]){\\n\\t\\t\\t\\t\\tmaxi=maxi|(1<<i);\\n\\t\\t\\t\\t\\tnode=node->links[1-bit];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tnode=node->links[bit];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tvector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n\\t\\t\\tTrie trie;\\n\\t\\t\\tsort(arr.begin(), arr.end());\\n\\t\\t\\tvector<pair<int, pair<int, int>>>v;\\n\\t\\t\\tfor(int i=0; i<queries.size(); i++){\\n\\t\\t\\t\\tv.push_back({queries[i][1], {queries[i][0], i}});\\n\\t\\t\\t}\\n\\t\\t\\tsort(v.begin(), v.end());\\n\\t\\t\\tvector<int>v1(queries.size(), 0);\\n\\t\\t\\tint st=0, en=arr.size();\\n\\t\\t\\tfor(int i=0; i<queries.size(); i++){\\n\\t\\t\\t\\twhile(st<en && arr[st]<=v[i].first){\\n\\t\\t\\t\\t\\ttrie.insert(arr[st]);\\n\\t\\t\\t\\t\\tst++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(st==0){v1[v[i].second.second]=-1;}\\n\\t\\t\\t\\telse{v1[v[i].second.second]=trie.maxnum(v[i].second.first);}\\n\\t\\t\\t}\\n\\t\\t\\treturn v1;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tvector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n\\t\\t\\tTrie trie;\\n\\t\\t\\tsort(arr.begin(), arr.end());\\n\\t\\t\\tvector<pair<int, pair<int, int>>>v;\\n\\t\\t\\tfor(int i=0; i<queries.size(); i++){\\n\\t\\t\\t\\tv.push_back({queries[i][1], {queries[i][0], i}",
                "codeTag": "Java"
            },
            {
                "id": 2201260,
                "title": "trie-solution-with-offline-processing-with-explanation",
                "content": "**Prerequisite** : \\n1. Trie\\n2. [https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)\\n\\n**Intution** : We try to think of the problem in a different way what if instead of answering query for (x, m) where x is the element by which we had to take the XOR and m is the upper bound for the other element which can be chosen we just need to query for maximum XOR from a pool of elements which can change with every query. This is a very standard problem and can be easily solved by making use of a **Trie** Data Structure.\\n\\nNow how to change the pool of elements so that our original query (x, m) can be answered. So it is easy to see that we only care about the element say \"a\" such that (a <= m).\\nSo we answer queries in increasing order of m for each query and insert all the elements which are **atmost** m into our Trie.\\n\\n**Steps** : \\n1. Sort the queries in increasing order of m.\\n2. Sort the elements in increasing order.\\n2. To answer each query insert the elements <= m.\\n3. Finding maximum XOR with x and current elements in our Trie.\\n\\n**Code for reference** \\n\\n```\\nclass Node {\\npublic:\\n    vector<Node *> child;\\n    Node() {\\n        child.assign(2, NULL);\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Node *root;\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int n) {\\n        Node *t = root;\\n        for (int i = 31; i >= 0; --i) {\\n            bool bit = ((1 << i) & n);\\n            if (!t->child[bit])\\n                t->child[bit] = new Node();\\n            t = t->child[bit];\\n        }\\n    }\\n    int query(int x) {\\n        Node *t = root;\\n        int res = 0;\\n        for (int i = 31; i >= 0; --i) {\\n            int bit = (bool)((1 << i) & x);\\n            if (t->child[bit ^ 1]) {\\n                res |= (1 << i);\\n                t = t->child[bit ^ 1];\\n            } else {\\n                t = t->child[bit];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = (int) queries.size();\\n        vector<int> ans(n, -1);\\n        \\n        vector<int> idx(n);\\n        iota(idx.begin(), idx.end(), 0);     \\n        sort(idx.begin(), idx.end(), [&](int i, int j) {\\n            return queries[i][1] < queries[j][1];\\n        });\\n        \\n        sort(nums.begin(), nums.end());\\n        Trie t;\\n        int st = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int x = queries[idx[i]][0];\\n            int m = queries[idx[i]][1];\\n            while (st < (int) nums.size() && nums[st] <= m) {\\n                t.insert(nums[st]);\\n                st++;\\n            }\\n            ans[idx[i]] = (st ? t.query(x) : -1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity : (32 * Q + QlogQ + NLogN)\\nSpace Complexity : (2 * 32 * N + Q)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Node {\\npublic:\\n    vector<Node *> child;\\n    Node() {\\n        child.assign(2, NULL);\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Node *root;\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int n) {\\n        Node *t = root;\\n        for (int i = 31; i >= 0; --i) {\\n            bool bit = ((1 << i) & n);\\n            if (!t->child[bit])\\n                t->child[bit] = new Node();\\n            t = t->child[bit];\\n        }\\n    }\\n    int query(int x) {\\n        Node *t = root;\\n        int res = 0;\\n        for (int i = 31; i >= 0; --i) {\\n            int bit = (bool)((1 << i) & x);\\n            if (t->child[bit ^ 1]) {\\n                res |= (1 << i);\\n                t = t->child[bit ^ 1];\\n            } else {\\n                t = t->child[bit];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = (int) queries.size();\\n        vector<int> ans(n, -1);\\n        \\n        vector<int> idx(n);\\n        iota(idx.begin(), idx.end(), 0);     \\n        sort(idx.begin(), idx.end(), [&](int i, int j) {\\n            return queries[i][1] < queries[j][1];\\n        });\\n        \\n        sort(nums.begin(), nums.end());\\n        Trie t;\\n        int st = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int x = queries[idx[i]][0];\\n            int m = queries[idx[i]][1];\\n            while (st < (int) nums.size() && nums[st] <= m) {\\n                t.insert(nums[st]);\\n                st++;\\n            }\\n            ans[idx[i]] = (st ? t.query(x) : -1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434352,
                "title": "modified-trie-solution-explained-in-detail",
                "content": "```\\nNote: You should consider 31 bits, Here I am just considering 3 bits to explain.\\n The idea is to make trie node such that it also contains minimum number going through node.\\n    Let nums=[0,1,2,3,4]\\n    Lets write it in bits.\\n    nums=[000,001,010,011,100]\\n    Then our trie containing bits only will look like this.\\n              root\\n            /      \\\\\\n           0        1\\n         /  \\\\       /\\n        0    1      0\\n      / \\\\    / \\\\   /\\n    0    1   0  1  0\\n    \\n   Now this would be sufficient to find max XOR if there was no constrains that is if mi was not included in question.See easier problem:\\n   Since there is constraint on what maximum number we can take, we can do the following.\\n   1. At each node, we will keep another place to store minimum number going through that node.\\n      See modified trie below for clear understanding. The number in bracket () represents the minimum number going through node.\\n               root\\n             /      \\\\\\n            0(0)     1(4)\\n          /    \\\\      \\\\\\n        0(0)    1(2)   0(4)\\n      / \\\\      /  \\\\     \\\\\\n    0(0) 1(1) 0(2) 1(3)  0(4)\\n   \\n   2. Now Traverse like this, if queries = [[3,1],[1,3],[5,6]]\\n      Intially res=0\\n      First query:\\n           (3,1) \\n      Covert 3 into bit.\\n          011\\n          a)Look leftmost bit that was not considered previously.\\n          b)Look for opposite bit in trie, and see if its minima is less than (mi).\\n          c)If yes, then traverse through it, Do res=(res|(1<<(position of bit))\\n            else if traverse through same bit also only if its minima is less than (mi), res remains same                           \\n            else\\n                res=-1 (not possible) just break    \\n            repeat from a \\n            \\nclass Node{\\npublic:\\n       int c;\\n       int minima;\\n       Node* children[2];\\n};\\nNode *getNode(int c)\\n{\\n         Node *node=new Node();\\n         node->c=c;\\n         node->minima=INT_MAX;\\n         for(int i=0;i<2;i++)\\n         {\\n             node->children[i]=NULL;\\n         }\\n         return node;\\n}\\nclass Trie{\\nprivate:\\n    Node *root;\\npublic:\\n    Trie()\\n    {\\n        root=getNode(2);\\n    }\\n    Node *cur;\\n    int x,res;\\n    vector<int> calculate(vector<int>& nums,vector<vector<int>>& q)\\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cur=root;\\n            for(int j=31;j>=0;j--)\\n            {\\n                if(nums[i]&(1<<j))\\n                    x=1;\\n                else\\n                    x=0;\\n                if(cur->children[x]==NULL)\\n                {\\n                    cur->children[x]=getNode(x);\\n                }\\n                cur=cur->children[x];\\n                cur->minima=min(cur->minima,nums[i]);\\n            }\\n        }\\n        int m=q.size();\\n        vector<int> ans(m);\\n        for(int i=0;i<q.size();i++)\\n        {\\n            cur=root;\\n            res=0;\\n            for(int j=31;j>=0;j--)\\n            {\\n                if(q[i][0]&(1<<j))\\n                    x=1;\\n                else\\n                    x=0;\\n                if(cur->children[x^1]!=NULL && (cur->children[x^1]->minima )<=q[i][1])\\n                {\\n                    res=(res|(1<<j));\\n                    cur=cur->children[x^1];\\n                }\\n                else if(cur->children[x]!=NULL && cur->children[x]->minima<=q[i][1])\\n                    cur=cur->children[x];\\n                else\\n                {\\n                    res=-1;\\n                    break;\\n                }\\n            }\\n            ans[i]=res;\\n        }\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        return trie.calculate(nums,queries);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nNote: You should consider 31 bits, Here I am just considering 3 bits to explain.\\n The idea is to make trie node such that it also contains minimum number going through node.\\n    Let nums=[0,1,2,3,4]\\n    Lets write it in bits.\\n    nums=[000,001,010,011,100]\\n    Then our trie containing bits only will look like this.\\n              root\\n            /      \\\\\\n           0        1\\n         /  \\\\       /\\n        0    1      0\\n      / \\\\    / \\\\   /\\n    0    1   0  1  0\\n    \\n   Now this would be sufficient to find max XOR if there was no constrains that is if mi was not included in question.See easier problem:\\n   Since there is constraint on what maximum number we can take, we can do the following.\\n   1. At each node, we will keep another place to store minimum number going through that node.\\n      See modified trie below for clear understanding. The number in bracket () represents the minimum number going through node.\\n               root\\n             /      \\\\\\n            0(0)     1(4)\\n          /    \\\\      \\\\\\n        0(0)    1(2)   0(4)\\n      / \\\\      /  \\\\     \\\\\\n    0(0) 1(1) 0(2) 1(3)  0(4)\\n   \\n   2. Now Traverse like this, if queries = [[3,1],[1,3],[5,6]]\\n      Intially res=0\\n      First query:\\n           (3,1) \\n      Covert 3 into bit.\\n          011\\n          a)Look leftmost bit that was not considered previously.\\n          b)Look for opposite bit in trie, and see if its minima is less than (mi).\\n          c)If yes, then traverse through it, Do res=(res|(1<<(position of bit))\\n            else if traverse through same bit also only if its minima is less than (mi), res remains same                           \\n            else\\n                res=-1 (not possible) just break    \\n            repeat from a \\n            \\nclass Node{\\npublic:\\n       int c;\\n       int minima;\\n       Node* children[2];\\n};\\nNode *getNode(int c)\\n{\\n         Node *node=new Node();\\n         node->c=c;\\n         node->minima=INT_MAX;\\n         for(int i=0;i<2;i++)\\n         {\\n             node->children[i]=NULL;\\n         }\\n         return node;\\n}\\nclass Trie{\\nprivate:\\n    Node *root;\\npublic:\\n    Trie()\\n    {\\n        root=getNode(2);\\n    }\\n    Node *cur;\\n    int x,res;\\n    vector<int> calculate(vector<int>& nums,vector<vector<int>>& q)\\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cur=root;\\n            for(int j=31;j>=0;j--)\\n            {\\n                if(nums[i]&(1<<j))\\n                    x=1;\\n                else\\n                    x=0;\\n                if(cur->children[x]==NULL)\\n                {\\n                    cur->children[x]=getNode(x);\\n                }\\n                cur=cur->children[x];\\n                cur->minima=min(cur->minima,nums[i]);\\n            }\\n        }\\n        int m=q.size();\\n        vector<int> ans(m);\\n        for(int i=0;i<q.size();i++)\\n        {\\n            cur=root;\\n            res=0;\\n            for(int j=31;j>=0;j--)\\n            {\\n                if(q[i][0]&(1<<j))\\n                    x=1;\\n                else\\n                    x=0;\\n                if(cur->children[x^1]!=NULL && (cur->children[x^1]->minima )<=q[i][1])\\n                {\\n                    res=(res|(1<<j));\\n                    cur=cur->children[x^1];\\n                }\\n                else if(cur->children[x]!=NULL && cur->children[x]->minima<=q[i][1])\\n                    cur=cur->children[x];\\n                else\\n                {\\n                    res=-1;\\n                    break;\\n                }\\n            }\\n            ans[i]=res;\\n        }\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        return trie.calculate(nums,queries);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209999,
                "title": "c-trie-bit-manipulation-using-sort-function-line-by-line-comments",
                "content": "704 ms (we can reduce this by replacing sort function with some efficient methods but this one is easy)\\n218.3 MB\\n\\n```\\nclass TrieNode {\\npublic:\\n    TrieNode* next[2];  // creating 2 TrieNode array for storing 2 bits 1 and 0 \\n    TrieNode()\\n    {\\n        next[0]=NULL;\\n        next[1]=NULL;\\n    }\\n};\\n\\n bool comp(vector<int>&a,vector<int>&b){    // for comapring 2 vectors\\n    return a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    TrieNode* root = new TrieNode();   // creat a root node to connect everything \\n    \\n   \\n    void insert(int num , TrieNode* root){\\n         \\n        TrieNode* curr = root;   // start from the root node\\n        \\n        for(int i=31;i>=0;i--)      // travel through all the bits (32 is the max limit)\\n        {\\n            int bit = (num>>i) & 1; //  right shifts the bits of the first operand, the second operand decides the number of places to shift. so if there are 32 bits it will shift 31 bits to the right and only the 32th bit is left \\n   // & gives 1 if both are one  \\n //so the right endmost bit in the num will do & ( bitwise operation with the 1 so that we could get only the last bit)      \\n            if(!curr->next[bit])    // no next(children to root trie ) is present then \\n                curr->next[bit]=new TrieNode(); // add a new TrieNode\\n            \\n            curr=curr->next[bit];  // add the new bit in the newly formed TrieNode array\\n        }\\n    }\\n    \\n    int query(int num,TrieNode *root) {\\n    \\n        TrieNode* curr = root;  \\n        int ans=0;\\n      \\n        for(int i=31;i>=0;i--)  \\n        {\\n            int bit=(num>>i)&1;\\n // basically we need as 1 as possible from the XOR operation between the num[i] and all the TrieNode route possible\\n// 0 XOR 1 = 1\\n// 1 XOR 0 = 1\\n// for a bit take the opposite bit to get 1           \\n            if(curr->next[!bit]) // we need a opposite bit that we get above\\n            {\\n                ans+= (1<<i); //Takes two numbers, left shifts the bits of the first operand, the second operand decides the number of places to shift.\\n// thats how get the number back\\n                \\n\\n            \\n                curr=curr->next[!bit];  // move towards the next opposite of opposite  bit \\n            }\\n            else curr=curr->next[bit]; // just move to next if no opposite bit found\\n            \\n        }\\n        return ans;\\n    }   \\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n       \\n        int  n =nums.size();\\n        int  m=queries.size();        \\n        vector<int>ans(m,-1);\\n        \\n        for(int i=0;i<queries.size();i++){   // this is just like a map so that we can get our ans in our initial form\\n            queries[i].push_back(i);\\n        }\\n        \\n        sort(nums.begin(),nums.end());    \\n        sort(queries.begin(),queries.end(),comp);\\n        // so we are first sorting as after sorting we can first add the no less than the queries[1] in the Trie now all the added no are already smaller and we can get our result easily\\n        // for second iteration we just add another numbers which are smaller than queries[2]\\n        int i=0;\\n        for(int k=0;k<m;k++){\\n            while(i<n && nums[i]<=queries[k][1]){\\n                insert(nums[i],root);\\n                i++;\\n            }\\n            if(i!=0){\\n                ans[queries[k][2]]=query(queries[k][0],root);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> ans;\\n    TrieNode* root = new TrieNode();   // creat a root node to connect everything \\n    \\n   \\n    void insert(int num , TrieNode* root){\\n         \\n        TrieNode* curr = root;   // start from the root node\\n        \\n        for(int i=31;i>=0;i--)      // travel through all the bits (32 is the max limit)\\n        {\\n            int bit = (num>>i) & 1; //  right shifts the bits of the first operand, the second operand decides the number of places to shift. so if there are 32 bits it will shift 31 bits to the right and only the 32th bit is left \\n   // & gives 1 if both are one  \\n //so the right endmost bit in the num will do & ( bitwise operation with the 1 so that we could get only the last bit)      \\n            if(!curr->next[bit])    // no next(children to root trie ) is present then \\n                curr->next[bit]=new TrieNode(); // add a new TrieNode\\n            \\n            curr=curr->next[bit];  // add the new bit in the newly formed TrieNode array\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 997992,
                "title": "javascript-very-optimized-288ms-61-4mb-non-trie-solution-w-detailed-explanation-100-100",
                "content": "***Basic Logic:***\\n\\nA bitwise XOR operation (ie, **a ^ b**) compares the binary bits of each number and yields the number found by turning each bit to **1** *if and only if* one, *but not both* of the corresponding bits in numbers **a** and **b** are **1**. If both bits are **0**, or both **1**, then that bit becomes a **0**.\\n```\\n\\t\\tBitwise XOR ( ^ ) example:\\n\\n\\t\\t\\tbase10:    229   ^   51   =   214\\n\\t\\t\\tbase2:  11100101 ^ 110011 = 11010110\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          if the compared bits\\n\\t\\t\\t\\t\\t^   0 0 1 1 0 0 1 1          are opposite of each other\\n\\t\\t\\t\\t\\t----v-v-X-v-X-v-v-X----\\n\\t\\t\\t\\t\\t    1 1 0 1 0 1 1 0          return a 1, otherwise a 0\\n```\\nThis means that in order to find the max result of **x ^ N[j])**, we need to check each bit from the left to right and eliminate numbers (if possible) which are less optimal until we find the best option in **N**. If, for example, the 30th bit of **x** was a **1**, then the best choices in **N** would have a 30th bit that was a **0**.\\n\\nTherefore, for any given bit, as long as there are options in **N** with the *opposite* value of the corresponding bit in **x**, then we could eliminate any option with a *same* bit value. If no option exists with the opposite bit value, we\\'ll be forced to accept the same bit value, however, before moving to the next bit to the right. By the time we finish with the 0th bit, we will have found our ideal solution in **N**.\\n\\n` `\\n***Caveat:***\\n\\nThe hints for this problem suggest using a **trie** data structure, and I\\'ll admit that my first solution went that direction, but I found it to be very inefficient. The nature of the test cases is such that you can\\'t even easily use a simple object, or even a Map, as the basis for the trie due to memory concerns.\\n\\nInstead, since we\\'re already doing a bit-by-bit comparison between a target and an array of numbers, we can use a more simple and efficient **binary search** to yield the answer to each query without relying on a bulky trie.\\n\\n` `\\n***Implementation:***\\n\\nIn order to accomplish a binary search of **N**, of course, it first must be sorted. We\\'ll then need to define the **function** that will use a binary search in order to find a **target** value within a subset of **N**, between **l** and **r**.\\n\\nThis is a fairly standard implementation, in which we repeatedly narrow the subset down by finding a midpoint **m**. In this case, we\\'re using a bitwise right shift (ie, **num >> 1**), which moves every bit to the right by **1** step. Just like dropping the last digit of a base 10 number would be like dividing the number by 10 and throwing away the remainder, the bitwise shift for binary numbers is the equivalent of dividing **num** by **2** and throwing away the remainder, or **Math.floor(num / 2)**. Here, we\\'re using it to find the midpoint between **l** and **r** with **l + r >> 1**, which is simply a more efficient way of doing the exact same thing as **Math.floor((l + r) / 2)**.\\n```\\n\\t\\tBitwise shift left or right ( << or >> ) example:\\n\\n\\t\\t\\tbase10:    229   << 3 =    1832\\n\\t\\t\\tbase2:  11100101 << 3 = 11100101000\\n\\n\\t\\t\\t\\t\\t  1 1 1 0 0 1 0 1          229\\n\\t\\t\\t\\t1 1 1 0 0 1 0 1 < < <          shifted left three bits\\n\\t\\t\\t ---v-v-v-v-v-v-v-v-X-X-X---\\n\\t\\t\\t\\t1 1 1 0 0 1 0 1 0 0 0          becomes 1832\\n\\n\\n\\t\\t\\tbase10:    229   >> 3 =  28\\n\\t\\t\\tbase2:  11100101 >> 3 = 11100\\n\\n\\t\\t\\t\\t      1 1 1 0 0 1 0 1          229\\n\\t\\t\\t\\t      > > > 1 1 1 0 0|X X X    shifted right three bits\\n\\t\\t\\t       ---------v-v-v-v-v---------\\n\\t\\t\\t\\t\\t\\t    1 1 1 0 0          becomes 28\\n```\\nAfter we find **m**, we check it against the **target**, and narrow the range by moving the respective endpoint, **l** or **r**, in. This is repeated until we find our target\\'s index. It\\'s important to note that this implementation of a binary search will return the index of the number that either matches the **target** exactly, or is the next number larger if no number is an exact match for the **target**.\\n\\nThe next step is to iterate through the list of queries, **Q**. In order to maintain efficiency, we can replace each query in **Q** with its result before ultimately returning **Q**. To do this, we\\'ll start by using a destructuring assignment to simultenously extract the comparison value **x** and the upper bound **lim**, while replacing them with the default result of **-1**. This will allow us to check to make sure that the smallest number, **N[0]**, is already higher than **lim**, and if so we can just **continue** to the next query.\\n\\nIf this is not the case, then the next thing we need to do is to **find** the right endpoint **r** of our initial subset range. Since we cannot include numbers that are larger than **lim**, but we do need to include numbers that exactly match **lim** (and based on the explanation above), we\\'ll need to slightly stagger the **find** parameters by searching instead for **lim+1** and then subtracting **1** from the resulting index.\\n\\nNow that we\\'ve defined the initial range, we can get to the heart of the query. First, we can simplify the check by noting how many bits are used in the largest value of our range, **N[r]** and iterate our shift amount **j** from one less than that down to **0**, rather than always iterating down from the max possible shift amount of **29**.\\n\\nFor each bit, we\\'ll first check to see if a binary search is even necessary. If the smallest and largest values left in our subset range, **N[l]** and **N[r]**, have the same value for the current bit position, the optimal choice becomes moot and we can just move on to the next iteration. There are several ways in which we can accomplish this, but in this case we\\'ll utilitize a bitwise AND (ie, **a & b**) comparison between each option and a shifted bitmask of **1 << j**.\\n\\nA bitwise AND comparison between corresponding bits will return a **1** *if and only if* both bits are a **1** and a **0** otherwise. Our bitmask of **1 << j** will create a number that is a **1** followed by **j** number of **0**s. For example, if we were comparing the 6th bit, our bitmask would be **1 << 5**, or **100000** in binary. In other words, a bitmask of **1 << 5** will create a number in which the *only* **1** is in the 6th bit, allowing us to isolate the 6th bit of *another* number by means of the bitwise AND comparison, since only that 6th bit can possibly have both values be a **1**.\\n```\\n\\t\\tBitwise AND ( & ) example:\\n\\n\\t\\t\\tbase10:    229   &   51   =   33\\n\\t\\t\\tbase2:  11100101 & 110011 = 100001\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          if the compared bits\\n\\t\\t\\t\\t\\t&   0 0 1 1 0 0 1 1          are both 1s\\n\\t\\t\\t\\t\\t----X-X-v-X-X-X-X-v----\\n\\t\\t\\t\\t\\t    0 0 1 0 0 0 0 1          return a 1, otherwise a 0\\n```\\n```\\n\\t\\tBitwise AND ( & ) combined with a Bitmask ( 1 << n ) examples:\\n\\t\\t\\n\\t\\t\\tbase10:    229   & 1 << 5 =   32\\n\\t\\t\\tbase2:  11100101 & 100000 = 100000\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          performing a bitwise AND\\n\\t\\t\\t\\t\\t&   0 0 1 0 0 0 0 0          using a bitmask for the 6th bit (1 << 5)\\n\\t\\t\\t\\t\\t----X-X-v-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    0 0 1 0 0 0 0 0          returns the isolated 6th bit only\\n\\n\\n\\t\\t\\tbase10:    229   & 1 << 4 = 0\\n\\t\\t\\tbase2:  11100101 &  10000 = 0\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          performing a bitwise AND\\n\\t\\t\\t\\t\\t&   0 0 0 1 0 0 0 0          using a bitmask for the 5th bit (1 << 4)\\n\\t\\t\\t\\t\\t----X-X-X-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    0 0 0 0 0 0 0 0          returns the isolated 5th bit only\\n```\\nSo our check of **N[l] & 1 << j** and **N[r] & 1 << j** will be equal if both **N[l]** and **N[r]** have the same value in the (**j+1**)th bit, meaning that we can skip to the next step.\\n\\nIf they\\'re not equal, however, then we can simply **find** the index at which our remaining options flip from a **0** to a **1** in that bit. Thanks to the previous check, we know at this point that our **N[r]** value must have a **1** in the current bit, so we can simply achieve this with **N[r] >> j << j**. As explained earlier, shifting to the right will throw out that many of the rightmost bits, so shifting right by **j** and then shifting left by **j** will have the effect of zeroing out the last **j** bits of **N[r]**, which neatly provides us the lowest possible optimal **target** value, which we can pass into the **find** function in order to find the midpoint index of the remaining **N** values.\\n\\nBy using another bitmask, we can find out if the current bit of **x** is a **1** or **0** with **x & 1 << j**. If it\\'s a **1**, then we want to choose the left half of our range of remaing **N** values, corresponding to the ones with a **0** in that bit. We do that by dropping our right-end index **r** to **mid**, but adjusted by **-1** remembering that our **find** function is set up to include matching results in the right half. Otherwise, we choose the right half of the remaining range by moving **l** to **mid**.\\n\\nOnce the **for** loop has iterated all the way through the **0**th bit, our range should have narrowed to one result, meaning that **l** should equal **r**. At that point, we can just update **Q** with the result of the query, **x ^ N[l]**, and when all queries are done, return the fully-updated **Q**.\\n\\n` `\\n***Code:***\\n```\\nconst maximizeXor = (N, Q) => {                          // TL;DR:\\n    N.sort((a,b) => a - b)                               // Sort N to enable binary search\\n    for (let i = 0, x, lim; i < Q.length; i++) {         // Iterate through the queries\\n        [[x, lim], Q[i]] = [Q[i], -1]                    // Extract query params and replace with default result of -1,\\n        if (lim < N[0]) continue                         //    then skip to the next query if no usable values below lim\\n        let l = 0, r = find(N, 0, N.length, lim+1) - 1   // Set the initial index range\\n        for (let j = ~~Math.log2(N[r]); ~j; j--)         // Check bits backwards from largest possible\\n            if ((N[l] & 1 << j) !== (N[r] & 1 << j)) {   // Skip if all options have the same value in the current bit\\n                let mid = find(N, l, r, N[r] >> j << j)  // Find the midpoint index where the bit flips from 0 to 1\\n                if (x & 1 << j) r = mid - 1              // If the current bit of x is a 1, choose the left side of mid\\n                else l = mid                             //    with 0s, otherwise take the right side of mid with 1s\\n            }\\n\\t\\tQ[i] = x ^ N[l]                                  // Update Q with the result, overwriting the default -1\\n    }\\n    return Q                                             // Return the fully-updated Q\\n}\\n\\nconst find = (N, l, r, target) => {                      // Binary search function, finding target in N between l and r\\n    while (l <= r) {\\n        let m = l + r >> 1                               // Find the midpoint; equivalent of Math.floor((l + r) / 2)\\n        if (N[m] < target) l = m + 1                     // If the midpoint is not high enough, move l up\\n        else r = m - 1                                   // Otherwise, move r back\\n    }\\n    return l                                             // Return the index that matches (or is the closest >) target\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\t\\tBitwise XOR ( ^ ) example:\\n\\n\\t\\t\\tbase10:    229   ^   51   =   214\\n\\t\\t\\tbase2:  11100101 ^ 110011 = 11010110\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          if the compared bits\\n\\t\\t\\t\\t\\t^   0 0 1 1 0 0 1 1          are opposite of each other\\n\\t\\t\\t\\t\\t----v-v-X-v-X-v-v-X----\\n\\t\\t\\t\\t\\t    1 1 0 1 0 1 1 0          return a 1, otherwise a 0\\n```\n```\\n\\t\\tBitwise shift left or right ( << or >> ) example:\\n\\n\\t\\t\\tbase10:    229   << 3 =    1832\\n\\t\\t\\tbase2:  11100101 << 3 = 11100101000\\n\\n\\t\\t\\t\\t\\t  1 1 1 0 0 1 0 1          229\\n\\t\\t\\t\\t1 1 1 0 0 1 0 1 < < <          shifted left three bits\\n\\t\\t\\t ---v-v-v-v-v-v-v-v-X-X-X---\\n\\t\\t\\t\\t1 1 1 0 0 1 0 1 0 0 0          becomes 1832\\n\\n\\n\\t\\t\\tbase10:    229   >> 3 =  28\\n\\t\\t\\tbase2:  11100101 >> 3 = 11100\\n\\n\\t\\t\\t\\t      1 1 1 0 0 1 0 1          229\\n\\t\\t\\t\\t      > > > 1 1 1 0 0|X X X    shifted right three bits\\n\\t\\t\\t       ---------v-v-v-v-v---------\\n\\t\\t\\t\\t\\t\\t    1 1 1 0 0          becomes 28\\n```\n```\\n\\t\\tBitwise AND ( & ) example:\\n\\n\\t\\t\\tbase10:    229   &   51   =   33\\n\\t\\t\\tbase2:  11100101 & 110011 = 100001\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          if the compared bits\\n\\t\\t\\t\\t\\t&   0 0 1 1 0 0 1 1          are both 1s\\n\\t\\t\\t\\t\\t----X-X-v-X-X-X-X-v----\\n\\t\\t\\t\\t\\t    0 0 1 0 0 0 0 1          return a 1, otherwise a 0\\n```\n```\\n\\t\\tBitwise AND ( & ) combined with a Bitmask ( 1 << n ) examples:\\n\\t\\t\\n\\t\\t\\tbase10:    229   & 1 << 5 =   32\\n\\t\\t\\tbase2:  11100101 & 100000 = 100000\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          performing a bitwise AND\\n\\t\\t\\t\\t\\t&   0 0 1 0 0 0 0 0          using a bitmask for the 6th bit (1 << 5)\\n\\t\\t\\t\\t\\t----X-X-v-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    0 0 1 0 0 0 0 0          returns the isolated 6th bit only\\n\\n\\n\\t\\t\\tbase10:    229   & 1 << 4 = 0\\n\\t\\t\\tbase2:  11100101 &  10000 = 0\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          performing a bitwise AND\\n\\t\\t\\t\\t\\t&   0 0 0 1 0 0 0 0          using a bitmask for the 5th bit (1 << 4)\\n\\t\\t\\t\\t\\t----X-X-X-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    0 0 0 0 0 0 0 0          returns the isolated 5th bit only\\n```\n```\\nconst maximizeXor = (N, Q) => {                          // TL;DR:\\n    N.sort((a,b) => a - b)                               // Sort N to enable binary search\\n    for (let i = 0, x, lim; i < Q.length; i++) {         // Iterate through the queries\\n        [[x, lim], Q[i]] = [Q[i], -1]                    // Extract query params and replace with default result of -1,\\n        if (lim < N[0]) continue                         //    then skip to the next query if no usable values below lim\\n        let l = 0, r = find(N, 0, N.length, lim+1) - 1   // Set the initial index range\\n        for (let j = ~~Math.log2(N[r]); ~j; j--)         // Check bits backwards from largest possible\\n            if ((N[l] & 1 << j) !== (N[r] & 1 << j)) {   // Skip if all options have the same value in the current bit\\n                let mid = find(N, l, r, N[r] >> j << j)  // Find the midpoint index where the bit flips from 0 to 1\\n                if (x & 1 << j) r = mid - 1              // If the current bit of x is a 1, choose the left side of mid\\n                else l = mid                             //    with 0s, otherwise take the right side of mid with 1s\\n            }\\n\\t\\tQ[i] = x ^ N[l]                                  // Update Q with the result, overwriting the default -1\\n    }\\n    return Q                                             // Return the fully-updated Q\\n}\\n\\nconst find = (N, l, r, target) => {                      // Binary search function, finding target in N between l and r\\n    while (l <= r) {\\n        let m = l + r >> 1                               // Find the midpoint; equivalent of Math.floor((l + r) / 2)\\n        if (N[m] < target) l = m + 1                     // If the midpoint is not high enough, move l up\\n        else r = m - 1                                   // Otherwise, move r back\\n    }\\n    return l                                             // Return the index that matches (or is the closest >) target\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3719151,
                "title": "python-99-52-faster-trie-easy",
                "content": "```\\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n        self.m=0\\n    \\n    def insert(self,word):\\n        node=self.root\\n        for ch in word:\\n            if ch not in node:\\n                node[ch]={}\\n            node=node[ch]\\n\\n    def compare(self,word,x):\\n        node=self.root\\n        t=\"\"\\n        a,b=\\'0\\',\\'1\\'\\n        for ch in word:\\n            if ch==a and b in node:\\n                t+=b\\n                node=node[b]\\n            elif ch==b and a in node:\\n                t+=a\\n                node=node[a]\\n            else:\\n                t+=ch\\n                node=node[ch]\\n        ans=int(t,2)^x\\n        return ans\\n\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        trie=Trie()\\n        n,l=len(queries),len(nums)\\n        for i in range(n):\\n            queries[i].append(i)\\n        queries.sort(key=lambda x:x[1])\\n        nums.sort()\\n        res=[0]*n\\n        j=0\\n        m=nums[0]\\n        for i in range(n):\\n            x,y,z=queries[i][0],queries[i][1],queries[i][2]\\n            if m>y:\\n                res[z]=-1\\n                continue\\n            while j<l and nums[j]<=y:\\n                word=\"{:032b}\".format(nums[j])\\n                trie.insert(word)\\n                j+=1\\n            word=\"{:032b}\".format(x)\\n            ans=trie.compare(word,x)\\n            res[z]=ans\\n            t=y\\n        return res\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n        self.m=0\\n    \\n    def insert(self,word):\\n        node=self.root\\n        for ch in word:\\n            if ch not in node:\\n                node[ch]={}\\n            node=node[ch]\\n\\n    def compare(self,word,x):\\n        node=self.root\\n        t=\"\"\\n        a,b=\\'0\\',\\'1\\'\\n        for ch in word:\\n            if ch==a and b in node:\\n                t+=b\\n                node=node[b]\\n            elif ch==b and a in node:\\n                t+=a\\n                node=node[a]\\n            else:\\n                t+=ch\\n                node=node[ch]\\n        ans=int(t,2)^x\\n        return ans\\n\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        trie=Trie()\\n        n,l=len(queries),len(nums)\\n        for i in range(n):\\n            queries[i].append(i)\\n        queries.sort(key=lambda x:x[1])\\n        nums.sort()\\n        res=[0]*n\\n        j=0\\n        m=nums[0]\\n        for i in range(n):\\n            x,y,z=queries[i][0],queries[i][1],queries[i][2]\\n            if m>y:\\n                res[z]=-1\\n                continue\\n            while j<l and nums[j]<=y:\\n                word=\"{:032b}\".format(nums[j])\\n                trie.insert(word)\\n                j+=1\\n            word=\"{:032b}\".format(x)\\n            ans=trie.compare(word,x)\\n            res[z]=ans\\n            t=y\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171276,
                "title": "c-efficient-trie-bit-magic-solution-offline-queries",
                "content": "*67 / 67 test cases passed.*\\n**Status:** Accepted\\n**Runtime:** 898 ms\\n**Memory Usage:** 216.9 MB\\n```\\n#define all(container) container.begin(), container.end()\\nstruct Node{\\n    Node* links[2];\\n    \\n    bool containsKey(int bit) {\\n        return links[bit]!=NULL;\\n    }\\n    Node* getNode(int bit){\\n        return links[bit];\\n    }\\n    void putNode(int bit,Node* node){\\n        links[bit]=node;\\n    }\\n};\\n\\nclass Trie{\\n    private: Node* root;\\n    public:\\n    Trie(){\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        root=new Node();\\n    }\\n    \\n    void insert(int& num){\\n        Node* node=root;\\n        \\n        for(int i=31;i>=0;i--){\\n            int bit = !!((num>>i)&1);\\n            if(!node->containsKey(bit))\\n                node->putNode(bit, new Node());\\n            node=node->getNode(bit);\\n        }\\n    }\\n    \\n    int getMax(int& num){\\n        Node* node=root;\\n        int maxNum=0;\\n        \\n        for(int i=31;i>=0;i--){\\n            int bit = !!((num>>i)&1);\\n            if(node->containsKey(!bit)){\\n                maxNum |= (1<<i);\\n                node=node->getNode(!bit);\\n            }\\n            else node=node->getNode(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        Trie* trie = new Trie();\\n        sort(all(arr));\\n        \\n        int n=arr.size(), q=queries.size();\\n        vector<pair<int, pair<int,int>>> oQ;\\n\\n        int index=0;\\n        for(auto& it: queries)\\n            oQ.push_back({it[1], {it[0], index++}});\\n\\n        sort(all(oQ));\\n\\n        index=0;\\n\\n        vector<int>ans(q,0);\\n\\n\\n        for(auto& it: oQ){\\n            int ai=it.first;\\n            while(index< n and arr[index]<=ai) \\n                trie->insert(arr[index++]);\\n\\n            if(!index) ans[it.second.second]=-1;\\n            else ans[it.second.second]=trie->getMax(it.second.first);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n#define all(container) container.begin(), container.end()\\nstruct Node{\\n    Node* links[2];\\n    \\n    bool containsKey(int bit) {\\n        return links[bit]!=NULL;\\n    }\\n    Node* getNode(int bit){\\n        return links[bit];\\n    }\\n    void putNode(int bit,Node* node){\\n        links[bit]=node;\\n    }\\n};\\n\\nclass Trie{\\n    private: Node* root;\\n    public:\\n    Trie(){\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        root=new Node();\\n    }\\n    \\n    void insert(int& num){\\n        Node* node=root;\\n        \\n        for(int i=31;i>=0;i--){\\n            int bit = !!((num>>i)&1);\\n            if(!node->containsKey(bit))\\n                node->putNode(bit, new Node());\\n            node=node->getNode(bit);\\n        }\\n    }\\n    \\n    int getMax(int& num){\\n        Node* node=root;\\n        int maxNum=0;\\n        \\n        for(int i=31;i>=0;i--){\\n            int bit = !!((num>>i)&1);\\n            if(node->containsKey(!bit)){\\n                maxNum |= (1<<i);\\n                node=node->getNode(!bit);\\n            }\\n            else node=node->getNode(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        Trie* trie = new Trie();\\n        sort(all(arr));\\n        \\n        int n=arr.size(), q=queries.size();\\n        vector<pair<int, pair<int,int>>> oQ;\\n\\n        int index=0;\\n        for(auto& it: queries)\\n            oQ.push_back({it[1], {it[0], index++}});\\n\\n        sort(all(oQ));\\n\\n        index=0;\\n\\n        vector<int>ans(q,0);\\n\\n\\n        for(auto& it: oQ){\\n            int ai=it.first;\\n            while(index< n and arr[index]<=ai) \\n                trie->insert(arr[index++]);\\n\\n            if(!index) ans[it.second.second]=-1;\\n            else ans[it.second.second]=trie->getMax(it.second.first);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791930,
                "title": "using-trie-c-simple-solution",
                "content": "```\\nclass Node {\\npublic:\\n\\tNode *links[2];\\n\\tbool containsKey(int ind) {\\n\\t\\treturn (links[ind] != NULL);\\n\\t}\\n\\tNode *get(int ind) {\\n\\t\\treturn links[ind];\\n\\t}\\n\\tvoid put(int ind,Node *root) {\\n\\t\\tlinks[ind] = root;\\n\\t}\\n};\\nclass Trie {\\nprivate:\\n\\tNode *root;\\npublic:\\n\\tTrie() {\\n\\t\\troot = new Node();\\n\\t}\\n\\tvoid insert(int num) {\\n\\t\\tNode *newNode = root;\\n\\t\\tfor(int i = 31; i >= 0; i--) {\\n\\t\\t\\tint bit = (num >> i) & 1;\\n\\t\\t\\tif(!newNode->containsKey(bit)) {\\n\\t\\t\\t\\tnewNode->put(bit,new Node());\\n\\t\\t\\t}\\n\\t\\t\\tnewNode = newNode->get(bit);\\n\\t\\t}\\n\\t}\\npublic:\\n\\tint findMax(int num) {\\n\\t\\tNode *newNode = root;\\n\\t\\tint maxNum = 0;\\n\\t\\tfor(int i = 31; i >= 0; i--) {\\n\\t\\t\\tint bit = (num >> i) & 1;\\n\\t\\t\\tif(newNode->containsKey(!bit)) {\\n\\t\\t\\t\\tmaxNum = maxNum | (1 << i);\\n\\t\\t\\t\\tnewNode = newNode->get(!bit);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tnewNode = newNode->get(bit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn maxNum;\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n    \\tvector<int>ans(queries.size(),0);\\n    \\tvector<pair<int,pair<int,int>>>offlineQueries;\\n    \\tsort(nums.begin(),nums.end());\\n    \\tint ind = 0;\\n    \\tfor(auto &it:queries) {\\n    \\t\\tofflineQueries.push_back({it[1],{it[0],ind++}});\\n    \\t}\\n    \\tsort(offlineQueries.begin(),offlineQueries.end());\\n    \\tint i = 0;\\n    \\tint n = nums.size();\\n    \\tTrie t;\\n    \\tfor(auto &it:offlineQueries) {\\n    \\t\\twhile(i < n && nums[i] <= it.first) {\\n    \\t\\t\\tt.insert(nums[i]);\\n    \\t\\t\\ti++;\\n    \\t\\t}\\n    \\t\\tif(i != 0) {\\n    \\t\\t\\tans[it.second.second] = t.findMax(it.second.first);\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tans[it.second.second] = -1;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Node {\\npublic:\\n\\tNode *links[2];\\n\\tbool containsKey(int ind) {\\n\\t\\treturn (links[ind] != NULL);\\n\\t}\\n\\tNode *get(int ind) {\\n\\t\\treturn links[ind];\\n\\t}\\n\\tvoid put(int ind,Node *root) {\\n\\t\\tlinks[ind] = root;\\n\\t}\\n};\\nclass Trie {\\nprivate:\\n\\tNode *root;\\npublic:\\n\\tTrie() {\\n\\t\\troot = new Node();\\n\\t}\\n\\tvoid insert(int num) {\\n\\t\\tNode *newNode = root;\\n\\t\\tfor(int i = 31; i >= 0; i--) {\\n\\t\\t\\tint bit = (num >> i) & 1;\\n\\t\\t\\tif(!newNode->containsKey(bit)) {\\n\\t\\t\\t\\tnewNode->put(bit,new Node());\\n\\t\\t\\t}\\n\\t\\t\\tnewNode = newNode->get(bit);\\n\\t\\t}\\n\\t}\\npublic:\\n\\tint findMax(int num) {\\n\\t\\tNode *newNode = root;\\n\\t\\tint maxNum = 0;\\n\\t\\tfor(int i = 31; i >= 0; i--) {\\n\\t\\t\\tint bit = (num >> i) & 1;\\n\\t\\t\\tif(newNode->containsKey(!bit)) {\\n\\t\\t\\t\\tmaxNum = maxNum | (1 << i);\\n\\t\\t\\t\\tnewNode = newNode->get(!bit);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tnewNode = newNode->get(bit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn maxNum;\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n    \\tvector<int>ans(queries.size(),0);\\n    \\tvector<pair<int,pair<int,int>>>offlineQueries;\\n    \\tsort(nums.begin(),nums.end());\\n    \\tint ind = 0;\\n    \\tfor(auto &it:queries) {\\n    \\t\\tofflineQueries.push_back({it[1],{it[0],ind++}});\\n    \\t}\\n    \\tsort(offlineQueries.begin(),offlineQueries.end());\\n    \\tint i = 0;\\n    \\tint n = nums.size();\\n    \\tTrie t;\\n    \\tfor(auto &it:offlineQueries) {\\n    \\t\\twhile(i < n && nums[i] <= it.first) {\\n    \\t\\t\\tt.insert(nums[i]);\\n    \\t\\t\\ti++;\\n    \\t\\t}\\n    \\t\\tif(i != 0) {\\n    \\t\\t\\tans[it.second.second] = t.findMax(it.second.first);\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tans[it.second.second] = -1;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357727,
                "title": "c-trie-efficient-solution-sorting",
                "content": "```\\nstruct Node{\\n    Node* left;\\n    Node* right;\\n    \\n    Node(){\\n        left = NULL;\\n        right = NULL;\\n    }\\n};\\n\\nclass Trie{\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    \\n    void insert(int data){\\n        Node* temp = root;\\n        for(int i = 31; i >= 0; i--){\\n            int bit = (data >> i) & 1;\\n            if(bit == 0){\\n                if(temp->left == NULL){\\n                    temp->left = new Node();\\n                }\\n                temp = temp->left;\\n            }\\n            else{\\n                if(temp->right == NULL){\\n                    temp->right = new Node();\\n                }\\n                temp = temp->right;\\n            }\\n        }\\n    }\\n    \\n    int max_xor_helper(int data){\\n        Node* temp = root;\\n        int max_xor_val = 0;\\n        for(int i = 31; i >= 0; i--){\\n            int bit = (data >> i) & 1;\\n            if(bit == 0){\\n                if(temp->right != NULL){\\n                    max_xor_val += (1 << i);\\n                    temp = temp->right;\\n                }\\n                else temp = temp->left;\\n            }\\n            else{\\n                if(temp->left != NULL){\\n                    max_xor_val += (1 << i);\\n                    temp = temp->left;\\n                }\\n                else temp = temp->right;\\n            }\\n        }\\n        return max_xor_val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<pair<pair<int, int>, int> > newQueries;\\n        for(int i = 0; i < queries.size(); i++){\\n            newQueries.push_back({{queries[i][0], queries[i][1]}, i});\\n        }\\n        \\n        sort(newQueries.begin(), newQueries.end(), [](pair<pair<int, int>, int> &a, pair<pair<int, int>, int> &b){\\n            return a.first.second < b.first.second;\\n        });\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> res(queries.size(), -1);\\n        int index = 0;\\n        Trie* myTrie = new Trie();\\n        \\n        for(int i = 0; i < newQueries.size(); i++){\\n            int data = newQueries[i].first.first;\\n            int limit = newQueries[i].first.second; \\n            int idx = newQueries[i].second;\\n            \\n            while(index < nums.size() && nums[index] <= limit){\\n                myTrie->insert(nums[index++]);\\n            }\\n            \\n            if(index > 0){\\n                res[idx] = myTrie->max_xor_helper(data);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* left;\\n    Node* right;\\n    \\n    Node(){\\n        left = NULL;\\n        right = NULL;\\n    }\\n};\\n\\nclass Trie{\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    \\n    void insert(int data){\\n        Node* temp = root;\\n        for(int i = 31; i >= 0; i--){\\n            int bit = (data >> i) & 1;\\n            if(bit == 0){\\n                if(temp->left == NULL){\\n                    temp->left = new Node();\\n                }\\n                temp = temp->left;\\n            }\\n            else{\\n                if(temp->right == NULL){\\n                    temp->right = new Node();\\n                }\\n                temp = temp->right;\\n            }\\n        }\\n    }\\n    \\n    int max_xor_helper(int data){\\n        Node* temp = root;\\n        int max_xor_val = 0;\\n        for(int i = 31; i >= 0; i--){\\n            int bit = (data >> i) & 1;\\n            if(bit == 0){\\n                if(temp->right != NULL){\\n                    max_xor_val += (1 << i);\\n                    temp = temp->right;\\n                }\\n                else temp = temp->left;\\n            }\\n            else{\\n                if(temp->left != NULL){\\n                    max_xor_val += (1 << i);\\n                    temp = temp->left;\\n                }\\n                else temp = temp->right;\\n            }\\n        }\\n        return max_xor_val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<pair<pair<int, int>, int> > newQueries;\\n        for(int i = 0; i < queries.size(); i++){\\n            newQueries.push_back({{queries[i][0], queries[i][1]}, i});\\n        }\\n        \\n        sort(newQueries.begin(), newQueries.end(), [](pair<pair<int, int>, int> &a, pair<pair<int, int>, int> &b){\\n            return a.first.second < b.first.second;\\n        });\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> res(queries.size(), -1);\\n        int index = 0;\\n        Trie* myTrie = new Trie();\\n        \\n        for(int i = 0; i < newQueries.size(); i++){\\n            int data = newQueries[i].first.first;\\n            int limit = newQueries[i].first.second; \\n            int idx = newQueries[i].second;\\n            \\n            while(index < nums.size() && nums[index] <= limit){\\n                myTrie->insert(nums[index++]);\\n            }\\n            \\n            if(index > 0){\\n                res[idx] = myTrie->max_xor_helper(data);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121225,
                "title": "trie-and-max-xor-value",
                "content": "```\\nclass Trie {\\npublic:\\n    void insert(int num) {\\n        insert(num, 31);\\n    }\\n    void insert(int num, int pos) {\\n        if (pos < 0) {\\n            return;\\n        }\\n        if (num & (1 << pos)) {\\n            if (one == nullptr) {\\n                one = new Trie();\\n            }\\n            one->insert(num, pos - 1);\\n        } else {\\n            if (zero == nullptr) {\\n                zero = new Trie();\\n            }\\n            zero->insert(num, pos - 1);\\n        }\\n    }\\n    Trie* zero = nullptr;\\n    Trie* one = nullptr;\\n};\\nint largest(const Trie& trie, int num, int pos) {\\n    if (pos < 0) {\\n        return 0;\\n    }\\n    if (trie.zero == nullptr && trie.one == nullptr) {\\n        return -1;\\n    }\\n    if (num & (1 << pos)) {\\n        if (trie.zero != nullptr) {\\n            return (1 << pos) + largest(*trie.zero, num, pos - 1);\\n        } else {\\n            return largest(*trie.one, num, pos - 1);\\n        }\\n    } else {\\n        if (trie.one != nullptr) {\\n            return (1 << pos) + largest(*trie.one, num, pos - 1);\\n        } else {\\n            return largest(*trie.zero, num, pos - 1);\\n        }\\n    }\\n}\\nint largest(const Trie& trie, int num) {\\n    return largest(trie, num, 31);\\n}\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(begin(nums), end(nums));\\n        int n = queries.size();\\n        vector<int> ans(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            queries[i].emplace_back(i);\\n        }\\n        sort(begin(queries), end(queries), [](auto& q1, auto& q2) {\\n            return q1[1] < q2[1];\\n        });\\n        int p = 0;\\n        Trie trie;\\n        for (auto& query : queries) {\\n            while (p < nums.size() && nums[p] <= query[1]) {\\n                trie.insert(nums[p]);\\n                ++p;\\n            }\\n            ans[query[2]] = largest(trie, query[0]);            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\npublic:\\n    void insert(int num) {\\n        insert(num, 31);\\n    }\\n    void insert(int num, int pos) {\\n        if (pos < 0) {\\n            return;\\n        }\\n        if (num & (1 << pos)) {\\n            if (one == nullptr) {\\n                one = new Trie();\\n            }\\n            one->insert(num, pos - 1);\\n        } else {\\n            if (zero == nullptr) {\\n                zero = new Trie();\\n            }\\n            zero->insert(num, pos - 1);\\n        }\\n    }\\n    Trie* zero = nullptr;\\n    Trie* one = nullptr;\\n};\\nint largest(const Trie& trie, int num, int pos) {\\n    if (pos < 0) {\\n        return 0;\\n    }\\n    if (trie.zero == nullptr && trie.one == nullptr) {\\n        return -1;\\n    }\\n    if (num & (1 << pos)) {\\n        if (trie.zero != nullptr) {\\n            return (1 << pos) + largest(*trie.zero, num, pos - 1);\\n        } else {\\n            return largest(*trie.one, num, pos - 1);\\n        }\\n    } else {\\n        if (trie.one != nullptr) {\\n            return (1 << pos) + largest(*trie.one, num, pos - 1);\\n        } else {\\n            return largest(*trie.zero, num, pos - 1);\\n        }\\n    }\\n}\\nint largest(const Trie& trie, int num) {\\n    return largest(trie, num, 31);\\n}\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(begin(nums), end(nums));\\n        int n = queries.size();\\n        vector<int> ans(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            queries[i].emplace_back(i);\\n        }\\n        sort(begin(queries), end(queries), [](auto& q1, auto& q2) {\\n            return q1[1] < q2[1];\\n        });\\n        int p = 0;\\n        Trie trie;\\n        for (auto& query : queries) {\\n            while (p < nums.size() && nums[p] <= query[1]) {\\n                trie.insert(nums[p]);\\n                ++p;\\n            }\\n            ans[query[2]] = largest(trie, query[0]);            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997038,
                "title": "c-go-sort-trie-simple-solution-o-n-log-n",
                "content": "The idea is to sort `nums` ans `queries` and build a trie as you go over the sorted queries and populate the trie with `nums[j] <= mi` and then calculate max possible value of `xi` and the numbers in the trie. \\n\\n<iframe src=\"https://leetcode.com/playground/LUwSjKdK/shared\" frameBorder=\"0\" width=\"700\" height=\"600\"></iframe>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Go",
                    "Trie",
                    "Sorting"
                ],
                "code": "The idea is to sort `nums` ans `queries` and build a trie as you go over the sorted queries and populate the trie with `nums[j] <= mi` and then calculate max possible value of `xi` and the numbers in the trie. \\n\\n<iframe src=\"https://leetcode.com/playground/LUwSjKdK/shared\" frameBorder=\"0\" width=\"700\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 989892,
                "title": "java-two-solutions-sort-no-sort",
                "content": "1. \\tBased on the idea of [Maximum XOR of Two Numbers in an Array ](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/), we will firstly create a trie to solve the problem.\\n2. \\tMany people have pointed out we can sort and then use two-pointer method to solve. I also posted my version.\\n3. \\tHowever, sorting takes `O(NlogN + QlogQ)` times. We can actually avoid sorting by looking up the given limit\\'s bit value. Looping from the most significant bit to the lest one, if the limit\\'s current bit value is 1, we can choose either edge (bit=0/bit=1) as the number we choose cannot be greater than the limit. On the other hand, if the limit\\'s current bit value is 0, we cannot choose the edge with bit = 1. Also, note that this is a backtracking process because we may find the limit prevents us from traversing in the lower part of trie.\\n4. \\tComparison: if we use sort, we need to know the query array ahead so it has to be offline. However, we can do it online in the second way.\\n\\nPlease leave comments if you have any questions. : )\\n\\n```\\nclass TrieNode {\\n    TrieNode[] children;\\n    public TrieNode() {\\n        this.children = new TrieNode[2];\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void addNumber(int num) {\\n        TrieNode trav = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = ((num >> i) & 1);\\n            if (trav.children[bit] == null) {\\n                trav.children[bit] = new TrieNode();\\n            }\\n            trav = trav.children[bit];\\n        }\\n    }\\n    \\n\\t// For Sort solution\\n    public int maximizeForXOR(int num) {\\n        TrieNode trav = root;\\n        int res = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (1 & (num >> i));\\n            if (trav.children[1-bit] != null) {\\n                trav = trav.children[1-bit];\\n                res |= (1 << i);\\n            } else if (trav.children[bit] != null) {\\n                trav = trav.children[bit];\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n\\t// For No-sort solution\\n    // If we are unable to maximize XOR result, it will return -1. Otherwise, it will return the max result.\\n    public int maximizeForXOR(int num, int m, int bitIdx, TrieNode trav, int res) {\\n        // there is no such a number. it has to be checked before bitIdx < 0\\n        if (trav == null) {\\n            return -1;\\n        }\\n        \\n        if (bitIdx < 0) {\\n            return res;\\n        }\\n\\n        int bit = ((num >> bitIdx) & 1);\\n        int mBit = ((m >> bitIdx) & 1);\\n        int tmp = -1;\\n        if (1-bit == 1) {\\n            // always try to maximize XOR result first\\n            if (mBit == 1)\\n                tmp = maximizeForXOR(num, m, bitIdx-1, trav.children[1], res | (1 << bitIdx));\\n            \\n            // if it cannot maximize by diving through current bit=1, then try diving through current bit=0\\n            if (tmp != -1) return tmp;\\n            \\n            if (mBit == 1)\\n                // note that if mBit is 1 but we choose bit=0, we will not have the limit anymore\\n                tmp = maximizeForXOR(num, Integer.MAX_VALUE, bitIdx-1, trav.children[0], res);\\n            else\\n                tmp = maximizeForXOR(num, m, bitIdx-1, trav.children[0], res);\\n        } else {\\n            // idea is similar as above\\n            if (mBit == 1)\\n                tmp = maximizeForXOR(num, Integer.MAX_VALUE, bitIdx-1, trav.children[0], res | (1 << bitIdx));\\n            else\\n                tmp = maximizeForXOR(num, m, bitIdx-1, trav.children[0], res | (1 << bitIdx));\\n            \\n            if (tmp != -1) return tmp;\\n            if (mBit == 1)\\n                tmp = maximizeForXOR(num, m, bitIdx-1, trav.children[1], res);\\n        }\\n        return tmp;\\n    }\\n}\\n```\\n\\n**Using Sort**\\nTime Complexity: `O(NlogN + QlogQ)`; `N = size of nums` and `Q = size of queries`\\n```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Trie trie = new Trie();\\n        int[] res = new int[queries.length];\\n        \\n        int[][] invertedIdx = new int[queries.length][3];\\n        for (int i = 0; i < queries.length; i++) {\\n            invertedIdx[i] = new int[]{queries[i][0], queries[i][1], i};\\n        }\\n        \\n        Arrays.sort(nums);\\n        Arrays.sort(invertedIdx, (a, b) -> Integer.compare(a[1], b[1]));\\n        int i = 0, j = 0;\\n        for (; j < invertedIdx.length; j++) {\\n            while (i < nums.length && nums[i] <= invertedIdx[j][1]) {\\n                trie.addNumber(nums[i++]);\\n            }\\n            res[invertedIdx[j][2]] = trie.maximizeForXOR(invertedIdx[j][0]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**No Sort**\\nTime Complexity: `O(N + Q*2^31)`; we have at most `2^31` TrieNode and may need to travse them all.\\n```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Trie trie = new Trie();\\n        int[] res = new int[queries.length];\\n        \\n        for (int num : nums) trie.addNumber(num);\\n        for (int i = 0; i < queries.length; i++) {\\n            res[i] = trie.maximizeForXOR(queries[i][0], queries[i][1], 31, trie.root, 0);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    TrieNode[] children;\\n    public TrieNode() {\\n        this.children = new TrieNode[2];\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void addNumber(int num) {\\n        TrieNode trav = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = ((num >> i) & 1);\\n            if (trav.children[bit] == null) {\\n                trav.children[bit] = new TrieNode();\\n            }\\n            trav = trav.children[bit];\\n        }\\n    }\\n    \\n\\t// For Sort solution\\n    public int maximizeForXOR(int num) {\\n        TrieNode trav = root;\\n        int res = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (1 & (num >> i));\\n            if (trav.children[1-bit] != null) {\\n                trav = trav.children[1-bit];\\n                res |= (1 << i);\\n            } else if (trav.children[bit] != null) {\\n                trav = trav.children[bit];\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n\\t// For No-sort solution\\n    // If we are unable to maximize XOR result, it will return -1. Otherwise, it will return the max result.\\n    public int maximizeForXOR(int num, int m, int bitIdx, TrieNode trav, int res) {\\n        // there is no such a number. it has to be checked before bitIdx < 0\\n        if (trav == null) {\\n            return -1;\\n        }\\n        \\n        if (bitIdx < 0) {\\n            return res;\\n        }\\n\\n        int bit = ((num >> bitIdx) & 1);\\n        int mBit = ((m >> bitIdx) & 1);\\n        int tmp = -1;\\n        if (1-bit == 1) {\\n            // always try to maximize XOR result first\\n            if (mBit == 1)\\n                tmp = maximizeForXOR(num, m, bitIdx-1, trav.children[1], res | (1 << bitIdx));\\n            \\n            // if it cannot maximize by diving through current bit=1, then try diving through current bit=0\\n            if (tmp != -1) return tmp;\\n            \\n            if (mBit == 1)\\n                // note that if mBit is 1 but we choose bit=0, we will not have the limit anymore\\n                tmp = maximizeForXOR(num, Integer.MAX_VALUE, bitIdx-1, trav.children[0], res);\\n            else\\n                tmp = maximizeForXOR(num, m, bitIdx-1, trav.children[0], res);\\n        } else {\\n            // idea is similar as above\\n            if (mBit == 1)\\n                tmp = maximizeForXOR(num, Integer.MAX_VALUE, bitIdx-1, trav.children[0], res | (1 << bitIdx));\\n            else\\n                tmp = maximizeForXOR(num, m, bitIdx-1, trav.children[0], res | (1 << bitIdx));\\n            \\n            if (tmp != -1) return tmp;\\n            if (mBit == 1)\\n                tmp = maximizeForXOR(num, m, bitIdx-1, trav.children[1], res);\\n        }\\n        return tmp;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Trie trie = new Trie();\\n        int[] res = new int[queries.length];\\n        \\n        int[][] invertedIdx = new int[queries.length][3];\\n        for (int i = 0; i < queries.length; i++) {\\n            invertedIdx[i] = new int[]{queries[i][0], queries[i][1], i};\\n        }\\n        \\n        Arrays.sort(nums);\\n        Arrays.sort(invertedIdx, (a, b) -> Integer.compare(a[1], b[1]));\\n        int i = 0, j = 0;\\n        for (; j < invertedIdx.length; j++) {\\n            while (i < nums.length && nums[i] <= invertedIdx[j][1]) {\\n                trie.addNumber(nums[i++]);\\n            }\\n            res[invertedIdx[j][2]] = trie.maximizeForXOR(invertedIdx[j][0]);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Trie trie = new Trie();\\n        int[] res = new int[queries.length];\\n        \\n        for (int num : nums) trie.addNumber(num);\\n        for (int i = 0; i < queries.length; i++) {\\n            res[i] = trie.maximizeForXOR(queries[i][0], queries[i][1], 31, trie.root, 0);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989561,
                "title": "trie-sort-queries-o-n-log-n",
                "content": "gist: \\u201Cmulti nodes\\u201D search, need a Trie.\\n\\nLearned str.rjust(), relearned Trie and bin() today.\\n\\n> w\\n\\'11\\'\\n\\n> w.rjust(32, \"0\")\\n\\'00000000000000000000000000000011\\'\\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = {}\\n        self.val = None\\n        \\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        self.root = Trie()\\n        nums.sort()\\n        Q =  [(m,x,i) for i, (x, m) in enumerate(queries)]\\n        Q.sort()\\n        res = [-1] * len(Q)\\n        i = 0\\n        n = len(nums)\\n        for m, x, qi in Q:\\n            # print(\"n,x,m\", n,x,m)\\n            while i < n and nums[i] <= m:\\n                v = nums[i]\\n                w = bin(v)[2:]\\n                w = w.rjust(32, \"0\")\\n                # print(\"nums, i, v\", i, v)\\n                self.add(w)\\n                i += 1\\n            y = self.find(bin(x)[2:].rjust(32, \"0\"))\\n            if y is None:\\n                ans = -1\\n            else:\\n                ans = x ^ y\\n            res[qi] = ans       \\n        \\n        return res\\n    \\n    def add(self, word):\\n        # print(\"add, \", word)\\n        root = self.root\\n        for c in word:\\n            if c not in root.child:\\n                root.child[c] = Trie()\\n            root = root.child[c]\\n        root.val = int(word, 2)\\n        root.w = word\\n    \\n    def find(self, word):\\n        # print(\"find,\", word)\\n        curt = \"\"\\n        root = self.root\\n        for c in word:\\n            x = str(1 - int(c))\\n            if x in root.child:\\n                root = root.child[x]\\n                curt += x\\n            elif c in root.child:\\n                root = root.child[c]\\n                curt += c\\n            else:\\n                return None\\n        # print(\"curt:\", curt)\\n        return root.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.child = {}\\n        self.val = None\\n        \\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        self.root = Trie()\\n        nums.sort()\\n        Q =  [(m,x,i) for i, (x, m) in enumerate(queries)]\\n        Q.sort()\\n        res = [-1] * len(Q)\\n        i = 0\\n        n = len(nums)\\n        for m, x, qi in Q:\\n            # print(\"n,x,m\", n,x,m)\\n            while i < n and nums[i] <= m:\\n                v = nums[i]\\n                w = bin(v)[2:]\\n                w = w.rjust(32, \"0\")\\n                # print(\"nums, i, v\", i, v)\\n                self.add(w)\\n                i += 1\\n            y = self.find(bin(x)[2:].rjust(32, \"0\"))\\n            if y is None:\\n                ans = -1\\n            else:\\n                ans = x ^ y\\n            res[qi] = ans       \\n        \\n        return res\\n    \\n    def add(self, word):\\n        # print(\"add, \", word)\\n        root = self.root\\n        for c in word:\\n            if c not in root.child:\\n                root.child[c] = Trie()\\n            root = root.child[c]\\n        root.val = int(word, 2)\\n        root.w = word\\n    \\n    def find(self, word):\\n        # print(\"find,\", word)\\n        curt = \"\"\\n        root = self.root\\n        for c in word:\\n            x = str(1 - int(c))\\n            if x in root.child:\\n                root = root.child[x]\\n                curt += x\\n            elif c in root.child:\\n                root = root.child[c]\\n                curt += c\\n            else:\\n                return None\\n        # print(\"curt:\", curt)\\n        return root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988356,
                "title": "javascript-greedy-trie",
                "content": "```javascript\\nvar maximizeXor = function (nums, queries) {\\n  const result = new Array(queries.length);\\n  \\n  // we must use an array to save on space\\n  // objects and maps take up too much memory\\n  // we create a trie so that we can easily find\\n  // the best result\\n  const trie = [null, null];\\n  for (let num of nums) {\\n    let node = trie;\\n\\t// we start at 30 because 10 ** 9 is our max value and 2 ** 30 > 10 ** 9\\n    for (let i = 30; i >= 0; i--) {\\n      const b = 1 << i;\\n      if (b & num) {\\n        if (!node[1]) {\\n          node[1] = [null, null];\\n        }\\n        node = node[1];\\n      } else {\\n        if (!node[0]) {\\n          node[0] = [null, null];\\n        }\\n        node = node[0];\\n      }\\n    }\\n  }\\n\\n  // do a quick check to find the minimum value\\n  // to speed up our run time\\n  const min = Math.min(...nums);\\n\\n  // this is our main function that will traverse the trie\\n  const dfs = (node, num, i, xorVal, max) => {\\n\\n    // if we don\\'t have a node then there was no number\\n\\t// with this bit set/unset so we return -1\\n\\t// also if our value that we are trying to XOR is\\n\\t// greater than the max, we return -1\\n    if (!node || xorVal > max) {\\n      return -1;\\n    }\\n\\n\\t// this is our base case and we found a matching value\\n\\t// so we can return the value\\n    if (i === -1) return xorVal;\\n\\t\\n\\t// create a bit mask of our current bit we are examining\\n    const bit = 1 << i;\\n\\t\\n\\t// decrement i for our next call\\n\\t// we won\\'t need i anymore for the remainder of this call\\n    i--;\\n\\t\\n\\t// if the bit is greater than the max then we only have 1 option\\n\\t// we must take the unset bit which is 0\\n\\t// so we traverse node[0] and pass along all other values\\n    if (bit > max) {\\n      return dfs(node[0], num, i, xorVal, max);\\n    }\\n\\t\\n\\t// if the bit is set in num\\n    if (num & bit) {\\n\\t  // then we want to preference the unset bit\\n\\t  // in the xorVal\\n\\t  // if it\\'s possible then we return it\\n\\t  // otherwise we try to set the bit\\n      let x = dfs(node[0], num, i, xorVal, max);\\n      if (x > -1) {\\n        return x;\\n      }\\n      return dfs(node[1], num, i, xorVal | bit, max);\\n\\t  \\n\\t// this is just the opposite of above\\n\\t// where we preference the set bit\\n\\t// because the bit is not set in num\\n    } else {\\n      let y = dfs(node[1], num, i, xorVal | bit, max);\\n      if (y > -1) {\\n        return y;\\n      }\\n      return dfs(node[0], num, i, xorVal, max);\\n    }\\n  };\\n\\n  // Iterate through the numbers\\n  for (let i = 0; i < queries.length; i++) {\\n    const [num, max] = queries[i];\\n\\t// do a fast check to minimize the work done\\n    if (max < min) {\\n      result[i] = -1;\\n      continue;\\n    }\\n\\t// store the result for the num XOR the result\\n    result[i] = dfs(trie, num, 30, 0, max) ^ num\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```javascript\\nvar maximizeXor = function (nums, queries) {\\n  const result = new Array(queries.length);\\n  \\n  // we must use an array to save on space\\n  // objects and maps take up too much memory\\n  // we create a trie so that we can easily find\\n  // the best result\\n  const trie = [null, null];\\n  for (let num of nums) {\\n    let node = trie;\\n\\t// we start at 30 because 10 ** 9 is our max value and 2 ** 30 > 10 ** 9\\n    for (let i = 30; i >= 0; i--) {\\n      const b = 1 << i;\\n      if (b & num) {\\n        if (!node[1]) {\\n          node[1] = [null, null];\\n        }\\n        node = node[1];\\n      } else {\\n        if (!node[0]) {\\n          node[0] = [null, null];\\n        }\\n        node = node[0];\\n      }\\n    }\\n  }\\n\\n  // do a quick check to find the minimum value\\n  // to speed up our run time\\n  const min = Math.min(...nums);\\n\\n  // this is our main function that will traverse the trie\\n  const dfs = (node, num, i, xorVal, max) => {\\n\\n    // if we don\\'t have a node then there was no number\\n\\t// with this bit set/unset so we return -1\\n\\t// also if our value that we are trying to XOR is\\n\\t// greater than the max, we return -1\\n    if (!node || xorVal > max) {\\n      return -1;\\n    }\\n\\n\\t// this is our base case and we found a matching value\\n\\t// so we can return the value\\n    if (i === -1) return xorVal;\\n\\t\\n\\t// create a bit mask of our current bit we are examining\\n    const bit = 1 << i;\\n\\t\\n\\t// decrement i for our next call\\n\\t// we won\\'t need i anymore for the remainder of this call\\n    i--;\\n\\t\\n\\t// if the bit is greater than the max then we only have 1 option\\n\\t// we must take the unset bit which is 0\\n\\t// so we traverse node[0] and pass along all other values\\n    if (bit > max) {\\n      return dfs(node[0], num, i, xorVal, max);\\n    }\\n\\t\\n\\t// if the bit is set in num\\n    if (num & bit) {\\n\\t  // then we want to preference the unset bit\\n\\t  // in the xorVal\\n\\t  // if it\\'s possible then we return it\\n\\t  // otherwise we try to set the bit\\n      let x = dfs(node[0], num, i, xorVal, max);\\n      if (x > -1) {\\n        return x;\\n      }\\n      return dfs(node[1], num, i, xorVal | bit, max);\\n\\t  \\n\\t// this is just the opposite of above\\n\\t// where we preference the set bit\\n\\t// because the bit is not set in num\\n    } else {\\n      let y = dfs(node[1], num, i, xorVal | bit, max);\\n      if (y > -1) {\\n        return y;\\n      }\\n      return dfs(node[0], num, i, xorVal, max);\\n    }\\n  };\\n\\n  // Iterate through the numbers\\n  for (let i = 0; i < queries.length; i++) {\\n    const [num, max] = queries[i];\\n\\t// do a fast check to minimize the work done\\n    if (max < min) {\\n      result[i] = -1;\\n      continue;\\n    }\\n\\t// store the result for the num XOR the result\\n    result[i] = dfs(trie, num, 30, 0, max) ^ num\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 988322,
                "title": "python-trie-with-minimum-value-tracking",
                "content": "This assumes a knowledge the trie data structure. Please refer to this [LeetCode resource](https://leetcode.com/explore/learn/card/trie/) to understand how it works.\\n\\nWe consider what we want here.\\n\\nFor each query `x,m`, we want the a complementary number `z` such that `z XOR x` is the maximum, while maintaining `z <= m`.\\n\\nWe consider the padded binary string of `x`, and the ideal complementary number `z` which has inverted bits.\\n\\n \\n```text\\nIf\\nx = 000000000000000000000000000101\\n\\nWe want\\nz = 111111111111111111111111111010\\nwhile \\nz <= m\\n```\\n\\nWhen we populate the trie, we record the minimum value of each node.\\n\\nNow we search for what we want in the trie. We try to visit the optimal nodes, which is the sequence of bits in `z`. \\n\\nHowever if the node\\'s minimum value is larger than required, or that the node contains no elements, we have to visit another node.\\n\\nEventually we will reach the end of the bit string, and we have the result. The minimum value of the leaf is the value of the node itself.\\n\\n```\\nLARGE = 2**30-1\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.min_val = LARGE\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word, val):\\n        current = self.root\\n        for letter in word:\\n            current = current.children[letter]\\n            current.min_val = min(val, current.min_val)\\n\\n    def search(self, word, maxx):\\n        current = self.root\\n        for letter in word:\\n            node = current.children.get(letter)\\n            \\n            if node is None or node.min_val > maxx:\\n                # visit the other node\\n                if letter == \\'1\\':\\n                    letter = \\'0\\'\\n                else:\\n                    letter = \\'1\\'\\n                node = current.children.get(letter)\\n            \\n            current = node\\n        return current.min_val\\n\\n\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums = set(nums)\\n        min_nums = min(nums)\\n        \\n        t = Trie()\\n        \\n        for num in nums:\\n            brr = \\'{:030b}\\'.format(num)\\n            # print(brr)\\n            t.insert(brr, num)\\n        \\n        res = []\\n        for x,m in queries:\\n            if m < min_nums:\\n                res.append(-1)\\n                continue\\n            \\n            brr = \\'{:030b}\\'.format(x)\\n            z = \\'\\'.join(\\'0\\' if x == \\'1\\' else \\'1\\' for x in brr)   # flip bits\\n            val = t.search(z,m)\\n            # print(brr, val)\\n            res.append(val^x)\\n             \\n        return res\\n```",
                "solutionTags": [],
                "code": "```text\\nIf\\nx = 000000000000000000000000000101\\n\\nWe want\\nz = 111111111111111111111111111010\\nwhile \\nz <= m\\n```\n```\\nLARGE = 2**30-1\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.min_val = LARGE\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word, val):\\n        current = self.root\\n        for letter in word:\\n            current = current.children[letter]\\n            current.min_val = min(val, current.min_val)\\n\\n    def search(self, word, maxx):\\n        current = self.root\\n        for letter in word:\\n            node = current.children.get(letter)\\n            \\n            if node is None or node.min_val > maxx:\\n                # visit the other node\\n                if letter == \\'1\\':\\n                    letter = \\'0\\'\\n                else:\\n                    letter = \\'1\\'\\n                node = current.children.get(letter)\\n            \\n            current = node\\n        return current.min_val\\n\\n\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums = set(nums)\\n        min_nums = min(nums)\\n        \\n        t = Trie()\\n        \\n        for num in nums:\\n            brr = \\'{:030b}\\'.format(num)\\n            # print(brr)\\n            t.insert(brr, num)\\n        \\n        res = []\\n        for x,m in queries:\\n            if m < min_nums:\\n                res.append(-1)\\n                continue\\n            \\n            brr = \\'{:030b}\\'.format(x)\\n            z = \\'\\'.join(\\'0\\' if x == \\'1\\' else \\'1\\' for x in brr)   # flip bits\\n            val = t.search(z,m)\\n            # print(brr, val)\\n            res.append(val^x)\\n             \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988136,
                "title": "c-trie-solution",
                "content": "Build a xor trie at first.\\nWe know that if we want to find the maximum result, we prefer to choose an element which has different bit with `x`(from hight to low). if the trie has two path, we will choose the different bit with x at first, if we can get `m`, just return it. otherwise go searching the other path.  \\n```\\n\\nstruct Trie{\\n    vector<Trie*> arr;\\n    bool isNum = false;\\n    Trie() {\\n        arr.resize(2);\\n    }\\n    \\n    void build(int n) {\\n        auto node = this;\\n        for(int i = 30; i >= 0; --i) {\\n            int x = (n >> i) & 1;\\n            if(node->arr[x] == NULL) node->arr[x] = new Trie();\\n            node = node->arr[x];\\n        }\\n        node->isNum = true;\\n    }\\n    \\n    int query(int x, int m, int res, int idx) {\\n        if(res > m) return -1; //can\\'t be larger than m.\\n        if(idx < 0) return res; //at the end of the number\\n        auto node = this;\\n        int xbit = (x >>idx) & 1;\\n        int mbit = (m >> idx) & 1;\\n        if(node->arr[xbit ^  1]) {  //try the invert bit of x at first.\\n            int ret = node->arr[xbit ^  1]->query(x, m, res | ((xbit ^ 1) << idx), idx - 1);\\n            if(ret >= 0) return ret;\\n        }\\n        if(node->arr[xbit]) { // can\\'t get result above, then we try the other path.\\n            return node->arr[xbit]->query(x, m, res | (xbit << idx), idx - 1);\\n        }\\n        return -1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        for(auto x : nums) {\\n            trie.build(x);\\n        }\\n        vector<int> ans;\\n        for(auto &q : queries) {\\n            int x = q[0], m = q[1];\\n            int res = 0;\\n            res = trie.query(x, m, res, 30);\\n            if(res >= 0) {\\n                ans.push_back(res ^ x);\\n            }else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nstruct Trie{\\n    vector<Trie*> arr;\\n    bool isNum = false;\\n    Trie() {\\n        arr.resize(2);\\n    }\\n    \\n    void build(int n) {\\n        auto node = this;\\n        for(int i = 30; i >= 0; --i) {\\n            int x = (n >> i) & 1;\\n            if(node->arr[x] == NULL) node->arr[x] = new Trie();\\n            node = node->arr[x];\\n        }\\n        node->isNum = true;\\n    }\\n    \\n    int query(int x, int m, int res, int idx) {\\n        if(res > m) return -1; //can\\'t be larger than m.\\n        if(idx < 0) return res; //at the end of the number\\n        auto node = this;\\n        int xbit = (x >>idx) & 1;\\n        int mbit = (m >> idx) & 1;\\n        if(node->arr[xbit ^  1]) {  //try the invert bit of x at first.\\n            int ret = node->arr[xbit ^  1]->query(x, m, res | ((xbit ^ 1) << idx), idx - 1);\\n            if(ret >= 0) return ret;\\n        }\\n        if(node->arr[xbit]) { // can\\'t get result above, then we try the other path.\\n            return node->arr[xbit]->query(x, m, res | (xbit << idx), idx - 1);\\n        }\\n        return -1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        for(auto x : nums) {\\n            trie.build(x);\\n        }\\n        vector<int> ans;\\n        for(auto &q : queries) {\\n            int x = q[0], m = q[1];\\n            int res = 0;\\n            res = trie.query(x, m, res, 30);\\n            if(res >= 0) {\\n                ans.push_back(res ^ x);\\n            }else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015266,
                "title": "striver-s-solution-trie",
                "content": "# Complexity\\n- Time complexity : $$O(Q + N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nstruct Node {\\n    Node* child[2];\\n\\n    bool containsKey(int bit) {\\n        return (child[bit] != NULL); // checks if this bit is present or not\\n    }\\n\\n    void put(int bit, Node* node) {\\n        child[bit] = node;\\n    }\\n\\n    Node* get(int bit) {\\n        return child[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\n\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n\\n    void insert(int num) {\\n        Node* node = root;\\n        for(int i=31 ; i>=0 ; i--) {\\n            int bit = (num>>i) & 1;\\n            if(!node->containsKey(bit)) {\\n                node->put(bit,new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n\\n    int getMax(int num) {\\n        Node* node = root;\\n        int maxNum = 0;\\n\\n        for(int i=31 ; i>=0 ; i--) {\\n            int bit = (num>>i) & 1;\\n            if(node->containsKey(1-bit)) {\\n                maxNum = maxNum | (1<<i);\\n                node = node->get(1-bit);\\n            }\\n            else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[1]<b[1];\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(),0);\\n        sort(begin(nums),end(nums));\\n        \\n        vector<vector<int>> offlineQueries;\\n        for(int i=0 ; i<queries.size() ; i++) {\\n            offlineQueries.push_back({queries[i][0],queries[i][1],i}); // {ai,xi,i}\\n        }\\n        sort(begin(offlineQueries),end(offlineQueries),cmp); // O(Q log Q)\\n\\n        int idx = 0;\\n        Trie trie;\\n        //  O(Q*32 + N*32)\\n        for(int i=0 ; i<offlineQueries.size() ; i++) {\\n            int ai = offlineQueries[i][0]; // query is of type [ai,xi]\\n            int xi = offlineQueries[i][1];\\n            int queryIdx = offlineQueries[i][2];\\n\\n            while(idx<nums.size() && nums[idx]<=xi) {\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n\\n            if(idx == 0) ans[queryIdx] = -1;\\n            else ans[queryIdx] = trie.getMax(ai);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node {\\n    Node* child[2];\\n\\n    bool containsKey(int bit) {\\n        return (child[bit] != NULL); // checks if this bit is present or not\\n    }\\n\\n    void put(int bit, Node* node) {\\n        child[bit] = node;\\n    }\\n\\n    Node* get(int bit) {\\n        return child[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\n\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n\\n    void insert(int num) {\\n        Node* node = root;\\n        for(int i=31 ; i>=0 ; i--) {\\n            int bit = (num>>i) & 1;\\n            if(!node->containsKey(bit)) {\\n                node->put(bit,new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n\\n    int getMax(int num) {\\n        Node* node = root;\\n        int maxNum = 0;\\n\\n        for(int i=31 ; i>=0 ; i--) {\\n            int bit = (num>>i) & 1;\\n            if(node->containsKey(1-bit)) {\\n                maxNum = maxNum | (1<<i);\\n                node = node->get(1-bit);\\n            }\\n            else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[1]<b[1];\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(),0);\\n        sort(begin(nums),end(nums));\\n        \\n        vector<vector<int>> offlineQueries;\\n        for(int i=0 ; i<queries.size() ; i++) {\\n            offlineQueries.push_back({queries[i][0],queries[i][1],i}); // {ai,xi,i}\\n        }\\n        sort(begin(offlineQueries),end(offlineQueries),cmp); // O(Q log Q)\\n\\n        int idx = 0;\\n        Trie trie;\\n        //  O(Q*32 + N*32)\\n        for(int i=0 ; i<offlineQueries.size() ; i++) {\\n            int ai = offlineQueries[i][0]; // query is of type [ai,xi]\\n            int xi = offlineQueries[i][1];\\n            int queryIdx = offlineQueries[i][2];\\n\\n            while(idx<nums.size() && nums[idx]<=xi) {\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n\\n            if(idx == 0) ans[queryIdx] = -1;\\n            else ans[queryIdx] = trie.getMax(ai);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417477,
                "title": "c-easy-solution-using-trie-data-structure",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe **Node** class represents a node in the trie, which has two child nodes (stored as an array) and provides methods for checking if it contains a particular bit, getting a child node corresponding to a particular bit, and inserting a child node corresponding to a particular bit.\\n\\nThe **Trie** class represents the trie data structure, which has a root node and provides methods for inserting an integer into the trie and finding the maximum XOR value for a given integer. The insert method takes an integer and **inserts** its binary representation as a sequence of bits into the trie. The **getmax** method takes an integer and searches for the best match in the trie by starting from the root node and moving down the trie, choosing the child node corresponding to the opposite bit if it exists (i.e., if a 0 is encountered, it tries to go to the 1 child node, and vice versa). At each level of the trie, it sets the bit of the maximum XOR value to 1 if a 1 child node exists at that level, and continues the search. Once the search is complete, the maximum XOR value is returned.\\n\\nThe **Solution** class uses the **Trie** class to solve the problem by sorting the input array and the queries, and then iterating through the queries in sorted order. For each query, it inserts all the integers in the input array that are less than or equal to the query\\'s second element into the trie, and then finds the maximum XOR value for the query\\'s first element using the **getmax** method. The results are stored in a vector and returned.\\n\\nOverall, the code is an efficient solution to the problem using a trie data structure to search for matches in the input array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the **insert** method of the **Trie** class is $$O(32n)$$, where n is the number of integers to be inserted into the trie. This is because the method performs **32** iterations, one for each bit of the integer, and the worst-case scenario is when all n integers have distinct binary representations.\\n\\nThe time complexity of the **getmax** method of the **Trie** class is also $$O(32)$$, since it performs a fixed number of operations for each query.\\n\\nThe time complexity of the **maximizeXor** method of the Solution class is $$O(n log n + q log q + q log n)$$, where n is the size of the input array, q is the number of **queries**, and the terms correspond to the time taken to sort the input array, sort the queries, and iterate through the queries, respectively. Within the loop over the queries, the time taken to insert integers into the trie is $$O(n)$$, since each integer is inserted at most once.\\n\\nTherefore, the overall time complexity of the solution is $$O(n log n + q log q + q log n + 32n)$$, and since **32n** is dominated by the other terms, we can simplify this to:\\n\\n$$O(n log n + q log q + q log n)$$.\\n\\n\\n# Code\\n```\\n\\n    class Node\\n    {\\n        Node* child[2];\\n        public:\\n        \\n        bool contain(int bit)\\n        {\\n            return child[bit] != NULL;\\n        }\\n        Node* get(int bit)\\n        {\\n            return child[bit];\\n        }\\n        void insert(int bit,Node* node)\\n        {\\n            child[bit] = node;\\n        }\\n\\n    };\\n    class Trie\\n    {\\n        Node* root;\\n        public:\\n        Trie()\\n        {\\n            root = new Node();\\n        }\\n        void insert(int num)\\n        {\\n            Node* node = root;\\n\\n            for(int i=31;i>=0;i--)\\n            {\\n                int bit = (num >> i) & 1;\\n                if(!node->contain(bit))\\n                {\\n                    node->insert(bit,new Node());\\n                }\\n                node = node->get(bit);\\n            }\\n        }\\n        int getmax(int num)\\n        {\\n            Node* node = root;\\n            int max1 = 0;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int bit = (num >> i) & 1;\\n                if(node->contain(1 - bit))\\n                {\\n                    max1 = max1 | (1 << i);\\n                    node = node->get(1-bit);\\n                }\\n                else\\n                {\\n                    node = node->get(bit);\\n                }\\n            }\\n            return max1;\\n        }\\n    };\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) \\n    {\\n        Trie trie;\\n\\t\\tsort(arr.begin(), arr.end());\\n\\t\\tvector<pair<int, pair<int, int>>>queries1;\\n\\t\\tfor(int i=0; i<queries.size(); i++)\\n        {\\n\\t\\t\\tqueries1.push_back({queries[i][1], {queries[i][0], i}});\\n\\t\\t}\\n\\n\\t\\tsort(queries1.begin(), queries1.end());\\n\\t\\tvector<int>ans(queries.size(), 0);\\n\\n\\t\\tint j=0, n=arr.size();\\n\\t\\tfor(int i=0; i<queries.size(); i++)\\n        {\\n\\t\\t\\twhile(j < n && arr[j] <= queries1[i].first)\\n            {\\n\\t\\t\\t\\ttrie.insert(arr[j]);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tif(j==0)\\n            {\\n                ans[queries1[i].second.second] = -1;\\n            }\\n\\t\\t\\telse\\n            {\\n                ans[queries1[i].second.second] = trie.getmax(queries1[i].second.first);\\n            }\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\n\\n    class Node\\n    {\\n        Node* child[2];\\n        public:\\n        \\n        bool contain(int bit)\\n        {\\n            return child[bit] != NULL;\\n        }\\n        Node* get(int bit)\\n        {\\n            return child[bit];\\n        }\\n        void insert(int bit,Node* node)\\n        {\\n            child[bit] = node;\\n        }\\n\\n    };\\n    class Trie\\n    {\\n        Node* root;\\n        public:\\n        Trie()\\n        {\\n            root = new Node();\\n        }\\n        void insert(int num)\\n        {\\n            Node* node = root;\\n\\n            for(int i=31;i>=0;i--)\\n            {\\n                int bit = (num >> i) & 1;\\n                if(!node->contain(bit))\\n                {\\n                    node->insert(bit,new Node());\\n                }\\n                node = node->get(bit);\\n            }\\n        }\\n        int getmax(int num)\\n        {\\n            Node* node = root;\\n            int max1 = 0;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int bit = (num >> i) & 1;\\n                if(node->contain(1 - bit))\\n                {\\n                    max1 = max1 | (1 << i);\\n                    node = node->get(1-bit);\\n                }\\n                else\\n                {\\n                    node = node->get(bit);\\n                }\\n            }\\n            return max1;\\n        }\\n    };\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) \\n    {\\n        Trie trie;\\n\\t\\tsort(arr.begin(), arr.end());\\n\\t\\tvector<pair<int, pair<int, int>>>queries1;\\n\\t\\tfor(int i=0; i<queries.size(); i++)\\n        {\\n\\t\\t\\tqueries1.push_back({queries[i][1], {queries[i][0], i}});\\n\\t\\t}\\n\\n\\t\\tsort(queries1.begin(), queries1.end());\\n\\t\\tvector<int>ans(queries.size(), 0);\\n\\n\\t\\tint j=0, n=arr.size();\\n\\t\\tfor(int i=0; i<queries.size(); i++)\\n        {\\n\\t\\t\\twhile(j < n && arr[j] <= queries1[i].first)\\n            {\\n\\t\\t\\t\\ttrie.insert(arr[j]);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tif(j==0)\\n            {\\n                ans[queries1[i].second.second] = -1;\\n            }\\n\\t\\t\\telse\\n            {\\n                ans[queries1[i].second.second] = trie.getmax(queries1[i].second.first);\\n            }\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644279,
                "title": "c-easy-to-understand-step-by-step",
                "content": "\\n# Code\\n```\\nclass Node{\\npublic:\\n    Node* links[2];\\n    int mini[2];\\n    \\n    Node(){\\n        links[0]=NULL,links[1]=NULL;\\n        mini[0]=INT_MAX,mini[1]=INT_MAX;\\n    }\\n    bool containsKey(int i){\\n        return links[i]!=NULL;\\n    }\\n    void put(int i, Node* node){\\n        links[i]=node;\\n    }\\n    Node* get(int i){\\n        return links[i];\\n    }\\n    void putMin(int bit, int x){\\n        mini[bit]=min(mini[bit],x);\\n    }\\n    int getMin(int bit){\\n        return mini[bit];\\n    }\\n};\\nclass Solution {\\npublic:\\n    Node* root;\\n    void insert(int x)\\n    {\\n        Node* curr=root;\\n        int k=32;\\n        while(k--)\\n        {\\n            int bit=((x>>k)&1);\\n            if(!curr->containsKey(bit))\\n                curr->put(bit,new Node());\\n            curr->putMin(bit,x);\\n            curr=curr->get(bit);\\n        }\\n    }\\n    int searchMaxXOR(int x, int m)\\n    {\\n        Node* curr=root;\\n        int ans=0,k=32;\\n        while(k--)\\n        {\\n            ans=ans*2;\\n            \\n            int bit=((x>>k)&1);\\n            if(curr->containsKey(1-bit) && curr->getMin(1-bit)<=m)\\n            {\\n                curr=curr->get(1-bit);\\n                ans++;\\n            }\\n            else\\n                curr=curr->get(bit);\\n        }\\n        return ans;\\n    }\\n    vector<int> maximizeXor(vector<int>& v, vector<vector<int>>& q) {\\n        int n=v.size();\\n        root=new Node();\\n        for(int i=0;i<n;i++)\\n            insert(v[i]);\\n        int minEle=*min_element(v.begin(),v.end());\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int x=q[i][0],m=q[i][1];\\n            if(minEle<=m)\\n                ans.push_back(searchMaxXOR(x,m));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node{\\npublic:\\n    Node* links[2];\\n    int mini[2];\\n    \\n    Node(){\\n        links[0]=NULL,links[1]=NULL;\\n        mini[0]=INT_MAX,mini[1]=INT_MAX;\\n    }\\n    bool containsKey(int i){\\n        return links[i]!=NULL;\\n    }\\n    void put(int i, Node* node){\\n        links[i]=node;\\n    }\\n    Node* get(int i){\\n        return links[i];\\n    }\\n    void putMin(int bit, int x){\\n        mini[bit]=min(mini[bit],x);\\n    }\\n    int getMin(int bit){\\n        return mini[bit];\\n    }\\n};\\nclass Solution {\\npublic:\\n    Node* root;\\n    void insert(int x)\\n    {\\n        Node* curr=root;\\n        int k=32;\\n        while(k--)\\n        {\\n            int bit=((x>>k)&1);\\n            if(!curr->containsKey(bit))\\n                curr->put(bit,new Node());\\n            curr->putMin(bit,x);\\n            curr=curr->get(bit);\\n        }\\n    }\\n    int searchMaxXOR(int x, int m)\\n    {\\n        Node* curr=root;\\n        int ans=0,k=32;\\n        while(k--)\\n        {\\n            ans=ans*2;\\n            \\n            int bit=((x>>k)&1);\\n            if(curr->containsKey(1-bit) && curr->getMin(1-bit)<=m)\\n            {\\n                curr=curr->get(1-bit);\\n                ans++;\\n            }\\n            else\\n                curr=curr->get(bit);\\n        }\\n        return ans;\\n    }\\n    vector<int> maximizeXor(vector<int>& v, vector<vector<int>>& q) {\\n        int n=v.size();\\n        root=new Node();\\n        for(int i=0;i<n;i++)\\n            insert(v[i]);\\n        int minEle=*min_element(v.begin(),v.end());\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int x=q[i][0],m=q[i][1];\\n            if(minEle<=m)\\n                ans.push_back(searchMaxXOR(x,m));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505075,
                "title": "c-trie-easy-to-understand-code",
                "content": "```\\nclass TrieNode {\\n  public: \\n    TrieNode* child[2] ; \\n    \\n    TrieNode() {\\n        this->child[0] = this->child[1] = 0 ; \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    TrieNode *nd ; \\n    \\n    void insert(int x) {\\n        TrieNode* t = nd ; \\n        bitset<32> b(x) ; \\n        for(int i = 31; i >=0 ; i--) {\\n            if(!t->child[b[i]])\\n                t->child[b[i]] = new TrieNode() ; \\n            t = t->child[b[i]] ;   \\n        }\\n    }\\n    \\n    int solve(int n) {\\n        TrieNode* t = nd ; \\n        bitset<32> b(n) ; \\n        int ct =0 ; \\n        for(int i = 31; i >=0 ; i--) {\\n            if(t->child[!b[i]])\\n                ct += (1 << i) , t = t->child[!b[i]] ; \\n            else \\n                t = t->child[b[i]] ;   \\n        }\\n        return ct ; \\n    }\\n    \\n    vector<int> maximizeXor(vector<int>& a, vector<vector<int>>& queries) {\\n        vector<pair<pair<int, int>, int> > q;\\n        for(int i = 0; i < queries.size(); i++)\\n            q.push_back({{queries[i][0], queries[i][1]}, i});\\n        sort(q.begin(), q.end(), [](pair<pair<int, int>, int> &a, pair<pair<int, int>, int> &b){\\n            return a.first.second < b.first.second;\\n        });\\n        sort(a.begin(), a.end()) ; \\n        vector<int> ans(q.size(), -1) ; \\n        nd = new TrieNode() ; \\n        int idx = 0 ; \\n        for(int i =0 ; i < q.size() ; i++) {\\n            int comp = q[i].first.first, lim = q[i].first.second, ptr = q[i].second ; \\n            while(idx < a.size() and a[idx] <= lim)\\n                insert(a[idx++]) ; \\n            if(idx>0)\\n                ans[ptr] = solve(comp) ; \\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n  public: \\n    TrieNode* child[2] ; \\n    \\n    TrieNode() {\\n        this->child[0] = this->child[1] = 0 ; \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    TrieNode *nd ; \\n    \\n    void insert(int x) {\\n        TrieNode* t = nd ; \\n        bitset<32> b(x) ; \\n        for(int i = 31; i >=0 ; i--) {\\n            if(!t->child[b[i]])\\n                t->child[b[i]] = new TrieNode() ; \\n            t = t->child[b[i]] ;   \\n        }\\n    }\\n    \\n    int solve(int n) {\\n        TrieNode* t = nd ; \\n        bitset<32> b(n) ; \\n        int ct =0 ; \\n        for(int i = 31; i >=0 ; i--) {\\n            if(t->child[!b[i]])\\n                ct += (1 << i) , t = t->child[!b[i]] ; \\n            else \\n                t = t->child[b[i]] ;   \\n        }\\n        return ct ; \\n    }\\n    \\n    vector<int> maximizeXor(vector<int>& a, vector<vector<int>>& queries) {\\n        vector<pair<pair<int, int>, int> > q;\\n        for(int i = 0; i < queries.size(); i++)\\n            q.push_back({{queries[i][0], queries[i][1]}, i});\\n        sort(q.begin(), q.end(), [](pair<pair<int, int>, int> &a, pair<pair<int, int>, int> &b){\\n            return a.first.second < b.first.second;\\n        });\\n        sort(a.begin(), a.end()) ; \\n        vector<int> ans(q.size(), -1) ; \\n        nd = new TrieNode() ; \\n        int idx = 0 ; \\n        for(int i =0 ; i < q.size() ; i++) {\\n            int comp = q[i].first.first, lim = q[i].first.second, ptr = q[i].second ; \\n            while(idx < a.size() and a[idx] <= lim)\\n                insert(a[idx++]) ; \\n            if(idx>0)\\n                ans[ptr] = solve(comp) ; \\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368286,
                "title": "c-trie-online-queries-bit-manipulation",
                "content": "```\\nclass Node{\\n  public:\\n    int min_num = INT_MAX;\\n    Node* child[2];\\n    Node(){\\n        child[0] = NULL;\\n        child[1] = NULL;\\n    }\\n};\\nclass Trie{\\n  private:\\n    Node* root;\\n  public:\\n    void construct(vector<int>& nums)\\n    {\\n        root = new Node();\\n        for(auto& num: nums)\\n        {\\n            Node* cur = root;\\n            cur->min_num = min(cur->min_num,num);\\n            for(int k = 31;k>=0;k--)\\n            {\\n                int x = (num>>k)&1;\\n                if(cur->child[x] == NULL)\\n                    cur->child[x] = new Node();\\n                cur = cur->child[x];\\n                cur->min_num = min(cur->min_num,num);\\n            }\\n        }\\n    }\\n    int query(vector<int>& q)\\n    {\\n        int num = q[0], m = q[1];\\n        Node* cur = root;\\n        bool small = 0;\\n        int ans = 0;\\n        if(cur->min_num > m) return -1;\\n        for(int k = 31;k>=0;k--)\\n        {\\n            int x = (num>>k)&1;\\n            int y = (m>>k)&1;\\n            int target = 1-x;\\n            if(y == 1 || small)\\n            {\\n                if(cur->child[target] != NULL && cur->child[target]->min_num <= m)\\n                {\\n                    cur = cur->child[target];\\n                    ans = (ans<<1) + 1;\\n                    if(target == 0) small = 1;\\n                }\\n                else\\n                {\\n                    cur = cur->child[1-target];\\n                    ans = (ans<<1);\\n                    if(target == 1) small = 1;\\n                }\\n            }\\n            else\\n            {\\n                if(cur->child[0] != NULL && cur->child[0]->min_num <= m)\\n                {\\n                    cur = cur->child[0];\\n                    ans = (ans<<1) + (target == 0);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        trie.construct(nums);\\n        int idx = 0;\\n        vector<int> out(queries.size());\\n        for(auto& q: queries)\\n        {\\n            out[idx++] = trie.query(q);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\n  public:\\n    int min_num = INT_MAX;\\n    Node* child[2];\\n    Node(){\\n        child[0] = NULL;\\n        child[1] = NULL;\\n    }\\n};\\nclass Trie{\\n  private:\\n    Node* root;\\n  public:\\n    void construct(vector<int>& nums)\\n    {\\n        root = new Node();\\n        for(auto& num: nums)\\n        {\\n            Node* cur = root;\\n            cur->min_num = min(cur->min_num,num);\\n            for(int k = 31;k>=0;k--)\\n            {\\n                int x = (num>>k)&1;\\n                if(cur->child[x] == NULL)\\n                    cur->child[x] = new Node();\\n                cur = cur->child[x];\\n                cur->min_num = min(cur->min_num,num);\\n            }\\n        }\\n    }\\n    int query(vector<int>& q)\\n    {\\n        int num = q[0], m = q[1];\\n        Node* cur = root;\\n        bool small = 0;\\n        int ans = 0;\\n        if(cur->min_num > m) return -1;\\n        for(int k = 31;k>=0;k--)\\n        {\\n            int x = (num>>k)&1;\\n            int y = (m>>k)&1;\\n            int target = 1-x;\\n            if(y == 1 || small)\\n            {\\n                if(cur->child[target] != NULL && cur->child[target]->min_num <= m)\\n                {\\n                    cur = cur->child[target];\\n                    ans = (ans<<1) + 1;\\n                    if(target == 0) small = 1;\\n                }\\n                else\\n                {\\n                    cur = cur->child[1-target];\\n                    ans = (ans<<1);\\n                    if(target == 1) small = 1;\\n                }\\n            }\\n            else\\n            {\\n                if(cur->child[0] != NULL && cur->child[0]->min_num <= m)\\n                {\\n                    cur = cur->child[0];\\n                    ans = (ans<<1) + (target == 0);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        trie.construct(nums);\\n        int idx = 0;\\n        vector<int> out(queries.size());\\n        for(auto& q: queries)\\n        {\\n            out[idx++] = trie.query(q);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265372,
                "title": "c-trie-soln-faster-then-90-clean-trie-using-class-and-structure",
                "content": "```\\nstruct Node{\\n    Node* links[2];\\n    \\n    bool iscontains(int bit)\\n    {\\n        return links[bit]!=NULL;\\n    }\\n    \\n    void put(int bit,Node* node)\\n    {\\n        links[bit]=node;\\n    }\\n    \\n    Node* get(int bit)\\n    {\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\n  private: Node* root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    \\n    void insert(int num)\\n    {\\n        Node* node=root;\\n        \\n        for(int i=31;i>=0;--i)\\n        {\\n            int bit=num>>i &1;\\n            \\n            if(!node->iscontains(bit))\\n                node->put(bit,new Node());\\n            \\n            node=node->get(bit);\\n        }\\n    }\\n    \\n    int getmax(int num)\\n    {\\n        Node* node=root;\\n        int mx=0;\\n        for(int i=31;i>=0;--i)\\n        {\\n            int bit=num>>i &1;\\n            \\n            if(node->iscontains(1-bit))\\n            {\\n                mx=mx | 1<<i;\\n                node=node->get(1-bit);\\n            }\\n            else\\n            node=node->get(bit);\\n        }\\n        return mx;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans(queries.size(),0);\\n        \\n        vector<pair<int,pair<int,int>>> vp;\\n        for(int i=0;i<queries.size();++i)\\n        {\\n            vp.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n        sort(vp.begin(),vp.end());\\n        \\n        int p=0;\\n        int i=0;\\n        Trie t;\\n        while(i<nums.size())\\n        {\\n            if(p>=vp.size()) return ans;\\n            if(nums[i]<=vp[p].first)\\n            {\\n                t.insert(nums[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                int k=vp[p].second.first;\\n                int ind=vp[p].second.second;\\n                \\n                if(i==0)\\n                {\\n                    ans[ind]=-1;\\n                    p++;\\n                    continue;\\n                }\\n                int mx=t.getmax(k);\\n                ans[ind]=mx;\\n                p++;\\n            }\\n        }\\n        while(p<vp.size())\\n        {\\n            int k=vp[p].second.first;\\n            int ind=vp[p].second.second;\\n             \\n            int mx=t.getmax(k);\\n            ans[ind]=mx;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[2];\\n    \\n    bool iscontains(int bit)\\n    {\\n        return links[bit]!=NULL;\\n    }\\n    \\n    void put(int bit,Node* node)\\n    {\\n        links[bit]=node;\\n    }\\n    \\n    Node* get(int bit)\\n    {\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\n  private: Node* root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    \\n    void insert(int num)\\n    {\\n        Node* node=root;\\n        \\n        for(int i=31;i>=0;--i)\\n        {\\n            int bit=num>>i &1;\\n            \\n            if(!node->iscontains(bit))\\n                node->put(bit,new Node());\\n            \\n            node=node->get(bit);\\n        }\\n    }\\n    \\n    int getmax(int num)\\n    {\\n        Node* node=root;\\n        int mx=0;\\n        for(int i=31;i>=0;--i)\\n        {\\n            int bit=num>>i &1;\\n            \\n            if(node->iscontains(1-bit))\\n            {\\n                mx=mx | 1<<i;\\n                node=node->get(1-bit);\\n            }\\n            else\\n            node=node->get(bit);\\n        }\\n        return mx;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans(queries.size(),0);\\n        \\n        vector<pair<int,pair<int,int>>> vp;\\n        for(int i=0;i<queries.size();++i)\\n        {\\n            vp.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n        sort(vp.begin(),vp.end());\\n        \\n        int p=0;\\n        int i=0;\\n        Trie t;\\n        while(i<nums.size())\\n        {\\n            if(p>=vp.size()) return ans;\\n            if(nums[i]<=vp[p].first)\\n            {\\n                t.insert(nums[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                int k=vp[p].second.first;\\n                int ind=vp[p].second.second;\\n                \\n                if(i==0)\\n                {\\n                    ans[ind]=-1;\\n                    p++;\\n                    continue;\\n                }\\n                int mx=t.getmax(k);\\n                ans[ind]=mx;\\n                p++;\\n            }\\n        }\\n        while(p<vp.size())\\n        {\\n            int k=vp[p].second.first;\\n            int ind=vp[p].second.second;\\n             \\n            int mx=t.getmax(k);\\n            ans[ind]=mx;\\n            p++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178869,
                "title": "c-easy-solution-w-trie-bit-manipulation-sorting-offline-query",
                "content": "```\\nclass Node {\\nprivate:\\n    Node* links[2];\\npublic:\\n    bool contains(int bit) {\\n        return (links[bit] != NULL);\\n    }\\n    void put(int bit, Node* node) {\\n        links[bit] = node;\\n    }\\n    Node* get(int bit) {\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        Node* node = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!node->contains(bit)) {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n    int maxXOR(int num) {\\n        Node* node = root;\\n        int mx = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!node->contains(1-bit)) {\\n                node = node->get(bit);\\n            } else {\\n                mx = mx | (1 << i);\\n                node = node->get(1-bit);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        int n = arr.size(), m = queries.size();\\n        Trie trie;\\n        vector<int> result(m, 0);\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(), queries.end(), [](vector<int> &lhs, vector<int> &rhs) {\\n            return lhs[1] < rhs[1];\\n        });\\n        int i = 0;\\n        for (auto query : queries) {\\n            int x = query[0], a = query[1], ind = query[2];\\n            while (i < n && arr[i] <= a) {\\n                trie.insert(arr[i]);\\n                i++;\\n            }\\n            if (i == 0) result[ind] = -1;\\n            else result[ind] = trie.maxXOR(x);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nclass Node {\\nprivate:\\n    Node* links[2];\\npublic:\\n    bool contains(int bit) {\\n        return (links[bit] != NULL);\\n    }\\n    void put(int bit, Node* node) {\\n        links[bit] = node;\\n    }\\n    Node* get(int bit) {\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        Node* node = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!node->contains(bit)) {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n    int maxXOR(int num) {\\n        Node* node = root;\\n        int mx = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!node->contains(1-bit)) {\\n                node = node->get(bit);\\n            } else {\\n                mx = mx | (1 << i);\\n                node = node->get(1-bit);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        int n = arr.size(), m = queries.size();\\n        Trie trie;\\n        vector<int> result(m, 0);\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(), queries.end(), [](vector<int> &lhs, vector<int> &rhs) {\\n            return lhs[1] < rhs[1];\\n        });\\n        int i = 0;\\n        for (auto query : queries) {\\n            int x = query[0], a = query[1], ind = query[2];\\n            while (i < n && arr[i] <= a) {\\n                trie.insert(arr[i]);\\n                i++;\\n            }\\n            if (i == 0) result[ind] = -1;\\n            else result[ind] = trie.maxXOR(x);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170473,
                "title": "trie-approach",
                "content": "**Brute Force:** Time Limit Exceeded\\n\\t\\n\\tTime Complexity: O(queries x N)\\n\\tSpace Complexity: O(N) + O(N)\\n```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            int xi = queries[i][0];\\n            int ai = queries[i][1];\\n            \\n            int maxXOR = -1;\\n            \\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[j] <= ai) {\\n                    maxXOR = Math.max(maxXOR, nums[j] ^ xi);\\n                }\\n            }\\n            list.add(maxXOR);\\n        }\\n        \\n        // list ----> array\\n        int[] ans = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            ans[i] = list.get(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**Trie Approach:**\\n\\n\\tTime Complexity: O(Queries x 32 + N x 32)\\n\\tSpace Complexity: O(N x N) + O(N) + O(N)\\n\\t\\n```\\nclass Node {\\n    Node[] links = new Node[2];\\n \\n    public Node() {\\n        \\n    }\\n    \\n    boolean containsKey(int ind) {\\n        return (links[ind] != null);\\n    }\\n  \\n    Node get(int ind) {\\n        return links[ind];\\n    }\\n  \\n    void put(int ind, Node node) {\\n        links[ind] = node;\\n    }\\n}\\n\\nclass Trie {\\n    private Node root;\\n    \\n    Trie() {\\n        root = new Node();\\n    }\\n \\n    public void insert(int num) {\\n        Node node = root;\\n        \\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            \\n            if (!node.containsKey(bit)) {\\n                node.put(bit, new Node());\\n            }\\n            node = node.get(bit);\\n        }\\n  }\\n \\n  public int getMax(int num) {\\n    Node node = root;\\n    int maxNum = 0;\\n      \\n    for (int i = 31; i >= 0; i--) {\\n      int bit = (num >> i) & 1;\\n        \\n      if (node.containsKey(1 - bit)) {\\n        maxNum = maxNum | (1 << i);\\n        node = node.get(1 - bit);\\n      } \\n      else {\\n        node = node.get(bit);\\n      }\\n    }\\n    return maxNum;\\n  }\\n}\\n\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        ArrayList<ArrayList<Integer>> offlineQueries = new ArrayList<>();\\n        int m = queries.length;\\n        \\n        for (int i = 0; i < m; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(queries[i][1]);\\n            temp.add(queries[i][0]);\\n            temp.add(i);\\n            offlineQueries.add(temp);\\n        }\\n        \\n        // Sorting Offline Queries\\n        Collections.sort(offlineQueries, new Comparator <ArrayList<Integer>>() {\\n          @Override\\n          public int compare(ArrayList<Integer> a, ArrayList<Integer> b) {\\n            return a.get(0).compareTo(b.get(0));\\n          }\\n        });\\n        \\n        int ind = 0;\\n        int n = nums.length;\\n        \\n        Trie trie = new Trie();\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        \\n        for (int i = 0; i < m; i++) {\\n            ans.add(-1);\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n          while (ind < n && nums[ind] <= offlineQueries.get(i).get(0)) {\\n            trie.insert(nums[ind]);\\n            ind++;\\n          }\\n            \\n          int queryInd = offlineQueries.get(i).get(2);\\n          \\n            if (ind != 0) {\\n              ans.set(queryInd, trie.getMax(offlineQueries.get(i).get(1)));\\n          }\\n          else {\\n              ans.set(queryInd, -1);\\n          }\\n       }\\n        \\n    \\n        // List ----> array\\n        int[] arr = new int[ans.size()];\\n        for (int i = 0; i < ans.size(); i++) {\\n            arr[i] = ans.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n\\n// Please upvote, if you find this helpful\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            int xi = queries[i][0];\\n            int ai = queries[i][1];\\n            \\n            int maxXOR = -1;\\n            \\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[j] <= ai) {\\n                    maxXOR = Math.max(maxXOR, nums[j] ^ xi);\\n                }\\n            }\\n            list.add(maxXOR);\\n        }\\n        \\n        // list ----> array\\n        int[] ans = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            ans[i] = list.get(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Node {\\n    Node[] links = new Node[2];\\n \\n    public Node() {\\n        \\n    }\\n    \\n    boolean containsKey(int ind) {\\n        return (links[ind] != null);\\n    }\\n  \\n    Node get(int ind) {\\n        return links[ind];\\n    }\\n  \\n    void put(int ind, Node node) {\\n        links[ind] = node;\\n    }\\n}\\n\\nclass Trie {\\n    private Node root;\\n    \\n    Trie() {\\n        root = new Node();\\n    }\\n \\n    public void insert(int num) {\\n        Node node = root;\\n        \\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            \\n            if (!node.containsKey(bit)) {\\n                node.put(bit, new Node());\\n            }\\n            node = node.get(bit);\\n        }\\n  }\\n \\n  public int getMax(int num) {\\n    Node node = root;\\n    int maxNum = 0;\\n      \\n    for (int i = 31; i >= 0; i--) {\\n      int bit = (num >> i) & 1;\\n        \\n      if (node.containsKey(1 - bit)) {\\n        maxNum = maxNum | (1 << i);\\n        node = node.get(1 - bit);\\n      } \\n      else {\\n        node = node.get(bit);\\n      }\\n    }\\n    return maxNum;\\n  }\\n}\\n\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        ArrayList<ArrayList<Integer>> offlineQueries = new ArrayList<>();\\n        int m = queries.length;\\n        \\n        for (int i = 0; i < m; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(queries[i][1]);\\n            temp.add(queries[i][0]);\\n            temp.add(i);\\n            offlineQueries.add(temp);\\n        }\\n        \\n        // Sorting Offline Queries\\n        Collections.sort(offlineQueries, new Comparator <ArrayList<Integer>>() {\\n          @Override\\n          public int compare(ArrayList<Integer> a, ArrayList<Integer> b) {\\n            return a.get(0).compareTo(b.get(0));\\n          }\\n        });\\n        \\n        int ind = 0;\\n        int n = nums.length;\\n        \\n        Trie trie = new Trie();\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        \\n        for (int i = 0; i < m; i++) {\\n            ans.add(-1);\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n          while (ind < n && nums[ind] <= offlineQueries.get(i).get(0)) {\\n            trie.insert(nums[ind]);\\n            ind++;\\n          }\\n            \\n          int queryInd = offlineQueries.get(i).get(2);\\n          \\n            if (ind != 0) {\\n              ans.set(queryInd, trie.getMax(offlineQueries.get(i).get(1)));\\n          }\\n          else {\\n              ans.set(queryInd, -1);\\n          }\\n       }\\n        \\n    \\n        // List ----> array\\n        int[] arr = new int[ans.size()];\\n        for (int i = 0; i < ans.size(); i++) {\\n            arr[i] = ans.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n\\n// Please upvote, if you find this helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123427,
                "title": "java-trie-structure-faster-than-100",
                "content": "```\\nclass TrieNode {\\n    TrieNode left, right;\\n    int min = Integer.MAX_VALUE;\\n}\\n\\nclass Solution {\\n    \\n    public void insert(TrieNode root, int val) {\\n        for(int i=31; i>=0; i--) {\\n            int idx = (1<<i)&val;\\n            if(idx ==0) {\\n                if(root.left == null) root.left = new TrieNode();\\n                root = root.left;\\n            } else {\\n                if(root.right == null) root.right = new TrieNode();\\n                root = root.right;\\n            }\\n            root.min = Math.min(root.min, val);\\n        }\\n    }\\n    \\n    public int findMaxXor(TrieNode root, int x, int max) {\\n        int result = 0;\\n        for(int i=31; i>=0; i--) {\\n            int idx = (1<<i)&x;\\n            if(idx == 0) {\\n                if(root.right!=null && root.right.min <= max) {\\n                    root = root.right;\\n                    result |= (1<<i);\\n                } else if(root.left !=null && root.left.min <= max) {\\n                    root = root.left;\\n                } else {\\n                    break;\\n                }\\n            } else {\\n                 if(root.left!=null && root.left.min <= max) {\\n                    root = root.left;\\n                    result |= (1<<i);\\n                } else if(root.right !=null && root.right.min <= max) {\\n                    root = root.right;\\n                } else {\\n                     break;\\n                 }\\n            } \\n        }\\n        return result;\\n    }\\n    \\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        TrieNode root = new TrieNode();\\n        int minNum = Integer.MAX_VALUE;\\n        for(int num : nums) {\\n            minNum = Math.min(minNum, num);\\n            insert(root, num);\\n        }\\n        \\n        int[] result = new int[queries.length];\\n        int i=0;\\n        for(int[] query : queries) {\\n            if(query[1]<minNum) \\n                result[i++] = -1;\\n            else\\n                result[i++] = findMaxXor(root, query[0], query[1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    TrieNode left, right;\\n    int min = Integer.MAX_VALUE;\\n}\\n\\nclass Solution {\\n    \\n    public void insert(TrieNode root, int val) {\\n        for(int i=31; i>=0; i--) {\\n            int idx = (1<<i)&val;\\n            if(idx ==0) {\\n                if(root.left == null) root.left = new TrieNode();\\n                root = root.left;\\n            } else {\\n                if(root.right == null) root.right = new TrieNode();\\n                root = root.right;\\n            }\\n            root.min = Math.min(root.min, val);\\n        }\\n    }\\n    \\n    public int findMaxXor(TrieNode root, int x, int max) {\\n        int result = 0;\\n        for(int i=31; i>=0; i--) {\\n            int idx = (1<<i)&x;\\n            if(idx == 0) {\\n                if(root.right!=null && root.right.min <= max) {\\n                    root = root.right;\\n                    result |= (1<<i);\\n                } else if(root.left !=null && root.left.min <= max) {\\n                    root = root.left;\\n                } else {\\n                    break;\\n                }\\n            } else {\\n                 if(root.left!=null && root.left.min <= max) {\\n                    root = root.left;\\n                    result |= (1<<i);\\n                } else if(root.right !=null && root.right.min <= max) {\\n                    root = root.right;\\n                } else {\\n                     break;\\n                 }\\n            } \\n        }\\n        return result;\\n    }\\n    \\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        TrieNode root = new TrieNode();\\n        int minNum = Integer.MAX_VALUE;\\n        for(int num : nums) {\\n            minNum = Math.min(minNum, num);\\n            insert(root, num);\\n        }\\n        \\n        int[] result = new int[queries.length];\\n        int i=0;\\n        for(int[] query : queries) {\\n            if(query[1]<minNum) \\n                result[i++] = -1;\\n            else\\n                result[i++] = findMaxXor(root, query[0], query[1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015920,
                "title": "c-trie-solution",
                "content": "```\\nclass Node {\\nprivate:\\n    Node* links[2];\\npublic:\\n    bool contains(int bit) {\\n        return (links[bit] != NULL);\\n    }\\n    void put(int bit, Node* node) {\\n        links[bit] = node;\\n    }\\n    Node* get(int bit) {\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        Node* node = root;\\n        for (int i = 31; i >= 0; --i) {\\n            int bit = (num >> i) & 1;\\n            if (!node->contains(bit)) {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n    int maxXor(int num) {\\n        Node* node = root;\\n        int mx = 0;\\n        for (int i = 31; i >= 0; --i) {\\n            int bit = (num >> i) & 1;\\n            if (node->contains(1-bit)) {\\n                mx = mx | (1 << i);\\n                node = node->get(1-bit);\\n            } else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size(), m = queries.size();\\n        Trie trie;\\n        vector<int> result(m, 0);\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(), queries.end(), [](vector<int> &lhs, vector<int> &rhs) {\\n            return lhs[1] < rhs[1];\\n        });\\n        int i = 0;\\n        for (auto query : queries) {\\n            int x = query[0], a = query[1], ind = query[2];\\n            while (i < n && nums[i] <= a) {\\n                trie.insert(nums[i]);\\n                i++;\\n            }\\n            if (i == 0) result[ind] = -1;\\n            else result[ind] = trie.maxXor(x);\\n        }\\n        return result;\\n    }\\n};\\n```\\nSolution is inspired by approach explained by Striver.",
                "solutionTags": [],
                "code": "```\\nclass Node {\\nprivate:\\n    Node* links[2];\\npublic:\\n    bool contains(int bit) {\\n        return (links[bit] != NULL);\\n    }\\n    void put(int bit, Node* node) {\\n        links[bit] = node;\\n    }\\n    Node* get(int bit) {\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        Node* node = root;\\n        for (int i = 31; i >= 0; --i) {\\n            int bit = (num >> i) & 1;\\n            if (!node->contains(bit)) {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n    int maxXor(int num) {\\n        Node* node = root;\\n        int mx = 0;\\n        for (int i = 31; i >= 0; --i) {\\n            int bit = (num >> i) & 1;\\n            if (node->contains(1-bit)) {\\n                mx = mx | (1 << i);\\n                node = node->get(1-bit);\\n            } else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size(), m = queries.size();\\n        Trie trie;\\n        vector<int> result(m, 0);\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(), queries.end(), [](vector<int> &lhs, vector<int> &rhs) {\\n            return lhs[1] < rhs[1];\\n        });\\n        int i = 0;\\n        for (auto query : queries) {\\n            int x = query[0], a = query[1], ind = query[2];\\n            while (i < n && nums[i] <= a) {\\n                trie.insert(nums[i]);\\n                i++;\\n            }\\n            if (i == 0) result[ind] = -1;\\n            else result[ind] = trie.maxXor(x);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888613,
                "title": "c-trie-clean-and-concise",
                "content": "**Prerequisite :  https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/**\\n```\\nclass Node\\n{\\n  public :\\n    Node *links[2];\\n    \\n    bool containsKey(int bit)\\n    {\\n        return links[bit]!=NULL;\\n    }\\n    Node *get(int bit)\\n    {\\n        return links[bit];\\n    }\\n    void put(int bit,Node *node)\\n    {\\n        links[bit]=node;\\n    }\\n};\\n\\nclass Trie\\n{\\n    public:\\n    Node *root;\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node *temp=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(!temp->containsKey(bit))\\n            {\\n                temp->put(bit,new Node());\\n                \\n            }\\n            temp=temp->get(bit);\\n            \\n        }\\n    }\\n    int getMaxVal(int num)\\n    {\\n         Node *temp=root;\\n        int maxVal=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            int opposite=1-bit;\\n            if(!temp->containsKey(opposite))\\n            {\\n                temp=temp->get(bit);\\n                \\n            }\\n            else\\n            {\\n                maxVal|=(1<<i);\\n                temp=temp->get(opposite);\\n            }\\n           \\n            \\n        }\\n        \\n        return maxVal;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        \\n        \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<queries.size();i++)\\n            queries[i].push_back(i);\\n        \\n        sort(queries.begin(),queries.end(),[&](vector<int>&a,vector<int>&b){\\n            return a[1]<b[1];\\n        });\\n        \\n        // for(auto i:queries)\\n        // {\\n        //     cout<<i[0]<<\" \"<<i[1]<<\" \"<<i[2]<<endl;\\n        // }\\n        int n=nums.size();\\n        int idx=0;\\n        Trie trie;\\n        int q=queries.size();\\n        vector<int>ans(q,0);\\n        for(auto i:queries)\\n        {\\n            while(idx<n and nums[idx]<=i[1])\\n            {\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n            if(idx==0)\\n            {\\n                ans[i[2]]=-1;\\n            }\\n            else\\n                ans[i[2]]=trie.getMaxVal(i[0]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Tree",
                    "Trie"
                ],
                "code": "```\\nclass Node\\n{\\n  public :\\n    Node *links[2];\\n    \\n    bool containsKey(int bit)\\n    {\\n        return links[bit]!=NULL;\\n    }\\n    Node *get(int bit)\\n    {\\n        return links[bit];\\n    }\\n    void put(int bit,Node *node)\\n    {\\n        links[bit]=node;\\n    }\\n};\\n\\nclass Trie\\n{\\n    public:\\n    Node *root;\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node *temp=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(!temp->containsKey(bit))\\n            {\\n                temp->put(bit,new Node());\\n                \\n            }\\n            temp=temp->get(bit);\\n            \\n        }\\n    }\\n    int getMaxVal(int num)\\n    {\\n         Node *temp=root;\\n        int maxVal=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            int opposite=1-bit;\\n            if(!temp->containsKey(opposite))\\n            {\\n                temp=temp->get(bit);\\n                \\n            }\\n            else\\n            {\\n                maxVal|=(1<<i);\\n                temp=temp->get(opposite);\\n            }\\n           \\n            \\n        }\\n        \\n        return maxVal;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        \\n        \\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<queries.size();i++)\\n            queries[i].push_back(i);\\n        \\n        sort(queries.begin(),queries.end(),[&](vector<int>&a,vector<int>&b){\\n            return a[1]<b[1];\\n        });\\n        \\n        // for(auto i:queries)\\n        // {\\n        //     cout<<i[0]<<\" \"<<i[1]<<\" \"<<i[2]<<endl;\\n        // }\\n        int n=nums.size();\\n        int idx=0;\\n        Trie trie;\\n        int q=queries.size();\\n        vector<int>ans(q,0);\\n        for(auto i:queries)\\n        {\\n            while(idx<n and nums[idx]<=i[1])\\n            {\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n            if(idx==0)\\n            {\\n                ans[i[2]]=-1;\\n            }\\n            else\\n                ans[i[2]]=trie.getMaxVal(i[0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1764614,
                "title": "c-trie-sorting-easy-to-understand",
                "content": "```\\nclass Node{\\n    public:\\n    Node* links[2];\\n    Node(){\\n        links[0] = NULL;\\n        links[1] = NULL;\\n    }\\n    bool isKey(int bit){\\n        return links[bit]!=NULL;\\n    }\\n    void putKey(int bit,Node* node){\\n        links[bit] = node;\\n    }\\n    Node* nextNode(int bit){\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\n    private:\\n    Node* root;\\n    public:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void buildTrie(int n){\\n        Node* node = root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (n>>i)&1;\\n            if(!node->isKey(bit)){\\n                node->putKey(bit,new Node());\\n            }node = node->nextNode(bit);\\n        }\\n    }\\n    int getXor(int n){\\n        int XorVal = 0;\\n        Node* node = root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (n>>i)&1;\\n            if(node->isKey(bit^1)){\\n                XorVal = XorVal|(1<<i);\\n                node = node->nextNode(bit^1);\\n            }else if(node->isKey(bit)){\\n                node = node->nextNode(bit);\\n            }else{\\n                return -1;\\n            }\\n        }return XorVal;\\n    }\\n};\\nclass store{\\n    public: \\n    int xi ;\\n    int mi ;\\n    int idx;\\n};\\nclass Solution {\\npublic:\\n    static bool comp(store v1,store v2){\\n        return v1.mi<v2.mi;\\n    }\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<pair<int,int>> res;\\n        Trie t;\\n        vector<store> qu;\\n        for(int i=0;i<queries.size();i++){\\n            qu.push_back({queries[i][0],queries[i][1],i});\\n        } \\n        sort(qu.begin(),qu.end(),comp);\\n        sort(nums.begin(),nums.end());\\n        int idx = 0;\\n        for(int i=0;i<nums.size()&&idx<qu.size();i++){\\n            while(idx<qu.size()&&nums[i]>qu[idx].mi){\\n                int XorVal = t.getXor(qu[idx].xi);\\n                res.push_back({XorVal,qu[idx].idx});\\n                idx++;\\n            }t.buildTrie(nums[i]);\\n        }\\n        while(idx<qu.size()){\\n            int XorVal = t.getXor(qu[idx].xi);\\n            res.push_back({XorVal,qu[idx].idx});\\n            idx++;\\n        }\\n        vector<int> ret((int)qu.size(),0);\\n        for(auto e:res){\\n            ret[e.second] = e.first;\\n        }return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nclass Node{\\n    public:\\n    Node* links[2];\\n    Node(){\\n        links[0] = NULL;\\n        links[1] = NULL;\\n    }\\n    bool isKey(int bit){\\n        return links[bit]!=NULL;\\n    }\\n    void putKey(int bit,Node* node){\\n        links[bit] = node;\\n    }\\n    Node* nextNode(int bit){\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\n    private:\\n    Node* root;\\n    public:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void buildTrie(int n){\\n        Node* node = root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (n>>i)&1;\\n            if(!node->isKey(bit)){\\n                node->putKey(bit,new Node());\\n            }node = node->nextNode(bit);\\n        }\\n    }\\n    int getXor(int n){\\n        int XorVal = 0;\\n        Node* node = root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (n>>i)&1;\\n            if(node->isKey(bit^1)){\\n                XorVal = XorVal|(1<<i);\\n                node = node->nextNode(bit^1);\\n            }else if(node->isKey(bit)){\\n                node = node->nextNode(bit);\\n            }else{\\n                return -1;\\n            }\\n        }return XorVal;\\n    }\\n};\\nclass store{\\n    public: \\n    int xi ;\\n    int mi ;\\n    int idx;\\n};\\nclass Solution {\\npublic:\\n    static bool comp(store v1,store v2){\\n        return v1.mi<v2.mi;\\n    }\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<pair<int,int>> res;\\n        Trie t;\\n        vector<store> qu;\\n        for(int i=0;i<queries.size();i++){\\n            qu.push_back({queries[i][0],queries[i][1],i});\\n        } \\n        sort(qu.begin(),qu.end(),comp);\\n        sort(nums.begin(),nums.end());\\n        int idx = 0;\\n        for(int i=0;i<nums.size()&&idx<qu.size();i++){\\n            while(idx<qu.size()&&nums[i]>qu[idx].mi){\\n                int XorVal = t.getXor(qu[idx].xi);\\n                res.push_back({XorVal,qu[idx].idx});\\n                idx++;\\n            }t.buildTrie(nums[i]);\\n        }\\n        while(idx<qu.size()){\\n            int XorVal = t.getXor(qu[idx].xi);\\n            res.push_back({XorVal,qu[idx].idx});\\n            idx++;\\n        }\\n        vector<int> ret((int)qu.size(),0);\\n        for(auto e:res){\\n            ret[e.second] = e.first;\\n        }return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762758,
                "title": "rust-trie-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Debug, Clone, Default)]\\nstruct Node {\\n    children: [Option<Box<Node>>; 2],\\n}\\n\\nimpl Node {\\n    pub fn insert(&mut self, n: i32) {\\n        do_insert(self, n, 31);\\n    }\\n}\\n\\nfn do_insert(node: &mut Node, num: i32, bit: u32) {\\n    let b = ((num & (1 << bit)) != 0) as usize;\\n    if node.children[b].is_none() {\\n        node.children[b] = Some(Box::new(Node::default()));\\n    }\\n\\n    if bit > 0 {\\n        do_insert(node.children[b].as_mut().unwrap(), num, bit - 1);\\n    }\\n}\\n\\npub fn maximize_xor(mut nums: Vec<i32>, mut queries: Vec<Vec<i32>>) -> Vec<i32> {\\n    // preserve the original indexes of the queries, because we need them to construct the result\\n    let mut result_indexes = HashMap::new();\\n    for (idx, query) in queries.iter().enumerate() {\\n        result_indexes\\n            .entry((query[0], query[1]))\\n            .or_insert(vec![])\\n            .push(idx);\\n    }\\n\\n    // sort the nums and the queries, in order to be able to partially build the trie\\n    // using only the numbers lower than the current query limit\\n    nums.sort_unstable();\\n    queries.sort_unstable_by(|a, b| a[1].cmp(&b[1]));\\n\\n    let mut result = vec![0; queries.len()];\\n    let mut trie = Node::default();\\n\\n    // we have inserted all numbers with a lesser index into the trie \\n    let mut next_idx = 0;\\n    \\n    // There are duplicate queries, so remember the last one in order to avoid \\n    // recomputing the duplicates. We remember the last one, because they are sorted\\n    let mut last_query = None;\\n    \\n    for query in queries.iter() {\\n        // check if we have already processed this query and skip it if we did\\n        if Some(query) == last_query {\\n            continue;\\n        }\\n        last_query = Some(query);\\n\\n        let val = query[0]; // the number to XOR with \\n        let lim = query[1]; // do not xor with numbers greater than this\\n\\n        // add all numbers less than `val` into the trie\\n        for idx in next_idx..nums.len() {\\n            let n = nums[idx];\\n            if n > lim {\\n                break;\\n            }\\n\\n            trie.insert(n);\\n            next_idx = idx + 1;\\n        }\\n\\n        // If next_idx is 0, then we do not have any values in the trie, \\n        // which means that the result is -1. Otherwise, compute the result\\n        let mut xored = -1;\\n        if next_idx != 0 {\\n            let mut node = &trie;\\n            xored = 0;\\n\\n            // find the maximum XOR value\\n            for bit in (0..32).rev() {\\n                let is_set = (val & (1 << bit)) != 0;\\n                // If the current bit is 1, then we need to look for 0 and vice-versa\\n                match &node.children[(is_set ^ true) as usize] {\\n                    None => {\\n                        // There is no node with value `(is_set ^ true) as usize` (i.e. the inverted value),\\n                        // which means that there must be a node with value `is_set as usize`\\n                        node = node.children[is_set as usize].as_ref().unwrap();\\n                    }\\n\\n                    Some(child) => {\\n                        // the XOR of the current bit index is 1\\n                        xored |= 1 << bit;\\n                        node = child;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // There might be duplicate queries, so update all positions\\n        for &idx in result_indexes.get(&(val, lim)).unwrap() {\\n            result[idx] = xored;\\n        }\\n    }\\n\\n    result\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Trie"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\n#[derive(Debug, Clone, Default)]\\nstruct Node {\\n    children: [Option<Box<Node>>; 2],\\n}\\n\\nimpl Node {\\n    pub fn insert(&mut self, n: i32) {\\n        do_insert(self, n, 31);\\n    }\\n}\\n\\nfn do_insert(node: &mut Node, num: i32, bit: u32) {\\n    let b = ((num & (1 << bit)) != 0) as usize;\\n    if node.children[b].is_none() {\\n        node.children[b] = Some(Box::new(Node::default()));\\n    }\\n\\n    if bit > 0 {\\n        do_insert(node.children[b].as_mut().unwrap(), num, bit - 1);\\n    }\\n}\\n\\npub fn maximize_xor(mut nums: Vec<i32>, mut queries: Vec<Vec<i32>>) -> Vec<i32> {\\n    // preserve the original indexes of the queries, because we need them to construct the result\\n    let mut result_indexes = HashMap::new();\\n    for (idx, query) in queries.iter().enumerate() {\\n        result_indexes\\n            .entry((query[0], query[1]))\\n            .or_insert(vec![])\\n            .push(idx);\\n    }\\n\\n    // sort the nums and the queries, in order to be able to partially build the trie\\n    // using only the numbers lower than the current query limit\\n    nums.sort_unstable();\\n    queries.sort_unstable_by(|a, b| a[1].cmp(&b[1]));\\n\\n    let mut result = vec![0; queries.len()];\\n    let mut trie = Node::default();\\n\\n    // we have inserted all numbers with a lesser index into the trie \\n    let mut next_idx = 0;\\n    \\n    // There are duplicate queries, so remember the last one in order to avoid \\n    // recomputing the duplicates. We remember the last one, because they are sorted\\n    let mut last_query = None;\\n    \\n    for query in queries.iter() {\\n        // check if we have already processed this query and skip it if we did\\n        if Some(query) == last_query {\\n            continue;\\n        }\\n        last_query = Some(query);\\n\\n        let val = query[0]; // the number to XOR with \\n        let lim = query[1]; // do not xor with numbers greater than this\\n\\n        // add all numbers less than `val` into the trie\\n        for idx in next_idx..nums.len() {\\n            let n = nums[idx];\\n            if n > lim {\\n                break;\\n            }\\n\\n            trie.insert(n);\\n            next_idx = idx + 1;\\n        }\\n\\n        // If next_idx is 0, then we do not have any values in the trie, \\n        // which means that the result is -1. Otherwise, compute the result\\n        let mut xored = -1;\\n        if next_idx != 0 {\\n            let mut node = &trie;\\n            xored = 0;\\n\\n            // find the maximum XOR value\\n            for bit in (0..32).rev() {\\n                let is_set = (val & (1 << bit)) != 0;\\n                // If the current bit is 1, then we need to look for 0 and vice-versa\\n                match &node.children[(is_set ^ true) as usize] {\\n                    None => {\\n                        // There is no node with value `(is_set ^ true) as usize` (i.e. the inverted value),\\n                        // which means that there must be a node with value `is_set as usize`\\n                        node = node.children[is_set as usize].as_ref().unwrap();\\n                    }\\n\\n                    Some(child) => {\\n                        // the XOR of the current bit index is 1\\n                        xored |= 1 << bit;\\n                        node = child;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // There might be duplicate queries, so update all positions\\n        for &idx in result_indexes.get(&(val, lim)).unwrap() {\\n            result[idx] = xored;\\n        }\\n    }\\n\\n    result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1742700,
                "title": "simple-trie-solution",
                "content": "**UPVOTE IF U LIKE**\\n\\nclass Node\\n{\\npublic:\\n\\n    Node* list[2];\\n\\n    bool containsKey(int i)\\n    {\\n        return list[i] != NULL;\\n    }\\n\\n    void put(int i , Node* node)\\n    {\\n        list[i] = node;\\n    }\\n\\n    Node* get(int i)\\n    {\\n        return  list[i];\\n    }\\n};\\n\\nclass Trie\\n{\\npublic:\\n\\n    Node* root;\\n\\n    Trie()\\n    {\\n        root = new Node();\\n    }\\n\\n    void insert(int num)\\n    {\\n        Node* node = root;\\n\\n        for(int i=31 ; i>=0 ; i--)\\n        {\\n            int bit = (num>>i) & 1;\\n\\n            if(!node->containsKey(bit)) node->put(bit , new Node());\\n\\n            node = node->get(bit);\\n        }\\n    }\\n\\n    int maxNum(int num)\\n    {\\n        Node* node = root;\\n        int maxXor = 0;\\n\\n        for(int i=31 ; i>=0 ; i--)\\n        {\\n            int bit = (num>>i) & 1;\\n\\n            if(node->containsKey(!bit))\\n            {\\n                maxXor = maxXor | 1<<i;\\n                node = node->get(!bit);\\n            }\\n            else node = node->get(bit);\\n        }\\n\\n        return maxXor;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        \\n       Trie t;\\n       int n = queries.size();\\n       vector<int> ans(n);\\n       vector<vector<int>> oQ;\\n        \\n       for(int i=0 ; i<n ; i++)\\n       {\\n           oQ.push_back({queries[i][1] , queries[i][0] , i});\\n       }\\n        \\n       sort(oQ.begin() , oQ.end());\\n       sort(nums.begin() , nums.end());\\n        \\n       for(int i=0 , j=0 ; i<n ; i++)\\n       {\\n           int limit = oQ[i][0];\\n           int num   = oQ[i][1];\\n           int index = oQ[i][2];\\n           int maxi = -1;\\n           \\n           while(j<nums.size() and nums[j] <= limit)\\n           {\\n               t.insert(nums[j]);\\n               j++;\\n           }\\n           \\n           if(j>0) maxi = t.maxNum(num);\\n           \\n           ans[index] = maxi;\\n           \\n       }\\n        \\n        return ans;\\n      \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        \\n       Trie t;\\n       int n = queries.size();\\n       vector<int> ans(n);\\n       vector<vector<int>> oQ;\\n        \\n       for(int i=0 ; i<n ; i++)\\n       {\\n           oQ.push_back({queries[i][1] , queries[i][0] , i}",
                "codeTag": "Java"
            },
            {
                "id": 1724048,
                "title": "java-solution-using-tree-trie-sort-and-bitmanipulation-beats-96",
                "content": "Please check https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/ to know  how  to use bit-maniputation and Trie to calculate the maximum XOR in `O(n)`.\\n\\nThis code uses the same approch in addition to sorting the input.\\n\\nIf `n` is the number of `nums` and  `m` is the number of `queries`\\nRuntime complexity: `O(m log(m)) + O(n log(n)) + O(m * n)`\\nSpace complexity: `O(m)`\\n\\n```\\nclass Solution {\\n    class QueryComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return Integer.compare(a[1], b[1]);\\n        }\\n    }\\n    \\n    class Node {\\n        Node zero;\\n        Node one;\\n        \\n        public Node() {\\n            this.zero = null;\\n            this.one = null;\\n        }\\n    }\\n    \\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        \\n        int len = queries.length;\\n        int[][] queryWithIndex = new int[len][3];\\n        for(int i = 0; i < len; i++) {\\n            queryWithIndex[i][0] = queries[i][0];\\n            queryWithIndex[i][1] = queries[i][1];\\n            queryWithIndex[i][2] = i;\\n        }\\n        Arrays.sort(queryWithIndex, new QueryComparator());\\n        \\n        int numId = 0;\\n        int[] ans = new int[len];\\n        \\n        Node root = new Node();\\n        for(int i = 0; i < len; i++) {\\n            while(numId < nums.length && nums[numId] <= queryWithIndex[i][1]) {\\n                addNumToTree(nums[numId], root);\\n                numId++;\\n            }\\n            \\n            ans[queryWithIndex[i][2]] = maxXOR(queryWithIndex[i][0], root);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void addNumToTree(int num, Node node) {\\n        for(int i = 31; i >= 0; i--) {\\n            int digit = (num >> i) & 1;\\n            if (digit == 1) {\\n                if (node.one == null) {\\n                    node.one = new Node();\\n                }\\n                node = node.one;\\n            } else {\\n                if (node.zero == null) {\\n                    node.zero = new Node();\\n                }\\n                node = node.zero;\\n            }\\n        }\\n    }\\n    \\n    private int maxXOR(int num, Node node) {\\n        if (node.one == null && node.zero == null) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n        for(int i = 31; i >= 0 && node != null; i--) {\\n            int digit = (num >> i) & 1;\\n            if (digit == 1) {\\n                if (node.zero != null) {\\n                    ans += (1 << i);\\n                    node = node.zero;\\n                } else {\\n                    node = node.one;\\n                }\\n            } else {\\n                if (node.one != null) {\\n                    ans += (1 << i);\\n                    node = node.one;\\n                } else {\\n                    node = node.zero;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    class QueryComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return Integer.compare(a[1], b[1]);\\n        }\\n    }\\n    \\n    class Node {\\n        Node zero;\\n        Node one;\\n        \\n        public Node() {\\n            this.zero = null;\\n            this.one = null;\\n        }\\n    }\\n    \\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        \\n        int len = queries.length;\\n        int[][] queryWithIndex = new int[len][3];\\n        for(int i = 0; i < len; i++) {\\n            queryWithIndex[i][0] = queries[i][0];\\n            queryWithIndex[i][1] = queries[i][1];\\n            queryWithIndex[i][2] = i;\\n        }\\n        Arrays.sort(queryWithIndex, new QueryComparator());\\n        \\n        int numId = 0;\\n        int[] ans = new int[len];\\n        \\n        Node root = new Node();\\n        for(int i = 0; i < len; i++) {\\n            while(numId < nums.length && nums[numId] <= queryWithIndex[i][1]) {\\n                addNumToTree(nums[numId], root);\\n                numId++;\\n            }\\n            \\n            ans[queryWithIndex[i][2]] = maxXOR(queryWithIndex[i][0], root);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void addNumToTree(int num, Node node) {\\n        for(int i = 31; i >= 0; i--) {\\n            int digit = (num >> i) & 1;\\n            if (digit == 1) {\\n                if (node.one == null) {\\n                    node.one = new Node();\\n                }\\n                node = node.one;\\n            } else {\\n                if (node.zero == null) {\\n                    node.zero = new Node();\\n                }\\n                node = node.zero;\\n            }\\n        }\\n    }\\n    \\n    private int maxXOR(int num, Node node) {\\n        if (node.one == null && node.zero == null) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n        for(int i = 31; i >= 0 && node != null; i--) {\\n            int digit = (num >> i) & 1;\\n            if (digit == 1) {\\n                if (node.zero != null) {\\n                    ans += (1 << i);\\n                    node = node.zero;\\n                } else {\\n                    node = node.one;\\n                }\\n            } else {\\n                if (node.one != null) {\\n                    ans += (1 << i);\\n                    node = node.one;\\n                } else {\\n                    node = node.zero;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670013,
                "title": "cpp-trie-bit-manipulation-explained",
                "content": "\\nPrereq - [Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)\\n\\nExplanation - If you understood the prereq than the only difference here is, we will not insert all the numbers before hand into the trie but will only insert those numbers which are less the query and to achieve this we will sort both the nums array and the query array. \\n\\n```\\nstruct Node{\\n    \\n    Node* links[2];\\n    \\n    bool contains(int bit){\\n        return links[bit] != NULL;\\n    }\\n    \\n    Node* put(int bit){\\n        Node* node = new Node();\\n        return links[bit] = node;\\n    }\\n    \\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie{\\n    Node* root;\\npublic:\\n    \\n    Trie(){\\n        root = new Node();\\n    }\\n    \\n    void insert(int num){\\n        Node* node = root;\\n        \\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(!node->contains(bit)){\\n                node = node->put(bit);\\n            }\\n            else{\\n                node = node->get(bit);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    int maxXOR(int num){\\n        Node* node = root;\\n        int res = 0;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(node->contains(!bit)){\\n                res |= 1<<i;\\n                node = node->get(!bit);\\n            }\\n            else{\\n                node = node->get(bit);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n        \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<pair<int, int>> vec;\\n        \\n        for(int i=0;i<q.size();i++){\\n            vec.push_back({q[i][1], i});\\n        }\\n        sort(vec.begin(), vec.end());\\n        \\n        vector<int> res(q.size());\\n        \\n        int k = 0;\\n        \\n        Trie t;\\n        \\n        for(int i=0;i<vec.size();i++){\\n            \\n            while(k<nums.size() && nums[k] <= vec[i].first){\\n                t.insert(nums[k]);\\n                k++;\\n            }\\n            \\n            int idx = vec[i].second;\\n            \\n            if(k==0){\\n                res[idx] = -1;\\n            }\\n            else{\\n                res[idx] = t.maxXOR(q[idx][0]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    \\n    Node* links[2];\\n    \\n    bool contains(int bit){\\n        return links[bit] != NULL;\\n    }\\n    \\n    Node* put(int bit){\\n        Node* node = new Node();\\n        return links[bit] = node;\\n    }\\n    \\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie{\\n    Node* root;\\npublic:\\n    \\n    Trie(){\\n        root = new Node();\\n    }\\n    \\n    void insert(int num){\\n        Node* node = root;\\n        \\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(!node->contains(bit)){\\n                node = node->put(bit);\\n            }\\n            else{\\n                node = node->get(bit);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    int maxXOR(int num){\\n        Node* node = root;\\n        int res = 0;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(node->contains(!bit)){\\n                res |= 1<<i;\\n                node = node->get(!bit);\\n            }\\n            else{\\n                node = node->get(bit);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n        \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<pair<int, int>> vec;\\n        \\n        for(int i=0;i<q.size();i++){\\n            vec.push_back({q[i][1], i});\\n        }\\n        sort(vec.begin(), vec.end());\\n        \\n        vector<int> res(q.size());\\n        \\n        int k = 0;\\n        \\n        Trie t;\\n        \\n        for(int i=0;i<vec.size();i++){\\n            \\n            while(k<nums.size() && nums[k] <= vec[i].first){\\n                t.insert(nums[k]);\\n                k++;\\n            }\\n            \\n            int idx = vec[i].second;\\n            \\n            if(k==0){\\n                res[idx] = -1;\\n            }\\n            else{\\n                res[idx] = t.maxXOR(q[idx][0]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491333,
                "title": "simple-trie-based-solution-well-explained",
                "content": "```\\nclass Solution {\\npublic:\\n        \\nclass trie{\\n    public:\\n    trie* arr[2];\\n    int value;\\n    trie()\\n    {\\n        arr[0]=NULL;\\n        arr[1]=NULL;\\n        value=0;\\n    }\\n};\\n    \\ntrie *root=new trie();\\n    \\nvoid insert(int value) //it is simple insertion of 32 bit number in trie\\n{\\n    trie *cur=root;\\n    for(int bit=31;bit>=0;bit--)\\n    {\\n        bool bitval=value&(1<<bit);\\n        if(cur->arr[bitval]==NULL)\\n        {\\n            trie *t=new trie();\\n            cur->arr[bitval]=t;\\n        }\\n       cur=cur->arr[bitval];\\n    }\\n    cur->value=value;   // here we are storing the value in last node\\n}\\n    \\n\\n//that is to simply finding the max value of value xor number which is  <= m                                    \\nint findmax(int value)\\n{\\n    trie *cur=root;\\n    for(int bit=31;bit>=0;bit--) // number\\'s current bit is 0 then we move to 1 and vice-versa to get max value\\n    {\\n        bool bitval=value&(1<<bit);\\n        if(cur->arr[!bitval]!=NULL)\\n        {\\n            cur=cur->arr[!bitval];\\n        }\\n        else if(cur->arr[bitval]!=NULL)\\n        {\\n            cur=cur->arr[bitval];\\n        }\\n        else\\n            return -1;\\n       \\n    }\\n    return value^cur->value;\\n   }\\n\\n    \\n    \\n    static bool comp(vector<int> &v1,vector<int> &v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n      vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n      vector<vector<int>> query=queries;\\n      vector<int> ans(query.size());  \\n        for(int i=0;i<query.size();i++)\\n        {\\n            query[i].push_back(i); // simply inserting query number so that we can put in order in ans as we are sorting the array\\n        }\\n        sort(arr.begin(),arr.end());\\n        sort(query.begin(),query.end(),comp);\\n        int i=0;\\n        \\n        for(auto v:query)\\n        {\\n            int x=v[1];\\n            while(i<arr.size() && arr[i]<=x){\\n                insert(arr[i]);\\n                i++;\\n            }\\n              \\n            ans[v[2]]=findmax(v[0]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nif you find it helpful please upvote.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n        \\nclass trie{\\n    public:\\n    trie* arr[2];\\n    int value;\\n    trie()\\n    {\\n        arr[0]=NULL;\\n        arr[1]=NULL;\\n        value=0;\\n    }\\n};\\n    \\ntrie *root=new trie();\\n    \\nvoid insert(int value) //it is simple insertion of 32 bit number in trie\\n{\\n    trie *cur=root;\\n    for(int bit=31;bit>=0;bit--)\\n    {\\n        bool bitval=value&(1<<bit);\\n        if(cur->arr[bitval]==NULL)\\n        {\\n            trie *t=new trie();\\n            cur->arr[bitval]=t;\\n        }\\n       cur=cur->arr[bitval];\\n    }\\n    cur->value=value;   // here we are storing the value in last node\\n}\\n    \\n\\n//that is to simply finding the max value of value xor number which is  <= m                                    \\nint findmax(int value)\\n{\\n    trie *cur=root;\\n    for(int bit=31;bit>=0;bit--) // number\\'s current bit is 0 then we move to 1 and vice-versa to get max value\\n    {\\n        bool bitval=value&(1<<bit);\\n        if(cur->arr[!bitval]!=NULL)\\n        {\\n            cur=cur->arr[!bitval];\\n        }\\n        else if(cur->arr[bitval]!=NULL)\\n        {\\n            cur=cur->arr[bitval];\\n        }\\n        else\\n            return -1;\\n       \\n    }\\n    return value^cur->value;\\n   }\\n\\n    \\n    \\n    static bool comp(vector<int> &v1,vector<int> &v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n      vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n      vector<vector<int>> query=queries;\\n      vector<int> ans(query.size());  \\n        for(int i=0;i<query.size();i++)\\n        {\\n            query[i].push_back(i); // simply inserting query number so that we can put in order in ans as we are sorting the array\\n        }\\n        sort(arr.begin(),arr.end());\\n        sort(query.begin(),query.end(),comp);\\n        int i=0;\\n        \\n        for(auto v:query)\\n        {\\n            int x=v[1];\\n            while(i<arr.size() && arr[i]<=x){\\n                insert(arr[i]);\\n                i++;\\n            }\\n              \\n            ans[v[2]]=findmax(v[0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401660,
                "title": "c-trie",
                "content": "```\\n\\n```public:\\n    struct trie\\n    {\\n       trie *child[2]={0};  \\n    };\\n    trie *root=new trie();\\n    int solve(int num)\\n    {\\n        int j;\\n       trie *curr=root;\\n            long long int sum=0;\\n            for(j=31;j>=0;j--)\\n            {\\n                int bit=num&(1<<j);\\n                if(bit)\\n                {\\n                    bit=1;\\n                }\\n                if(curr->child[!bit])\\n                {\\n                    sum=sum+(1<<j);\\n                    curr=curr->child[!bit];\\n                }\\n                else\\n                {\\n                    curr=curr->child[bit];\\n                }\\n            }\\n            return sum;\\n    }\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<pair<int,int>>v;\\n        sort(nums.begin(),nums.end());\\n        vector<int>res(queries.size(),0);\\n        int i,j;\\n        for(i=0;i<queries.size();i++)\\n        {\\n            v.push_back({queries[i][1],i});\\n        }\\n        sort(v.begin(),v.end());\\n        int k=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            while(1)\\n            {\\n            if(k<v.size()&&nums[0]>v[k].first)\\n              {\\n                res[v[k].second]=-1;\\n                k++;\\n              }\\n            else if(k<v.size()&&nums[i]>v[k].first)\\n               {\\n                int ans=solve(queries[v[k].second][0]);\\n                res[v[k].second]=ans;\\n                k++;\\n               }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            trie *curr=root;\\n            for(j=31;j>=0;j--)\\n            {\\n                int bit=nums[i]&(1<<j);\\n                if(bit)\\n                {\\n                    bit=1;\\n                }\\n                if(!curr->child[bit])\\n                {\\n                   curr->child[bit]=new trie();   \\n                }\\n                curr=curr->child[bit];\\n            }\\n        }\\n        while(k<v.size())\\n        {\\n            if(k<v.size()&&nums[0]>v[k].first)\\n            {\\n                res[v[k].second]=-1;\\n                k++;\\n            }\\n            else\\n            {\\n                int ans=solve(queries[v[k].second][0]);\\n                res[v[k].second]=ans;\\n                k++;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1357040,
                "title": "analysis-explanation-on-why-sort-solution-w-o-trie-is-the-fastest-one-and-ideal-for-this-problem",
                "content": "I tried the Trie solution and was stumped as to why I was getting TLE in the last test case (67th).\\nAlthough complexity wise that solution  should pass through, it might not for practical language limitations and test machine\\'s performance variations. Giving my explanation below.\\n\\n**Important aspect to note:** The max length of the array is 10^5 and the max value of each element can be 10^9.\\n\\n**Drawback of Trie for this question**\\nIf we were to create a Trie in any order with or without sorting the array or the queries, we would still have to make a worst case number of operations to the tune of 10^5 * log_2(10^9) = 10^5 * **30** i.e. the max depth of the Trie. The same goes for searching for the max xor element within the trie for a possible 10^5 times depth (usually most questions guarantee a total of near  10^5 for both array and query or across the test cases for array lengths).\\n\\n**Advantage of sort and binary search solution**: Please refer to solution given [here ](https://leetcode.com/problems/maximum-xor-with-an-element-from-array/discuss/989454/Python-14-lines-or-2144-ms) by Stefan.\\nThe max length of array is 10^5 and so nlogn would run iterations to the tune of 10^5 * log_2(10^5) = 10^5 * **17** . Now this 17 to 30 might not seem much of a  difference, but given the variables of test machine performance and language overheads etc, it would be ideal if we keep the solution to run anywhere near 20 * 10^5 to be safe.\\n\\nObservations on test machine run time for same code: program runs anywhere between 5s to 9.3s for the last test case, when combined with other 66 test cases it will mostly go to TLE in the submission, and in general as well.\\n\\nMy Trie solution without sort which goes to TLE (similar to Votrubac\\'s soln)-\\nI timed it with timer and could see that just the insertion for 10^5 elements was enough in the last TC to push run time to 6-9s.\\n```\\n\\nimport time\\nglobal maxbits\\nmaxbits=30\\nclass TrieNode:\\n    def __init__(self):\\n        self.children=[None, None]\\n    def insert(self, n):\\n        bi = bin(n)[2:].zfill(maxbits)\\n        curChildren=self.children\\n        for i in bi:\\n            bit=int(i)\\n            if curChildren[bit] is None:\\n                curChildren[bit] = TrieNode()\\n            curChildren = curChildren[bit].children\\n        \\n    def findMax(self, node, search_bits, limit, i, res ):\\n\\t\\tif res>limit : return -1\\n        if i<0: return res\\n        bit=bool(int(search_bits[maxbits-1-i]))\\n        if node.children[0] is None:\\n            return self.findMax(node.children[1], search_bits, limit, i-1, res+(1<<i))\\n        if node.children[1] is None:\\n            return self.findMax(node.children[0], search_bits, limit, i-1, res+(0<<i))\\n        new_res = self.findMax(node.children[not bit], search_bits, limit, i-1, res+((not bit)<<i))\\n        if new_res <0:\\n            new_res = self.findMax(node.children[bit],search_bits, limit, i-1, res+(bit<<i))\\n        return new_res\\n    \\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        root = TrieNode()\\n        ma=0\\n        for i in nums:\\n            ma=max(ma, i)\\n        for i in queries:\\n            ma=max(ma,i[0],i[1])\\n        global maxbits\\n        maxbits=ceil(math.log2(ma)) #or ma.bit_length()\\n        for i in nums:\\n            indst=time.time()\\n            root.insert(i)\\n            tot+=(round(time.time()-indst,2))\\n        res = []\\n        for q in queries:\\n            second = bin(q[0])[2:].zfill(maxbits)\\n            ans = root.findMax(root, second, q[1], maxbits-1, 0)\\n            if ans>=0:\\n                res.append(ans^q[0])\\n            else: res.append(-1)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nimport time\\nglobal maxbits\\nmaxbits=30\\nclass TrieNode:\\n    def __init__(self):\\n        self.children=[None, None]\\n    def insert(self, n):\\n        bi = bin(n)[2:].zfill(maxbits)\\n        curChildren=self.children\\n        for i in bi:\\n            bit=int(i)\\n            if curChildren[bit] is None:\\n                curChildren[bit] = TrieNode()\\n            curChildren = curChildren[bit].children\\n        \\n    def findMax(self, node, search_bits, limit, i, res ):\\n\\t\\tif res>limit : return -1\\n        if i<0: return res\\n        bit=bool(int(search_bits[maxbits-1-i]))\\n        if node.children[0] is None:\\n            return self.findMax(node.children[1], search_bits, limit, i-1, res+(1<<i))\\n        if node.children[1] is None:\\n            return self.findMax(node.children[0], search_bits, limit, i-1, res+(0<<i))\\n        new_res = self.findMax(node.children[not bit], search_bits, limit, i-1, res+((not bit)<<i))\\n        if new_res <0:\\n            new_res = self.findMax(node.children[bit],search_bits, limit, i-1, res+(bit<<i))\\n        return new_res\\n    \\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        root = TrieNode()\\n        ma=0\\n        for i in nums:\\n            ma=max(ma, i)\\n        for i in queries:\\n            ma=max(ma,i[0],i[1])\\n        global maxbits\\n        maxbits=ceil(math.log2(ma)) #or ma.bit_length()\\n        for i in nums:\\n            indst=time.time()\\n            root.insert(i)\\n            tot+=(round(time.time()-indst,2))\\n        res = []\\n        for q in queries:\\n            second = bin(q[0])[2:].zfill(maxbits)\\n            ans = root.findMax(root, second, q[1], maxbits-1, 0)\\n            if ans>=0:\\n                res.append(ans^q[0])\\n            else: res.append(-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352109,
                "title": "java-trie",
                "content": "```\\nclass Solution {\\n    public class TrieNode{\\n        TrieNode children[];\\n        TrieNode(){\\n            children = new TrieNode[2];\\n        }\\n    }\\n    \\n    TrieNode root;\\n    \\n    public void insert(int val){\\n        TrieNode curr = root;\\n        \\n        int bitIdx = 31;\\n        \\n        while(bitIdx-->= 0){\\n            int mask = (1<<bitIdx);\\n            int bit = (val&mask) == 0 ? 0 : 1;\\n            \\n            TrieNode node = curr.children[bit];\\n            if(node == null){\\n                node = new TrieNode();\\n                curr.children[bit]= node;\\n            }\\n            \\n            curr = node;\\n        }\\n    }\\n    \\n    public int find(int val){\\n        if(root.children == null) return -1;\\n        TrieNode curr = root;\\n        \\n        int bitIdx = 31;\\n        int res = 0;\\n        \\n        while(bitIdx-->= 0){\\n            int mask = (1<<bitIdx); \\n            int bit = (val&mask) == 0 ? 0 : 1;\\n            \\n            TrieNode node = curr.children[bit];\\n            if(bit == 0){\\n                if(node == null) {\\n                    node = curr.children[1];\\n                    res |= mask;\\n                }\\n            }else{\\n                if(node == null){\\n                    node = curr.children[0];\\n                }else{\\n                    res |= mask;\\n                }\\n            }\\n            curr = node;\\n        }\\n        return res;\\n    }\\n    \\n    \\n    public int[] maximizeXor(int[] nums, int[][] q) {\\n        root = new TrieNode();\\n        \\n        Arrays.sort(nums);\\n        \\n        ArrayList<int[]> qr = new ArrayList<>();\\n        for(int i = 0; i<q.length; i++){\\n            qr.add(new int[]{q[i][0], q[i][1], i});\\n        }\\n        \\n        Collections.sort(qr, (a,b) -> a[1] - b[1]);\\n        \\n        int idx = 0;\\n        int ans[] = new int[qr.size()];\\n        boolean flag = false;\\n        for(int i = 0; i<qr.size(); i++){\\n            while(idx < nums.length && nums[idx] <= qr.get(i)[1]){\\n                insert(nums[idx++]);\\n                flag = true;\\n            }\\n            if(flag == false){\\n                ans[qr.get(i)[2]] = -1;\\n                continue;\\n            }\\n            int comp = Integer.MAX_VALUE ^ qr.get(i)[0];\\n            int res = find(comp);\\n            ans[qr.get(i)[2]] = (res ^ qr.get(i)[0]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public class TrieNode{\\n        TrieNode children[];\\n        TrieNode(){\\n            children = new TrieNode[2];\\n        }\\n    }\\n    \\n    TrieNode root;\\n    \\n    public void insert(int val){\\n        TrieNode curr = root;\\n        \\n        int bitIdx = 31;\\n        \\n        while(bitIdx-->= 0){\\n            int mask = (1<<bitIdx);\\n            int bit = (val&mask) == 0 ? 0 : 1;\\n            \\n            TrieNode node = curr.children[bit];\\n            if(node == null){\\n                node = new TrieNode();\\n                curr.children[bit]= node;\\n            }\\n            \\n            curr = node;\\n        }\\n    }\\n    \\n    public int find(int val){\\n        if(root.children == null) return -1;\\n        TrieNode curr = root;\\n        \\n        int bitIdx = 31;\\n        int res = 0;\\n        \\n        while(bitIdx-->= 0){\\n            int mask = (1<<bitIdx); \\n            int bit = (val&mask) == 0 ? 0 : 1;\\n            \\n            TrieNode node = curr.children[bit];\\n            if(bit == 0){\\n                if(node == null) {\\n                    node = curr.children[1];\\n                    res |= mask;\\n                }\\n            }else{\\n                if(node == null){\\n                    node = curr.children[0];\\n                }else{\\n                    res |= mask;\\n                }\\n            }\\n            curr = node;\\n        }\\n        return res;\\n    }\\n    \\n    \\n    public int[] maximizeXor(int[] nums, int[][] q) {\\n        root = new TrieNode();\\n        \\n        Arrays.sort(nums);\\n        \\n        ArrayList<int[]> qr = new ArrayList<>();\\n        for(int i = 0; i<q.length; i++){\\n            qr.add(new int[]{q[i][0], q[i][1], i});\\n        }\\n        \\n        Collections.sort(qr, (a,b) -> a[1] - b[1]);\\n        \\n        int idx = 0;\\n        int ans[] = new int[qr.size()];\\n        boolean flag = false;\\n        for(int i = 0; i<qr.size(); i++){\\n            while(idx < nums.length && nums[idx] <= qr.get(i)[1]){\\n                insert(nums[idx++]);\\n                flag = true;\\n            }\\n            if(flag == false){\\n                ans[qr.get(i)[2]] = -1;\\n                continue;\\n            }\\n            int comp = Integer.MAX_VALUE ^ qr.get(i)[0];\\n            int res = find(comp);\\n            ans[qr.get(i)[2]] = (res ^ qr.get(i)[0]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120421,
                "title": "why-this-trie-solution-without-sorting-is-slower-than-the-one-with-sorting",
                "content": "In the worst case, I think we have to insert all the elements into the Trie tree anyway.\\nAnd for each query matching, we should compare 31 times for each bit. Then why the solution using sorting is still faster?\\n```\\nclass Solution {\\n    private static class Node {\\n        int min;\\n        Node[] children;\\n\\n        public Node(int minValue) {\\n            min = minValue;\\n            children = new Node[2];\\n        }\\n    }\\n\\n    private Node trie = new Node(Integer.MAX_VALUE);\\n\\n    private void insert(int num) {\\n        Node node = trie;\\n        node.min = Math.min(node.min, num);\\n\\n        for (int i = 30; i >= 0; i--) {\\n            int bit = (num >>> i) & 1;\\n            if (node.children[bit] == null) {\\n                node.children[bit] = new Node(num);\\n            }\\n\\n            node = node.children[bit];\\n            node.min = Math.min(node.min, num);\\n        }\\n    }\\n\\n    private int query(int x, int m) {\\n        if (trie.min > m) {\\n            return -1;\\n        }\\n\\n        Node node = trie;\\n        int res = 0;\\n        for (int i = 30; i >= 0; i--) {\\n            int xBit = (x >>> i) & 1;\\n            int oppositeBit = xBit ^ 1;\\n            int setBit = xBit;\\n            if (node.children[oppositeBit] != null && node.children[oppositeBit].min <= m) {\\n                setBit = oppositeBit;\\n            }\\n\\n            node = node.children[setBit];\\n            res = res | ((setBit ^ xBit) << i);\\n        }\\n        return res;\\n    }\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        for (int num : nums) {\\n            insert(num);\\n        }\\n\\n        int[] ans = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            ans[i] = query(queries[i][0], queries[i][1]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static class Node {\\n        int min;\\n        Node[] children;\\n\\n        public Node(int minValue) {\\n            min = minValue;\\n            children = new Node[2];\\n        }\\n    }\\n\\n    private Node trie = new Node(Integer.MAX_VALUE);\\n\\n    private void insert(int num) {\\n        Node node = trie;\\n        node.min = Math.min(node.min, num);\\n\\n        for (int i = 30; i >= 0; i--) {\\n            int bit = (num >>> i) & 1;\\n            if (node.children[bit] == null) {\\n                node.children[bit] = new Node(num);\\n            }\\n\\n            node = node.children[bit];\\n            node.min = Math.min(node.min, num);\\n        }\\n    }\\n\\n    private int query(int x, int m) {\\n        if (trie.min > m) {\\n            return -1;\\n        }\\n\\n        Node node = trie;\\n        int res = 0;\\n        for (int i = 30; i >= 0; i--) {\\n            int xBit = (x >>> i) & 1;\\n            int oppositeBit = xBit ^ 1;\\n            int setBit = xBit;\\n            if (node.children[oppositeBit] != null && node.children[oppositeBit].min <= m) {\\n                setBit = oppositeBit;\\n            }\\n\\n            node = node.children[setBit];\\n            res = res | ((setBit ^ xBit) << i);\\n        }\\n        return res;\\n    }\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        for (int num : nums) {\\n            insert(num);\\n        }\\n\\n        int[] ans = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            ans[i] = query(queries[i][0], queries[i][1]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023487,
                "title": "simple-and-easy-to-understand-with-comments",
                "content": "Sort the nums array \\nsort the queries array\\none by one add the values of nums array which are smaller than m for corresponding query\\nNow find the maximum xor for that x using trie\\n\\nNote:Before doing this question you can try this one https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/ here you find the maximum xor of two elements.After completing this question, It will be easier to solve this question as well\\n```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        struct TrieNode* child[2];\\n        TrieNode(){\\n            for(int i=0;i<2;++i){\\n                child[i]=NULL;\\n            }\\n        }\\n    };\\n    void insert(int x,TrieNode* root){\\n        for(int i=31;i>=0;i--){\\n            int val=(x>>i)&1;\\n            if(root->child[val]==NULL){\\n                root->child[val]=new TrieNode;\\n            }\\n            root=root->child[val];\\n        }\\n    }\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        for(int i=0;i<queries.size();++i){   \\n            queries[i].push_back(i);        //To preserve the order of query\\n        }\\n        sort(queries.begin(),queries.end(),[](vector<int>& a,vector<int>& b){ return a[1]<b[1];}); //Here I sorted the queries array so that only those values from num array are stored which are less than m[i]\\n\\t\\t\\n        sort(nums.begin(),nums.end());  //for the same reason nums are sorted\\n        int n=nums.size();\\n        TrieNode* root=new TrieNode;\\n        int idx=0;\\n        vector<int> ans(queries.size());\\n        for(vector<int>& query:queries){\\n            while(idx<n && nums[idx]<=query[1]){\\n                insert(nums[idx++],root);    //insert the particular node untill the values of node is less than m[i]\\n            }\\n            TrieNode* head=root;\\n            if(idx==0){   //It means no m is lesser than all values of nums array\\n                ans[query[2]]=-1;\\n                continue;\\n            }\\n            int curr=0;   //ans for the current query\\n            for(int i=31;i>=0;i--){\\n                int val=(query[0]>>i)&1;\\n                if(head->child[!val]!=NULL){   //To get the maximum value for xor\\'s we are finding !val. If particular bit of x[i] is 1 then for maximum xor the corresponding bit should be 0\\n                    head=head->child[!val];   \\n                    curr|=(1<<i);  \\n                }\\n                else{\\n                    head=head->child[val];\\n                }\\n            }\\n            ans[query[2]]=curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        struct TrieNode* child[2];\\n        TrieNode(){\\n            for(int i=0;i<2;++i){\\n                child[i]=NULL;\\n            }\\n        }\\n    };\\n    void insert(int x,TrieNode* root){\\n        for(int i=31;i>=0;i--){\\n            int val=(x>>i)&1;\\n            if(root->child[val]==NULL){\\n                root->child[val]=new TrieNode;\\n            }\\n            root=root->child[val];\\n        }\\n    }\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        for(int i=0;i<queries.size();++i){   \\n            queries[i].push_back(i);        //To preserve the order of query\\n        }\\n        sort(queries.begin(),queries.end(),[](vector<int>& a,vector<int>& b){ return a[1]<b[1];}); //Here I sorted the queries array so that only those values from num array are stored which are less than m[i]\\n\\t\\t\\n        sort(nums.begin(),nums.end());  //for the same reason nums are sorted\\n        int n=nums.size();\\n        TrieNode* root=new TrieNode;\\n        int idx=0;\\n        vector<int> ans(queries.size());\\n        for(vector<int>& query:queries){\\n            while(idx<n && nums[idx]<=query[1]){\\n                insert(nums[idx++],root);    //insert the particular node untill the values of node is less than m[i]\\n            }\\n            TrieNode* head=root;\\n            if(idx==0){   //It means no m is lesser than all values of nums array\\n                ans[query[2]]=-1;\\n                continue;\\n            }\\n            int curr=0;   //ans for the current query\\n            for(int i=31;i>=0;i--){\\n                int val=(query[0]>>i)&1;\\n                if(head->child[!val]!=NULL){   //To get the maximum value for xor\\'s we are finding !val. If particular bit of x[i] is 1 then for maximum xor the corresponding bit should be 0\\n                    head=head->child[!val];   \\n                    curr|=(1<<i);  \\n                }\\n                else{\\n                    head=head->child[val];\\n                }\\n            }\\n            ans[query[2]]=curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014548,
                "title": "java-trie-binary-tree-straight-forward",
                "content": "```\\nclass Solution {\\n     class TrieNode {\\n        TrieNode left, right;\\n        public TrieNode() {\\n            left = null;\\n            right = null;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(TrieNode root, int num) {\\n        TrieNode curr = root;\\n        \\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num>>i) & 1;\\n            if(bit == 0) {\\n                if(curr.left == null) {\\n                    curr.left = new TrieNode();\\n                }\\n                curr = curr.left;\\n            } else {\\n                if(curr.right == null) {\\n                    curr.right = new TrieNode(); \\n                }\\n                curr = curr.right;\\n            }\\n        }\\n    }\\n    \\n    public int getMaxXor(TrieNode root, int num) {\\n        TrieNode curr = root;\\n        int maxXor = 0;\\n        \\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num>>i) & 1;\\n            if(bit == 0) {\\n                if(curr.right != null) {\\n                    curr =  curr.right;\\n                    maxXor += (1<<i);\\n                } else {\\n                    curr = curr.left;\\n                }\\n            } else {\\n                if(curr.left != null) {\\n                    curr = curr.left;\\n                    maxXor += (1<<i);\\n                } else {\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        \\n        return maxXor;\\n    }\\n    \\n    //Given method\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        TrieNode root = new TrieNode();\\n        int[] result = new int[queries.length];\\n        int[][] query = new int[queries.length][3];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            query[i][0] = queries[i][0];\\n            query[i][1] = queries[i][1];\\n            query[i][2] = i;\\n        }\\n        \\n        Arrays.sort(nums);\\n        Arrays.sort(query, (a,b)->(a[1]-b[1]));\\n        int index = 0; \\n        for(int i = 0; i < query.length; i++) {\\n            while(index < nums.length && nums[index] <= query[i][1]) {\\n                insert(root, nums[index]);\\n                index++;\\n            }\\n            \\n            if(nums[0] > query[i][1]) {\\n                result[query[i][2]] = -1;\\n            } else {\\n                result[query[i][2]] = getMaxXor(root, query[i][0]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n     class TrieNode {\\n        TrieNode left, right;\\n        public TrieNode() {\\n            left = null;\\n            right = null;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(TrieNode root, int num) {\\n        TrieNode curr = root;\\n        \\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num>>i) & 1;\\n            if(bit == 0) {\\n                if(curr.left == null) {\\n                    curr.left = new TrieNode();\\n                }\\n                curr = curr.left;\\n            } else {\\n                if(curr.right == null) {\\n                    curr.right = new TrieNode(); \\n                }\\n                curr = curr.right;\\n            }\\n        }\\n    }\\n    \\n    public int getMaxXor(TrieNode root, int num) {\\n        TrieNode curr = root;\\n        int maxXor = 0;\\n        \\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num>>i) & 1;\\n            if(bit == 0) {\\n                if(curr.right != null) {\\n                    curr =  curr.right;\\n                    maxXor += (1<<i);\\n                } else {\\n                    curr = curr.left;\\n                }\\n            } else {\\n                if(curr.left != null) {\\n                    curr = curr.left;\\n                    maxXor += (1<<i);\\n                } else {\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        \\n        return maxXor;\\n    }\\n    \\n    //Given method\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        TrieNode root = new TrieNode();\\n        int[] result = new int[queries.length];\\n        int[][] query = new int[queries.length][3];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            query[i][0] = queries[i][0];\\n            query[i][1] = queries[i][1];\\n            query[i][2] = i;\\n        }\\n        \\n        Arrays.sort(nums);\\n        Arrays.sort(query, (a,b)->(a[1]-b[1]));\\n        int index = 0; \\n        for(int i = 0; i < query.length; i++) {\\n            while(index < nums.length && nums[index] <= query[i][1]) {\\n                insert(root, nums[index]);\\n                index++;\\n            }\\n            \\n            if(nums[0] > query[i][1]) {\\n                result[query[i][2]] = -1;\\n            } else {\\n                result[query[i][2]] = getMaxXor(root, query[i][0]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997203,
                "title": "rust-btreeset-o-q-log-n-with-explanation",
                "content": "```rust\\nimpl Solution {\\n    pub fn maximize_xor(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let vals: std::collections::BTreeSet<_> = nums.into_iter().collect();\\n        let res = |x: i32, m: i32| {\\n            let mut pref = 0;\\n            for i in (0..30).rev() {\\n                let scope = 1 << i;\\n                let bit = (x & scope) ^ scope;\\n                let rbit = bit ^ scope;\\n                let check = |b: i32| {\\n                    let lower = pref + b;\\n\\t\\t\\t\\t\\tlet upper = (lower + scope).min(m + 1);\\n\\t\\t\\t\\t\\treturn upper >= lower && vals.range(lower..upper).next().is_some();\\n                };\\n                pref += if check(bit) { bit } else if check(rbit) { rbit } else { return -1; }\\n            }\\n            pref ^ x\\n        };\\n        queries.into_iter().map(|v| res(v[0], v[1])).collect()\\n    }\\n}\\n```\\nFirst we build a BTreeSet to quickly answer the question : if there are numbers within given range.\\nNext we define a function to get solution for each query \\n```\\nlet res = |x: i32, m: i32| {\\n```\\n\\nFor each number we will go from the most significat digit to the less, and try to answer the question \"should we put 1 here or 0\"\\nVariable `pref` is the current prefix, which will be the resulting number.\\n```rust\\n            let mut pref = 0;\\n            for i in (0..30).rev() {\\n```\\nWe define a variable with the only 1 in the current digit.\\n```rust\\n                let scope = 1 << i;\\n```\\nNext we \\n`x & scope` will be non-zero if the current focused digit of the `x` is 1 and 0 otherwise.\\nOur priority to get `1` in this position in the `xor` result, so we targeted to the inversion of this.\\n```rust\\n                let bit = (x & scope) ^ scope;\\n```\\nOur second choice is the inversion of this we can write `bit ^ scope` or `x & scope` , these are the same numbers\\n```rust\\n                let rbit = bit ^ scope;\\n```\\nSo, for each of these two, we must check if there are some numbers in the given set, that ^\\n* have the current prefix\\n* have the given digit on the i-th position \\n* not more than `m`\\n\\nSo lower bound of our interval is \\n```rust\\n                    let lower = pref + b;\\n```\\nAnd upper non-inclusive bound is smallert of `lower + scope` and `m + 1`\\n```rust\\n\\t\\t\\t\\t\\tlet upper = (lower + scope).min(m + 1);\\n```\\nNext we must check if our interval is non-empty and we have any numbers in the given interval, thankfully we have `.range` method of `BTreeSet` that return an iterator of numbers in the given range, so we just checking that iterator is non-empty\\n```rust\\n\\t\\t\\t\\t\\treturn upper >= lower && vals.range(lower..upper).next().is_some();\\n```\\nNow we choose between `bit` and `rbit` (preferring `bit`) as  the next addition to our `pref` and if none of them is good, we return `-1` immediately\\n```rust\\n                pref += if check(bit) { bit } else if check(rbit) { rbit } else { return -1; }\\n```\\nFinal `pref` is the searched value, so we return it\\'s `xor` with `x`\\n```rust\\n        pref ^ x\\n```\\nCalling `res` function for each query as the result\\n```\\n    queries.into_iter().map(|v| res(v[0], v[1])).collect()\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn maximize_xor(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let vals: std::collections::BTreeSet<_> = nums.into_iter().collect();\\n        let res = |x: i32, m: i32| {\\n            let mut pref = 0;\\n            for i in (0..30).rev() {\\n                let scope = 1 << i;\\n                let bit = (x & scope) ^ scope;\\n                let rbit = bit ^ scope;\\n                let check = |b: i32| {\\n                    let lower = pref + b;\\n\\t\\t\\t\\t\\tlet upper = (lower + scope).min(m + 1);\\n\\t\\t\\t\\t\\treturn upper >= lower && vals.range(lower..upper).next().is_some();\\n                };\\n                pref += if check(bit) { bit } else if check(rbit) { rbit } else { return -1; }\\n            }\\n            pref ^ x\\n        };\\n        queries.into_iter().map(|v| res(v[0], v[1])).collect()\\n    }\\n}\\n```\n```\\nlet res = |x: i32, m: i32| {\\n```\n```rust\\n            let mut pref = 0;\\n            for i in (0..30).rev() {\\n```\n```rust\\n                let scope = 1 << i;\\n```\n```rust\\n                let bit = (x & scope) ^ scope;\\n```\n```rust\\n                let rbit = bit ^ scope;\\n```\n```rust\\n                    let lower = pref + b;\\n```\n```rust\\n\\t\\t\\t\\t\\tlet upper = (lower + scope).min(m + 1);\\n```\n```rust\\n\\t\\t\\t\\t\\treturn upper >= lower && vals.range(lower..upper).next().is_some();\\n```\n```rust\\n                pref += if check(bit) { bit } else if check(rbit) { rbit } else { return -1; }\\n```\n```rust\\n        pref ^ x\\n```\n```\\n    queries.into_iter().map(|v| res(v[0], v[1])).collect()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 990035,
                "title": "python-augmented-trie-online-queries",
                "content": "INTRODUCTION\\n\\nThis solves the problem in an online fashion. Solving the problem online means that our code can actually be decomposed into two parts -\\nthe first part is computing all the information we need to be able to efficiently answer a query, and the second part is answering the queries efficiently using only the computed information. It is frequently the case that problems are much easier offline than online. Credit to xiaowuc for the language of this paragraph: I\\'ve paraphrased from an article he wrote elsewhere.\\n\\nOUTLINE OF APPROACH\\n\\nWe refactor `nums` as `a`. We put all the values from `a` into a trie, and we augment each trie node with the smallest element in the subtree rooted at that node. Here\\'s a diagram of the augmented trie for `a = [0, 1, 2, 3, 4]`:\\n\\n![image](https://assets.leetcode.com/users/images/963ab410-1e75-4511-ba86-c2a0d1f0b051_1609130593.3313665.png)\\n\\nNow, let\\'s consider some query `(x, max_limit)`. When we search the Trie, we want to find the value `y` that maximizes `x ^ y` subject to the constraint that `y <= max_limit`. Intuitively, we want to always select a `y` with a different bit at most significant position.\\n\\nIf there are no numbers in the trie which are less than `max_limit` then `-1` is the result for the query.\\nOtherwise, we have at least one number in our Trie that meets our constraints.\\n\\nTo find the best `y`, we consider the `jth` bit, starting with the MSB and iterating down to LSB. For example, we start with `j = 31` and examine the 31st bit of `x`.\\n\\nLet `bit` be the value the `jth` bit of `x`\\nWe prefer to select some `y` such that `x ^ y` has a one at the `jth` bit\\nIf `bit` is zero, then we prefer to xor with a one\\nIf `bit` is one, then we prefer to xor with a zero\\n\\nTherefore, for the `jth` bit, we have a \"preferred branch\" in our Trie which is strictly better than the \"other branch\". We look ahead at our \"preferred branch\". If the \"preferred branch\" leads to a subtree containing some minimum value less than `max_limit` then we take the \"preferred branch\". Otherwise, we must take the \"other branch\".\\n\\nIn the code below, when we search, we know there is at least one number in the trie which is less than `max_limit`, so we will always find a result.\\n\\n```\\nclass Node:\\n    \\n    __slots__ = (\\'kid\\', \\'val\\', \\'min\\')\\n\\n    def __init__(self):\\n        self.kid = [None, None]\\n        self.val = None\\n        self.min = math.inf\\n\\n    def insert(self, x):\\n        node = self\\n\\n        for j in range(31, -1, -1):\\n            bit = x >> j & 1\\n            if node.kid[bit] is None:\\n                node.kid[bit] = Node()\\n            node = node.kid[bit]\\n            node.min = min(node.min, x)\\n\\n        node.val = x\\n\\n    def search(self, x, max_limit):\\n        node = self\\n        for j in range(31, -1, -1):\\n            bit = x >> j & 1\\n            pref = 1 ^ bit\\n            if node.kid[pref] is not None and node.kid[pref].min <= max_limit:\\n                node = node.kid[pref]\\n            else:\\n                node = node.kid[bit]\\n\\n        return node.val\\n\\n\\nclass Solution:\\n\\n    def maximizeXor(self, a: List[int], queries: List[List[int]]) -> List[int]:\\n        res = []\\n        min_a = min(a)\\n        root = Node()\\n\\n        for x in set(a):\\n            root.insert(x)\\n\\n        for x, m in queries:\\n            if m < min_a:\\n                res.append(-1)\\n            else:\\n                y = root.search(x, m)\\n                res.append(x ^ y)\\n\\n        return res\\n\\n```\\n\\nEdit: Modified this approach to use [__slots__](https://docs.python.org/3/reference/datamodel.html#slots) so it does not TLE with latest tests and time constraints. Thanks @infomount for the heads-up. If anyone else finds this code not passing time limits, please \"@\" me, and I\\'ll put a version further optimized for speed at the expense of readability.\\n",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    \\n    __slots__ = (\\'kid\\', \\'val\\', \\'min\\')\\n\\n    def __init__(self):\\n        self.kid = [None, None]\\n        self.val = None\\n        self.min = math.inf\\n\\n    def insert(self, x):\\n        node = self\\n\\n        for j in range(31, -1, -1):\\n            bit = x >> j & 1\\n            if node.kid[bit] is None:\\n                node.kid[bit] = Node()\\n            node = node.kid[bit]\\n            node.min = min(node.min, x)\\n\\n        node.val = x\\n\\n    def search(self, x, max_limit):\\n        node = self\\n        for j in range(31, -1, -1):\\n            bit = x >> j & 1\\n            pref = 1 ^ bit\\n            if node.kid[pref] is not None and node.kid[pref].min <= max_limit:\\n                node = node.kid[pref]\\n            else:\\n                node = node.kid[bit]\\n\\n        return node.val\\n\\n\\nclass Solution:\\n\\n    def maximizeXor(self, a: List[int], queries: List[List[int]]) -> List[int]:\\n        res = []\\n        min_a = min(a)\\n        root = Node()\\n\\n        for x in set(a):\\n            root.insert(x)\\n\\n        for x, m in queries:\\n            if m < min_a:\\n                res.append(-1)\\n            else:\\n                y = root.search(x, m)\\n                res.append(x ^ y)\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988374,
                "title": "simple-trie-python",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        \\n        trie = defaultdict(dict)\\n        nums.sort()\\n        queries = [query+[i] for i, query in enumerate (queries)]\\n        queries.sort(key = lambda x: x[1])\\n        curr = 0\\n        \\n        \\n        def add_to_trie (nums): \\n            for num in nums: \\n                curr = trie\\n                for i in range (31,-1, -1):\\n                    bit = int(num & (1 << i) != 0)\\n                    if bit not in curr: \\n                        curr[bit] = {}\\n                    curr = curr[bit]\\n                curr[-1] = num\\n        \\n        def search_trie (x):\\n            curr = trie\\n            for i in range (31, -1, -1):\\n                bit = int(x & (1 << i) == 0)\\n                if bit not in curr: \\n                    curr = curr[not(bit)]\\n                else: \\n                    curr = curr[bit]\\n            \\n            return curr[-1] ^ x\\n        \\n            \\n        out= [-1]*len(queries)\\n        \\n        for query in queries: \\n            x, y, o_ind = query\\n            ind = bisect.bisect_right(nums, y)\\n            add_to_trie(nums[curr:ind])\\n            if ind != 0: \\n                curr_ans = search_trie(x)\\n            else: \\n                curr_ans = -1\\n            out[o_ind] = curr_ans\\n            curr = ind\\n        \\n        return out\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        \\n        trie = defaultdict(dict)\\n        nums.sort()\\n        queries = [query+[i] for i, query in enumerate (queries)]\\n        queries.sort(key = lambda x: x[1])\\n        curr = 0\\n        \\n        \\n        def add_to_trie (nums): \\n            for num in nums: \\n                curr = trie\\n                for i in range (31,-1, -1):\\n                    bit = int(num & (1 << i) != 0)\\n                    if bit not in curr: \\n                        curr[bit] = {}",
                "codeTag": "Java"
            },
            {
                "id": 988341,
                "title": "python-trie-o-n-time-and-o-n-space-no-sorting",
                "content": "We can avoid the sorting used in other solutions by tracking the minimum value at each node of the trie.\\n\\nWe load all elements of `nums` into our trie initially. Note that querying into the trie is independent of the number of elements in the trie and only depends on the depth of the trie. While loading elements into our trie at every node, we also track the minimum value that is a child of the node. \\nAfter creating the trie, we can greedily find the optimal element of `nums` to XOR with `x` bit by bit.\\n\\n**Complexity**:\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\n```\\nclass Solution:\\n    def trie(self, nums):\\n        t = dict()\\n        for num in nums:\\n            self.addtrie(num, t) \\n        return t\\n            \\n    def addtrie(self, num, t):\\n        for i in range(31, -1, -1):\\n            if (1<<i) & num:\\n                if 1 in t:\\n                    t[1][1] = min(t[1][1], num)\\n                else:\\n                    t[1] = [dict(), num]\\n                t = t[1][0]\\n            else:\\n                if 0 in t:\\n                    t[0][1] = min(t[0][1], num)\\n                else:\\n                    t[0] = [dict(), num]\\n                t = t[0][0]\\n        return\\n    \\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        root = self.trie(nums)\\n        \\n        for x, m in queries:\\n            val = 0\\n            t = root\\n            for i in range(31, -1, -1):\\n                if (1<<i) & x:\\n                    if 0 in t:\\n                        t = t[0][0]\\n                    elif 1 in t and t[1][1] <= m:\\n                        val |= (1<<i)\\n                        t = t[1][0]\\n                    else:\\n                        val = -1\\n                        break\\n                else:\\n                    if 1 in t and t[1][1] <= m:\\n                        val |= (1<<i)\\n                        t = t[1][0]\\n                    elif 0 in t:\\n                        t = t[0][0]\\n                    else:\\n                        val = -1\\n                        break\\n            if val < 0:\\n                ans.append(-1)\\n            else:\\n                ans.append(val^x)\\n            \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def trie(self, nums):\\n        t = dict()\\n        for num in nums:\\n            self.addtrie(num, t) \\n        return t\\n            \\n    def addtrie(self, num, t):\\n        for i in range(31, -1, -1):\\n            if (1<<i) & num:\\n                if 1 in t:\\n                    t[1][1] = min(t[1][1], num)\\n                else:\\n                    t[1] = [dict(), num]\\n                t = t[1][0]\\n            else:\\n                if 0 in t:\\n                    t[0][1] = min(t[0][1], num)\\n                else:\\n                    t[0] = [dict(), num]\\n                t = t[0][0]\\n        return\\n    \\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        root = self.trie(nums)\\n        \\n        for x, m in queries:\\n            val = 0\\n            t = root\\n            for i in range(31, -1, -1):\\n                if (1<<i) & x:\\n                    if 0 in t:\\n                        t = t[0][0]\\n                    elif 1 in t and t[1][1] <= m:\\n                        val |= (1<<i)\\n                        t = t[1][0]\\n                    else:\\n                        val = -1\\n                        break\\n                else:\\n                    if 1 in t and t[1][1] <= m:\\n                        val |= (1<<i)\\n                        t = t[1][0]\\n                    elif 0 in t:\\n                        t = t[0][0]\\n                    else:\\n                        val = -1\\n                        break\\n            if val < 0:\\n                ans.append(-1)\\n            else:\\n                ans.append(val^x)\\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 988325,
                "title": "c-trie-with-comments-and-explanation",
                "content": "First, we build a trie of `nums`. For each query `(xi, mi)`, we traverse the tree to find the largest branch that is within the limit of `mi`. To avoid going into a branch that contains no answer, we can store a `min` field at each trie node denoting the smallest number inserted under the sub-trie rooted at this node, and if `min` is larger than `mi`, than the branch is definitely not the way to go. \\n\\nThe runtime is O(N*32).\\n\\n```\\nconstexpr int B = 31;\\nstruct Node {\\n    int min;\\n    int ch[2];\\n    \\n    Node& init() {\\n        min = 1e9+7;\\n        ch[0] = ch[1] = -1;\\n        return *this;\\n    }\\n};\\nNode nodes[35*100000+1024];\\nint ni;\\n\\nvoid insert(Node& node, int bi, int num) {\\n    node.min = min(node.min, num);\\n    if (bi == -1) return;\\n    const int b = (num & (1<<bi)) ? 1 : 0;\\n    if (node.ch[b] == -1) {\\n        nodes[ni++].init();\\n        node.ch[b] = ni-1;\\n    }\\n    insert(nodes[node.ch[b]], bi-1, num);\\n}\\n\\nvoid build(const vector<int>& nums) {\\n    nodes[0].init();\\n    ni = 1;\\n    for (const auto x : nums) {\\n        insert(nodes[0], B, x);\\n    }\\n}\\n\\nint search(Node& node, int bi, int x, int m, int p) {\\n    if (p > m) return -1;\\n    if (bi == -1) return x^p;\\n    int pref[] = {1, 0}; // defaults to prefer branch 1 than branch 0.\\n    if (x&(1<<bi)) swap(pref[0], pref[1]); // If current bit is one, prefer 0 than 1.\\n    // Find first valid branch in preference order.\\n    for (const auto ch : pref) {\\n        if (node.ch[ch] == -1) continue;\\n        auto& ch_node = nodes[node.ch[ch]];\\n        if (ch_node.min > m) continue;\\n        return search(ch_node, bi-1, x, m, p+(ch<<bi));\\n    }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        build(nums);\\n        vector<int> ans;\\n        ans.reserve(queries.size());\\n        for (const auto& q: queries) {\\n            ans.push_back(search(nodes[0], B, q[0], q[1], 0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconstexpr int B = 31;\\nstruct Node {\\n    int min;\\n    int ch[2];\\n    \\n    Node& init() {\\n        min = 1e9+7;\\n        ch[0] = ch[1] = -1;\\n        return *this;\\n    }\\n};\\nNode nodes[35*100000+1024];\\nint ni;\\n\\nvoid insert(Node& node, int bi, int num) {\\n    node.min = min(node.min, num);\\n    if (bi == -1) return;\\n    const int b = (num & (1<<bi)) ? 1 : 0;\\n    if (node.ch[b] == -1) {\\n        nodes[ni++].init();\\n        node.ch[b] = ni-1;\\n    }\\n    insert(nodes[node.ch[b]], bi-1, num);\\n}\\n\\nvoid build(const vector<int>& nums) {\\n    nodes[0].init();\\n    ni = 1;\\n    for (const auto x : nums) {\\n        insert(nodes[0], B, x);\\n    }\\n}\\n\\nint search(Node& node, int bi, int x, int m, int p) {\\n    if (p > m) return -1;\\n    if (bi == -1) return x^p;\\n    int pref[] = {1, 0}; // defaults to prefer branch 1 than branch 0.\\n    if (x&(1<<bi)) swap(pref[0], pref[1]); // If current bit is one, prefer 0 than 1.\\n    // Find first valid branch in preference order.\\n    for (const auto ch : pref) {\\n        if (node.ch[ch] == -1) continue;\\n        auto& ch_node = nodes[node.ch[ch]];\\n        if (ch_node.min > m) continue;\\n        return search(ch_node, bi-1, x, m, p+(ch<<bi));\\n    }\\n    return -1;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        build(nums);\\n        vector<int> ans;\\n        ans.reserve(queries.size());\\n        for (const auto& q: queries) {\\n            ans.push_back(search(nodes[0], B, q[0], q[1], 0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988223,
                "title": "fan-out-2-trie-but-not-sure-why-time-out-figured-out-why-constant-factor-matters",
                "content": "```\\nclass Trie {\\npublic:\\n    Trie(): zero(nullptr), one(nullptr) {}\\n    void insert(vector<int>& bin) {\\n        insert_(bin, 0);\\n    }\\n    void insert_(vector<int>& bin, int idx) {\\n        if (idx < bin.size()) {\\n            if (bin[idx] == 0) {\\n                if (zero == nullptr) {\\n                    zero = new Trie();\\n                }\\n                zero->insert_(bin, idx + 1);\\n            } else {\\n                if (one == nullptr) {\\n                    one = new Trie();\\n                }\\n                one->insert_(bin, idx + 1);\\n            }\\n        }\\n    }\\n    int query(vector<int>& bin) {\\n        return query(bin, 0);\\n    }\\n    int query(vector<int>& bin, int idx) {\\n        vector<int> num;\\n        query_(bin, idx, num);\\n        int ans = 0;\\n        for (int i = 0; i < num.size(); ++i) {\\n            ans = 2 * ans + num[i];\\n        }\\n        return ans;\\n    }\\n    void query_(vector<int>& bin, int idx, vector<int>& num) {\\n        if (idx < bin.size()) {\\n            if (bin[idx] == 0) {\\n                if (one) {\\n                    num.emplace_back(1);\\n                    one->query_(bin, idx + 1, num);\\n                } else {\\n                    assert(zero);\\n                    num.emplace_back(0);\\n                    zero->query_(bin, idx + 1, num);\\n                }\\n            } else {\\n                if (zero) {\\n                    num.emplace_back(1);\\n                    zero->query_(bin, idx + 1, num);\\n                } else {\\n                    assert(one);\\n                    num.emplace_back(0);\\n                    one->query_(bin, idx + 1, num);\\n                }\\n            }\\n        }\\n    }\\n    bool empty() const {\\n        return zero == nullptr && one == nullptr;\\n    }\\n\\n    Trie* zero;\\n    Trie* one;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int biggest = 0;\\n        for (int num : nums) {\\n            biggest = max(biggest, num);\\n        }\\n\\n        sort(begin(nums), end(nums));\\n\\n        vector<tuple<int, int, int>> qs;\\n        for (int i = 0; i < queries.size(); ++i) {\\n            auto& query = queries[i];\\n            qs.emplace_back(query[1], query[0], i);\\n            biggest = max(biggest, query[0]);\\n        }\\n        sort(begin(qs), end(qs));\\n\\n        longest = binary(biggest).size();\\n\\n        Trie* trie = new Trie();\\n        vector<int> ans(qs.size(), 0);\\n\\n        int pointer = 0;\\n        for (int i = 0; i < qs.size(); ++i) {\\n            auto [ceil, operand, idx] = qs[i];\\n            for (; pointer < nums.size() && nums[pointer] <= ceil; ++pointer) {\\n                auto bin = binary(nums[pointer]);\\n                trie->insert(bin);\\n            }\\n            if (trie->empty()) {\\n                ans[idx] = -1;\\n            } else {\\n                auto operandBin = binary(operand);\\n                ans[idx] = trie->query(operandBin);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    vector<int> binary(int num) {\\n        vector<int> ans;\\n        while (num) {\\n            ans.emplace_back(num % 2 ? 1 : 0);\\n            num /= 2;\\n        }\\n        while (ans.size() < longest) {\\n            ans.emplace_back(0);\\n        }\\n        return {rbegin(ans), rend(ans)};\\n    }\\n\\n    int longest;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\npublic:\\n    Trie(): zero(nullptr), one(nullptr) {}\\n    void insert(vector<int>& bin) {\\n        insert_(bin, 0);\\n    }\\n    void insert_(vector<int>& bin, int idx) {\\n        if (idx < bin.size()) {\\n            if (bin[idx] == 0) {\\n                if (zero == nullptr) {\\n                    zero = new Trie();\\n                }\\n                zero->insert_(bin, idx + 1);\\n            } else {\\n                if (one == nullptr) {\\n                    one = new Trie();\\n                }\\n                one->insert_(bin, idx + 1);\\n            }\\n        }\\n    }\\n    int query(vector<int>& bin) {\\n        return query(bin, 0);\\n    }\\n    int query(vector<int>& bin, int idx) {\\n        vector<int> num;\\n        query_(bin, idx, num);\\n        int ans = 0;\\n        for (int i = 0; i < num.size(); ++i) {\\n            ans = 2 * ans + num[i];\\n        }\\n        return ans;\\n    }\\n    void query_(vector<int>& bin, int idx, vector<int>& num) {\\n        if (idx < bin.size()) {\\n            if (bin[idx] == 0) {\\n                if (one) {\\n                    num.emplace_back(1);\\n                    one->query_(bin, idx + 1, num);\\n                } else {\\n                    assert(zero);\\n                    num.emplace_back(0);\\n                    zero->query_(bin, idx + 1, num);\\n                }\\n            } else {\\n                if (zero) {\\n                    num.emplace_back(1);\\n                    zero->query_(bin, idx + 1, num);\\n                } else {\\n                    assert(one);\\n                    num.emplace_back(0);\\n                    one->query_(bin, idx + 1, num);\\n                }\\n            }\\n        }\\n    }\\n    bool empty() const {\\n        return zero == nullptr && one == nullptr;\\n    }\\n\\n    Trie* zero;\\n    Trie* one;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int biggest = 0;\\n        for (int num : nums) {\\n            biggest = max(biggest, num);\\n        }\\n\\n        sort(begin(nums), end(nums));\\n\\n        vector<tuple<int, int, int>> qs;\\n        for (int i = 0; i < queries.size(); ++i) {\\n            auto& query = queries[i];\\n            qs.emplace_back(query[1], query[0], i);\\n            biggest = max(biggest, query[0]);\\n        }\\n        sort(begin(qs), end(qs));\\n\\n        longest = binary(biggest).size();\\n\\n        Trie* trie = new Trie();\\n        vector<int> ans(qs.size(), 0);\\n\\n        int pointer = 0;\\n        for (int i = 0; i < qs.size(); ++i) {\\n            auto [ceil, operand, idx] = qs[i];\\n            for (; pointer < nums.size() && nums[pointer] <= ceil; ++pointer) {\\n                auto bin = binary(nums[pointer]);\\n                trie->insert(bin);\\n            }\\n            if (trie->empty()) {\\n                ans[idx] = -1;\\n            } else {\\n                auto operandBin = binary(operand);\\n                ans[idx] = trie->query(operandBin);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    vector<int> binary(int num) {\\n        vector<int> ans;\\n        while (num) {\\n            ans.emplace_back(num % 2 ? 1 : 0);\\n            num /= 2;\\n        }\\n        while (ans.size() < longest) {\\n            ans.emplace_back(0);\\n        }\\n        return {rbegin(ans), rend(ans)};\\n    }\\n\\n    int longest;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988207,
                "title": "java-easy-and-well-explained-solution-using-binary-tree-and-priority-queue",
                "content": "```\\n/*\\n    The basic approach is to sort the nums array and the queries array on the basis of queries[i][1] values. Then we can put the numbers from nums that are smaller than queries[i][1] and then find the maximum xor of queries[i][0] from the tree.\\n\\tTime : O(n log n + q log q). \\n*/\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int q=queries.length,n=nums.length;\\n        int []arr=new int[q];        \\n        \\n        Arrays.sort(nums); \\n        \\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->a[1]<=b[1]?-1:1);\\n        for(int i=0;i<q;i++)\\n            pq.offer(new int[]{queries[i][0],queries[i][1],i}); // storing the index is necessary.\\n        \\n        int j=0;\\n        int []pr;\\n        \\n        Tree root=new Tree(0);\\n        \\n        for(int i=0;i<q;i++){\\n            \\n            pr=pq.poll();\\n            \\n            while(j<n&&nums[j]<=pr[1]){ // inserting the numbers that are smaller.\\n                insert(root,change(nums[j]));\\n                j++;\\n            }\\n            \\n            if(j==0) // if all the numbers of nums are larger.\\n                arr[pr[2]]=-1;\\n            else\\n                arr[pr[2]]=(int)(find(root,change(pr[0]),(long)(1l<<31))); // finding the maximum xor.\\n        }\\n        return arr;\\n    }\\n    \\n    // change the number to a binary string of 32 characters.\\n    public String change(int val){\\n        StringBuilder sbr=new StringBuilder();\\n        while(val>0){\\n            sbr.append(val&1);\\n            val>>=1;            \\n        }\\n        int l=sbr.length();\\n        while(l<32){\\n            sbr.append(0);\\n            l++;\\n        }\\n        return sbr.reverse().toString();\\n    }\\n    \\n    // insert the number, in the form of binary string, into the binary tree.\\n    public void insert(Tree node, String num){\\n        Tree root=node;\\n        int i=0;\\n        while(i<num.length()){\\n            if(num.charAt(i)==\\'1\\'){\\n                if(root.right==null)\\n                    root.right=new Tree(1);\\n                root=root.right;\\n            }\\n            else{\\n                if(root.left==null)\\n                    root.left=new Tree(0);\\n                root=root.left;\\n            }\\n            i++;\\n        }        \\n    }\\n    \\n    // find the highest xor of the given number with the numbers already present in the tree.\\n    public long find(Tree node, String num, long p){\\n        Tree root=node;\\n        int i=0;\\n        long ans=0l;\\n        while(i<num.length()){\\n            if(num.charAt(i)==\\'0\\'){\\n                if(root.right!=null){\\n                    root=root.right;\\n                    ans+=p;\\n                }\\n                else\\n                    root=root.left;\\n            }\\n            else{\\n                if(root.left!=null){\\n                    root=root.left;\\n                    ans+=p;\\n                }\\n                else\\n                    root=root.right;\\n            }\\n            i++;\\n            p>>=1;\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass Tree{\\n    int val;\\n    Tree left,right;\\n    Tree(int v){\\n        val=v;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    The basic approach is to sort the nums array and the queries array on the basis of queries[i][1] values. Then we can put the numbers from nums that are smaller than queries[i][1] and then find the maximum xor of queries[i][0] from the tree.\\n\\tTime : O(n log n + q log q). \\n*/\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int q=queries.length,n=nums.length;\\n        int []arr=new int[q];        \\n        \\n        Arrays.sort(nums); \\n        \\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->a[1]<=b[1]?-1:1);\\n        for(int i=0;i<q;i++)\\n            pq.offer(new int[]{queries[i][0],queries[i][1],i}); // storing the index is necessary.\\n        \\n        int j=0;\\n        int []pr;\\n        \\n        Tree root=new Tree(0);\\n        \\n        for(int i=0;i<q;i++){\\n            \\n            pr=pq.poll();\\n            \\n            while(j<n&&nums[j]<=pr[1]){ // inserting the numbers that are smaller.\\n                insert(root,change(nums[j]));\\n                j++;\\n            }\\n            \\n            if(j==0) // if all the numbers of nums are larger.\\n                arr[pr[2]]=-1;\\n            else\\n                arr[pr[2]]=(int)(find(root,change(pr[0]),(long)(1l<<31))); // finding the maximum xor.\\n        }\\n        return arr;\\n    }\\n    \\n    // change the number to a binary string of 32 characters.\\n    public String change(int val){\\n        StringBuilder sbr=new StringBuilder();\\n        while(val>0){\\n            sbr.append(val&1);\\n            val>>=1;            \\n        }\\n        int l=sbr.length();\\n        while(l<32){\\n            sbr.append(0);\\n            l++;\\n        }\\n        return sbr.reverse().toString();\\n    }\\n    \\n    // insert the number, in the form of binary string, into the binary tree.\\n    public void insert(Tree node, String num){\\n        Tree root=node;\\n        int i=0;\\n        while(i<num.length()){\\n            if(num.charAt(i)==\\'1\\'){\\n                if(root.right==null)\\n                    root.right=new Tree(1);\\n                root=root.right;\\n            }\\n            else{\\n                if(root.left==null)\\n                    root.left=new Tree(0);\\n                root=root.left;\\n            }\\n            i++;\\n        }        \\n    }\\n    \\n    // find the highest xor of the given number with the numbers already present in the tree.\\n    public long find(Tree node, String num, long p){\\n        Tree root=node;\\n        int i=0;\\n        long ans=0l;\\n        while(i<num.length()){\\n            if(num.charAt(i)==\\'0\\'){\\n                if(root.right!=null){\\n                    root=root.right;\\n                    ans+=p;\\n                }\\n                else\\n                    root=root.left;\\n            }\\n            else{\\n                if(root.left!=null){\\n                    root=root.left;\\n                    ans+=p;\\n                }\\n                else\\n                    root=root.right;\\n            }\\n            i++;\\n            p>>=1;\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass Tree{\\n    int val;\\n    Tree left,right;\\n    Tree(int v){\\n        val=v;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988152,
                "title": "simple-c-o-n-greedy-solution-with-trie",
                "content": "Approach: try move to nodes with opposite value of i-th bit (track min value of each node to detect movement is possible)\\n\\n```\\n    public class Solution\\n    {\\n        private const int MAX_BIT_INDEX = 29;\\n\\n        public class TrieNode\\n        {\\n            public readonly TrieNode[] Next = new TrieNode[2];\\n            public int Min = int.MaxValue;\\n        }\\n\\n        public class Trie\\n        {\\n            public TrieNode Root = new TrieNode();\\n\\n\\n            public void AddValue(int val)\\n            {\\n                TrieNode node = Root;\\n                for (int idx = MAX_BIT_INDEX; idx >= 0; idx--)\\n                {\\n                    int bit = (val >> idx) & 1;\\n                    node.Next[bit] = node.Next[bit] ?? new TrieNode();\\n                    node.Min = Math.Min(node.Min, val);\\n                    node = node.Next[bit];\\n                }\\n                node.Min = Math.Min(node.Min, val);\\n            }\\n\\n\\n            public int Search(int x, int max)\\n            {\\n                TrieNode node = Root;\\n                int res = 0;\\n                for (int idx = MAX_BIT_INDEX; idx >= 0; idx--)\\n                {\\n                    int xBit = (x >> idx) & 1;\\n                    int opposite = xBit ^ 1;\\n\\n                    if (node.Next[opposite] == null || node.Next[opposite].Min > max)\\n                    {\\n                        if (node.Next[xBit] == null || node.Next[xBit].Min > max)\\n                        {\\n                            res = -1;\\n                            return res;\\n                        }\\n                        else\\n                        {\\n                            node = node.Next[xBit];\\n                        }\\n                    }\\n                    else\\n                    {\\n                        res |= 1 << idx;\\n                        node = node.Next[opposite];\\n                    }\\n\\n                }\\n\\n                return res;\\n            }\\n\\n        }\\n\\n        public int[] MaximizeXor(int[] nums, int[][] queries)\\n        {\\n            Trie t = new Trie();\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                t.AddValue(nums[i]);\\n            }\\n\\n            int[] res = new int[queries.Length];\\n\\n            for (int i = 0; i < queries.Length; i++)\\n            {\\n                res[i] = t.Search(queries[i][0], queries[i][1]);\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private const int MAX_BIT_INDEX = 29;\\n\\n        public class TrieNode\\n        {\\n            public readonly TrieNode[] Next = new TrieNode[2];\\n            public int Min = int.MaxValue;\\n        }\\n\\n        public class Trie\\n        {\\n            public TrieNode Root = new TrieNode();\\n\\n\\n            public void AddValue(int val)\\n            {\\n                TrieNode node = Root;\\n                for (int idx = MAX_BIT_INDEX; idx >= 0; idx--)\\n                {\\n                    int bit = (val >> idx) & 1;\\n                    node.Next[bit] = node.Next[bit] ?? new TrieNode();\\n                    node.Min = Math.Min(node.Min, val);\\n                    node = node.Next[bit];\\n                }\\n                node.Min = Math.Min(node.Min, val);\\n            }\\n\\n\\n            public int Search(int x, int max)\\n            {\\n                TrieNode node = Root;\\n                int res = 0;\\n                for (int idx = MAX_BIT_INDEX; idx >= 0; idx--)\\n                {\\n                    int xBit = (x >> idx) & 1;\\n                    int opposite = xBit ^ 1;\\n\\n                    if (node.Next[opposite] == null || node.Next[opposite].Min > max)\\n                    {\\n                        if (node.Next[xBit] == null || node.Next[xBit].Min > max)\\n                        {\\n                            res = -1;\\n                            return res;\\n                        }\\n                        else\\n                        {\\n                            node = node.Next[xBit];\\n                        }\\n                    }\\n                    else\\n                    {\\n                        res |= 1 << idx;\\n                        node = node.Next[opposite];\\n                    }\\n\\n                }\\n\\n                return res;\\n            }\\n\\n        }\\n\\n        public int[] MaximizeXor(int[] nums, int[][] queries)\\n        {\\n            Trie t = new Trie();\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                t.AddValue(nums[i]);\\n            }\\n\\n            int[] res = new int[queries.Length];\\n\\n            for (int i = 0; i < queries.Length; i++)\\n            {\\n                res[i] = t.Search(queries[i][0], queries[i][1]);\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988148,
                "title": "java-nlogn-mlogm-solution-using-trie-with-explanation",
                "content": "Intuition : \\n- We want to search the bit from left to right between `x` and the candidate number\\n- We can build a Trie with left representing 0 and right representing 1 on each bit\\n- To build the Trie only for the number that is useful, we want to sort the query to start from smallest `m`\\n- We build all `nums` that is smaller or equals to `m` into the Trie\\n- We try to navigate the Trie on each bit from left to right with the opposite of the bit on `x` if such branch exist\\n\\nTime O(NLogN + MLogM) with N = nums.length, M = queries.length\\n\\n```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] q) {\\n        Trie root = new Trie();\\n        int[][] queries = new int[q.length][q[0].length + 1];\\n        for(int i = 0; i < q.length; i++) {\\n            queries[i][0] = q[i][0];\\n            queries[i][1] = q[i][1];\\n            queries[i][2] = i;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(queries, (a, b) -> {\\n            return a[1] - b[1];\\n        });\\n        int[] output = new int[q.length];\\n        Arrays.fill(output, -1);\\n        int p = 0;\\n        for(int i = 0; i < q.length; i++) {\\n            while(p < nums.length && nums[p] <= queries[i][1]) {\\n                insert(root, nums[p]);\\n                p++;\\n            }\\n            Trie curr = root;\\n            int res = 0;\\n            if(root.left == null && root.right == null) {\\n                continue;\\n            }\\n            for(int j = 31; j >= 0; j--) {\\n                if(((1 << j) & queries[i][0]) == 0) {\\n                    if(curr.right != null) {\\n                        res |= (1 << j);\\n                        curr = curr.right;\\n                    } else {\\n                        curr = curr.left;\\n                    }\\n                } else {\\n                    if(curr.left != null) {\\n                        res |= (1 << j);\\n                        curr = curr.left;\\n                    } else {\\n                        curr = curr.right;\\n                    }\\n                }\\n            }\\n            output[queries[i][2]] = res;\\n        }\\n        return output;\\n    }\\n    \\n    void insert(Trie root, int val) {\\n        Trie curr = root;\\n        for(int i = 31; i >= 0; i--) {\\n            if(((1 << i) & val) == 0) {\\n                if(curr.left == null) curr.left = new Trie();\\n                curr = curr.left;\\n            } else {\\n                if(curr.right == null) curr.right = new Trie();\\n                curr = curr.right;\\n            }\\n        }\\n    }\\n    \\n    static class Trie {\\n        Trie left;\\n        Trie right;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] q) {\\n        Trie root = new Trie();\\n        int[][] queries = new int[q.length][q[0].length + 1];\\n        for(int i = 0; i < q.length; i++) {\\n            queries[i][0] = q[i][0];\\n            queries[i][1] = q[i][1];\\n            queries[i][2] = i;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(queries, (a, b) -> {\\n            return a[1] - b[1];\\n        });\\n        int[] output = new int[q.length];\\n        Arrays.fill(output, -1);\\n        int p = 0;\\n        for(int i = 0; i < q.length; i++) {\\n            while(p < nums.length && nums[p] <= queries[i][1]) {\\n                insert(root, nums[p]);\\n                p++;\\n            }\\n            Trie curr = root;\\n            int res = 0;\\n            if(root.left == null && root.right == null) {\\n                continue;\\n            }\\n            for(int j = 31; j >= 0; j--) {\\n                if(((1 << j) & queries[i][0]) == 0) {\\n                    if(curr.right != null) {\\n                        res |= (1 << j);\\n                        curr = curr.right;\\n                    } else {\\n                        curr = curr.left;\\n                    }\\n                } else {\\n                    if(curr.left != null) {\\n                        res |= (1 << j);\\n                        curr = curr.left;\\n                    } else {\\n                        curr = curr.right;\\n                    }\\n                }\\n            }\\n            output[queries[i][2]] = res;\\n        }\\n        return output;\\n    }\\n    \\n    void insert(Trie root, int val) {\\n        Trie curr = root;\\n        for(int i = 31; i >= 0; i--) {\\n            if(((1 << i) & val) == 0) {\\n                if(curr.left == null) curr.left = new Trie();\\n                curr = curr.left;\\n            } else {\\n                if(curr.right == null) curr.right = new Trie();\\n                curr = curr.right;\\n            }\\n        }\\n    }\\n    \\n    static class Trie {\\n        Trie left;\\n        Trie right;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102992,
                "title": "simple-and-elegant-solution-trie-sorting-easy-to-understand-code-well-explained",
                "content": "# Approach\\nThe `maximizeXor` function is designed to solve a problem involving maximizing XOR values between two integers in a set. Here\\'s a breakdown of how the function works:\\n\\n### Trie Data Structure\\n\\n1. It begins by creating an empty trie data structure using the `trieNode` class.\\n\\n2. It also prepares a vector called `offQueries` to store the queries in a specific format for easier sorting. Each query is represented by a vector containing three integers:\\n   - The second element of the query\\n   - The first element of the query\\n   - The index of the query in the output array\\n\\n### Sorting\\n\\n3. The `offQueries` vector is sorted in ascending order based on the second element of each query using the `sort` function.\\n\\n4. The input vector `nums` is also sorted in ascending order using the `sort` function.\\n\\n### Query Processing\\n\\n5. The function then iterates over each query in `offQueries`. For each query:\\n   - It inserts all integers in `nums` that are less than or equal to the second element of the query into the trie using the `insert` function.\\n\\n   - It calls the `maximumXor` function with the first element of the query as input and stores the result in the output array at the index specified by the third element of the query.\\n\\n### maximumXor Function\\n\\n6. The `maximumXor` function is used to find the maximum XOR value between a given integer and any integer in the trie.\\n\\n7. It starts at the root node of the trie and iteratively follows the path corresponding to the bits of the input integer.\\n\\n8. At each step, it chooses the child node that has the opposite bit to the corresponding bit of the input integer if such a child node exists. If not, it chooses the child node that has the same bit as the corresponding bit of the input integer.\\n\\n9. The function keeps track of the XOR value of the bits encountered so far and returns the maximum XOR value encountered when it reaches a leaf node.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is $$O((n + q) * w * log n)$$, where:\\n- `n` is the number of integers in the input vector `nums`.\\n- `q` is the number of queries in the input vector `queries`.\\n- `w` is the number of bits in the largest integer.\\n\\nThis complexity arises from the following operations:\\n\\n1. **Sorting `nums`**: Sorting the input vector `nums` takes $$O(n * log n)$$ time.\\n\\n2. **Sorting `queries`**: Similarly, sorting the input vector `queries` takes $$O(q * log q)$$ time.\\n\\n3. **Trie Insertion**: Inserting each integer in `nums` into a trie takes $$O(n * w)$$ time, considering `w` as the number of bits in the largest integer.\\n\\n4. **Maximum XOR Operation**: Performing the maximum XOR operation for each query takes $$O(q * w)$$ time.\\n\\nSumming up these components, the overall time complexity of the code is $$O((n + q) * w * log n)$$. \\n\\n\\n\\n- Space complexity:\\nThe space complexity of this code is $$O(n * w),$$ where:\\n- `n` is the number of integers in the input vector `nums`.\\n- `w` is the number of bits in the largest integer.\\n\\n# Code\\n```\\n#define ll long long\\nclass trieNode\\n{\\npublic:\\n    trieNode *child[2] = {};\\n};\\nclass Solution\\n{\\nprivate:\\n    trieNode *tr;\\n    void insert(ll x)\\n    {\\n        trieNode *t = tr;\\n        bitset<32> bs(x);\\n        for (ll j = 31; j >= 0; j--)\\n        {\\n            if (!t->child[bs[j]])\\n                t->child[bs[j]] = new trieNode();\\n            t = t->child[bs[j]];\\n        }\\n    }\\n\\n    ll maximumXor(ll n)\\n    {\\n        trieNode *t = tr;\\n        bitset<32> bs(n);\\n        ll ans = 0;\\n        int j = 31;\\n        while (t and j >= 0)\\n        {\\n            if (t->child[!bs[j]])\\n            {\\n                ans += (1 << j);\\n                t = t->child[!bs[j]];\\n            }\\n            else\\n                t = t->child[bs[j]];\\n            j--;\\n        }\\n        if (!t)\\n            return -1;\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximizeXor(vector<int> &nums, vector<vector<int>> &queries)\\n    {\\n        int n = queries.size();\\n        int m = nums.size();\\n        tr = new trieNode();\\n        vector<int> ans(n, 0);\\n        vector<vector<ll>> offQueries(n);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            offQueries[i].push_back(queries[i][1]);\\n            offQueries[i].push_back(queries[i][0]);\\n            offQueries[i].push_back(i);\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        sort(offQueries.begin(), offQueries.end());\\n\\n        ll q = queries.size();\\n        ll i = 0;\\n        ll j = 0;\\n\\n        while (q--)\\n        {\\n            while (j < m and nums[j] <= offQueries[i][0])\\n            {\\n                insert(nums[j]);\\n                j++;\\n            }\\n            ans[offQueries[i][2]] = maximumXor(offQueries[i][1]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass trieNode\\n{\\npublic:\\n    trieNode *child[2] = {};\\n};\\nclass Solution\\n{\\nprivate:\\n    trieNode *tr;\\n    void insert(ll x)\\n    {\\n        trieNode *t = tr;\\n        bitset<32> bs(x);\\n        for (ll j = 31; j >= 0; j--)\\n        {\\n            if (!t->child[bs[j]])\\n                t->child[bs[j]] = new trieNode();\\n            t = t->child[bs[j]];\\n        }\\n    }\\n\\n    ll maximumXor(ll n)\\n    {\\n        trieNode *t = tr;\\n        bitset<32> bs(n);\\n        ll ans = 0;\\n        int j = 31;\\n        while (t and j >= 0)\\n        {\\n            if (t->child[!bs[j]])\\n            {\\n                ans += (1 << j);\\n                t = t->child[!bs[j]];\\n            }\\n            else\\n                t = t->child[bs[j]];\\n            j--;\\n        }\\n        if (!t)\\n            return -1;\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximizeXor(vector<int> &nums, vector<vector<int>> &queries)\\n    {\\n        int n = queries.size();\\n        int m = nums.size();\\n        tr = new trieNode();\\n        vector<int> ans(n, 0);\\n        vector<vector<ll>> offQueries(n);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            offQueries[i].push_back(queries[i][1]);\\n            offQueries[i].push_back(queries[i][0]);\\n            offQueries[i].push_back(i);\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        sort(offQueries.begin(), offQueries.end());\\n\\n        ll q = queries.size();\\n        ll i = 0;\\n        ll j = 0;\\n\\n        while (q--)\\n        {\\n            while (j < m and nums[j] <= offQueries[i][0])\\n            {\\n                insert(nums[j]);\\n                j++;\\n            }\\n            ans[offQueries[i][2]] = maximumXor(offQueries[i][1]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086372,
                "title": "commented-java-solution-tries-bit-manip-harddd",
                "content": "\\n # Approach\\nIn simple words, it helps us compare and find the best matches between binary numbers.\\n\\nFirst, the code sorts the input numbers (nums) and the queries based on their upper limits. This sorting helps us process queries efficiently.\\n\\nThen, it iterates through the sorted queries one by one. For each query:\\n\\nIt adds numbers from the sorted list (nums) into the Trie data structure, but only those that are less than or equal to the current query\\'s upper limit.\\nIf there are no such numbers, it sets the result for that query to -1.\\nIf there are numbers in the Trie that match the query\\'s conditions, it finds the maximum XOR value between the lower limit and these numbers. It does this using the Trie data structure.\\n\\nFinally, it stores the maximum XOR value in the result array for the current query.\\n# Code\\n```\\nclass Solution {\\n    // Define a TrieNode class\\n    class TrieNode {\\n        TrieNode left, right;\\n        public TrieNode() {\\n            left = null;\\n            right = null;\\n        }\\n    }\\n\\n    // Insert a number into the Trie by iteration\\n    public void insert(TrieNode root, int num) {\\n        TrieNode curr = root;\\n\\n        // Iterate through the binary representation of num\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (bit == 0) {\\n                if (curr.left == null) {\\n                    curr.left = new TrieNode();\\n                }\\n                curr = curr.left;\\n            } else \\n            {\\n                if (curr.right == null)   curr.right = new TrieNode();\\n                \\n                curr = curr.right;\\n            }\\n        }\\n    }\\n\\n    // Get the maximum XOR value with a number in the Trie\\n    public int getMaxXor(TrieNode root, int num) {\\n        TrieNode curr = root;\\n        int maxXor = 0;\\n\\n        // Iterate through the binary representation of num\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (bit == 0) {\\n                if (curr.right != null) {\\n                    curr = curr.right;\\n                    maxXor += (1 << i);\\n                } else {\\n                    curr = curr.left;\\n                }\\n            } \\n            else \\n            {\\n                if (curr.left != null) {\\n                    curr = curr.left;\\n                    maxXor += (1 << i);\\n                } else\\n                 {\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n\\n        return maxXor;\\n    }\\n\\n    // Given method to maximize XOR values\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        TrieNode root = new TrieNode();\\n        int[] result = new int[queries.length];\\n        int[][] query = new int[queries.length][3];\\n\\n        // Copy queries to a new array and sort it by the second element\\n        for (int i = 0; i < queries.length; i++) {\\n            query[i][0] = queries[i][0];\\n            query[i][1] = queries[i][1];\\n            query[i][2] = i;\\n        }\\n\\n        // Sort the input numbers and the queries\\n        Arrays.sort(nums);\\n        Arrays.sort(query, (a, b) -> (a[1] - b[1]));\\n        int index = 0;\\n\\n        // Process queries\\n        for (int i = 0; i < query.length; i++) {\\n            while (index < nums.length && nums[index] <= query[i][1]) {\\n                insert(root, nums[index]);\\n                index++;\\n            }\\n\\n            // If there are no numbers less than or equal to query[i][1], set result to -1\\n            if (nums[0] > query[i][1]) {\\n                result[query[i][2]] = -1;\\n            } else {\\n                // Otherwise, calculate the maximum XOR value\\n                result[query[i][2]] = getMaxXor(root, query[i][0]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Define a TrieNode class\\n    class TrieNode {\\n        TrieNode left, right;\\n        public TrieNode() {\\n            left = null;\\n            right = null;\\n        }\\n    }\\n\\n    // Insert a number into the Trie by iteration\\n    public void insert(TrieNode root, int num) {\\n        TrieNode curr = root;\\n\\n        // Iterate through the binary representation of num\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (bit == 0) {\\n                if (curr.left == null) {\\n                    curr.left = new TrieNode();\\n                }\\n                curr = curr.left;\\n            } else \\n            {\\n                if (curr.right == null)   curr.right = new TrieNode();\\n                \\n                curr = curr.right;\\n            }\\n        }\\n    }\\n\\n    // Get the maximum XOR value with a number in the Trie\\n    public int getMaxXor(TrieNode root, int num) {\\n        TrieNode curr = root;\\n        int maxXor = 0;\\n\\n        // Iterate through the binary representation of num\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (bit == 0) {\\n                if (curr.right != null) {\\n                    curr = curr.right;\\n                    maxXor += (1 << i);\\n                } else {\\n                    curr = curr.left;\\n                }\\n            } \\n            else \\n            {\\n                if (curr.left != null) {\\n                    curr = curr.left;\\n                    maxXor += (1 << i);\\n                } else\\n                 {\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n\\n        return maxXor;\\n    }\\n\\n    // Given method to maximize XOR values\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        TrieNode root = new TrieNode();\\n        int[] result = new int[queries.length];\\n        int[][] query = new int[queries.length][3];\\n\\n        // Copy queries to a new array and sort it by the second element\\n        for (int i = 0; i < queries.length; i++) {\\n            query[i][0] = queries[i][0];\\n            query[i][1] = queries[i][1];\\n            query[i][2] = i;\\n        }\\n\\n        // Sort the input numbers and the queries\\n        Arrays.sort(nums);\\n        Arrays.sort(query, (a, b) -> (a[1] - b[1]));\\n        int index = 0;\\n\\n        // Process queries\\n        for (int i = 0; i < query.length; i++) {\\n            while (index < nums.length && nums[index] <= query[i][1]) {\\n                insert(root, nums[index]);\\n                index++;\\n            }\\n\\n            // If there are no numbers less than or equal to query[i][1], set result to -1\\n            if (nums[0] > query[i][1]) {\\n                result[query[i][2]] = -1;\\n            } else {\\n                // Otherwise, calculate the maximum XOR value\\n                result[query[i][2]] = getMaxXor(root, query[i][0]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023316,
                "title": "maximum-xor",
                "content": "# Intuition\\nTrie Data Structure\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Trie\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M) + O(MlogM) + O(M*32 + N*32)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(32*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node {\\n    Node links[] = new Node[2];\\n    boolean containsKey(int ind) {\\n        return (links[ind] != null);\\n    }\\n    void put(int ind, Node node) {\\n        links[ind] = node; \\n    }\\n    Node get(int ind) {\\n        return links[ind];\\n    }\\n}\\nclass Trie {\\n    Node root;\\n    Trie () {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        Node node = root;\\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if(!node.containsKey(bit)) {\\n                node.put(bit, new Node());\\n            }\\n            node = node.get(bit);\\n        }\\n    }\\n    int getMax(int num) {\\n        Node node =root;\\n        int maxNum = 0;\\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if(node.containsKey(1-bit))  {\\n                maxNum = maxNum | (1 << i);\\n                node = node.get(1-bit);\\n            }\\n            else {\\n                node = node.get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        int m = queries.length;\\n        ArrayList<ArrayList<Integer>> offlineQueries = new ArrayList<>();\\n        for(int i = 0; i < m; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(queries[i][1]);\\n            temp.add(queries[i][0]);\\n            temp.add(i);\\n            offlineQueries.add(temp);\\n        }\\n        Collections.sort(offlineQueries, new Comparator<ArrayList<Integer>> () {\\n            public int compare(ArrayList<Integer> a, ArrayList<Integer> b) {\\n                return a.get(0).compareTo(b.get(0));\\n            }\\n        });\\n        int[] ans = new int[m];\\n        int n = nums.length;\\n        Trie trie = new Trie();\\n        Arrays.fill(ans, -1);\\n        int ind = 0;\\n        for(int i = 0; i < m; i++) {\\n            while(ind < n && nums[ind] <= offlineQueries.get(i).get(0)) {\\n                trie.insert(nums[ind]);\\n                ind++;\\n            }\\n            int queuryIndex = offlineQueries.get(i).get(2);\\n            if(ind != 0) {\\n                ans[queuryIndex] = trie.getMax(offlineQueries.get(i).get(1));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node {\\n    Node links[] = new Node[2];\\n    boolean containsKey(int ind) {\\n        return (links[ind] != null);\\n    }\\n    void put(int ind, Node node) {\\n        links[ind] = node; \\n    }\\n    Node get(int ind) {\\n        return links[ind];\\n    }\\n}\\nclass Trie {\\n    Node root;\\n    Trie () {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        Node node = root;\\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if(!node.containsKey(bit)) {\\n                node.put(bit, new Node());\\n            }\\n            node = node.get(bit);\\n        }\\n    }\\n    int getMax(int num) {\\n        Node node =root;\\n        int maxNum = 0;\\n        for(int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if(node.containsKey(1-bit))  {\\n                maxNum = maxNum | (1 << i);\\n                node = node.get(1-bit);\\n            }\\n            else {\\n                node = node.get(bit);\\n            }\\n        }\\n        return maxNum;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        int m = queries.length;\\n        ArrayList<ArrayList<Integer>> offlineQueries = new ArrayList<>();\\n        for(int i = 0; i < m; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(queries[i][1]);\\n            temp.add(queries[i][0]);\\n            temp.add(i);\\n            offlineQueries.add(temp);\\n        }\\n        Collections.sort(offlineQueries, new Comparator<ArrayList<Integer>> () {\\n            public int compare(ArrayList<Integer> a, ArrayList<Integer> b) {\\n                return a.get(0).compareTo(b.get(0));\\n            }\\n        });\\n        int[] ans = new int[m];\\n        int n = nums.length;\\n        Trie trie = new Trie();\\n        Arrays.fill(ans, -1);\\n        int ind = 0;\\n        for(int i = 0; i < m; i++) {\\n            while(ind < n && nums[ind] <= offlineQueries.get(i).get(0)) {\\n                trie.insert(nums[ind]);\\n                ind++;\\n            }\\n            int queuryIndex = offlineQueries.get(i).get(2);\\n            if(ind != 0) {\\n                ans[queuryIndex] = trie.getMax(offlineQueries.get(i).get(1));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971819,
                "title": "trie-clean-pre-req-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust modification of https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/\\n# Complexity\\n- Time complexity:\\nO((n + m) * log n + m * log m)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nstruct Node{\\n    Node* links[2] = {nullptr};\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node;\\n    }\\n    void insert(int x){\\n        Node* curr = root;\\n        for(int i=31; i>=0; i--){\\n            int bit = (x>>i)&1;\\n            if(curr->links[bit]==nullptr)\\n                curr->links[bit] = new Node;\\n            curr = curr->links[bit];            \\n        }\\n    }\\n    int getmaxor(int x){\\n        Node* curr = root;\\n        int maxor = 0;\\n        for(int i=31; i>=0; i--){\\n            int bit = (x>>i)&1;\\n            int oppbit = 1-bit;\\n\\n            if(curr->links[oppbit]){\\n                maxor = maxor | (1<<i);\\n                curr = curr->links[oppbit];\\n            }else{\\n                curr = curr->links[bit];\\n            }\\n        }\\n        return maxor;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n\\n        vector<pair<int, pair<int, int>>> q;\\n        //  {limit, {x, index in query}};\\n\\n        int ind = 0;\\n        for(auto query:queries){\\n            int m_i = query[1];\\n            int x_i = query[0];\\n            //  ofc index  = ind\\n            q.push_back({m_i, {x_i, ind++}});\\n        }\\n\\n        //  now sort q acc to the m_i\\'s i.e., the limits\\n        sort(q.begin(), q.end());\\n\\n        const int n = size(nums), m = size(queries);\\n        vector<int> ans(m);\\n        Trie t;\\n        int i = 0;\\n\\n        //  NOW for every elem k_i in q\\n        //  add all the num from nums that\\'s in the k_i\\'s limit\\n        //  then, get max, if the index from nums (i here) hasn\\'t moved\\n        //  then, we have no number in the q_i\\'s limit\\n\\n        for(auto &k:q){\\n            int m_i = k.first;\\n            int x_i = k.second.first;\\n            int q_index = k.second.second;\\n            while(i<n and nums[i]<=m_i){\\n                t.insert(nums[i]);\\n                i++;\\n            }\\n            if(i==0)\\n                ans[q_index] = -1;\\n            else\\n                ans[q_index] = t.getmaxor(x_i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[2] = {nullptr};\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node;\\n    }\\n    void insert(int x){\\n        Node* curr = root;\\n        for(int i=31; i>=0; i--){\\n            int bit = (x>>i)&1;\\n            if(curr->links[bit]==nullptr)\\n                curr->links[bit] = new Node;\\n            curr = curr->links[bit];            \\n        }\\n    }\\n    int getmaxor(int x){\\n        Node* curr = root;\\n        int maxor = 0;\\n        for(int i=31; i>=0; i--){\\n            int bit = (x>>i)&1;\\n            int oppbit = 1-bit;\\n\\n            if(curr->links[oppbit]){\\n                maxor = maxor | (1<<i);\\n                curr = curr->links[oppbit];\\n            }else{\\n                curr = curr->links[bit];\\n            }\\n        }\\n        return maxor;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n\\n        vector<pair<int, pair<int, int>>> q;\\n        //  {limit, {x, index in query}};\\n\\n        int ind = 0;\\n        for(auto query:queries){\\n            int m_i = query[1];\\n            int x_i = query[0];\\n            //  ofc index  = ind\\n            q.push_back({m_i, {x_i, ind++}});\\n        }\\n\\n        //  now sort q acc to the m_i\\'s i.e., the limits\\n        sort(q.begin(), q.end());\\n\\n        const int n = size(nums), m = size(queries);\\n        vector<int> ans(m);\\n        Trie t;\\n        int i = 0;\\n\\n        //  NOW for every elem k_i in q\\n        //  add all the num from nums that\\'s in the k_i\\'s limit\\n        //  then, get max, if the index from nums (i here) hasn\\'t moved\\n        //  then, we have no number in the q_i\\'s limit\\n\\n        for(auto &k:q){\\n            int m_i = k.first;\\n            int x_i = k.second.first;\\n            int q_index = k.second.second;\\n            while(i<n and nums[i]<=m_i){\\n                t.insert(nums[i]);\\n                i++;\\n            }\\n            if(i==0)\\n                ans[q_index] = -1;\\n            else\\n                ans[q_index] = t.getmaxor(x_i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967639,
                "title": "python-trie-offline-queries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n\\n\\n        #sorting nums\\n        l=len(nums)\\n        nums.sort()\\n        ptr=0\\n\\n        #Initialinsing Trie\\n        Trie=defaultdict(defaultdict)\\n\\n        # answer\\n        nq=len(queries)\\n        ans=[0 for i in range(nq)]\\n        qury=SortedList()\\n\\n        #sorting of queries\\n        for i in range(nq):\\n            qury.add((queries[i][1],queries[i][0],i))\\n        \\n        for i in range(nq):\\n            ref=qury[0]\\n            qury.discard(ref)\\n            while ptr<l and nums[ptr]<=ref[0]:\\n                tt=nums[ptr]\\n                local_trie=Trie\\n\\n                for i in range(31,-1,-1):\\n                    point=0\\n                    if tt & 1<<i:\\n                        point=1\\n                    if not local_trie[point]:\\n                        local_trie[point]=defaultdict(defaultdict) \\n                    local_trie=local_trie[point]\\n                local_trie[\\'end\\']=True\\n                ptr+=1\\n            local_trie=Trie\\n            nm=0\\n            flag=True\\n            for i in range(31,-1,-1):\\n                point=0\\n                if ref[1] & 1<<i:\\n                    point=1\\n                if local_trie[point^1]:\\n                    nm+=2**i\\n                    local_trie=local_trie[point ^ 1]\\n                elif local_trie[point]:\\n                    local_trie=local_trie[point]\\n                else:\\n                    flag=False\\n                    break\\n            if not flag:\\n                ans[ref[2]]=-1\\n            else:\\n                ans[ref[2]]=nm                \\n        return ans\\n\\n        \\n\\n\\n\\n\\n\\n            \\n\\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n\\n\\n        #sorting nums\\n        l=len(nums)\\n        nums.sort()\\n        ptr=0\\n\\n        #Initialinsing Trie\\n        Trie=defaultdict(defaultdict)\\n\\n        # answer\\n        nq=len(queries)\\n        ans=[0 for i in range(nq)]\\n        qury=SortedList()\\n\\n        #sorting of queries\\n        for i in range(nq):\\n            qury.add((queries[i][1],queries[i][0],i))\\n        \\n        for i in range(nq):\\n            ref=qury[0]\\n            qury.discard(ref)\\n            while ptr<l and nums[ptr]<=ref[0]:\\n                tt=nums[ptr]\\n                local_trie=Trie\\n\\n                for i in range(31,-1,-1):\\n                    point=0\\n                    if tt & 1<<i:\\n                        point=1\\n                    if not local_trie[point]:\\n                        local_trie[point]=defaultdict(defaultdict) \\n                    local_trie=local_trie[point]\\n                local_trie[\\'end\\']=True\\n                ptr+=1\\n            local_trie=Trie\\n            nm=0\\n            flag=True\\n            for i in range(31,-1,-1):\\n                point=0\\n                if ref[1] & 1<<i:\\n                    point=1\\n                if local_trie[point^1]:\\n                    nm+=2**i\\n                    local_trie=local_trie[point ^ 1]\\n                elif local_trie[point]:\\n                    local_trie=local_trie[point]\\n                else:\\n                    flag=False\\n                    break\\n            if not flag:\\n                ans[ref[2]]=-1\\n            else:\\n                ans[ref[2]]=nm                \\n        return ans\\n\\n        \\n\\n\\n\\n\\n\\n            \\n\\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941636,
                "title": "very-easy-to-understand-priority-queue-and-trie-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n) + O(mlog(m)) + O(n*32 + m*32)$$\\n\\n- Space complexity:\\n$$O(m)$$\\n\\n# Code\\n```\\n// Creating trie data structure\\nclass Node{\\n    Node[] arr = new Node[2];\\n\\n    boolean containsKey(int i){\\n        return arr[i] != null;\\n    }\\n\\n    void put(int i, Node node){\\n        arr[i] = node;\\n    }\\n\\n    Node get(int i){\\n        return arr[i];\\n    }\\n}\\n\\nclass Trie{\\n    Node root;\\n\\n    public Trie(){\\n        root = new Node();\\n    }\\n\\n    public void insert(int num){\\n        Node node = root;\\n        for(int i = 31; i>=0; i--){\\n            int bit = (num >> i) & 1;\\n            if(!node.containsKey(bit)){\\n                node.put(bit, new Node());\\n            }\\n            node = node.get(bit);\\n        }\\n    }\\n\\n    // Give the max xor of num with the existing data in trie.\\n    // it tries to maximize the xor by taking the opposite bit in trie with respect to the bit of given number at ith position and if opposite bit is absent then go on with the same bit\\n    public int maxXor(int num){\\n        Node node = root;\\n        int max = 0;\\n        for(int i=31; i>=0; i--){\\n            int bit = (num>>i) & 1;\\n            if(node.containsKey(1-bit)){\\n                max = max | (1 << i);\\n                node = node.get(1-bit);\\n            } else {\\n                node = node.get(bit);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\n// Create a new class tuple to store the queries\\nclass Tuple{\\n    int m;\\n    int x;\\n    int ind;\\n    public Tuple(int _m, int _x, int _ind){\\n        this.m = _m;\\n        this.x = _x;\\n        this.ind = _ind;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        // Storing data in priority queue sorted by their threshold value m\\n        PriorityQueue<Tuple> pq = new PriorityQueue<>((x, y) -> x.m - y.m);\\n        for(int i = 0; i < queries.length; i++){\\n            int m = queries[i][1];\\n            int x = queries[i][0];\\n            pq.add(new Tuple(m, x, i));\\n        }\\n\\n        Trie trie = new Trie();\\n        int[] res = new int[queries.length];\\n        Arrays.sort(nums);\\n        Arrays.fill(res, -1);\\n        int j = 0;\\n\\n        // Now pushing the nums[j] into tree until it is <= m then take the maxXor and aging repeat \\n        for(int i=0; i<queries.length; i++){\\n            Tuple tup = pq.remove();\\n            int x = tup.x;\\n            int m = tup.m;\\n            int ind = tup.ind;\\n\\n            //Pushing until nums[j] is less than equal to m and then break out to take maxXor\\n            while(j < nums.length && nums[j] <= m){\\n                trie.insert(nums[j]);\\n                j++;\\n            }\\n\\n            // NOTE : Make sure to place this if condition otherwise if trie dosen\\'t contain anything\\n            // maxXor will give an error\\n            if(j != 0) res[ind] = trie.maxXor(x);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Trie",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Creating trie data structure\\nclass Node{\\n    Node[] arr = new Node[2];\\n\\n    boolean containsKey(int i){\\n        return arr[i] != null;\\n    }\\n\\n    void put(int i, Node node){\\n        arr[i] = node;\\n    }\\n\\n    Node get(int i){\\n        return arr[i];\\n    }\\n}\\n\\nclass Trie{\\n    Node root;\\n\\n    public Trie(){\\n        root = new Node();\\n    }\\n\\n    public void insert(int num){\\n        Node node = root;\\n        for(int i = 31; i>=0; i--){\\n            int bit = (num >> i) & 1;\\n            if(!node.containsKey(bit)){\\n                node.put(bit, new Node());\\n            }\\n            node = node.get(bit);\\n        }\\n    }\\n\\n    // Give the max xor of num with the existing data in trie.\\n    // it tries to maximize the xor by taking the opposite bit in trie with respect to the bit of given number at ith position and if opposite bit is absent then go on with the same bit\\n    public int maxXor(int num){\\n        Node node = root;\\n        int max = 0;\\n        for(int i=31; i>=0; i--){\\n            int bit = (num>>i) & 1;\\n            if(node.containsKey(1-bit)){\\n                max = max | (1 << i);\\n                node = node.get(1-bit);\\n            } else {\\n                node = node.get(bit);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\n// Create a new class tuple to store the queries\\nclass Tuple{\\n    int m;\\n    int x;\\n    int ind;\\n    public Tuple(int _m, int _x, int _ind){\\n        this.m = _m;\\n        this.x = _x;\\n        this.ind = _ind;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        // Storing data in priority queue sorted by their threshold value m\\n        PriorityQueue<Tuple> pq = new PriorityQueue<>((x, y) -> x.m - y.m);\\n        for(int i = 0; i < queries.length; i++){\\n            int m = queries[i][1];\\n            int x = queries[i][0];\\n            pq.add(new Tuple(m, x, i));\\n        }\\n\\n        Trie trie = new Trie();\\n        int[] res = new int[queries.length];\\n        Arrays.sort(nums);\\n        Arrays.fill(res, -1);\\n        int j = 0;\\n\\n        // Now pushing the nums[j] into tree until it is <= m then take the maxXor and aging repeat \\n        for(int i=0; i<queries.length; i++){\\n            Tuple tup = pq.remove();\\n            int x = tup.x;\\n            int m = tup.m;\\n            int ind = tup.ind;\\n\\n            //Pushing until nums[j] is less than equal to m and then break out to take maxXor\\n            while(j < nums.length && nums[j] <= m){\\n                trie.insert(nums[j]);\\n                j++;\\n            }\\n\\n            // NOTE : Make sure to place this if condition otherwise if trie dosen\\'t contain anything\\n            // maxXor will give an error\\n            if(j != 0) res[ind] = trie.maxXor(x);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941042,
                "title": "c-step-by-step-easiest-trie-solution-w-comments",
                "content": "\\n\\n# Code\\n```\\nstruct Node{\\n    Node* link[2];\\n\\n    bool contains(int bit){ //to check the bit of a node (or to check) if it exists\\n        return(link[bit]!=NULL);\\n    }\\n    void put(int bit, Node* node){  //make a new refernece node and push there\\n        link[bit] = node;\\n    }\\n    Node* get(int bit){ //get the next node to current one\\n        return (link[bit]);\\n    }\\n};\\n\\nclass trie{\\nprivate:\\n    Node* root;\\n\\npublic:\\n    trie(){\\n        root = new Node();\\n    }\\n\\n    void insert(int num){ //num is a 32-bit integer number\\n        Node* node = root;\\n        for(int i=31; i>=0; i--){\\n            int bit = (num >> i) & 1; // if the ith bit is set or not\\n            if(!node->contains(bit)){\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n\\n    int getmax(int num){ //gives u the max xor obtained by num^all elments of arr2 (basically trie)\\n        Node* node = root;\\n        int maxno = 0;\\n        for(int i=31; i>=0; i--){\\n            int bit = (num>>i) & 1;\\n\\n            if(node!= NULL && node->contains(1-bit)){ // agar ulta bit exist karta h to dono ka xor 1 aayega\\n                maxno = maxno | (1<<i); //so us posn par 1 insert kardo final ans ke\\n                node = node->get(1-bit);\\n            }\\n            else{\\n              if(node!=NULL)  node = node-> get(bit); //else vo bit in final ans 0 hi reh jayega and we move to next bit of num\\n            }\\n        }\\n        return maxno;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    static bool cmp(vector<int>&v1, vector<int>&v2){\\n\\n        if(v1[1]==v2[1]){\\n            return v1[2]<v2[2];\\n        }\\n        return v1[1]<v2[1];\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        \\n        // use thought process of OFFLINE QUERIES!\\n\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<q.size(); i++){\\n            q[i].push_back(i); // pushing its own index in query \\n        }\\n\\n        sort(q.begin(), q.end(), cmp); //sorting according to query\\'s second index\\n        \\n        vector<int> ans(q.size(),-1);\\n\\n        trie trie; //object of class trie\\n        int j=0;\\n\\n        for(int i=0; i<q.size(); i++){\\n            while(j<nums.size() && nums[j]<=q[i][1]){\\n                trie.insert(nums[j]);\\n                j++;\\n            }\\n\\n            if(j==0) ans[q[i][2]] = -1;\\n            else ans[q[i][2]] = trie.getmax(q[i][0]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* link[2];\\n\\n    bool contains(int bit){ //to check the bit of a node (or to check) if it exists\\n        return(link[bit]!=NULL);\\n    }\\n    void put(int bit, Node* node){  //make a new refernece node and push there\\n        link[bit] = node;\\n    }\\n    Node* get(int bit){ //get the next node to current one\\n        return (link[bit]);\\n    }\\n};\\n\\nclass trie{\\nprivate:\\n    Node* root;\\n\\npublic:\\n    trie(){\\n        root = new Node();\\n    }\\n\\n    void insert(int num){ //num is a 32-bit integer number\\n        Node* node = root;\\n        for(int i=31; i>=0; i--){\\n            int bit = (num >> i) & 1; // if the ith bit is set or not\\n            if(!node->contains(bit)){\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n\\n    int getmax(int num){ //gives u the max xor obtained by num^all elments of arr2 (basically trie)\\n        Node* node = root;\\n        int maxno = 0;\\n        for(int i=31; i>=0; i--){\\n            int bit = (num>>i) & 1;\\n\\n            if(node!= NULL && node->contains(1-bit)){ // agar ulta bit exist karta h to dono ka xor 1 aayega\\n                maxno = maxno | (1<<i); //so us posn par 1 insert kardo final ans ke\\n                node = node->get(1-bit);\\n            }\\n            else{\\n              if(node!=NULL)  node = node-> get(bit); //else vo bit in final ans 0 hi reh jayega and we move to next bit of num\\n            }\\n        }\\n        return maxno;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    static bool cmp(vector<int>&v1, vector<int>&v2){\\n\\n        if(v1[1]==v2[1]){\\n            return v1[2]<v2[2];\\n        }\\n        return v1[1]<v2[1];\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        \\n        // use thought process of OFFLINE QUERIES!\\n\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<q.size(); i++){\\n            q[i].push_back(i); // pushing its own index in query \\n        }\\n\\n        sort(q.begin(), q.end(), cmp); //sorting according to query\\'s second index\\n        \\n        vector<int> ans(q.size(),-1);\\n\\n        trie trie; //object of class trie\\n        int j=0;\\n\\n        for(int i=0; i<q.size(); i++){\\n            while(j<nums.size() && nums[j]<=q[i][1]){\\n                trie.insert(nums[j]);\\n                j++;\\n            }\\n\\n            if(j==0) ans[q[i][2]] = -1;\\n            else ans[q[i][2]] = trie.getmax(q[i][0]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935806,
                "title": "offline-queries-trie-c-easy",
                "content": "make a trie with insert and getmax function and then sort the queries on the basis of ai max no upto which you want the answer and then store the indexes as well for which you want the answer and call the functions and get the answer\\none check point suppose there are no elements in Trie at that point just mark your answer as -1 \\n\\n\\n# Code\\n```\\nstruct Node{\\n    Node* links[2];\\n};\\nclass Trie{\\n    public:\\n    Node* root;\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int n){\\n        Node* temp=root;\\n        for(int i=31; i>=0; i--){\\n            int bit=((n>>i) & 1);\\n            if(temp->links[bit]==NULL){\\n                Node* newnode=new Node();\\n                temp->links[bit]=newnode;\\n            } \\n            temp=temp->links[bit];\\n        }\\n    }\\n    int getmax(int n){\\n        Node* temp=root;\\n        int ma=0;\\n        for(int i=31; i>=0; i--){\\n            int bit=(n>>i) & 1;\\n            \\n            if(temp->links[!bit]){\\n                ma=(ma | (1<<i));\\n                temp=temp->links[!bit];\\n            }else{\\n\\n            temp=temp->links[bit];\\n            }\\n        }\\n        return ma;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n   static bool cmp(vector<int> &a,vector<int> &b){\\n       return a[1]<b[1];\\n   }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        sort(nums.begin(),nums.end());\\n        int j=0;\\n        for(auto &it:q){\\n            it.push_back(j++);\\n        }\\n        sort(q.begin(),q.end(),cmp);\\n        vector<int> ans(q.size(),0);\\n        int ind=0;\\n        int n=nums.size();\\n        Trie T;\\n\\n        for(int i=0; i<q.size(); i++){\\n            int mx=q[i][1];\\n            int xi=q[i][0];\\n            int ansi=q[i][2];\\n            while(ind<n && nums[ind]<=mx){\\n                T.insert(nums[ind]);\\n                ind++;\\n            }\\n            if(ind==0){\\n                ans[ansi]=-1;\\n            }\\n            else{\\n                ans[ansi]=T.getmax(xi);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[2];\\n};\\nclass Trie{\\n    public:\\n    Node* root;\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int n){\\n        Node* temp=root;\\n        for(int i=31; i>=0; i--){\\n            int bit=((n>>i) & 1);\\n            if(temp->links[bit]==NULL){\\n                Node* newnode=new Node();\\n                temp->links[bit]=newnode;\\n            } \\n            temp=temp->links[bit];\\n        }\\n    }\\n    int getmax(int n){\\n        Node* temp=root;\\n        int ma=0;\\n        for(int i=31; i>=0; i--){\\n            int bit=(n>>i) & 1;\\n            \\n            if(temp->links[!bit]){\\n                ma=(ma | (1<<i));\\n                temp=temp->links[!bit];\\n            }else{\\n\\n            temp=temp->links[bit];\\n            }\\n        }\\n        return ma;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n   static bool cmp(vector<int> &a,vector<int> &b){\\n       return a[1]<b[1];\\n   }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        sort(nums.begin(),nums.end());\\n        int j=0;\\n        for(auto &it:q){\\n            it.push_back(j++);\\n        }\\n        sort(q.begin(),q.end(),cmp);\\n        vector<int> ans(q.size(),0);\\n        int ind=0;\\n        int n=nums.size();\\n        Trie T;\\n\\n        for(int i=0; i<q.size(); i++){\\n            int mx=q[i][1];\\n            int xi=q[i][0];\\n            int ansi=q[i][2];\\n            while(ind<n && nums[ind]<=mx){\\n                T.insert(nums[ind]);\\n                ind++;\\n            }\\n            if(ind==0){\\n                ans[ansi]=-1;\\n            }\\n            else{\\n                ans[ansi]=T.getmax(xi);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924513,
                "title": "cpp-trie-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node {\\npublic:\\n    Node *links[2];\\n\\n    bool containKey(int num){\\n        return links[num];\\n    }\\n    Node * get(int num){\\n        return links[num];\\n    }\\n    void put(int num,Node*node){\\n        links[num]=node;\\n    }\\n\\n};\\nclass Trie{\\n    private: Node * root;\\n    public:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int num){\\n        Node * node=root;\\n    for(int i=31;i>=0;i--){\\n        int val=(num>>i)&1;\\n        if(!node->containKey(val)) node->put(val,new Node());\\n\\n        node=node->get(val);\\n\\n    }\\n    }\\n    int getNum(int num){\\n        int ans=0;\\n          Node * node=root;\\n    for(int i=31;i>=0;i--){\\n        int val=(num>>i)&1;\\n        int nval=1-val;\\n        if(node->containKey(nval)){\\n            ans=ans|(1<<i) ;\\n            node=node->get(nval);\\n        }\\n        else node=node->get(val);\\n        \\n\\n    }\\n    return ans;\\n    } \\n\\n};\\nclass Solution {\\npublic:\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<pair<int,pair<int,int>>> arr;\\n        Trie * trie=new Trie();\\n        vector<int> ans(queries.size());\\n        for(int i=0;i<queries.size();i++ )arr.push_back({queries[i][1],{queries[i][0],i}});\\n        sort(arr.begin(),arr.end());\\n        sort(nums.begin(),nums.end());\\n        int k=0;\\n        int m=nums.size();\\n        for(int i=0;i<queries.size();i++){\\n            \\n            while(k<m && nums[k]<=arr[i].first){\\n                trie->insert(nums[k++]);\\n            }\\n            if(k==0)ans[arr[i].second.second]=-1;\\n            else\\n        ans[arr[i].second.second]=trie->getNum(arr[i].second.first);\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\npublic:\\n    Node *links[2];\\n\\n    bool containKey(int num){\\n        return links[num];\\n    }\\n    Node * get(int num){\\n        return links[num];\\n    }\\n    void put(int num,Node*node){\\n        links[num]=node;\\n    }\\n\\n};\\nclass Trie{\\n    private: Node * root;\\n    public:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int num){\\n        Node * node=root;\\n    for(int i=31;i>=0;i--){\\n        int val=(num>>i)&1;\\n        if(!node->containKey(val)) node->put(val,new Node());\\n\\n        node=node->get(val);\\n\\n    }\\n    }\\n    int getNum(int num){\\n        int ans=0;\\n          Node * node=root;\\n    for(int i=31;i>=0;i--){\\n        int val=(num>>i)&1;\\n        int nval=1-val;\\n        if(node->containKey(nval)){\\n            ans=ans|(1<<i) ;\\n            node=node->get(nval);\\n        }\\n        else node=node->get(val);\\n        \\n\\n    }\\n    return ans;\\n    } \\n\\n};\\nclass Solution {\\npublic:\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<pair<int,pair<int,int>>> arr;\\n        Trie * trie=new Trie();\\n        vector<int> ans(queries.size());\\n        for(int i=0;i<queries.size();i++ )arr.push_back({queries[i][1],{queries[i][0],i}});\\n        sort(arr.begin(),arr.end());\\n        sort(nums.begin(),nums.end());\\n        int k=0;\\n        int m=nums.size();\\n        for(int i=0;i<queries.size();i++){\\n            \\n            while(k<m && nums[k]<=arr[i].first){\\n                trie->insert(nums[k++]);\\n            }\\n            if(k==0)ans[arr[i].second.second]=-1;\\n            else\\n        ans[arr[i].second.second]=trie->getNum(arr[i].second.first);\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920940,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a set of queries, the code processes them in order of increasing maximum values. For each query, it gradually builds the XOR result by traversing the Trie, making optimal bit choices to maximize the XOR value between the query number and the available numbers in the Trie.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(q+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nstruct Node{\\n    Node *links[2];\\n    bool containsKey(int bit)\\n    {\\n        return (links[bit]!=NULL);\\n    }\\n    Node* get(int bit)\\n    {\\n        return links[bit];\\n    }\\n    void put(int bit,Node *node)\\n    {\\n        links[bit]=node;\\n    }\\n};\\nclass Trie{\\n  public:\\n    Node *root;\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node *node=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i) &1;\\n            if(!node->containsKey(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n    \\n    int getMax(int num)\\n    {\\n        Node *node=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(node->containsKey(1-bit))\\n            {\\n                maxNum=maxNum | (1<<i);\\n                node=node->get(1-bit);\\n            }\\n            else\\n            node=node->get(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<pair<int,pair<int,int>>> v;\\n        int q=queries.size();\\n        for(int i=0;i<q;i++)\\n        {\\n            v.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int> ans(q,0);\\n        Trie trie;\\n        int ind=0;\\n        for(int i=0;i<q;i++)\\n        {\\n            int ai=v[i].first;\\n            int xi=v[i].second.first;\\n            int j=v[i].second.second;\\n\\n            while(ind< n && arr[ind]<=ai)\\n            {\\n               trie.insert(arr[ind]);\\n               ind++;\\n            }\\n            if(ind==0)\\n            ans[j]=-1;\\n            else\\n            ans[j]=trie.getMax(xi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node{\\n    Node *links[2];\\n    bool containsKey(int bit)\\n    {\\n        return (links[bit]!=NULL);\\n    }\\n    Node* get(int bit)\\n    {\\n        return links[bit];\\n    }\\n    void put(int bit,Node *node)\\n    {\\n        links[bit]=node;\\n    }\\n};\\nclass Trie{\\n  public:\\n    Node *root;\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node *node=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i) &1;\\n            if(!node->containsKey(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n    \\n    int getMax(int num)\\n    {\\n        Node *node=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(node->containsKey(1-bit))\\n            {\\n                maxNum=maxNum | (1<<i);\\n                node=node->get(1-bit);\\n            }\\n            else\\n            node=node->get(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        int n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<pair<int,pair<int,int>>> v;\\n        int q=queries.size();\\n        for(int i=0;i<q;i++)\\n        {\\n            v.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int> ans(q,0);\\n        Trie trie;\\n        int ind=0;\\n        for(int i=0;i<q;i++)\\n        {\\n            int ai=v[i].first;\\n            int xi=v[i].second.first;\\n            int j=v[i].second.second;\\n\\n            while(ind< n && arr[ind]<=ai)\\n            {\\n               trie.insert(arr[ind]);\\n               ind++;\\n            }\\n            if(ind==0)\\n            ans[j]=-1;\\n            else\\n            ans[j]=trie.getMax(xi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897295,
                "title": "beats-96-simple-solution-using-trie-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node {\\n  Node * links[2];\\n\\n  bool containsKey(int ind) {\\n    return (links[ind] != NULL);\\n  }\\n  Node * get(int ind) {\\n    return links[ind];\\n  }\\n  void put(int ind, Node * node) {\\n    links[ind] = node;\\n  }\\n};\\nclass Trie {\\n  private: Node * root;\\n  public:\\n    Trie() {\\n      root = new Node();\\n    }\\n\\n  public:\\n    void insert(int num) {\\n      Node * node = root;\\n      for (int i = 31; i >= 0; i--) {\\n        int bit = (num >> i) & 1;\\n        if (!node -> containsKey(bit)) {\\n          node -> put(bit, new Node());\\n        }\\n        node = node -> get(bit);\\n      }\\n    }\\n  public:\\n    int findMax(int num) {\\n      Node * node = root;\\n      int maxNum = 0;\\n      for (int i = 31; i >= 0; i--) {\\n        int bit = (num >> i) & 1;\\n        if (node -> containsKey(!bit)) {\\n          maxNum = maxNum | (1 << i);\\n          node = node -> get(!bit);\\n        } else {\\n          node = node -> get(bit);\\n        }\\n      }\\n      return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int>ans(queries.size(),0);\\n        sort(nums.begin(),nums.end());\\n        vector<pair<int,pair<int,int>>>offlinequeries;\\n        for(int i=0; i<queries.size(); i++){\\n            offlinequeries.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n        sort(offlinequeries.begin(),offlinequeries.end());\\n        int i=0;\\n        int n=nums.size();\\n        Trie trie;\\n        for(auto it:offlinequeries){\\n            while(i<n && nums[i]<=it.first){\\n                trie.insert(nums[i]);\\n                i++;\\n            }\\n            if(i!=0) ans[it.second.second]= trie.findMax(it.second.first);\\n            else ans[it.second.second]=-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n  Node * links[2];\\n\\n  bool containsKey(int ind) {\\n    return (links[ind] != NULL);\\n  }\\n  Node * get(int ind) {\\n    return links[ind];\\n  }\\n  void put(int ind, Node * node) {\\n    links[ind] = node;\\n  }\\n};\\nclass Trie {\\n  private: Node * root;\\n  public:\\n    Trie() {\\n      root = new Node();\\n    }\\n\\n  public:\\n    void insert(int num) {\\n      Node * node = root;\\n      for (int i = 31; i >= 0; i--) {\\n        int bit = (num >> i) & 1;\\n        if (!node -> containsKey(bit)) {\\n          node -> put(bit, new Node());\\n        }\\n        node = node -> get(bit);\\n      }\\n    }\\n  public:\\n    int findMax(int num) {\\n      Node * node = root;\\n      int maxNum = 0;\\n      for (int i = 31; i >= 0; i--) {\\n        int bit = (num >> i) & 1;\\n        if (node -> containsKey(!bit)) {\\n          maxNum = maxNum | (1 << i);\\n          node = node -> get(!bit);\\n        } else {\\n          node = node -> get(bit);\\n        }\\n      }\\n      return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int>ans(queries.size(),0);\\n        sort(nums.begin(),nums.end());\\n        vector<pair<int,pair<int,int>>>offlinequeries;\\n        for(int i=0; i<queries.size(); i++){\\n            offlinequeries.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n        sort(offlinequeries.begin(),offlinequeries.end());\\n        int i=0;\\n        int n=nums.size();\\n        Trie trie;\\n        for(auto it:offlinequeries){\\n            while(i<n && nums[i]<=it.first){\\n                trie.insert(nums[i]);\\n                i++;\\n            }\\n            if(i!=0) ans[it.second.second]= trie.findMax(it.second.first);\\n            else ans[it.second.second]=-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896840,
                "title": "97-56-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{\\npublic:\\n    Node* links[2];\\n    int mini[2];\\n    \\n    Node(){\\n        links[0]=NULL,links[1]=NULL;\\n        mini[0]=INT_MAX,mini[1]=INT_MAX;\\n    }\\n    bool containsKey(int i){\\n        return links[i]!=NULL;\\n    }\\n    void put(int i, Node* node){\\n        links[i]=node;\\n    }\\n    Node* get(int i){\\n        return links[i];\\n    }\\n    void putMin(int bit, int x){\\n        mini[bit]=min(mini[bit],x);\\n    }\\n    int getMin(int bit){\\n        return mini[bit];\\n    }\\n};\\nclass Solution {\\npublic:\\n    Node* root;\\n    void insert(int x)\\n    {\\n        Node* curr=root;\\n        int k=32;\\n        while(k--)\\n        {\\n            int bit=((x>>k)&1);\\n            if(!curr->containsKey(bit))\\n                curr->put(bit,new Node());\\n            curr->putMin(bit,x);\\n            curr=curr->get(bit);\\n        }\\n    }\\n    int searchMaxXOR(int x, int m)\\n    {\\n        Node* curr=root;\\n        int ans=0,k=32;\\n        while(k--)\\n        {\\n            ans=ans*2;\\n            \\n            int bit=((x>>k)&1);\\n            if(curr->containsKey(1-bit) && curr->getMin(1-bit)<=m)\\n            {\\n                curr=curr->get(1-bit);\\n                ans++;\\n            }\\n            else\\n                curr=curr->get(bit);\\n        }\\n        return ans;\\n    }\\n    vector<int> maximizeXor(vector<int>& v, vector<vector<int>>& q) {\\n        int n=v.size();\\n        root=new Node();\\n        for(int i=0;i<n;i++)\\n            insert(v[i]);\\n        int minEle=*min_element(v.begin(),v.end());\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int x=q[i][0],m=q[i][1];\\n            if(minEle<=m)\\n                ans.push_back(searchMaxXOR(x,m));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\npublic:\\n    Node* links[2];\\n    int mini[2];\\n    \\n    Node(){\\n        links[0]=NULL,links[1]=NULL;\\n        mini[0]=INT_MAX,mini[1]=INT_MAX;\\n    }\\n    bool containsKey(int i){\\n        return links[i]!=NULL;\\n    }\\n    void put(int i, Node* node){\\n        links[i]=node;\\n    }\\n    Node* get(int i){\\n        return links[i];\\n    }\\n    void putMin(int bit, int x){\\n        mini[bit]=min(mini[bit],x);\\n    }\\n    int getMin(int bit){\\n        return mini[bit];\\n    }\\n};\\nclass Solution {\\npublic:\\n    Node* root;\\n    void insert(int x)\\n    {\\n        Node* curr=root;\\n        int k=32;\\n        while(k--)\\n        {\\n            int bit=((x>>k)&1);\\n            if(!curr->containsKey(bit))\\n                curr->put(bit,new Node());\\n            curr->putMin(bit,x);\\n            curr=curr->get(bit);\\n        }\\n    }\\n    int searchMaxXOR(int x, int m)\\n    {\\n        Node* curr=root;\\n        int ans=0,k=32;\\n        while(k--)\\n        {\\n            ans=ans*2;\\n            \\n            int bit=((x>>k)&1);\\n            if(curr->containsKey(1-bit) && curr->getMin(1-bit)<=m)\\n            {\\n                curr=curr->get(1-bit);\\n                ans++;\\n            }\\n            else\\n                curr=curr->get(bit);\\n        }\\n        return ans;\\n    }\\n    vector<int> maximizeXor(vector<int>& v, vector<vector<int>>& q) {\\n        int n=v.size();\\n        root=new Node();\\n        for(int i=0;i<n;i++)\\n            insert(v[i]);\\n        int minEle=*min_element(v.begin(),v.end());\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int x=q[i][0],m=q[i][1];\\n            if(minEle<=m)\\n                ans.push_back(searchMaxXOR(x,m));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883813,
                "title": "c-persistent-trie",
                "content": "# Intuition\\nI kind of missed the idea that we can do two pointers. Instead, I want to build a Trie, and I want to query some versions of this Trie. This is called \"persistent trie\".\\n\\n# Approach\\n\\nAdd numbers one-by-one in increasing order. Create a new Trie each time, but reuse the existing Trie as much as possible. In particular, I only need to copy the path which my newest added number is using.\\n\\nThen, when querying, find the appropriate Trie using binary search, and query the Trie as usual.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n) + n * M)$$\\n\\n- Space complexity:\\n$$O(n * M)$$\\n\\n# Code\\n```\\nstatic constexpr int M = 31;\\n\\nstruct Node;\\nvoid dfs(Node* v, int sp, int p, int jump);\\n\\nstruct Node\\n{\\n    Node *go[2];\\n\\n    Node() {\\n        go[0] = go[1] = nullptr;\\n    }\\n\\n    Node* copy()\\n    {\\n        auto ret = new Node();\\n        ret->go[0] = go[0];\\n        ret->go[1] = go[1];\\n        return ret;\\n    }\\n\\n    Node* add(int x, int bit_num)\\n    {\\n        if (bit_num < 0)\\n            return this;\\n        int bit = ((1 << bit_num) & x) > 0;\\n\\n        auto ret = copy();\\n\\n        if (go[bit] != nullptr)\\n        {\\n            ret->go[bit] = ret->go[bit]->add(x, bit_num - 1);\\n        }\\n        else\\n        {\\n            //cout << \"\\\\n\\\\nforce adding \" << x << endl;\\n            ret->go[bit] = new Node();\\n            auto v = ret->go[bit];\\n            for (int bb = bit_num - 1; bb >= 0; bb--)\\n            {\\n                int bit = ((1 << bb) & x) > 0;\\n              //  cout << bb << \" \" << bit << endl;\\n                v->go[bit] = new Node();\\n                v = v->go[bit];\\n            }\\n            //dfs(ret, 0, -1, bit_num);\\n        }\\n\\n        return ret;\\n    }\\n};\\n\\nvoid dfs(Node* v, int sp, int p, int jump)\\n{\\n    if (v == nullptr)\\n        return;\\n    cout << string(sp, \\' \\') << p << \" \" << v << \" \" << jump << endl;\\n    dfs(v->go[0], sp + 1, 0, jump - 1);\\n    dfs(v->go[1], sp + 1, 1, jump - 1);\\n}\\n\\nint query(Node *v, int x)\\n{\\n    int ret = 0;\\n    //cout << \"query \" << (x & 1) << endl;\\n    //cout << v << \" \" << x << endl;\\n    for (int i = M - 1; i >= 0; i--)\\n    {\\n        int bit = ((1 << i) & x) > 0;\\n        //cout << i << \" \" << v  << \" \" << bit << endl;\\n        //cout << \"\\\\t\" << v->go[0] << \" \" << v->go[1] << endl;\\n        if (v->go[bit ^ 1] != nullptr)\\n        {\\n          //  cout << \"adding \" << (1 << i) << endl;\\n            ret += 1 << i;\\n            v = v->go[bit ^ 1];\\n        }\\n        else\\n            v = v->go[bit];\\n    }\\n\\n    return ret;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& a, vector<vector<int>>& queries) {\\n        sort(a.begin(), a.end());\\n       /* for (int x: a)\\n            cout << x << \" \";\\n        cout << endl;*/\\n        Node *root = new Node();\\n        vector<Node*> has;\\n        has.push_back(root);\\n\\n        for (int i = 0; i < a.size(); i++)\\n        {\\n            has.push_back(has.back()->add(a[i], M - 1));\\n        }\\n\\n        vector<int> ans(queries.size(), -1);\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            auto g = upper_bound(a.begin(), a.end(), queries[i][1])\\n                - a.begin();\\n            if (g != 0)\\n                ans[i] = query(has[g], queries[i][0]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic constexpr int M = 31;\\n\\nstruct Node;\\nvoid dfs(Node* v, int sp, int p, int jump);\\n\\nstruct Node\\n{\\n    Node *go[2];\\n\\n    Node() {\\n        go[0] = go[1] = nullptr;\\n    }\\n\\n    Node* copy()\\n    {\\n        auto ret = new Node();\\n        ret->go[0] = go[0];\\n        ret->go[1] = go[1];\\n        return ret;\\n    }\\n\\n    Node* add(int x, int bit_num)\\n    {\\n        if (bit_num < 0)\\n            return this;\\n        int bit = ((1 << bit_num) & x) > 0;\\n\\n        auto ret = copy();\\n\\n        if (go[bit] != nullptr)\\n        {\\n            ret->go[bit] = ret->go[bit]->add(x, bit_num - 1);\\n        }\\n        else\\n        {\\n            //cout << \"\\\\n\\\\nforce adding \" << x << endl;\\n            ret->go[bit] = new Node();\\n            auto v = ret->go[bit];\\n            for (int bb = bit_num - 1; bb >= 0; bb--)\\n            {\\n                int bit = ((1 << bb) & x) > 0;\\n              //  cout << bb << \" \" << bit << endl;\\n                v->go[bit] = new Node();\\n                v = v->go[bit];\\n            }\\n            //dfs(ret, 0, -1, bit_num);\\n        }\\n\\n        return ret;\\n    }\\n};\\n\\nvoid dfs(Node* v, int sp, int p, int jump)\\n{\\n    if (v == nullptr)\\n        return;\\n    cout << string(sp, \\' \\') << p << \" \" << v << \" \" << jump << endl;\\n    dfs(v->go[0], sp + 1, 0, jump - 1);\\n    dfs(v->go[1], sp + 1, 1, jump - 1);\\n}\\n\\nint query(Node *v, int x)\\n{\\n    int ret = 0;\\n    //cout << \"query \" << (x & 1) << endl;\\n    //cout << v << \" \" << x << endl;\\n    for (int i = M - 1; i >= 0; i--)\\n    {\\n        int bit = ((1 << i) & x) > 0;\\n        //cout << i << \" \" << v  << \" \" << bit << endl;\\n        //cout << \"\\\\t\" << v->go[0] << \" \" << v->go[1] << endl;\\n        if (v->go[bit ^ 1] != nullptr)\\n        {\\n          //  cout << \"adding \" << (1 << i) << endl;\\n            ret += 1 << i;\\n            v = v->go[bit ^ 1];\\n        }\\n        else\\n            v = v->go[bit];\\n    }\\n\\n    return ret;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& a, vector<vector<int>>& queries) {\\n        sort(a.begin(), a.end());\\n       /* for (int x: a)\\n            cout << x << \" \";\\n        cout << endl;*/\\n        Node *root = new Node();\\n        vector<Node*> has;\\n        has.push_back(root);\\n\\n        for (int i = 0; i < a.size(); i++)\\n        {\\n            has.push_back(has.back()->add(a[i], M - 1));\\n        }\\n\\n        vector<int> ans(queries.size(), -1);\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            auto g = upper_bound(a.begin(), a.end(), queries[i][1])\\n                - a.begin();\\n            if (g != 0)\\n                ans[i] = query(has[g], queries[i][0]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3881467,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_nums + n_queries)\\n * Space Complexity: O(n_nums)\\n * where `n_nums` is the length of the vector `nums`\\n *       `n_queries` is the length of the vector `queries`\\n */\\nclass Solution {\\n private:\\n  static constexpr int binary = 2;\\n  \\n  class TrieNode {\\n   public:\\n    TrieNode() : children_{}, min_num_(numeric_limits<int>::max()) {\\n    }\\n    \\n    TrieNode* get_or_create_child(const int b) {\\n      TrieNode *&ret = children_[b];\\n      if (ret == nullptr) {\\n        ret = new TrieNode();\\n      }\\n      return ret;\\n    }\\n    \\n    TrieNode* get_child(const int b) {\\n      return children_[b];\\n    }\\n    \\n    void set_min_num(const int num) {\\n      min_num_ = min(min_num_, num);\\n    }\\n    \\n    int min_num() const {\\n      return min_num_;\\n    }\\n    \\n   private:\\n    TrieNode *children_[binary];\\n    int min_num_;\\n  };\\n  \\n  class Trie {\\n   public:\\n    Trie(const int max_offset, const vector<int> &nums) : max_offset_(max_offset) {\\n      build(nums);\\n    }\\n    \\n    int query(const int x, const int m) {\\n      TrieNode *node = &root_;\\n      if (node->min_num() > m) {\\n        return -1;\\n      }\\n      \\n      int ret = 0;\\n      for (int offset = max_offset_; offset > -1; --offset) {\\n        const int b = (x >> offset) & 1;\\n        const int flipped = b ^ 1;\\n        if (node->get_child(flipped) != nullptr && node->get_child(flipped)->min_num() <= m) {\\n          node = node->get_child(flipped);\\n          ret |= 1 << offset;\\n        } else {\\n          /**\\n           * it\\'s certain that\\n           * 1. `node->get_child(b)` is not `nullptr` and\\n           * 2. `node->get_child(b)->min_num()` is less than or equal to `m`\\n           */\\n          node = node->get_child(b);\\n        }\\n      }\\n      return ret;\\n    }\\n    \\n   private:\\n    void build(const vector<int> &nums) {\\n      for (const int num : nums) {\\n        build(num);\\n      }\\n    }\\n    \\n    void build(const int num) {\\n      TrieNode *node = &root_;\\n      for (int offset = max_offset_; offset > -1; --offset) {\\n        node->set_min_num(num);\\n        const int b = (num >> offset) & 1;\\n        node = node->get_or_create_child(b);\\n      }\\n      node->set_min_num(num);\\n    }\\n   \\n    const int max_offset_;\\n    TrieNode root_;\\n  };\\n  \\n public:\\n  vector<int> maximizeXor(const vector<int> &nums, const vector<vector<int>> &queries) {\\n    const int max_offset = get_max_offset(nums, queries);\\n    Trie trie(max_offset, nums);\\n    vector<int> ret;\\n    for (const vector<int> &query : queries) {\\n      ret.emplace_back(trie.query(query.front(), query.back()));\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int get_max_offset(const vector<int> &nums, const vector<vector<int>> &queries) {\\n    int ret = 0;\\n    for (const int num : nums) {\\n      ret = max(ret, get_max_offset(num));\\n    }\\n    for (const vector<int> &query : queries) {\\n      ret = max(ret, get_max_offset(query.front()));\\n    }\\n    return ret;\\n  }\\n  \\n  int get_max_offset(const int num) {\\n    int ret = 0;\\n    for (int number = num; number > 0; number >>= 1) {\\n      ++ret;\\n    }\\n    return ret - 1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_nums + n_queries)\\n * Space Complexity: O(n_nums)\\n * where `n_nums` is the length of the vector `nums`\\n *       `n_queries` is the length of the vector `queries`\\n */\\nclass Solution {\\n private:\\n  static constexpr int binary = 2;\\n  \\n  class TrieNode {\\n   public:\\n    TrieNode() : children_{}, min_num_(numeric_limits<int>::max()) {\\n    }\\n    \\n    TrieNode* get_or_create_child(const int b) {\\n      TrieNode *&ret = children_[b];\\n      if (ret == nullptr) {\\n        ret = new TrieNode();\\n      }\\n      return ret;\\n    }\\n    \\n    TrieNode* get_child(const int b) {\\n      return children_[b];\\n    }\\n    \\n    void set_min_num(const int num) {\\n      min_num_ = min(min_num_, num);\\n    }\\n    \\n    int min_num() const {\\n      return min_num_;\\n    }\\n    \\n   private:\\n    TrieNode *children_[binary];\\n    int min_num_;\\n  };\\n  \\n  class Trie {\\n   public:\\n    Trie(const int max_offset, const vector<int> &nums) : max_offset_(max_offset) {\\n      build(nums);\\n    }\\n    \\n    int query(const int x, const int m) {\\n      TrieNode *node = &root_;\\n      if (node->min_num() > m) {\\n        return -1;\\n      }\\n      \\n      int ret = 0;\\n      for (int offset = max_offset_; offset > -1; --offset) {\\n        const int b = (x >> offset) & 1;\\n        const int flipped = b ^ 1;\\n        if (node->get_child(flipped) != nullptr && node->get_child(flipped)->min_num() <= m) {\\n          node = node->get_child(flipped);\\n          ret |= 1 << offset;\\n        } else {\\n          /**\\n           * it\\'s certain that\\n           * 1. `node->get_child(b)` is not `nullptr` and\\n           * 2. `node->get_child(b)->min_num()` is less than or equal to `m`\\n           */\\n          node = node->get_child(b);\\n        }\\n      }\\n      return ret;\\n    }\\n    \\n   private:\\n    void build(const vector<int> &nums) {\\n      for (const int num : nums) {\\n        build(num);\\n      }\\n    }\\n    \\n    void build(const int num) {\\n      TrieNode *node = &root_;\\n      for (int offset = max_offset_; offset > -1; --offset) {\\n        node->set_min_num(num);\\n        const int b = (num >> offset) & 1;\\n        node = node->get_or_create_child(b);\\n      }\\n      node->set_min_num(num);\\n    }\\n   \\n    const int max_offset_;\\n    TrieNode root_;\\n  };\\n  \\n public:\\n  vector<int> maximizeXor(const vector<int> &nums, const vector<vector<int>> &queries) {\\n    const int max_offset = get_max_offset(nums, queries);\\n    Trie trie(max_offset, nums);\\n    vector<int> ret;\\n    for (const vector<int> &query : queries) {\\n      ret.emplace_back(trie.query(query.front(), query.back()));\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int get_max_offset(const vector<int> &nums, const vector<vector<int>> &queries) {\\n    int ret = 0;\\n    for (const int num : nums) {\\n      ret = max(ret, get_max_offset(num));\\n    }\\n    for (const vector<int> &query : queries) {\\n      ret = max(ret, get_max_offset(query.front()));\\n    }\\n    return ret;\\n  }\\n  \\n  int get_max_offset(const int num) {\\n    int ret = 0;\\n    for (int number = num; number > 0; number >>= 1) {\\n      ++ret;\\n    }\\n    return ret - 1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876740,
                "title": "c-solution-easy-to-understand-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n    Node* links[2];\\n    bool containsKey(int bit){\\n        return links[bit]!=NULL;\\n    }  \\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n    void put(int bit,Node* node){\\n        links[bit] = node;\\n    }\\n};\\nclass Solution {\\npublic:\\n    class Trie{\\n        private:Node* root;\\n        public:\\n        Trie(){\\n            root = new Node();\\n        }\\n        void insert(int num){\\n            Node* node = root;\\n            for(int i=31;i>=0;i--){\\n                int bit = (num>>i)&1;\\n                if(!(node->containsKey(bit))){\\n                    node->put(bit,new Node());\\n                }\\n                node = node->get(bit);\\n            }\\n        }\\n        int getMax(int num){\\n            Node* node = root;\\n            int ans = 0;\\n            for(int i=31;i>=0;i--){\\n                int bit = ((num>>i)&1);\\n                if(node->containsKey(!bit)){\\n                    node = node->get(!bit);\\n                    ans|=(1<<i);\\n                }\\n                else node = node->get(bit);\\n            }\\n            return ans;\\n        }\\n    };\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int>ans(queries.size(),-1);\\n        Trie t;\\n        sort(nums.begin(),nums.end());\\n        vector<pair<int,pair<int,int>>>v;\\n        for(int i=0;i<queries.size();i++){\\n            v.push_back({i,{queries[i][1],queries[i][0]}});\\n        }\\n        sort(v.begin(),v.end(),[&](pair<int,pair<int,int>>p1,pair<int,pair<int,int>>p2){\\n            if(p1.second.first==p2.second.first){\\n                return p1.first<p2.first;\\n            }\\n            return p1.second.first<p2.second.first;\\n        });\\n        int j = 0;\\n        for(int i=0;i<v.size();i++){\\n            while(j<nums.size() && nums[j]<=v[i].second.first)t.insert(nums[j++]);\\n            if(j>0)ans[v[i].first] = t.getMax(v[i].second.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[2];\\n    bool containsKey(int bit){\\n        return links[bit]!=NULL;\\n    }  \\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n    void put(int bit,Node* node){\\n        links[bit] = node;\\n    }\\n};\\nclass Solution {\\npublic:\\n    class Trie{\\n        private:Node* root;\\n        public:\\n        Trie(){\\n            root = new Node();\\n        }\\n        void insert(int num){\\n            Node* node = root;\\n            for(int i=31;i>=0;i--){\\n                int bit = (num>>i)&1;\\n                if(!(node->containsKey(bit))){\\n                    node->put(bit,new Node());\\n                }\\n                node = node->get(bit);\\n            }\\n        }\\n        int getMax(int num){\\n            Node* node = root;\\n            int ans = 0;\\n            for(int i=31;i>=0;i--){\\n                int bit = ((num>>i)&1);\\n                if(node->containsKey(!bit)){\\n                    node = node->get(!bit);\\n                    ans|=(1<<i);\\n                }\\n                else node = node->get(bit);\\n            }\\n            return ans;\\n        }\\n    };\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int>ans(queries.size(),-1);\\n        Trie t;\\n        sort(nums.begin(),nums.end());\\n        vector<pair<int,pair<int,int>>>v;\\n        for(int i=0;i<queries.size();i++){\\n            v.push_back({i,{queries[i][1],queries[i][0]}});\\n        }\\n        sort(v.begin(),v.end(),[&](pair<int,pair<int,int>>p1,pair<int,pair<int,int>>p2){\\n            if(p1.second.first==p2.second.first){\\n                return p1.first<p2.first;\\n            }\\n            return p1.second.first<p2.second.first;\\n        });\\n        int j = 0;\\n        for(int i=0;i<v.size();i++){\\n            while(j<nums.size() && nums[j]<=v[i].second.first)t.insert(nums[j++]);\\n            if(j>0)ans[v[i].first] = t.getMax(v[i].second.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876420,
                "title": "c-trie-solution",
                "content": "# Intuition\\nJust a typical Trie problem where we have to insert each and every number into Trie and try to get the maximum XOR for the given queries.\\nWe have to do one thing based on constriants given, like we should only take values which are less than `m` for each query.\\n\\n# Approach\\nSo how to build trie, so what you can think is like first try to sort the given nums array and with this you will have smallest numbers at first and so on. Now take the queries and sort it according to the `m` defined. This will allow us to move the query array that we have built and we can push the numbers into the trie until the `m` is greater than or equal to the nums[i]. This way we can easily move on.\\n\\n\\nHow to calculate the maximum XOR?\\nProperty of XOR -\\n1) 1 ^ 0 = 0 ^ 1 => 1\\n2) 1 ^ 1 = 0 ^ 0 => 0\\n\\nNow we can get idea right so we have to find as many possible 1 and thus we can get maximum XOR for the number which will help us.\\nFor finding the maximum number we have to go through the trie we have built so far and whenever we have `bit opposite to the current bit` we can choose the path and move forward.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N)) + O(M) + O(M*log(M)) * O(N*32 + M*32) - Sorting the nums array  + For creating the query array + sorting and creating the Trie + inserting and calculating the maximum XOR.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(32*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node {\\n    Node *links[2];\\n    int val;\\n    public: \\n    Node() {\\n        links[0] = links[1] = NULL;\\n        val = 0;\\n    }\\n    ~Node() {\\n        if(links[0]) {\\n            delete links[0];\\n        }\\n        if(links[1]) {\\n            delete links[1];\\n        }\\n    }\\n\\n    bool contains(int bit) {\\n        return this->links[bit];\\n    }\\n    Node *getNext(int bit) {\\n        return this->links[bit];\\n    }\\n    void createNode(int bit, Node *node) {\\n        this->links[bit] = node;\\n    }\\n    void setValue(int num) {\\n        this->val = num;\\n    }\\n    int getValue() {\\n        return this->val;\\n    }\\n};\\n\\n\\nvoid insert(int num, Node **root) {\\n    Node *temp = *root;\\n    for(int i=31;i>=0;i--) {\\n        bool bit = (num>>i & 1);\\n        if(!temp->contains(bit)) {\\n            temp->createNode(bit, new Node());\\n        }\\n        temp = temp->getNext(bit);\\n    }\\n    temp->setValue(num);\\n}\\n\\nint maxiXOR(int num, Node *root) {\\n    Node *temp = root;\\n    for(int i=31;i>=0;i--) {\\n        bool bit = (num>>i & 1);\\n        if(temp->contains(!bit)) {\\n            temp = temp->getNext(!bit);\\n        }\\n        else {\\n            temp = temp->getNext(bit);\\n        }\\n    }\\n    return temp->getValue();\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Node *root = new Node();\\n        vector<int> ans(queries.size(), -1);\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, pair<int, int>>> query;\\n        int index = 0;\\n        for(auto &it : queries) {\\n            query.push_back({it[1], {it[0], index++}});\\n        }\\n        sort(query.begin(), query.end());\\n        int i=0;\\n        for(auto &it:query) {\\n            while(i<nums.size() && it.first >= nums[i]) {\\n                insert(nums[i], &root);\\n                i++;\\n            }\\n            if(i!=0) {\\n                ans[it.second.second] = maxiXOR(it.second.first, root)^it.second.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node {\\n    Node *links[2];\\n    int val;\\n    public: \\n    Node() {\\n        links[0] = links[1] = NULL;\\n        val = 0;\\n    }\\n    ~Node() {\\n        if(links[0]) {\\n            delete links[0];\\n        }\\n        if(links[1]) {\\n            delete links[1];\\n        }\\n    }\\n\\n    bool contains(int bit) {\\n        return this->links[bit];\\n    }\\n    Node *getNext(int bit) {\\n        return this->links[bit];\\n    }\\n    void createNode(int bit, Node *node) {\\n        this->links[bit] = node;\\n    }\\n    void setValue(int num) {\\n        this->val = num;\\n    }\\n    int getValue() {\\n        return this->val;\\n    }\\n};\\n\\n\\nvoid insert(int num, Node **root) {\\n    Node *temp = *root;\\n    for(int i=31;i>=0;i--) {\\n        bool bit = (num>>i & 1);\\n        if(!temp->contains(bit)) {\\n            temp->createNode(bit, new Node());\\n        }\\n        temp = temp->getNext(bit);\\n    }\\n    temp->setValue(num);\\n}\\n\\nint maxiXOR(int num, Node *root) {\\n    Node *temp = root;\\n    for(int i=31;i>=0;i--) {\\n        bool bit = (num>>i & 1);\\n        if(temp->contains(!bit)) {\\n            temp = temp->getNext(!bit);\\n        }\\n        else {\\n            temp = temp->getNext(bit);\\n        }\\n    }\\n    return temp->getValue();\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Node *root = new Node();\\n        vector<int> ans(queries.size(), -1);\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, pair<int, int>>> query;\\n        int index = 0;\\n        for(auto &it : queries) {\\n            query.push_back({it[1], {it[0], index++}});\\n        }\\n        sort(query.begin(), query.end());\\n        int i=0;\\n        for(auto &it:query) {\\n            while(i<nums.size() && it.first >= nums[i]) {\\n                insert(nums[i], &root);\\n                i++;\\n            }\\n            if(i!=0) {\\n                ans[it.second.second] = maxiXOR(it.second.first, root)^it.second.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875414,
                "title": "trie-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Trie{\\n    Trie* child[2];\\n    int val;\\n    public:\\n    Trie(): child{nullptr, nullptr}, val(0){}\\n\\n    void insert(int& n){\\n        Trie* t = this;\\n        for(int i=31; i>=0; i--){\\n            bool bit = n & (1<<i);\\n            if(t->child[bit] == nullptr)\\n            t->child[bit] = new Trie();\\n\\n            t = t->child[bit];\\n        }\\n        t->val = n;\\n    }\\n\\n    int maxXor(int& n){\\n        Trie* t = this;\\n        for(int i=31; i>=0; i--){\\n            bool bit = n & (1<<i);\\n            if(t->child[!bit] != nullptr)\\n            t = t->child[!bit];\\n            else t = t->child[bit];\\n        }\\n        return (t->val ^ n);\\n    }\\n};\\n\\nbool comp(vector<int>& v1, vector<int>& v2){\\n    return v1[1] < v2[1];\\n} \\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<vector<int>> queries_t;\\n        vector<vector<int>> res_t;\\n        vector<int> res;\\n        int i=0;\\n        for(auto query : queries){\\n           query.push_back(i);\\n           queries_t.push_back(query);\\n           i++;\\n        }\\n        sort(queries_t.begin(), queries_t.end(), comp);\\n        sort(nums.begin(), nums.end());\\n        Trie* root = new Trie();\\n        int j=0, n = nums.size();\\n        for(auto& query : queries_t){\\n            while(j < n && nums[j] <= query[1]){\\n                root->insert(nums[j]);\\n                j++;\\n            }\\n            if(j==0){\\n                res_t.push_back({-1, query[2]});\\n            }\\n            else{\\n                int currRes = root->maxXor(query[0]);\\n                res_t.push_back({currRes, query[2]});\\n            }\\n        }\\n        sort(res_t.begin(), res_t.end(), comp);\\n        for(auto& vec : res_t){\\n            res.push_back(vec[0]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Trie{\\n    Trie* child[2];\\n    int val;\\n    public:\\n    Trie(): child{nullptr, nullptr}, val(0){}\\n\\n    void insert(int& n){\\n        Trie* t = this;\\n        for(int i=31; i>=0; i--){\\n            bool bit = n & (1<<i);\\n            if(t->child[bit] == nullptr)\\n            t->child[bit] = new Trie();\\n\\n            t = t->child[bit];\\n        }\\n        t->val = n;\\n    }\\n\\n    int maxXor(int& n){\\n        Trie* t = this;\\n        for(int i=31; i>=0; i--){\\n            bool bit = n & (1<<i);\\n            if(t->child[!bit] != nullptr)\\n            t = t->child[!bit];\\n            else t = t->child[bit];\\n        }\\n        return (t->val ^ n);\\n    }\\n};\\n\\nbool comp(vector<int>& v1, vector<int>& v2){\\n    return v1[1] < v2[1];\\n} \\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<vector<int>> queries_t;\\n        vector<vector<int>> res_t;\\n        vector<int> res;\\n        int i=0;\\n        for(auto query : queries){\\n           query.push_back(i);\\n           queries_t.push_back(query);\\n           i++;\\n        }\\n        sort(queries_t.begin(), queries_t.end(), comp);\\n        sort(nums.begin(), nums.end());\\n        Trie* root = new Trie();\\n        int j=0, n = nums.size();\\n        for(auto& query : queries_t){\\n            while(j < n && nums[j] <= query[1]){\\n                root->insert(nums[j]);\\n                j++;\\n            }\\n            if(j==0){\\n                res_t.push_back({-1, query[2]});\\n            }\\n            else{\\n                int currRes = root->maxXor(query[0]);\\n                res_t.push_back({currRes, query[2]});\\n            }\\n        }\\n        sort(res_t.begin(), res_t.end(), comp);\\n        for(auto& vec : res_t){\\n            res.push_back(vec[0]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869250,
                "title": "trie-solution-easy-c",
                "content": "\\n# Code\\n```\\nstruct Node{\\n    Node* links[2];\\n\\n    bool contains(int bit){\\n        return links[bit] != NULL;\\n    }\\n\\n    void put(int bit, Node* node){\\n        links[bit] = node;\\n    }\\n\\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie{\\n    private: \\n        Node* root;\\n    public: \\n        Trie(){\\n            root = new Node();\\n        }\\n\\n        void insert(int num){\\n            Node* node = root;\\n            for(int i = 31;i>=0;i--){\\n                int bit = (num>>i) &1;\\n                if(!node->contains(bit)){\\n                    node->put(bit, new Node());\\n                }\\n                node = node->get(bit);\\n            }\\n        }\\n\\n        int getMax(int num){\\n            Node* node = root;\\n            int mxNum = 0;\\n            for(int i= 31;i>=0;i--){\\n                int bit = (num>>i)&1;\\n                if(!node->contains(1-bit)){\\n                    node = node->get(bit);\\n                }\\n                else{\\n                    mxNum = mxNum | (1<<i);\\n                    node = node->get(1-bit);\\n                }\\n            }\\n            return mxNum;\\n        }\\n};\\n\\nbool mycomp(pair<int, pair<int, int>> a, pair<int, pair<int, int>> b){\\n    return a.second.second < b.second.second;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size());\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, pair<int,int>>> q;\\n        for(int i=0; i < queries.size(); i++){\\n            q.push_back(make_pair(i, make_pair(queries[i][0], queries[i][1])));\\n        }\\n\\n        sort(q.begin(), q.end(), mycomp);\\n\\n        Trie trie;\\n        int idx = 0;\\n        \\n        for(int i=0; i < queries.size(); i++){\\n            while(idx < nums.size() && nums[idx] <= q[i].second.second){\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n            if(idx == 0) ans[q[i].first] = (-1);\\n            else ans[q[i].first] = trie.getMax(q[i].second.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[2];\\n\\n    bool contains(int bit){\\n        return links[bit] != NULL;\\n    }\\n\\n    void put(int bit, Node* node){\\n        links[bit] = node;\\n    }\\n\\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie{\\n    private: \\n        Node* root;\\n    public: \\n        Trie(){\\n            root = new Node();\\n        }\\n\\n        void insert(int num){\\n            Node* node = root;\\n            for(int i = 31;i>=0;i--){\\n                int bit = (num>>i) &1;\\n                if(!node->contains(bit)){\\n                    node->put(bit, new Node());\\n                }\\n                node = node->get(bit);\\n            }\\n        }\\n\\n        int getMax(int num){\\n            Node* node = root;\\n            int mxNum = 0;\\n            for(int i= 31;i>=0;i--){\\n                int bit = (num>>i)&1;\\n                if(!node->contains(1-bit)){\\n                    node = node->get(bit);\\n                }\\n                else{\\n                    mxNum = mxNum | (1<<i);\\n                    node = node->get(1-bit);\\n                }\\n            }\\n            return mxNum;\\n        }\\n};\\n\\nbool mycomp(pair<int, pair<int, int>> a, pair<int, pair<int, int>> b){\\n    return a.second.second < b.second.second;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size());\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, pair<int,int>>> q;\\n        for(int i=0; i < queries.size(); i++){\\n            q.push_back(make_pair(i, make_pair(queries[i][0], queries[i][1])));\\n        }\\n\\n        sort(q.begin(), q.end(), mycomp);\\n\\n        Trie trie;\\n        int idx = 0;\\n        \\n        for(int i=0; i < queries.size(); i++){\\n            while(idx < nums.size() && nums[idx] <= q[i].second.second){\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n            if(idx == 0) ans[q[i].first] = (-1);\\n            else ans[q[i].first] = trie.getMax(q[i].second.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814304,
                "title": "simple-c-solution",
                "content": "# Intuition\\ninsert an element of nums only when its value is less than queries at that moment(after sorting queries by its queries[i][1]) \\n\\n# Approach\\neg:nums:{0,1,2,3,4} queries:{{3,2},{4,1}} after sorting {{1,4},{2,3}}.\\nbefore first query insert only {0,1} then later insert {2} into trie\\n\\nnow the question is nothing but finding maximum xor \\n\\n# Code\\n```\\nstruct Node{\\n    Node *links[2];\\n    bool containkey(int bit){\\n        if(links[bit]==NULL)return false;\\n        return true;\\n    }\\n    void  put(int bit,Node *node){\\n        links[bit]=node;\\n    }\\n    Node *get(int bit){\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\n    Node *root;\\n    public:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int num){\\n        Node *node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(!node->containkey(bit)){\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n    int f(int num){\\n        int maxi=0;\\n        Node *node=root;\\n        for(int i=31;i>=0;i--){\\n            int n=num;\\n            int bit=(n>>i)&1;\\n           if(node->containkey(1-bit)){\\n                maxi=maxi|(1<<i);\\n                node=node->get(1-bit);\\n            } \\n           else node=node->get(bit); \\n        }\\n        return maxi;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        vector<vector<int>>a;\\n        int n=queries.size();\\n        vector<int>b(n,-1);\\n       for(int i=0;i<queries.size();i++){\\n          a.push_back({queries[i][1],queries[i][0],i});\\n       } \\n      \\n       sort(a.begin(),a.end());\\n       sort(nums.begin(),nums.end());\\n       int i=0;\\n       for(int j=0;j<a.size();j++){\\n           int c=-1;\\n          while(i<nums.size()&&nums[i]<=a[j][0])trie.insert(nums[i]),i++;\\n          if(i>0)\\n          c= trie.f(a[j][1]);\\n         b[a[j][2]]=c;\\n       }\\n       return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node{\\n    Node *links[2];\\n    bool containkey(int bit){\\n        if(links[bit]==NULL)return false;\\n        return true;\\n    }\\n    void  put(int bit,Node *node){\\n        links[bit]=node;\\n    }\\n    Node *get(int bit){\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\n    Node *root;\\n    public:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int num){\\n        Node *node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(!node->containkey(bit)){\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n    int f(int num){\\n        int maxi=0;\\n        Node *node=root;\\n        for(int i=31;i>=0;i--){\\n            int n=num;\\n            int bit=(n>>i)&1;\\n           if(node->containkey(1-bit)){\\n                maxi=maxi|(1<<i);\\n                node=node->get(1-bit);\\n            } \\n           else node=node->get(bit); \\n        }\\n        return maxi;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        vector<vector<int>>a;\\n        int n=queries.size();\\n        vector<int>b(n,-1);\\n       for(int i=0;i<queries.size();i++){\\n          a.push_back({queries[i][1],queries[i][0],i});\\n       } \\n      \\n       sort(a.begin(),a.end());\\n       sort(nums.begin(),nums.end());\\n       int i=0;\\n       for(int j=0;j<a.size();j++){\\n           int c=-1;\\n          while(i<nums.size()&&nums[i]<=a[j][0])trie.insert(nums[i]),i++;\\n          if(i>0)\\n          c= trie.f(a[j][1]);\\n         b[a[j][2]]=c;\\n       }\\n       return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811729,
                "title": "easy-c-using-trie",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(Q+N)$$ where Q=queries.size(),     N=nums.size()\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n    Node*links[2];\\n    bool containsKey(int bit){\\n        return links[bit]!=NULL;\\n    }\\n    Node*getBit(int bit){\\n        return links[bit];\\n    }\\n    void put(int bit,Node*node){\\n        links[bit]=node;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    Node*root;\\npublic:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int num){\\n        Node*node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit,new Node());\\n            }\\n            node=node->getBit(bit);\\n        }\\n    }\\n    int getmax(int num){\\n        Node*node=root;\\n        int maxi=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(node->containsKey(1-bit)){\\n                maxi=maxi | (1<<i);\\n                node=node->getBit(1-bit);\\n            }else node=node->getBit(bit);\\n        }\\n        return maxi;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int q=queries.size();\\n        vector<pair<int,pair<int,int>>>oQ;\\n        for(int i=0;i<q;i++){\\n            oQ.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n        sort(oQ.begin(),oQ.end());\\n        int ind=0,n=nums.size();\\n        Trie T;\\n        vector<int>ans(q,0);\\n        for(int i=0;i<q;i++){\\n            int ai=oQ[i].first;\\n            int xi=oQ[i].second.first;\\n            int qind=oQ[i].second.second;\\n            while(ind<n and nums[ind]<=ai){\\n                T.insert(nums[ind]);\\n                ind++;\\n            }\\n            if(ind==0)ans[qind]=-1;\\n            else ans[qind]=T.getmax(xi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node{\\n    Node*links[2];\\n    bool containsKey(int bit){\\n        return links[bit]!=NULL;\\n    }\\n    Node*getBit(int bit){\\n        return links[bit];\\n    }\\n    void put(int bit,Node*node){\\n        links[bit]=node;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    Node*root;\\npublic:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int num){\\n        Node*node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit,new Node());\\n            }\\n            node=node->getBit(bit);\\n        }\\n    }\\n    int getmax(int num){\\n        Node*node=root;\\n        int maxi=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(node->containsKey(1-bit)){\\n                maxi=maxi | (1<<i);\\n                node=node->getBit(1-bit);\\n            }else node=node->getBit(bit);\\n        }\\n        return maxi;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(),nums.end());\\n        int q=queries.size();\\n        vector<pair<int,pair<int,int>>>oQ;\\n        for(int i=0;i<q;i++){\\n            oQ.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n        sort(oQ.begin(),oQ.end());\\n        int ind=0,n=nums.size();\\n        Trie T;\\n        vector<int>ans(q,0);\\n        for(int i=0;i<q;i++){\\n            int ai=oQ[i].first;\\n            int xi=oQ[i].second.first;\\n            int qind=oQ[i].second.second;\\n            while(ind<n and nums[ind]<=ai){\\n                T.insert(nums[ind]);\\n                ind++;\\n            }\\n            if(ind==0)ans[qind]=-1;\\n            else ans[qind]=T.getmax(xi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808405,
                "title": "trie-and-bit-manipulation",
                "content": "# Code\\n```\\nstruct Node\\n{\\n    Node* length[2];\\n    void put(int bit,Node* node)\\n    {\\n        length[bit]=node;\\n    }\\n\\n    Node* get(int bit)\\n    {\\n        return length[bit];\\n    }\\n\\n    bool containsKey(int bit)\\n    {\\n        return (length[bit]!=NULL);\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void insert(int num,Node* root)\\n    {\\n            Node *node= root;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int currbit=(num>>i) & 1;\\n                if(!node->containsKey(currbit))\\n                {\\n                    node->put(currbit,new Node());\\n                }\\n                node=node->get(currbit);\\n            } \\n    }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> query;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n         query.push_back({queries[i][1],queries[i][0],i});\\n        }\\n\\n        int ms=query.size();\\n        int n=nums.size();\\n\\n        sort(query.begin(),query.end());\\n        vector<int> result(ms);\\n\\n        Node* root=new Node();\\n        int index=0;\\n        for(int i=0;i<ms;i++)\\n        {\\n            int x=query[i][1];\\n            int m=query[i][0];\\n            int pos=query[i][2];\\n            while(index<n && nums[index]<=m)\\n            {\\n                insert(nums[index],root);\\n                index++;\\n            }\\n            if(index==0)\\n             result[pos]=-1;\\n            else\\n            {\\n            int currSum=0;\\n            Node* node=root;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int req=1-((x>>i)&1);\\n                if(node->containsKey(req))\\n                {\\n                 currSum |= (1<<i);\\n                 node=node->get(req);\\n                }\\n                else\\n                {\\n                    node=node->get(1-req);\\n                }\\n            }\\n            result[pos]=currSum;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node\\n{\\n    Node* length[2];\\n    void put(int bit,Node* node)\\n    {\\n        length[bit]=node;\\n    }\\n\\n    Node* get(int bit)\\n    {\\n        return length[bit];\\n    }\\n\\n    bool containsKey(int bit)\\n    {\\n        return (length[bit]!=NULL);\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void insert(int num,Node* root)\\n    {\\n            Node *node= root;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int currbit=(num>>i) & 1;\\n                if(!node->containsKey(currbit))\\n                {\\n                    node->put(currbit,new Node());\\n                }\\n                node=node->get(currbit);\\n            } \\n    }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> query;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n         query.push_back({queries[i][1],queries[i][0],i});\\n        }\\n\\n        int ms=query.size();\\n        int n=nums.size();\\n\\n        sort(query.begin(),query.end());\\n        vector<int> result(ms);\\n\\n        Node* root=new Node();\\n        int index=0;\\n        for(int i=0;i<ms;i++)\\n        {\\n            int x=query[i][1];\\n            int m=query[i][0];\\n            int pos=query[i][2];\\n            while(index<n && nums[index]<=m)\\n            {\\n                insert(nums[index],root);\\n                index++;\\n            }\\n            if(index==0)\\n             result[pos]=-1;\\n            else\\n            {\\n            int currSum=0;\\n            Node* node=root;\\n            for(int i=31;i>=0;i--)\\n            {\\n                int req=1-((x>>i)&1);\\n                if(node->containsKey(req))\\n                {\\n                 currSum |= (1<<i);\\n                 node=node->get(req);\\n                }\\n                else\\n                {\\n                    node=node->get(1-req);\\n                }\\n            }\\n            result[pos]=currSum;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802424,
                "title": "self-explanatory-code-in-cpp-using-trie",
                "content": "# Approach: Use Trie Data Structure\\n# Code\\n```\\nclass Node\\n{\\n    vector<Node*>children;\\npublic:\\n    Node()\\n    {\\n        children.resize(2,NULL);\\n    }\\n    bool isSet(int bit)\\n    {\\n        return children[bit];\\n    }\\n    void setNode(int bit)\\n    {\\n        children[bit]=new Node();\\n    }\\n    Node* getNode(int bit)\\n    {\\n        return children[bit];\\n    }\\n};\\nclass Trie\\n{\\n    Node* root;\\npublic:\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node* ptr=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(!ptr->isSet(bit))\\n                ptr->setNode(bit);\\n            ptr=ptr->getNode(bit);\\n        }\\n    }\\n    int getMax(int num)\\n    {\\n        Node* ptr=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(ptr->isSet(!bit))\\n            {\\n                maxNum|=(1<<i);\\n                ptr=ptr->getNode(!bit);\\n            }\\n            else\\n                ptr=ptr->getNode(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>que;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            que.push_back({queries[i][1],queries[i][0],i});\\n        }\\n        sort(que.begin(),que.end());\\n        vector<int>ans(que.size());\\n        Trie tr;\\n        int ind=0;\\n        int i=0;\\n        while(ind<que.size())\\n        {\\n            int index=que[ind][2];\\n            int val=que[ind][0];\\n            int xorNum=que[ind][1];\\n            while(i<nums.size() and nums[i]<=val)\\n            {\\n                tr.insert(nums[i]);\\n                i++;\\n            }\\n            if(i==0)    ans[index]=-1;\\n            else    ans[index]=tr.getMax(xorNum);\\n            ind++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo upvote if you like the approach \\uD83D\\uDC96",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Node\\n{\\n    vector<Node*>children;\\npublic:\\n    Node()\\n    {\\n        children.resize(2,NULL);\\n    }\\n    bool isSet(int bit)\\n    {\\n        return children[bit];\\n    }\\n    void setNode(int bit)\\n    {\\n        children[bit]=new Node();\\n    }\\n    Node* getNode(int bit)\\n    {\\n        return children[bit];\\n    }\\n};\\nclass Trie\\n{\\n    Node* root;\\npublic:\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node* ptr=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(!ptr->isSet(bit))\\n                ptr->setNode(bit);\\n            ptr=ptr->getNode(bit);\\n        }\\n    }\\n    int getMax(int num)\\n    {\\n        Node* ptr=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(ptr->isSet(!bit))\\n            {\\n                maxNum|=(1<<i);\\n                ptr=ptr->getNode(!bit);\\n            }\\n            else\\n                ptr=ptr->getNode(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>que;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            que.push_back({queries[i][1],queries[i][0],i});\\n        }\\n        sort(que.begin(),que.end());\\n        vector<int>ans(que.size());\\n        Trie tr;\\n        int ind=0;\\n        int i=0;\\n        while(ind<que.size())\\n        {\\n            int index=que[ind][2];\\n            int val=que[ind][0];\\n            int xorNum=que[ind][1];\\n            while(i<nums.size() and nums[i]<=val)\\n            {\\n                tr.insert(nums[i]);\\n                i++;\\n            }\\n            if(i==0)    ans[index]=-1;\\n            else    ans[index]=tr.getMax(xorNum);\\n            ind++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797324,
                "title": "trie-bit-manipulation-o-nlogn-qlogq-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TrieNode{\\n    public:\\n    TrieNode*links[2];\\n    bool isEnd=false;\\n};\\n\\nclass Trie{\\n    public:\\n    TrieNode*root;\\n    Trie(){\\n        root=new TrieNode();\\n    }\\n\\n    void insert(int num){\\n        TrieNode*curr=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(!curr->links[bit])curr->links[bit]=new TrieNode();\\n            curr=curr->links[bit];\\n        }\\n    }\\n\\n    int getMax(int num){\\n        int maxNum=0;\\n        TrieNode*curr=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            int opp=1-bit;\\n            if(curr->links[opp]){\\n                curr=curr->links[opp];\\n                maxNum=maxNum|(1<<i);\\n            }\\n            else curr=curr->links[bit];\\n        }\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int>v=nums;\\n        sort(v.begin(),v.end());\\n        vector<vector<int>>q=queries;\\n        for(int i=0;i<q.size();i++){\\n            reverse(q[i].begin(),q[i].end());\\n            q[i].push_back(i);\\n        }\\n        sort(q.begin(),q.end());\\n        vector<int>ans(q.size());\\n        int ptr=0;\\n        Trie trie;\\n        for(int i=0;i<q.size();i++){\\n            while(ptr<v.size()&&v[ptr]<=q[i][0])trie.insert(v[ptr++]);\\n            if(ptr==0)ans[q[i][2]]=-1;\\n            else ans[q[i][2]]=trie.getMax(q[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TrieNode{\\n    public:\\n    TrieNode*links[2];\\n    bool isEnd=false;\\n};\\n\\nclass Trie{\\n    public:\\n    TrieNode*root;\\n    Trie(){\\n        root=new TrieNode();\\n    }\\n\\n    void insert(int num){\\n        TrieNode*curr=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(!curr->links[bit])curr->links[bit]=new TrieNode();\\n            curr=curr->links[bit];\\n        }\\n    }\\n\\n    int getMax(int num){\\n        int maxNum=0;\\n        TrieNode*curr=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            int opp=1-bit;\\n            if(curr->links[opp]){\\n                curr=curr->links[opp];\\n                maxNum=maxNum|(1<<i);\\n            }\\n            else curr=curr->links[bit];\\n        }\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int>v=nums;\\n        sort(v.begin(),v.end());\\n        vector<vector<int>>q=queries;\\n        for(int i=0;i<q.size();i++){\\n            reverse(q[i].begin(),q[i].end());\\n            q[i].push_back(i);\\n        }\\n        sort(q.begin(),q.end());\\n        vector<int>ans(q.size());\\n        int ptr=0;\\n        Trie trie;\\n        for(int i=0;i<q.size();i++){\\n            while(ptr<v.size()&&v[ptr]<=q[i][0])trie.insert(v[ptr++]);\\n            if(ptr==0)ans[q[i][2]]=-1;\\n            else ans[q[i][2]]=trie.getMax(q[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779918,
                "title": "easy-c-solution-with-comments",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n))+O(n*log(n))+O(n*log(n))+O(32*32*n)$$ \\n# Code\\n```\\nstruct Node{\\n    Node* ref[2];\\n    Node(){\\n        for(int i=0;i<2;i++) ref[i]=NULL;\\n    }\\n    Node* get_next(){\\n        return new Node();\\n    }\\n    Node* move_next(int i){\\n        return this->ref[i];\\n    }\\n};\\nstruct store{\\n    int x,m,i;\\n    store(int _x,int _m,int _i){\\n        x=_x;\\n        m=_m;\\n        i=_i;\\n    }\\n};\\nclass Solution {\\nprivate:\\n    Node* root;\\npublic:\\n    Solution(){\\n        root=new Node();\\n    }\\n    static bool cmp(store s1,store s2){\\n        if(s1.m<s2.m) return true;\\n        return false;\\n    }\\n    void insert(int num){\\n        Node* temp=root;\\n        for(int i=31;i>=0;i--){\\n            if(temp->ref[num>>i & 1]==NULL) temp->ref[num>>i & 1]=temp->get_next();\\n            temp=temp->move_next(num>>i & 1);\\n        }\\n    }\\n    int get_max(int num){\\n        int number=0;\\n        Node* temp=root;\\n        for(int i=31;i>=0;i--){\\n            bool bit_needed;\\n            if(num>>i & 1) bit_needed=false;\\n            else bit_needed=true;\\n            if(temp->ref[bit_needed]!=NULL){\\n                if(bit_needed) number=number | 1<<i;\\n                temp=temp->move_next(bit_needed);\\n            }\\n            else{\\n                if(!bit_needed) number=number | 1<<i;\\n                temp=temp->move_next(!bit_needed);\\n            }\\n        }\\n        return number;\\n    }\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        // sort the values in the num\\n        sort(nums.begin(),nums.end());\\n        // store the queries in from of x,a,index\\n        vector<store>q;\\n        for(int i=0;i<queries.size();i++){\\n            q.push_back(store(queries[i][0],queries[i][1],i));\\n        }\\n        // sort the queries\\n        sort(q.begin(),q.end(),cmp);\\n        // vector to store the result \\n        vector<int>res(q.size(),-1);\\n        // now start finding the results\\n        int start_index=0;\\n        for(int i=0;i<q.size();i++){\\n            int _x=q[i].x;\\n            int _m=q[i].m;\\n            int index=q[i].i;\\n            auto it=upper_bound(nums.begin(),nums.end(),_m)-nums.begin();\\n            if(it==0) continue;\\n            // first insert numbers from index start_index to it-1;\\n            for(int j=start_index;j<it;j++){\\n                insert(nums[j]);\\n            }\\n            start_index=it-1;\\n            // now find the max_xor for the number _x\\n            res[index]=_x^get_max(_x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* ref[2];\\n    Node(){\\n        for(int i=0;i<2;i++) ref[i]=NULL;\\n    }\\n    Node* get_next(){\\n        return new Node();\\n    }\\n    Node* move_next(int i){\\n        return this->ref[i];\\n    }\\n};\\nstruct store{\\n    int x,m,i;\\n    store(int _x,int _m,int _i){\\n        x=_x;\\n        m=_m;\\n        i=_i;\\n    }\\n};\\nclass Solution {\\nprivate:\\n    Node* root;\\npublic:\\n    Solution(){\\n        root=new Node();\\n    }\\n    static bool cmp(store s1,store s2){\\n        if(s1.m<s2.m) return true;\\n        return false;\\n    }\\n    void insert(int num){\\n        Node* temp=root;\\n        for(int i=31;i>=0;i--){\\n            if(temp->ref[num>>i & 1]==NULL) temp->ref[num>>i & 1]=temp->get_next();\\n            temp=temp->move_next(num>>i & 1);\\n        }\\n    }\\n    int get_max(int num){\\n        int number=0;\\n        Node* temp=root;\\n        for(int i=31;i>=0;i--){\\n            bool bit_needed;\\n            if(num>>i & 1) bit_needed=false;\\n            else bit_needed=true;\\n            if(temp->ref[bit_needed]!=NULL){\\n                if(bit_needed) number=number | 1<<i;\\n                temp=temp->move_next(bit_needed);\\n            }\\n            else{\\n                if(!bit_needed) number=number | 1<<i;\\n                temp=temp->move_next(!bit_needed);\\n            }\\n        }\\n        return number;\\n    }\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        // sort the values in the num\\n        sort(nums.begin(),nums.end());\\n        // store the queries in from of x,a,index\\n        vector<store>q;\\n        for(int i=0;i<queries.size();i++){\\n            q.push_back(store(queries[i][0],queries[i][1],i));\\n        }\\n        // sort the queries\\n        sort(q.begin(),q.end(),cmp);\\n        // vector to store the result \\n        vector<int>res(q.size(),-1);\\n        // now start finding the results\\n        int start_index=0;\\n        for(int i=0;i<q.size();i++){\\n            int _x=q[i].x;\\n            int _m=q[i].m;\\n            int index=q[i].i;\\n            auto it=upper_bound(nums.begin(),nums.end(),_m)-nums.begin();\\n            if(it==0) continue;\\n            // first insert numbers from index start_index to it-1;\\n            for(int j=start_index;j<it;j++){\\n                insert(nums[j]);\\n            }\\n            start_index=it-1;\\n            // now find the max_xor for the number _x\\n            res[index]=_x^get_max(_x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772829,
                "title": "maximum-xor-with-a-given-limit-easy-approach",
                "content": "\\n# Problem Statement:\\nYou are given an array of non-negative integers nums and an array queries where queries[i] = [xi, mi].\\nFor each query, find a maximum XOR value of xi and any number from the array nums that is less than or equal to mi.\\nThe XOR value is defined as xi XOR nums[j], where j is the index of the chosen number.\\n\\n# Intuition:\\nTo solve this problem efficiently, we can use the Trie data structure. We insert all the numbers from the nums array into the Trie and then process the queries one by one.\\nFor each query, we start from the most significant bit and traverse the Trie based on the bits of the query number xi.\\nAt each bit position, we try to go in the opposite direction (bit 0 if the current bit is 1, and bit 1 if the current bit is 0) if it exists in the Trie.\\nBy doing this, we ensure that the XOR value will have the maximum number of bits set to 1.\\nFinally, we return the maximum XOR value found for each query.\\n\\n# Approach:\\n1. Define a Node class to represent the Trie node. Each node has two possible children: 0 and 1.\\n   - The children array is used to store the references to the child nodes.\\n\\n2. Define a Trie class to implement the Trie data structure.\\n   - The root node is initialized in the constructor.\\n   - The insert function is used to insert a number into the Trie:\\n     - Start from the root node.\\n     - Traverse the binary representation of the number from the most significant bit to the least significant bit.\\n     - Create a new child node if it doesn\\'t exist.\\n     - Move to the child node.\\n   - The getMaxXOR function retrieves the maximum XOR value for a given number:\\n     - Start from the root node.\\n     - Traverse the binary representation of the number from the most significant bit to the least significant bit.\\n     - Check if the opposite bit child node exists:\\n       - If it exists, set the corresponding bit of the XOR value to 1 and move to the opposite bit child node.\\n       - If it doesn\\'t exist, move to the current bit child node.\\n     - Return the maximum XOR value.\\n\\n3. Define the Solution class to solve the problem.\\n   - Sort the nums array in ascending order.\\n   - Initialize a vector result to store the answers for the queries.\\n   - Add the query index to each query for tracking the answer.\\n   - Sort the queries based on the maximum limit in ascending order.\\n   - Create an instance of the Trie class.\\n   - Initialize a variable numsIndex to track the index of the numbers from the nums array.\\n   - Iterate through each query:\\n     - Extract the number xi, maximum limit mi, and query index from the query.\\n     - Insert numbers into the Trie until the maximum limit is reached:\\n       - Check if the current number from the nums array is less than or equal to the maximum limit.\\n       - If it is, insert the number into the Trie and increment the numsIndex.\\n     - If no numbers were inserted into the Trie, continue to the next query.\\n     - Calculate the maximum XOR value for the given number using the getMaxXOR function from the Trie and store it in the result vector.\\n   - Return the result vector.\\n\\n# Complexity Analysis:\\n- Let n be the length of the nums array and m be the number of queries.\\n- Building the Trie takes O(n) time and space.\\n- Processing each query takes O(log(maximum limit)) time.\\n- Sorting the queries takes O(m log m) time.\\n- The overall time complexity is O(n + m log m).\\n- The overall space complexity is O(n).\\n\\nCode:\\n```cpp\\nclass Node {\\npublic:\\n    Node* children[2]; // Two possible children: 0 or 1\\n\\n    Node() {\\n        children[0] = nullptr;\\n        children[1] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Node* root;\\n\\n    Trie() {\\n        root = new Node();\\n    }\\n\\n    // Inserts a number into the trie\\n    void insert(int num) {\\n        Node* currentNode = root;\\n\\n        // Traverse the binary representation of the number\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num & (1 << i)) ? 1 : 0;\\n\\n            // Create a new child node if it doesn\\'t exist\\n            if (currentNode->children[bit] == nullptr) {\\n                currentNode->children[bit] = new Node();\\n            }\\n\\n            // Move to the child node\\n            currentNode = currentNode->children[bit];\\n        }\\n    }\\n\\n    // Retrieves the maximum XOR value for a given number\\n    int getMaxXOR(int num) {\\n        Node* currentNode = root;\\n        int maxXOR = 0;\\n\\n        // Traverse the binary representation of the number\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num & (1 << i)) ? 1 : 0;\\n            int oppositeBit = bit == 1 ? 0 : 1;\\n\\n            // Check if the opposite bit child node exists\\n            if (currentNode->children[oppositeBit] != nullptr) {\\n                maxXOR |= (1 << i); // Set the i-th bit of the XOR value to 1\\n                currentNode = currentNode->children[oppositeBit];\\n            }\\n            else {\\n                currentNode = currentNode->children[bit];\\n            }\\n        }\\n\\n        return maxXOR;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        int numQueries = queries.size();\\n        vector<int> result(numQueries, -1);\\n\\n        // Add the query index to each query for tracking the answer\\n        for (int i = 0; i < numQueries; i++) {\\n            queries[i].push_back(i);\\n        }\\n\\n        // Sort the queries based on the maximum limit\\n        sort(queries.begin(), queries.end(), [](const auto& a, const auto& b) {\\n            return a[1] < b[1];\\n        });\\n\\n        Trie trie;\\n        int numsIndex = 0;\\n\\n        for (int i = 0; i < numQueries; i++) {\\n            int x = queries[i][0]; // Number from the query\\n            int maxLimit = queries[i][1]; // Maximum limit from the query\\n            int queryIndex = queries[i][2]; // Index of the query in the original order\\n\\n            // Insert numbers into the trie until the maximum limit is reached\\n            while (numsIndex < nums.size() && nums[numsIndex] <= maxLimit) {\\n                trie.insert(nums[numsIndex]);\\n                numsIndex++;\\n            }\\n\\n            if (numsIndex == 0) {\\n                continue;\\n            }\\n\\n            // Calculate the maximum XOR value for the given number\\n            result[queryIndex] = trie.getMaxXOR(x);\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```cpp\\nclass Node {\\npublic:\\n    Node* children[2]; // Two possible children: 0 or 1\\n\\n    Node() {\\n        children[0] = nullptr;\\n        children[1] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Node* root;\\n\\n    Trie() {\\n        root = new Node();\\n    }\\n\\n    // Inserts a number into the trie\\n    void insert(int num) {\\n        Node* currentNode = root;\\n\\n        // Traverse the binary representation of the number\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num & (1 << i)) ? 1 : 0;\\n\\n            // Create a new child node if it doesn\\'t exist\\n            if (currentNode->children[bit] == nullptr) {\\n                currentNode->children[bit] = new Node();\\n            }\\n\\n            // Move to the child node\\n            currentNode = currentNode->children[bit];\\n        }\\n    }\\n\\n    // Retrieves the maximum XOR value for a given number\\n    int getMaxXOR(int num) {\\n        Node* currentNode = root;\\n        int maxXOR = 0;\\n\\n        // Traverse the binary representation of the number\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num & (1 << i)) ? 1 : 0;\\n            int oppositeBit = bit == 1 ? 0 : 1;\\n\\n            // Check if the opposite bit child node exists\\n            if (currentNode->children[oppositeBit] != nullptr) {\\n                maxXOR |= (1 << i); // Set the i-th bit of the XOR value to 1\\n                currentNode = currentNode->children[oppositeBit];\\n            }\\n            else {\\n                currentNode = currentNode->children[bit];\\n            }\\n        }\\n\\n        return maxXOR;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        int numQueries = queries.size();\\n        vector<int> result(numQueries, -1);\\n\\n        // Add the query index to each query for tracking the answer\\n        for (int i = 0; i < numQueries; i++) {\\n            queries[i].push_back(i);\\n        }\\n\\n        // Sort the queries based on the maximum limit\\n        sort(queries.begin(), queries.end(), [](const auto& a, const auto& b) {\\n            return a[1] < b[1];\\n        });\\n\\n        Trie trie;\\n        int numsIndex = 0;\\n\\n        for (int i = 0; i < numQueries; i++) {\\n            int x = queries[i][0]; // Number from the query\\n            int maxLimit = queries[i][1]; // Maximum limit from the query\\n            int queryIndex = queries[i][2]; // Index of the query in the original order\\n\\n            // Insert numbers into the trie until the maximum limit is reached\\n            while (numsIndex < nums.size() && nums[numsIndex] <= maxLimit) {\\n                trie.insert(nums[numsIndex]);\\n                numsIndex++;\\n            }\\n\\n            if (numsIndex == 0) {\\n                continue;\\n            }\\n\\n            // Calculate the maximum XOR value for the given number\\n            result[queryIndex] = trie.getMaxXOR(x);\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754249,
                "title": "sort-two-pointers-use-trie-to-find-maxxor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Trie {\\n    struct TrieNode {\\n        TrieNode* t[2];\\n\\n        TrieNode() {\\n            t[0] = t[1] = NULL;\\n        }\\n    };\\n\\n    TrieNode* root;\\n    // support range [0, 1e9]\\n    // a total of 30 bits\\n    int bits = 29;\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(int num) {\\n        TrieNode* node = root;\\n        for (int i = bits; i >= 0; i--) {\\n            int b = (num >> i) & 0x01;\\n            if (!node->t[b]) {\\n                node->t[b] = new TrieNode();\\n            }\\n\\n            node = node->t[b];\\n        }\\n    }\\n\\n    int maxXor(int x) {\\n        // empty trie, -1\\n        if (!root->t[0] && !root->t[1]) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n        TrieNode* node = root;\\n        for (int i = bits; i >= 0; i--) {\\n            int b = ((x >> i) & 0x01);\\n            // the expected node, make ans i bit 1\\n            int r = b ^ 1;\\n\\n            if (node->t[r]) {\\n                ans |= 1 << i;\\n                node = node->t[r];\\n            } else {\\n                // ans i bit 0, go to the only branch\\n                node = node->t[b];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    /*\\n    Observations:\\n    1. Since queries are all given as input, we process them in\\n       non-decreasign mi order to incrementally add numbers from nums.\\n       We can use an extra index array, or push the original index\\n       into queries[i] as the 3rd element.\\n    2. Sort nums and queries, use two pointers to move forward.\\n    3. Use a Trie tree to hold numbers <= mi. O(30m) space.\\n       As long as trie is not empty, move down the tree along the\\n       path that makes each ans bit 1, otherwise 0. O(30) time.\\n\\n       sorting; two pointers; bit manipulation; trie;\\n       O(mlogm + nlogn) time O(m) space;\\n    */\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int m = nums.size(), n = queries.size();\\n\\n        sort(nums.begin(), nums.end());\\n        // sort queries by mi\\n        vector<int> idx(n);\\n        iota(idx.begin(), idx.end(), 0);\\n        sort(idx.begin(), idx.end(), [&](const int i, const int j) {\\n            return (queries[i][1] < queries[j][1] ||\\n                   (queries[i][1] == queries[j][1] && i < j));\\n        });\\n\\n        Trie *trie = new Trie();\\n        vector<int> ans(n);\\n        for (int i = 0, j = 0; j < n; j++) {\\n            int slot = idx[j];\\n\\n            // insert all numbers <= queries[idx[j][1]]\\n            while (i < m && nums[i] <= queries[slot][1]) {\\n                trie->insert(nums[i]);\\n                i++;\\n            }\\n\\n            ans[slot] = trie->maxXor(queries[slot][0]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Trie {\\n    struct TrieNode {\\n        TrieNode* t[2];\\n\\n        TrieNode() {\\n            t[0] = t[1] = NULL;\\n        }\\n    };\\n\\n    TrieNode* root;\\n    // support range [0, 1e9]\\n    // a total of 30 bits\\n    int bits = 29;\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n\\n    void insert(int num) {\\n        TrieNode* node = root;\\n        for (int i = bits; i >= 0; i--) {\\n            int b = (num >> i) & 0x01;\\n            if (!node->t[b]) {\\n                node->t[b] = new TrieNode();\\n            }\\n\\n            node = node->t[b];\\n        }\\n    }\\n\\n    int maxXor(int x) {\\n        // empty trie, -1\\n        if (!root->t[0] && !root->t[1]) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n        TrieNode* node = root;\\n        for (int i = bits; i >= 0; i--) {\\n            int b = ((x >> i) & 0x01);\\n            // the expected node, make ans i bit 1\\n            int r = b ^ 1;\\n\\n            if (node->t[r]) {\\n                ans |= 1 << i;\\n                node = node->t[r];\\n            } else {\\n                // ans i bit 0, go to the only branch\\n                node = node->t[b];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    /*\\n    Observations:\\n    1. Since queries are all given as input, we process them in\\n       non-decreasign mi order to incrementally add numbers from nums.\\n       We can use an extra index array, or push the original index\\n       into queries[i] as the 3rd element.\\n    2. Sort nums and queries, use two pointers to move forward.\\n    3. Use a Trie tree to hold numbers <= mi. O(30m) space.\\n       As long as trie is not empty, move down the tree along the\\n       path that makes each ans bit 1, otherwise 0. O(30) time.\\n\\n       sorting; two pointers; bit manipulation; trie;\\n       O(mlogm + nlogn) time O(m) space;\\n    */\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int m = nums.size(), n = queries.size();\\n\\n        sort(nums.begin(), nums.end());\\n        // sort queries by mi\\n        vector<int> idx(n);\\n        iota(idx.begin(), idx.end(), 0);\\n        sort(idx.begin(), idx.end(), [&](const int i, const int j) {\\n            return (queries[i][1] < queries[j][1] ||\\n                   (queries[i][1] == queries[j][1] && i < j));\\n        });\\n\\n        Trie *trie = new Trie();\\n        vector<int> ans(n);\\n        for (int i = 0, j = 0; j < n; j++) {\\n            int slot = idx[j];\\n\\n            // insert all numbers <= queries[idx[j][1]]\\n            while (i < m && nums[i] <= queries[slot][1]) {\\n                trie->insert(nums[i]);\\n                i++;\\n            }\\n\\n            ans[slot] = trie->maxXor(queries[slot][0]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746387,
                "title": "c-easy-solution-with-trie",
                "content": "# Intuition\\nFor Solving this Question First Solve [Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)  \\n\\nand then follow these Step\\n\\n# Approach\\n1. insert the index  of queries vector to in each queries and now each queries become of length 3 xi,mi,i\\n2. Sort the Queries in ascending order of mi\\n3. Sort the nums array in ascending order\\n4. now iterat the queries array and insert the number less than mi in Trie\\n5. after that calculate XOR of Xi and update in i position of answer array\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(26*(max(nums.size(),queries.size())))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    struct TrieNode{\\n        TrieNode*child[2];\\n    };\\n    TrieNode*root=new TrieNode();\\n    void insert(int num){\\n        TrieNode*cur=root;\\n        for(int i=30;i>=0;i--){\\n            int bit=((1<<i)&num)==0?0:1;\\n            if(cur->child[bit]==NULL)\\n                cur->child[bit]=new TrieNode();\\n            cur=cur->child[bit];\\n        }\\n    }\\n\\n    int XOR(int num){\\n        TrieNode*cur=root;\\n        int ans=0;\\n        for(int i=30;i>=0;i--){\\n            int bit=((1<<i)&num)==0?0:1;\\n            if(cur->child[!bit]!=NULL){\\n                ans+=(1<<i);\\n                cur=cur->child[!bit];\\n            }else cur=cur->child[bit];\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        int N=q.size();\\n        for(int i=0;i<N;i++){\\n            q[i].push_back(i);\\n        }\\n        vector<int> ans(N,-1);\\n        sort(q.begin(),q.end(),[](vector<int> &a,vector<int> &b){return a[1]<b[1];});\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        for(auto x:q){\\n            while(i<nums.size() && nums[i]<=x[1])\\n                insert(nums[i++]);\\n            if(i>0){\\n                ans[x[2]]=XOR(x[0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    struct TrieNode{\\n        TrieNode*child[2];\\n    };\\n    TrieNode*root=new TrieNode();\\n    void insert(int num){\\n        TrieNode*cur=root;\\n        for(int i=30;i>=0;i--){\\n            int bit=((1<<i)&num)==0?0:1;\\n            if(cur->child[bit]==NULL)\\n                cur->child[bit]=new TrieNode();\\n            cur=cur->child[bit];\\n        }\\n    }\\n\\n    int XOR(int num){\\n        TrieNode*cur=root;\\n        int ans=0;\\n        for(int i=30;i>=0;i--){\\n            int bit=((1<<i)&num)==0?0:1;\\n            if(cur->child[!bit]!=NULL){\\n                ans+=(1<<i);\\n                cur=cur->child[!bit];\\n            }else cur=cur->child[bit];\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        int N=q.size();\\n        for(int i=0;i<N;i++){\\n            q[i].push_back(i);\\n        }\\n        vector<int> ans(N,-1);\\n        sort(q.begin(),q.end(),[](vector<int> &a,vector<int> &b){return a[1]<b[1];});\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        for(auto x:q){\\n            while(i<nums.size() && nums[i]<=x[1])\\n                insert(nums[i++]);\\n            if(i>0){\\n                ans[x[2]]=XOR(x[0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730947,
                "title": "hashmap-error-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# This solution is creating a new array for sotring the original index of the queries .But when i tried to store the indexin a hashmap , it gives me wrong answer in the submit but works fine in run. IDKKKKKk\\n\\n## The HashMap one is below this\\n```\\nclass Solution {\\n    Node root = new Node();\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n\\n    \\n\\n      int[][] t = new int[queries.length][3];\\n      for(int i = 0 ; i < t.length ;i++) {\\n          t[i] = new int[]{queries[i][0],queries[i][1],i};\\n      }\\n\\n\\n\\n        Arrays.sort(nums);\\n        // min = nums[0];\\n        Arrays.sort(t,(a,b) -> (a[1]-b[1]));\\n        int[] ans = new int[queries.length];\\n   \\n\\n        int index = 0;\\n        for(int i = 0 ; i < t.length ;i++) {\\n            int n = t[i][0];\\n            int border = t[i][1];\\n            if(border < nums[0]) {\\n\\n                ans[t[i][2]] = -1;\\n                continue;\\n            }\\n            while(index < nums.length && nums[index] <= border) {\\n                insert(nums[index++]);\\n            }\\n        ans[t[i][2]]  = getMax(n) ^ n;\\n        }\\nreturn ans;\\n\\n    }\\n\\n\\n    int getMax(int x) {\\n        Node temp = root;\\n        int max = 0;\\n\\n        for(int i = 31 ; i >= 0 ;i--) {\\n           \\n            int bit = (x >> i) & 1;\\n            if(temp.links[1-bit] == null) {\\n                temp = temp.links[bit];\\n                max = max | ((bit) << i);\\n            } else {\\n                temp = temp.links[1-bit];\\n                max = max | (1-bit) << i;\\n            }\\n\\n        }\\n        return max;\\n    }\\n\\n    void insert(int x) {\\n        Node temp = root;\\n        for(int i = 31 ; i >=0 ;i--) {\\n            int bit = (x >> i) & 1;\\n            if(temp.links[bit] == null) {\\n                temp.links[bit] = new Node();\\n            }\\n            temp = temp.links[bit];\\n        }\\n    }\\n\\n\\n}\\n\\n\\n\\nclass Node {\\n    Node[] links;\\n    Node() {\\n        links = new Node[26];\\n    }\\n}\\n```\\n\\n\\n\\n```\\nclass Solution {\\n    Node root = new Node();\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        // sort the queries first on the basis of second element;\\n        HashMap<String,Integer> indexHash = new HashMap<>();\\n\\n        for(int i = 0 ; i < queries.length ;i++) {\\n            indexHash.put(queries[i].toString(),i);\\n        }\\n\\n\\n        Arrays.sort(nums);\\n        // min = nums[0];\\n        Arrays.sort(queries,(a,b) -> (a[1]-b[1]));\\n        int[] ans = new int[queries.length];\\n        // System.out.println(Arrays.toString(queries[0]));\\n        // return new int[] {};\\n        int index = 0;\\n        for(int i = 0 ; i < queries.length ;i++) {\\n            int n = queries[i][0];\\n            int border = queries[i][1];\\n            if(border < nums[0]) {\\n\\n                ans[indexHash.get(queries[i].toString())] = -1;\\n                continue;\\n            }\\n            while(index < nums.length && nums[index] <= border) {\\n                insert(nums[index++]);\\n            }\\n         ans[indexHash.get(queries[i].toString())] = getMax(n) ^ n;\\n        }\\nreturn ans;\\n\\n    }\\n\\n\\n    int getMax(int x) {\\n        Node temp = root;\\n        int max = 0;\\n\\n        for(int i = 31 ; i >= 0 ;i--) {\\n           \\n            int bit = (x >> i) & 1;\\n            if(temp.links[1-bit] == null) {\\n                temp = temp.links[bit];\\n                max = max | ((bit) << i);\\n            } else {\\n                temp = temp.links[1-bit];\\n                max = max | (1-bit) << i;\\n            }\\n\\n        }\\n        return max;\\n    }\\n\\n    void insert(int x) {\\n        Node temp = root;\\n        for(int i = 31 ; i >=0 ;i--) {\\n            int bit = (x >> i) & 1;\\n            if(temp.links[bit] == null) {\\n                temp.links[bit] = new Node();\\n            }\\n            temp = temp.links[bit];\\n        }\\n    }\\n\\n\\n}\\n\\n\\n\\nclass Node {\\n    Node[] links;\\n    Node() {\\n        links = new Node[26];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    Node root = new Node();\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n\\n    \\n\\n      int[][] t = new int[queries.length][3];\\n      for(int i = 0 ; i < t.length ;i++) {\\n          t[i] = new int[]{queries[i][0],queries[i][1],i};\\n      }\\n\\n\\n\\n        Arrays.sort(nums);\\n        // min = nums[0];\\n        Arrays.sort(t,(a,b) -> (a[1]-b[1]));\\n        int[] ans = new int[queries.length];\\n   \\n\\n        int index = 0;\\n        for(int i = 0 ; i < t.length ;i++) {\\n            int n = t[i][0];\\n            int border = t[i][1];\\n            if(border < nums[0]) {\\n\\n                ans[t[i][2]] = -1;\\n                continue;\\n            }\\n            while(index < nums.length && nums[index] <= border) {\\n                insert(nums[index++]);\\n            }\\n        ans[t[i][2]]  = getMax(n) ^ n;\\n        }\\nreturn ans;\\n\\n    }\\n\\n\\n    int getMax(int x) {\\n        Node temp = root;\\n        int max = 0;\\n\\n        for(int i = 31 ; i >= 0 ;i--) {\\n           \\n            int bit = (x >> i) & 1;\\n            if(temp.links[1-bit] == null) {\\n                temp = temp.links[bit];\\n                max = max | ((bit) << i);\\n            } else {\\n                temp = temp.links[1-bit];\\n                max = max | (1-bit) << i;\\n            }\\n\\n        }\\n        return max;\\n    }\\n\\n    void insert(int x) {\\n        Node temp = root;\\n        for(int i = 31 ; i >=0 ;i--) {\\n            int bit = (x >> i) & 1;\\n            if(temp.links[bit] == null) {\\n                temp.links[bit] = new Node();\\n            }\\n            temp = temp.links[bit];\\n        }\\n    }\\n\\n\\n}\\n\\n\\n\\nclass Node {\\n    Node[] links;\\n    Node() {\\n        links = new Node[26];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Node root = new Node();\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        // sort the queries first on the basis of second element;\\n        HashMap<String,Integer> indexHash = new HashMap<>();\\n\\n        for(int i = 0 ; i < queries.length ;i++) {\\n            indexHash.put(queries[i].toString(),i);\\n        }\\n\\n\\n        Arrays.sort(nums);\\n        // min = nums[0];\\n        Arrays.sort(queries,(a,b) -> (a[1]-b[1]));\\n        int[] ans = new int[queries.length];\\n        // System.out.println(Arrays.toString(queries[0]));\\n        // return new int[] {};\\n        int index = 0;\\n        for(int i = 0 ; i < queries.length ;i++) {\\n            int n = queries[i][0];\\n            int border = queries[i][1];\\n            if(border < nums[0]) {\\n\\n                ans[indexHash.get(queries[i].toString())] = -1;\\n                continue;\\n            }\\n            while(index < nums.length && nums[index] <= border) {\\n                insert(nums[index++]);\\n            }\\n         ans[indexHash.get(queries[i].toString())] = getMax(n) ^ n;\\n        }\\nreturn ans;\\n\\n    }\\n\\n\\n    int getMax(int x) {\\n        Node temp = root;\\n        int max = 0;\\n\\n        for(int i = 31 ; i >= 0 ;i--) {\\n           \\n            int bit = (x >> i) & 1;\\n            if(temp.links[1-bit] == null) {\\n                temp = temp.links[bit];\\n                max = max | ((bit) << i);\\n            } else {\\n                temp = temp.links[1-bit];\\n                max = max | (1-bit) << i;\\n            }\\n\\n        }\\n        return max;\\n    }\\n\\n    void insert(int x) {\\n        Node temp = root;\\n        for(int i = 31 ; i >=0 ;i--) {\\n            int bit = (x >> i) & 1;\\n            if(temp.links[bit] == null) {\\n                temp.links[bit] = new Node();\\n            }\\n            temp = temp.links[bit];\\n        }\\n    }\\n\\n\\n}\\n\\n\\n\\nclass Node {\\n    Node[] links;\\n    Node() {\\n        links = new Node[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729054,
                "title": "trie-sorting-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\nlet `n = nums.length`\\n`m = queries.length`\\n- Time complexity: $O(\\\\max(n,m) \\\\cdot \\\\log(\\\\max(n,m)))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    class TrieNode{\\n        TrieNode hash[];\\n        TrieNode(){\\n            hash = new TrieNode[2];\\n        }\\n    }\\n    void insert(TrieNode root,int num){\\n        TrieNode curr = root;\\n        for(int i = 31;i >= 0;--i){\\n            int bit = (num >> i) & 1;\\n            if(curr.hash[bit] == null) curr.hash[bit] = new TrieNode();\\n            curr = curr.hash[bit];\\n        }\\n    }\\n    int maxXOR(TrieNode root,int num){\\n        TrieNode curr = root;\\n        int ans = 0;\\n        for(int i = 31;i >= 0;--i){\\n            int bit = (num >> i) & 1;\\n            if(curr == null) return -1;\\n            if(curr.hash[bit ^ 1] != null){\\n                ans |= (1 << i);\\n                curr = curr.hash[bit ^ 1];\\n            }\\n            else curr = curr.hash[bit];\\n        }\\n        return ans;\\n    }\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        TrieNode root = new TrieNode();\\n        Arrays.sort(nums);\\n        for(int i = 0;i < queries.length;i++){\\n            queries[i] = new int[]{queries[i][0],queries[i][1],i};\\n        }\\n        int ans[] = new int[queries.length];\\n        Arrays.sort(queries,(a,b) -> Integer.compare(a[1],b[1]));\\n        for(int i = 0,j = 0;i < queries.length;i++){\\n            for(;j < nums.length && nums[j] <= queries[i][1];j++){\\n                insert(root,nums[j]);\\n            }\\n            ans[queries[i][2]] = maxXOR(root,queries[i][0]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# Upvote if you like it \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Trie",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    class TrieNode{\\n        TrieNode hash[];\\n        TrieNode(){\\n            hash = new TrieNode[2];\\n        }\\n    }\\n    void insert(TrieNode root,int num){\\n        TrieNode curr = root;\\n        for(int i = 31;i >= 0;--i){\\n            int bit = (num >> i) & 1;\\n            if(curr.hash[bit] == null) curr.hash[bit] = new TrieNode();\\n            curr = curr.hash[bit];\\n        }\\n    }\\n    int maxXOR(TrieNode root,int num){\\n        TrieNode curr = root;\\n        int ans = 0;\\n        for(int i = 31;i >= 0;--i){\\n            int bit = (num >> i) & 1;\\n            if(curr == null) return -1;\\n            if(curr.hash[bit ^ 1] != null){\\n                ans |= (1 << i);\\n                curr = curr.hash[bit ^ 1];\\n            }\\n            else curr = curr.hash[bit];\\n        }\\n        return ans;\\n    }\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        TrieNode root = new TrieNode();\\n        Arrays.sort(nums);\\n        for(int i = 0;i < queries.length;i++){\\n            queries[i] = new int[]{queries[i][0],queries[i][1],i};\\n        }\\n        int ans[] = new int[queries.length];\\n        Arrays.sort(queries,(a,b) -> Integer.compare(a[1],b[1]));\\n        for(int i = 0,j = 0;i < queries.length;i++){\\n            for(;j < nums.length && nums[j] <= queries[i][1];j++){\\n                insert(root,nums[j]);\\n            }\\n            ans[queries[i][2]] = maxXOR(root,queries[i][0]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725555,
                "title": "100-beat-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    public static class Pair{\\n        int xi;\\n        int mi;\\n        int qi;\\n        Pair(int xi, int mi, int qi){\\n            this.xi=xi;\\n            this.mi=mi;\\n            this.qi=qi;\\n        }\\n    }\\n    public int[] maximizeXor(int[] arr, int[][] qu) {\\n        Arrays.sort(arr);\\n        Pair []p = new Pair[qu.length];\\n        for(int i=0; i<p.length; i++){\\n            p[i]= new Pair(qu[i][0],qu[i][1],i);\\n        }\\n\\n        Arrays.sort(p, new Comparator<Pair>(){\\n            @Override\\n            public int compare(Pair o1, Pair o2){\\n                return o1.mi - o2.mi;\\n            }\\n        });\\n\\n        Node root = new Node();\\n        int []ans = new int[p.length];\\n        int j=0;\\n\\n        for(int i=0; i<ans.length; i++){\\n            while(j<arr.length && arr[j]<=p[i].mi){\\n                Insert(root,arr[j]);\\n                j++;\\n            }\\n\\n            if(j==0){\\n                ans[p[i].qi]=-1;\\n            }\\n            else{\\n                ans[p[i].qi] = getmaxXor(root, p[i].xi);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public class Node {\\n\\t\\tNode zero;\\n\\t\\tNode one;\\n\\t}\\n\\n    public void Insert(Node root, int val) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (int i = 31; i >= 0; i--) {\\n\\t\\t\\tif ((val & (1 << i)) == 0) {\\n\\t\\t\\t\\tif (curr.zero != null) {\\n\\t\\t\\t\\t\\tcurr = curr.zero;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tNode nn = new Node();\\n\\t\\t\\t\\t\\tcurr.zero = nn;\\n\\t\\t\\t\\t\\tcurr = nn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (curr.one != null) {\\n\\t\\t\\t\\t\\tcurr = curr.one;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tNode nn = new Node();\\n\\t\\t\\t\\t\\tcurr.one = nn;\\n\\t\\t\\t\\t\\tcurr = nn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\n    public static int getmaxXor(Node root, int val) {\\n\\t\\tint num = 0;\\n\\t\\tNode curr = root;\\n\\t\\tfor (int i = 31; i >= 0; i--) {\\n\\t\\t\\tint bit = (val & (1 << i));\\n\\t\\t\\tif (bit == 0) {\\n\\t\\t\\t\\tif (curr.one != null) {\\n\\t\\t\\t\\t\\tnum += (1 << i);\\n\\t\\t\\t\\t\\tcurr = curr.one;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcurr = curr.zero;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (curr.zero != null) {\\n\\t\\t\\t\\t\\tnum += (1 << i);\\n\\t\\t\\t\\t\\tcurr = curr.zero;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcurr = curr.one;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn num;\\n\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static class Pair{\\n        int xi;\\n        int mi;\\n        int qi;\\n        Pair(int xi, int mi, int qi){\\n            this.xi=xi;\\n            this.mi=mi;\\n            this.qi=qi;\\n        }\\n    }\\n    public int[] maximizeXor(int[] arr, int[][] qu) {\\n        Arrays.sort(arr);\\n        Pair []p = new Pair[qu.length];\\n        for(int i=0; i<p.length; i++){\\n            p[i]= new Pair(qu[i][0],qu[i][1],i);\\n        }\\n\\n        Arrays.sort(p, new Comparator<Pair>(){\\n            @Override\\n            public int compare(Pair o1, Pair o2){\\n                return o1.mi - o2.mi;\\n            }\\n        });\\n\\n        Node root = new Node();\\n        int []ans = new int[p.length];\\n        int j=0;\\n\\n        for(int i=0; i<ans.length; i++){\\n            while(j<arr.length && arr[j]<=p[i].mi){\\n                Insert(root,arr[j]);\\n                j++;\\n            }\\n\\n            if(j==0){\\n                ans[p[i].qi]=-1;\\n            }\\n            else{\\n                ans[p[i].qi] = getmaxXor(root, p[i].xi);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public class Node {\\n\\t\\tNode zero;\\n\\t\\tNode one;\\n\\t}\\n\\n    public void Insert(Node root, int val) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (int i = 31; i >= 0; i--) {\\n\\t\\t\\tif ((val & (1 << i)) == 0) {\\n\\t\\t\\t\\tif (curr.zero != null) {\\n\\t\\t\\t\\t\\tcurr = curr.zero;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tNode nn = new Node();\\n\\t\\t\\t\\t\\tcurr.zero = nn;\\n\\t\\t\\t\\t\\tcurr = nn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (curr.one != null) {\\n\\t\\t\\t\\t\\tcurr = curr.one;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tNode nn = new Node();\\n\\t\\t\\t\\t\\tcurr.one = nn;\\n\\t\\t\\t\\t\\tcurr = nn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\n    public static int getmaxXor(Node root, int val) {\\n\\t\\tint num = 0;\\n\\t\\tNode curr = root;\\n\\t\\tfor (int i = 31; i >= 0; i--) {\\n\\t\\t\\tint bit = (val & (1 << i));\\n\\t\\t\\tif (bit == 0) {\\n\\t\\t\\t\\tif (curr.one != null) {\\n\\t\\t\\t\\t\\tnum += (1 << i);\\n\\t\\t\\t\\t\\tcurr = curr.one;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcurr = curr.zero;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (curr.zero != null) {\\n\\t\\t\\t\\t\\tnum += (1 << i);\\n\\t\\t\\t\\t\\tcurr = curr.zero;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcurr = curr.one;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn num;\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725546,
                "title": "trie-approach-used-in-java-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTrie and Bit Manipulation Approach used for solving this question\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) \\n    {\\n        Arrays.sort(nums);\\n        Pair[] p = new Pair[queries.length];\\n        for (int i = 0; i < p.length; i++)\\n        {\\n           p[i] = new Pair(queries[i][0],queries[i][1],i);\\n        }\\n        Arrays.sort(p,new Comparator<Pair>()\\n        {\\n            @Override\\n            public int compare(Pair o1,Pair o2)\\n            {\\n                return o1.mi - o2.mi;\\n            }\\n        });\\n        Node newNode = new Node();\\n        int[] ans =  new int[p.length];\\n        int j = 0;\\n        for (int i = 0; i < ans.length; i++) {\\n\\n            while(j < nums.length && nums[j] <= p[i].mi)\\n            {\\n                Insert(newNode,nums[j]);\\n                j++;\\n            }\\n            if(j == 0)\\n            {\\n                ans[p[i].qi] = -1;\\n            }\\n            else\\n            {\\n                ans[p[i].qi] = getmaxXor(newNode,p[i].xi);\\n            }\\n\\n        }\\n        // System.out.println(Arrays.toString(ans));\\n        // return Arrays.toString(ans);\\n        return ans;\\n        \\n        \\n    }\\n    public static class Node {\\n        Node zero;\\n        Node one;\\n    }\\n\\n    public static void Insert(Node root, int val) {\\n        Node curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            if ((val & (1 << i)) == 0) {\\n                if (curr.zero != null) {\\n                    curr = curr.zero;\\n                } else {\\n                    Node nn = new Node();\\n                    curr.zero = nn;\\n                    curr = nn;\\n                }\\n            } else {\\n                if (curr.one != null) {\\n                    curr = curr.one;\\n                } else {\\n                    Node nn = new Node();\\n                    curr.one = nn;\\n                    curr = nn;\\n                }\\n            }\\n\\n        }\\n\\n    }\\n\\n    public static int getmaxXor(Node root, int val) {\\n        int num = 0;\\n        Node curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (val & (1 << i));\\n            if (bit == 0) {\\n                if (curr.one != null) {\\n                    num += (1 << i);\\n                    curr = curr.one;\\n                } else {\\n                    curr = curr.zero;\\n                }\\n            } else {\\n                if (curr.zero != null) {\\n                    num += (1 << i);\\n                    curr = curr.zero;\\n                } else {\\n                    curr = curr.one;\\n                }\\n            }\\n\\n        }\\n        return num;\\n\\n    }\\n    public static class Pair\\n    {\\n        int xi;\\n        int mi;\\n        int qi;\\n        Pair(int xi,int mi,int qi)\\n        {\\n            this.mi = mi;\\n            this.qi = qi;\\n            this.xi = xi;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) \\n    {\\n        Arrays.sort(nums);\\n        Pair[] p = new Pair[queries.length];\\n        for (int i = 0; i < p.length; i++)\\n        {\\n           p[i] = new Pair(queries[i][0],queries[i][1],i);\\n        }\\n        Arrays.sort(p,new Comparator<Pair>()\\n        {\\n            @Override\\n            public int compare(Pair o1,Pair o2)\\n            {\\n                return o1.mi - o2.mi;\\n            }\\n        });\\n        Node newNode = new Node();\\n        int[] ans =  new int[p.length];\\n        int j = 0;\\n        for (int i = 0; i < ans.length; i++) {\\n\\n            while(j < nums.length && nums[j] <= p[i].mi)\\n            {\\n                Insert(newNode,nums[j]);\\n                j++;\\n            }\\n            if(j == 0)\\n            {\\n                ans[p[i].qi] = -1;\\n            }\\n            else\\n            {\\n                ans[p[i].qi] = getmaxXor(newNode,p[i].xi);\\n            }\\n\\n        }\\n        // System.out.println(Arrays.toString(ans));\\n        // return Arrays.toString(ans);\\n        return ans;\\n        \\n        \\n    }\\n    public static class Node {\\n        Node zero;\\n        Node one;\\n    }\\n\\n    public static void Insert(Node root, int val) {\\n        Node curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            if ((val & (1 << i)) == 0) {\\n                if (curr.zero != null) {\\n                    curr = curr.zero;\\n                } else {\\n                    Node nn = new Node();\\n                    curr.zero = nn;\\n                    curr = nn;\\n                }\\n            } else {\\n                if (curr.one != null) {\\n                    curr = curr.one;\\n                } else {\\n                    Node nn = new Node();\\n                    curr.one = nn;\\n                    curr = nn;\\n                }\\n            }\\n\\n        }\\n\\n    }\\n\\n    public static int getmaxXor(Node root, int val) {\\n        int num = 0;\\n        Node curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (val & (1 << i));\\n            if (bit == 0) {\\n                if (curr.one != null) {\\n                    num += (1 << i);\\n                    curr = curr.one;\\n                } else {\\n                    curr = curr.zero;\\n                }\\n            } else {\\n                if (curr.zero != null) {\\n                    num += (1 << i);\\n                    curr = curr.zero;\\n                } else {\\n                    curr = curr.one;\\n                }\\n            }\\n\\n        }\\n        return num;\\n\\n    }\\n    public static class Pair\\n    {\\n        int xi;\\n        int mi;\\n        int qi;\\n        Pair(int xi,int mi,int qi)\\n        {\\n            this.mi = mi;\\n            this.qi = qi;\\n            this.xi = xi;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725512,
                "title": "java-solution-with-trie-beats-100",
                "content": "\\n\\n```\\nclass Solution {\\n    static class Pair{\\n        int xi;\\n        int mi;\\n        int qi;\\n\\n        public Pair(int a, int b, int c){\\n            this.xi=a;\\n            this.mi=b;\\n            this.qi=c;\\n        }\\n    }\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Pair[] query = new Pair[queries.length];\\n\\n        Arrays.sort(nums);\\n\\n        for(int i = 0 ; i < queries.length ; i ++){\\n            query[i]=new Pair(queries[i][0] , queries[i][1] , i);\\n        }\\n\\n        Arrays.sort(query , new Comparator<Pair>(){\\n            public int compare ( Pair o1 , Pair o2 ){\\n                return o1.mi - o2.mi ;\\n            }\\n        });\\n\\n        int ans[] =  new int[query.length];\\n        Node root = new Node();\\n        int j = 0;\\n        for(int i = 0 ; i < ans.length ; i++){\\n            while (j < nums.length && nums[j] <= query[i].mi){\\n                insert(root , nums[j]);\\n                j++;\\n            }\\n            if (j == 0){\\n                ans[query[i].qi] = -1;\\n            }\\n            else{\\n                ans[query[i].qi] = getMaxXor(root , query[i].xi);\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n    public static class Node{\\n        Node zero;\\n        Node one;\\n    }\\n\\n\\n    public void insert (Node root, int val) {\\n        Node curr = root;\\n        for(int i = 31 ; i >=0 ; i--){\\n            if((val & (1 << i)) == 0){\\n                if( curr.zero != null){\\n                    curr=curr.zero;\\n                }\\n                else{\\n                    Node nn = new Node();\\n                    curr.zero=nn;\\n                    curr = nn;\\n                }\\n            }\\n            else{\\n                if( curr.one != null){\\n                    curr = curr.one;\\n                }\\n                else{\\n                    Node nn = new Node();\\n                    curr.one = nn;\\n                    curr = nn;\\n                }\\n            }\\n        }\\n    }\\n\\n    private static int getMaxXor ( Node root, int val ){\\n        int num = 0;\\n        Node curr = root;\\n        for( int i = 31 ; i >= 0 ; i--){\\n            int bit = val & (1 << i);\\n\\n            if( bit == 0 ){\\n                if( curr.one != null ){\\n                    num += (1 << i);\\n                    curr = curr.one;\\n                }\\n                else{\\n                    curr = curr.zero;\\n                }\\n            }\\n            else{\\n                if( curr.zero != null){\\n                    num += (1 << i);\\n                    curr = curr.zero;\\n                }\\n                else{\\n                    curr = curr.one;\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    static class Pair{\\n        int xi;\\n        int mi;\\n        int qi;\\n\\n        public Pair(int a, int b, int c){\\n            this.xi=a;\\n            this.mi=b;\\n            this.qi=c;\\n        }\\n    }\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Pair[] query = new Pair[queries.length];\\n\\n        Arrays.sort(nums);\\n\\n        for(int i = 0 ; i < queries.length ; i ++){\\n            query[i]=new Pair(queries[i][0] , queries[i][1] , i);\\n        }\\n\\n        Arrays.sort(query , new Comparator<Pair>(){\\n            public int compare ( Pair o1 , Pair o2 ){\\n                return o1.mi - o2.mi ;\\n            }\\n        });\\n\\n        int ans[] =  new int[query.length];\\n        Node root = new Node();\\n        int j = 0;\\n        for(int i = 0 ; i < ans.length ; i++){\\n            while (j < nums.length && nums[j] <= query[i].mi){\\n                insert(root , nums[j]);\\n                j++;\\n            }\\n            if (j == 0){\\n                ans[query[i].qi] = -1;\\n            }\\n            else{\\n                ans[query[i].qi] = getMaxXor(root , query[i].xi);\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n    public static class Node{\\n        Node zero;\\n        Node one;\\n    }\\n\\n\\n    public void insert (Node root, int val) {\\n        Node curr = root;\\n        for(int i = 31 ; i >=0 ; i--){\\n            if((val & (1 << i)) == 0){\\n                if( curr.zero != null){\\n                    curr=curr.zero;\\n                }\\n                else{\\n                    Node nn = new Node();\\n                    curr.zero=nn;\\n                    curr = nn;\\n                }\\n            }\\n            else{\\n                if( curr.one != null){\\n                    curr = curr.one;\\n                }\\n                else{\\n                    Node nn = new Node();\\n                    curr.one = nn;\\n                    curr = nn;\\n                }\\n            }\\n        }\\n    }\\n\\n    private static int getMaxXor ( Node root, int val ){\\n        int num = 0;\\n        Node curr = root;\\n        for( int i = 31 ; i >= 0 ; i--){\\n            int bit = val & (1 << i);\\n\\n            if( bit == 0 ){\\n                if( curr.one != null ){\\n                    num += (1 << i);\\n                    curr = curr.one;\\n                }\\n                else{\\n                    curr = curr.zero;\\n                }\\n            }\\n            else{\\n                if( curr.zero != null){\\n                    num += (1 << i);\\n                    curr = curr.zero;\\n                }\\n                else{\\n                    curr = curr.one;\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725479,
                "title": "java-solution-using-binary-trie-beats-100",
                "content": "\\n```\\nclass Solution {\\n    Node root;\\n    class Node{\\n        Node zero;\\n        Node one;\\n    }\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int a[][]=new int[queries.length][3];\\n        for(int i=0;i<queries.length;i++){\\n            a[i][0]=queries[i][0];\\n            a[i][1]=queries[i][1];\\n            a[i][2]=i;\\n        }\\n        Arrays.sort(a,(i1,i2)->i1[1]-i2[1]);\\n        Arrays.sort(nums);\\n        int in=0;\\n        int ans[]=new int[queries.length];\\n        root=new Node();\\n        for(int i=0;i<a.length;i++){\\n            int m=a[i][1];\\n            while(in<nums.length&&nums[in]<=m){\\n                insert(nums[in++]);\\n            }\\n            if(in==0){\\n                ans[a[i][2]]=-1;\\n                continue;\\n            }\\n            ans[a[i][2]]=max(a[i][0]);\\n        }\\n        return ans;\\n    }\\n    public int max(int n){\\n        int ans=0;\\n        Node curr=root;\\n        for(int i=31;i>=0;i--){\\n            if((n&(1<<i))==0){\\n                if(curr.one!=null){\\n                    ans+=(1<<i);\\n                    curr=curr.one;\\n                }\\n                else curr=curr.zero;\\n                \\n            }\\n            else{\\n                if(curr.zero!=null){\\n                    ans+=(1<<i);\\n                    curr=curr.zero;\\n                }\\n                else curr=curr.one;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n    public void insert(int v){\\n        Node curr=root;\\n        for(int i=31;i>=0;i--){\\n            if((v&(1<<i))==0){\\n                if(curr.zero!=null){\\n                    curr=curr.zero;\\n                }\\n                else{\\n                    curr.zero=new Node();\\n                    curr=curr.zero;\\n                }\\n            }\\n            else{\\n                if(curr.one!=null){\\n                    curr=curr.one;\\n                }\\n                else{\\n                    curr.one=new Node();\\n                    curr=curr.one;\\n                }\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Node root;\\n    class Node{\\n        Node zero;\\n        Node one;\\n    }\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int a[][]=new int[queries.length][3];\\n        for(int i=0;i<queries.length;i++){\\n            a[i][0]=queries[i][0];\\n            a[i][1]=queries[i][1];\\n            a[i][2]=i;\\n        }\\n        Arrays.sort(a,(i1,i2)->i1[1]-i2[1]);\\n        Arrays.sort(nums);\\n        int in=0;\\n        int ans[]=new int[queries.length];\\n        root=new Node();\\n        for(int i=0;i<a.length;i++){\\n            int m=a[i][1];\\n            while(in<nums.length&&nums[in]<=m){\\n                insert(nums[in++]);\\n            }\\n            if(in==0){\\n                ans[a[i][2]]=-1;\\n                continue;\\n            }\\n            ans[a[i][2]]=max(a[i][0]);\\n        }\\n        return ans;\\n    }\\n    public int max(int n){\\n        int ans=0;\\n        Node curr=root;\\n        for(int i=31;i>=0;i--){\\n            if((n&(1<<i))==0){\\n                if(curr.one!=null){\\n                    ans+=(1<<i);\\n                    curr=curr.one;\\n                }\\n                else curr=curr.zero;\\n                \\n            }\\n            else{\\n                if(curr.zero!=null){\\n                    ans+=(1<<i);\\n                    curr=curr.zero;\\n                }\\n                else curr=curr.one;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n    public void insert(int v){\\n        Node curr=root;\\n        for(int i=31;i>=0;i--){\\n            if((v&(1<<i))==0){\\n                if(curr.zero!=null){\\n                    curr=curr.zero;\\n                }\\n                else{\\n                    curr.zero=new Node();\\n                    curr=curr.zero;\\n                }\\n            }\\n            else{\\n                if(curr.one!=null){\\n                    curr=curr.one;\\n                }\\n                else{\\n                    curr.one=new Node();\\n                    curr=curr.one;\\n                }\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714309,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Node{\\npublic:\\n    Node* links[2];\\n    int mini[2];\\n    \\n    Node(){\\n        links[0]=NULL,links[1]=NULL;\\n        mini[0]=INT_MAX,mini[1]=INT_MAX;\\n    }\\n    bool containsKey(int i){\\n        return links[i]!=NULL;\\n    }\\n    void put(int i, Node* node){\\n        links[i]=node;\\n    }\\n    Node* get(int i){\\n        return links[i];\\n    }\\n    void putMin(int bit, int x){\\n        mini[bit]=min(mini[bit],x);\\n    }\\n    int getMin(int bit){\\n        return mini[bit];\\n    }\\n};\\nclass Solution {\\npublic:\\n    Node* root;\\n    void insert(int x)\\n    {\\n        Node* curr=root;\\n        int k=32;\\n        while(k--)\\n        {\\n            int bit=((x>>k)&1);\\n            if(!curr->containsKey(bit))\\n                curr->put(bit,new Node());\\n            curr->putMin(bit,x);\\n            curr=curr->get(bit);\\n        }\\n    }\\n    int searchMaxXOR(int x, int m)\\n    {\\n        Node* curr=root;\\n        int ans=0,k=32;\\n        while(k--)\\n        {\\n            ans=ans*2;\\n            \\n            int bit=((x>>k)&1);\\n            if(curr->containsKey(1-bit) && curr->getMin(1-bit)<=m)\\n            {\\n                curr=curr->get(1-bit);\\n                ans++;\\n            }\\n            else\\n                curr=curr->get(bit);\\n        }\\n        return ans;\\n    }\\n    vector<int> maximizeXor(vector<int>& v, vector<vector<int>>& q) {\\n        int n=v.size();\\n        root=new Node();\\n        for(int i=0;i<n;i++)\\n            insert(v[i]);\\n        int minEle=*min_element(v.begin(),v.end());\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int x=q[i][0],m=q[i][1];\\n            if(minEle<=m)\\n                ans.push_back(searchMaxXOR(x,m));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node{\\npublic:\\n    Node* links[2];\\n    int mini[2];\\n    \\n    Node(){\\n        links[0]=NULL,links[1]=NULL;\\n        mini[0]=INT_MAX,mini[1]=INT_MAX;\\n    }\\n    bool containsKey(int i){\\n        return links[i]!=NULL;\\n    }\\n    void put(int i, Node* node){\\n        links[i]=node;\\n    }\\n    Node* get(int i){\\n        return links[i];\\n    }\\n    void putMin(int bit, int x){\\n        mini[bit]=min(mini[bit],x);\\n    }\\n    int getMin(int bit){\\n        return mini[bit];\\n    }\\n};\\nclass Solution {\\npublic:\\n    Node* root;\\n    void insert(int x)\\n    {\\n        Node* curr=root;\\n        int k=32;\\n        while(k--)\\n        {\\n            int bit=((x>>k)&1);\\n            if(!curr->containsKey(bit))\\n                curr->put(bit,new Node());\\n            curr->putMin(bit,x);\\n            curr=curr->get(bit);\\n        }\\n    }\\n    int searchMaxXOR(int x, int m)\\n    {\\n        Node* curr=root;\\n        int ans=0,k=32;\\n        while(k--)\\n        {\\n            ans=ans*2;\\n            \\n            int bit=((x>>k)&1);\\n            if(curr->containsKey(1-bit) && curr->getMin(1-bit)<=m)\\n            {\\n                curr=curr->get(1-bit);\\n                ans++;\\n            }\\n            else\\n                curr=curr->get(bit);\\n        }\\n        return ans;\\n    }\\n    vector<int> maximizeXor(vector<int>& v, vector<vector<int>>& q) {\\n        int n=v.size();\\n        root=new Node();\\n        for(int i=0;i<n;i++)\\n            insert(v[i]);\\n        int minEle=*min_element(v.begin(),v.end());\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int x=q[i][0],m=q[i][1];\\n            if(minEle<=m)\\n                ans.push_back(searchMaxXOR(x,m));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703996,
                "title": "c-trie-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach can be to check all the elements of arr which are smaller than m. and storing the maximum XOR among them. But the time complexity will be more because for every queries we need to traverse the whole array(worst case).\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can take help of trie data structure for storing the numbers in binary bits.In this way we can store all the numbers in the trie.\\n\\nIf we are given a number x and we have to find the maxmimum XOR among the array elements.Take a variable maxNum=0. We start from the left most bit of x and see if we have corresponding opposite bit in the trie or not.if yes we go to that reference and update that bit in maxNum as 1 else we just go to the next reference. (reason behind this is because of the property of XOR, XOR of opposite bits is 1 and to maximise the number we should have maximum number of set bits.But if we don\\'t have opposite bit then we have to go with whatever bit is present at that position.) \\n\\nat last the maximum XOR of x and arr elements will be stored in maxNUm.\\nreturn it.\\n\\nBut here one catch is that we have to find max XOR among the elements which are smaller than or equal to m. How do we do this?\\n\\nwe can simply start inserting the array elements in trie when a query is called, this way only those element will be present in the trie whihc are smaller than equal to m.Thus we\\'ll get the desired answer.\\n\\nfirst sort the array so that all elements are inserted sequentially.\\nnow sort the queries array according to m value but also keep the original index because we have to insert maxXor of ith query at ith position.(you can do this by modifying the query array and storing index after m value in the vector and then sorting according to m value). \\n\\nnow for each query traverse the array elements upto which it is smaller than m and insert into trie. call the query function of trie and store the ans at position specfied.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M) + O(MlogM) + O(M*32 + N*32)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(32*N)\\n\\n\\n# Code\\n```\\nclass Node{\\n   Node* links[2];\\n   public: \\n    bool containsKey(int bit){\\n        return (links[bit]!=NULL);\\n    }\\n    void put(int bit,Node* node){\\n        links[bit]=node;\\n    }\\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie{\\n    Node* root;\\npublic:\\n    Trie(){\\n        root=new Node();\\n    }\\n\\n    void insert(int num){\\n        Node* node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n    int query(int num){\\n        Node* node=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--){\\n             int bit = (num>>i)&1;\\n            if(node->containsKey(!bit)){\\n             maxNum = maxNum | (1<<i);\\n             node=node->get(!bit);\\n            }\\n            else node=node->get(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(),-1);\\n        Trie tr;\\n        sort(arr.begin(),arr.end());\\n        \\n        vector < pair < int, pair < int, int >>> offlineQueries;\\nint index = 0;\\n  for (auto & it: queries) {\\n    offlineQueries.push_back({\\n      it[1],\\n      {\\n        it[0],\\n        index++\\n      }\\n    });\\n  }\\n  \\n  sort(offlineQueries.begin(), offlineQueries.end());\\n    int i = 0;\\n  int n = arr.size();\\n        for (auto & it: offlineQueries) {\\n    while (i < n && arr[i] <= it.first) {\\n      tr.insert(arr[i]);\\n      i++;\\n    }\\n    if (i != 0) ans[it.second.second] = tr.query(it.second.first);\\n    else ans[it.second.second] = -1;\\n  }\\n  return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\n   Node* links[2];\\n   public: \\n    bool containsKey(int bit){\\n        return (links[bit]!=NULL);\\n    }\\n    void put(int bit,Node* node){\\n        links[bit]=node;\\n    }\\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie{\\n    Node* root;\\npublic:\\n    Trie(){\\n        root=new Node();\\n    }\\n\\n    void insert(int num){\\n        Node* node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n    int query(int num){\\n        Node* node=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--){\\n             int bit = (num>>i)&1;\\n            if(node->containsKey(!bit)){\\n             maxNum = maxNum | (1<<i);\\n             node=node->get(!bit);\\n            }\\n            else node=node->get(bit);\\n        }\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(),-1);\\n        Trie tr;\\n        sort(arr.begin(),arr.end());\\n        \\n        vector < pair < int, pair < int, int >>> offlineQueries;\\nint index = 0;\\n  for (auto & it: queries) {\\n    offlineQueries.push_back({\\n      it[1],\\n      {\\n        it[0],\\n        index++\\n      }\\n    });\\n  }\\n  \\n  sort(offlineQueries.begin(), offlineQueries.end());\\n    int i = 0;\\n  int n = arr.size();\\n        for (auto & it: offlineQueries) {\\n    while (i < n && arr[i] <= it.first) {\\n      tr.insert(arr[i]);\\n      i++;\\n    }\\n    if (i != 0) ans[it.second.second] = tr.query(it.second.first);\\n    else ans[it.second.second] = -1;\\n  }\\n  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690162,
                "title": "bruh-these-trie-codes-are-so-long-0-0",
                "content": "```\\nclass Node{\\n        Node* links[2]={NULL,NULL};\\n        bool flag=false;\\n        \\n    public:\\n        Node* getLink(int bit)\\n        {\\n            return links[bit];\\n        }\\n        void setNull()\\n        {\\n            links[0]=NULL;\\n            links[1]=NULL;\\n        }\\n        void addNewNode(int bit,Node * New)\\n        {\\n            New->setNull();\\n            links[bit]=New;\\n        }\\n    };\\nNode* root;\\nvoid insert(int num)\\n{\\n    Node* cur=root;\\n    for(int i=31;i>0;i--)\\n    {\\n        int mask= 1<<(i-1);\\n        int bit= ((num&mask)>0)?1:0;\\n        if(cur->getLink(bit)==NULL)\\n        {\\n            cur->addNewNode(bit,new Node);\\n        }\\n        cur=cur->getLink(bit);\\n    }\\n}\\nint getMaxXor(int num)\\n{\\n    Node *cur =root;\\n    int Xor=0;\\n    for(int i=31;i>0;i--)\\n    {\\n        int mask= 1<<(i-1);\\n        int bit= ((num&mask)>0)?1:0;\\n        if(cur->getLink(!bit)!=NULL)\\n        {\\n            Xor= Xor|mask;\\n            cur=cur->getLink(!bit);\\n        }\\n        else\\n        {\\n            cur = cur->getLink(bit);\\n        }\\n    }\\n    return Xor;\\n}\\nstatic bool cmp(vector<int>&A, vector<int>&B)\\n{\\n    return A[1]<B[1];\\n}\\nclass Solution {\\npublic:\\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        root= new Node;\\n        root->setNull();\\n        \\n        int n= queries.size();\\n        vector <int>ans(n,0);\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            queries[i].push_back(i);\\n        }\\n        \\n        sort(queries.begin(),queries.end(),cmp);\\n        int lastAdded=0;\\n        \\n        for(auto it:queries)\\n        {\\n            int queryNum= it[2];\\n            while(lastAdded<nums.size() && nums[lastAdded]<=it[1])\\n            {\\n                insert(nums[lastAdded++]);\\n            }\\n            int Xor ;\\n            if(lastAdded==0) //edge case if there is no number smaller than max return -1\\n                Xor=-1;\\n            else\\n                Xor = getMaxXor(it[0]);\\n          \\n             ans[queryNum]=Xor;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Node{\\n        Node* links[2]={NULL,NULL};\\n        bool flag=false;\\n        \\n    public:\\n        Node* getLink(int bit)\\n        {\\n            return links[bit];\\n        }\\n        void setNull()\\n        {\\n            links[0]=NULL;\\n            links[1]=NULL;\\n        }\\n        void addNewNode(int bit,Node * New)\\n        {\\n            New->setNull();\\n            links[bit]=New;\\n        }\\n    };\\nNode* root;\\nvoid insert(int num)\\n{\\n    Node* cur=root;\\n    for(int i=31;i>0;i--)\\n    {\\n        int mask= 1<<(i-1);\\n        int bit= ((num&mask)>0)?1:0;\\n        if(cur->getLink(bit)==NULL)\\n        {\\n            cur->addNewNode(bit,new Node);\\n        }\\n        cur=cur->getLink(bit);\\n    }\\n}\\nint getMaxXor(int num)\\n{\\n    Node *cur =root;\\n    int Xor=0;\\n    for(int i=31;i>0;i--)\\n    {\\n        int mask= 1<<(i-1);\\n        int bit= ((num&mask)>0)?1:0;\\n        if(cur->getLink(!bit)!=NULL)\\n        {\\n            Xor= Xor|mask;\\n            cur=cur->getLink(!bit);\\n        }\\n        else\\n        {\\n            cur = cur->getLink(bit);\\n        }\\n    }\\n    return Xor;\\n}\\nstatic bool cmp(vector<int>&A, vector<int>&B)\\n{\\n    return A[1]<B[1];\\n}\\nclass Solution {\\npublic:\\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        root= new Node;\\n        root->setNull();\\n        \\n        int n= queries.size();\\n        vector <int>ans(n,0);\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            queries[i].push_back(i);\\n        }\\n        \\n        sort(queries.begin(),queries.end(),cmp);\\n        int lastAdded=0;\\n        \\n        for(auto it:queries)\\n        {\\n            int queryNum= it[2];\\n            while(lastAdded<nums.size() && nums[lastAdded]<=it[1])\\n            {\\n                insert(nums[lastAdded++]);\\n            }\\n            int Xor ;\\n            if(lastAdded==0) //edge case if there is no number smaller than max return -1\\n                Xor=-1;\\n            else\\n                Xor = getMaxXor(it[0]);\\n          \\n             ans[queryNum]=Xor;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683563,
                "title": "maximize-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOffline Queries.\\nwhat if we can have only less than or equal to A[i] valued numbers in our trie data structure.\\nWe can then easily know the max xor.\\nIf we can do that, can we sort the arr and insert accordingly in the trie and calculate the answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Node\\n{\\n    private:\\n    Node *links[2]={NULL}; //0,1\\n    public:\\n    Node *get(int bit) { return links[bit];}\\n    void put(int bit,Node* node) {\\n        links[bit]=node;\\n    }\\n    bool contains(int bit){\\n        return links[bit]!=NULL;\\n    }\\n\\n};\\nclass Trie\\n{\\n    private:\\n    Node* root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();//root reference\\n    }\\n    void insert(int num)\\n    {\\n        auto node=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(!node->contains(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n\\n    int maxiXor(int num)\\n    {\\n        auto node=root;\\n        int maxi=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(node->contains(1-bit))\\n            {\\n                maxi= maxi|((1<<i)); //put 1 at that loc if opposite found.\\n                node=node->get(1-bit);\\n            }\\n            else\\n            {\\n                node=node->get(bit);\\n            }\\n        }\\n        return maxi;\\n    }\\n\\n};\\n\\n\\nbool comp(vector<int> &a,vector<int> &b)\\n{\\n    return a[1]<b[1];\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        \\n        Trie trie;\\n    int n=queries.size();\\n    int m=arr.size();\\n    vector<vector<int>> queriess=queries;\\n    vector<int> nums=arr;\\n    vector<int> ans(n);\\n    for(int i=0;i<n;i++)\\n    {\\n        queriess[i].push_back(i);\\n    }\\n    sort(queriess.begin(),queriess.end(),comp);\\n    sort(nums.begin(),nums.end());\\n    int i=0;\\n    for(auto &query:queriess)\\n    {\\n        while(i<m && nums[i]<=query[1])\\n        {\\n            trie.insert(nums[i]);\\n            i++;\\n        }\\n        if(i==0)\\n        {\\n            ans[query[2]]=-1;\\n        }\\n        else\\n        ans[query[2]]=trie.maxiXor(query[0]);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Node\\n{\\n    private:\\n    Node *links[2]={NULL}; //0,1\\n    public:\\n    Node *get(int bit) { return links[bit];}\\n    void put(int bit,Node* node) {\\n        links[bit]=node;\\n    }\\n    bool contains(int bit){\\n        return links[bit]!=NULL;\\n    }\\n\\n};\\nclass Trie\\n{\\n    private:\\n    Node* root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();//root reference\\n    }\\n    void insert(int num)\\n    {\\n        auto node=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(!node->contains(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n\\n    int maxiXor(int num)\\n    {\\n        auto node=root;\\n        int maxi=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(node->contains(1-bit))\\n            {\\n                maxi= maxi|((1<<i)); //put 1 at that loc if opposite found.\\n                node=node->get(1-bit);\\n            }\\n            else\\n            {\\n                node=node->get(bit);\\n            }\\n        }\\n        return maxi;\\n    }\\n\\n};\\n\\n\\nbool comp(vector<int> &a,vector<int> &b)\\n{\\n    return a[1]<b[1];\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        \\n        Trie trie;\\n    int n=queries.size();\\n    int m=arr.size();\\n    vector<vector<int>> queriess=queries;\\n    vector<int> nums=arr;\\n    vector<int> ans(n);\\n    for(int i=0;i<n;i++)\\n    {\\n        queriess[i].push_back(i);\\n    }\\n    sort(queriess.begin(),queriess.end(),comp);\\n    sort(nums.begin(),nums.end());\\n    int i=0;\\n    for(auto &query:queriess)\\n    {\\n        while(i<m && nums[i]<=query[1])\\n        {\\n            trie.insert(nums[i]);\\n            i++;\\n        }\\n        if(i==0)\\n        {\\n            ans[query[2]]=-1;\\n        }\\n        else\\n        ans[query[2]]=trie.maxiXor(query[0]);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3683562,
                "title": "maximize-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOffline Queries.\\nwhat if we can have only less than or equal to A[i] valued numbers in our trie data structure.\\nWe can then easily know the max xor.\\nIf we can do that, can we sort the arr and insert accordingly in the trie and calculate the answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Node\\n{\\n    private:\\n    Node *links[2]={NULL}; //0,1\\n    public:\\n    Node *get(int bit) { return links[bit];}\\n    void put(int bit,Node* node) {\\n        links[bit]=node;\\n    }\\n    bool contains(int bit){\\n        return links[bit]!=NULL;\\n    }\\n\\n};\\nclass Trie\\n{\\n    private:\\n    Node* root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();//root reference\\n    }\\n    void insert(int num)\\n    {\\n        auto node=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(!node->contains(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n\\n    int maxiXor(int num)\\n    {\\n        auto node=root;\\n        int maxi=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(node->contains(1-bit))\\n            {\\n                maxi= maxi|((1<<i)); //put 1 at that loc if opposite found.\\n                node=node->get(1-bit);\\n            }\\n            else\\n            {\\n                node=node->get(bit);\\n            }\\n        }\\n        return maxi;\\n    }\\n\\n};\\n\\n\\nbool comp(vector<int> &a,vector<int> &b)\\n{\\n    return a[1]<b[1];\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        \\n        Trie trie;\\n    int n=queries.size();\\n    int m=arr.size();\\n    vector<vector<int>> queriess=queries;\\n    vector<int> nums=arr;\\n    vector<int> ans(n);\\n    for(int i=0;i<n;i++)\\n    {\\n        queriess[i].push_back(i);\\n    }\\n    sort(queriess.begin(),queriess.end(),comp);\\n    sort(nums.begin(),nums.end());\\n    int i=0;\\n    for(auto &query:queriess)\\n    {\\n        while(i<m && nums[i]<=query[1])\\n        {\\n            trie.insert(nums[i]);\\n            i++;\\n        }\\n        if(i==0)\\n        {\\n            ans[query[2]]=-1;\\n        }\\n        else\\n        ans[query[2]]=trie.maxiXor(query[0]);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Node\\n{\\n    private:\\n    Node *links[2]={NULL}; //0,1\\n    public:\\n    Node *get(int bit) { return links[bit];}\\n    void put(int bit,Node* node) {\\n        links[bit]=node;\\n    }\\n    bool contains(int bit){\\n        return links[bit]!=NULL;\\n    }\\n\\n};\\nclass Trie\\n{\\n    private:\\n    Node* root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();//root reference\\n    }\\n    void insert(int num)\\n    {\\n        auto node=root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(!node->contains(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n\\n    int maxiXor(int num)\\n    {\\n        auto node=root;\\n        int maxi=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(node->contains(1-bit))\\n            {\\n                maxi= maxi|((1<<i)); //put 1 at that loc if opposite found.\\n                node=node->get(1-bit);\\n            }\\n            else\\n            {\\n                node=node->get(bit);\\n            }\\n        }\\n        return maxi;\\n    }\\n\\n};\\n\\n\\nbool comp(vector<int> &a,vector<int> &b)\\n{\\n    return a[1]<b[1];\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) {\\n        \\n        Trie trie;\\n    int n=queries.size();\\n    int m=arr.size();\\n    vector<vector<int>> queriess=queries;\\n    vector<int> nums=arr;\\n    vector<int> ans(n);\\n    for(int i=0;i<n;i++)\\n    {\\n        queriess[i].push_back(i);\\n    }\\n    sort(queriess.begin(),queriess.end(),comp);\\n    sort(nums.begin(),nums.end());\\n    int i=0;\\n    for(auto &query:queriess)\\n    {\\n        while(i<m && nums[i]<=query[1])\\n        {\\n            trie.insert(nums[i]);\\n            i++;\\n        }\\n        if(i==0)\\n        {\\n            ans[query[2]]=-1;\\n        }\\n        else\\n        ans[query[2]]=trie.maxiXor(query[0]);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3664751,
                "title": "similar-to-maximum-xor-of-two-numbers-in-an-array-using-trie-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n    Node* links[2];\\n    bool containskey(int bit){\\n        return (links[bit] != NULL);\\n    }\\n    void put( int bit, Node* node){\\n        links[bit] = node;\\n    }\\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\nprivate: \\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(int num){\\n        Node* node = root;\\n        for(int i =31;i>=0;i--){\\n            int bit = (num>>i) & 1;\\n            if(!node->containskey(bit)){\\n                node->put(bit,new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n   \\n    int givemax(int num){\\n        Node* node = root;\\n        int maxim = 0;\\n        for(int i =31;i>=0;i--){\\n            int bit = (num>>i) & 1;\\n            if(node->containskey(1-bit)){\\n                maxim = maxim | (1<<i);\\n                node = node->get(1-bit);\\n            }\\n            else{\\n\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxim;\\n    }\\n    \\n\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        vector<int>ans(queries.size(),0);\\n        vector<pair<int, pair<int,int>>>sortedqueries;\\n        \\n        for(int i =0;i<queries.size();i++){\\n            int ai = queries[i][1];\\n            int xi = queries[i][0];\\n            sortedqueries.push_back({ai,{xi,i}});\\n        }\\n        sort(sortedqueries.begin(),sortedqueries.end());\\n        int ind  =0;\\n        for(int i =0;i<queries.size();i++){\\n            int ai = sortedqueries[i].first;\\n            int xi = sortedqueries[i].second.first;\\n            int index = sortedqueries[i].second.second;\\n            while(ind<n && nums[ind]<= ai){\\n               \\n                trie.insert(nums[ind]);\\n                ind++;\\n\\n            }\\n            if(ind == 0){\\n                ans[index] = -1;\\n            }\\n            else{\\n                ans[index] = trie.givemax(xi);\\n            }\\n            \\n        }\\n        return ans;\\n\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[2];\\n    bool containskey(int bit){\\n        return (links[bit] != NULL);\\n    }\\n    void put( int bit, Node* node){\\n        links[bit] = node;\\n    }\\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\nprivate: \\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(int num){\\n        Node* node = root;\\n        for(int i =31;i>=0;i--){\\n            int bit = (num>>i) & 1;\\n            if(!node->containskey(bit)){\\n                node->put(bit,new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n   \\n    int givemax(int num){\\n        Node* node = root;\\n        int maxim = 0;\\n        for(int i =31;i>=0;i--){\\n            int bit = (num>>i) & 1;\\n            if(node->containskey(1-bit)){\\n                maxim = maxim | (1<<i);\\n                node = node->get(1-bit);\\n            }\\n            else{\\n\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxim;\\n    }\\n    \\n\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        vector<int>ans(queries.size(),0);\\n        vector<pair<int, pair<int,int>>>sortedqueries;\\n        \\n        for(int i =0;i<queries.size();i++){\\n            int ai = queries[i][1];\\n            int xi = queries[i][0];\\n            sortedqueries.push_back({ai,{xi,i}});\\n        }\\n        sort(sortedqueries.begin(),sortedqueries.end());\\n        int ind  =0;\\n        for(int i =0;i<queries.size();i++){\\n            int ai = sortedqueries[i].first;\\n            int xi = sortedqueries[i].second.first;\\n            int index = sortedqueries[i].second.second;\\n            while(ind<n && nums[ind]<= ai){\\n               \\n                trie.insert(nums[ind]);\\n                ind++;\\n\\n            }\\n            if(ind == 0){\\n                ans[index] = -1;\\n            }\\n            else{\\n                ans[index] = trie.givemax(xi);\\n            }\\n            \\n        }\\n        return ans;\\n\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631657,
                "title": "offline-query-sorting-and-bitwise-trie",
                "content": "Here we will first sort the query annd store it with index . \\nWe will also sort the array.\\nAfter that we will use two pointers for storing the array elements in trie.\\nWe realize that for ans to be maximum , we have to maximize the most significant bit of ans greedily, for which we can use numbers stored in trie.\\nSo if MSB of and is 0 then we have to find such a number such that its MSB is 1 , and vice versa.\\n\\n```\\nstruct trienode{\\n    trienode* child[2];\\n    trienode(){\\n        child[0]=child[1]=nullptr;\\n    }\\n};\\n\\nstruct trie{\\n    trienode* root;\\n    \\n    trie(){\\n        root=new trienode();\\n    }\\n    \\n    void insert(int x){\\n        trienode *curr=root;\\n        for(int i=31;i>=0;i--){\\n            if((x>>i)&1){\\n                if(!curr->child[1]){\\n                    curr->child[1]=new trienode();\\n                }\\n                curr=curr->child[1];\\n            }else{\\n                if(!curr->child[0]){\\n                    curr->child[0]=new trienode();\\n                }\\n                curr=curr->child[0];\\n            }\\n        }\\n    }\\n    \\n    int find_max(int x){\\n        if(root->child[0]==nullptr and root->child[1]==nullptr){\\n            return -1;\\n        }\\n        trienode* curr=root;\\n        int ans=0;\\n        for(int i=31;i>=0;i--){\\n            if((x>>i)&1){\\n                if(curr and curr->child[0]){\\n                    ans+=(1<<i);\\n                    curr=curr->child[0];\\n                }else{\\n                    curr=curr->child[1];\\n                }\\n            }else{\\n                if(curr and curr->child[1]){\\n                    ans+=(1<<i);\\n                    curr=curr->child[1];\\n                }else{\\n                    curr=curr->child[0];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& a, vector<vector<int>>& queries) {\\n        vector<array<int,3>> q;\\n        for(int i=0;i<queries.size();i++){\\n            q.push_back({queries[i][1],queries[i][0],i});\\n        }\\n        sort(q.begin(),q.end());\\n        sort(a.begin(),a.end());\\n        vector<int> ans(q.size(),-1);\\n        trie* t=new trie();\\n        int j=0;\\n        for(int i=0;i<q.size();i++){\\n            int x=q[i][1];\\n            int m=q[i][0];\\n            int idx=q[i][2];\\n            while(j<a.size() && a[j]<=m){\\n                t->insert(a[j]);\\n                j++;\\n            }\\n            int mf=t->find_max(x);\\n            ans[idx]=mf;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nstruct trienode{\\n    trienode* child[2];\\n    trienode(){\\n        child[0]=child[1]=nullptr;\\n    }\\n};\\n\\nstruct trie{\\n    trienode* root;\\n    \\n    trie(){\\n        root=new trienode();\\n    }\\n    \\n    void insert(int x){\\n        trienode *curr=root;\\n        for(int i=31;i>=0;i--){\\n            if((x>>i)&1){\\n                if(!curr->child[1]){\\n                    curr->child[1]=new trienode();\\n                }\\n                curr=curr->child[1];\\n            }else{\\n                if(!curr->child[0]){\\n                    curr->child[0]=new trienode();\\n                }\\n                curr=curr->child[0];\\n            }\\n        }\\n    }\\n    \\n    int find_max(int x){\\n        if(root->child[0]==nullptr and root->child[1]==nullptr){\\n            return -1;\\n        }\\n        trienode* curr=root;\\n        int ans=0;\\n        for(int i=31;i>=0;i--){\\n            if((x>>i)&1){\\n                if(curr and curr->child[0]){\\n                    ans+=(1<<i);\\n                    curr=curr->child[0];\\n                }else{\\n                    curr=curr->child[1];\\n                }\\n            }else{\\n                if(curr and curr->child[1]){\\n                    ans+=(1<<i);\\n                    curr=curr->child[1];\\n                }else{\\n                    curr=curr->child[0];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& a, vector<vector<int>>& queries) {\\n        vector<array<int,3>> q;\\n        for(int i=0;i<queries.size();i++){\\n            q.push_back({queries[i][1],queries[i][0],i});\\n        }\\n        sort(q.begin(),q.end());\\n        sort(a.begin(),a.end());\\n        vector<int> ans(q.size(),-1);\\n        trie* t=new trie();\\n        int j=0;\\n        for(int i=0;i<q.size();i++){\\n            int x=q[i][1];\\n            int m=q[i][0];\\n            int idx=q[i][2];\\n            while(j<a.size() && a[j]<=m){\\n                t->insert(a[j]);\\n                j++;\\n            }\\n            int mf=t->find_max(x);\\n            ans[idx]=mf;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604080,
                "title": "c-easy-solution",
                "content": "# Intuition\\n suppose that trie only conatain elements less than a[i] then it will be a easier problem .for that u need to sort the vector nums, and also sort the queries accourding the index , \\n\\n# Approach\\n first of all sort the num vector, then create a vector<pair<int,pair<int>>> to store the queries,\\nthen sort the above created vector , then iterate on the queries vector which u have created to find the maxXor .\\n\\n# Complexity\\n- **Time complexity**:\\n- O(N * Log (N)) for sorting the array \\n- O(Q * Log(Q)) for sorting the queries vector, where q is the number of queries\\n- O(Q*32 + N*32 ) where q are no of queries , N is the size of nums array\\n\\n- **Space complexity**:\\n Sc ----> O(Q) for storing the queries in the vector \\nand the space taken by the trie can not be exactly determined\\n\\n# Code\\n```\\nclass TrieNode{\\n    private:\\n        vector<TrieNode*> links;\\n    public:\\n    TrieNode(){\\n        links.resize(2,NULL);\\n    }\\n    bool containsKey(int bit){\\n        return links[bit]!=NULL;\\n    }\\n    TrieNode* get(int bit){\\n        return links[bit];\\n    }\\n    void put(int bit ,TrieNode * newNode){\\n        links[bit]=newNode;\\n    }\\n    \\n};\\nclass Trie{\\n    private:\\n    TrieNode* root;\\n    public:\\n    Trie(){\\n        root=new TrieNode();\\n    }\\n    //inserting all the binary digits of a number in the trie\\n    void insert(int num){\\n        TrieNode * node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit =(num>>i)&1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit,new TrieNode());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n    int findMaxXor(int num){\\n        int maxNum=0;\\n        TrieNode* node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(node->containsKey(1-bit)){\\n                maxNum=maxNum | (1<<i);\\n                node=node->get(1-bit);\\n            }    \\n            else {\\n                 node=node->get(bit);\\n            }        \\n        }\\n        return maxNum;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(),nums.end());\\n\\n        vector<pair<int,pair<int,int>>> oQ;\\n        int q=queries.size();\\n        for(int i=0;i<q;i++){\\n            oQ.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n\\n        sort(oQ.begin(),oQ.end());  //this will make sure that trie only contain elements <=a[i]\\n        vector<int> ans(q,0);\\n\\n        int ind=0;\\n        int n=nums.size();\\n        Trie trie;\\n        for(int i=0;i<q;i++){\\n            int ai=oQ[i].first;\\n            int xi=oQ[i].second.first;\\n            int queryInd=oQ[i].second.second;\\n\\n            while(ind < n &&  nums[ind] <= ai){\\n                trie.insert(nums[ind]);\\n                ind++;\\n            }\\n            if(ind==0){\\n                ans[queryInd]=-1;\\n            }\\n            else{\\n                ans[queryInd]=trie.findMaxXor(xi);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TrieNode{\\n    private:\\n        vector<TrieNode*> links;\\n    public:\\n    TrieNode(){\\n        links.resize(2,NULL);\\n    }\\n    bool containsKey(int bit){\\n        return links[bit]!=NULL;\\n    }\\n    TrieNode* get(int bit){\\n        return links[bit];\\n    }\\n    void put(int bit ,TrieNode * newNode){\\n        links[bit]=newNode;\\n    }\\n    \\n};\\nclass Trie{\\n    private:\\n    TrieNode* root;\\n    public:\\n    Trie(){\\n        root=new TrieNode();\\n    }\\n    //inserting all the binary digits of a number in the trie\\n    void insert(int num){\\n        TrieNode * node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit =(num>>i)&1;\\n            if(!node->containsKey(bit)){\\n                node->put(bit,new TrieNode());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n    int findMaxXor(int num){\\n        int maxNum=0;\\n        TrieNode* node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(node->containsKey(1-bit)){\\n                maxNum=maxNum | (1<<i);\\n                node=node->get(1-bit);\\n            }    \\n            else {\\n                 node=node->get(bit);\\n            }        \\n        }\\n        return maxNum;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(),nums.end());\\n\\n        vector<pair<int,pair<int,int>>> oQ;\\n        int q=queries.size();\\n        for(int i=0;i<q;i++){\\n            oQ.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n\\n        sort(oQ.begin(),oQ.end());  //this will make sure that trie only contain elements <=a[i]\\n        vector<int> ans(q,0);\\n\\n        int ind=0;\\n        int n=nums.size();\\n        Trie trie;\\n        for(int i=0;i<q;i++){\\n            int ai=oQ[i].first;\\n            int xi=oQ[i].second.first;\\n            int queryInd=oQ[i].second.second;\\n\\n            while(ind < n &&  nums[ind] <= ai){\\n                trie.insert(nums[ind]);\\n                ind++;\\n            }\\n            if(ind==0){\\n                ans[queryInd]=-1;\\n            }\\n            else{\\n                ans[queryInd]=trie.findMaxXor(xi);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558306,
                "title": "trie-template-code-offline-query",
                "content": "```\\nstruct Node{\\n    \\n    Node* links[2];\\n    \\n    bool cointainsKey(int bit)\\n    {\\n        return (links[bit]!=NULL);\\n    }\\n    \\n    void put(int i,Node* node)\\n    {\\n        links[i]=node;\\n    }\\n    \\n    Node * get(int i)\\n    {\\n        return links[i];\\n    }\\n    \\n};\\nclass Trie\\n{\\n    Node * root;\\n    \\n    public:\\n    \\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    \\n    void insert(int num)\\n    {\\n        Node* node=root;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            \\n            if(!node->cointainsKey(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n    int findMax(int num)\\n    {\\n        Node* node=root;\\n        \\n        int maxNum=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n           \\n            if(node->cointainsKey(!bit))\\n            {\\n                maxNum=maxNum|(1<<i);\\n                node=node->get(!bit);    \\n            }\\n            else\\n            {\\n                node=node->get(bit);    \\n            }\\n            \\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) \\n    {\\n        sort(nums.begin(),nums.end());\\n        \\n        vector<pair<int,pair<int,int>>> offlineQuery;\\n        \\n        int n=nums.size(),q=queries.size();\\n        \\n        for(int i=0;i<q;i++)\\n        {\\n            offlineQuery.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n                                              \\n        sort(offlineQuery.begin(),offlineQuery.end());\\n        \\n        int ind=0;\\n        Trie trie;\\n        vector<int> ans(q,0);\\n        \\n        for(int i=0;i<q;i++)\\n        {\\n            int ai=offlineQuery[i].first;\\n            int xi=offlineQuery[i].second.first;\\n            int qi=offlineQuery[i].second.second;\\n            \\n            while(ind<n && nums[ind]<=ai)\\n            {\\n                trie.insert(nums[ind]);\\n                ind++;\\n            }\\n            if(ind==0) \\n                ans[qi]=-1;\\n            else\\n                ans[qi]=trie.findMax(xi);\\n        }\\n                                              \\n                                              \\n        return ans;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    \\n    Node* links[2];\\n    \\n    bool cointainsKey(int bit)\\n    {\\n        return (links[bit]!=NULL);\\n    }\\n    \\n    void put(int i,Node* node)\\n    {\\n        links[i]=node;\\n    }\\n    \\n    Node * get(int i)\\n    {\\n        return links[i];\\n    }\\n    \\n};\\nclass Trie\\n{\\n    Node * root;\\n    \\n    public:\\n    \\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    \\n    void insert(int num)\\n    {\\n        Node* node=root;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            \\n            if(!node->cointainsKey(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n        }\\n    }\\n    int findMax(int num)\\n    {\\n        Node* node=root;\\n        \\n        int maxNum=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n           \\n            if(node->cointainsKey(!bit))\\n            {\\n                maxNum=maxNum|(1<<i);\\n                node=node->get(!bit);    \\n            }\\n            else\\n            {\\n                node=node->get(bit);    \\n            }\\n            \\n        }\\n        return maxNum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) \\n    {\\n        sort(nums.begin(),nums.end());\\n        \\n        vector<pair<int,pair<int,int>>> offlineQuery;\\n        \\n        int n=nums.size(),q=queries.size();\\n        \\n        for(int i=0;i<q;i++)\\n        {\\n            offlineQuery.push_back({queries[i][1],{queries[i][0],i}});\\n        }\\n                                              \\n        sort(offlineQuery.begin(),offlineQuery.end());\\n        \\n        int ind=0;\\n        Trie trie;\\n        vector<int> ans(q,0);\\n        \\n        for(int i=0;i<q;i++)\\n        {\\n            int ai=offlineQuery[i].first;\\n            int xi=offlineQuery[i].second.first;\\n            int qi=offlineQuery[i].second.second;\\n            \\n            while(ind<n && nums[ind]<=ai)\\n            {\\n                trie.insert(nums[ind]);\\n                ind++;\\n            }\\n            if(ind==0) \\n                ans[qi]=-1;\\n            else\\n                ans[qi]=trie.findMax(xi);\\n        }\\n                                              \\n                                              \\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553148,
                "title": "c-solution-using-trie-and-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we want to find the maximum xor with a number we would try to find another number with as many opposite bits in each place as the first number as xor of opposite bits gives 1 and of same bits gives 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will first sort all numbers in the array and then the queries according to their limit while keeping a track of their index in a multimap.\\nWe will then go through the queries and for each query, we will insert numbers from the array into the trie that we haven\\'t inserted before and that don\\'t cross the limit for that query.\\nWe then traverse through the trie while trying to pass through opposite bits as that of the number if not possible take the same bit and update the result.\\n\\n# Code\\n```\\nclass TrieNode {\\npublic:\\n    bool bit;\\n    pair<TrieNode*,TrieNode*> p;\\n    TrieNode(bool b) {\\n        bit=b;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void insert(TrieNode *t,int it) {\\n        for(int i=31;i>=0;i--) {\\n            int bit=it & (1<<i);\\n            if(bit) {\\n                if(!(t->p).second) (t->p).second = new TrieNode(1);\\n                t=(t->p).second;\\n            } else {\\n                if(!(t->p).first) (t->p).first = new TrieNode(0);\\n                t=(t->p).first;\\n            }\\n        }\\n    }\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> res(queries.size(),0);\\n        TrieNode* root=new TrieNode(0);\\n        multimap<vector<int>,int> q;\\n        for(int i=0;i<queries.size();i++) {\\n            swap(queries[i][0],queries[i][1]);\\n            q.insert({queries[i],i});\\n        }\\n        sort(nums.begin(),nums.end());\\n        int n=0;\\n        for(auto itr:q) {\\n            TrieNode* t=root;\\n            int cur=0;\\n            int it=itr.first[1];\\n            int m=itr.first[0];\\n            int idx=itr.second;\\n            while(n<nums.size() && nums[n]<=m) {\\n                insert(t,nums[n]);\\n                n++;\\n            }\\n            if(n==0) {\\n                res[idx]=-1;\\n                continue;\\n            }\\n            for(int i=31;i>=0;i--) {\\n                int bit=(1<<i) & it;\\n                if(bit) {\\n                    if((t->p).first) {\\n                        cur=cur | (1<<i);\\n                        t=(t->p).first;\\n                    } else {\\n                        t=(t->p).second;\\n                    }\\n                } else {\\n                    if((t->p).second) {\\n                        cur=cur | (1<<i);\\n                        t=(t->p).second;\\n                    } else {\\n                        t=(t->p).first;\\n                    }\\n                }\\n            }\\n            res[idx]=cur;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    bool bit;\\n    pair<TrieNode*,TrieNode*> p;\\n    TrieNode(bool b) {\\n        bit=b;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void insert(TrieNode *t,int it) {\\n        for(int i=31;i>=0;i--) {\\n            int bit=it & (1<<i);\\n            if(bit) {\\n                if(!(t->p).second) (t->p).second = new TrieNode(1);\\n                t=(t->p).second;\\n            } else {\\n                if(!(t->p).first) (t->p).first = new TrieNode(0);\\n                t=(t->p).first;\\n            }\\n        }\\n    }\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> res(queries.size(),0);\\n        TrieNode* root=new TrieNode(0);\\n        multimap<vector<int>,int> q;\\n        for(int i=0;i<queries.size();i++) {\\n            swap(queries[i][0],queries[i][1]);\\n            q.insert({queries[i],i});\\n        }\\n        sort(nums.begin(),nums.end());\\n        int n=0;\\n        for(auto itr:q) {\\n            TrieNode* t=root;\\n            int cur=0;\\n            int it=itr.first[1];\\n            int m=itr.first[0];\\n            int idx=itr.second;\\n            while(n<nums.size() && nums[n]<=m) {\\n                insert(t,nums[n]);\\n                n++;\\n            }\\n            if(n==0) {\\n                res[idx]=-1;\\n                continue;\\n            }\\n            for(int i=31;i>=0;i--) {\\n                int bit=(1<<i) & it;\\n                if(bit) {\\n                    if((t->p).first) {\\n                        cur=cur | (1<<i);\\n                        t=(t->p).first;\\n                    } else {\\n                        t=(t->p).second;\\n                    }\\n                } else {\\n                    if((t->p).second) {\\n                        cur=cur | (1<<i);\\n                        t=(t->p).second;\\n                    } else {\\n                        t=(t->p).first;\\n                    }\\n                }\\n            }\\n            res[idx]=cur;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550496,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))\\n        ans = [-1]*len(queries)\\n        \\n        trie = {}\\n        k = 0\\n        for m, x, i in queries: \\n            while k < len(nums) and nums[k] <= m: \\n                node = trie\\n                val = bin(nums[k])[2:].zfill(32)\\n                for c in val: node = node.setdefault(int(c), {})\\n                node[\"#\"] = nums[k]\\n                k += 1\\n            if trie: \\n                node = trie\\n                val = bin(x)[2:].zfill(32)\\n                for c in val: node = node.get(1-int(c)) or node.get(int(c))\\n                ans[i] = x ^ node[\"#\"]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))\\n        ans = [-1]*len(queries)\\n        \\n        trie = {}\\n        k = 0\\n        for m, x, i in queries: \\n            while k < len(nums) and nums[k] <= m: \\n                node = trie\\n                val = bin(nums[k])[2:].zfill(32)\\n                for c in val: node = node.setdefault(int(c), {})\\n                node[\"#\"] = nums[k]\\n                k += 1\\n            if trie: \\n                node = trie\\n                val = bin(x)[2:].zfill(32)\\n                for c in val: node = node.get(1-int(c)) or node.get(int(c))\\n                ans[i] = x ^ node[\"#\"]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528507,
                "title": "java-solution-with-detailed-explaination-trie-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int n = nums.length;\\n        int m = queries.length;\\n\\n        // Create an arraylist of Pair objects representing each query\\n        ArrayList<Pair> query = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            query.add(new Pair(queries[i], i)); // add each query as a Pair object to the arraylist\\n        }\\n\\n        // Sort the query arraylist in ascending order of the second element of the query arrays\\n        Collections.sort(query, (x, y) -> x.arr[1] - y.arr[1]);\\n\\n        // Sort the nums array in ascending order\\n        Arrays.sort(nums);\\n\\n        // Create a Trie object to store the nums array in binary format\\n        Trie trie = new Trie();\\n\\n        // Create an arraylist to store the answers to the queries\\n        ArrayList<Integer> ans = new ArrayList<>(m);\\n\\n        // Initialize the ans arraylist with -1 for each query\\n        for (int i = 0; i < m; i++) {\\n            ans.add(-1);\\n        }\\n\\n        int ind = 0; // index to keep track of the current position in the nums array\\n\\n        // Iterate over each query in the query arraylist\\n        for (int i = 0; i < m; i++) {\\n\\n            // Insert all elements of the nums array that are less than or equal to the current query into the Trie\\n            while (ind < n && nums[ind] <= query.get(i).arr[1]) {\\n                trie.insert(nums[ind++]);\\n            }\\n\\n            // If there are any elements in the Trie, get the maximum XOR value for the current query and update the ans arraylist\\n            if (ind != 0) {\\n                ans.set(query.get(i).ind, trie.getMax(query.get(i).arr[0]));\\n            } else { // Otherwise, set the answer to -1\\n                ans.set(query.get(i).ind, -1);\\n            }\\n        }\\n\\n        // Convert the ans arraylist to an array and return it\\n        int[] sol = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            sol[i] = ans.get(i);\\n        }\\n        return sol;\\n    }\\n}\\n\\n// Definition of a Trie node\\nclass TrieNode {\\n    TrieNode[] links; // an array of TrieNode objects\\n    TrieNode() {\\n        links = new TrieNode[2]; // initialize the links array with two null pointers\\n    }\\n    boolean containsKey(int n) {\\n        return links[n] != null; // returns true if the n-th element of the links array is not null\\n    }\\n    TrieNode get(int n) {\\n        return links[n]; // returns the n-th element of the links array\\n    }\\n    void put(int n, TrieNode node) {\\n        links[n] = node; // sets the n-th element of the links array to the specified TrieNode object\\n    }\\n}\\n\\n// Definition of a Trie\\nclass Trie{\\n\\tTrieNode root=new TrieNode(); // Initialize Trie with a root node\\n\\tTrie(){}\\n\\tvoid insert(int num){\\n\\t\\tTrieNode node=root;\\n\\t\\tfor(int i=31;i>=0;i--){ // Loop through all the bits of the number (32 bits)\\n\\t\\t\\tint bit=(num>>i) & 1; // Get the i-th bit of the number\\n\\t\\t\\tif(!node.containsKey(bit)){ // If the current node doesn\\'t have the child node for the bit\\n\\t\\t\\t\\tnode.put(bit, new TrieNode()); // Create a new child node for the bit\\n\\t\\t\\t}\\n\\t\\t\\tnode=node.get(bit); // Move to the child node for the bit\\n\\t\\t}\\n\\t}\\n\\tint getMax(int num){\\n\\t\\tTrieNode node=root;\\n\\t\\tint max=0;\\n\\t\\tfor(int i=31;i>=0;i--){ // Loop through all the bits of the query number (32 bits)\\n\\t\\t\\tint bit=(num>>i)&1; // Get the i-th bit of the query number\\n\\t\\t\\tif(node.containsKey(1-bit)){ // If the current node has the child node for the complement of the bit\\n\\t\\t\\t\\tmax=max|(1<<i); // Set the i-th bit of the max number to 1\\n\\t\\t\\t\\tnode=node.get(1-bit); // Move to the child node for the complement of the bit\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tnode=node.get(bit); // Move to the child node for the bit\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max; // Return the maximum XOR value found in the Trie\\n\\t}\\n}\\n\\n// Define Pair class to store each query and its index\\nclass Pair{\\n\\tint [] arr; // Array to store the query parameters\\n\\tint ind; // Index of the query\\n\\tPair(int []arr,int ind){\\n\\t\\tthis.arr=arr; // Initialize the query parameters\\n\\t\\tthis.ind=ind; // Initialize the query index\\n\\t}\\n} \\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int n = nums.length;\\n        int m = queries.length;\\n\\n        // Create an arraylist of Pair objects representing each query\\n        ArrayList<Pair> query = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            query.add(new Pair(queries[i], i)); // add each query as a Pair object to the arraylist\\n        }\\n\\n        // Sort the query arraylist in ascending order of the second element of the query arrays\\n        Collections.sort(query, (x, y) -> x.arr[1] - y.arr[1]);\\n\\n        // Sort the nums array in ascending order\\n        Arrays.sort(nums);\\n\\n        // Create a Trie object to store the nums array in binary format\\n        Trie trie = new Trie();\\n\\n        // Create an arraylist to store the answers to the queries\\n        ArrayList<Integer> ans = new ArrayList<>(m);\\n\\n        // Initialize the ans arraylist with -1 for each query\\n        for (int i = 0; i < m; i++) {\\n            ans.add(-1);\\n        }\\n\\n        int ind = 0; // index to keep track of the current position in the nums array\\n\\n        // Iterate over each query in the query arraylist\\n        for (int i = 0; i < m; i++) {\\n\\n            // Insert all elements of the nums array that are less than or equal to the current query into the Trie\\n            while (ind < n && nums[ind] <= query.get(i).arr[1]) {\\n                trie.insert(nums[ind++]);\\n            }\\n\\n            // If there are any elements in the Trie, get the maximum XOR value for the current query and update the ans arraylist\\n            if (ind != 0) {\\n                ans.set(query.get(i).ind, trie.getMax(query.get(i).arr[0]));\\n            } else { // Otherwise, set the answer to -1\\n                ans.set(query.get(i).ind, -1);\\n            }\\n        }\\n\\n        // Convert the ans arraylist to an array and return it\\n        int[] sol = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            sol[i] = ans.get(i);\\n        }\\n        return sol;\\n    }\\n}\\n\\n// Definition of a Trie node\\nclass TrieNode {\\n    TrieNode[] links; // an array of TrieNode objects\\n    TrieNode() {\\n        links = new TrieNode[2]; // initialize the links array with two null pointers\\n    }\\n    boolean containsKey(int n) {\\n        return links[n] != null; // returns true if the n-th element of the links array is not null\\n    }\\n    TrieNode get(int n) {\\n        return links[n]; // returns the n-th element of the links array\\n    }\\n    void put(int n, TrieNode node) {\\n        links[n] = node; // sets the n-th element of the links array to the specified TrieNode object\\n    }\\n}\\n\\n// Definition of a Trie\\nclass Trie{\\n\\tTrieNode root=new TrieNode(); // Initialize Trie with a root node\\n\\tTrie(){}\\n\\tvoid insert(int num){\\n\\t\\tTrieNode node=root;\\n\\t\\tfor(int i=31;i>=0;i--){ // Loop through all the bits of the number (32 bits)\\n\\t\\t\\tint bit=(num>>i) & 1; // Get the i-th bit of the number\\n\\t\\t\\tif(!node.containsKey(bit)){ // If the current node doesn\\'t have the child node for the bit\\n\\t\\t\\t\\tnode.put(bit, new TrieNode()); // Create a new child node for the bit\\n\\t\\t\\t}\\n\\t\\t\\tnode=node.get(bit); // Move to the child node for the bit\\n\\t\\t}\\n\\t}\\n\\tint getMax(int num){\\n\\t\\tTrieNode node=root;\\n\\t\\tint max=0;\\n\\t\\tfor(int i=31;i>=0;i--){ // Loop through all the bits of the query number (32 bits)\\n\\t\\t\\tint bit=(num>>i)&1; // Get the i-th bit of the query number\\n\\t\\t\\tif(node.containsKey(1-bit)){ // If the current node has the child node for the complement of the bit\\n\\t\\t\\t\\tmax=max|(1<<i); // Set the i-th bit of the max number to 1\\n\\t\\t\\t\\tnode=node.get(1-bit); // Move to the child node for the complement of the bit\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tnode=node.get(bit); // Move to the child node for the bit\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max; // Return the maximum XOR value found in the Trie\\n\\t}\\n}\\n\\n// Define Pair class to store each query and its index\\nclass Pair{\\n\\tint [] arr; // Array to store the query parameters\\n\\tint ind; // Index of the query\\n\\tPair(int []arr,int ind){\\n\\t\\tthis.arr=arr; // Initialize the query parameters\\n\\t\\tthis.ind=ind; // Initialize the query index\\n\\t}\\n} \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512456,
                "title": "python-simple-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.dict1 = {}\\n        \\n    def insert(self, num):\\n        dict2 = self.dict1\\n        \\n        for i in range(31,-1,-1):\\n            bit = (num >> i)&1\\n            if bit not in dict2:\\n                dict2[bit] = {}\\n                \\n            dict2 = dict2[bit]\\n            \\n    def query(self, num):\\n        if not self.dict1: return -1\\n        \\n        dict2, xor = self.dict1, 0\\n        \\n        for i in range(31,-1,-1):\\n            bit = (num >> i)&1\\n            if (1-bit) in dict2:\\n                xor |= (1<<i)\\n                dict2 = dict2[1-bit]\\n            else:\\n                dict2 = dict2[bit]\\n                \\n        return xor\\n\\nclass Solution:\\n    def maximizeXor(self, nums, queries):\\n        nums.sort()\\n        queries = sorted(enumerate(queries), key = lambda x: x[1][1])\\n        j, trie, ans = 0, Trie(), [-1]*len(queries)\\n        \\n        for i, (x,m) in queries:\\n            while j < len(nums) and nums[j] <= m:\\n                trie.insert(nums[j])\\n                j += 1\\n            ans[i] = trie.query(x)\\n            \\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.dict1 = {}\\n        \\n    def insert(self, num):\\n        dict2 = self.dict1\\n        \\n        for i in range(31,-1,-1):\\n            bit = (num >> i)&1\\n            if bit not in dict2:\\n                dict2[bit] = {}\\n                \\n            dict2 = dict2[bit]\\n            \\n    def query(self, num):\\n        if not self.dict1: return -1\\n        \\n        dict2, xor = self.dict1, 0\\n        \\n        for i in range(31,-1,-1):\\n            bit = (num >> i)&1\\n            if (1-bit) in dict2:\\n                xor |= (1<<i)\\n                dict2 = dict2[1-bit]\\n            else:\\n                dict2 = dict2[bit]\\n                \\n        return xor\\n\\nclass Solution:\\n    def maximizeXor(self, nums, queries):\\n        nums.sort()\\n        queries = sorted(enumerate(queries), key = lambda x: x[1][1])\\n        j, trie, ans = 0, Trie(), [-1]*len(queries)\\n        \\n        for i, (x,m) in queries:\\n            while j < len(nums) and nums[j] <= m:\\n                trie.insert(nums[j])\\n                j += 1\\n            ans[i] = trie.query(x)\\n            \\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476395,
                "title": "easy-trie-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct Node{\\n         Node* links[2];\\n         bool isConatins(int ind)\\n         {\\n             return links[ind]!=NULL;\\n         }\\n         void put(int ind,Node* node)\\n         {\\n           links[ind]=node;\\n         }\\n         Node* get(int ind)\\n         {\\n             return links[ind];\\n         }\\n    };\\n    class Trie{\\n        public:\\n        Node* root;\\n        Trie()\\n        {\\n           root=new Node();\\n        }\\n        void insert(int num)\\n        {\\n            Node* node=root;\\n            for (int i=31;i>=0;i--)\\n            {\\n                int bit=((num>>i)&1);\\n                if (!node->isConatins(bit))\\n                {\\n                    node->put(bit,new Node());\\n                }\\n                node=node->get(bit);\\n            }\\n        }\\n        int maxNum(int num)\\n        {\\n            int ans=0;\\n            Node* node=root;\\n            for (int i=31;i>=0;i--)\\n            {\\n                int bit=((num>>i)&1);\\n                if (node->isConatins(1-bit))\\n                {\\n                    ans|=(1<<i);\\n                    node=node->get(1-bit);\\n                }\\n                else{\\n                    node=node->get(bit);\\n                }\\n            }\\n            return ans;\\n        }\\n    };\\n\\n    bool static comp(vector<int>&a,vector<int>&b)\\n    {\\n        return a[1]<b[1];\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        for (int i=0;i<queries.size();i++)\\n        {\\n            queries[i].push_back(i);\\n        }\\n        sort(nums.begin(),nums.end());\\n        sort(queries.begin(),queries.end(),comp);\\n        int ind=0;\\n        vector<int>ans(queries.size());\\n        Trie * trie=new Trie();\\n        for (int i=0;i<queries.size();i++)\\n        {\\n            while(ind<nums.size() && nums[ind]<=queries[i][1])\\n            {\\n                trie->insert(nums[ind]);\\n                ind++;\\n            }\\n           if (ind==0)\\n           {\\n               ans[queries[i][2]]=-1;\\n           }\\n           else ans[queries[i][2]]=trie->maxNum(queries[i][0]);\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n         Node* links[2];\\n         bool isConatins(int ind)\\n         {\\n             return links[ind]!=NULL;\\n         }\\n         void put(int ind,Node* node)\\n         {\\n           links[ind]=node;\\n         }\\n         Node* get(int ind)\\n         {\\n             return links[ind];\\n         }\\n    };\\n    class Trie{\\n        public:\\n        Node* root;\\n        Trie()\\n        {\\n           root=new Node();\\n        }\\n        void insert(int num)\\n        {\\n            Node* node=root;\\n            for (int i=31;i>=0;i--)\\n            {\\n                int bit=((num>>i)&1);\\n                if (!node->isConatins(bit))\\n                {\\n                    node->put(bit,new Node());\\n                }\\n                node=node->get(bit);\\n            }\\n        }\\n        int maxNum(int num)\\n        {\\n            int ans=0;\\n            Node* node=root;\\n            for (int i=31;i>=0;i--)\\n            {\\n                int bit=((num>>i)&1);\\n                if (node->isConatins(1-bit))\\n                {\\n                    ans|=(1<<i);\\n                    node=node->get(1-bit);\\n                }\\n                else{\\n                    node=node->get(bit);\\n                }\\n            }\\n            return ans;\\n        }\\n    };\\n\\n    bool static comp(vector<int>&a,vector<int>&b)\\n    {\\n        return a[1]<b[1];\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        for (int i=0;i<queries.size();i++)\\n        {\\n            queries[i].push_back(i);\\n        }\\n        sort(nums.begin(),nums.end());\\n        sort(queries.begin(),queries.end(),comp);\\n        int ind=0;\\n        vector<int>ans(queries.size());\\n        Trie * trie=new Trie();\\n        for (int i=0;i<queries.size();i++)\\n        {\\n            while(ind<nums.size() && nums[ind]<=queries[i][1])\\n            {\\n                trie->insert(nums[ind]);\\n                ind++;\\n            }\\n           if (ind==0)\\n           {\\n               ans[queries[i][2]]=-1;\\n           }\\n           else ans[queries[i][2]]=trie->maxNum(queries[i][0]);\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370734,
                "title": "trie-offline-queries",
                "content": "\\n\\n# Code\\n```\\n\\nstruct Node{\\n    Node *links[2];\\n\\n    Node(){\\n        for(int i=0; i < 2; i++){\\n            links[i] = NULL;\\n        }\\n    }\\n\\n    bool containsKey(int bit){\\n        return (links[bit] != NULL);\\n    }\\n\\n    void put(int bit,Node* node){\\n        links[bit] = node;\\n    }\\n\\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie{\\nprivate:\\n\\tNode* root;\\npublic: \\n\\tTrie(){\\n\\t\\troot = new Node();\\n\\t}\\n\\n\\tvoid insert(int num){\\n\\t\\tNode* node = root;\\n\\t\\tfor(int i = 31; i >= 0; i--){\\n\\t\\t\\tint bit = (num>>i) & 1;\\n\\t\\t\\tif(!node->containsKey(bit)){\\n\\t\\t\\t\\tnode->put(bit,new Node());\\n\\t\\t\\t}\\n\\t\\t\\tnode = node->get(bit);\\n\\t\\t}\\n\\t}\\n\\n    int getMax(int num){\\n        Node* node = root;\\n        int maxi = 0;\\n        for(int i = 31; i >= 0; i--){\\n            int bit = (num >> i) & 1;\\n            if(node->containsKey(1-bit)){\\n                maxi = maxi | (1 << i);\\n                node = node->get(1-bit);\\n            }else{\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxi;\\n    }\\n\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n\\n        Trie trie;\\n\\n        int n = queries.size();\\n        vector<int> ans(n,0);\\n\\n        // {mi,{xi,query-number}}\\n\\n        multiset<pair<int,pair<int,int>>> st;\\n        int i = 0;\\n\\n        for(auto query:queries){\\n            st.insert({query[1],{query[0],i}});\\n            i++;\\n        }\\n\\n        sort(nums.begin(),nums.end());\\n\\n        i = 0;\\n        while(!st.empty()){\\n            auto it = *(st.begin());\\n            int m = it.first;\\n            int key = it.second.first;\\n            int qn = it.second.second;\\n\\n            st.erase(it);\\n\\n            while(i < nums.size() and nums[i] <= m){\\n                trie.insert(nums[i]);\\n                i++;\\n            }\\n\\n            if(i == 0){\\n                ans[qn] = -1;\\n            }else{\\n                ans[qn] = trie.getMax(key);\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nstruct Node{\\n    Node *links[2];\\n\\n    Node(){\\n        for(int i=0; i < 2; i++){\\n            links[i] = NULL;\\n        }\\n    }\\n\\n    bool containsKey(int bit){\\n        return (links[bit] != NULL);\\n    }\\n\\n    void put(int bit,Node* node){\\n        links[bit] = node;\\n    }\\n\\n    Node* get(int bit){\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie{\\nprivate:\\n\\tNode* root;\\npublic: \\n\\tTrie(){\\n\\t\\troot = new Node();\\n\\t}\\n\\n\\tvoid insert(int num){\\n\\t\\tNode* node = root;\\n\\t\\tfor(int i = 31; i >= 0; i--){\\n\\t\\t\\tint bit = (num>>i) & 1;\\n\\t\\t\\tif(!node->containsKey(bit)){\\n\\t\\t\\t\\tnode->put(bit,new Node());\\n\\t\\t\\t}\\n\\t\\t\\tnode = node->get(bit);\\n\\t\\t}\\n\\t}\\n\\n    int getMax(int num){\\n        Node* node = root;\\n        int maxi = 0;\\n        for(int i = 31; i >= 0; i--){\\n            int bit = (num >> i) & 1;\\n            if(node->containsKey(1-bit)){\\n                maxi = maxi | (1 << i);\\n                node = node->get(1-bit);\\n            }else{\\n                node = node->get(bit);\\n            }\\n        }\\n        return maxi;\\n    }\\n\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n\\n        Trie trie;\\n\\n        int n = queries.size();\\n        vector<int> ans(n,0);\\n\\n        // {mi,{xi,query-number}}\\n\\n        multiset<pair<int,pair<int,int>>> st;\\n        int i = 0;\\n\\n        for(auto query:queries){\\n            st.insert({query[1],{query[0],i}});\\n            i++;\\n        }\\n\\n        sort(nums.begin(),nums.end());\\n\\n        i = 0;\\n        while(!st.empty()){\\n            auto it = *(st.begin());\\n            int m = it.first;\\n            int key = it.second.first;\\n            int qn = it.second.second;\\n\\n            st.erase(it);\\n\\n            while(i < nums.size() and nums[i] <= m){\\n                trie.insert(nums[i]);\\n                i++;\\n            }\\n\\n            if(i == 0){\\n                ans[qn] = -1;\\n            }else{\\n                ans[qn] = trie.getMax(key);\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363321,
                "title": "c-trie",
                "content": "# Complexity\\n- Time complexity: max(Q* log(Q),N * log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(Q + N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass query{\\n\\n    public:\\n      int xi;\\n      int mi;\\n      int index;\\n\\n      void set(int mi,int xi,int index){\\n          this->mi=mi;\\n          this->xi=xi;\\n          this->index= index;\\n      }\\n\\n};\\nstatic bool cmp(query a,query b){\\n       return a.mi<b.mi;\\n}\\nclass Node{\\n public:\\n    Node* list[2];\\n\\n     bool contain(int a){\\n         return list[a]!=NULL;       \\n     }\\n     void add(int a){\\n         list[a]=new Node(); \\n     }\\n     Node* get(int a){\\n         return list[a];\\n     }\\n};\\nclass Trie{\\n    private: \\n    Node* root;\\n    \\n    public:\\n    Trie(){\\n        root=new Node();\\n    }\\n    \\n    void insert(int num){\\n    Node* iter= root;\\n    \\n     for(int i=31;i>=0;i--){\\n         int bit= (num>>i) & 1;\\n          \\n           if(!iter->contain(bit)){\\n               iter->add(bit);\\n           }\\n          iter=iter->get(bit);\\n     }\\n    }\\n        \\n    int getmaxor(int num){\\n        Node* iter= root;\\n        int temp=0;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(iter->contain(1-bit)){\\n                iter= iter->get(1-bit);\\n                temp= temp | 1<<i;\\n            }\\n            else{\\n                iter=iter->get(bit);\\n            }\\n        }\\n        return temp;\\n    }\\n        \\n    \\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n       Trie node;\\n       int size= queries.size();\\n       vector<int> ans(size,-1);\\n\\n        sort(nums.begin(),nums.end()); \\n    \\n        vector<query> qarr(size);\\n\\n        int i=0;\\n        while(i<size){\\n           qarr[i].set(queries[i][1],queries[i][0],i);\\n            i++;\\n        }\\n        sort(qarr.begin(),qarr.end(),cmp);\\n\\n        int idx=0;\\n        int n= nums.size();\\n        for(auto it : qarr){\\n\\n            while(idx<n && nums[idx]<=it.mi){\\n                node.insert(nums[idx]);\\n                idx++;\\n            }\\n            if(idx==0) continue;\\n            ans[it.index]= node.getmaxor(it.xi);\\n\\n        }\\nreturn ans;\\n\\n\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n       Trie node;\\n       int size= queries.size();\\n       vector<int> ans(size,-1);\\n\\n        sort(nums.begin(),nums.end()); \\n    \\n        vector<query> qarr(size);\\n\\n        int i=0;\\n        while(i<size){\\n           qarr[i].set(queries[i][1],queries[i][0],i);\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3358426,
                "title": "easy-trie-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCorresponding number which can give Xor with given value x\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimilar to find maximum xor in Trie medium\\nBut some changes.\\nChanges are:\\nNums have to be sorted.\\nNew queries which contains relative order as its original and is sorted according to queries[i][1].\\nWe only insert nums according to maximum queries[i][1].\\nThis satisfies our second condition in question nums[j]<=mi\\n\\nFor -1\\nwe check if queries[i][1]<nums(sorted)[0] \\n\\n# Complexity\\n- Time complexity: Q*N*32 \\n-   where Q and N are the size of the given arrays.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{\\npublic:\\n    Node* bits[2];\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int num){\\n        Node* curr=root;\\n        for(int i{31};i>=0;--i){\\n            int bit=(num>>i)&1;\\n            if(!curr->bits[bit])\\n                curr->bits[bit]=new Node();\\n            curr=curr->bits[bit];\\n        }\\n    }\\n    int getMaxm(int num){\\n        int maxmNo=0;\\n        Node* curr=root;\\n        for(int i{31};i>=0;--i){\\n            int bit=(num>>i)&1;\\n            int mark=0;\\n            if(curr->bits[!bit]){\\n                mark=!bit;\\n                curr=curr->bits[!bit];\\n            }else{\\n                mark=bit;\\n                curr=curr->bits[bit];\\n            }\\n            maxmNo=maxmNo|(mark<<i);\\n        }\\n        return maxmNo;\\n    } \\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<vector<int>>offlineQueries;\\n        for(int i{0};i<queries.size();++i){\\n            vector<int>temp{queries[i][1],queries[i][0],i};\\n            offlineQueries.push_back(temp);\\n        }\\n\\n        sort(nums.begin(),nums.end());\\n        sort(offlineQueries.begin(),offlineQueries.end());\\n        \\n        Trie t;\\n        unordered_map<int,int>um;\\n        \\n        int i=0;\\n\\n        for(auto query:offlineQueries){\\n            while(i<nums.size() && nums[i]<=query[0]){\\n                t.insert(nums[i]);\\n                i++;\\n            }\\n            if(query[0]>=nums[0]){\\n                int val=t.getMaxm(query[1]);\\n                um[query[2]]=val^query[1];\\n            }else{\\n                um[query[2]]=-1;\\n            }\\n\\n        }\\n        \\n        vector<int>ans;\\n        for(int k{0};k<queries.size();++k){\\n            ans.push_back(um[k]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\npublic:\\n    Node* bits[2];\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int num){\\n        Node* curr=root;\\n        for(int i{31};i>=0;--i){\\n            int bit=(num>>i)&1;\\n            if(!curr->bits[bit])\\n                curr->bits[bit]=new Node();\\n            curr=curr->bits[bit];\\n        }\\n    }\\n    int getMaxm(int num){\\n        int maxmNo=0;\\n        Node* curr=root;\\n        for(int i{31};i>=0;--i){\\n            int bit=(num>>i)&1;\\n            int mark=0;\\n            if(curr->bits[!bit]){\\n                mark=!bit;\\n                curr=curr->bits[!bit];\\n            }else{\\n                mark=bit;\\n                curr=curr->bits[bit];\\n            }\\n            maxmNo=maxmNo|(mark<<i);\\n        }\\n        return maxmNo;\\n    } \\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<vector<int>>offlineQueries;\\n        for(int i{0};i<queries.size();++i){\\n            vector<int>temp{queries[i][1],queries[i][0],i};\\n            offlineQueries.push_back(temp);\\n        }\\n\\n        sort(nums.begin(),nums.end());\\n        sort(offlineQueries.begin(),offlineQueries.end());\\n        \\n        Trie t;\\n        unordered_map<int,int>um;\\n        \\n        int i=0;\\n\\n        for(auto query:offlineQueries){\\n            while(i<nums.size() && nums[i]<=query[0]){\\n                t.insert(nums[i]);\\n                i++;\\n            }\\n            if(query[0]>=nums[0]){\\n                int val=t.getMaxm(query[1]);\\n                um[query[2]]=val^query[1];\\n            }else{\\n                um[query[2]]=-1;\\n            }\\n\\n        }\\n        \\n        vector<int>ans;\\n        for(int k{0};k<queries.size();++k){\\n            ans.push_back(um[k]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341879,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    struct Node\\n    {\\n        Node *links[2];\\n\\n        void put(int ch, Node *newNode) { links[ch] = newNode; }\\n\\n        Node *get(int ch) { return links[ch]; }\\n\\n        bool containsKey(int ch) { return links[ch] != NULL; }\\n    };\\n\\n    class Trie\\n    {\\n        Node *root;\\n\\n    public:\\n        Trie() { root = new Node(); }\\n\\n        void insert(int num)\\n        {\\n            Node *node = root;\\n            for (int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num >> i) & 1; // to check bit is set or not\\n\\n                if (!node->containsKey(bit))\\n                    node->put(bit, new Node());\\n\\n                node = node->get(bit);\\n            }\\n        }\\n\\n        int getMax(int num)\\n        {\\n            Node *node = root;\\n            int maxi = 0;\\n\\n            for (int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num >> i) & 1; // to check bit is set or not\\n\\n                if (!node->containsKey(!bit)) // check for opposite bit. If not contains go to reference of same bit\\n                    node = node->get(bit);\\n                else\\n                {\\n                    maxi = maxi | (1 << i);    // turning the bit on\\n                    node = node->get(1 - bit); //  go to opposite\\n                }\\n            }\\n\\n            return maxi;\\n        }\\n    };\\n\\n\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size(), m = queries.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans(m);\\n        \\n        /* Store query number */\\n        vector<vector<int>> offlineQueries;\\n        for(int i = 0; i < m; i++)\\n            offlineQueries.push_back({queries[i][1], queries[i][0], i});\\n\\n        sort(offlineQueries.begin(), offlineQueries.end());\\n\\n        Trie t;\\n        int i = 0;\\n        for(auto it: offlineQueries) {\\n            while(i < n and nums[i] <= it[0]) {\\n                t.insert(nums[i]);\\n                i++;\\n            }\\n\\n            if(i != 0) ans[it[2]] = t.getMax(it[1]);\\n            else ans[it[2]] = -1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    struct Node\\n    {\\n        Node *links[2];\\n\\n        void put(int ch, Node *newNode) { links[ch] = newNode; }\\n\\n        Node *get(int ch) { return links[ch]; }\\n\\n        bool containsKey(int ch) { return links[ch] != NULL; }\\n    };\\n\\n    class Trie\\n    {\\n        Node *root;\\n\\n    public:\\n        Trie() { root = new Node(); }\\n\\n        void insert(int num)\\n        {\\n            Node *node = root;\\n            for (int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num >> i) & 1; // to check bit is set or not\\n\\n                if (!node->containsKey(bit))\\n                    node->put(bit, new Node());\\n\\n                node = node->get(bit);\\n            }\\n        }\\n\\n        int getMax(int num)\\n        {\\n            Node *node = root;\\n            int maxi = 0;\\n\\n            for (int i = 31; i >= 0; i--)\\n            {\\n                int bit = (num >> i) & 1; // to check bit is set or not\\n\\n                if (!node->containsKey(!bit)) // check for opposite bit. If not contains go to reference of same bit\\n                    node = node->get(bit);\\n                else\\n                {\\n                    maxi = maxi | (1 << i);    // turning the bit on\\n                    node = node->get(1 - bit); //  go to opposite\\n                }\\n            }\\n\\n            return maxi;\\n        }\\n    };\\n\\n\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size(), m = queries.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans(m);\\n        \\n        /* Store query number */\\n        vector<vector<int>> offlineQueries;\\n        for(int i = 0; i < m; i++)\\n            offlineQueries.push_back({queries[i][1], queries[i][0], i});\\n\\n        sort(offlineQueries.begin(), offlineQueries.end());\\n\\n        Trie t;\\n        int i = 0;\\n        for(auto it: offlineQueries) {\\n            while(i < n and nums[i] <= it[0]) {\\n                t.insert(nums[i]);\\n                i++;\\n            }\\n\\n            if(i != 0) ans[it[2]] = t.getMax(it[1]);\\n            else ans[it[2]] = -1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336285,
                "title": "c-trie-offline-queries-easy-solution",
                "content": "```\\nstruct Node{\\n    Node* links[2];\\n};\\n\\nclass Trie{\\n    private:Node* root;\\n    public:\\n    \\n       Trie(){\\n           root=new Node();\\n       }\\n    void insert(int num){\\n        Node* curr=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i) & 1;\\n            if(curr->links[bit]==NULL){\\n                curr->links[bit]=new Node();\\n            }\\n            curr=curr->links[bit];\\n        }\\n        return;\\n    }\\n    int getMax(int num){\\n        Node* curr=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i) & 1;\\n            if(curr && curr->links[1-bit]!=NULL){\\n                maxNum = (1<<i) | maxNum;\\n                curr=curr->links[1-bit];\\n            }else if(curr) curr=curr->links[bit];\\n        }\\n        return maxNum;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        sort(nums.begin(),nums.end());\\n        int n=queries.size();\\n        vector<int> ans(n,0);\\n        vector<pair<int,pair<int,int>>> offline(n);\\n        for(int i=0;i<n;i++){\\n            offline[i]=make_pair(queries[i][1],make_pair(queries[i][0],i));\\n        }\\n        sort(offline.begin(),offline.end());\\n        int ptr=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[0]>offline[i].first){\\n                ans[offline[i].second.second]=-1;\\n                continue;\\n            }\\n            while(ptr<nums.size() && nums[ptr]<=offline[i].first){\\n                trie.insert(nums[ptr]);\\n                ptr++;\\n            }\\n            int result=trie.getMax(offline[i].second.first);\\n            ans[offline[i].second.second]=result;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n    Node* links[2];\\n};\\n\\nclass Trie{\\n    private:Node* root;\\n    public:\\n    \\n       Trie(){\\n           root=new Node();\\n       }\\n    void insert(int num){\\n        Node* curr=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i) & 1;\\n            if(curr->links[bit]==NULL){\\n                curr->links[bit]=new Node();\\n            }\\n            curr=curr->links[bit];\\n        }\\n        return;\\n    }\\n    int getMax(int num){\\n        Node* curr=root;\\n        int maxNum=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i) & 1;\\n            if(curr && curr->links[1-bit]!=NULL){\\n                maxNum = (1<<i) | maxNum;\\n                curr=curr->links[1-bit];\\n            }else if(curr) curr=curr->links[bit];\\n        }\\n        return maxNum;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        sort(nums.begin(),nums.end());\\n        int n=queries.size();\\n        vector<int> ans(n,0);\\n        vector<pair<int,pair<int,int>>> offline(n);\\n        for(int i=0;i<n;i++){\\n            offline[i]=make_pair(queries[i][1],make_pair(queries[i][0],i));\\n        }\\n        sort(offline.begin(),offline.end());\\n        int ptr=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[0]>offline[i].first){\\n                ans[offline[i].second.second]=-1;\\n                continue;\\n            }\\n            while(ptr<nums.size() && nums[ptr]<=offline[i].first){\\n                trie.insert(nums[ptr]);\\n                ptr++;\\n            }\\n            int result=trie.getMax(offline[i].second.first);\\n            ans[offline[i].second.second]=result;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327270,
                "title": "c-trie-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TrieNode{\\npublic:\\n  TrieNode*next[2]={}; \\n};\\nclass Trie{\\npublic:\\n  TrieNode* root;\\n  Trie(){\\n      root = new TrieNode();\\n  }\\n  void insert(int x){\\n     TrieNode* node=root;   \\n     for(int i=31;i>=0;i--){\\n         int bit = (x>>i) & 1;\\n         if(!node->next[bit]){\\n             node->next[bit]=new TrieNode();\\n         }\\n         node = node->next[bit];\\n     }\\n    }\\n    int getmax(int num){\\n        if (!root->next[0] && !root->next[1]){\\n            return -1;\\n        }\\n        TrieNode* node=root;\\n        int mx=0;\\n        for(int i=31;i>=0;i--){\\n         int bit = (num>>i) & 1;\\n         if(node->next[1-bit]){\\n            mx = mx | (1<<i);\\n            node = node->next[1-bit];\\n         }else{\\n           node= node->next[bit]; \\n         }\\n        }\\n        return mx;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        vector<vector<int>> q;\\n        for (int i = 0; i < queries.size(); i++) {\\n            auto v = queries[i];\\n            q.push_back({v[1], v[0], i});\\n        }\\n        sort(q.begin(), q.end());\\n        sort(nums.begin(), nums.end());        \\n        int j = 0;\\n        vector<int> res(queries.size());        \\n        for (auto& p : q) {\\n            while (j < nums.size() && nums[j] <= p[0]) {\\n                trie.insert(nums[j]);\\n                j++;\\n            }\\n            res[p[2]] = trie.getmax(p[1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n  TrieNode*next[2]={}; \\n};\\nclass Trie{\\npublic:\\n  TrieNode* root;\\n  Trie(){\\n      root = new TrieNode();\\n  }\\n  void insert(int x){\\n     TrieNode* node=root;   \\n     for(int i=31;i>=0;i--){\\n         int bit = (x>>i) & 1;\\n         if(!node->next[bit]){\\n             node->next[bit]=new TrieNode();\\n         }\\n         node = node->next[bit];\\n     }\\n    }\\n    int getmax(int num){\\n        if (!root->next[0] && !root->next[1]){\\n            return -1;\\n        }\\n        TrieNode* node=root;\\n        int mx=0;\\n        for(int i=31;i>=0;i--){\\n         int bit = (num>>i) & 1;\\n         if(node->next[1-bit]){\\n            mx = mx | (1<<i);\\n            node = node->next[1-bit];\\n         }else{\\n           node= node->next[bit]; \\n         }\\n        }\\n        return mx;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie trie;\\n        vector<vector<int>> q;\\n        for (int i = 0; i < queries.size(); i++) {\\n            auto v = queries[i];\\n            q.push_back({v[1], v[0], i});\\n        }\\n        sort(q.begin(), q.end());\\n        sort(nums.begin(), nums.end());        \\n        int j = 0;\\n        vector<int> res(queries.size());        \\n        for (auto& p : q) {\\n            while (j < nums.size() && nums[j] <= p[0]) {\\n                trie.insert(nums[j]);\\n                j++;\\n            }\\n            res[p[2]] = trie.getmax(p[1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317418,
                "title": "using-trie-striver-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass node{\\n  public:\\n  node*child[2];\\n  node(){\\n    child[0]=child[1]=NULL;\\n  }\\n};\\n      class trie{\\n      public:\\n      node*root;\\n      trie(){\\n        root=new node();\\n      }\\n      void insert(int k){\\n    node*temp=root;\\n      for(int i=31;i>=0;i--){\\n      int ind=(1<<i)&k;\\n    ind=ind?1:0;\\n      if(temp->child[ind]==NULL) \\n\\n      temp->child[ind]=new node();\\n      temp=temp->child[ind];\\n      }\\n      }\\n      int get(int x){\\n        int ans=0;\\n        node*temp=root;\\n        for(int i=31;i>=0;i--){\\n          int t=(1<<i)&x;\\n          t=t?1:0;\\n          int ind=1-t; \\n          if(temp->child[ind]) {\\n            ans|=1<<i;\\n          temp=temp->child[ind];\\n          }\\n          else temp=temp->child[t];\\n        }\\n        return ans;\\n      }\\n      };\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& a, vector<vector<int>>& q) {\\n      vector<int>ans(q.size());\\n        sort(a.begin(),a.end());\\n        vector<vector<int>> v(q.size(),vector<int>(3));\\n      for(int i=0;i<q.size();i++)\\n      {\\n        v[i]={q[i][1],q[i][0],i};\\n      }\\n      sort(v.begin(),v.end());\\n      trie*obj=new trie();\\n      int j=0;\\n      for(auto it:v){\\n      int x=it[1],m=it[0],ind=it[2];\\n      for(;j<a.size();j++){\\n        if(a[j]<=m) obj->insert(a[j]);\\n        else break;\\n      }\\n      if(j==0) ans[ind]=-1;\\n      else\\n       {\\n         int xo=obj->get(x);\\n       ans[ind]=xo;\\n       }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass node{\\n  public:\\n  node*child[2];\\n  node(){\\n    child[0]=child[1]=NULL;\\n  }\\n};\\n      class trie{\\n      public:\\n      node*root;\\n      trie(){\\n        root=new node();\\n      }\\n      void insert(int k){\\n    node*temp=root;\\n      for(int i=31;i>=0;i--){\\n      int ind=(1<<i)&k;\\n    ind=ind?1:0;\\n      if(temp->child[ind]==NULL) \\n\\n      temp->child[ind]=new node();\\n      temp=temp->child[ind];\\n      }\\n      }\\n      int get(int x){\\n        int ans=0;\\n        node*temp=root;\\n        for(int i=31;i>=0;i--){\\n          int t=(1<<i)&x;\\n          t=t?1:0;\\n          int ind=1-t; \\n          if(temp->child[ind]) {\\n            ans|=1<<i;\\n          temp=temp->child[ind];\\n          }\\n          else temp=temp->child[t];\\n        }\\n        return ans;\\n      }\\n      };\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& a, vector<vector<int>>& q) {\\n      vector<int>ans(q.size());\\n        sort(a.begin(),a.end());\\n        vector<vector<int>> v(q.size(),vector<int>(3));\\n      for(int i=0;i<q.size();i++)\\n      {\\n        v[i]={q[i][1],q[i][0],i};\\n      }\\n      sort(v.begin(),v.end());\\n      trie*obj=new trie();\\n      int j=0;\\n      for(auto it:v){\\n      int x=it[1],m=it[0],ind=it[2];\\n      for(;j<a.size();j++){\\n        if(a[j]<=m) obj->insert(a[j]);\\n        else break;\\n      }\\n      if(j==0) ans[ind]=-1;\\n      else\\n       {\\n         int xo=obj->get(x);\\n       ans[ind]=xo;\\n       }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298075,
                "title": "c-solution-using-trie-bit-manipulation",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    struct Node{\\n        Node *link[2];\\n        bool flag = false;\\n    };\\n\\n    Node *root;\\n\\n    void insert(string &num){\\n        Node *trav = root;\\n        for(int i=0; i<num.size(); i++){\\n            if(trav->link[num[i]-\\'0\\'] == NULL){\\n                trav->link[num[i]-\\'0\\'] = new Node();\\n            }\\n            trav = trav->link[num[i]-\\'0\\'];\\n        }\\n        trav->flag = true;\\n    }\\n\\n    void findlower(string &upper, string &lower){\\n        Node *trav = root;\\n        for(int i=0; i<upper.size(); i++){\\n            char need;\\n            if(upper[i] == \\'0\\') need = \\'1\\';\\n            else need = \\'0\\';\\n\\n            if(trav->link[need - \\'0\\'] != NULL){\\n                lower.push_back(need);\\n                trav = trav->link[need-\\'0\\'];\\n            }else{\\n                lower.push_back(upper[i]);\\n                trav = trav->link[upper[i] -\\'0\\'];\\n            }\\n        }\\n    }\\n\\n    struct compareVec{\\n        inline bool operator() (const vector<int> &a, const vector<int> &b){\\n            return (a.back() < b.back());\\n        }\\n    };\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        vector<vector<int>> queryInit(queries);\\n        unordered_map<string , int> trace;\\n        root = new Node();\\n        sort(nums.begin(),  nums.end());\\n        sort(queries.begin(), queries.end(), compareVec());\\n        int idx = 0;\\n        for(int i=0; i<nums.size();  i++){\\n            //cout << nums[i] << endl;\\n            string num = bitset<32>(nums[i]).to_string();\\n            //cout << nums[i] << endl;\\n            if(nums[i] <= queries[idx][1]){insert(num);} \\n            else\\n            {\\n                if(i == 0){\\n                    string temp = to_string(queries[idx][0]) + \" \" + to_string(queries[idx][1]);\\n                    trace[temp] = -1;\\n                } //res.push_back(-1);\\n                else{\\n                    string upper = bitset<32>(queries[idx][0]).to_string();\\n                    string lower = \"\";\\n                    findlower(upper, lower);\\n                    //cout << stoi(upper, 0, 2) << \" \" << stoi(lower, 0, 2) << endl;\\n                    //res.push_back(stoi(upper, 0, 2) ^ stoi(lower, 0, 2));\\n                    string temp = to_string(queries[idx][0]) + \" \" + to_string(queries[idx][1]);\\n                    trace[temp] = stoi(upper, 0, 2) ^ stoi(lower, 0, 2);\\n                }\\n                idx++;\\n                if(idx == queries.size()) break;\\n                i--;\\n                //insert(num);\\n            }\\n        }\\n\\n        while(idx < queries.size()){\\n            string upper = bitset<32>(queries[idx][0]).to_string();\\n            string lower = \"\";\\n            findlower(upper, lower);\\n            //cout << stoi(upper, 0, 2) << \" \" << stoi(lower, 0, 2) << endl;\\n            //res.push_back(stoi(upper, 0, 2) ^ stoi(lower, 0, 2));\\n            string temp = to_string(queries[idx][0]) + \" \" + to_string(queries[idx][1]);\\n            trace[temp] = stoi(upper, 0, 2) ^ stoi(lower, 0, 2);\\n            idx++;\\n        }\\n\\n        for(int i=0; i<queryInit.size(); i++){\\n            string temp = to_string(queryInit[i][0]) + \" \" + to_string(queryInit[i][1]);\\n            res.push_back(trace[temp]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    struct Node{\\n        Node *link[2];\\n        bool flag = false;\\n    };\\n\\n    Node *root;\\n\\n    void insert(string &num){\\n        Node *trav = root;\\n        for(int i=0; i<num.size(); i++){\\n            if(trav->link[num[i]-\\'0\\'] == NULL){\\n                trav->link[num[i]-\\'0\\'] = new Node();\\n            }\\n            trav = trav->link[num[i]-\\'0\\'];\\n        }\\n        trav->flag = true;\\n    }\\n\\n    void findlower(string &upper, string &lower){\\n        Node *trav = root;\\n        for(int i=0; i<upper.size(); i++){\\n            char need;\\n            if(upper[i] == \\'0\\') need = \\'1\\';\\n            else need = \\'0\\';\\n\\n            if(trav->link[need - \\'0\\'] != NULL){\\n                lower.push_back(need);\\n                trav = trav->link[need-\\'0\\'];\\n            }else{\\n                lower.push_back(upper[i]);\\n                trav = trav->link[upper[i] -\\'0\\'];\\n            }\\n        }\\n    }\\n\\n    struct compareVec{\\n        inline bool operator() (const vector<int> &a, const vector<int> &b){\\n            return (a.back() < b.back());\\n        }\\n    };\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        vector<vector<int>> queryInit(queries);\\n        unordered_map<string , int> trace;\\n        root = new Node();\\n        sort(nums.begin(),  nums.end());\\n        sort(queries.begin(), queries.end(), compareVec());\\n        int idx = 0;\\n        for(int i=0; i<nums.size();  i++){\\n            //cout << nums[i] << endl;\\n            string num = bitset<32>(nums[i]).to_string();\\n            //cout << nums[i] << endl;\\n            if(nums[i] <= queries[idx][1]){insert(num);} \\n            else\\n            {\\n                if(i == 0){\\n                    string temp = to_string(queries[idx][0]) + \" \" + to_string(queries[idx][1]);\\n                    trace[temp] = -1;\\n                } //res.push_back(-1);\\n                else{\\n                    string upper = bitset<32>(queries[idx][0]).to_string();\\n                    string lower = \"\";\\n                    findlower(upper, lower);\\n                    //cout << stoi(upper, 0, 2) << \" \" << stoi(lower, 0, 2) << endl;\\n                    //res.push_back(stoi(upper, 0, 2) ^ stoi(lower, 0, 2));\\n                    string temp = to_string(queries[idx][0]) + \" \" + to_string(queries[idx][1]);\\n                    trace[temp] = stoi(upper, 0, 2) ^ stoi(lower, 0, 2);\\n                }\\n                idx++;\\n                if(idx == queries.size()) break;\\n                i--;\\n                //insert(num);\\n            }\\n        }\\n\\n        while(idx < queries.size()){\\n            string upper = bitset<32>(queries[idx][0]).to_string();\\n            string lower = \"\";\\n            findlower(upper, lower);\\n            //cout << stoi(upper, 0, 2) << \" \" << stoi(lower, 0, 2) << endl;\\n            //res.push_back(stoi(upper, 0, 2) ^ stoi(lower, 0, 2));\\n            string temp = to_string(queries[idx][0]) + \" \" + to_string(queries[idx][1]);\\n            trace[temp] = stoi(upper, 0, 2) ^ stoi(lower, 0, 2);\\n            idx++;\\n        }\\n\\n        for(int i=0; i<queryInit.size(); i++){\\n            string temp = to_string(queryInit[i][0]) + \" \" + to_string(queryInit[i][1]);\\n            res.push_back(trace[temp]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3277122,
                "title": "c-trie-approach-bit-manipulation-offline-queries-96-faster-well-explained",
                "content": "# Approach\\n### DataStructues / Techniques Used\\n1. Sorting\\n2. Trie - operations : insertion, get_max\\n3. offline queries\\n4. Bit Manipulation \\n\\n\\n\\n# Code\\n```\\nclass TrieNode{\\npublic:\\n    TrieNode* children[2]; // every node can have two children 0 or 1\\n    bool isEnd;\\n    //constructor\\n    TrieNode(){\\n        children[0] = children[1] = NULL;\\n        isEnd = false;\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n     //initializing root of trie\\n    TrieNode* root;\\n    //constructor\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n\\n    //to insert given num (in binary representation - 32 bit)\\n    void insert(int num){\\n        TrieNode* curr = root;\\n\\n        for(int i = 31; i >= 0; i--){\\n            int bit = (num >> i) & 1;\\n\\n            //if children does not contains this bit\\n            //create a new children\\n            if(curr->children[bit] == NULL){\\n                curr->children[bit] = new TrieNode();\\n            }\\n\\n            curr = curr->children[bit];\\n        }\\n\\n        curr->isEnd = true;\\n    }\\n\\n    // to get the maximum of xor operation with a given integer\\n    int getMax(int num){\\n        TrieNode* curr = root;\\n        int maxNum = 0;\\n\\n        for(int i = 31; i >= 0; i--){\\n            int bit = (num >> i) & 1; //find the ith bit\\n\\n            // now check if opposite of bit is contained by children or not\\n            if(curr->children[1 - bit] != NULL){\\n                maxNum = maxNum | (1 << i);\\n                curr = curr->children[1 - bit];\\n            }\\n            else{\\n                curr = curr->children[bit];\\n            }\\n        }\\n\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        //initialize root of trie\\n        Trie* root = new Trie();\\n        int q = queries.size(), n = nums.size();\\n\\n        //step 1 - sort the nums vector\\n        sort(nums.begin(), nums.end());\\n\\n        //step 2 - modify queries to perform offline queries\\n        //it will stores {mi , xi, idx(from original queries)}\\n        vector<pair<int, pair<int,int>>> offlineQueries;\\n\\n        for(int i = 0; i < q; i++){\\n            int xi = queries[i][0];\\n            int mi = queries[i][1];\\n\\n            offlineQueries.push_back({mi, {xi, i}});\\n        }\\n\\n        //step 3 - sort offline Queries according to mi\\n        sort(offlineQueries.begin(), offlineQueries.end());\\n\\n        //step 4 - initialize ans vector \\n        vector<int> ans(q, 0);\\n\\n        int idx = 0;\\n\\n        for(int i = 0; i < q; i++){\\n            int mi = offlineQueries[i].first;\\n            int xi = offlineQueries[i].second.first;\\n            int qIdx = offlineQueries[i].second.second;\\n\\n            while(idx < n && nums[idx] <= mi){\\n                root->insert(nums[idx]);\\n                idx++;\\n            }\\n\\n            if(idx == 0){\\n                ans[qIdx] = -1;\\n            }\\n            else{\\n                int maxi = root->getMax(xi);\\n                ans[qIdx] = maxi;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n## Please Upvote if it help :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    TrieNode* children[2]; // every node can have two children 0 or 1\\n    bool isEnd;\\n    //constructor\\n    TrieNode(){\\n        children[0] = children[1] = NULL;\\n        isEnd = false;\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n     //initializing root of trie\\n    TrieNode* root;\\n    //constructor\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n\\n    //to insert given num (in binary representation - 32 bit)\\n    void insert(int num){\\n        TrieNode* curr = root;\\n\\n        for(int i = 31; i >= 0; i--){\\n            int bit = (num >> i) & 1;\\n\\n            //if children does not contains this bit\\n            //create a new children\\n            if(curr->children[bit] == NULL){\\n                curr->children[bit] = new TrieNode();\\n            }\\n\\n            curr = curr->children[bit];\\n        }\\n\\n        curr->isEnd = true;\\n    }\\n\\n    // to get the maximum of xor operation with a given integer\\n    int getMax(int num){\\n        TrieNode* curr = root;\\n        int maxNum = 0;\\n\\n        for(int i = 31; i >= 0; i--){\\n            int bit = (num >> i) & 1; //find the ith bit\\n\\n            // now check if opposite of bit is contained by children or not\\n            if(curr->children[1 - bit] != NULL){\\n                maxNum = maxNum | (1 << i);\\n                curr = curr->children[1 - bit];\\n            }\\n            else{\\n                curr = curr->children[bit];\\n            }\\n        }\\n\\n        return maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        //initialize root of trie\\n        Trie* root = new Trie();\\n        int q = queries.size(), n = nums.size();\\n\\n        //step 1 - sort the nums vector\\n        sort(nums.begin(), nums.end());\\n\\n        //step 2 - modify queries to perform offline queries\\n        //it will stores {mi , xi, idx(from original queries)}\\n        vector<pair<int, pair<int,int>>> offlineQueries;\\n\\n        for(int i = 0; i < q; i++){\\n            int xi = queries[i][0];\\n            int mi = queries[i][1];\\n\\n            offlineQueries.push_back({mi, {xi, i}});\\n        }\\n\\n        //step 3 - sort offline Queries according to mi\\n        sort(offlineQueries.begin(), offlineQueries.end());\\n\\n        //step 4 - initialize ans vector \\n        vector<int> ans(q, 0);\\n\\n        int idx = 0;\\n\\n        for(int i = 0; i < q; i++){\\n            int mi = offlineQueries[i].first;\\n            int xi = offlineQueries[i].second.first;\\n            int qIdx = offlineQueries[i].second.second;\\n\\n            while(idx < n && nums[idx] <= mi){\\n                root->insert(nums[idx]);\\n                idx++;\\n            }\\n\\n            if(idx == 0){\\n                ans[qIdx] = -1;\\n            }\\n            else{\\n                int maxi = root->getMax(xi);\\n                ans[qIdx] = maxi;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274725,
                "title": "superb-solution-of-a-superb-question-cpp-100-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct trie{\\n    trie* next[2];\\n    trie()\\n    {\\n        next[0]=NULL;\\n        next[1]=NULL;\\n    }\\n};\\nclass TrieNode{\\n    private:\\n        trie* root;\\n    public:\\n        TrieNode()\\n        {\\n            root=new trie();\\n        }\\n    \\n    void insert(int num)\\n    {\\n        trie* curr=root;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(curr->next[bit]==NULL)\\n            {\\n                curr->next[bit]=new trie();\\n            }\\n            curr=curr->next[bit];\\n        }\\n    }\\n    \\n    int max_xor(int num)\\n    {\\n        trie* curr=root;\\n        int ans=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1; //0\\n            \\n            if(curr->next[!bit]) //1\\n            {\\n                ans+=(1<<i);\\n                curr=curr->next[!bit];\\n            }\\n            else\\n            {\\n                curr=curr->next[bit];\\n            }\\n        }\\n        return ans;\\n    }   \\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, pair<int, int>>> oQ;\\n        int q=queries.size();\\n        for(int i=0; i<q; i++){\\n            oQ.push_back({queries[i][1], {queries[i][0], i}});\\n        }\\n        sort(oQ.begin(), oQ.end());\\n        vector<int> ans(q, 0);\\n        int i = 0, n=nums.size(); \\n        TrieNode* t=new TrieNode(); \\n        \\n        for(auto &it : oQ) {\\n            while(i < n && nums[i] <= it.first) {\\n                t->insert(nums[i]); \\n                i++; \\n            }\\n            if(i!=0) ans[it.second.second] = t->max_xor(it.second.first); \\n            else ans[it.second.second] = -1; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nstruct trie{\\n    trie* next[2];\\n    trie()\\n    {\\n        next[0]=NULL;\\n        next[1]=NULL;\\n    }\\n};\\nclass TrieNode{\\n    private:\\n        trie* root;\\n    public:\\n        TrieNode()\\n        {\\n            root=new trie();\\n        }\\n    \\n    void insert(int num)\\n    {\\n        trie* curr=root;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1;\\n            if(curr->next[bit]==NULL)\\n            {\\n                curr->next[bit]=new trie();\\n            }\\n            curr=curr->next[bit];\\n        }\\n    }\\n    \\n    int max_xor(int num)\\n    {\\n        trie* curr=root;\\n        int ans=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit=(num>>i)&1; //0\\n            \\n            if(curr->next[!bit]) //1\\n            {\\n                ans+=(1<<i);\\n                curr=curr->next[!bit];\\n            }\\n            else\\n            {\\n                curr=curr->next[bit];\\n            }\\n        }\\n        return ans;\\n    }   \\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, pair<int, int>>> oQ;\\n        int q=queries.size();\\n        for(int i=0; i<q; i++){\\n            oQ.push_back({queries[i][1], {queries[i][0], i}});\\n        }\\n        sort(oQ.begin(), oQ.end());\\n        vector<int> ans(q, 0);\\n        int i = 0, n=nums.size(); \\n        TrieNode* t=new TrieNode(); \\n        \\n        for(auto &it : oQ) {\\n            while(i < n && nums[i] <= it.first) {\\n                t->insert(nums[i]); \\n                i++; \\n            }\\n            if(i!=0) ans[it.second.second] = t->max_xor(it.second.first); \\n            else ans[it.second.second] = -1; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234430,
                "title": "trie-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthe idea is to insert elements of the array in increasing order with getting maximum xor value for the  respective queries in increasing order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass node{\\n    public:\\nnode* link[2];\\nbool islink(int n){return link[n]!=NULL;}\\nvoid makelink(int n, node* p){link[n]=p;}\\nnode* get_link(int n){return link[n];}\\n};\\n\\nclass Solution {\\npublic:\\nnode* root= new node();\\nvoid insert(int num){\\n    node* t=root;\\n    for(int i=31; i>=0; i--){\\n        int bit =(num>>i)&1;\\n        if(!t->islink(bit)){t->makelink(bit, new node());}\\n        t=t->get_link(bit);\\n    }\\n}\\n\\nint get_max(int num){\\n    node* t=root;\\n    int n=0;\\n    for(int i=31; i>=0; i--){\\n        int bit=(num>>i)&1;\\n        if(t->islink(1-bit)){\\n              n=n|(1<<i);\\n              t=t->get_link(1-bit);\\n        }\\n        else t=t->get_link(bit);\\n    }\\n    return n;\\n}\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        sort(nums.begin(), nums.end());\\n        int i=0;\\n        vector<int> ans(q.size());\\n        vector<pair<int, pair<int, int>>> v;\\n        for(int i=0; i<q.size(); i++)v.push_back({q[i][1], {q[i][0], i}});\\n        sort(v.begin(), v.end());\\n        for(int j=0; j<q.size(); j++){\\n            while( i<nums.size() && nums[i]<=v[j].first){insert(nums[i]); i++;}\\n            if(nums[0]>v[j].first)ans[v[j].second.second] =-1;\\n            else ans[v[j].second.second]=get_max(v[j].second.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass node{\\n    public:\\nnode* link[2];\\nbool islink(int n){return link[n]!=NULL;}\\nvoid makelink(int n, node* p){link[n]=p;}\\nnode* get_link(int n){return link[n];}\\n};\\n\\nclass Solution {\\npublic:\\nnode* root= new node();\\nvoid insert(int num){\\n    node* t=root;\\n    for(int i=31; i>=0; i--){\\n        int bit =(num>>i)&1;\\n        if(!t->islink(bit)){t->makelink(bit, new node());}\\n        t=t->get_link(bit);\\n    }\\n}\\n\\nint get_max(int num){\\n    node* t=root;\\n    int n=0;\\n    for(int i=31; i>=0; i--){\\n        int bit=(num>>i)&1;\\n        if(t->islink(1-bit)){\\n              n=n|(1<<i);\\n              t=t->get_link(1-bit);\\n        }\\n        else t=t->get_link(bit);\\n    }\\n    return n;\\n}\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        sort(nums.begin(), nums.end());\\n        int i=0;\\n        vector<int> ans(q.size());\\n        vector<pair<int, pair<int, int>>> v;\\n        for(int i=0; i<q.size(); i++)v.push_back({q[i][1], {q[i][0], i}});\\n        sort(v.begin(), v.end());\\n        for(int j=0; j<q.size(); j++){\\n            while( i<nums.size() && nums[i]<=v[j].first){insert(nums[i]); i++;}\\n            if(nums[0]>v[j].first)ans[v[j].second.second] =-1;\\n            else ans[v[j].second.second]=get_max(v[j].second.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212701,
                "title": "java-solution-using-trie-data-structure",
                "content": "```\\nclass Node {\\n    Node links[] = new Node[2]; \\n    \\n    public Node() {\\n    }\\n    boolean containsKey(int ind) {\\n        return (links[ind] != null); \\n    }\\n    Node get(int ind) {\\n        return links[ind]; \\n    }\\n    void put(int ind, Node node) {\\n        links[ind] = node; \\n    }\\n};\\nclass Trie {\\n    private Node root; \\n\\n    //Initialize your data structure here\\n\\n    Trie() {\\n        root = new Node(); \\n    }\\n\\n\\n    //Inserts a word into the trie\\n\\n    public void insert(int num) {\\n        Node node = root;\\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(!node.containsKey(bit)) {\\n                node.put(bit, new Node()); \\n            }\\n            node = node.get(bit); \\n        }\\n    }\\n    \\n    public int getMax(int num) {\\n        Node node = root; \\n        int maxNum = 0; \\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(node.containsKey(1 - bit)) {\\n                maxNum = maxNum | (1<<i);\\n                node = node.get( 1 - bit); \\n            }\\n            else {\\n                node = node.get(bit); \\n            }\\n        }\\n        return maxNum; \\n    }\\n};\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        ArrayList<ArrayList<Integer>> offlineQueries = new ArrayList<ArrayList<Integer>>(); \\n         int m = queries.length; \\n         for(int i = 0;i<m;i++) {\\n             ArrayList<Integer> temp = new ArrayList<Integer>(); \\n             temp.add(queries[i][1]); \\n             temp.add(queries[i][0]); \\n             temp.add(i); \\n             offlineQueries.add(temp); \\n         }\\n         Collections.sort(offlineQueries, new Comparator<ArrayList<Integer>> () {\\n            @Override\\n            public int compare(ArrayList<Integer> a, ArrayList<Integer> b) {\\n                return a.get(0).compareTo(b.get(0));\\n            }\\n        });\\n        int ind = 0;\\n        int n = nums.length;\\n        int[] ans = new int[m];\\n        Trie trie = new Trie();\\n       for(int i = 0;i<m;i++) {\\n             while(ind<n && nums[ind] <= offlineQueries.get(i).get(0)) {\\n                 trie.insert(nums[ind]); \\n                 ind++; \\n             }\\n             int queryInd = offlineQueries.get(i).get(2); \\n             if(ind!=0) ans[queryInd] = trie.getMax(offlineQueries.get(i).get(1));\\n             else ans[queryInd] = -1; \\n         }\\n         return ans;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Node {\\n    Node links[] = new Node[2]; \\n    \\n    public Node() {\\n    }\\n    boolean containsKey(int ind) {\\n        return (links[ind] != null); \\n    }\\n    Node get(int ind) {\\n        return links[ind]; \\n    }\\n    void put(int ind, Node node) {\\n        links[ind] = node; \\n    }\\n};\\nclass Trie {\\n    private Node root; \\n\\n    //Initialize your data structure here\\n\\n    Trie() {\\n        root = new Node(); \\n    }\\n\\n\\n    //Inserts a word into the trie\\n\\n    public void insert(int num) {\\n        Node node = root;\\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(!node.containsKey(bit)) {\\n                node.put(bit, new Node()); \\n            }\\n            node = node.get(bit); \\n        }\\n    }\\n    \\n    public int getMax(int num) {\\n        Node node = root; \\n        int maxNum = 0; \\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(node.containsKey(1 - bit)) {\\n                maxNum = maxNum | (1<<i);\\n                node = node.get( 1 - bit); \\n            }\\n            else {\\n                node = node.get(bit); \\n            }\\n        }\\n        return maxNum; \\n    }\\n};\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        ArrayList<ArrayList<Integer>> offlineQueries = new ArrayList<ArrayList<Integer>>(); \\n         int m = queries.length; \\n         for(int i = 0;i<m;i++) {\\n             ArrayList<Integer> temp = new ArrayList<Integer>(); \\n             temp.add(queries[i][1]); \\n             temp.add(queries[i][0]); \\n             temp.add(i); \\n             offlineQueries.add(temp); \\n         }\\n         Collections.sort(offlineQueries, new Comparator<ArrayList<Integer>> () {\\n            @Override\\n            public int compare(ArrayList<Integer> a, ArrayList<Integer> b) {\\n                return a.get(0).compareTo(b.get(0));\\n            }\\n        });\\n        int ind = 0;\\n        int n = nums.length;\\n        int[] ans = new int[m];\\n        Trie trie = new Trie();\\n       for(int i = 0;i<m;i++) {\\n             while(ind<n && nums[ind] <= offlineQueries.get(i).get(0)) {\\n                 trie.insert(nums[ind]); \\n                 ind++; \\n             }\\n             int queryInd = offlineQueries.get(i).get(2); \\n             if(ind!=0) ans[queryInd] = trie.getMax(offlineQueries.get(i).get(1));\\n             else ans[queryInd] = -1; \\n         }\\n         return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202442,
                "title": "easy-and-clean-solution-using-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node\\n{\\n    Node [] links = new Node[2];\\n\\n    public boolean containsKey(int idx)\\n    {\\n        return links[idx] != null;\\n    }\\n    public void put(int idx, Node node)\\n    {\\n        links[idx] = node;\\n    }\\n    public Node get(int idx)\\n    {\\n        return links[idx];\\n    }\\n}\\nclass Trie\\n{\\n    Node root;\\n    public Trie()\\n    {\\n        root = new Node();\\n    }\\n\\n    public void insert(int num)\\n    {\\n        Node node = root;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            int bit = (num >> i) & 1;\\n            if(!node.containsKey(bit))\\n            node.put(bit, new Node());\\n            node = node.get(bit);\\n        }\\n    }\\n\\n    public int getMax(int num)\\n    {\\n        Node node = root;\\n        int max = 0;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            int bit = (num >> i) & 1;\\n            if(node.containsKey(1 - bit))\\n            {\\n                max = max | (1 << i);\\n                node = node.get(1 - bit);\\n            }\\n            else if(node.containsKey(bit))\\n            node = node.get(bit);\\n            else\\n            return -1;\\n        }\\n        return max;\\n    }\\n\\n}\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Trie trie = new Trie();\\n        int [][] q = new int[queries.length][3];\\n        for(int i = 0; i < q.length; i++)\\n        {\\n            q[i][0] = queries[i][0];\\n            q[i][1] = queries[i][1];\\n            q[i][2] = i;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(q, (x,y) -> x[1] - y[1]);\\n        int [] results = new int[q.length];\\n        int idx = 0;\\n        for(int i = 0; i < q.length; i++)\\n        {\\n            while(idx < nums.length && nums[idx] <= q[i][1])\\n            {\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n            results[q[i][2]] = trie.getMax(q[i][0]);\\n        }\\n        return results;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node\\n{\\n    Node [] links = new Node[2];\\n\\n    public boolean containsKey(int idx)\\n    {\\n        return links[idx] != null;\\n    }\\n    public void put(int idx, Node node)\\n    {\\n        links[idx] = node;\\n    }\\n    public Node get(int idx)\\n    {\\n        return links[idx];\\n    }\\n}\\nclass Trie\\n{\\n    Node root;\\n    public Trie()\\n    {\\n        root = new Node();\\n    }\\n\\n    public void insert(int num)\\n    {\\n        Node node = root;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            int bit = (num >> i) & 1;\\n            if(!node.containsKey(bit))\\n            node.put(bit, new Node());\\n            node = node.get(bit);\\n        }\\n    }\\n\\n    public int getMax(int num)\\n    {\\n        Node node = root;\\n        int max = 0;\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            int bit = (num >> i) & 1;\\n            if(node.containsKey(1 - bit))\\n            {\\n                max = max | (1 << i);\\n                node = node.get(1 - bit);\\n            }\\n            else if(node.containsKey(bit))\\n            node = node.get(bit);\\n            else\\n            return -1;\\n        }\\n        return max;\\n    }\\n\\n}\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Trie trie = new Trie();\\n        int [][] q = new int[queries.length][3];\\n        for(int i = 0; i < q.length; i++)\\n        {\\n            q[i][0] = queries[i][0];\\n            q[i][1] = queries[i][1];\\n            q[i][2] = i;\\n        }\\n        Arrays.sort(nums);\\n        Arrays.sort(q, (x,y) -> x[1] - y[1]);\\n        int [] results = new int[q.length];\\n        int idx = 0;\\n        for(int i = 0; i < q.length; i++)\\n        {\\n            while(idx < nums.length && nums[idx] <= q[i][1])\\n            {\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n            results[q[i][2]] = trie.getMax(q[i][0]);\\n        }\\n        return results;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201281,
                "title": "trie-offline-query-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n    Node *links[2];\\n    bool contain(int bit){\\n        return links[bit]!=NULL;\\n    }\\n    void put(int bit,Node *node){\\n        links[bit]=node;\\n    }\\n    Node *get(int bit){\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\n    private: Node *root;\\n    public:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int &num){\\n        Node *node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(!node->contain(bit)){\\n                node->put(bit,new Node());\\n            }node=node->get(bit);\\n        }\\n    }\\n    int getMax(int &num){\\n        Node *node=root;\\n        int maxi=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(node->contain(1-bit)){\\n                maxi=maxi|(1<<i);\\n                node=node->get(1-bit);\\n            }\\n            else node=node->get(bit);\\n        }\\n        return maxi;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& qu) {\\n        Trie trie;\\n        int i;\\n        vector<vector<int>>arr;\\n        for(i=0;i<qu.size();i++){\\n            int x=qu[i][0];\\n            int lim=qu[i][1];\\n            arr.push_back({lim,x,i});\\n        }\\n        vector<int>ans(qu.size());\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        sort(arr.begin(),arr.end());\\n        int ind=0;\\n        for(i=0;i<qu.size();i++){\\n            int lim=arr[i][0];\\n            int x=arr[i][1];\\n            int qind=arr[i][2];\\n            while(ind<n&&nums[ind]<=lim){\\n                trie.insert(nums[ind]);\\n                ind++;\\n            }\\n            if(ind==0) ans[qind]=-1;\\n            else ans[qind]=trie.getMax(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node{\\n    Node *links[2];\\n    bool contain(int bit){\\n        return links[bit]!=NULL;\\n    }\\n    void put(int bit,Node *node){\\n        links[bit]=node;\\n    }\\n    Node *get(int bit){\\n        return links[bit];\\n    }\\n};\\nclass Trie{\\n    private: Node *root;\\n    public:\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(int &num){\\n        Node *node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(!node->contain(bit)){\\n                node->put(bit,new Node());\\n            }node=node->get(bit);\\n        }\\n    }\\n    int getMax(int &num){\\n        Node *node=root;\\n        int maxi=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(num>>i)&1;\\n            if(node->contain(1-bit)){\\n                maxi=maxi|(1<<i);\\n                node=node->get(1-bit);\\n            }\\n            else node=node->get(bit);\\n        }\\n        return maxi;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& qu) {\\n        Trie trie;\\n        int i;\\n        vector<vector<int>>arr;\\n        for(i=0;i<qu.size();i++){\\n            int x=qu[i][0];\\n            int lim=qu[i][1];\\n            arr.push_back({lim,x,i});\\n        }\\n        vector<int>ans(qu.size());\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        sort(arr.begin(),arr.end());\\n        int ind=0;\\n        for(i=0;i<qu.size();i++){\\n            int lim=arr[i][0];\\n            int x=arr[i][1];\\n            int qind=arr[i][2];\\n            while(ind<n&&nums[ind]<=lim){\\n                trie.insert(nums[ind]);\\n                ind++;\\n            }\\n            if(ind==0) ans[qind]=-1;\\n            else ans[qind]=trie.getMax(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199563,
                "title": "trie-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximize_xor(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut trie = Trie::new();\\n        let mut nums = nums;\\n        nums.sort();\\n        let mut queries = queries\\n            .into_iter()\\n            .enumerate()\\n            .map(|(i, q)| (q[1], q[0], i))\\n            .collect::<Vec<_>>();\\n        queries.sort();\\n        let mut v1 = vec![0; queries.len()];\\n        let mut st = 0;\\n        let en = nums.len();\\n        for (m, x, i) in queries {\\n            while st < en && nums[st] <= m {\\n                trie.insert(nums[st]);\\n                st += 1;\\n            }\\n            if st == 0 {\\n                v1[i] = -1;\\n            } else {\\n                v1[i] = trie.maxnum(x);\\n            }\\n        }\\n        v1\\n    }\\n}\\n\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\ntype OptNode = Option<Rc<RefCell<Node>>>;\\nstruct Node {\\n    links: [OptNode; 2],\\n}\\n\\nimpl Node {\\n    fn new() -> Self {\\n        Self { links: [None, None] }\\n    }\\n}\\n\\nstruct Trie {\\n    root: OptNode,\\n}\\n\\nimpl Trie {\\n    fn new() -> Self {\\n        Self {\\n            root: Some(Rc::new(RefCell::new(Node::new()))),\\n        }\\n    }\\n\\n    fn insert(&mut self, num: i32) {\\n        let num = num as usize;\\n        let mut node = self.root.clone();\\n        for i in (0..32).rev() {\\n            let bit = (num >> i) & 1;\\n            {\\n                let mut ref_node = node.as_ref().unwrap().borrow_mut();\\n                if ref_node.links[bit].is_none() {\\n                    ref_node.links[bit] = Some(Rc::new(RefCell::new(Node::new())));\\n                }\\n            }\\n            let v = node.as_ref().unwrap().borrow().links[bit].clone();\\n            node = v;\\n        }\\n    }\\n\\n    fn maxnum(&self, num: i32) -> i32 {\\n        let mut maxi = 0;\\n        let mut node = self.root.clone();\\n        for i in (0..32).rev() {\\n            let bit = (num >> i) & 1;\\n            let v = if node.as_ref().unwrap().borrow().links[(1 - bit) as usize].is_some() {\\n                maxi |= 1 << i;\\n                node.as_ref().unwrap().borrow().links[(1 - bit) as usize].clone()\\n            } else {\\n                node.as_ref().unwrap().borrow().links[bit as usize].clone()\\n            };\\n            node = v;\\n        }\\n        maxi\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximize_xor(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut trie = Trie::new();\\n        let mut nums = nums;\\n        nums.sort();\\n        let mut queries = queries\\n            .into_iter()\\n            .enumerate()\\n            .map(|(i, q)| (q[1], q[0], i))\\n            .collect::<Vec<_>>();\\n        queries.sort();\\n        let mut v1 = vec![0; queries.len()];\\n        let mut st = 0;\\n        let en = nums.len();\\n        for (m, x, i) in queries {\\n            while st < en && nums[st] <= m {\\n                trie.insert(nums[st]);\\n                st += 1;\\n            }\\n            if st == 0 {\\n                v1[i] = -1;\\n            } else {\\n                v1[i] = trie.maxnum(x);\\n            }\\n        }\\n        v1\\n    }\\n}\\n\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\ntype OptNode = Option<Rc<RefCell<Node>>>;\\nstruct Node {\\n    links: [OptNode; 2],\\n}\\n\\nimpl Node {\\n    fn new() -> Self {\\n        Self { links: [None, None] }\\n    }\\n}\\n\\nstruct Trie {\\n    root: OptNode,\\n}\\n\\nimpl Trie {\\n    fn new() -> Self {\\n        Self {\\n            root: Some(Rc::new(RefCell::new(Node::new()))),\\n        }\\n    }\\n\\n    fn insert(&mut self, num: i32) {\\n        let num = num as usize;\\n        let mut node = self.root.clone();\\n        for i in (0..32).rev() {\\n            let bit = (num >> i) & 1;\\n            {\\n                let mut ref_node = node.as_ref().unwrap().borrow_mut();\\n                if ref_node.links[bit].is_none() {\\n                    ref_node.links[bit] = Some(Rc::new(RefCell::new(Node::new())));\\n                }\\n            }\\n            let v = node.as_ref().unwrap().borrow().links[bit].clone();\\n            node = v;\\n        }\\n    }\\n\\n    fn maxnum(&self, num: i32) -> i32 {\\n        let mut maxi = 0;\\n        let mut node = self.root.clone();\\n        for i in (0..32).rev() {\\n            let bit = (num >> i) & 1;\\n            let v = if node.as_ref().unwrap().borrow().links[(1 - bit) as usize].is_some() {\\n                maxi |= 1 << i;\\n                node.as_ref().unwrap().borrow().links[(1 - bit) as usize].clone()\\n            } else {\\n                node.as_ref().unwrap().borrow().links[bit as usize].clone()\\n            };\\n            node = v;\\n        }\\n        maxi\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3194514,
                "title": "java-trie",
                "content": "\\n\\n# Code\\n```\\nclass Node{\\n\\tNode[] links = new Node[2];\\n\\n\\tpublic boolean isContainsKey(int bit){\\n\\t\\treturn links[bit]!=null;\\n\\t}\\n\\n\\tpublic Node get(int bit){\\n\\t\\treturn links[bit];\\n\\t}\\n\\n\\tpublic void put(int bit, Node node){\\n\\t\\tlinks[bit]=node;\\n\\t}\\n}\\n\\nclass Trie{\\n\\tNode root;\\n\\n\\tTrie(){\\n\\t\\troot = new Node();\\n\\t}\\n\\n\\tpublic void insert(int num){\\n\\t\\tNode node = root;\\n        // creating bit and storing into trie\\n\\t\\tfor(int i=31; i>=0; i--){\\n\\t\\t\\tint bit =  1 & (num>>i);\\n\\n\\t\\t\\tif(!node.isContainsKey(bit)){\\n\\t\\t\\t\\tnode.put(bit, new Node());\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.get(bit);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int search(int num){\\n\\t\\tNode node = root;\\n\\n        int longest=0;\\n\\t\\tfor(int i=31; i>=0; i--){\\n\\t\\t\\tint bit = 1 & (num>>i) ;\\n\\n            // we need longest using XOR.\\n\\t\\t\\t// we started from left to right side.\\n\\t\\t\\t// so will try to find current bit opposite so that number can be maximize\\n\\t\\t\\t// if find in trie will set the bit on for longest(number)\\n\\t\\t\\t// else we have zero already. it is okay\\n\\t\\t\\tif(node.isContainsKey(1-bit)){\\n\\t\\t\\t\\tnode = node.get(1-bit);\\n\\t\\t\\t\\tlongest =  (1<<i) | longest; // make the bit on\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n                 node = node.get(bit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn longest;\\n\\t}\\n}\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int m = queries.length;\\n        int[] ans = new int[m];\\n        \\n        \\n        int[][] query = new int[m][3];\\n        for(int i=0; i<m; i++){\\n            // at 0 xi\\n            // at 1 ai\\n            // at 2 its position\\n            query[i][0]=queries[i][0];\\n            query[i][1]=queries[i][1];\\n            query[i][2]=i;\\n\\n\\n            // maintaing -1 initailly in answer\\n            ans[i]= -1;\\n        }\\n         // sorting using ai\\n        Arrays.sort(query, (a, b) -> a[1] - b[1]);\\n\\n        // Sorting main array also\\n        Arrays.sort(nums);\\n\\n        int index=0;\\n        Trie trie = new Trie();\\n\\n        for(int i=0; i<m; i++){\\n\\n            while(index<nums.length && nums[index]<= query[i][1]){\\n                trie.insert(nums[index]);\\n                index++;\\n\\n            }\\n            if(index!=0){\\n                ans[query[i][2]]=  trie.search(query[i][0]) ;\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node{\\n\\tNode[] links = new Node[2];\\n\\n\\tpublic boolean isContainsKey(int bit){\\n\\t\\treturn links[bit]!=null;\\n\\t}\\n\\n\\tpublic Node get(int bit){\\n\\t\\treturn links[bit];\\n\\t}\\n\\n\\tpublic void put(int bit, Node node){\\n\\t\\tlinks[bit]=node;\\n\\t}\\n}\\n\\nclass Trie{\\n\\tNode root;\\n\\n\\tTrie(){\\n\\t\\troot = new Node();\\n\\t}\\n\\n\\tpublic void insert(int num){\\n\\t\\tNode node = root;\\n        // creating bit and storing into trie\\n\\t\\tfor(int i=31; i>=0; i--){\\n\\t\\t\\tint bit =  1 & (num>>i);\\n\\n\\t\\t\\tif(!node.isContainsKey(bit)){\\n\\t\\t\\t\\tnode.put(bit, new Node());\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.get(bit);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int search(int num){\\n\\t\\tNode node = root;\\n\\n        int longest=0;\\n\\t\\tfor(int i=31; i>=0; i--){\\n\\t\\t\\tint bit = 1 & (num>>i) ;\\n\\n            // we need longest using XOR.\\n\\t\\t\\t// we started from left to right side.\\n\\t\\t\\t// so will try to find current bit opposite so that number can be maximize\\n\\t\\t\\t// if find in trie will set the bit on for longest(number)\\n\\t\\t\\t// else we have zero already. it is okay\\n\\t\\t\\tif(node.isContainsKey(1-bit)){\\n\\t\\t\\t\\tnode = node.get(1-bit);\\n\\t\\t\\t\\tlongest =  (1<<i) | longest; // make the bit on\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n                 node = node.get(bit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn longest;\\n\\t}\\n}\\nclass Solution {\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        int m = queries.length;\\n        int[] ans = new int[m];\\n        \\n        \\n        int[][] query = new int[m][3];\\n        for(int i=0; i<m; i++){\\n            // at 0 xi\\n            // at 1 ai\\n            // at 2 its position\\n            query[i][0]=queries[i][0];\\n            query[i][1]=queries[i][1];\\n            query[i][2]=i;\\n\\n\\n            // maintaing -1 initailly in answer\\n            ans[i]= -1;\\n        }\\n         // sorting using ai\\n        Arrays.sort(query, (a, b) -> a[1] - b[1]);\\n\\n        // Sorting main array also\\n        Arrays.sort(nums);\\n\\n        int index=0;\\n        Trie trie = new Trie();\\n\\n        for(int i=0; i<m; i++){\\n\\n            while(index<nums.length && nums[index]<= query[i][1]){\\n                trie.insert(nums[index]);\\n                index++;\\n\\n            }\\n            if(index!=0){\\n                ans[query[i][2]]=  trie.search(query[i][0]) ;\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113406,
                "title": "61-2-faster-offline-queries-trie-c-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    class Trie{\\n        Trie* container[2];\\n        bool is_end;\\n        Trie(){\\n            memset(container,NULL,sizeof(container));\\n            is_end=false;\\n        }\\n\\n        void insert(Trie* root,ll current){\\n            Trie* temp=root;\\n            for(ll i=31;i>=0;i--){\\n                ll now=(current>>i)&1;\\n                if(temp->container[now]==NULL){\\n                    temp->container[now]=new Trie();\\n                }\\n                temp=temp->container[now];\\n            }\\n            temp->is_end=true;\\n            return;\\n        }\\n\\n        ll biggest(Trie* root,ll current){\\n            ll answer=0;\\n            Trie* temp=root;\\n            for(ll i=31;i>=0;i--){\\n                ll now=(current>>i)&1;\\n                if(temp->container[now^1]!=NULL){\\n                    answer|=(1<<i);\\n                    temp=temp->container[now^1];\\n                }\\n                else{\\n                    temp=temp->container[now];\\n                }\\n            }\\n            return answer;\\n        }\\n    };\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        ll n=nums.size(),m=queries.size();\\n        vector<vector<ll>>offline;\\n        vector<int>answer(m);\\n        for(ll i=0;i<m;i++){\\n            offline.push_back({queries[i][1],queries[i][0],i});\\n        }\\n        sort(offline.begin(),offline.end());sort(nums.begin(),nums.end());\\n        ll i=0,j=0;\\n        Trie trie;\\n        Trie* root=new Trie();\\n        while(j<m){\\n            ll current=offline[j][0];\\n            while(i<n && nums[i]<=current){\\n                trie.insert(root,nums[i++]);\\n            }\\n            while(j<m && offline[j][0]==current){\\n                if(i==0){\\n                    answer[offline[j][2]]=-1;\\n                }\\n                else{\\n                    answer[offline[j][2]]=trie.biggest(root,offline[j][1]);\\n                }\\n                j++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    class Trie{\\n        Trie* container[2];\\n        bool is_end;\\n        Trie(){\\n            memset(container,NULL,sizeof(container));\\n            is_end=false;\\n        }\\n\\n        void insert(Trie* root,ll current){\\n            Trie* temp=root;\\n            for(ll i=31;i>=0;i--){\\n                ll now=(current>>i)&1;\\n                if(temp->container[now]==NULL){\\n                    temp->container[now]=new Trie();\\n                }\\n                temp=temp->container[now];\\n            }\\n            temp->is_end=true;\\n            return;\\n        }\\n\\n        ll biggest(Trie* root,ll current){\\n            ll answer=0;\\n            Trie* temp=root;\\n            for(ll i=31;i>=0;i--){\\n                ll now=(current>>i)&1;\\n                if(temp->container[now^1]!=NULL){\\n                    answer|=(1<<i);\\n                    temp=temp->container[now^1];\\n                }\\n                else{\\n                    temp=temp->container[now];\\n                }\\n            }\\n            return answer;\\n        }\\n    };\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        ll n=nums.size(),m=queries.size();\\n        vector<vector<ll>>offline;\\n        vector<int>answer(m);\\n        for(ll i=0;i<m;i++){\\n            offline.push_back({queries[i][1],queries[i][0],i});\\n        }\\n        sort(offline.begin(),offline.end());sort(nums.begin(),nums.end());\\n        ll i=0,j=0;\\n        Trie trie;\\n        Trie* root=new Trie();\\n        while(j<m){\\n            ll current=offline[j][0];\\n            while(i<n && nums[i]<=current){\\n                trie.insert(root,nums[i++]);\\n            }\\n            while(j<m && offline[j][0]==current){\\n                if(i==0){\\n                    answer[offline[j][2]]=-1;\\n                }\\n                else{\\n                    answer[offline[j][2]]=trie.biggest(root,offline[j][1]);\\n                }\\n                j++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089558,
                "title": "c-intuitive-no-sort-no-recursion-no-non-sense-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Node {\\npublic:\\n    vector<Node*>   child;\\n    int minVal;\\n    Node () {\\n        child.resize(2,NULL);\\n        minVal = INT_MAX;\\n    }\\n};\\n\\nvoid insert(Node *rt, int n) {\\n    for (int i=31 ; i>=0 ; i--) {\\n        bool bit = n & (1 << i);\\n        if (rt->child[bit] == NULL) {\\n            rt->child[bit] = new Node();\\n            rt->child[bit]->minVal = n;\\n        }\\n        rt = rt->child[bit];\\n        if (n < rt->minVal)\\n            rt->minVal = n;\\n    }\\n}\\n\\n\\nint mxXOR (Node *rt, int n, int m) {\\n    int ans=0, sum=0;\\n    for (int i = 31; i >= 0; i--) {\\n\\t\\tbool bit = ((n >> i) & 1);\\n        bool req = !bit;\\n\\t\\tif (rt->child[req] != NULL and rt->child[req]->minVal <= m) {\\n\\t\\t\\tans += (1 << i);\\n\\t\\t\\trt = rt->child[req];\\n\\t\\t}\\n        else if (rt->child[bit] != NULL && rt->child[bit]->minVal <= m)\\n\\t\\t\\trt = rt->child[bit];\\n\\t\\telse  return -1;\\n\\t}\\n\\n    return ans;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& A, vector<vector<int>>& queries) {\\n        Node *root = new Node();\\n        for (auto ele:A)    insert(root, ele);\\n        vector<int> ans;\\n        for (auto &ele:queries) {\\n            int x = ele[0], m = ele[1];\\n            ans.push_back(mxXOR(root,x,m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node {\\npublic:\\n    vector<Node*>   child;\\n    int minVal;\\n    Node () {\\n        child.resize(2,NULL);\\n        minVal = INT_MAX;\\n    }\\n};\\n\\nvoid insert(Node *rt, int n) {\\n    for (int i=31 ; i>=0 ; i--) {\\n        bool bit = n & (1 << i);\\n        if (rt->child[bit] == NULL) {\\n            rt->child[bit] = new Node();\\n            rt->child[bit]->minVal = n;\\n        }\\n        rt = rt->child[bit];\\n        if (n < rt->minVal)\\n            rt->minVal = n;\\n    }\\n}\\n\\n\\nint mxXOR (Node *rt, int n, int m) {\\n    int ans=0, sum=0;\\n    for (int i = 31; i >= 0; i--) {\\n\\t\\tbool bit = ((n >> i) & 1);\\n        bool req = !bit;\\n\\t\\tif (rt->child[req] != NULL and rt->child[req]->minVal <= m) {\\n\\t\\t\\tans += (1 << i);\\n\\t\\t\\trt = rt->child[req];\\n\\t\\t}\\n        else if (rt->child[bit] != NULL && rt->child[bit]->minVal <= m)\\n\\t\\t\\trt = rt->child[bit];\\n\\t\\telse  return -1;\\n\\t}\\n\\n    return ans;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& A, vector<vector<int>>& queries) {\\n        Node *root = new Node();\\n        for (auto ele:A)    insert(root, ele);\\n        vector<int> ans;\\n        for (auto &ele:queries) {\\n            int x = ele[0], m = ele[1];\\n            ans.push_back(mxXOR(root,x,m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076166,
                "title": "java-solution-easy-approach-using-trie-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Node{\\n    Node links[] = new Node[2];\\n    boolean containsKey(int bit){\\n        return (links[bit]!=null);\\n    }\\n    void put(int bit,Node node){\\n        links[bit] = node;\\n    }\\n    Node get(int bit){\\n        return links[bit];\\n    }\\n}\\n\\nclass Trie{\\n    private static Node root;\\n    Trie(){\\n        root = new Node();\\n    }\\n    public static void insert(int num){\\n        Node node = root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(!node.containsKey(bit)){\\n                node.put(bit,new Node());\\n            }\\n            node = node.get(bit);\\n        }\\n    }\\n    public int getMax(int num){\\n        Node node = root;\\n        int maxNumber = 0;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(node.containsKey(1-bit)){\\n                maxNumber = maxNumber|(1<<i);\\n                node = node.get(1-bit);\\n            }\\n            else{\\n                node = node.get(bit);\\n            }\\n        }\\n        return maxNumber;\\n    }\\n}\\n\\nclass Solution {\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        ArrayList<ArrayList<Integer>> offlineQueries = new ArrayList<>();\\n        int N = nums.length;\\n        int Q = queries.length;\\n        for(int i=0;i<Q;i++){\\n            ArrayList<Integer> l = new ArrayList<>();\\n            l.add(queries[i][1]);\\n            l.add(queries[i][0]);\\n            l.add(i);\\n            offlineQueries.add(l);\\n        }\\n        // O(QlogQ)\\n        Collections.sort(offlineQueries,new Comparator<ArrayList<Integer>>(){\\n            @Override\\n            public int compare(ArrayList<Integer> a,ArrayList<Integer>b){\\n                return a.get(0).compareTo(b.get(0));\\n            }\\n        });\\n        int index = 0;\\n        Trie obj = new Trie();\\n        // O(Q*32 + N*32)\\n        int ans[] = new int[Q];\\n        for(int i=0;i<Q;i++){\\n            while(index<N && nums[index]<=offlineQueries.get(i).get(0)){\\n                obj.insert(nums[index]);\\n                index++;\\n            }\\n            int queryInd = offlineQueries.get(i).get(2);\\n            if(index!=0){\\n                ans[queryInd] = obj.getMax(offlineQueries.get(i).get(1));\\n            }\\n            else{\\n                ans[queryInd] = -1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n}\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\npublic class Node{\\n    Node links[] = new Node[2];\\n    boolean containsKey(int bit){\\n        return (links[bit]!=null);\\n    }\\n    void put(int bit,Node node){\\n        links[bit] = node;\\n    }\\n    Node get(int bit){\\n        return links[bit];\\n    }\\n}\\n\\nclass Trie{\\n    private static Node root;\\n    Trie(){\\n        root = new Node();\\n    }\\n    public static void insert(int num){\\n        Node node = root;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(!node.containsKey(bit)){\\n                node.put(bit,new Node());\\n            }\\n            node = node.get(bit);\\n        }\\n    }\\n    public int getMax(int num){\\n        Node node = root;\\n        int maxNumber = 0;\\n        for(int i=31;i>=0;i--){\\n            int bit = (num>>i)&1;\\n            if(node.containsKey(1-bit)){\\n                maxNumber = maxNumber|(1<<i);\\n                node = node.get(1-bit);\\n            }\\n            else{\\n                node = node.get(bit);\\n            }\\n        }\\n        return maxNumber;\\n    }\\n}\\n\\nclass Solution {\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        ArrayList<ArrayList<Integer>> offlineQueries = new ArrayList<>();\\n        int N = nums.length;\\n        int Q = queries.length;\\n        for(int i=0;i<Q;i++){\\n            ArrayList<Integer> l = new ArrayList<>();\\n            l.add(queries[i][1]);\\n            l.add(queries[i][0]);\\n            l.add(i);\\n            offlineQueries.add(l);\\n        }\\n        // O(QlogQ)\\n        Collections.sort(offlineQueries,new Comparator<ArrayList<Integer>>(){\\n            @Override\\n            public int compare(ArrayList<Integer> a,ArrayList<Integer>b){\\n                return a.get(0).compareTo(b.get(0));\\n            }\\n        });\\n        int index = 0;\\n        Trie obj = new Trie();\\n        // O(Q*32 + N*32)\\n        int ans[] = new int[Q];\\n        for(int i=0;i<Q;i++){\\n            while(index<N && nums[index]<=offlineQueries.get(i).get(0)){\\n                obj.insert(nums[index]);\\n                index++;\\n            }\\n            int queryInd = offlineQueries.get(i).get(2);\\n            if(index!=0){\\n                ans[queryInd] = obj.getMax(offlineQueries.get(i).get(1));\\n            }\\n            else{\\n                ans[queryInd] = -1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n}\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013813,
                "title": "java-solution-in-trie",
                "content": "\\n# Code\\n```\\n\\nclass Node {\\n    Node[] links = new Node[2];\\n    public Node() {\\n\\n    }\\n    public Node get(int bit) {\\n        return links[bit];\\n    }\\n\\n    boolean containsKey(int bit) {\\n        return (links[bit] != null);\\n    }\\n\\n    void set(int bit, Node node) {\\n        links[bit] = node;\\n    } \\n}\\n\\nclass Trie {\\n    Node root;\\n    public Trie() {\\n        root = new Node();\\n    }\\n\\n    public void insert(int num) {\\n        Node node = root;\\n         for(int i = 31; i >= 0; i--) {\\n             int bit = (num>>i)&1;\\n            if(!node.containsKey(bit)) {\\n                node.set(bit, new Node());\\n            }\\n            node = node.get(bit);\\n         }\\n    }\\n    public int maxXor(int num) {\\n        Node node = root; \\n        \\n        int ans = 0;\\n        for(int i= 31; i >=0; i--) {\\n            if(node == null) return -1;\\n            int bit= (num>>i)&1;\\n            if(node.containsKey(1-bit)) {\\n                ans = ans | 1<<i;\\n                node = node.get(1-bit);\\n            } else {\\n                node = node.get(bit);\\n            }\\n        \\n        }\\n        return ans;\\n    }\\n\\n    }\\n\\nclass Solution {\\n    public static void columnSort(int[][] queries) {\\n        Arrays.sort(queries, new Comparator<int[]>() {\\n                    public int compare(int[] frst, int[] scnd) {\\n                          if(frst[1] > scnd[1]) {\\n                                 return 1;\\n                           }\\n                          else return -1;\\n                           }\\n                          });\\n    }\\n    public static void printArr(int[] nums) {\\n        for(int ele: nums) {\\n            System.out.print(ele + \" \");\\n        }\\n        System.out.println();\\n    }\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        int n = queries.length;\\n        int[][] modified = new int[n][3];\\n        for(int i = 0; i < n ; i++) {\\n            modified[i][0] = queries[i][0];\\n            modified[i][1] = queries[i][1];\\n            modified[i][2] = i;\\n        }\\n        columnSort(modified);\\n        for(int[] arr: modified) {\\n        printArr(arr);\\n        }\\n        int[] ans = new int[n];\\n        Trie trie = new Trie();\\n        int index = 0;\\n        for(int i = 0; i < n; i++) {\\n            int maxi = 0;\\n\\n            while(index < nums.length && (modified[i][1] >= nums[index] )) {\\n                \\n                trie.insert(nums[index]);\\n                index++;\\n            }\\n            maxi = trie.maxXor(modified[i][0]);\\n            ans[modified[i][2]]= maxi;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Node {\\n    Node[] links = new Node[2];\\n    public Node() {\\n\\n    }\\n    public Node get(int bit) {\\n        return links[bit];\\n    }\\n\\n    boolean containsKey(int bit) {\\n        return (links[bit] != null);\\n    }\\n\\n    void set(int bit, Node node) {\\n        links[bit] = node;\\n    } \\n}\\n\\nclass Trie {\\n    Node root;\\n    public Trie() {\\n        root = new Node();\\n    }\\n\\n    public void insert(int num) {\\n        Node node = root;\\n         for(int i = 31; i >= 0; i--) {\\n             int bit = (num>>i)&1;\\n            if(!node.containsKey(bit)) {\\n                node.set(bit, new Node());\\n            }\\n            node = node.get(bit);\\n         }\\n    }\\n    public int maxXor(int num) {\\n        Node node = root; \\n        \\n        int ans = 0;\\n        for(int i= 31; i >=0; i--) {\\n            if(node == null) return -1;\\n            int bit= (num>>i)&1;\\n            if(node.containsKey(1-bit)) {\\n                ans = ans | 1<<i;\\n                node = node.get(1-bit);\\n            } else {\\n                node = node.get(bit);\\n            }\\n        \\n        }\\n        return ans;\\n    }\\n\\n    }\\n\\nclass Solution {\\n    public static void columnSort(int[][] queries) {\\n        Arrays.sort(queries, new Comparator<int[]>() {\\n                    public int compare(int[] frst, int[] scnd) {\\n                          if(frst[1] > scnd[1]) {\\n                                 return 1;\\n                           }\\n                          else return -1;\\n                           }\\n                          });\\n    }\\n    public static void printArr(int[] nums) {\\n        for(int ele: nums) {\\n            System.out.print(ele + \" \");\\n        }\\n        System.out.println();\\n    }\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        int n = queries.length;\\n        int[][] modified = new int[n][3];\\n        for(int i = 0; i < n ; i++) {\\n            modified[i][0] = queries[i][0];\\n            modified[i][1] = queries[i][1];\\n            modified[i][2] = i;\\n        }\\n        columnSort(modified);\\n        for(int[] arr: modified) {\\n        printArr(arr);\\n        }\\n        int[] ans = new int[n];\\n        Trie trie = new Trie();\\n        int index = 0;\\n        for(int i = 0; i < n; i++) {\\n            int maxi = 0;\\n\\n            while(index < nums.length && (modified[i][1] >= nums[index] )) {\\n                \\n                trie.insert(nums[index]);\\n                index++;\\n            }\\n            maxi = trie.maxXor(modified[i][0]);\\n            ans[modified[i][2]]= maxi;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013811,
                "title": "java-solution-in-trie",
                "content": "\\n# Code\\n```\\n\\nclass Node {\\n    Node[] links = new Node[2];\\n    public Node() {\\n\\n    }\\n    public Node get(int bit) {\\n        return links[bit];\\n    }\\n\\n    boolean containsKey(int bit) {\\n        return (links[bit] != null);\\n    }\\n\\n    void set(int bit, Node node) {\\n        links[bit] = node;\\n    } \\n}\\n\\nclass Trie {\\n    Node root;\\n    public Trie() {\\n        root = new Node();\\n    }\\n\\n    public void insert(int num) {\\n        Node node = root;\\n         for(int i = 31; i >= 0; i--) {\\n             int bit = (num>>i)&1;\\n            if(!node.containsKey(bit)) {\\n                node.set(bit, new Node());\\n            }\\n            node = node.get(bit);\\n         }\\n    }\\n    public int maxXor(int num) {\\n        Node node = root; \\n        \\n        int ans = 0;\\n        for(int i= 31; i >=0; i--) {\\n            if(node == null) return -1;\\n            int bit= (num>>i)&1;\\n            if(node.containsKey(1-bit)) {\\n                ans = ans | 1<<i;\\n                node = node.get(1-bit);\\n            } else {\\n                node = node.get(bit);\\n            }\\n        \\n        }\\n        return ans;\\n    }\\n\\n    }\\n\\nclass Solution {\\n    public static void columnSort(int[][] queries) {\\n        Arrays.sort(queries, new Comparator<int[]>() {\\n                    public int compare(int[] frst, int[] scnd) {\\n                          if(frst[1] > scnd[1]) {\\n                                 return 1;\\n                           }\\n                          else return -1;\\n                           }\\n                          });\\n    }\\n    public static void printArr(int[] nums) {\\n        for(int ele: nums) {\\n            System.out.print(ele + \" \");\\n        }\\n        System.out.println();\\n    }\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        int n = queries.length;\\n        int[][] modified = new int[n][3];\\n        for(int i = 0; i < n ; i++) {\\n            modified[i][0] = queries[i][0];\\n            modified[i][1] = queries[i][1];\\n            modified[i][2] = i;\\n        }\\n        columnSort(modified);\\n        for(int[] arr: modified) {\\n        printArr(arr);\\n        }\\n        int[] ans = new int[n];\\n        Trie trie = new Trie();\\n        int index = 0;\\n        for(int i = 0; i < n; i++) {\\n            int maxi = 0;\\n\\n            while(index < nums.length && (modified[i][1] >= nums[index] )) {\\n                \\n                trie.insert(nums[index]);\\n                index++;\\n            }\\n            maxi = trie.maxXor(modified[i][0]);\\n            ans[modified[i][2]]= maxi;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Node {\\n    Node[] links = new Node[2];\\n    public Node() {\\n\\n    }\\n    public Node get(int bit) {\\n        return links[bit];\\n    }\\n\\n    boolean containsKey(int bit) {\\n        return (links[bit] != null);\\n    }\\n\\n    void set(int bit, Node node) {\\n        links[bit] = node;\\n    } \\n}\\n\\nclass Trie {\\n    Node root;\\n    public Trie() {\\n        root = new Node();\\n    }\\n\\n    public void insert(int num) {\\n        Node node = root;\\n         for(int i = 31; i >= 0; i--) {\\n             int bit = (num>>i)&1;\\n            if(!node.containsKey(bit)) {\\n                node.set(bit, new Node());\\n            }\\n            node = node.get(bit);\\n         }\\n    }\\n    public int maxXor(int num) {\\n        Node node = root; \\n        \\n        int ans = 0;\\n        for(int i= 31; i >=0; i--) {\\n            if(node == null) return -1;\\n            int bit= (num>>i)&1;\\n            if(node.containsKey(1-bit)) {\\n                ans = ans | 1<<i;\\n                node = node.get(1-bit);\\n            } else {\\n                node = node.get(bit);\\n            }\\n        \\n        }\\n        return ans;\\n    }\\n\\n    }\\n\\nclass Solution {\\n    public static void columnSort(int[][] queries) {\\n        Arrays.sort(queries, new Comparator<int[]>() {\\n                    public int compare(int[] frst, int[] scnd) {\\n                          if(frst[1] > scnd[1]) {\\n                                 return 1;\\n                           }\\n                          else return -1;\\n                           }\\n                          });\\n    }\\n    public static void printArr(int[] nums) {\\n        for(int ele: nums) {\\n            System.out.print(ele + \" \");\\n        }\\n        System.out.println();\\n    }\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        int n = queries.length;\\n        int[][] modified = new int[n][3];\\n        for(int i = 0; i < n ; i++) {\\n            modified[i][0] = queries[i][0];\\n            modified[i][1] = queries[i][1];\\n            modified[i][2] = i;\\n        }\\n        columnSort(modified);\\n        for(int[] arr: modified) {\\n        printArr(arr);\\n        }\\n        int[] ans = new int[n];\\n        Trie trie = new Trie();\\n        int index = 0;\\n        for(int i = 0; i < n; i++) {\\n            int maxi = 0;\\n\\n            while(index < nums.length && (modified[i][1] >= nums[index] )) {\\n                \\n                trie.insert(nums[index]);\\n                index++;\\n            }\\n            maxi = trie.maxXor(modified[i][0]);\\n            ans[modified[i][2]]= maxi;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973620,
                "title": "c-trie-66-2-fastest",
                "content": "# Intuition\\nXOR->Trie\\n\\n# Approach\\n<!--USing Trie -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n    Node* list[2];\\n\\n    bool checkkey(int bit){\\n        return list[bit]!=NULL;\\n    }\\n    void put(int bit, Node* node){\\n        list[bit]=node;\\n    }\\n    Node* get(int bit){\\n        return list[bit];\\n    }\\n};\\nclass Solution {\\npublic:\\n\\n    static bool cmp (vector<int>&a,vector<int>&b)\\n    {\\n        return (a[1]<b[1]);\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& A, vector<vector<int>>& q) {\\n        int n = A.size();\\n        int m = q.size();\\n        sort(A.begin(),A.end());\\n        vector<vector<int>>B;\\n        for(int i=0;i<m;i++){\\n            B.push_back({q[i][0],q[i][1],i});\\n        }\\n        sort(B.begin(),B.end(),cmp);\\n        vector<int>ans(m);\\n        Node* root = new Node();\\n        int x,a;\\n        int idx=0;\\n        for(int i=0;i<m;i++){\\n            x = B[i][0]; a = B[i][1];\\n            while(idx<n && A[idx]<=a){\\n                Node* node = root;\\n                for(int j=31;j>=0;j--){\\n                    if(!node->checkkey( (A[idx]>>j)&1 )){\\n                        node->put((A[idx]>>j)&1,new Node());\\n                    }\\n                    node = node->get((A[idx]>>j)&1);\\n                }\\n                idx++;\\n            }\\n            if(idx==0){\\n                ans[B[i][2]]=-1;\\n                continue;\\n            } \\n            int maxxor =0;\\n            Node* node = root;\\n            int tmp;\\n            for(int j=31;j>=0;j--){\\n                tmp=0;\\n                if(node->checkkey( ((x>>j)&1)^1 )){\\n                    tmp =1;\\n                    node = node->get(((x>>j)&1)^1);\\n                }\\n                else node = node->get((x>>j)&1);\\n                maxxor += (1<<j)*tmp;\\n            }\\n            ans[B[i][2]]=maxxor;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* list[2];\\n\\n    bool checkkey(int bit){\\n        return list[bit]!=NULL;\\n    }\\n    void put(int bit, Node* node){\\n        list[bit]=node;\\n    }\\n    Node* get(int bit){\\n        return list[bit];\\n    }\\n};\\nclass Solution {\\npublic:\\n\\n    static bool cmp (vector<int>&a,vector<int>&b)\\n    {\\n        return (a[1]<b[1]);\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& A, vector<vector<int>>& q) {\\n        int n = A.size();\\n        int m = q.size();\\n        sort(A.begin(),A.end());\\n        vector<vector<int>>B;\\n        for(int i=0;i<m;i++){\\n            B.push_back({q[i][0],q[i][1],i});\\n        }\\n        sort(B.begin(),B.end(),cmp);\\n        vector<int>ans(m);\\n        Node* root = new Node();\\n        int x,a;\\n        int idx=0;\\n        for(int i=0;i<m;i++){\\n            x = B[i][0]; a = B[i][1];\\n            while(idx<n && A[idx]<=a){\\n                Node* node = root;\\n                for(int j=31;j>=0;j--){\\n                    if(!node->checkkey( (A[idx]>>j)&1 )){\\n                        node->put((A[idx]>>j)&1,new Node());\\n                    }\\n                    node = node->get((A[idx]>>j)&1);\\n                }\\n                idx++;\\n            }\\n            if(idx==0){\\n                ans[B[i][2]]=-1;\\n                continue;\\n            } \\n            int maxxor =0;\\n            Node* node = root;\\n            int tmp;\\n            for(int j=31;j>=0;j--){\\n                tmp=0;\\n                if(node->checkkey( ((x>>j)&1)^1 )){\\n                    tmp =1;\\n                    node = node->get(((x>>j)&1)^1);\\n                }\\n                else node = node->get((x>>j)&1);\\n                maxxor += (1<<j)*tmp;\\n            }\\n            ans[B[i][2]]=maxxor;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957260,
                "title": "trie-sorting-based-solution",
                "content": "```\\nstruct Node{\\n    \\n    Node* links[2] ;\\n    \\n    bool containsKey( int bit )\\n    {\\n        return (links[bit] != NULL) ;\\n    }\\n    \\n    Node *get( int bit )\\n    {\\n        return links[bit] ;\\n    }\\n    \\n    void put( int bit , Node* node )\\n    {\\n        links[bit] = node ;\\n    }\\n};\\n\\nclass Trie{\\n    \\n    private : Node* root ;\\n    public :\\n    Trie()\\n    {\\n        root = new Node() ;\\n    }\\n    \\n    void insert( int  n )\\n    {\\n        Node* node = root ;\\n        \\n        for( int i = 31 ; i >= 0 ; i-- )\\n        {\\n            int bit = (n>>i) & 1 ;\\n            \\n            if(!node->containsKey(bit))\\n            {\\n                node->put( bit , new Node() ) ;\\n              \\n            }\\n            \\n              node = node->get(bit) ;\\n        }\\n    }\\n    \\n    int getMax( int n )\\n    {\\n        int res = 0 ;\\n        Node* node = root ;\\n        for( int i = 31 ; i >= 0 ; i-- )\\n        {\\n            int bit = (n>>i) & 1 ;\\n            if(node->containsKey(!bit))\\n            {\\n                res =  res | (1<<i) ;\\n                node = node->get(!bit) ;\\n                \\n            }\\n            else{\\n                node = node->get(bit) ;\\n            }\\n        }\\n        \\n        return res ;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n   \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q ) {\\n        \\n        int n =  q.size() ;\\n        vector<int>ans( n , -1 ) ;\\n        sort( nums.begin() , nums.end()) ;\\n        \\n        vector<vector<int>>queries ;\\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            queries.push_back({ q[i][1] , q[i][0] , i }) ;\\n        }\\n        sort( queries.begin() , queries.end() ) ;\\n        int m = nums.size() ;\\n        int j = 0 ;\\n        \\n        Trie trie ;\\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            int mx = -1 ;\\n            int lmt = queries[i][0] ;\\n            int ele = queries[i][1] ;\\n            int idx = queries[i][2] ;\\n            \\n            while( j < m && nums[j] <= lmt )\\n            {\\n                trie.insert(nums[j]) ;\\n                j++ ;\\n            }\\n            \\n            if( j > 0 )\\n            {\\n                mx = trie.getMax(ele)  ;\\n            }\\n            \\n            \\n            ans[idx] = mx ;\\n        }\\n        \\n        return  ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n    \\n    Node* links[2] ;\\n    \\n    bool containsKey( int bit )\\n    {\\n        return (links[bit] != NULL) ;\\n    }\\n    \\n    Node *get( int bit )\\n    {\\n        return links[bit] ;\\n    }\\n    \\n    void put( int bit , Node* node )\\n    {\\n        links[bit] = node ;\\n    }\\n};\\n\\nclass Trie{\\n    \\n    private : Node* root ;\\n    public :\\n    Trie()\\n    {\\n        root = new Node() ;\\n    }\\n    \\n    void insert( int  n )\\n    {\\n        Node* node = root ;\\n        \\n        for( int i = 31 ; i >= 0 ; i-- )\\n        {\\n            int bit = (n>>i) & 1 ;\\n            \\n            if(!node->containsKey(bit))\\n            {\\n                node->put( bit , new Node() ) ;\\n              \\n            }\\n            \\n              node = node->get(bit) ;\\n        }\\n    }\\n    \\n    int getMax( int n )\\n    {\\n        int res = 0 ;\\n        Node* node = root ;\\n        for( int i = 31 ; i >= 0 ; i-- )\\n        {\\n            int bit = (n>>i) & 1 ;\\n            if(node->containsKey(!bit))\\n            {\\n                res =  res | (1<<i) ;\\n                node = node->get(!bit) ;\\n                \\n            }\\n            else{\\n                node = node->get(bit) ;\\n            }\\n        }\\n        \\n        return res ;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n   \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q ) {\\n        \\n        int n =  q.size() ;\\n        vector<int>ans( n , -1 ) ;\\n        sort( nums.begin() , nums.end()) ;\\n        \\n        vector<vector<int>>queries ;\\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            queries.push_back({ q[i][1] , q[i][0] , i }) ;\\n        }\\n        sort( queries.begin() , queries.end() ) ;\\n        int m = nums.size() ;\\n        int j = 0 ;\\n        \\n        Trie trie ;\\n        \\n        for( int i = 0 ; i < n ; i++ )\\n        {\\n            int mx = -1 ;\\n            int lmt = queries[i][0] ;\\n            int ele = queries[i][1] ;\\n            int idx = queries[i][2] ;\\n            \\n            while( j < m && nums[j] <= lmt )\\n            {\\n                trie.insert(nums[j]) ;\\n                j++ ;\\n            }\\n            \\n            if( j > 0 )\\n            {\\n                mx = trie.getMax(ele)  ;\\n            }\\n            \\n            \\n            ans[idx] = mx ;\\n        }\\n        \\n        return  ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954000,
                "title": "trie-sorting",
                "content": "```\\nstruct Node {\\n    Node* links[2];\\n    bool ContainsKey(int bit) {\\n        return (links[bit] != NULL);\\n    }\\n    void Set(int bit, Node* node) {\\n        links[bit] = node;\\n    }\\n    Node* Get(int bit) {\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void Insert(int Num) {\\n        Node* node = root;\\n        for(auto i = 31; i >= 0; i--) {\\n            int bit = (Num >> i) & 1;\\n            if(!node -> ContainsKey(bit)) {\\n                node -> Set(bit, new Node());\\n            }\\n            node = node -> Get(bit);\\n        }\\n    }\\n    int GetMax(int Num) {\\n        Node* node = root;\\n        int A = 0;\\n        for(auto i = 31; i >= 0; i--) {\\n            int bit = (Num >> i) & 1;\\n            if(node -> ContainsKey(!bit)) {\\n                A = A | (1 << i);\\n                node = node -> Get(!bit);\\n            }\\n            else node = node -> Get(bit);\\n        }\\n        return A;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        int N = nums.size(), M = queries.size();\\n        Trie* root = new Trie();\\n        vector<pair<int, pair<int, int>>> V;\\n        for(auto i = 0; i < M; i++) {\\n            int X = queries[i][0];\\n            int Ai = queries[i][1];\\n            V.push_back({Ai, {X, i}});\\n        }\\n        sort(V.begin(), V.end());\\n        vector<int> A(M);\\n        int Ind = 0;\\n        for(auto &i : V) {\\n            int Ai = i.first, J = i.second.second;\\n            while(Ind < N && nums[Ind] <= Ai) {\\n                root -> Insert(nums[Ind++]);\\n            }\\n            if(Ind == 0) A[J] = -1;\\n            else A[J] = root -> GetMax(i.second.first);\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nstruct Node {\\n    Node* links[2];\\n    bool ContainsKey(int bit) {\\n        return (links[bit] != NULL);\\n    }\\n    void Set(int bit, Node* node) {\\n        links[bit] = node;\\n    }\\n    Node* Get(int bit) {\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void Insert(int Num) {\\n        Node* node = root;\\n        for(auto i = 31; i >= 0; i--) {\\n            int bit = (Num >> i) & 1;\\n            if(!node -> ContainsKey(bit)) {\\n                node -> Set(bit, new Node());\\n            }\\n            node = node -> Get(bit);\\n        }\\n    }\\n    int GetMax(int Num) {\\n        Node* node = root;\\n        int A = 0;\\n        for(auto i = 31; i >= 0; i--) {\\n            int bit = (Num >> i) & 1;\\n            if(node -> ContainsKey(!bit)) {\\n                A = A | (1 << i);\\n                node = node -> Get(!bit);\\n            }\\n            else node = node -> Get(bit);\\n        }\\n        return A;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        int N = nums.size(), M = queries.size();\\n        Trie* root = new Trie();\\n        vector<pair<int, pair<int, int>>> V;\\n        for(auto i = 0; i < M; i++) {\\n            int X = queries[i][0];\\n            int Ai = queries[i][1];\\n            V.push_back({Ai, {X, i}});\\n        }\\n        sort(V.begin(), V.end());\\n        vector<int> A(M);\\n        int Ind = 0;\\n        for(auto &i : V) {\\n            int Ai = i.first, J = i.second.second;\\n            while(Ind < N && nums[Ind] <= Ai) {\\n                root -> Insert(nums[Ind++]);\\n            }\\n            if(Ind == 0) A[J] = -1;\\n            else A[J] = root -> GetMax(i.second.first);\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950827,
                "title": "trie-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n   struct Node {\\n    Node *links[2]; \\n \\n    bool containsKey(int ind) {\\n        return (links[ind] != NULL); \\n    }\\n    Node* get(int ind) {\\n        return links[ind]; \\n    }\\n    void put(int ind, Node* node) {\\n        links[ind] = node; \\n    }\\n}; \\nclass Trie {\\n    private: Node* root; \\npublic:\\n    Trie() {\\n        root = new Node(); \\n    }\\n    \\n    public: \\n    void insert(int num) {\\n        Node* node = root;\\n        // cout << num << endl; \\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(!node->containsKey(bit)) {\\n                node->put(bit, new Node()); \\n            }\\n            node = node->get(bit); \\n        }\\n    }\\n    public:\\n    int findMax(int num) {\\n        Node* node = root; \\n        int maxNum = 0; \\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(node->containsKey(!bit)) {\\n                maxNum = maxNum | (1<<i); \\n                node = node->get(!bit); \\n            }\\n            else {\\n                node = node->get(bit); \\n            }\\n        }\\n        return maxNum; \\n    }\\n};\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) \\n    {\\n        vector<int> ans(queries.size(),0) ; \\n        vector<pair<int,pair<int,int>>> offlinequeries ; \\n        sort(arr.begin(),arr.end()) ;\\n        int index =0 ; \\n        for(auto &it : queries)\\n        offlinequeries.push_back({it[1],{it[0],index++}}) ;\\n        sort(offlinequeries.begin(),offlinequeries.end()) ;\\n        int i = 0, n = arr.size() ;\\n        Trie trie ; \\n        \\n        for(auto &it: offlinequeries )\\n        {\\n            while(i<n && arr[i]<= it.first )\\n            {\\n                trie.insert(arr[i]) ;\\n                i++ ;\\n            }\\n            if(i!=0)\\n            ans[it.second.second] = trie.findMax(it.second.first);\\n            else ans[it.second.second] = -1 ; \\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n   struct Node {\\n    Node *links[2]; \\n \\n    bool containsKey(int ind) {\\n        return (links[ind] != NULL); \\n    }\\n    Node* get(int ind) {\\n        return links[ind]; \\n    }\\n    void put(int ind, Node* node) {\\n        links[ind] = node; \\n    }\\n}; \\nclass Trie {\\n    private: Node* root; \\npublic:\\n    Trie() {\\n        root = new Node(); \\n    }\\n    \\n    public: \\n    void insert(int num) {\\n        Node* node = root;\\n        // cout << num << endl; \\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(!node->containsKey(bit)) {\\n                node->put(bit, new Node()); \\n            }\\n            node = node->get(bit); \\n        }\\n    }\\n    public:\\n    int findMax(int num) {\\n        Node* node = root; \\n        int maxNum = 0; \\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(node->containsKey(!bit)) {\\n                maxNum = maxNum | (1<<i); \\n                node = node->get(!bit); \\n            }\\n            else {\\n                node = node->get(bit); \\n            }\\n        }\\n        return maxNum; \\n    }\\n};\\n    vector<int> maximizeXor(vector<int>& arr, vector<vector<int>>& queries) \\n    {\\n        vector<int> ans(queries.size(),0) ; \\n        vector<pair<int,pair<int,int>>> offlinequeries ; \\n        sort(arr.begin(),arr.end()) ;\\n        int index =0 ; \\n        for(auto &it : queries)\\n        offlinequeries.push_back({it[1],{it[0],index++}}) ;\\n        sort(offlinequeries.begin(),offlinequeries.end()) ;\\n        int i = 0, n = arr.size() ;\\n        Trie trie ; \\n        \\n        for(auto &it: offlinequeries )\\n        {\\n            while(i<n && arr[i]<= it.first )\\n            {\\n                trie.insert(arr[i]) ;\\n                i++ ;\\n            }\\n            if(i!=0)\\n            ans[it.second.second] = trie.findMax(it.second.first);\\n            else ans[it.second.second] = -1 ; \\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2921481,
                "title": "easy-trie-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:   \\n    struct Node {\\n        Node * list[2];         // 1 or 0 we are storing no in form of bits\\n        bool isContains(int bit){\\n            return list[bit] != NULL;\\n        }\\n        void put (int bit, Node * node){\\n            list[bit] = node;\\n        }\\n        Node* get (int bit) {\\n            return list[bit];\\n        }\\n    };\\n    class Trie {\\n        Node * root;\\n        public: \\n        Trie(){\\n            root = new Node();\\n        }\\n        void insert(int n){                     // inserting no in form of bits from 31 to 0\\n            Node * node = root;\\n            for(int i = 31;i>=0;i--){\\n                int bit = ((n>>i)&1);\\n                if(!node->isContains(bit)){         // if not Contain put\\n                    node->put(bit,new Node());\\n                }\\n                node = node->get(bit);              // move to the next one\\n            }\\n        }\\n        int MaxXor(int n){\\n            int maxm = 0;\\n            Node * node = root;\\n            for(int i = 31;i>=0;i--){\\n                int bit = !((n>>i)&1);              // we are looking for opp bit of n \\n                if(node->isContains(bit)){          // if we found opp bit add it to maxm and move\\n                    maxm = maxm|(1<<i);\\n                    node = node->get(bit);\\n                }\\n                else \\n                node = node->get(!bit);             // if we don\\'t found opp bit no option just choose the same bit \\n            }\\n            return maxm;\\n        }\\n    };\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(),-1);\\n        vector<pair<int,pair<int,int>>> query;          //{maxm, {n, index}}\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size(), m = queries.size();\\n        for(int i = 0;i<m;i++){\\n            query.push_back({queries[i][1], {queries[i][0],i}});\\n        }\\n        sort(query.begin(),query.end());\\n        int idx = 0;\\n        Trie trie;\\n        for(auto i : query){\\n            while(idx<n && nums[idx]<= i.first){\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n            if(idx!= 0) ans[i.second.second] = trie.MaxXor(i.second.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    struct Node {\\n        Node * list[2];         // 1 or 0 we are storing no in form of bits\\n        bool isContains(int bit){\\n            return list[bit] != NULL;\\n        }\\n        void put (int bit, Node * node){\\n            list[bit] = node;\\n        }\\n        Node* get (int bit) {\\n            return list[bit];\\n        }\\n    };\\n    class Trie {\\n        Node * root;\\n        public: \\n        Trie(){\\n            root = new Node();\\n        }\\n        void insert(int n){                     // inserting no in form of bits from 31 to 0\\n            Node * node = root;\\n            for(int i = 31;i>=0;i--){\\n                int bit = ((n>>i)&1);\\n                if(!node->isContains(bit)){         // if not Contain put\\n                    node->put(bit,new Node());\\n                }\\n                node = node->get(bit);              // move to the next one\\n            }\\n        }\\n        int MaxXor(int n){\\n            int maxm = 0;\\n            Node * node = root;\\n            for(int i = 31;i>=0;i--){\\n                int bit = !((n>>i)&1);              // we are looking for opp bit of n \\n                if(node->isContains(bit)){          // if we found opp bit add it to maxm and move\\n                    maxm = maxm|(1<<i);\\n                    node = node->get(bit);\\n                }\\n                else \\n                node = node->get(!bit);             // if we don\\'t found opp bit no option just choose the same bit \\n            }\\n            return maxm;\\n        }\\n    };\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(),-1);\\n        vector<pair<int,pair<int,int>>> query;          //{maxm, {n, index}}\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size(), m = queries.size();\\n        for(int i = 0;i<m;i++){\\n            query.push_back({queries[i][1], {queries[i][0],i}});\\n        }\\n        sort(query.begin(),query.end());\\n        int idx = 0;\\n        Trie trie;\\n        for(auto i : query){\\n            while(idx<n && nums[idx]<= i.first){\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n            if(idx!= 0) ans[i.second.second] = trie.MaxXor(i.second.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914767,
                "title": "c-solution-clear",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nclass TreeNode {\\n    public:\\n        TreeNode* next[2];\\n        TreeNode () {next[0] = NULL; next[1] = NULL;};\\n    };\\n    TreeNode* root = new TreeNode(), *cur;\\n\\n    void insert(int num) {\\n        cur = root;\\n        for (int i = 30; i >= 0; i--) {\\n            int ind = ((num >> i) & 1);\\n            if (cur->next[ind] ==  NULL)\\n                cur->next[ind] = new TreeNode();\\n            cur = cur->next[ind];\\n        }\\n    }\\n\\n    int find_xor(int num) {\\n        int res = 0;\\n        cur = root;\\n        for (int i = 30; i >= 0; i--) {\\n            int ind = (num >> i) & 1;\\n            if (cur->next[ind ^ 1]) {\\n                res += 1 << i;\\n                cur = cur->next[ind ^ 1];\\n            } else {\\n                cur = cur->next[ind];\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& v, vector<vector<int>>& qq) {\\n        int n = v.size(), i = 0;\\n        vector<int> ans(qq.size());\\n        vector<tuple<int,int,int>> q;\\n\\n        for (int j=0; j<qq.size(); j++){\\n            q.push_back({qq[j][1], qq[j][0], j});\\n        }\\n        sort(begin(q), end(q));\\n        sort(begin(v), end(v));\\n\\n        for (auto [m, x, ind]:q){\\n            if (m < v[0]){\\n                ans[ind] = -1;\\n                continue;\\n            }\\n            while (i<n && v[i] <= m){\\n                insert(v[i++]);\\n            }\\n            ans[ind] = find_xor(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nclass TreeNode {\\n    public:\\n        TreeNode* next[2];\\n        TreeNode () {next[0] = NULL; next[1] = NULL;};\\n    };\\n    TreeNode* root = new TreeNode(), *cur;\\n\\n    void insert(int num) {\\n        cur = root;\\n        for (int i = 30; i >= 0; i--) {\\n            int ind = ((num >> i) & 1);\\n            if (cur->next[ind] ==  NULL)\\n                cur->next[ind] = new TreeNode();\\n            cur = cur->next[ind];\\n        }\\n    }\\n\\n    int find_xor(int num) {\\n        int res = 0;\\n        cur = root;\\n        for (int i = 30; i >= 0; i--) {\\n            int ind = (num >> i) & 1;\\n            if (cur->next[ind ^ 1]) {\\n                res += 1 << i;\\n                cur = cur->next[ind ^ 1];\\n            } else {\\n                cur = cur->next[ind];\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& v, vector<vector<int>>& qq) {\\n        int n = v.size(), i = 0;\\n        vector<int> ans(qq.size());\\n        vector<tuple<int,int,int>> q;\\n\\n        for (int j=0; j<qq.size(); j++){\\n            q.push_back({qq[j][1], qq[j][0], j});\\n        }\\n        sort(begin(q), end(q));\\n        sort(begin(v), end(v));\\n\\n        for (auto [m, x, ind]:q){\\n            if (m < v[0]){\\n                ans[ind] = -1;\\n                continue;\\n            }\\n            while (i<n && v[i] <= m){\\n                insert(v[i++]);\\n            }\\n            ans[ind] = find_xor(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913181,
                "title": "c-easy-and-faster-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\nprivate:\\n    struct TrieNode{\\n      TrieNode* children[2];\\n    };\\n\\npublic:\\n\\n    TrieNode* root = new TrieNode();\\n\\n    static bool comp(vector<int>& a, vector<int>& b){\\n        return a[1]<b[1];\\n    }\\n\\n    void insertInTrie(int num){\\n\\n        TrieNode* curr = root;\\n        for(int i = 31; i>=0; i--){\\n          int bit = (num>>i) & 1;\\n          if(!curr->children[bit]){\\n            curr->children[bit] = new TrieNode();\\n          }\\n          curr = curr->children[bit];\\n        }\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        \\n        for(int i = 0; i<queries.size(); i++){\\n          queries[i].push_back(i);\\n        }\\n\\n        sort(queries.begin(), queries.end(), comp);\\n        sort(nums.begin(), nums.end());\\n\\n        vector<int> ans(queries.size());\\n\\n        int j = 0;\\n        for(int i = 0; i<queries.size(); i++){\\n\\n          int currNum = queries[i][0];\\n          int currLimit = queries[i][1];\\n          int currInt = queries[i][2];\\n\\n          while(j<nums.size() && nums[j] <= currLimit){\\n            insertInTrie(nums[j]);\\n            j++;\\n          }\\n          \\n          TrieNode* curr = root;\\n          int rslt = 0;\\n\\n          bool EmptyTree = true;\\n          for(int i = 31; i>=0; i--){\\n            int bit = (currNum>>i) & 1;\\n            if(curr->children[!bit]){\\n              EmptyTree = false;\\n              rslt += pow(2, i);\\n              curr = curr->children[!bit];\\n            }\\n            else if(curr->children[bit]){\\n              EmptyTree = false;\\n              curr = curr->children[bit];\\n            }\\n            else{\\n                break;\\n            }\\n          }\\n          if(EmptyTree){\\n              ans[currInt] = -1; \\n          }\\n          else{\\n              ans[currInt] = rslt; \\n          }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    struct TrieNode{\\n      TrieNode* children[2];\\n    };\\n\\npublic:\\n\\n    TrieNode* root = new TrieNode();\\n\\n    static bool comp(vector<int>& a, vector<int>& b){\\n        return a[1]<b[1];\\n    }\\n\\n    void insertInTrie(int num){\\n\\n        TrieNode* curr = root;\\n        for(int i = 31; i>=0; i--){\\n          int bit = (num>>i) & 1;\\n          if(!curr->children[bit]){\\n            curr->children[bit] = new TrieNode();\\n          }\\n          curr = curr->children[bit];\\n        }\\n    }\\n\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        \\n        for(int i = 0; i<queries.size(); i++){\\n          queries[i].push_back(i);\\n        }\\n\\n        sort(queries.begin(), queries.end(), comp);\\n        sort(nums.begin(), nums.end());\\n\\n        vector<int> ans(queries.size());\\n\\n        int j = 0;\\n        for(int i = 0; i<queries.size(); i++){\\n\\n          int currNum = queries[i][0];\\n          int currLimit = queries[i][1];\\n          int currInt = queries[i][2];\\n\\n          while(j<nums.size() && nums[j] <= currLimit){\\n            insertInTrie(nums[j]);\\n            j++;\\n          }\\n          \\n          TrieNode* curr = root;\\n          int rslt = 0;\\n\\n          bool EmptyTree = true;\\n          for(int i = 31; i>=0; i--){\\n            int bit = (currNum>>i) & 1;\\n            if(curr->children[!bit]){\\n              EmptyTree = false;\\n              rslt += pow(2, i);\\n              curr = curr->children[!bit];\\n            }\\n            else if(curr->children[bit]){\\n              EmptyTree = false;\\n              curr = curr->children[bit];\\n            }\\n            else{\\n                break;\\n            }\\n          }\\n          if(EmptyTree){\\n              ans[currInt] = -1; \\n          }\\n          else{\\n              ans[currInt] = rslt; \\n          }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814018,
                "title": "trie-bitwise-offline-query-complexity-analysis-easy-code-c",
                "content": "![image.png](https://assets.leetcode.com/users/images/db5cf9a3-1db5-4011-b27c-4b39e2e1a2a3_1668433341.2061965.png)\\n\\n\\n# Intuition\\nStore all nums in binary format in a Trie data structure and run queries in offline approach\\n\\n# Approach\\n- Create Trie class\\n- Sort the queries based on second element\\n- Sort the nums\\n- Insert num in Trie until the current num is less than the current query[1]\\n- Run ```T->findMax``` function on current free for current query \\n\\n# Time Complexity\\n$$O(NlogN) + O(QlogQ)$$\\nwhere,\\nN is the size of ```nums```\\nQ is the size of ```queries```\\n\\n\\n# Space Complexity\\n$$O(N*32) + O(Q*2)$$ = $$O(N) + O(Q)$$\\n\\nwhere,\\nN is the size of ```nums```\\nQ is the size of ```queries```\\n\\n# Code\\n```\\nstruct Node {\\n    Node *children[2];\\n    Node() {\\n        children[0] = nullptr;\\n        children[1] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\n    private:\\n        Node *root = new Node();\\n    public:\\n        void insert(int num) {\\n            Node *curNode = root;\\n            for (int i = 31; i >= 0; i--) {\\n                int index = (num >> i) & 1;\\n                if (curNode->children[index] == nullptr) {\\n                    curNode->children[index] = new Node();\\n                }\\n                curNode = curNode->children[index];\\n            }\\n        }\\n        int findMax(int num) {\\n            if (root->children[0] == nullptr && root->children[1] == nullptr) {\\n                return -1;\\n            }\\n            int curMax = 0;\\n            Node *curNode = root;\\n            for (int i = 31; i >= 0; i--) {\\n                int index = (num >> i) & 1;\\n                if (curNode->children[!index] != nullptr) {\\n                    curMax = curMax | (1 << i);\\n                    curNode = curNode->children[!index];\\n                }\\n                else {\\n                    curNode = curNode->children[index];\\n                }\\n            }\\n            return curMax;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> sol(queries.size());\\n        Trie *T = new Trie();\\n        int index = 0;\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        sort(queries.begin(), queries.end(), [](vector<int> &a, vector<int> &b){ \\n            return a[1] < b[1];\\n        });\\n\\n        for (auto &query : queries) {\\n            while (index < nums.size() && nums[index] <= query[1]) {\\n                T->insert(nums[index]);\\n                index++;\\n            }\\n            sol[query[2]] = T->findMax(query[0]);\\n        }\\n\\n        return sol;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```T->findMax```\n```nums```\n```queries```\n```nums```\n```queries```\n```\\nstruct Node {\\n    Node *children[2];\\n    Node() {\\n        children[0] = nullptr;\\n        children[1] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\n    private:\\n        Node *root = new Node();\\n    public:\\n        void insert(int num) {\\n            Node *curNode = root;\\n            for (int i = 31; i >= 0; i--) {\\n                int index = (num >> i) & 1;\\n                if (curNode->children[index] == nullptr) {\\n                    curNode->children[index] = new Node();\\n                }\\n                curNode = curNode->children[index];\\n            }\\n        }\\n        int findMax(int num) {\\n            if (root->children[0] == nullptr && root->children[1] == nullptr) {\\n                return -1;\\n            }\\n            int curMax = 0;\\n            Node *curNode = root;\\n            for (int i = 31; i >= 0; i--) {\\n                int index = (num >> i) & 1;\\n                if (curNode->children[!index] != nullptr) {\\n                    curMax = curMax | (1 << i);\\n                    curNode = curNode->children[!index];\\n                }\\n                else {\\n                    curNode = curNode->children[index];\\n                }\\n            }\\n            return curMax;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> sol(queries.size());\\n        Trie *T = new Trie();\\n        int index = 0;\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        sort(queries.begin(), queries.end(), [](vector<int> &a, vector<int> &b){ \\n            return a[1] < b[1];\\n        });\\n\\n        for (auto &query : queries) {\\n            while (index < nums.size() && nums[index] <= query[1]) {\\n                T->insert(nums[index]);\\n                index++;\\n            }\\n            sol[query[2]] = T->findMax(query[0]);\\n        }\\n\\n        return sol;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813982,
                "title": "trie-bitwise-offline-query-complexity-analysis-easy-code-c",
                "content": "# Intuition\\nStore all nums in binary format in a Trie data structure and run queries in offline approach\\n\\n# Approach\\n- Create Trie class\\n- Sort the queries based on second element\\n- Sort the nums\\n- Insert num in Trie until the current num is less than the current query[1]\\n\\n\\n# Code\\n```\\nstruct Node {\\n    Node *children[2];\\n    Node() {\\n        children[0] = nullptr;\\n        children[1] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\n    private:\\n        Node *root;\\n        Node *getNode() {\\n            return new Node();\\n        }\\n    public:\\n        Trie() {\\n            root = new Node();\\n        }\\n        void insert(int num) {\\n            Node *curNode = root;\\n            for (int i = 31; i >= 0; i--) {\\n                int index = (num >> i) & 1;\\n                if (curNode->children[index] == nullptr) curNode->children[index] = getNode();\\n                curNode = curNode->children[index];\\n            }\\n        }\\n        int findMax(int num) {\\n            if (root->children[0] == nullptr && root->children[1] == nullptr) return -1;\\n            int curMax = 0;\\n            Node *curNode = root;\\n            for (int i = 31; i >= 0; i--) {\\n                int index = (num >> i) & 1;\\n                if (curNode->children[!index] != nullptr) {\\n                    curMax = curMax | (1 << i);\\n                    curNode = curNode->children[!index];\\n                }\\n                else curNode = curNode->children[index];\\n            }\\n            return curMax;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> sol(queries.size());\\n        vector<vector<int>> newQueries;\\n        Trie *T = new Trie();\\n        int index = 0;\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            newQueries.push_back({queries[i][1], queries[i][0], i});\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        sort(newQueries.begin(), newQueries.end());\\n\\n        for (auto &query : newQueries) {\\n            while (index < nums.size() && nums[index] <= query[0]) {\\n                T->insert(nums[index]);\\n                index++;\\n            }\\n            sol[query[2]] = T->findMax(query[1]);\\n        }\\n\\n        return sol;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n    Node *children[2];\\n    Node() {\\n        children[0] = nullptr;\\n        children[1] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\n    private:\\n        Node *root;\\n        Node *getNode() {\\n            return new Node();\\n        }\\n    public:\\n        Trie() {\\n            root = new Node();\\n        }\\n        void insert(int num) {\\n            Node *curNode = root;\\n            for (int i = 31; i >= 0; i--) {\\n                int index = (num >> i) & 1;\\n                if (curNode->children[index] == nullptr) curNode->children[index] = getNode();\\n                curNode = curNode->children[index];\\n            }\\n        }\\n        int findMax(int num) {\\n            if (root->children[0] == nullptr && root->children[1] == nullptr) return -1;\\n            int curMax = 0;\\n            Node *curNode = root;\\n            for (int i = 31; i >= 0; i--) {\\n                int index = (num >> i) & 1;\\n                if (curNode->children[!index] != nullptr) {\\n                    curMax = curMax | (1 << i);\\n                    curNode = curNode->children[!index];\\n                }\\n                else curNode = curNode->children[index];\\n            }\\n            return curMax;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> sol(queries.size());\\n        vector<vector<int>> newQueries;\\n        Trie *T = new Trie();\\n        int index = 0;\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            newQueries.push_back({queries[i][1], queries[i][0], i});\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        sort(newQueries.begin(), newQueries.end());\\n\\n        for (auto &query : newQueries) {\\n            while (index < nums.size() && nums[index] <= query[0]) {\\n                T->insert(nums[index]);\\n                index++;\\n            }\\n            sol[query[2]] = T->findMax(query[1]);\\n        }\\n\\n        return sol;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804141,
                "title": "c-sol-trie-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(m)+o(mlogm)+o((n+q)*32)\\n- m->size of queue array\\n- n->size of nums array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(3*m)+o(m)  m->size of quries vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nstruct Node {\\n    Node *links[2]; \\n \\n    bool containsKey(int ind) {\\n        return (links[ind] != NULL); \\n    }\\n    Node* get(int ind) {\\n        return links[ind]; \\n    }\\n    void put(int ind, Node* node) {\\n        links[ind] = node; \\n    }\\n}; \\nclass Trie {\\n    private: Node* root; \\npublic:\\n    Trie() {\\n        root = new Node(); \\n    }\\n    \\n    public: \\n    void insert(int num) {\\n        Node* node = root;\\n        // cout << num << endl; \\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(!node->containsKey(bit)) {\\n                node->put(bit, new Node()); \\n            }\\n            node = node->get(bit); \\n        }\\n    }\\n    public:\\n    int maxval(int num) {\\n        Node* node = root; \\n        int maxNum = 0; \\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(node->containsKey(!bit)) {\\n                maxNum = maxNum | (1<<i); \\n                node = node->get(!bit); \\n            }\\n            else {\\n                node = node->get(bit); \\n            }\\n        }\\n        return maxNum; \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(),0);\\n        vector<pair<int,pair<int,int>>> ofq;\\n        sort(nums.begin(),nums.end());\\n        int idx=0;\\n        for(auto &it:queries){\\n            ofq.push_back({it[1],{it[0],idx++}});\\n        }\\n        sort(ofq.begin(),ofq.end());\\n        int i=0;\\n        int n= nums.size();\\n        Trie*trie= new Trie();\\n\\n        for(auto &it: ofq){\\n            while(i<n && nums[i]<=it.first){\\n                trie->insert(nums[i]);\\n                i++;\\n            }\\n            if(i!=0)  ans[it.second.second]=trie->maxval(it.second.first);\\n            else{\\n                ans[it.second.second]=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nstruct Node {\\n    Node *links[2]; \\n \\n    bool containsKey(int ind) {\\n        return (links[ind] != NULL); \\n    }\\n    Node* get(int ind) {\\n        return links[ind]; \\n    }\\n    void put(int ind, Node* node) {\\n        links[ind] = node; \\n    }\\n}; \\nclass Trie {\\n    private: Node* root; \\npublic:\\n    Trie() {\\n        root = new Node(); \\n    }\\n    \\n    public: \\n    void insert(int num) {\\n        Node* node = root;\\n        // cout << num << endl; \\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(!node->containsKey(bit)) {\\n                node->put(bit, new Node()); \\n            }\\n            node = node->get(bit); \\n        }\\n    }\\n    public:\\n    int maxval(int num) {\\n        Node* node = root; \\n        int maxNum = 0; \\n        for(int i = 31;i>=0;i--) {\\n            int bit = (num >> i) & 1; \\n            if(node->containsKey(!bit)) {\\n                maxNum = maxNum | (1<<i); \\n                node = node->get(!bit); \\n            }\\n            else {\\n                node = node->get(bit); \\n            }\\n        }\\n        return maxNum; \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(),0);\\n        vector<pair<int,pair<int,int>>> ofq;\\n        sort(nums.begin(),nums.end());\\n        int idx=0;\\n        for(auto &it:queries){\\n            ofq.push_back({it[1],{it[0],idx++}});\\n        }\\n        sort(ofq.begin(),ofq.end());\\n        int i=0;\\n        int n= nums.size();\\n        Trie*trie= new Trie();\\n\\n        for(auto &it: ofq){\\n            while(i<n && nums[i]<=it.first){\\n                trie->insert(nums[i]);\\n                i++;\\n            }\\n            if(i!=0)  ans[it.second.second]=trie->maxval(it.second.first);\\n            else{\\n                ans[it.second.second]=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2789292,
                "title": "c-simple-trie-solution-beats-100-no-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node {\\nprivate:\\n    Node* links[2];\\npublic:\\n    bool contains(int bit) {\\n        return (links[bit] != NULL);\\n    }\\n    void put(int bit, Node* node) {\\n        links[bit] = node;\\n    }\\n    Node* get(int bit) {\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        Node* node = root;\\n        for (int i = 31; i >= 0; --i) {\\n            int bit = (num >> i) & 1;\\n            if (!node->contains(bit)) {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n    int maxXor(int num) {\\n        Node* node = root;\\n        int mx = 0;\\n        for (int i = 31; i >= 0; --i) {\\n            int bit = (num >> i) & 1;\\n            if (node->contains(1-bit)) {\\n                mx = mx | (1 << i);\\n                node = node->get(1-bit);\\n            } else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size(), m = queries.size();\\n        Trie trie;\\n        vector<int> result(m, 0);\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(), queries.end(), [](vector<int> &lhs, vector<int> &rhs) {\\n            return lhs[1] < rhs[1];\\n        });\\n        int i = 0;\\n        for (auto query : queries) {\\n            int x = query[0], a = query[1], ind = query[2];\\n            while (i < n && nums[i] <= a) {\\n                trie.insert(nums[i]);\\n                i++;\\n            }\\n            if (i == 0) result[ind] = -1;\\n            else result[ind] = trie.maxXor(x);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node {\\nprivate:\\n    Node* links[2];\\npublic:\\n    bool contains(int bit) {\\n        return (links[bit] != NULL);\\n    }\\n    void put(int bit, Node* node) {\\n        links[bit] = node;\\n    }\\n    Node* get(int bit) {\\n        return links[bit];\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    Node* root;\\npublic:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        Node* node = root;\\n        for (int i = 31; i >= 0; --i) {\\n            int bit = (num >> i) & 1;\\n            if (!node->contains(bit)) {\\n                node->put(bit, new Node());\\n            }\\n            node = node->get(bit);\\n        }\\n    }\\n    int maxXor(int num) {\\n        Node* node = root;\\n        int mx = 0;\\n        for (int i = 31; i >= 0; --i) {\\n            int bit = (num >> i) & 1;\\n            if (node->contains(1-bit)) {\\n                mx = mx | (1 << i);\\n                node = node->get(1-bit);\\n            } else {\\n                node = node->get(bit);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size(), m = queries.size();\\n        Trie trie;\\n        vector<int> result(m, 0);\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(), queries.end(), [](vector<int> &lhs, vector<int> &rhs) {\\n            return lhs[1] < rhs[1];\\n        });\\n        int i = 0;\\n        for (auto query : queries) {\\n            int x = query[0], a = query[1], ind = query[2];\\n            while (i < n && nums[i] <= a) {\\n                trie.insert(nums[i]);\\n                i++;\\n            }\\n            if (i == 0) result[ind] = -1;\\n            else result[ind] = trie.maxXor(x);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784318,
                "title": "maximum-xor-using-trie-approach-in-optimal-time-and-space",
                "content": "# Intuition\\nWe first need to understand how to find Maximum xor of a number with an array using trie approach. Then only we will be able to do this question\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor approach watch video of striver youtube\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n*32)\\n\\n# Code\\n```\\nstruct Node{\\n    Node* link[2];\\n\\n    bool contains(int bit){\\n        if(link[bit]!= NULL) return true;\\n        return false;\\n    }\\n\\n    void CreateNew(int bit, Node* newnode){\\n        link[bit] = newnode;\\n    }\\n\\n    Node* next(int bit){\\n        return(link[bit]);\\n    }\\n};\\n\\nclass Trie{\\n    Node* root;\\n    public:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(int x){\\n        Node* node = root;\\n        for(int i = 31 ; i>=0 ; i--){\\n            int bit = (x>>i) & 1;\\n            if(!node->contains(bit)){\\n                node->CreateNew(bit , new Node());\\n            }\\n            node = node->next(bit);\\n        }\\n    }\\n\\n    int EleMaxXor(int x){\\n        int ans = 0;\\n        Node* node = root;\\n        for(int i = 31 ; i>=0 ; i--){\\n            int bit = (x>>i) & 1;\\n            if(node->contains(1-bit)){\\n                ans |= (1<<i);\\n                node = node->next(1-bit);\\n            }\\n            else{\\n                node = node->next(bit);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie t;\\n        vector<pair<int, pair<int, int>>> oq;\\n        int q = queries.size();\\n\\n        for(int i = 0; i<q ; i++){\\n            oq.push_back({queries[i][1] , {queries[i][0] , i}});\\n        }\\n\\n        vector<int> ans(q, 0);\\n        sort(nums.begin() , nums.end());\\n        sort(oq.begin() , oq.end());\\n\\n        int idx = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<q; i++){\\n            int mi = oq[i].first;\\n            int xi = oq[i].second.first;\\n            int qidx = oq[i].second.second;\\n\\n            while(idx < n && nums[idx] <= mi){\\n                t.insert(nums[idx++]);\\n            }\\n            if(idx == 0) ans[qidx] = -1;\\n            else ans[qidx] = t.EleMaxXor(xi);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* link[2];\\n\\n    bool contains(int bit){\\n        if(link[bit]!= NULL) return true;\\n        return false;\\n    }\\n\\n    void CreateNew(int bit, Node* newnode){\\n        link[bit] = newnode;\\n    }\\n\\n    Node* next(int bit){\\n        return(link[bit]);\\n    }\\n};\\n\\nclass Trie{\\n    Node* root;\\n    public:\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(int x){\\n        Node* node = root;\\n        for(int i = 31 ; i>=0 ; i--){\\n            int bit = (x>>i) & 1;\\n            if(!node->contains(bit)){\\n                node->CreateNew(bit , new Node());\\n            }\\n            node = node->next(bit);\\n        }\\n    }\\n\\n    int EleMaxXor(int x){\\n        int ans = 0;\\n        Node* node = root;\\n        for(int i = 31 ; i>=0 ; i--){\\n            int bit = (x>>i) & 1;\\n            if(node->contains(1-bit)){\\n                ans |= (1<<i);\\n                node = node->next(1-bit);\\n            }\\n            else{\\n                node = node->next(bit);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        Trie t;\\n        vector<pair<int, pair<int, int>>> oq;\\n        int q = queries.size();\\n\\n        for(int i = 0; i<q ; i++){\\n            oq.push_back({queries[i][1] , {queries[i][0] , i}});\\n        }\\n\\n        vector<int> ans(q, 0);\\n        sort(nums.begin() , nums.end());\\n        sort(oq.begin() , oq.end());\\n\\n        int idx = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<q; i++){\\n            int mi = oq[i].first;\\n            int xi = oq[i].second.first;\\n            int qidx = oq[i].second.second;\\n\\n            while(idx < n && nums[idx] <= mi){\\n                t.insert(nums[idx++]);\\n            }\\n            if(idx == 0) ans[qidx] = -1;\\n            else ans[qidx] = t.EleMaxXor(xi);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774213,
                "title": "c-easy-solution",
                "content": "```\\nstruct Node{\\n    Node* links[2];\\n};\\nclass Trie{\\n  private:\\n    Node* root;\\n  public:\\n    Trie(){\\n        root=new Node();\\n    }    \\n    void insert(int n){\\n        Node* node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(n>>i)&1;\\n            if(node->links[bit]==NULL){\\n                node->links[bit]=new Node();\\n            }\\n            node=node->links[bit];\\n        }\\n    }\\n    int getMax(int n){\\n        Node* node=root;\\n        int mx=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(n>>i)&1;\\n            if(node->links[1-bit]!=NULL){\\n                mx=mx|(1<<i);\\n                node=node->links[1-bit];\\n            }\\n            else{\\n                node=node->links[bit];\\n            }\\n        }\\n        return mx;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        sort(nums.begin(),nums.end());\\n        vector<pair<int,pair<int,int>>>oq;\\n        \\n        int m=q.size();\\n        for(int i=0;i<m;i++){\\n            oq.push_back({q[i][1],{q[i][0],i}});\\n        }\\n        sort(oq.begin(),oq.end());\\n        \\n        int idx=0;\\n        vector<int>ans(m,0);\\n        int n=nums.size();\\n        Trie trie;\\n        for(int i=0;i<m;i++){\\n            int a=oq[i].first;\\n            int x=oq[i].second.first;\\n            int qidx=oq[i].second.second;\\n            \\n            while(idx<n && nums[idx]<=a){\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n            if(idx==0){\\n                ans[qidx]=-1;\\n            }\\n            else{\\n                ans[qidx]=trie.getMax(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n    Node* links[2];\\n};\\nclass Trie{\\n  private:\\n    Node* root;\\n  public:\\n    Trie(){\\n        root=new Node();\\n    }    \\n    void insert(int n){\\n        Node* node=root;\\n        for(int i=31;i>=0;i--){\\n            int bit=(n>>i)&1;\\n            if(node->links[bit]==NULL){\\n                node->links[bit]=new Node();\\n            }\\n            node=node->links[bit];\\n        }\\n    }\\n    int getMax(int n){\\n        Node* node=root;\\n        int mx=0;\\n        for(int i=31;i>=0;i--){\\n            int bit=(n>>i)&1;\\n            if(node->links[1-bit]!=NULL){\\n                mx=mx|(1<<i);\\n                node=node->links[1-bit];\\n            }\\n            else{\\n                node=node->links[bit];\\n            }\\n        }\\n        return mx;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& q) {\\n        sort(nums.begin(),nums.end());\\n        vector<pair<int,pair<int,int>>>oq;\\n        \\n        int m=q.size();\\n        for(int i=0;i<m;i++){\\n            oq.push_back({q[i][1],{q[i][0],i}});\\n        }\\n        sort(oq.begin(),oq.end());\\n        \\n        int idx=0;\\n        vector<int>ans(m,0);\\n        int n=nums.size();\\n        Trie trie;\\n        for(int i=0;i<m;i++){\\n            int a=oq[i].first;\\n            int x=oq[i].second.first;\\n            int qidx=oq[i].second.second;\\n            \\n            while(idx<n && nums[idx]<=a){\\n                trie.insert(nums[idx]);\\n                idx++;\\n            }\\n            if(idx==0){\\n                ans[qidx]=-1;\\n            }\\n            else{\\n                ans[qidx]=trie.getMax(x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766032,
                "title": "c-binary-search-with-vector-iterator",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>::iterator begin, vector<int>::iterator end, int x, int v, int mask) {\\n        if (begin == end) return -1;\\n        if (begin + 1 == end) return *begin;\\n        if (mask == 0) return -1;\\n        \\n        bool hasBit = x & mask;\\n        int u = v | mask;\\n        mask = mask >> 1;\\n        auto mid = lower_bound(begin, end, u);\\n        \\n        if ((!hasBit && mid != end) || begin == mid) {\\n            return find(mid, end, x, u, mask);\\n        } else {\\n            return find(begin, mid, x, v, mask);\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = queries.size();\\n        sort(nums.begin(), nums.end());\\n        auto end = unique(nums.begin(), nums.end());\\n        \\n        vector<int> ans(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            int x = queries[i][0];\\n            int m = queries[i][1];\\n            int mask = 1 << 30;\\n            \\n            auto range = upper_bound(nums.begin(), end, m);\\n            ans[i] = find(nums.begin(), range, x, 0, mask);\\n            if (ans[i] != -1) ans[i] ^= x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>::iterator begin, vector<int>::iterator end, int x, int v, int mask) {\\n        if (begin == end) return -1;\\n        if (begin + 1 == end) return *begin;\\n        if (mask == 0) return -1;\\n        \\n        bool hasBit = x & mask;\\n        int u = v | mask;\\n        mask = mask >> 1;\\n        auto mid = lower_bound(begin, end, u);\\n        \\n        if ((!hasBit && mid != end) || begin == mid) {\\n            return find(mid, end, x, u, mask);\\n        } else {\\n            return find(begin, mid, x, v, mask);\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        int n = queries.size();\\n        sort(nums.begin(), nums.end());\\n        auto end = unique(nums.begin(), nums.end());\\n        \\n        vector<int> ans(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            int x = queries[i][0];\\n            int m = queries[i][1];\\n            int mask = 1 << 30;\\n            \\n            auto range = upper_bound(nums.begin(), end, m);\\n            ans[i] = find(nums.begin(), range, x, 0, mask);\\n            if (ans[i] != -1) ans[i] ^= x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760739,
                "title": "java-trie-striver-approach-faster-than-88-39",
                "content": "class Node{\\n\\n     Node [] links = new Node[2];\\n     Node(){\\n        \\n    }\\n    boolean containsKey(int bit)\\n    {\\n        return (links[bit]!=null);\\n    }\\n    void put(int bit,Node node)\\n    {\\n        links[bit] = node;\\n    }\\n    Node get(int bit)\\n    {\\n        return links[bit];\\n    }\\n}\\nclass Trie{\\n\\n    Node root;\\n    Trie(){\\n        root = new Node();\\n    }\\n    void insert(int nums)\\n    {\\n        Node node = root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (nums>>i) & 1;\\n            if(!node.containsKey(bit))\\n            {\\n                node.put(bit,new Node());\\n            }\\n            node = node.get(bit);\\n        }\\n    }\\n    int getMax(int nums)\\n    {\\n        int Maxnum = 0;\\n        Node node = root;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit = (nums>>i) & 1;\\n            if(node.containsKey(1-bit))\\n            {\\n                Maxnum = Maxnum | (1<<i);\\n                node = node.get(1-bit);\\n            }\\n            else\\n            node = node.get(bit);\\n        }\\n        return Maxnum;\\n    }\\n}\\nclass Solution {\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        int [] ans = new int[queries.length];\\n        int [][] offlineOrders = new int[queries.length][3];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            offlineOrders[i][0] = queries[i][0];\\n            offlineOrders[i][1] = queries[i][1];\\n            offlineOrders[i][2] = i;\\n        }\\n        //sort based on mi(queries[i][1]);\\n        Arrays.sort(offlineOrders,(a,b)->(a[1]-b[1]));\\n        int index = 0;\\n        Trie trie = new Trie();\\n        for (int query[] : offlineOrders) {\\n            while (index < nums.length && nums[index] <= query[1]) {\\n                trie.insert(nums[index]);\\n                index++;\\n            }\\n            int tmpval = -1;\\n            if (index != 0) \\n                tmpval = trie.getMax(query[0]);\\n            ans[query[2]] = tmpval;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Bit Manipulation",
                    "Trie",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int[] maximizeXor(int[] nums, int[][] queries) {\\n        Arrays.sort(nums);\\n        int [] ans = new int[queries.length];\\n        int [][] offlineOrders = new int[queries.length][3];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            offlineOrders[i][0] = queries[i][0];\\n            offlineOrders[i][1] = queries[i][1];\\n            offlineOrders[i][2] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2758470,
                "title": "c-easiest-approach-trie",
                "content": "```\\n//Hope it helps thanks to striver(Raj bhaiya)\\n#include<bits/stdc++.h>\\nstruct Node{\\n    Node *links[2];\\n    \\n    bool contains(int a)\\n    {\\n        return links[a]!=NULL;\\n    }\\n    \\n    Node *get(int a)\\n    {\\n        return links[a];\\n    }\\n    \\n    void put(int a,Node *node)\\n    {\\n        links[a]=node;\\n    }\\n};\\nclass Trie{\\n    Node *root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    \\n    void insert(int a)\\n    {\\n        Node *node=root;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit_val=(a>>i)&1;\\n            if(!node->contains(bit_val))\\n            {\\n                node->put(bit_val,new Node());\\n            }\\n            node=node->get(bit_val);\\n        }\\n        \\n    }\\n    \\n    int max_xor(int a)\\n    {\\n        Node *node=root;\\n        int ma_xor=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit_val=(a>>i)&1;\\n            int inv_bit=!bit_val;\\n            \\n            if(node->contains(inv_bit))\\n            {\\n                ma_xor=ma_xor|(1<<i);\\n                node=node->get(inv_bit);\\n            }\\n            else\\n            {\\n                node=node->get(bit_val);\\n            }\\n        }\\n        \\n        return ma_xor;\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        //Mi Xi index\\n        vector<pair<int,pair<int,int>>>queries_index;\\n        sort(nums.begin(),nums.end());\\n        \\n        int n=queries.size();\\n        \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int Xi=queries[i][0];\\n            int Mi=queries[i][1];\\n            \\n            queries_index.push_back({Mi,{Xi,i}});\\n        }\\n        \\n        sort(queries_index.begin(),queries_index.end());\\n        \\n        int max_ans=INT_MIN;\\n        vector<int>ans(n,0);\\n        int m=nums.size();\\n        int i=0;\\n        Trie t1;\\n        for(int index=0;index<queries.size();index++)\\n        {\\n            int key_point=queries_index[index].first;\\n            int AI=queries_index[index].second.first;\\n            int idx=queries_index[index].second.second;\\n            while(i<m && nums[i]<=key_point)\\n            {\\n                t1.insert(nums[i]);\\n                i++;\\n            }\\n            if(i==0)ans[idx]=-1;\\n            else\\n            ans[idx]=t1.max_xor(AI);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\n//Hope it helps thanks to striver(Raj bhaiya)\\n#include<bits/stdc++.h>\\nstruct Node{\\n    Node *links[2];\\n    \\n    bool contains(int a)\\n    {\\n        return links[a]!=NULL;\\n    }\\n    \\n    Node *get(int a)\\n    {\\n        return links[a];\\n    }\\n    \\n    void put(int a,Node *node)\\n    {\\n        links[a]=node;\\n    }\\n};\\nclass Trie{\\n    Node *root;\\n    public:\\n    Trie()\\n    {\\n        root=new Node();\\n    }\\n    \\n    void insert(int a)\\n    {\\n        Node *node=root;\\n        \\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit_val=(a>>i)&1;\\n            if(!node->contains(bit_val))\\n            {\\n                node->put(bit_val,new Node());\\n            }\\n            node=node->get(bit_val);\\n        }\\n        \\n    }\\n    \\n    int max_xor(int a)\\n    {\\n        Node *node=root;\\n        int ma_xor=0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            int bit_val=(a>>i)&1;\\n            int inv_bit=!bit_val;\\n            \\n            if(node->contains(inv_bit))\\n            {\\n                ma_xor=ma_xor|(1<<i);\\n                node=node->get(inv_bit);\\n            }\\n            else\\n            {\\n                node=node->get(bit_val);\\n            }\\n        }\\n        \\n        return ma_xor;\\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        //Mi Xi index\\n        vector<pair<int,pair<int,int>>>queries_index;\\n        sort(nums.begin(),nums.end());\\n        \\n        int n=queries.size();\\n        \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int Xi=queries[i][0];\\n            int Mi=queries[i][1];\\n            \\n            queries_index.push_back({Mi,{Xi,i}});\\n        }\\n        \\n        sort(queries_index.begin(),queries_index.end());\\n        \\n        int max_ans=INT_MIN;\\n        vector<int>ans(n,0);\\n        int m=nums.size();\\n        int i=0;\\n        Trie t1;\\n        for(int index=0;index<queries.size();index++)\\n        {\\n            int key_point=queries_index[index].first;\\n            int AI=queries_index[index].second.first;\\n            int idx=queries_index[index].second.second;\\n            while(i<m && nums[i]<=key_point)\\n            {\\n                t1.insert(nums[i]);\\n                i++;\\n            }\\n            if(i==0)ans[idx]=-1;\\n            else\\n            ans[idx]=t1.max_xor(AI);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2744646,
                "title": "java-trie",
                "content": "class Solution {\\n    public int[] maximizeXor(int[] nums, int[][] arr) {\\n        Arrays.sort(nums);\\n        ArrayList<ArrayList<Integer>> offline=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            ArrayList<Integer> temp=new ArrayList<>();\\n            temp.add(arr[i][1]);\\n            temp.add(arr[i][0]);\\n            temp.add(i);\\n            offline.add(temp);\\n        }\\n        Collections.sort(offline, new Comparator<ArrayList<Integer>> () {\\n            @Override\\n            public int compare(ArrayList<Integer> a, ArrayList<Integer> b) {\\n                return a.get(0).compareTo(b.get(0));\\n            } \\n        });\\n            Trie t=new Trie();\\n            int n=nums.length;\\n            int ans[]=new int[arr.length];\\n            int ind=0;\\n        for(int i=0;i<arr.length;i++) ans[i]=-1;\\n            for(int i=0;i<arr.length;i++){\\n                int ai=offline.get(i).get(0);\\n                int xi=offline.get(i).get(1);\\n                int qind=offline.get(i).get(2);\\n                while(ind<n && nums[ind]<=offline.get(i).get(0)){\\n                    t.create(nums[ind]);\\n                    ind++;\\n                }\\n                 int queryInd = offline.get(i).get(2); \\n                     if(ind!=0) ans[queryInd]=t.maximum(offline.get(i).get(1));\\n                     else ans[queryInd]=-1; \\n                 }\\n                 return ans; \\n            }\\n         class Node {\\n        Node arr[]=new Node[2];\\n    }\\n    class Trie{\\n        Node root;\\n        Trie(){\\n            root=new Node();\\n        }\\n        void create(int num){\\n            Node node=root;\\n            for(int i=31;i>=0;i--){\\n                int bit=(num>>i)&1;\\n                if(node.arr[bit]==null){\\n                    node.arr[bit]=new Node();\\n                }\\n                node=node.arr[bit];\\n            }\\n        }\\n        int maximum(int num){\\n            Node node=root;\\n            int max=0;\\n            for(int i=31;i>=0;i--){\\n                int bit=(num>>i)&1;\\n                if(node.arr[1-bit]!=null){\\n                    max=max|(1<<i);\\n                     node=node.arr[1-bit];\\n                  \\n                }else{\\n                     node=node.arr[bit];\\n                }\\n                \\n                 \\n            }\\n            return max;\\n        }\\n}\\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "class Solution {\\n    public int[] maximizeXor(int[] nums, int[][] arr) {\\n        Arrays.sort(nums);\\n        ArrayList<ArrayList<Integer>> offline=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            ArrayList<Integer> temp=new ArrayList<>();\\n            temp.add(arr[i][1]);\\n            temp.add(arr[i][0]);\\n            temp.add(i);\\n            offline.add(temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2672147,
                "title": "c-trie",
                "content": "```\\nclass Trie{\\n    Trie * a[2];\\n    int ct;\\n    public:\\n        Trie(){\\n            a[0] = NULL;\\n            a[1] = NULL;\\n            ct = 0; \\n        }\\n        string get32(int a){\\n            string s;\\n            while(a > 0){\\n                s += (a % 2 + \\'0\\');\\n                a /= 2;\\n            }\\n            while(s.size() < 32){\\n                s += \\'0\\';\\n            }\\n            reverse(s.begin(), s.end());\\n            return s;\\n        }\\n        void add_(int a){\\n            string s = get32(a);\\n            Trie *ptr = this;\\n            for(int i = 0; i < 32; i++){\\n                int ind = s[i] - \\'0\\';\\n                if(!ptr -> a[ind]){\\n                    ptr -> a[ind] = new Trie;\\n                }\\n                ptr -> a[ind] -> ct++;\\n                ptr = ptr -> a[ind];\\n            }\\n        }\\n        void delete_(int a){\\n            string s = get32(a);\\n            Trie *ptr = this;\\n            for(int i= 0; i < 32; i++){\\n                int ind = s[i] - \\'0\\';\\n                ptr -> a[ind] -> ct--;\\n                if(ptr -> a[ind] -> ct == 0){\\n                    ptr -> a[ind] = NULL;\\n                    break;\\n                }\\n                ptr = ptr -> a[ind];\\n            }\\n        }\\n        int max_xor(int n){\\n            int ans = 0;\\n            string s = get32(n);\\n            Trie *ptr = this;\\n            for(int i= 0; i < 32; i++){\\n                int ind = (s[i] - \\'0\\');\\n                if(ptr -> a[ind ^ 1]){\\n                    ans += (1 << (31 - i));\\n                    ptr = ptr -> a[ind ^ 1];\\n                }\\n                else {\\n                    ptr = ptr -> a[ind];\\n                }\\n            }\\n            return ans;\\n        }\\n};\\nbool comp(vector<int>&a, vector<int>&b){\\n    return a[1] > b[1];\\n}\\nvoid delete_(Trie &obj, int a, vector<int>&nums){\\n    int n = nums.size();\\n    for(int i = n-1; i >= 0; i--){\\n        if(nums[i] > a){\\n            obj.delete_(nums[i]);\\n            nums.pop_back();\\n            continue;\\n        }\\n        break;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        int n = queries.size();\\n        for(int i = 0; i < n; i++){\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(), queries.end(), comp);\\n        Trie obj;\\n        int m = nums.size();\\n        for(int i = 0; i < m; i++){\\n            obj.add_(nums[i]);\\n        }\\n        vector<int>ans(n);\\n        for(int i = 0; i < n; i++){\\n            delete_(obj, queries[i][1], nums);\\n            if(nums.size() == 0){\\n                ans[queries[i][2]] = -1;\\n            }\\n            else{\\n                int p = obj.max_xor(queries[i][0]);\\n                ans[queries[i][2]] = p;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\n    Trie * a[2];\\n    int ct;\\n    public:\\n        Trie(){\\n            a[0] = NULL;\\n            a[1] = NULL;\\n            ct = 0; \\n        }\\n        string get32(int a){\\n            string s;\\n            while(a > 0){\\n                s += (a % 2 + \\'0\\');\\n                a /= 2;\\n            }\\n            while(s.size() < 32){\\n                s += \\'0\\';\\n            }\\n            reverse(s.begin(), s.end());\\n            return s;\\n        }\\n        void add_(int a){\\n            string s = get32(a);\\n            Trie *ptr = this;\\n            for(int i = 0; i < 32; i++){\\n                int ind = s[i] - \\'0\\';\\n                if(!ptr -> a[ind]){\\n                    ptr -> a[ind] = new Trie;\\n                }\\n                ptr -> a[ind] -> ct++;\\n                ptr = ptr -> a[ind];\\n            }\\n        }\\n        void delete_(int a){\\n            string s = get32(a);\\n            Trie *ptr = this;\\n            for(int i= 0; i < 32; i++){\\n                int ind = s[i] - \\'0\\';\\n                ptr -> a[ind] -> ct--;\\n                if(ptr -> a[ind] -> ct == 0){\\n                    ptr -> a[ind] = NULL;\\n                    break;\\n                }\\n                ptr = ptr -> a[ind];\\n            }\\n        }\\n        int max_xor(int n){\\n            int ans = 0;\\n            string s = get32(n);\\n            Trie *ptr = this;\\n            for(int i= 0; i < 32; i++){\\n                int ind = (s[i] - \\'0\\');\\n                if(ptr -> a[ind ^ 1]){\\n                    ans += (1 << (31 - i));\\n                    ptr = ptr -> a[ind ^ 1];\\n                }\\n                else {\\n                    ptr = ptr -> a[ind];\\n                }\\n            }\\n            return ans;\\n        }\\n};\\nbool comp(vector<int>&a, vector<int>&b){\\n    return a[1] > b[1];\\n}\\nvoid delete_(Trie &obj, int a, vector<int>&nums){\\n    int n = nums.size();\\n    for(int i = n-1; i >= 0; i--){\\n        if(nums[i] > a){\\n            obj.delete_(nums[i]);\\n            nums.pop_back();\\n            continue;\\n        }\\n        break;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        int n = queries.size();\\n        for(int i = 0; i < n; i++){\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(), queries.end(), comp);\\n        Trie obj;\\n        int m = nums.size();\\n        for(int i = 0; i < m; i++){\\n            obj.add_(nums[i]);\\n        }\\n        vector<int>ans(n);\\n        for(int i = 0; i < n; i++){\\n            delete_(obj, queries[i][1], nums);\\n            if(nums.size() == 0){\\n                ans[queries[i][2]] = -1;\\n            }\\n            else{\\n                int p = obj.max_xor(queries[i][0]);\\n                ans[queries[i][2]] = p;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670396,
                "title": "c-trie-optimize-for-msbs",
                "content": "# Intuition\\nLet\\'s disect this problem into two parts:\\n1. Find the best number `nums[j]` such that `nums[j] ^ queries[i][0]` is maximized.\\n2. Look at every `nums[j] <= queries[i][1]`.\\n\\nFor the first part, we iterate over the bits of `xi` from MSB to LSB; for every bit, we find if any of our numbers has this exact bit __inverted__. This will set the bit to `1` after an XOR operation. We can use a prefix tree (trie) where every node has exactly two children: `0` bit and `1` bit.\\n\\nFor the second part, we only need to maintain a set of numbers less than or equal to the current `queries[i][1]`. We can sort both the `nums` and `queries` array in ascending order. For `queries[i][1]`, we will insert all `nums[j]` where `nums[j] <= queries[i][1]`.\\n\\n## Implementation\\n__Space:__ O(32*2) = O(64) => O(1)\\n__Time:__ max(nlog(n), mlog(m)) where n is the size of `nums` and m is the size of `queries`.\\n\\n\\n\\n```c++\\nstruct Node{\\n    Node* C[2]={nullptr,nullptr};\\n    Node(){}\\n};\\n\\n\\nclass Solution {\\npublic:\\n    Node* root;\\n\\t# From the constraint the max value is 1e9 -> at most 31 bits.\\n    const int bits=31;\\n    void add(int num){\\n        Node* node = root;\\n        for(int i=bits;i>=0;--i){\\n            int b=(num>>i)&1;\\n            if(!node->C[b]){\\n                node->C[b]=new Node();\\n            }\\n            node = node->C[b];\\n        }\\n    }\\n    \\n    int search(int num){\\n        Node *node=root;\\n        int ans=0;\\n        for(int i=bits;i>=0;--i){\\n\\t\\t\\t// Current bit\\n            int b=(num>>i)&1;\\n\\t\\t\\t// Invert of the current bit\\n            int rb = b==0?1:0;\\n\\t\\t\\t// Optimize for the MSB.\\n            if(node->C[rb]!=nullptr){\\n                ans |= ((rb)<<i);\\n                node = node->C[rb];\\n            } else if(node->C[b]!=nullptr) {\\n                ans |= (b<<i);\\n                node = node->C[b];\\n            }else{\\n\\t\\t\\t\\t// Handle the case where no answer is found.\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> maximizeXor(vector<int>& A, vector<vector<int>>& Q) {\\n        root = new Node();\\n        for(int i=0;i<Q.size();++i){ Q[i].push_back(i);}\\n        sort(A.begin(),A.end());\\n        sort(Q.begin(),Q.end(),[](const auto&a, const auto& b){return a[1] < b[1];});\\n        \\n        vector<int>ans(Q.size(),-1);\\n\\t\\t\\n        int j=0; // Index of A\\n        for(int i=0;i<Q.size();++i){\\n            while(j<A.size()&&A[j]<=Q[i][1]){\\n                add(A[j++]);\\n            }\\n            int res=search(Q[i][0]);\\n            if(res!=-1){\\n                ans[Q[i][2]] = res^Q[i][0];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Trie"
                ],
                "code": "```c++\\nstruct Node{\\n    Node* C[2]={nullptr,nullptr};\\n    Node(){}\\n};\\n\\n\\nclass Solution {\\npublic:\\n    Node* root;\\n\\t# From the constraint the max value is 1e9 -> at most 31 bits.\\n    const int bits=31;\\n    void add(int num){\\n        Node* node = root;\\n        for(int i=bits;i>=0;--i){\\n            int b=(num>>i)&1;\\n            if(!node->C[b]){\\n                node->C[b]=new Node();\\n            }\\n            node = node->C[b];\\n        }\\n    }\\n    \\n    int search(int num){\\n        Node *node=root;\\n        int ans=0;\\n        for(int i=bits;i>=0;--i){\\n\\t\\t\\t// Current bit\\n            int b=(num>>i)&1;\\n\\t\\t\\t// Invert of the current bit\\n            int rb = b==0?1:0;\\n\\t\\t\\t// Optimize for the MSB.\\n            if(node->C[rb]!=nullptr){\\n                ans |= ((rb)<<i);\\n                node = node->C[rb];\\n            } else if(node->C[b]!=nullptr) {\\n                ans |= (b<<i);\\n                node = node->C[b];\\n            }else{\\n\\t\\t\\t\\t// Handle the case where no answer is found.\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> maximizeXor(vector<int>& A, vector<vector<int>>& Q) {\\n        root = new Node();\\n        for(int i=0;i<Q.size();++i){ Q[i].push_back(i);}\\n        sort(A.begin(),A.end());\\n        sort(Q.begin(),Q.end(),[](const auto&a, const auto& b){return a[1] < b[1];});\\n        \\n        vector<int>ans(Q.size(),-1);\\n\\t\\t\\n        int j=0; // Index of A\\n        for(int i=0;i<Q.size();++i){\\n            while(j<A.size()&&A[j]<=Q[i][1]){\\n                add(A[j++]);\\n            }\\n            int res=search(Q[i][0]);\\n            if(res!=-1){\\n                ans[Q[i][2]] = res^Q[i][0];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1771007,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "Congrats on completing Striver SDE sheet.\nSimilar to [this ](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) question.\nHint:- Save a minValue in each node that denotes the minimum value that can be made using this subtree.\n\n[Complete C++ solution](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) (If you have tried enough)"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Well I just decided to start from the back"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Thanks buddy!"
                    },
                    {
                        "username": "jrengineer",
                        "content": "I use a Trie-based solution with C++ shared_ptr, which is much safer than raw pointer.\\nHowever, I got TLE with or without sort trick.\\n\\nFinally I figure out I beat > 80% after switch back to Trie with raw pointer."
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem solving Maximized after struggling to get it for hours. Even if we refer to a solution, we get to learn a lot."
                    },
                    {
                        "username": "Destravna",
                        "content": "66/67 test cases passed why my code is failing last test case :(\\n```\\nclass TrieNode {\\n\\n    // we don\\'t need isEnd because all the numbers are 32 bit and end at the same position\\npublic:\\n    TrieNode *child[2];\\n    TrieNode() {\\n        for (int i = 0; i < 2; i++)\\n            child[i] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode *root;\\n\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    void insert(int num) {\\n        auto curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!curr->child[bit]) {\\n                curr->child[bit] = new TrieNode();\\n            }\\n            curr = curr->child[bit];\\n        }\\n    }\\n\\n    // now I want to find the maximum value of xor we can have of a number x xored with any number in trie\\n    int findMax(int num) {\\n        auto curr = root;\\n        int maxNum = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (curr->child[!bit]) {\\n                maxNum = maxNum | (1 << i);\\n                curr = curr->child[!bit];\\n            } else if(curr->child[bit])\\n                curr = curr->child[bit];\\n            else return -1;\\n        }\\n        return maxNum == 0 ? -1 : maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ids(queries.size(), 0);\\n        iota(ids.begin(), ids.end(), 0);\\n        sort(ids.begin(), ids.end(), [&](int i1, int i2){\\n            return queries[i1][1] < queries[i2][1];\\n        });\\n        vector<int> res(queries.size(), 0);\\n        int idx = 0;\\n        Trie *t = new Trie();\\n        for(auto x:ids){\\n            int curr = queries[x][1];\\n            while(idx < nums.size() && nums[idx] <= curr){\\n                t->insert(nums[idx++]);\\n            }\\n            res[x] = t->findMax(queries[x][0]);\\n        }\\n        delete t;\\n        return res;   \\n    }\\n};\\n```"
                    },
                    {
                        "username": "rishinith",
                        "content": "Handle the case if there is no element in the nums less than than query.mi. Result is -1 for that query\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Sorting queries and nums and insert accordingly."
                    }
                ]
            },
            {
                "id": 1574738,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "Congrats on completing Striver SDE sheet.\nSimilar to [this ](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) question.\nHint:- Save a minValue in each node that denotes the minimum value that can be made using this subtree.\n\n[Complete C++ solution](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) (If you have tried enough)"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Well I just decided to start from the back"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Thanks buddy!"
                    },
                    {
                        "username": "jrengineer",
                        "content": "I use a Trie-based solution with C++ shared_ptr, which is much safer than raw pointer.\\nHowever, I got TLE with or without sort trick.\\n\\nFinally I figure out I beat > 80% after switch back to Trie with raw pointer."
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem solving Maximized after struggling to get it for hours. Even if we refer to a solution, we get to learn a lot."
                    },
                    {
                        "username": "Destravna",
                        "content": "66/67 test cases passed why my code is failing last test case :(\\n```\\nclass TrieNode {\\n\\n    // we don\\'t need isEnd because all the numbers are 32 bit and end at the same position\\npublic:\\n    TrieNode *child[2];\\n    TrieNode() {\\n        for (int i = 0; i < 2; i++)\\n            child[i] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode *root;\\n\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    void insert(int num) {\\n        auto curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!curr->child[bit]) {\\n                curr->child[bit] = new TrieNode();\\n            }\\n            curr = curr->child[bit];\\n        }\\n    }\\n\\n    // now I want to find the maximum value of xor we can have of a number x xored with any number in trie\\n    int findMax(int num) {\\n        auto curr = root;\\n        int maxNum = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (curr->child[!bit]) {\\n                maxNum = maxNum | (1 << i);\\n                curr = curr->child[!bit];\\n            } else if(curr->child[bit])\\n                curr = curr->child[bit];\\n            else return -1;\\n        }\\n        return maxNum == 0 ? -1 : maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ids(queries.size(), 0);\\n        iota(ids.begin(), ids.end(), 0);\\n        sort(ids.begin(), ids.end(), [&](int i1, int i2){\\n            return queries[i1][1] < queries[i2][1];\\n        });\\n        vector<int> res(queries.size(), 0);\\n        int idx = 0;\\n        Trie *t = new Trie();\\n        for(auto x:ids){\\n            int curr = queries[x][1];\\n            while(idx < nums.size() && nums[idx] <= curr){\\n                t->insert(nums[idx++]);\\n            }\\n            res[x] = t->findMax(queries[x][0]);\\n        }\\n        delete t;\\n        return res;   \\n    }\\n};\\n```"
                    },
                    {
                        "username": "rishinith",
                        "content": "Handle the case if there is no element in the nums less than than query.mi. Result is -1 for that query\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Sorting queries and nums and insert accordingly."
                    }
                ]
            },
            {
                "id": 1975587,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "Congrats on completing Striver SDE sheet.\nSimilar to [this ](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) question.\nHint:- Save a minValue in each node that denotes the minimum value that can be made using this subtree.\n\n[Complete C++ solution](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) (If you have tried enough)"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Well I just decided to start from the back"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Thanks buddy!"
                    },
                    {
                        "username": "jrengineer",
                        "content": "I use a Trie-based solution with C++ shared_ptr, which is much safer than raw pointer.\\nHowever, I got TLE with or without sort trick.\\n\\nFinally I figure out I beat > 80% after switch back to Trie with raw pointer."
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem solving Maximized after struggling to get it for hours. Even if we refer to a solution, we get to learn a lot."
                    },
                    {
                        "username": "Destravna",
                        "content": "66/67 test cases passed why my code is failing last test case :(\\n```\\nclass TrieNode {\\n\\n    // we don\\'t need isEnd because all the numbers are 32 bit and end at the same position\\npublic:\\n    TrieNode *child[2];\\n    TrieNode() {\\n        for (int i = 0; i < 2; i++)\\n            child[i] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode *root;\\n\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    void insert(int num) {\\n        auto curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!curr->child[bit]) {\\n                curr->child[bit] = new TrieNode();\\n            }\\n            curr = curr->child[bit];\\n        }\\n    }\\n\\n    // now I want to find the maximum value of xor we can have of a number x xored with any number in trie\\n    int findMax(int num) {\\n        auto curr = root;\\n        int maxNum = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (curr->child[!bit]) {\\n                maxNum = maxNum | (1 << i);\\n                curr = curr->child[!bit];\\n            } else if(curr->child[bit])\\n                curr = curr->child[bit];\\n            else return -1;\\n        }\\n        return maxNum == 0 ? -1 : maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ids(queries.size(), 0);\\n        iota(ids.begin(), ids.end(), 0);\\n        sort(ids.begin(), ids.end(), [&](int i1, int i2){\\n            return queries[i1][1] < queries[i2][1];\\n        });\\n        vector<int> res(queries.size(), 0);\\n        int idx = 0;\\n        Trie *t = new Trie();\\n        for(auto x:ids){\\n            int curr = queries[x][1];\\n            while(idx < nums.size() && nums[idx] <= curr){\\n                t->insert(nums[idx++]);\\n            }\\n            res[x] = t->findMax(queries[x][0]);\\n        }\\n        delete t;\\n        return res;   \\n    }\\n};\\n```"
                    },
                    {
                        "username": "rishinith",
                        "content": "Handle the case if there is no element in the nums less than than query.mi. Result is -1 for that query\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Sorting queries and nums and insert accordingly."
                    }
                ]
            },
            {
                "id": 1951548,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "Congrats on completing Striver SDE sheet.\nSimilar to [this ](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) question.\nHint:- Save a minValue in each node that denotes the minimum value that can be made using this subtree.\n\n[Complete C++ solution](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) (If you have tried enough)"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Well I just decided to start from the back"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Thanks buddy!"
                    },
                    {
                        "username": "jrengineer",
                        "content": "I use a Trie-based solution with C++ shared_ptr, which is much safer than raw pointer.\\nHowever, I got TLE with or without sort trick.\\n\\nFinally I figure out I beat > 80% after switch back to Trie with raw pointer."
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem solving Maximized after struggling to get it for hours. Even if we refer to a solution, we get to learn a lot."
                    },
                    {
                        "username": "Destravna",
                        "content": "66/67 test cases passed why my code is failing last test case :(\\n```\\nclass TrieNode {\\n\\n    // we don\\'t need isEnd because all the numbers are 32 bit and end at the same position\\npublic:\\n    TrieNode *child[2];\\n    TrieNode() {\\n        for (int i = 0; i < 2; i++)\\n            child[i] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode *root;\\n\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    void insert(int num) {\\n        auto curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!curr->child[bit]) {\\n                curr->child[bit] = new TrieNode();\\n            }\\n            curr = curr->child[bit];\\n        }\\n    }\\n\\n    // now I want to find the maximum value of xor we can have of a number x xored with any number in trie\\n    int findMax(int num) {\\n        auto curr = root;\\n        int maxNum = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (curr->child[!bit]) {\\n                maxNum = maxNum | (1 << i);\\n                curr = curr->child[!bit];\\n            } else if(curr->child[bit])\\n                curr = curr->child[bit];\\n            else return -1;\\n        }\\n        return maxNum == 0 ? -1 : maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ids(queries.size(), 0);\\n        iota(ids.begin(), ids.end(), 0);\\n        sort(ids.begin(), ids.end(), [&](int i1, int i2){\\n            return queries[i1][1] < queries[i2][1];\\n        });\\n        vector<int> res(queries.size(), 0);\\n        int idx = 0;\\n        Trie *t = new Trie();\\n        for(auto x:ids){\\n            int curr = queries[x][1];\\n            while(idx < nums.size() && nums[idx] <= curr){\\n                t->insert(nums[idx++]);\\n            }\\n            res[x] = t->findMax(queries[x][0]);\\n        }\\n        delete t;\\n        return res;   \\n    }\\n};\\n```"
                    },
                    {
                        "username": "rishinith",
                        "content": "Handle the case if there is no element in the nums less than than query.mi. Result is -1 for that query\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Sorting queries and nums and insert accordingly."
                    }
                ]
            },
            {
                "id": 1923513,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "Congrats on completing Striver SDE sheet.\nSimilar to [this ](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) question.\nHint:- Save a minValue in each node that denotes the minimum value that can be made using this subtree.\n\n[Complete C++ solution](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) (If you have tried enough)"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Well I just decided to start from the back"
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Thanks buddy!"
                    },
                    {
                        "username": "jrengineer",
                        "content": "I use a Trie-based solution with C++ shared_ptr, which is much safer than raw pointer.\\nHowever, I got TLE with or without sort trick.\\n\\nFinally I figure out I beat > 80% after switch back to Trie with raw pointer."
                    },
                    {
                        "username": "algoacer",
                        "content": "Problem solving Maximized after struggling to get it for hours. Even if we refer to a solution, we get to learn a lot."
                    },
                    {
                        "username": "Destravna",
                        "content": "66/67 test cases passed why my code is failing last test case :(\\n```\\nclass TrieNode {\\n\\n    // we don\\'t need isEnd because all the numbers are 32 bit and end at the same position\\npublic:\\n    TrieNode *child[2];\\n    TrieNode() {\\n        for (int i = 0; i < 2; i++)\\n            child[i] = nullptr;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode *root;\\n\\npublic:\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    void insert(int num) {\\n        auto curr = root;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (!curr->child[bit]) {\\n                curr->child[bit] = new TrieNode();\\n            }\\n            curr = curr->child[bit];\\n        }\\n    }\\n\\n    // now I want to find the maximum value of xor we can have of a number x xored with any number in trie\\n    int findMax(int num) {\\n        auto curr = root;\\n        int maxNum = 0;\\n        for (int i = 31; i >= 0; i--) {\\n            int bit = (num >> i) & 1;\\n            if (curr->child[!bit]) {\\n                maxNum = maxNum | (1 << i);\\n                curr = curr->child[!bit];\\n            } else if(curr->child[bit])\\n                curr = curr->child[bit];\\n            else return -1;\\n        }\\n        return maxNum == 0 ? -1 : maxNum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ids(queries.size(), 0);\\n        iota(ids.begin(), ids.end(), 0);\\n        sort(ids.begin(), ids.end(), [&](int i1, int i2){\\n            return queries[i1][1] < queries[i2][1];\\n        });\\n        vector<int> res(queries.size(), 0);\\n        int idx = 0;\\n        Trie *t = new Trie();\\n        for(auto x:ids){\\n            int curr = queries[x][1];\\n            while(idx < nums.size() && nums[idx] <= curr){\\n                t->insert(nums[idx++]);\\n            }\\n            res[x] = t->findMax(queries[x][0]);\\n        }\\n        delete t;\\n        return res;   \\n    }\\n};\\n```"
                    },
                    {
                        "username": "rishinith",
                        "content": "Handle the case if there is no element in the nums less than than query.mi. Result is -1 for that query\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Sorting queries and nums and insert accordingly."
                    }
                ]
            }
        ]
    }
]