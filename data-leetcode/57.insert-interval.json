[
    {
        "title": "Insert Interval",
        "question_content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\n&nbsp;\nExample 1:\n\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nExample 2:\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n&nbsp;\nConstraints:\n\n\t0 <= intervals.length <= 104\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 105\n\tintervals is sorted by starti in ascending order.\n\tnewInterval.length == 2\n\t0 <= start <= end <= 105",
        "solutions": [
            {
                "id": 21602,
                "title": "short-and-straight-forward-java-solution",
                "content": "Hi guys!\\n\\nHere's a pretty straight-forward and concise solution below.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new LinkedList<>();\\n        int i = 0;\\n        // add all the intervals ending before newInterval starts\\n        while (i < intervals.size() && intervals.get(i).end < newInterval.start)\\n            result.add(intervals.get(i++));\\n        // merge all overlapping intervals to one considering newInterval\\n        while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {\\n            newInterval = new Interval( // we could mutate newInterval here also\\n                    Math.min(newInterval.start, intervals.get(i).start),\\n                    Math.max(newInterval.end, intervals.get(i).end));\\n            i++;\\n        }\\n        result.add(newInterval); // add the union of intervals we got\\n        // add all the rest\\n        while (i < intervals.size()) result.add(intervals.get(i++)); \\n        return result;\\n    }\\n\\nHope it helps.",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nHere's a pretty straight-forward and concise solution below.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new LinkedList<>();\\n        int i = 0;\\n        // add all the intervals ending before newInterval starts\\n        while (i < intervals.size() && intervals.get(i).end < newInterval.start)\\n            result.add(intervals.get(i++));\\n        // merge all overlapping intervals to one considering newInterval\\n        while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {\\n            newInterval = new Interval( // we could mutate newInterval here also\\n                    Math.min(newInterval.start, intervals.get(i).start),\\n                    Math.max(newInterval.end, intervals.get(i).end));\\n            i++;\\n        }\\n        result.add(newInterval); // add the union of intervals we got\\n        // add all the rest\\n        while (i < intervals.size()) result.add(intervals.get(i++)); \\n        return result;\\n    }\\n\\nHope it helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 21622,
                "title": "7-lines-3-easy-solutions",
                "content": "**Solution 1:** (7 lines, 88 ms)\\n\\nCollect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left = [i for i in intervals if i.end < s]\\n        right = [i for i in intervals if i.start > e]\\n        if left + right != intervals:\\n            s = min(s, intervals[len(left)].start)\\n            e = max(e, intervals[~len(right)].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 2:** (8 lines, 84 ms)\\n\\nSame algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        parts = merge, left, right = [], [], []\\n        for i in intervals:\\n            parts[(i.end < s) - (i.start > e)].append(i)\\n        if merge:\\n            s = min(s, merge[0].start)\\n            e = max(e, merge[-1].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 3:** (11 lines, 80 ms)\\n\\nSame again, but collect and merge while going over the intervals once.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left, right = [], []\\n        for i in intervals:\\n            if i.end < s:\\n                left += i,\\n            elif i.start > e:\\n                right += i,\\n            else:\\n                s = min(s, i.start)\\n                e = max(e, i.end)\\n        return left + [Interval(s, e)] + right",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1:** (7 lines, 88 ms)\\n\\nCollect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left = [i for i in intervals if i.end < s]\\n        right = [i for i in intervals if i.start > e]\\n        if left + right != intervals:\\n            s = min(s, intervals[len(left)].start)\\n            e = max(e, intervals[~len(right)].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 2:** (8 lines, 84 ms)\\n\\nSame algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        parts = merge, left, right = [], [], []\\n        for i in intervals:\\n            parts[(i.end < s) - (i.start > e)].append(i)\\n        if merge:\\n            s = min(s, merge[0].start)\\n            e = max(e, merge[-1].end)\\n        return left + [Interval(s, e)] + right\\n\\n---\\n\\n**Solution 3:** (11 lines, 80 ms)\\n\\nSame again, but collect and merge while going over the intervals once.\\n\\n    def insert(self, intervals, newInterval):\\n        s, e = newInterval.start, newInterval.end\\n        left, right = [], []\\n        for i in intervals:\\n            if i.end < s:\\n                left += i,\\n            elif i.start > e:\\n                right += i,\\n            else:\\n                s = min(s, i.start)\\n                e = max(e, i.end)\\n        return left + [Interval(s, e)] + right",
                "codeTag": "Python3"
            },
            {
                "id": 1327206,
                "title": "99-16-faster-proper-explaination-c-solution-o-n",
                "content": "Here 3 cases will arive:\\n1) ***Non Overlapping intervals before given newInterval*** -> push into the ans vector \\n2) **Overlapping of intervals and newInterval** update new interval \\n   starting point of newInterval will be min of the interval starting point \\n   or starting point of newInterval\\n   Ending point will be the max of interval ending point or newInterval          end point.\\n3) **Non overlapping intervals after the newintervals have been merged** ->    push ito ans vector   \\n   \\n**Time complexity - O(N)** \\n**space complexity - O(1)**\\n\\nAlso, please do not use sorting algo here because we have already provided with sorted list.\\n\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote and comment if have doubt**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21600,
                "title": "short-java-code",
                "content": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<Interval>();\\n        for (Interval i : intervals) {\\n            if (newInterval == null || i.end < newInterval.start)\\n                result.add(i);\\n            else if (i.start > newInterval.end) {\\n                result.add(newInterval);\\n                result.add(i);\\n                newInterval = null;\\n            } else {\\n                newInterval.start = Math.min(newInterval.start, i.start);\\n                newInterval.end = Math.max(newInterval.end, i.end);\\n            }\\n        }\\n        if (newInterval != null)\\n            result.add(newInterval);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<Interval>();\\n        for (Interval i : intervals) {\\n            if (newInterval == null || i.end < newInterval.start)\\n                result.add(i);\\n            else if (i.start > newInterval.end) {\\n                result.add(newInterval);\\n                result.add(i);\\n                newInterval = null;\\n            } else {\\n                newInterval.start = Math.min(newInterval.start, i.start);\\n                newInterval.end = Math.max(newInterval.end, i.end);\\n            }\\n        }\\n        if (newInterval != null)\\n            result.add(newInterval);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21809,
                "title": "python-o-n-and-o-nlgn-solutions",
                "content": "        \\n    \\n    # O(nlgn) time, the same as Merge Intervals \\n    # https://leetcode.com/problems/merge-intervals/\\n    def insert1(self, intervals, newInterval):\\n        intervals.append(newInterval)\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x.start):\\n            if res and res[-1].end >= i.start:\\n                res[-1].end = max(res[-1].end, i.end)\\n            else:\\n                res.append(i)\\n        return res\\n        \\n    # O(n) time, not in-place, make use of the \\n    # property that the intervals were initially sorted \\n    # according to their start times\\n    def insert(self, intervals, newInterval):\\n        res, n = [], newInterval\\n        for index, i in enumerate(intervals):\\n            if i.end < n.start:\\n                res.append(i)\\n            elif n.end < i.start:\\n                res.append(n)\\n                return res+intervals[index:]  # can return earlier\\n            else:  # overlap case\\n                n.start = min(n.start, i.start)\\n                n.end = max(n.end, i.end)\\n        res.append(n)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    \\n    # O(nlgn) time, the same as Merge Intervals \\n    # https://leetcode.com/problems/merge-intervals/\\n    def insert1(self, intervals, newInterval):\\n        intervals.append(newInterval)\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x.start):\\n            if res and res[-1].end >= i.start:\\n                res[-1].end = max(res[-1].end, i.end)\\n            else:\\n                res.append(i)\\n        return res\\n        \\n    # O(n) time, not in-place, make use of the \\n    # property that the intervals were initially sorted \\n    # according to their start times\\n    def insert(self, intervals, newInterval):\\n        res, n = [], newInterval\\n        for index, i in enumerate(intervals):\\n            if i.end < n.start:\\n                res.append(i)\\n            elif n.end < i.start:\\n                res.append(n)\\n                return res+intervals[index:]  # can return earlier\\n            else:  # overlap case\\n                n.start = min(n.start, i.start)\\n                n.end = max(n.end, i.end)\\n        res.append(n)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 959756,
                "title": "java-1ms-easy-line-by-line-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Iterate through all slots\\n        for(int[] slot : intervals)\\n        {\\n            \\n            // if newInterval before slot insert newInterval & update slot as new interval\\n            if(newInterval[1] < slot[0])\\n            {\\n                result.add(newInterval);\\n                newInterval = slot;\\n            } \\n            \\n            // if slot is lesser than new Interval insert slot\\n            else if(slot[1] < newInterval[0])\\n            {\\n                result.add(slot);\\n            } \\n            \\n            // if above conditions fail its an overlap since possibility of new interval existing in left & right of slot is checked\\n            // update lowest of start & highest of end & not insert\\n            else {\\n                newInterval[0] = Math.min(newInterval[0],slot[0]);\\n                newInterval[1] = Math.max(newInterval[1],slot[1]);\\n            }\\n        }\\n        \\n        // insert the last newInterval\\n        result.add(newInterval);\\n        \\n        // convert to int[][] array\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Iterate through all slots\\n        for(int[] slot : intervals)\\n        {\\n            \\n            // if newInterval before slot insert newInterval & update slot as new interval\\n            if(newInterval[1] < slot[0])\\n            {\\n                result.add(newInterval);\\n                newInterval = slot;\\n            } \\n            \\n            // if slot is lesser than new Interval insert slot\\n            else if(slot[1] < newInterval[0])\\n            {\\n                result.add(slot);\\n            } \\n            \\n            // if above conditions fail its an overlap since possibility of new interval existing in left & right of slot is checked\\n            // update lowest of start & highest of end & not insert\\n            else {\\n                newInterval[0] = Math.min(newInterval[0],slot[0]);\\n                newInterval[1] = Math.max(newInterval[1],slot[1]);\\n            }\\n        }\\n        \\n        // insert the last newInterval\\n        result.add(newInterval);\\n        \\n        // convert to int[][] array\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21599,
                "title": "elegant-c-stl-solution-using-equal-range-to-find-overlapped-intervals",
                "content": "    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            auto compare = [] (const Interval &intv1, const Interval &intv2)\\n                              { return intv1.end < intv2.start; };\\n            auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare);\\n            auto itr1 = range.first, itr2 = range.second;\\n            if (itr1 == itr2) {\\n                intervals.insert(itr1, newInterval);\\n            } else {\\n                itr2--;\\n                itr2->start = min(newInterval.start, itr1->start);\\n                itr2->end = max(newInterval.end, itr2->end);\\n                intervals.erase(itr1, itr2);\\n            }\\n            return intervals;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            auto compare = [] (const Interval &intv1, const Interval &intv2)\\n                              { return intv1.end < intv2.start; }",
                "codeTag": "Java"
            },
            {
                "id": 477856,
                "title": "beat-99-consice-java-solution",
                "content": "```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n        \\n        for (int i = 0; i < intervals.length; i ++) {\\n\\t\\t\\t/*1. No overlap and toAdd appears before current interval, add toAdd to result.*/\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n            /*2. Has overlap, update the toAdd to the merged interval.*/\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n\\t\\t\\t/*3. No overlap and toAdd appears after current interval, add current interval to result.*/\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n        \\n        for (int i = 0; i < intervals.length; i ++) {\\n\\t\\t\\t/*1. No overlap and toAdd appears before current interval, add toAdd to result.*/\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n            /*2. Has overlap, update the toAdd to the merged interval.*/\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n\\t\\t\\t/*3. No overlap and toAdd appears after current interval, add current interval to result.*/\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844494,
                "title": "python-o-n-solution-explained",
                "content": "I am not sure, why this problem is marked as hard, because we do not use any smart ideas to solve it: just do what is asked: traverse our intervals and merge them. Let us consider the case: `intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]` and go through our code:\\n\\n1. Interval `[1,2]` is before `[4,8]`, that is `y < I[0]`, so we just add it to our `res`.\\n2. Interval `[3,5]` is not before `[4,8]` but not after also, so it is the third case and we need to update `I`: `I = [3,8]` now.\\n3. Interval `[6,7]`: the same logic, update `I = [3,8]` now (it did not change though)\\n4. Interval `[8,10]`: still condition number `3`, so `I = [3,10]` now.\\n5. Interval `[12,16]`: it is after our `I`, so this is condition number `2` and we `break` from our loop: `i = 3` now.\\n6. Outside loop we combine `res = [1,2]`, `I = [3,10]` and `intervals[4:] = [12,16]`.\\n\\nWhy we use `i -= 1` inside our loop, before `break`? It can happen, that we did not visit this part and it means, that our suffix `intervals[i+1:]` should be empty.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(n)` as well and additional space complexity (if we do not count our output) is `O(1)`.\\n\\n**Note**: that intstead of traversing our intervals with linear search, we can use binary search, however it will not reduce the overall complexity of algorithm, our result will have in average `O(n)` elements.\\n\\n```\\nclass Solution:\\n    def insert(self, intervals, I):\\n        res, i = [], -1\\n        for i, (x, y) in enumerate(intervals):\\n            if y < I[0]:\\n                res.append([x, y])\\n            elif I[1] < x:\\n                i -= 1\\n                break\\n            else:\\n                I[0] = min(I[0], x)\\n                I[1] = max(I[1], y)\\n                \\n        return res + [I] + intervals[i+1:]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, I):\\n        res, i = [], -1\\n        for i, (x, y) in enumerate(intervals):\\n            if y < I[0]:\\n                res.append([x, y])\\n            elif I[1] < x:\\n                i -= 1\\n                break\\n            else:\\n                I[0] = min(I[0], x)\\n                I[1] = max(I[1], y)\\n                \\n        return res + [I] + intervals[i+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844523,
                "title": "c-super-clean-clear-short-simple-solution-o-n-time-o-1-space",
                "content": "the main idea is that when iterating over the intervals there are three cases: \\n1. the new interval is in the range of the other interval\\n2. the new interval\\'s range is before the other\\n3. the new interval is after the range of other interval\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        vector<vector<int>> result;\\n        \\n        for (size_t i = 0; i < intervals.size(); i++)\\n        {\\n\\t\\t\\t//  the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if (intervals[i][1] < newInterval[0])\\n            {\\n                result.push_back(intervals[i]);\\n            }\\n\\t\\t\\t// the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            else if (intervals[i][0] > newInterval[1])\\n            {\\n                result.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\t\\t\\t// the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1])\\n            {\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n\\n            }\\n        }\\n        \\n        result.push_back(newInterval); \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        vector<vector<int>> result;\\n        \\n        for (size_t i = 0; i < intervals.size(); i++)\\n        {\\n\\t\\t\\t//  the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if (intervals[i][1] < newInterval[0])\\n            {\\n                result.push_back(intervals[i]);\\n            }\\n\\t\\t\\t// the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            else if (intervals[i][0] > newInterval[1])\\n            {\\n                result.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\t\\t\\t// the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1])\\n            {\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n\\n            }\\n        }\\n        \\n        result.push_back(newInterval); \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844549,
                "title": "python-super-short-simple-clean-solution-99-faster",
                "content": "the main idea is that when iterating over the intervals there are three cases:\\n\\n1. the new interval is in the range of the other interval\\n2. the new interval\\'s range is before the other\\n3. the new interval is after the range of other interval\\n\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        \\n        for interval in intervals:\\n\\t\\t\\t# the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if interval[1] < newInterval[0]:\\n                result.append(interval)\\n            # the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            elif interval[0] > newInterval[1]:\\n                result.append(newInterval)\\n                newInterval = interval\\n            # the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            elif interval[1] >= newInterval[0] or interval[0] <= newInterval[1]:\\n                newInterval[0] = min(interval[0], newInterval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n\\n        \\n        result.append(newInterval); \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        \\n        for interval in intervals:\\n\\t\\t\\t# the new interval is after the range of other interval, so we can leave the current interval baecause the new one does not overlap with it\\n            if interval[1] < newInterval[0]:\\n                result.append(interval)\\n            # the new interval\\'s range is before the other, so we can add the new interval and update it to the current one\\n            elif interval[0] > newInterval[1]:\\n                result.append(newInterval)\\n                newInterval = interval\\n            # the new interval is in the range of the other interval, we have an overlap, so we must choose the min for start and max for end of interval \\n            elif interval[1] >= newInterval[0] or interval[0] <= newInterval[1]:\\n                newInterval[0] = min(interval[0], newInterval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n\\n        \\n        result.append(newInterval); \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556269,
                "title": "simple-concise-js-solution-w-comments",
                "content": "use ES6 destructuring assignment to make code much more concise and readable.\\n\\n```\\n// O(n), O(n)\\nvar insert = function (intervals, newInterval) {\\n  let [start, end] = newInterval;\\n  let left = [];\\n  let right = [];\\n  \\n  for (const interval of intervals) {\\n    const [first, last] = interval;\\n\\t\\n\\t// current interval is smaller than newInterval\\n    if (last < start) left.push(interval);\\n\\t\\n\\t// current interval is larger than newInterval\\n    else if (first > end) right.push(interval);\\n\\t\\n\\t// there is a overlap\\n    else {\\n      start = Math.min(start, first);\\n      end = Math.max(end, last);\\n    }\\n  }\\n  \\n  return [...left, [start, end], ...right]; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n), O(n)\\nvar insert = function (intervals, newInterval) {\\n  let [start, end] = newInterval;\\n  let left = [];\\n  let right = [];\\n  \\n  for (const interval of intervals) {\\n    const [first, last] = interval;\\n\\t\\n\\t// current interval is smaller than newInterval\\n    if (last < start) left.push(interval);\\n\\t\\n\\t// current interval is larger than newInterval\\n    else if (first > end) right.push(interval);\\n\\t\\n\\t// there is a overlap\\n    else {\\n      start = Math.min(start, first);\\n      end = Math.max(end, last);\\n    }\\n  }\\n  \\n  return [...left, [start, end], ...right]; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844394,
                "title": "python-js-go-c-o-n-by-boundary-checking-w-comment",
                "content": "Python O( n ) by boundary checking\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        \\n        # Constant to help us access start point and end point of interval\\n        START, END = 0, 1\\n        \\n        s, e = newInterval[START], newInterval[END]\\n        \\n        left, right = [], []\\n        \\n        for cur_interval in intervals:\\n            \\n            if cur_interval[END] < s:\\n                # current interval is on the left-hand side of newInterval\\n                left += [ cur_interval ]\\n                \\n            elif cur_interval[START] > e:\\n                # current interval is on the right-hand side of newInterval\\n                right += [ cur_interval ]\\n                \\n            else:\\n                # current interval has overlap with newInterval\\n                # merge and update boundary\\n                s = min(s, cur_interval[START])\\n                e = max(e, cur_interval[END])\\n                \\n        return left + [ [s, e] ] + right    \\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar insert = function(intervals, newInterval) {\\n    \\n    const [START, END] = [0, 1];\\n    \\n    // start point as well as end point of new interval\\n    let [s, e] = [ newInterval[START], newInterval[END] ];\\n    \\n    // left: \\u3000record of intervals on left hand side\\n    // right:\\u3000record of intervals on right hand side\\n    let [left, right] = [ [], [] ];\\n    \\n    for( let curInterval of intervals){\\n        \\n        if( curInterval[END] < s ){\\n            \\n            // current interval is on the left hand side of newInterval\\n            left.push( curInterval);\\n            \\n        }else if( curInterval[START] > e ){\\n            \\n            // current interval is on the right hand side of newInterval\\n            right.push( curInterval );\\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = Math.min( s, curInterval[START] );\\n            e = Math.max( e, curInterval[END] );\\n            \\n        }\\n        \\n    }\\n    \\n    let result = left.concat( [ [s, e] ]).concat(right);\\n    return result;\\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n\\n```\\n// native Go doesn\\'t have built-in interger min/max library function\\n// we have to make it manually\\n\\nfunc max(x, y int) int{\\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int{\\n    if x <= y{\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n// ---------------------------------\\n\\n\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    // Constant to help us access start point and end point of interval\\n    const START, END = 0, 1\\n    \\n    s := newInterval[START]\\n    e := newInterval[END]\\n    \\n    left := make( [][]int, 0)\\n    right := make( [][]int, 0)\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if curInterval[END] < s{\\n            \\n            // current interval is on the left hand side of newInterval\\n            left = append(left, curInterval)\\n            \\n        }else if curInterval[START] > e{\\n            \\n            // current interval is on the right hand side of newInterval\\n            right = append(right, curInterval)\\n            \\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = min( s, curInterval[START] )\\n            e = max( e, curInterval[END] )\\n            \\n        }\\n    }\\n    \\n    result := make( [][]int, 0)\\n    result = append(result, left...)\\n    result = append(result, []int{s, e} )\\n    result = append(result, right...)\\n    \\n    return result\\n    \\n}\\n```\\n\\n---\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        // Constant to help us access start point and end point of interval\\n        const int START=0, END=1;\\n        \\n        int s=newInterval[START], e=newInterval[END];\\n        \\n        vector< vector<int> > left, right;\\n        \\n        for( auto& curInterval : intervals ) {\\n            \\n            if (curInterval[END] < s){\\n                \\n                // current interval is on the left hand side of newInterval\\n                left.push_back( curInterval );\\n                \\n            }else if( curInterval[START] > e ){\\n                \\n                // current interval is on the right hand side of newInterval\\n                right.push_back( curInterval );\\n            \\n            }else{\\n                // current interval has overlap with newInterval\\n                // merge and update boundary\\n                s = min(s, curInterval[START] );\\n                e = max(e, curInterval[END] );\\n            }\\n        }\\n        \\n        result.insert( result.end(), left.begin(), left.end() );\\n        result.push_back( {s, e} );\\n        result.insert( result.end(), right.begin(), right.end() );\\n        \\n        return result;\\n        \\n        \\n    }\\nprivate:\\n    vector< vector<int> > result;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        \\n        # Constant to help us access start point and end point of interval\\n        START, END = 0, 1\\n        \\n        s, e = newInterval[START], newInterval[END]\\n        \\n        left, right = [], []\\n        \\n        for cur_interval in intervals:\\n            \\n            if cur_interval[END] < s:\\n                # current interval is on the left-hand side of newInterval\\n                left += [ cur_interval ]\\n                \\n            elif cur_interval[START] > e:\\n                # current interval is on the right-hand side of newInterval\\n                right += [ cur_interval ]\\n                \\n            else:\\n                # current interval has overlap with newInterval\\n                # merge and update boundary\\n                s = min(s, cur_interval[START])\\n                e = max(e, cur_interval[END])\\n                \\n        return left + [ [s, e] ] + right    \\n```\n```\\nvar insert = function(intervals, newInterval) {\\n    \\n    const [START, END] = [0, 1];\\n    \\n    // start point as well as end point of new interval\\n    let [s, e] = [ newInterval[START], newInterval[END] ];\\n    \\n    // left: \\u3000record of intervals on left hand side\\n    // right:\\u3000record of intervals on right hand side\\n    let [left, right] = [ [], [] ];\\n    \\n    for( let curInterval of intervals){\\n        \\n        if( curInterval[END] < s ){\\n            \\n            // current interval is on the left hand side of newInterval\\n            left.push( curInterval);\\n            \\n        }else if( curInterval[START] > e ){\\n            \\n            // current interval is on the right hand side of newInterval\\n            right.push( curInterval );\\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = Math.min( s, curInterval[START] );\\n            e = Math.max( e, curInterval[END] );\\n            \\n        }\\n        \\n    }\\n    \\n    let result = left.concat( [ [s, e] ]).concat(right);\\n    return result;\\n    \\n};\\n```\n```\\n// native Go doesn\\'t have built-in interger min/max library function\\n// we have to make it manually\\n\\nfunc max(x, y int) int{\\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\nfunc min(x, y int) int{\\n    if x <= y{\\n        return x\\n    }else{\\n        return y\\n    }\\n}\\n\\n// ---------------------------------\\n\\n\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    // Constant to help us access start point and end point of interval\\n    const START, END = 0, 1\\n    \\n    s := newInterval[START]\\n    e := newInterval[END]\\n    \\n    left := make( [][]int, 0)\\n    right := make( [][]int, 0)\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if curInterval[END] < s{\\n            \\n            // current interval is on the left hand side of newInterval\\n            left = append(left, curInterval)\\n            \\n        }else if curInterval[START] > e{\\n            \\n            // current interval is on the right hand side of newInterval\\n            right = append(right, curInterval)\\n            \\n        }else{\\n            \\n            // current interval has overlap with newInterval\\n            // merge and update boundary\\n            s = min( s, curInterval[START] )\\n            e = max( e, curInterval[END] )\\n            \\n        }\\n    }\\n    \\n    result := make( [][]int, 0)\\n    result = append(result, left...)\\n    result = append(result, []int{s, e} )\\n    result = append(result, right...)\\n    \\n    return result\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        // Constant to help us access start point and end point of interval\\n        const int START=0, END=1;\\n        \\n        int s=newInterval[START], e=newInterval[END];\\n        \\n        vector< vector<int> > left, right;\\n        \\n        for( auto& curInterval : intervals ) {\\n            \\n            if (curInterval[END] < s){\\n                \\n                // current interval is on the left hand side of newInterval\\n                left.push_back( curInterval );\\n                \\n            }else if( curInterval[START] > e ){\\n                \\n                // current interval is on the right hand side of newInterval\\n                right.push_back( curInterval );\\n            \\n            }else{\\n                // current interval has overlap with newInterval\\n                // merge and update boundary\\n                s = min(s, curInterval[START] );\\n                e = max(e, curInterval[END] );\\n            }\\n        }\\n        \\n        result.insert( result.end(), left.begin(), left.end() );\\n        result.push_back( {s, e} );\\n        result.insert( result.end(), right.begin(), right.end() );\\n        \\n        return result;\\n        \\n        \\n    }\\nprivate:\\n    vector< vector<int> > result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955134,
                "title": "java-solution-with-explanation-and-comments",
                "content": "# Approach and Explanation\\n<!-- Describe your approach to solving the problem. -->\\n1. This code defines a class Solution that contains a method insert which takes in two parameters: an array of intervals represented by a 2D array, and a new interval represented by a 1D array. The method returns a new 2D array containing the merged intervals.\\n\\n2. The approach of this code is to add the intervals that come before the new interval to the answer arraylist, then check if the new interval should be merged with the last interval in the answer arraylist, and finally, add the remaining intervals from the input array to the answer arraylist.\\n\\n3. The code first initializes an empty ArrayList called ans. The variable idx is initialized to 0, and the while loop iterates through the input intervals array. The loop compares the starting value of the current interval with the starting value of the new interval, and if the current interval\\'s starting value is less than the new interval\\'s starting value, it is added to the ans arraylist. If the starting value of the current interval is greater than or equal to the new interval\\'s starting value, the loop breaks. This ensures that the intervals in the ans arraylist will be in the same order as they were in the input array, but with the new interval inserted in the correct position.\\n\\n4. Next, the code checks if the ans arraylist is empty or if the new interval\\'s starting value is greater than the last interval\\'s ending value in the ans arraylist. If either of these conditions is true, the new interval is added to the ans arraylist. Otherwise, the last interval in the ans arraylist is merged with the new interval by updating the last interval\\'s ending value to be the maximum of the last interval\\'s ending value and the new interval\\'s ending value.\\n\\n5. Finally, the while loop iterates through the remaining intervals in the input array. The loop compares the ending value of the last interval in the ans arraylist with the starting value of the current interval. If the last interval\\'s ending value is greater than or equal to the current interval\\'s starting value, it means the two intervals overlap and should be merged. The last interval\\'s ending value is updated to be the maximum of the last interval\\'s ending value and the current interval\\'s ending value. If the last interval\\'s ending value is less than the current interval\\'s starting value, it means the two intervals do not overlap and the current interval is added to the ans arraylist.\\n\\n6. After the while loop, the ans arraylist is converted to a 2D array and returned as the final output.\\n```\\n//TC = O(n)\\n//Sc = O(n)\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {   \\n       // Initialize an ArrayList to hold the merged intervals\\n        ArrayList<int[]> ans = new ArrayList<>();\\n        // Initialize a variable to track our position in the input intervals array\\n        int idx = 0;\\n        // Loop through the input intervals\\n        while(idx < intervals.length){\\n            // If the current interval starts before the new interval, add it to the answer list\\n            if(intervals[idx][0] < newInterval[0]){\\n                ans.add(intervals[idx]);\\n                idx++;\\n            // If the current interval starts after or at the same time as the new interval, exit the loop\\n            }else{\\n                break;\\n            }\\n        }\\n        // If the answer list is empty or the last interval in the answer list ends before the new interval starts\\n        // add the new interval to the answer list\\n        if(ans.size() == 0 || (newInterval[0] > ans.get(ans.size()-1)[1])){\\n            ans.add(newInterval);\\n        // If the last interval in the answer list overlaps with the new interval, merge them by updating the end time of the last interval\\n        }else{\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            lastInterval[1] = Math.max(lastInterval[1],newInterval[1]);\\n        }\\n        // Loop through the remaining intervals in the input array\\n        while(idx < intervals.length){\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            // If the last interval in the answer list overlaps with the current interval, merge them by updating the end time of the last interval\\n            if(lastInterval[1] >= intervals[idx][0]){\\n                lastInterval[1] = Math.max(lastInterval[1], intervals[idx][1]);\\n            }else{\\n                // If the last interval does not overlap with the current interval, add it to the answer list\\n                ans.add(intervals[idx]);\\n            }\\n            idx++;\\n        }\\n        // Convert the ArrayList to a 2D int array and return it\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//TC = O(n)\\n//Sc = O(n)\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {   \\n       // Initialize an ArrayList to hold the merged intervals\\n        ArrayList<int[]> ans = new ArrayList<>();\\n        // Initialize a variable to track our position in the input intervals array\\n        int idx = 0;\\n        // Loop through the input intervals\\n        while(idx < intervals.length){\\n            // If the current interval starts before the new interval, add it to the answer list\\n            if(intervals[idx][0] < newInterval[0]){\\n                ans.add(intervals[idx]);\\n                idx++;\\n            // If the current interval starts after or at the same time as the new interval, exit the loop\\n            }else{\\n                break;\\n            }\\n        }\\n        // If the answer list is empty or the last interval in the answer list ends before the new interval starts\\n        // add the new interval to the answer list\\n        if(ans.size() == 0 || (newInterval[0] > ans.get(ans.size()-1)[1])){\\n            ans.add(newInterval);\\n        // If the last interval in the answer list overlaps with the new interval, merge them by updating the end time of the last interval\\n        }else{\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            lastInterval[1] = Math.max(lastInterval[1],newInterval[1]);\\n        }\\n        // Loop through the remaining intervals in the input array\\n        while(idx < intervals.length){\\n            int[] lastInterval = ans.get(ans.size()-1);\\n            // If the last interval in the answer list overlaps with the current interval, merge them by updating the end time of the last interval\\n            if(lastInterval[1] >= intervals[idx][0]){\\n                lastInterval[1] = Math.max(lastInterval[1], intervals[idx][1]);\\n            }else{\\n                // If the last interval does not overlap with the current interval, add it to the answer list\\n                ans.add(intervals[idx]);\\n            }\\n            idx++;\\n        }\\n        // Convert the ArrayList to a 2D int array and return it\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21659,
                "title": "my-binary-search-approach-implementation-2ms",
                "content": "I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval's start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval's end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don't need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you!\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<>();\\n        if (intervals == null || newInterval == null) return result;\\n        int iStart = findStartPos(intervals, newInterval.start);\\n        int iEnd = findEndPos(intervals, newInterval.end);\\n        if (iStart > 0 && intervals.get(iStart - 1).end >= newInterval.start) iStart--;\\n        if (iEnd == intervals.size() || intervals.get(iEnd).start > newInterval.end) iEnd--;\\n        \\n        //If not in the corner cases, this condition should apply.\\n        if (iStart <= iEnd) {\\n            newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end));\\n        }\\n\\n        int i = 0;\\n        while (i < iStart) result.add(intervals.get(i++));\\n        result.add(newInterval);\\n        i = iEnd + 1;\\n        while (i < intervals.size()) result.add(intervals.get(i++));\\n        return result;\\n    }\\n    \\n    private int findStartPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).start == value) return m;\\n            else if (intervals.get(m).start < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int findEndPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).end == value) return m;\\n            else if (intervals.get(m).end < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval's start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval's end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don't need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you!\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        List<Interval> result = new ArrayList<>();\\n        if (intervals == null || newInterval == null) return result;\\n        int iStart = findStartPos(intervals, newInterval.start);\\n        int iEnd = findEndPos(intervals, newInterval.end);\\n        if (iStart > 0 && intervals.get(iStart - 1).end >= newInterval.start) iStart--;\\n        if (iEnd == intervals.size() || intervals.get(iEnd).start > newInterval.end) iEnd--;\\n        \\n        //If not in the corner cases, this condition should apply.\\n        if (iStart <= iEnd) {\\n            newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end));\\n        }\\n\\n        int i = 0;\\n        while (i < iStart) result.add(intervals.get(i++));\\n        result.add(newInterval);\\n        i = iEnd + 1;\\n        while (i < intervals.size()) result.add(intervals.get(i++));\\n        return result;\\n    }\\n    \\n    private int findStartPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).start == value) return m;\\n            else if (intervals.get(m).start < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }\\n    \\n    private int findEndPos(List<Interval> intervals, int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int m = (l + r) >> 1;\\n            if (intervals.get(m).end == value) return m;\\n            else if (intervals.get(m).end < value) l = m + 1;\\n            else r = m - 1;\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3056665,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=nPwyAn_2nT8&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=16) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/QmhQJ3Du/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=nPwyAn_2nT8&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=16) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/QmhQJ3Du/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 21753,
                "title": "o-n-python-solution",
                "content": "    class Solution:\\n        # @param intervals, a list of Intervals\\n        # @param newInterval, a Interval\\n        # @return a list of Interval\\n        def insert(self, intervals, newInterval):\\n            start = newInterval.start\\n            end = newInterval.end\\n            result = []\\n            i = 0\\n            while i < len(intervals):\\n                if start <= intervals[i].end:\\n                    if end < intervals[i].start:\\n                        break\\n                    start = min(start, intervals[i].start)\\n                    end = max(end, intervals[i].end)\\n                else:\\n                    result.append(intervals[i])\\n                i += 1\\n            result.append(Interval(start, end))\\n            result += intervals[i:]\\n            return result",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param intervals, a list of Intervals\\n        # @param newInterval, a Interval\\n        # @return a list of Interval\\n        def insert(self, intervals, newInterval):\\n            start = newInterval.start\\n            end = newInterval.end\\n            result = []\\n            i = 0\\n            while i < len(intervals):\\n                if start <= intervals[i].end:\\n                    if end < intervals[i].start:\\n                        break\\n                    start = min(start, intervals[i].start)\\n                    end = max(end, intervals[i].end)\\n                else:\\n                    result.append(intervals[i])\\n                i += 1\\n            result.append(Interval(start, end))\\n            result += intervals[i:]\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 3056559,
                "title": "super-easy-explanation-c-o-n-simple-solution",
                "content": "# **Consider \\uD83D\\uDC4D**\\n```\\n                    Please Upvote If You Find It Helpful.\\n```\\n# Approach\\nThere are 3 cases:\\n1. **Non overlapping intervals before given new interval** push into the res vector.\\n2. In this case check for **overlapping intervals and new interval** and merge then as\\n    Starting point if new interval will be minimun of starting point of intervals or new interval(given)\\n    Ending point of new interval will be the max of ending point of interval or new interval(given)\\n3. **Non overlapping intervals after the new interval** is merged is pushed into the res vector\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```\\n                                 Give a \\uD83D\\uDC4D\\n```\\nLet\\'s connect on [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful.\\n```\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        //case 1: no overlapping case before the merge intervals\\n\\t\\t//compare ending point of intervals to starting point of newInterval\\n        while(i < n && intervals[i][1] < newInterval[0]){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }                           \\n\\t\\t//case 2: overlapping case and merging of intervals\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        // case 3: no overlapping of intervals after newinterval being merged\\n        while(i < n){\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\n                                 Give a \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056954,
                "title": "c-java-python-short-crisp-approach",
                "content": "**Approach:**\\n* The approach used is to `first` iterate through the given intervals, and keeping track of the index of the interval where the new `interval` should be inserted such that the intervals remain `sorted`. Then it will `merge` any overlapping intervals with the new interval and update its `start` and `end` times. `Finally`, it will insert the new interval into the correct position in the intervals and `return` the modified intervals.\\n* The `key` idea behind this approach is to maintain the `sorted` order of the intervals, and to `merge` any overlapping intervals with the new interval. \\n* By iterating through the intervals and keeping track of the index where the new interval should be `inserted`, we can ensure that the intervals `remain` sorted, and by merging any `overlapping` intervals with the new interval, we can ensure that the final `output` has no `overlapping` intervals.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> res;\\n        int i = 0, n = intervals.size();\\n        while (i < n && intervals[i][1] < newInterval[0]) res.push_back(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = {min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])}, i++;\\n        res.push_back(newInterval);\\n        while (i < n) res.push_back(intervals[i++]);\\n        return res;\\n    }\\n};\\n```\\n**Java:**\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, n = intervals.length;\\n        while (i < n && intervals[i][1] < newInterval[0]) res.add(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = new int[] {Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])}, i++;\\n        res.add(newInterval);\\n        while (i < n) res.add(intervals[i++]);\\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}\\n```\\n**Python:**\\n\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        n = len(intervals)\\n        while i < n and intervals[i][1] < newInterval[0]:\\n            res.append(intervals[i])\\n            i += 1\\n        while i < n and intervals[i][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        res.append(newInterval)\\n        while i < n:\\n            res.append(intervals[i])\\n            i += 1\\n        return res\\n```\\n\\n----\\nThe **Time complexity** is **O(n)** \\nThe **Space complexity** is **O(n)** .\\n\\n----\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> res;\\n        int i = 0, n = intervals.size();\\n        while (i < n && intervals[i][1] < newInterval[0]) res.push_back(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = {min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])}, i++;\\n        res.push_back(newInterval);\\n        while (i < n) res.push_back(intervals[i++]);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, n = intervals.length;\\n        while (i < n && intervals[i][1] < newInterval[0]) res.add(intervals[i++]);\\n        while (i < n && intervals[i][0] <= newInterval[1]) newInterval = new int[] {Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])}, i++;\\n        res.add(newInterval);\\n        while (i < n) res.add(intervals[i++]);\\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        n = len(intervals)\\n        while i < n and intervals[i][1] < newInterval[0]:\\n            res.append(intervals[i])\\n            i += 1\\n        while i < n and intervals[i][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        res.append(newInterval)\\n        while i < n:\\n            res.append(intervals[i])\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21632,
                "title": "very-short-and-easy-to-understand-c-solution",
                "content": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        vector<Interval> ret;\\n        auto it = intervals.begin();\\n        for(; it!=intervals.end(); ++it){\\n\\t\\t\\tif(newInterval.end < (*it).start) //all intervals after will not overlap with the newInterval\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\telse if(newInterval.start > (*it).end) //*it will not overlap with the newInterval\\n\\t\\t\\t\\tret.push_back(*it); \\n            else{ //update newInterval bacause *it overlap with the newInterval\\n                newInterval.start = min(newInterval.start, (*it).start);\\n                newInterval.end = max(newInterval.end, (*it).end);\\n            }\\t\\n        }\\n        // don't forget the rest of the intervals and the newInterval\\n\\t\\tret.push_back(newInterval);\\n\\t\\tfor(; it!=intervals.end(); ++it)\\n\\t\\t\\tret.push_back(*it);\\n\\t\\treturn ret;\\n    }\\nMy question is why this code need 500ms !?",
                "solutionTags": [],
                "code": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        vector<Interval> ret;\\n        auto it = intervals.begin();\\n        for(; it!=intervals.end(); ++it){\\n\\t\\t\\tif(newInterval.end < (*it).start) //all intervals after will not overlap with the newInterval\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\telse if(newInterval.start > (*it).end) //*it will not overlap with the newInterval\\n\\t\\t\\t\\tret.push_back(*it); \\n            else{ //update newInterval bacause *it overlap with the newInterval\\n                newInterval.start = min(newInterval.start, (*it).start);\\n                newInterval.end = max(newInterval.end, (*it).end);\\n            }\\t\\n        }\\n        // don't forget the rest of the intervals and the newInterval\\n\\t\\tret.push_back(newInterval);\\n\\t\\tfor(; it!=intervals.end(); ++it)\\n\\t\\t\\tret.push_back(*it);\\n\\t\\treturn ret;\\n    }\\nMy question is why this code need 500ms !?",
                "codeTag": "Unknown"
            },
            {
                "id": 21815,
                "title": "two-easy-o-n-c-solutions-with-explanations",
                "content": "By far the best solution I have seen is of `O(n)` time (some solutions claim to be of `O(logn)` turns out to be `O(n)`). One of the simplest ideas is to compare each interval in `intervals` (`intervals[i]`) with `newInterval` and then perform respective operations according to their relationships.\\n\\n 1. If they overlap, merge them to `newInterval`;\\n 2. If `intervals[i]` is to the left of `newInterval`, push `intervals[i]` to the result vector;\\n 3. If `newInterval` is to the left of `intervals[i]`, push `newInterval` and all the remaining intervals (`intervals[i]`, ..., `intervals[n - 1]`) to the result vector.\\n\\nThe code is as follows. \\n\\n    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            vector<Interval> res;\\n            int n = intervals.size();\\n            for (int i = 0; i < n; i++) {\\n                if (intervals[i].end < newInterval.start)\\n                    res.push_back(intervals[i]);\\n                else if (newInterval.end < intervals[i].start) {\\n                    res.push_back(newInterval);\\n                    for (int j = i; j < n; j++)\\n                        res.push_back(intervals[j]);\\n                    return res; \\n                }\\n                else newInterval = merge(intervals[i], newInterval);\\n            }\\n            res.push_back(newInterval);\\n            return res;\\n        }\\n    private:\\n        Interval merge(Interval& interval1, Interval& interval2) {\\n            int start = min(interval1.start, interval2.start);\\n            int end = max(interval1.end, interval2.end);\\n            return Interval(start, end);\\n        }\\n    };\\n\\nAnother idea is to search for the two ends of the overlapping intervals using binary search. Then we only need to merge `newInterval` with the intervals at the two ends if they overlap. All the intervals within the two ends will be contained in` newInterval`.\\n\\nLet's do the example in the problem statement: `intervals = [1, 2], [3, 5], [6, 7], [8, 10], [12, 16]` and `newInterval = [4, 9]`. We first find the rightmost interval with `start` smaller than that of `newInterval`, which is `[3, 5]`. Then we find the leftmost interval with `end` larger than that of `newInterval`, which is `[8, 10]`. Then all the intervals between them will be contained within `newInterval` (you may check this to convince yourself) and so can be safely ignored. We only need to check whether `newInterval` overlaps with the two intervals on the two ends and merge them if necessary.\\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            int n = intervals.size(), leftEnd, rightEnd, l, r;\\n            vector<Interval> res;\\n            // Find the rightmost interval with start smaller than that of newInterval\\n            for (l = 0, r = n - 1; l <= r; ) {\\n                int mid = l + ((r - l) >> 1);\\n                if (intervals[mid].start > newInterval.start)\\n                    r = mid - 1;\\n                else l = mid + 1;\\n            } \\n            leftEnd = r;\\n            // Find the leftmost interval with end larger than that of newInterval\\n            for (l = 0, r = n - 1; l <= r; ) {\\n                int mid = l + ((r - l) >> 1);\\n                if (intervals[mid].end < newInterval.end)\\n                    l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            rightEnd = l;\\n            // Merge newInterval with intervals[leftEnd] and intervals[rightEnd] if necessary\\n            if (leftEnd >= 0 && intervals[leftEnd].end >= newInterval.start)\\n                newInterval.start = intervals[leftEnd--].start;\\n            if (rightEnd < n && intervals[rightEnd].start <= newInterval.end)\\n                newInterval.end = intervals[rightEnd++].end;\\n            // Save the intervals sequentially\\n            for (int i = 0; i <= leftEnd; i++)\\n                res.push_back(intervals[i]);\\n            res.push_back(newInterval);\\n            for (int i = rightEnd; i < n; i++)\\n                res.push_back(intervals[i]);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n            vector<Interval> res;\\n            int n = intervals.size();\\n            for (int i = 0; i < n; i++) {\\n                if (intervals[i].end < newInterval.start)\\n                    res.push_back(intervals[i]);\\n                else if (newInterval.end < intervals[i].start) {\\n                    res.push_back(newInterval);\\n                    for (int j = i; j < n; j++)\\n                        res.push_back(intervals[j]);\\n                    return res; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3056524,
                "title": "python3-merge-interval-solution-explained-space-complexity-o-n-o-1",
                "content": "**Intuition**\\n\\nThis problem is almost the same as [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/) if we first insert ```newInterval``` into ```intervals``` such that ```intervals``` is still sorted by the start time, and then merge overlapped intervals.\\n\\n - use binary search to find the index where ```newInterval``` should be instered into ```intervals```. O(logN)\\n - Insert the ```newInterval```. O(N)\\n - merge overlapped intervals if there are any.\\n    - We can interately build a stack, and merge a new interval with the last interval in the stack if they overlap.\\n    - To check if a new interval is overlap with the last interval in stack, we simply check if the last end is greater than or equal to the new start. If it is, we merge the two intervals by using the last start as the start, and the max(lastEnd, newEnd) as the end.\\n    - If there is no overlap between the new interval and the last interval in stack, we simply add the new interval to the stack.\\n\\n**Solution 1** using stack\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        stack = []\\n        for s,e in intervals:\\n            if stack and stack[-1][1] >= s:\\n                lastS,lastE = stack.pop()\\n                stack.append([lastS, max(lastE,e)])\\n            else:\\n                stack.append([s,e])\\n        return stack\\n```\\n\\nWe don\\'t really need to use a stack, but using the list slicing in Python to merge the overlapped intervals.\\n\\n**Solution 2** inplace merge\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        i = 0\\n        while i<len(intervals):\\n            s,e = intervals[i]\\n            if i>0 and intervals[i-1][1] >= s:\\n                lastS,lastE = intervals[i-1]\\n                intervals[i-1:i+1] = [[lastS, max(lastE,e)]]\\n            else:\\n                i += 1\\n        return intervals\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n",
                "solutionTags": [],
                "code": "```newInterval```\n```intervals```\n```intervals```\n```newInterval```\n```intervals```\n```newInterval```\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        stack = []\\n        for s,e in intervals:\\n            if stack and stack[-1][1] >= s:\\n                lastS,lastE = stack.pop()\\n                stack.append([lastS, max(lastE,e)])\\n            else:\\n                stack.append([s,e])\\n        return stack\\n```\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insertI = bisect_left(intervals, newInterval)\\n        intervals.insert(insertI, newInterval)\\n        i = 0\\n        while i<len(intervals):\\n            s,e = intervals[i]\\n            if i>0 and intervals[i-1][1] >= s:\\n                lastS,lastE = intervals[i-1]\\n                intervals[i-1:i+1] = [[lastS, max(lastE,e)]]\\n            else:\\n                i += 1\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902628,
                "title": "c-optimized-solution-9-lines-beats-95-time",
                "content": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        \\n        while(i < n && intervals[i][1] < newInterval[0])    res.push_back(intervals[i++]);\\n\\t\\t\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        while(i < n)    res.push_back(intervals[i++]);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size(), i = 0;\\n        vector<vector<int>> res;\\n        \\n        while(i < n && intervals[i][1] < newInterval[0])    res.push_back(intervals[i++]);\\n\\t\\t\\n        while(i < n && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        res.push_back(newInterval);\\n        while(i < n)    res.push_back(intervals[i++]);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342029,
                "title": "javascript-solution-beats-99-79",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let size = intervals.length;\\n    let index = 0;\\n    let res = [];\\n    \\n    while(index < size && intervals[index][1] < newInterval[0]) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    while(index < size && intervals[index][0] <= newInterval[1]) {\\n        newInterval[0] = Math.min(newInterval[0], intervals[index][0]);\\n        newInterval[1] = Math.max(newInterval[1], intervals[index][1]);\\n        index++;\\n    }\\n    res.push(newInterval);\\n    while(index < size) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let size = intervals.length;\\n    let index = 0;\\n    let res = [];\\n    \\n    while(index < size && intervals[index][1] < newInterval[0]) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    while(index < size && intervals[index][0] <= newInterval[1]) {\\n        newInterval[0] = Math.min(newInterval[0], intervals[index][0]);\\n        newInterval[1] = Math.max(newInterval[1], intervals[index][1]);\\n        index++;\\n    }\\n    res.push(newInterval);\\n    while(index < size) {\\n        res.push(intervals[index]);\\n        index++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313612,
                "title": "python3-faster-than-99-58-36ms-14-9mb",
                "content": "Python3 - Faster than 99.58% - 36ms & 14.9MB\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        intervals.sort(key=lambda x: x[0])\\n        \\n        result = []\\n        for interval in intervals:\\n            if not result or result[-1][1] < interval[0]:\\n                result.append(interval)\\n            else:\\n                result[-1][1] = max(result[-1][1],interval[1])\\n                \\n        return result\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        intervals.sort(key=lambda x: x[0])\\n        \\n        result = []\\n        for interval in intervals:\\n            if not result or result[-1][1] < interval[0]:\\n                result.append(interval)\\n            else:\\n                result[-1][1] = max(result[-1][1],interval[1])\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298982,
                "title": "javascript-solution-95-fast",
                "content": "```\\nvar insert = function (intervals, newInterval) {\\n    if (intervals.length === 0) {\\n        return [ newInterval ];\\n    }\\n\\n    const result = [];\\n    let flag = 0;\\n    let i;\\n\\n    for (i = 0; i < intervals.length; i++) {\\n        const interval = intervals[i];\\n        if (newInterval[0] > interval[1]){\\n            result.push(interval);\\n        } else if (newInterval[1] < interval[0]){\\n            result.push(newInterval);\\n            flag = 1;\\n            break;\\n        } else {\\n            newInterval[0] = Math.min(newInterval[0], interval[0]);\\n            newInterval[1] = Math.max(newInterval[1], interval[1]);\\n        }\\n    }\\n\\n    if (flag === 0) {\\n        result.push(newInterval);\\n        return result;\\n    } else {\\n        return result.concat(intervals.splice(i));\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function (intervals, newInterval) {\\n    if (intervals.length === 0) {\\n        return [ newInterval ];\\n    }\\n\\n    const result = [];\\n    let flag = 0;\\n    let i;\\n\\n    for (i = 0; i < intervals.length; i++) {\\n        const interval = intervals[i];\\n        if (newInterval[0] > interval[1]){\\n            result.push(interval);\\n        } else if (newInterval[1] < interval[0]){\\n            result.push(newInterval);\\n            flag = 1;\\n            break;\\n        } else {\\n            newInterval[0] = Math.min(newInterval[0], interval[0]);\\n            newInterval[1] = Math.max(newInterval[1], interval[1]);\\n        }\\n    }\\n\\n    if (flag === 0) {\\n        result.push(newInterval);\\n        return result;\\n    } else {\\n        return result.concat(intervals.splice(i));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845073,
                "title": "python-3-sweep-line-heap-explanations",
                "content": "### Explanation\\n- Typical `Sweep Line` question, use `heap` for help\\n- Mark every start as `-1`, every end as `1`\\n- Sort all start & end points\\n- Close interval only when counter `cur` equals to `0`\\n- Check out below comments for more detail\\n### Implementation\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        heap, ans, = [], [] \\n        for s, e in intervals + [newInterval]: # add start & end to heap (-1 is start, 1 is end)\\n            heapq.heappush(heap, (s, -1))\\n            heapq.heappush(heap, (e, 1))\\n        cur, s = 0, None            \\n        while heap:                            \\n            i, val = heapq.heappop(heap)       # pop heap\\n            if s is None: s = i                # is s is None, assign i to s (interval start)\\n            cur += val                         # keep counting until close interval\\n            if not cur:                        # when cur == 0, meaning we can close the interval\\n                ans.append([s, i])             # append interval to ans\\n                s = None                       # reset s to None\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        heap, ans, = [], [] \\n        for s, e in intervals + [newInterval]: # add start & end to heap (-1 is start, 1 is end)\\n            heapq.heappush(heap, (s, -1))\\n            heapq.heappush(heap, (e, 1))\\n        cur, s = 0, None            \\n        while heap:                            \\n            i, val = heapq.heappop(heap)       # pop heap\\n            if s is None: s = i                # is s is None, assign i to s (interval start)\\n            cur += val                         # keep counting until close interval\\n            if not cur:                        # when cur == 0, meaning we can close the interval\\n                ans.append([s, i])             # append interval to ans\\n                s = None                       # reset s to None\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 844719,
                "title": "golang-idiomatic-solution",
                "content": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    res := make([][]int, 0)\\n    \\n    i := 0\\n    \\n    for ; i < len(intervals) && intervals[i][1] < newInterval[0]; i++ {\\n        res = append(res, intervals[i])\\n    }\\n    \\n    for ; i < len(intervals) && intervals[i][0] <= newInterval[1]; i++ {\\n        newInterval[0] = min(intervals[i][0], newInterval[0])\\n        newInterval[1] = max(intervals[i][1], newInterval[1])\\n    }\\n    \\n    res = append(res, newInterval)\\n    \\n    for i < len(intervals) {\\n        res = append(res, intervals[i])\\n        i++\\n    }\\n    \\n    return res\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    \\n    res := make([][]int, 0)\\n    \\n    i := 0\\n    \\n    for ; i < len(intervals) && intervals[i][1] < newInterval[0]; i++ {\\n        res = append(res, intervals[i])\\n    }\\n    \\n    for ; i < len(intervals) && intervals[i][0] <= newInterval[1]; i++ {\\n        newInterval[0] = min(intervals[i][0], newInterval[0])\\n        newInterval[1] = max(intervals[i][1], newInterval[1])\\n    }\\n    \\n    res = append(res, newInterval)\\n    \\n    for i < len(intervals) {\\n        res = append(res, intervals[i])\\n        i++\\n    }\\n    \\n    return res\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2429511,
                "title": "java-explained-solution",
                "content": "```\\n/*\\nInterval will not be overlapped\\ncase 1 : when interval[end] < newInterval[start],ex-newInterval = [4,8], interval = [1,2]\\ncase 2 : when interval[start] > newInterval[end],ex-newInterval = [4,8], interval = [12,16]\\ncase 3 : when new interval is already added in output list\\n\\nremaining all cases they will be overlapped\\n*/\\n\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> res = new ArrayList<>();\\n        for(int[] interval: intervals){\\n            // case3 and case1\\n            if(newInterval==null || interval[1]<newInterval[0]){\\n                res.add(interval);\\n            }else if(interval[0]>newInterval[1]){ // case 2\\n                res.add(newInterval);\\n                res.add(interval);\\n                newInterval = null;\\n            }else{ // overlapping\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        if(newInterval!=null) res.add(newInterval);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nInterval will not be overlapped\\ncase 1 : when interval[end] < newInterval[start],ex-newInterval = [4,8], interval = [1,2]\\ncase 2 : when interval[start] > newInterval[end],ex-newInterval = [4,8], interval = [12,16]\\ncase 3 : when new interval is already added in output list\\n\\nremaining all cases they will be overlapped\\n*/\\n\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> res = new ArrayList<>();\\n        for(int[] interval: intervals){\\n            // case3 and case1\\n            if(newInterval==null || interval[1]<newInterval[0]){\\n                res.add(interval);\\n            }else if(interval[0]>newInterval[1]){ // case 2\\n                res.add(newInterval);\\n                res.add(interval);\\n                newInterval = null;\\n            }else{ // overlapping\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        if(newInterval!=null) res.add(newInterval);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388642,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\\n        var res = new List<int[]>();\\n        \\n        foreach (var interval in intervals)\\n        {\\n            if (interval[0] > newInterval[1])\\n            {\\n                res.Add(newInterval);\\n                newInterval = interval;\\n            }\\n            else if (interval[1] < newInterval[0])\\n            {\\n                res.Add(interval);\\n            }\\n            else\\n            {\\n                newInterval[0] = Math.Min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.Max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        res.Add(newInterval);\\n        \\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\\n        var res = new List<int[]>();\\n        \\n        foreach (var interval in intervals)\\n        {\\n            if (interval[0] > newInterval[1])\\n            {\\n                res.Add(newInterval);\\n                newInterval = interval;\\n            }\\n            else if (interval[1] < newInterval[0])\\n            {\\n                res.Add(interval);\\n            }\\n            else\\n            {\\n                newInterval[0] = Math.Min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.Max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        res.Add(newInterval);\\n        \\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464497,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "Ported to C# from [Java solution](https://leetcode.com/problems/insert-interval/discuss/463417/My-concise-Java-solution-(single-pass-O(n)-3-steps))\\n\\n```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        int i = 0;\\n\\n        // Step 1 - add all intervals ending before newInterval starts\\n        while (i < intervals.Length && intervals[i][1] < newInterval[0])\\n            result.Add(intervals[i++]);\\n\\n        // Step 2 - update the newInterval by merging with all overlapping intervals\\n        while (i < intervals.Length && intervals[i][0] <= newInterval[1])\\n        {\\n            newInterval[0] = Math.Min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.Max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        result.Add(newInterval); // add updated interval\\n\\n        // Step 3 - add remaining intervals\\n        while (i < intervals.Length)\\n            result.Add(intervals[i++]);\\n        \\n        return result.ToArray();\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] Insert(int[][] intervals, int[] newInterval)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        int i = 0;\\n\\n        // Step 1 - add all intervals ending before newInterval starts\\n        while (i < intervals.Length && intervals[i][1] < newInterval[0])\\n            result.Add(intervals[i++]);\\n\\n        // Step 2 - update the newInterval by merging with all overlapping intervals\\n        while (i < intervals.Length && intervals[i][0] <= newInterval[1])\\n        {\\n            newInterval[0] = Math.Min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.Max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        result.Add(newInterval); // add updated interval\\n\\n        // Step 3 - add remaining intervals\\n        while (i < intervals.Length)\\n            result.Add(intervals[i++]);\\n        \\n        return result.ToArray();\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250459,
                "title": "very-simple-javascript-o-n-solution",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    const result = [];\\n    \\n    for (let i = 0; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n        \\n        // If overlaps\\n        if (Math.max(interval[0], newInterval[0]) <= Math.min(interval[1], newInterval[1])) {\\n            newInterval = [Math.min(interval[0], newInterval[0]), Math.max(interval[1], newInterval[1])];\\n            continue;\\n        }\\n        \\n        // If lower\\n        if (interval[0] > newInterval[1]) {\\n            result.push(newInterval, ...intervals.slice(i));\\n            return result;\\n        }\\n        \\n        result.push(interval);\\n    }\\n    \\n    result.push(newInterval);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    const result = [];\\n    \\n    for (let i = 0; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n        \\n        // If overlaps\\n        if (Math.max(interval[0], newInterval[0]) <= Math.min(interval[1], newInterval[1])) {\\n            newInterval = [Math.min(interval[0], newInterval[0]), Math.max(interval[1], newInterval[1])];\\n            continue;\\n        }\\n        \\n        // If lower\\n        if (interval[0] > newInterval[1]) {\\n            result.push(newInterval, ...intervals.slice(i));\\n            return result;\\n        }\\n        \\n        result.push(interval);\\n    }\\n    \\n    result.push(newInterval);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1221925,
                "title": "java-solution-with-comments-o-n",
                "content": "The approach is to:\\n1. Skip all the intervals that end before the newInterval starts because they would not overlap anyway. So we add them to the final result.\\n2. For those intervals that overlap with the newInterval, we will merge them before inserting into the final result list. We say that an interval b overlaps with a is b.start <= a.end.\\n3. At the end, we will add the remaining intervals from the original array that do not overlap with the newInterval.\\n\\nWe will use a List since we do not know the size of our merged intervals beforehand and then we will convert the list to the required 2-dimensional array\\n\\n```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length; // length of intervals\\n        if (intervals == null || n == 0) {\\n            return new int[][] { newInterval };\\n        }\\n        \\n        // result list to be converted to int[] at the end\\n        List<int[]> result = new ArrayList<>();\\n        \\n        // skip the intervals that end before new interval\\n        int i = 0;\\n        \\n        while (i < n && intervals[i][1] < newInterval[0]) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        \\n        // merge all intervals that overlap with newInterval\\n        while (i < n && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n        // add the newly merged interval\\n        result.add(newInterval);\\n        \\n        // add all the remaining intervals to result\\n        while (i < n) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n\\n\\t\\t// convert to a 2d array\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "The approach is to:\\n1. Skip all the intervals that end before the newInterval starts because they would not overlap anyway. So we add them to the final result.\\n2. For those intervals that overlap with the newInterval, we will merge them before inserting into the final result list. We say that an interval b overlaps with a is b.start <= a.end.\\n3. At the end, we will add the remaining intervals from the original array that do not overlap with the newInterval.\\n\\nWe will use a List since we do not know the size of our merged intervals beforehand and then we will convert the list to the required 2-dimensional array\\n\\n```\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length; // length of intervals\\n        if (intervals == null || n == 0) {\\n            return new int[][] { newInterval };\\n        }\\n        \\n        // result list to be converted to int[] at the end\\n        List<int[]> result = new ArrayList<>();\\n        \\n        // skip the intervals that end before new interval\\n        int i = 0;\\n        \\n        while (i < n && intervals[i][1] < newInterval[0]) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        \\n        // merge all intervals that overlap with newInterval\\n        while (i < n && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n        // add the newly merged interval\\n        result.add(newInterval);\\n        \\n        // add all the remaining intervals to result\\n        while (i < n) {\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n\\n\\t\\t// convert to a 2d array\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 685007,
                "title": "python-very-simple-solution-based-on-merge-intervals",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ## RC ##\\n\\t\\t## Similar to Leetcode 56. Merge Intervals ##\\n\\t\\t## LOGIC ##\\n\\t\\t## 1. As per the problem statement, the intervals are initially sorted, so we donot need to sort them, we can just insert the new interval in the right position and apply the merge intervals algorithm. ##\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        i = 0\\n        while( i<len(intervals) and intervals[i][0] < newInterval[0]):\\n            i+= 1\\n        \\n        intervals.insert(i,newInterval)\\n        \\n        ans = []\\n        for interval in intervals:\\n            if len(ans) == 0 or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ## RC ##\\n\\t\\t## Similar to Leetcode 56. Merge Intervals ##\\n\\t\\t## LOGIC ##\\n\\t\\t## 1. As per the problem statement, the intervals are initially sorted, so we donot need to sort them, we can just insert the new interval in the right position and apply the merge intervals algorithm. ##\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        i = 0\\n        while( i<len(intervals) and intervals[i][0] < newInterval[0]):\\n            i+= 1\\n        \\n        intervals.insert(i,newInterval)\\n        \\n        ans = []\\n        for interval in intervals:\\n            if len(ans) == 0 or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056535,
                "title": "python3-79-ms-faster-than-93-12-of-python3-clean-and-easy-to-understand",
                "content": "```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        for i in range(len(intervals)):\\n            if newInterval[1] < intervals[i][0]:\\n                result.append(newInterval)\\n                return result + intervals[i:]\\n            elif newInterval[0] > intervals[i][1]:\\n                result.append(intervals[i])\\n            else:\\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\\n        result.append(newInterval)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        for i in range(len(intervals)):\\n            if newInterval[1] < intervals[i][0]:\\n                result.append(newInterval)\\n                return result + intervals[i:]\\n            elif newInterval[0] > intervals[i][1]:\\n                result.append(intervals[i])\\n            else:\\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\\n        result.append(newInterval)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1430986,
                "title": "binary-search-solution",
                "content": "First looking where to insert elements from new interval using binary search (to left of the interval or into the interval itself) - O(log N). Second composing two lists left and right to the new interval. Third merging if start or end falls in between of any interval. Overall worst case still O(N) but binary search helps in cases like new interval consumes all intervals.\\n\\n**Python**\\n```\\n    def bsearch(intervals: List[List[int]], x: int) -> int:\\n        lo, hi = 0, len(intervals)\\n        mid = 0\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if intervals[mid][0] > x:\\n                hi = mid\\n            elif intervals[mid][1] < x:\\n                lo = mid + 1\\n            else:\\n                break\\n        return mid\\n \\n    def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        li, ri = bsearch(intervals, s), bsearch(intervals, e)\\n        l = intervals[:li + int(li < len(intervals) and intervals[li][1] < s)]\\n        r = intervals[ri + int(ri >= len(intervals) or intervals[ri][0] <= e):]\\n        if len(l) + len(r) != len(intervals):\\n            s = min(s, intervals[len(l)][0])\\n            e = max(e, intervals[-len(r)-1][1])\\n        return l + [[s, e]] + r\\n```\\n\\n**Javascript**\\n```\\nconst bsearch = (intervals, x) => {\\n    let mid = 0;\\n    let lo = 0;\\n    let hi = intervals.length;\\n    while (lo < hi) {\\n        mid = (lo + hi - Number((lo + hi) % 2 !== 0)) / 2;\\n        if (intervals[mid][0] > x)\\n            hi = mid;\\n        else if (intervals[mid][1] < x)\\n            lo = mid + 1\\n        else\\n            break;\\n    }\\n    return mid;\\n}\\n\\nconst insert = (intervals, newInterval) => {\\n    let [s, e] = newInterval;\\n    const li = bsearch(intervals, newInterval[0]);\\n    const ri = bsearch(intervals, newInterval[1]);\\n    const l = intervals.slice(0, li + Number(li < intervals.length && intervals[li][1] < s));\\n    const r = intervals.slice(ri + Number(ri >= intervals.length || intervals[ri][0] <= e))\\n    if (l.length + r.length !== intervals.length) {\\n        s = Math.min(s, intervals[l.length][0]);\\n        e = Math.max(e, intervals[intervals.length - r.length - 1][1]);\\n    }\\n    return [...l, [s, e], ...r];\\n};\\n```\\n\\n**Rust**\\n```\\n    use std::cmp::Ordering;\\n    fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        let (mut s, mut e) = (new_interval[0], new_interval[1]);\\n        let pred = |x| {\\n            move |i: &Vec<i32>| {\\n                if i[0] > x {\\n                    Ordering::Greater\\n                } else if i[1] < x {\\n                    Ordering::Less\\n                } else {\\n                    Ordering::Equal\\n                }\\n            }\\n        };\\n        let li = intervals.binary_search_by(pred(s)).unwrap_or_else(|x| x);\\n        let ri = intervals.binary_search_by(pred(e)).unwrap_or_else(|x| x);\\n        let l = &intervals[..(li + usize::from(li < intervals.len() && intervals[li][1] < s))];\\n        let r = &intervals[(ri + usize::from(ri >= intervals.len() || intervals[ri][0] <= e)).min(intervals.len())..];\\n        if l.len() + r.len() != intervals.len() {\\n            s = s.min(intervals[l.len()][0]);\\n            e = e.max(intervals[intervals.len() - r.len() - 1][1]);\\n        }\\n        vec![l, &vec![vec![s, e]], r].concat()\\n    }\\n```",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\n    def bsearch(intervals: List[List[int]], x: int) -> int:\\n        lo, hi = 0, len(intervals)\\n        mid = 0\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if intervals[mid][0] > x:\\n                hi = mid\\n            elif intervals[mid][1] < x:\\n                lo = mid + 1\\n            else:\\n                break\\n        return mid\\n \\n    def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        li, ri = bsearch(intervals, s), bsearch(intervals, e)\\n        l = intervals[:li + int(li < len(intervals) and intervals[li][1] < s)]\\n        r = intervals[ri + int(ri >= len(intervals) or intervals[ri][0] <= e):]\\n        if len(l) + len(r) != len(intervals):\\n            s = min(s, intervals[len(l)][0])\\n            e = max(e, intervals[-len(r)-1][1])\\n        return l + [[s, e]] + r\\n```\n```\\nconst bsearch = (intervals, x) => {\\n    let mid = 0;\\n    let lo = 0;\\n    let hi = intervals.length;\\n    while (lo < hi) {\\n        mid = (lo + hi - Number((lo + hi) % 2 !== 0)) / 2;\\n        if (intervals[mid][0] > x)\\n            hi = mid;\\n        else if (intervals[mid][1] < x)\\n            lo = mid + 1\\n        else\\n            break;\\n    }\\n    return mid;\\n}\\n\\nconst insert = (intervals, newInterval) => {\\n    let [s, e] = newInterval;\\n    const li = bsearch(intervals, newInterval[0]);\\n    const ri = bsearch(intervals, newInterval[1]);\\n    const l = intervals.slice(0, li + Number(li < intervals.length && intervals[li][1] < s));\\n    const r = intervals.slice(ri + Number(ri >= intervals.length || intervals[ri][0] <= e))\\n    if (l.length + r.length !== intervals.length) {\\n        s = Math.min(s, intervals[l.length][0]);\\n        e = Math.max(e, intervals[intervals.length - r.length - 1][1]);\\n    }\\n    return [...l, [s, e], ...r];\\n};\\n```\n```\\n    use std::cmp::Ordering;\\n    fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        let (mut s, mut e) = (new_interval[0], new_interval[1]);\\n        let pred = |x| {\\n            move |i: &Vec<i32>| {\\n                if i[0] > x {\\n                    Ordering::Greater\\n                } else if i[1] < x {\\n                    Ordering::Less\\n                } else {\\n                    Ordering::Equal\\n                }\\n            }\\n        };\\n        let li = intervals.binary_search_by(pred(s)).unwrap_or_else(|x| x);\\n        let ri = intervals.binary_search_by(pred(e)).unwrap_or_else(|x| x);\\n        let l = &intervals[..(li + usize::from(li < intervals.len() && intervals[li][1] < s))];\\n        let r = &intervals[(ri + usize::from(ri >= intervals.len() || intervals[ri][0] <= e)).min(intervals.len())..];\\n        if l.len() + r.len() != intervals.len() {\\n            s = s.min(intervals[l.len()][0]);\\n            e = e.max(intervals[intervals.len() - r.len() - 1][1]);\\n        }\\n        vec![l, &vec![vec![s, e]], r].concat()\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463417,
                "title": "my-concise-java-solution-single-pass-o-n-3-steps-with-explanation",
                "content": "The idea is simple. Since the intervals are already sorted by start time, all we need is one pass from left to right. \\n**3 steps:**\\n1. Add any intervals that finish before the new interval starts.\\n2. Update the new interval by merging it will all overlapping intervals. Add the updated newInterval to result.\\n3. Add remaining intervals to result, and voila!\\n\\nHere\\'s the code\\n```\\npublic int[][] insert(int[][] intervals, int[] newInterval) {       \\n\\tList<int[]> result = new ArrayList<>();        \\n\\tint i=0;\\n\\n\\t// Step 1 - add all intervals ending before newInterval starts\\n\\twhile (i<intervals.length && intervals[i][1] < newInterval[0]) result.add(intervals[i++]);\\n\\n\\t// Step 2 - update the newInterval by merging with all overlapping intervals\\n\\twhile (i<intervals.length && intervals[i][0] <= newInterval[1]) {\\n\\t\\tnewInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n\\t\\tnewInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n\\t\\ti++;\\n\\t}\\n\\tresult.add(newInterval); // add updated interval\\n\\n\\t// Step 3 - add remaining intervals\\n\\twhile (i<intervals.length) result.add(intervals[i++]);\\n\\treturn result.toArray(new int[0][2]);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] insert(int[][] intervals, int[] newInterval) {       \\n\\tList<int[]> result = new ArrayList<>();        \\n\\tint i=0;\\n\\n\\t// Step 1 - add all intervals ending before newInterval starts\\n\\twhile (i<intervals.length && intervals[i][1] < newInterval[0]) result.add(intervals[i++]);\\n\\n\\t// Step 2 - update the newInterval by merging with all overlapping intervals\\n\\twhile (i<intervals.length && intervals[i][0] <= newInterval[1]) {\\n\\t\\tnewInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n\\t\\tnewInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n\\t\\ti++;\\n\\t}\\n\\tresult.add(newInterval); // add updated interval\\n\\n\\t// Step 3 - add remaining intervals\\n\\twhile (i<intervals.length) result.add(intervals[i++]);\\n\\treturn result.toArray(new int[0][2]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056859,
                "title": "c-easy-intutive-solution-in-o-nlogn-time-complexity",
                "content": "# Intuition\\nIt is similar to the question [Merge Intervals](https://leetcode.com/problems/merge-intervals/) must try before doing this problem.\\n\\n# Approach\\nInsert the new interval in and then the question becomes same as merge intervals.\\n\\n# Complexity\\n- Time complexity:O(NLogN)\\n\\n- Space complexity:O(2*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval});\\n        sort(intervals.begin() , intervals.end());\\n        int j = 0 , n = intervals.size();\\n        for(int i = 1 ; i < n ; i++){\\n            if(intervals[j][1] >= intervals[i][0]){\\n                intervals[j][1] = max(intervals[j][1] , intervals[i][1]);\\n            }\\n            else{\\n                j++;\\n                intervals[j] = intervals[i];\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(int i = 0 ; i <= j ; i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n*I just did this solution for doing it some other way and i know there exist a O(N) solution too*\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval});\\n        sort(intervals.begin() , intervals.end());\\n        int j = 0 , n = intervals.size();\\n        for(int i = 1 ; i < n ; i++){\\n            if(intervals[j][1] >= intervals[i][0]){\\n                intervals[j][1] = max(intervals[j][1] , intervals[i][1]);\\n            }\\n            else{\\n                j++;\\n                intervals[j] = intervals[i];\\n            }\\n        }\\n        vector<vector<int>> ans;\\n        for(int i = 0 ; i <= j ; i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912542,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var i = 0\\n\\n        while i < intervals.count, intervals[i][1] < newInterval[0] {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        var newInterval = newInterval\\n        while i < intervals.count, intervals[i][0] <= newInterval[1] {\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        }\\n\\n        ans.append(newInterval)\\n\\n        while i < intervals.count {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var i = 0\\n\\n        while i < intervals.count, intervals[i][1] < newInterval[0] {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        var newInterval = newInterval\\n        while i < intervals.count, intervals[i][0] <= newInterval[1] {\\n            newInterval[0] = min(intervals[i][0], newInterval[0])\\n            newInterval[1] = max(intervals[i][1], newInterval[1])\\n            i += 1\\n        }\\n\\n        ans.append(newInterval)\\n\\n        while i < intervals.count {\\n            ans.append(intervals[i])\\n            i += 1\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1444764,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        l = bisect.bisect_left([x[1] for x in intervals],newInterval[0])\\n        r = bisect.bisect_right([x[0] for x in intervals],newInterval[1])\\n        \\n        if l < len(intervals):\\n            newInterval[0] = min(newInterval[0],intervals[l][0])\\n            \\n        if r > 0:\\n            newInterval[1] = max(newInterval[1],intervals[r-1][1])\\n            \\n        return intervals[:l] + [ newInterval ] + intervals[r:]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        l = bisect.bisect_left([x[1] for x in intervals],newInterval[0])\\n        r = bisect.bisect_right([x[0] for x in intervals],newInterval[1])\\n        \\n        if l < len(intervals):\\n            newInterval[0] = min(newInterval[0],intervals[l][0])\\n            \\n        if r > 0:\\n            newInterval[1] = max(newInterval[1],intervals[r-1][1])\\n            \\n        return intervals[:l] + [ newInterval ] + intervals[r:]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 792436,
                "title": "c-one-pass-o-n-solution",
                "content": "```csharp\\npublic int[][] Insert(int[][] intervals, int[] newInterval) \\n{\\n\\tif(intervals.Length == 0)\\n\\t{\\n\\t\\treturn new int[][] { newInterval };\\n\\t}        \\n\\n\\tList<int[]> result = new List<int[]>();\\n\\tforeach(var interval in intervals)\\n\\t{\\n\\t\\tif(newInterval[0] > interval[1])\\n\\t\\t{\\n\\t\\t\\tresult.Add(interval);\\n\\t\\t}\\n\\n\\t\\telse if(newInterval[1] < interval[0])\\n\\t\\t{\\n\\t\\t\\tresult.Add(newInterval);\\n\\t\\t\\tnewInterval = interval;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewInterval[0] = Math.Min(interval[0], newInterval[0]);\\n\\t\\t\\tnewInterval[1] = Math.Max(interval[1], newInterval[1]);\\n\\t\\t}\\n\\t}\\n\\n\\tresult.Add(newInterval);\\n\\treturn result.ToArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[][] Insert(int[][] intervals, int[] newInterval) \\n{\\n\\tif(intervals.Length == 0)\\n\\t{\\n\\t\\treturn new int[][] { newInterval };\\n\\t}        \\n\\n\\tList<int[]> result = new List<int[]>();\\n\\tforeach(var interval in intervals)\\n\\t{\\n\\t\\tif(newInterval[0] > interval[1])\\n\\t\\t{\\n\\t\\t\\tresult.Add(interval);\\n\\t\\t}\\n\\n\\t\\telse if(newInterval[1] < interval[0])\\n\\t\\t{\\n\\t\\t\\tresult.Add(newInterval);\\n\\t\\t\\tnewInterval = interval;\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tnewInterval[0] = Math.Min(interval[0], newInterval[0]);\\n\\t\\t\\tnewInterval[1] = Math.Max(interval[1], newInterval[1]);\\n\\t\\t}\\n\\t}\\n\\n\\tresult.Add(newInterval);\\n\\treturn result.ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056498,
                "title": "c-short-easy-code-with-explanation",
                "content": "# Intuition\\nThe main idea of solving this problem is that when iterate over the intervals, there are three cases:\\n\\n1) the new interval\\'s range is before the range of current interval.\\nExample new interval= {3,4} and current interval= {6,9}\\n\\n2) the new interval is after the range of current interval.\\nExample new interval= {5,7} and current interval= {2,3}\\n3) the new interval range overlaps with the range of current interval.\\nExample interval= {5,9} and new interval= {6,11}\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple iterate through intervals.\\n- If case 1 occurs,ie. The new interval\\'s range is before the current interval, so we can insert the new interval into answer and update new interval to the current interval.\\n- If case 2 occurs,ie. The new interval is after the range of current interval, so we can simply insert the current interval into answer.\\n- If case 3 occurs,ie. The new interval overlaps with current interval, so we update the first element of new interval to the minimum of current interval and new interval and update the second element of new interval to the maximum of current interval and new interval.\\nExample interval= {5,9} and new interval= {6,11}. Then update new interval = {min(5,6),max(9,11)}={5,11}\\n- At the end of iterations simply insert new interval to the answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<intervals.size();i++){\\n            //case 1 occurs\\n            if(intervals[i][0] > newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\n            //case 2 occurs\\n            else if(intervals[i][1] < newInterval[0]){ans.push_back(intervals[i]);}       \\n    \\n            //case 3 occurs\\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        //final step\\n        ans.push_back(newInterval); \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0;i<intervals.size();i++){\\n            //case 1 occurs\\n            if(intervals[i][0] > newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = intervals[i]; \\n            }\\n\\n            //case 2 occurs\\n            else if(intervals[i][1] < newInterval[0]){ans.push_back(intervals[i]);}       \\n    \\n            //case 3 occurs\\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        //final step\\n        ans.push_back(newInterval); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738782,
                "title": "solution-swift-insert-interval-test-cases",
                "content": "```swift\\nclass Solution {\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [newInterval] }\\n        guard !newInterval.isEmpty else { return intervals }\\n        \\n        var idx = 0, new = newInterval, result: [[Int]] = []\\n        let len = intervals.count\\n        \\n        while idx < len, intervals[idx][1] < new[0] {\\n            result.append(intervals[idx])\\n            idx += 1\\n        }\\n        \\n        while idx < len, intervals[idx][0] <= new[1] {\\n            new[0] = min(intervals[idx][0], new[0])\\n            new[1] = max(intervals[idx][1], new[1])\\n            idx += 1\\n        }\\n        \\n        result.append(new)\\n        \\n        for i in idx..<len { result.append(intervals[i]) }\\n        \\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.insert([[1,3],[6,9]], [2,5])\\n        XCTAssertEqual(value, [[1,5],[6,9]])\\n    }\\n    \\n    // Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\\n    func test1() {\\n        let value = solution.insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\\n        XCTAssertEqual(value, [[1,2],[3,10],[12,16]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [newInterval] }\\n        guard !newInterval.isEmpty else { return intervals }\\n        \\n        var idx = 0, new = newInterval, result: [[Int]] = []\\n        let len = intervals.count\\n        \\n        while idx < len, intervals[idx][1] < new[0] {\\n            result.append(intervals[idx])\\n            idx += 1\\n        }\\n        \\n        while idx < len, intervals[idx][0] <= new[1] {\\n            new[0] = min(intervals[idx][0], new[0])\\n            new[1] = max(intervals[idx][1], new[1])\\n            idx += 1\\n        }\\n        \\n        result.append(new)\\n        \\n        for i in idx..<len { result.append(intervals[i]) }\\n        \\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.insert([[1,3],[6,9]], [2,5])\\n        XCTAssertEqual(value, [[1,5],[6,9]])\\n    }\\n    \\n    // Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\\n    func test1() {\\n        let value = solution.insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])\\n        XCTAssertEqual(value, [[1,2],[3,10],[12,16]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844503,
                "title": "c-simple-explained-solution-o-n-time-o-1-space-faster-than-96",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size();\\n        \\n        if (n == 0) // edge case #1: no intervals in original list\\n            return {newInterval};\\n        \\n        if (intervals[n-1][1] < newInterval[0]) { // edge case #2: new interval goes in the end of the list with no overlap\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        vector<vector<int>> res;\\n        int i = 0;\\n        for(; i<n; i++) {\\n            \\n            if (intervals[i][1] < newInterval[0]) // new interval doesn\\'t overlap\\n                res.push_back(intervals[i]);\\n            else {\\n                int first = min(intervals[i][0], newInterval[0]);\\n                int last = newInterval[1];\\n                \\n                while (i < n && last >= intervals[i][0]) { // while new interval overlaps:\\n                    last = max(intervals[i][1], newInterval[1]);\\n                    i++;\\n                }\\n                res.push_back({first, last});\\n                break;\\n            }\\n        }\\n        \\n        while (i < n) { // add the rest\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size();\\n        \\n        if (n == 0) // edge case #1: no intervals in original list\\n            return {newInterval};\\n        \\n        if (intervals[n-1][1] < newInterval[0]) { // edge case #2: new interval goes in the end of the list with no overlap\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        vector<vector<int>> res;\\n        int i = 0;\\n        for(; i<n; i++) {\\n            \\n            if (intervals[i][1] < newInterval[0]) // new interval doesn\\'t overlap\\n                res.push_back(intervals[i]);\\n            else {\\n                int first = min(intervals[i][0], newInterval[0]);\\n                int last = newInterval[1];\\n                \\n                while (i < n && last >= intervals[i][0]) { // while new interval overlaps:\\n                    last = max(intervals[i][1], newInterval[1]);\\n                    i++;\\n                }\\n                res.push_back({first, last});\\n                break;\\n            }\\n        }\\n        \\n        while (i < n) { // add the rest\\n            res.push_back(intervals[i]);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21698,
                "title": "java-2ms-o-log-n-o-1-binary-search-solution-beats-97-7-with-clear-explaination",
                "content": "The idea is using binary search to find the position that the newInterval to be inserted. \\n\\nSince the original intervals are sorted and disjoint, we can apply binary search to find the insertion index of newInterval.start (by interval.start), and to find the insertion index of newInterval.end(by interval.end), \\u3010see LeeCode problem #35\\u3011. Then remove the overlapped elements of the list and merge the newInterval with boundary elements on two sides.\\n\\nComplexity: O(log n) in time (in fact, depending on the implement of the access method list.get(i) and of list.subList(int, int).clear()); O(1) in space.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Since the original list is sorted and all intervals are disjoint,\\n\\t\\t\\t * apply binary search to find the insertion index for the new\\n\\t\\t\\t * interval. [LC35]\\n\\t\\t\\t * \\n\\t\\t\\t * 1. Find insIdx=the insertion index of new.start, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).start>=new.start.\\n\\t\\t\\t * \\n\\t\\t\\t * 2. Find nxtIdx=the insertion index of new.end, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).end>=new.end.\\n\\t\\t\\t * \\n\\t\\t\\t * 3. Remove all elements of the list with indices insIdx<=i<nxtIdx.\\n\\t\\t\\t * \\n\\t\\t\\t * 4. Merge new with list.get(insIdx-1) or list.get(nxtIdx) or both.\\n\\t\\t\\t */\\n\\n\\t\\t\\tint n = intervals.size();\\n\\t\\t\\tif (n == 0) {\\n\\t\\t\\t\\tintervals.add(newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint low = 0, high = n - 1, mid = 0;\\n\\t\\t\\tint temp, target = newInterval.start;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).start;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// insIdx = the index where new interval to be inserted\\n\\t\\t\\tint insIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval pre = (insIdx == 0) ? null : intervals.get(insIdx - 1);\\n\\t\\t\\t// 0<=insIdx<=n, pre=[insIdx-1], pre.start<new.start\\n\\n\\t\\t\\tlow = insIdx;\\n\\t\\t\\thigh = n - 1;\\n\\t\\t\\ttarget = newInterval.end;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).end;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// nxtIdx= the next index after the inserted new interval\\n\\t\\t\\tint nxtIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval nxt = (nxtIdx == n) ? null : intervals.get(nxtIdx);\\n\\t\\t\\t// insIdx<=nxtIdx<=n, nxt=[nxtIdx], nxt.end>=new.end\\n\\n\\t\\t\\t// [0]...[insIdx-1] <--> [insIdx]...[nxtIdx-1][nxtIdx]...[n]\\n\\t\\t\\tintervals.subList(insIdx, nxtIdx).clear();\\n\\n\\t\\t\\t// check whether newInterval can be merged with pre or nxt\\n\\t\\t\\tboolean isMerged = false, isMerged2 = false;\\n\\t\\t\\tif (insIdx > 0 && pre.end >= newInterval.start) {\\n\\t\\t\\t\\tpre.end = Math.max(pre.end, newInterval.end);\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (nxtIdx < n && newInterval.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = Math.min(nxt.start, newInterval.start);\\n\\t\\t\\t\\tisMerged2 = isMerged;\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!isMerged) {\\n\\t\\t\\t\\tintervals.add(insIdx, newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// merged with pre or nxt or both, deal with the both case\\n\\t\\t\\tif (isMerged2 && pre.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = pre.start; // pre.start < new.start, nxt.start;\\n\\t\\t\\t\\tintervals.remove(insIdx - 1); // remove pre\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn intervals;\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "The idea is using binary search to find the position that the newInterval to be inserted. \\n\\nSince the original intervals are sorted and disjoint, we can apply binary search to find the insertion index of newInterval.start (by interval.start), and to find the insertion index of newInterval.end(by interval.end), \\u3010see LeeCode problem #35\\u3011. Then remove the overlapped elements of the list and merge the newInterval with boundary elements on two sides.\\n\\nComplexity: O(log n) in time (in fact, depending on the implement of the access method list.get(i) and of list.subList(int, int).clear()); O(1) in space.\\n\\n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Since the original list is sorted and all intervals are disjoint,\\n\\t\\t\\t * apply binary search to find the insertion index for the new\\n\\t\\t\\t * interval. [LC35]\\n\\t\\t\\t * \\n\\t\\t\\t * 1. Find insIdx=the insertion index of new.start, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).start>=new.start.\\n\\t\\t\\t * \\n\\t\\t\\t * 2. Find nxtIdx=the insertion index of new.end, i.e., the first\\n\\t\\t\\t * index i such that list.get(i).end>=new.end.\\n\\t\\t\\t * \\n\\t\\t\\t * 3. Remove all elements of the list with indices insIdx<=i<nxtIdx.\\n\\t\\t\\t * \\n\\t\\t\\t * 4. Merge new with list.get(insIdx-1) or list.get(nxtIdx) or both.\\n\\t\\t\\t */\\n\\n\\t\\t\\tint n = intervals.size();\\n\\t\\t\\tif (n == 0) {\\n\\t\\t\\t\\tintervals.add(newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint low = 0, high = n - 1, mid = 0;\\n\\t\\t\\tint temp, target = newInterval.start;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).start;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// insIdx = the index where new interval to be inserted\\n\\t\\t\\tint insIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval pre = (insIdx == 0) ? null : intervals.get(insIdx - 1);\\n\\t\\t\\t// 0<=insIdx<=n, pre=[insIdx-1], pre.start<new.start\\n\\n\\t\\t\\tlow = insIdx;\\n\\t\\t\\thigh = n - 1;\\n\\t\\t\\ttarget = newInterval.end;\\n\\t\\t\\twhile (low <= high) {\\n\\t\\t\\t\\tmid = (low + high) / 2;\\n\\t\\t\\t\\ttemp = intervals.get(mid).end;\\n\\t\\t\\t\\tif (temp == target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (temp < target)\\n\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// nxtIdx= the next index after the inserted new interval\\n\\t\\t\\tint nxtIdx = (low <= high) ? mid : low;\\n\\t\\t\\tInterval nxt = (nxtIdx == n) ? null : intervals.get(nxtIdx);\\n\\t\\t\\t// insIdx<=nxtIdx<=n, nxt=[nxtIdx], nxt.end>=new.end\\n\\n\\t\\t\\t// [0]...[insIdx-1] <--> [insIdx]...[nxtIdx-1][nxtIdx]...[n]\\n\\t\\t\\tintervals.subList(insIdx, nxtIdx).clear();\\n\\n\\t\\t\\t// check whether newInterval can be merged with pre or nxt\\n\\t\\t\\tboolean isMerged = false, isMerged2 = false;\\n\\t\\t\\tif (insIdx > 0 && pre.end >= newInterval.start) {\\n\\t\\t\\t\\tpre.end = Math.max(pre.end, newInterval.end);\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (nxtIdx < n && newInterval.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = Math.min(nxt.start, newInterval.start);\\n\\t\\t\\t\\tisMerged2 = isMerged;\\n\\t\\t\\t\\tisMerged = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!isMerged) {\\n\\t\\t\\t\\tintervals.add(insIdx, newInterval);\\n\\t\\t\\t\\treturn intervals;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// merged with pre or nxt or both, deal with the both case\\n\\t\\t\\tif (isMerged2 && pre.end >= nxt.start) {\\n\\t\\t\\t\\tnxt.start = pre.start; // pre.start < new.start, nxt.start;\\n\\t\\t\\t\\tintervals.remove(insIdx - 1); // remove pre\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn intervals;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 844481,
                "title": "c-clean-and-commented-with-example-explained-o-n-time",
                "content": "****Explaination****\\n- **1st While loop** to put all intervals that are to the left of the inserted interval. \\n-  **2nd While loop to** merge all intervals that intersect with the inserted interval.\\n-  **3rd While loop** put all intervals that are to the right of the inserted interval.\\n\\n****Example****\\nGiven [1,2],[3,5],[6,7],[8,10],[12,14], insert and merge [4,9] in as [1,2],[3,10],[12,14]\\n![image](https://assets.leetcode.com/users/images/58677d7a-175e-4f97-ab36-44d01d3195e5_1599985042.67296.png)\\n\\n****Code****\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> sol;\\n        if(!size(intervals) and !size(newInterval)){\\n            sol.push_back(newInterval);\\n            return sol;\\n        }\\n        if(!size(intervals)){\\n            sol.push_back(newInterval);\\n            return(sol);\\n        }\\n        int i=0;\\n        int start=newInterval[0];\\n        int end=newInterval[1];\\n\\t\\t//while #1 put all intervals that are to the left of the inserted interval. \\n                while(i<size(intervals) and  intervals[i][1]<newInterval[0]) \\n                    sol.push_back(intervals[i++]);\\n\\t\\t//while #2 merge all intervals that intersect with the inserted interval.\\n                while(i<size(intervals) and intervals[i][0]<=end){\\n                    start = min(start, intervals[i][0]);\\n                    end = max(end, intervals[i][1]);\\n                    i++;\\n                }\\n                sol.push_back({start,end});\\n\\t//while #3 put all intervals that are to the right of the inserted interval.\\n            while(i<size(intervals))\\n                sol.push_back(intervals[i++]);\\n        return sol;          \\n    }\\n};\\n```\\n****Complexity****\\nO(n)",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> sol;\\n        if(!size(intervals) and !size(newInterval)){\\n            sol.push_back(newInterval);\\n            return sol;\\n        }\\n        if(!size(intervals)){\\n            sol.push_back(newInterval);\\n            return(sol);\\n        }\\n        int i=0;\\n        int start=newInterval[0];\\n        int end=newInterval[1];\\n\\t\\t//while #1 put all intervals that are to the left of the inserted interval. \\n                while(i<size(intervals) and  intervals[i][1]<newInterval[0]) \\n                    sol.push_back(intervals[i++]);\\n\\t\\t//while #2 merge all intervals that intersect with the inserted interval.\\n                while(i<size(intervals) and intervals[i][0]<=end){\\n                    start = min(start, intervals[i][0]);\\n                    end = max(end, intervals[i][1]);\\n                    i++;\\n                }\\n                sol.push_back({start,end});\\n\\t//while #3 put all intervals that are to the right of the inserted interval.\\n            while(i<size(intervals))\\n                sol.push_back(intervals[i++]);\\n        return sol;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844417,
                "title": "python-simple-explained-solution-o-n-time-o-1-space-faster-than-99",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\n        # edge case #1: no intervals in original list\\n        if len(intervals) == 0:\\n            return [newInterval]\\n\\t\\t\\t\\n        # edge case #2: new interval goes in the end of the list with no overlap\\n        if intervals[-1][1] < newInterval[0]:\\n            return intervals + [newInterval]\\n\\t\\t\\t\\n        # edge case #3: new interval goes in the beginning of the list with no overlap\\n        if newInterval[1] < intervals[0][0]:\\n            return [newInterval] + intervals\\n\\t\\t\\t\\n        res = []\\n        i = 0\\n        for curr_interval in intervals:\\n            # new interval doesn\\'t overlap\\n            if curr_interval[1] < newInterval[0]:\\n                res.append(curr_interval)\\n            else:\\n                first = min(curr_interval[0], newInterval[0])\\n                last = newInterval[1]\\n                i = intervals.index(curr_interval)\\n\\t\\t\\t\\t\\n                # while new interval overlaps:\\n                while i < len(intervals) and last >= intervals[i][0]:\\n                    last = max(intervals[i][1], newInterval[1])\\n                    i+=1\\n                res.append([first, last])\\n                break\\n\\t\\t\\t\\t\\n        # add the rest\\n        res += intervals[i:]\\n        return res\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\n        # edge case #1: no intervals in original list\\n        if len(intervals) == 0:\\n            return [newInterval]\\n\\t\\t\\t\\n        # edge case #2: new interval goes in the end of the list with no overlap\\n        if intervals[-1][1] < newInterval[0]:\\n            return intervals + [newInterval]\\n\\t\\t\\t\\n        # edge case #3: new interval goes in the beginning of the list with no overlap\\n        if newInterval[1] < intervals[0][0]:\\n            return [newInterval] + intervals\\n\\t\\t\\t\\n        res = []\\n        i = 0\\n        for curr_interval in intervals:\\n            # new interval doesn\\'t overlap\\n            if curr_interval[1] < newInterval[0]:\\n                res.append(curr_interval)\\n            else:\\n                first = min(curr_interval[0], newInterval[0])\\n                last = newInterval[1]\\n                i = intervals.index(curr_interval)\\n\\t\\t\\t\\t\\n                # while new interval overlaps:\\n                while i < len(intervals) and last >= intervals[i][0]:\\n                    last = max(intervals[i][1], newInterval[1])\\n                    i+=1\\n                res.append([first, last])\\n                break\\n\\t\\t\\t\\t\\n        # add the rest\\n        res += intervals[i:]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134823,
                "title": "python-6-lines-easy-to-understand-60-ms-beats-96",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        new, i = [], 0\\n        for i, it in enumerate(intervals):\\n            if newInterval.end < it.start: i -= 1; break\\n            elif it.end < newInterval.start: new += it,\\n            else: newInterval.start, newInterval.end = min(it.start, newInterval.start), max(it.end, newInterval.end)\\n        return new + [newInterval] + intervals[i + 1:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, newInterval):\\n        new, i = [], 0\\n        for i, it in enumerate(intervals):\\n            if newInterval.end < it.start: i -= 1; break\\n            elif it.end < newInterval.start: new += it,\\n            else: newInterval.start, newInterval.end = min(it.start, newInterval.start), max(it.end, newInterval.end)\\n        return new + [newInterval] + intervals[i + 1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21828,
                "title": "my-ac-java-in-place-solution",
                "content": "    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            if(intervals.isEmpty()){\\n                intervals.add(newInterval);\\n                return intervals;\\n            }\\n            \\n            int start = newInterval.start;\\n            int end = newInterval.end;\\n            ListIterator<Interval> li = intervals.listIterator();\\n            boolean inserted = false;\\n            while(li.hasNext()){\\n                Interval itv = li.next();\\n                if(start <= itv.end){\\n                    if(end < itv.start){ //newInterval does not overlap with current itv, time to insert\\n                        li.remove();\\n                        li.add(new Interval(start, end));\\n                        li.add(itv);\\n                        inserted = true;\\n                        break;\\n                    }\\n                    \\n                    // still some overlap so compare start & end\\n                    start = Math.min(start, itv.start);\\n                    end = Math.max(end, itv.end);\\n                    li.remove();\\n                }\\n            }\\n            \\n            if(!inserted){\\n                intervals.add(new Interval(start, end));\\n            }\\n            \\n            return intervals;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            if(intervals.isEmpty()){\\n                intervals.add(newInterval);\\n                return intervals;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3057760,
                "title": "java-99th-percentile-one-pass-explained-article",
                "content": "![image.png](https://assets.leetcode.com/users/images/79f9f39a-f625-4707-9c7b-dcbb13533e2b_1673854957.9331577.png)\\n\\n\\n# Intuition\\nWe are given a non-overlapping, sorted intervals array. These properties are essential because we can utilize them to solve the problem in one pass.\\n\\nLet\\'s visualize a few possibilities that we may have. Imagine these given intervals:\\n```\\n    [     ] [ ] [  ]\\n```\\nImagine them on an x-axis line.\\n\\nWe may need to insert the following intervals:\\n```\\n    [     ] [ ] [  ]\\n |           |   \\n\\n | |\\n                         | |\\n\\n```\\n\\nThese are three situations where we may need to insert a new interval.\\n\\nThe first one overlaps multiple given intervals, the second one doesn\\'t overlap and should be inserted in the beginning, and the last is non-overlapping and should be inserted in the end.\\n\\nWe either need to *merge* the interval with one of the given intervals (or multiple), or insert it.\\n\\n*If we merge an interval, we don\\'t impact the intervals previously added*, because they are sorted. `nextIntervalEnd > previousStart`, which is always true because of non-overlapping sorted property.\\n\\nTherefore we need to merge intervals *until* we find an interval that started after the merged interval.\\n\\nIf the given interval doesn\\'t overlap with the merged interval, we simply add it to the result array.\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> mergedIntervals = new ArrayList<>();\\n        int[] merged = new int[] {newInterval[0], newInterval[1]};\\n        boolean isInserted = false;\\n\\n        for (int[] interval : intervals) {\\n            if(interval[0] > merged[1]) {\\n                if(!isInserted) {\\n                    mergedIntervals.add(merged);\\n                    isInserted = true;\\n                }\\n                mergedIntervals.add(interval);\\n                \\n            } else {\\n                // does intersect\\n                if(doesIntersect(merged, interval)) {\\n                    merged[0] = Math.min(merged[0], interval[0]);\\n                    merged[1] = Math.max(merged[1], interval[1]);\\n                } else {\\n                    // not intersecting\\n                    mergedIntervals.add(interval);\\n                }\\n                \\n                \\n            }\\n        }\\n\\n        // new interval is at the end\\n        if(!isInserted) {\\n            mergedIntervals.add(merged);\\n            isInserted = true;\\n        }\\n\\n        // Java specific to copy to arr[][]...\\n        int[][] res = new int[mergedIntervals.size()][2];\\n        for(int i = 0; i < mergedIntervals.size(); i++) {\\n            res[i] = mergedIntervals.get(i);\\n        }\\n        return res;\\n\\n    }\\n\\n    private boolean doesIntersect(int[] intervalA, int[] intervalB) {\\n        return intervalA[0] <= intervalB[1] && intervalB[0] <= intervalA[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    [     ] [ ] [  ]\\n```\n```\\n    [     ] [ ] [  ]\\n |           |   \\n\\n | |\\n                         | |\\n\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> mergedIntervals = new ArrayList<>();\\n        int[] merged = new int[] {newInterval[0], newInterval[1]};\\n        boolean isInserted = false;\\n\\n        for (int[] interval : intervals) {\\n            if(interval[0] > merged[1]) {\\n                if(!isInserted) {\\n                    mergedIntervals.add(merged);\\n                    isInserted = true;\\n                }\\n                mergedIntervals.add(interval);\\n                \\n            } else {\\n                // does intersect\\n                if(doesIntersect(merged, interval)) {\\n                    merged[0] = Math.min(merged[0], interval[0]);\\n                    merged[1] = Math.max(merged[1], interval[1]);\\n                } else {\\n                    // not intersecting\\n                    mergedIntervals.add(interval);\\n                }\\n                \\n                \\n            }\\n        }\\n\\n        // new interval is at the end\\n        if(!isInserted) {\\n            mergedIntervals.add(merged);\\n            isInserted = true;\\n        }\\n\\n        // Java specific to copy to arr[][]...\\n        int[][] res = new int[mergedIntervals.size()][2];\\n        for(int i = 0; i < mergedIntervals.size(); i++) {\\n            res[i] = mergedIntervals.get(i);\\n        }\\n        return res;\\n\\n    }\\n\\n    private boolean doesIntersect(int[] intervalA, int[] intervalB) {\\n        return intervalA[0] <= intervalB[1] && intervalB[0] <= intervalA[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643451,
                "title": "explained-simple-and-clear-python3-code",
                "content": "\\n# Approach\\nThe solution follows the logic of iterating through the intervals to find the correct position to insert the new interval while maintaining the sorted order. After insertion, it iterates over the modified array to merge any overlapping intervals by updating the end time of the previous interval if necessary. Finally, it returns the modified array with the new interval inserted and any overlapping intervals merged.\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, inv: List[List[int]], nw: List[int]) -> List[List[int]]:\\n        #insert nw\\n        test=True\\n        for i in range(len(inv)):\\n            if inv[i][0]>nw[0]:\\n                test=False\\n                inv.insert(i,nw)\\n        if test:\\n            inv.append(nw)\\n\\n        i=1\\n        while i<len(inv):\\n            if inv[i-1][1]>=inv[i][0]:\\n                inv[i-1][1]=max (inv[i-1][1],inv[i][1])\\n                inv.pop(i)\\n            else:\\n                i+=1\\n            \\n        return inv\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, inv: List[List[int]], nw: List[int]) -> List[List[int]]:\\n        #insert nw\\n        test=True\\n        for i in range(len(inv)):\\n            if inv[i][0]>nw[0]:\\n                test=False\\n                inv.insert(i,nw)\\n        if test:\\n            inv.append(nw)\\n\\n        i=1\\n        while i<len(inv):\\n            if inv[i-1][1]>=inv[i][0]:\\n                inv[i-1][1]=max (inv[i-1][1],inv[i][1])\\n                inv.pop(i)\\n            else:\\n                i+=1\\n            \\n        return inv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056720,
                "title": "java-short-beats-99-26-priorityqueue",
                "content": "# One Pass (Beats 99.26%) : Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        /*  \\n            Test Case 1.\\n            newInterval : [2,5]\\n            intervals : [[1,3],[6,9]]\\n                                 ^\\n        */\\n        for (int[] interval : intervals) {\\n            if (interval[1] < newInterval[0]) {\\n                list.add(interval);\\n\\n                // second interval[1] =>  [6, 9] > [1, 5]\\n            } else if (interval[0] > newInterval[1]) {\\n                list.add(new int[] {newInterval[0], newInterval[1]}); // added (1,5)\\n                newInterval = interval; // (6,9)\\n\\n                // first interval[0] => [1, 3] >= [2,5]\\n            } else if (interval[1] >= newInterval[0]) {\\n                // newInterval = [1, 5]\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        list.add(newInterval); // added (6, 9) => list: [(1, 5), (6, 9)]\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\n# PriorityQueue : Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] interval : intervals) pq.add(interval);\\n        pq.add(newInterval);\\n        \\n        List<int[]> res = new ArrayList<>(); \\n        int[] prev = pq.poll();        \\n        while (!pq.isEmpty()) {             \\n            int[] cur = pq.poll();\\n            if (prev[1] >= cur[0]) {\\n                prev = new int[]{prev[0], Math.max(cur[1], prev[1])};\\n            } else {\\n                res.add(prev);\\n                prev = cur;\\n            }\\n        }\\n        res.add(prev);       \\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        /*  \\n            Test Case 1.\\n            newInterval : [2,5]\\n            intervals : [[1,3],[6,9]]\\n                                 ^\\n        */\\n        for (int[] interval : intervals) {\\n            if (interval[1] < newInterval[0]) {\\n                list.add(interval);\\n\\n                // second interval[1] =>  [6, 9] > [1, 5]\\n            } else if (interval[0] > newInterval[1]) {\\n                list.add(new int[] {newInterval[0], newInterval[1]}); // added (1,5)\\n                newInterval = interval; // (6,9)\\n\\n                // first interval[0] => [1, 3] >= [2,5]\\n            } else if (interval[1] >= newInterval[0]) {\\n                // newInterval = [1, 5]\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        list.add(newInterval); // added (6, 9) => list: [(1, 5), (6, 9)]\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] interval : intervals) pq.add(interval);\\n        pq.add(newInterval);\\n        \\n        List<int[]> res = new ArrayList<>(); \\n        int[] prev = pq.poll();        \\n        while (!pq.isEmpty()) {             \\n            int[] cur = pq.poll();\\n            if (prev[1] >= cur[0]) {\\n                prev = new int[]{prev[0], Math.max(cur[1], prev[1])};\\n            } else {\\n                res.add(prev);\\n                prev = cur;\\n            }\\n        }\\n        res.add(prev);       \\n        return res.toArray(new int[res.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038557,
                "title": "java-greedy",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for(int[] in: intervals){\\n            if(in[1] < newInterval[0]){\\n                ans.add(in);\\n            }\\n            else if(in[0] > newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = in;\\n            }\\n            else{\\n                newInterval[0] = Math.min(newInterval[0], in[0]);\\n                newInterval[1] = Math.max(newInterval[1], in[1]);\\n            }\\n        }\\n        \\n        ans.add(newInterval);\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for(int[] in: intervals){\\n            if(in[1] < newInterval[0]){\\n                ans.add(in);\\n            }\\n            else if(in[0] > newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = in;\\n            }\\n            else{\\n                newInterval[0] = Math.min(newInterval[0], in[0]);\\n                newInterval[1] = Math.max(newInterval[1], in[1]);\\n            }\\n        }\\n        \\n        ans.add(newInterval);\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804462,
                "title": "java-99-solution-one-pass-o-n-with-comments",
                "content": "\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> l = new ArrayList<>();\\n        // 1. if an interval end before newInterval start, it can be added to output directly.\\n        // 2. if an interval overlapping with new Interval, merge it into new Interval. overlapping if an interval end after new Interval start and start before new Interval end.\\n        // 3  after all overlapping intervals processed, add the merged new Interval (or the original new interval if no interval meet #2 condition, i.e. no overlap)\\n        // 4. add the rest non overlapping intervals. all the rest have start after new interval end.\\n        \\n        int i = 0, N = intervals.length;\\n        while (i < N && intervals[i][1] < newInterval[0]) // #1\\n            l.add(intervals[i++]);\\n        \\n        while (i < N && intervals[i][0] <= newInterval[1]) { // #2\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i++][1]);\\n        }\\n        \\n        l.add(newInterval); // #3       \\n        while (i < N) l.add(intervals[i++]);  // #4\\n        return l.toArray(new int[][]{});\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> l = new ArrayList<>();\\n        // 1. if an interval end before newInterval start, it can be added to output directly.\\n        // 2. if an interval overlapping with new Interval, merge it into new Interval. overlapping if an interval end after new Interval start and start before new Interval end.\\n        // 3  after all overlapping intervals processed, add the merged new Interval (or the original new interval if no interval meet #2 condition, i.e. no overlap)\\n        // 4. add the rest non overlapping intervals. all the rest have start after new interval end.\\n        \\n        int i = 0, N = intervals.length;\\n        while (i < N && intervals[i][1] < newInterval[0]) // #1\\n            l.add(intervals[i++]);\\n        \\n        while (i < N && intervals[i][0] <= newInterval[1]) { // #2\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i++][1]);\\n        }\\n        \\n        l.add(newInterval); // #3       \\n        while (i < N) l.add(intervals[i++]);  // #4\\n        return l.toArray(new int[][]{});\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 703958,
                "title": "javascript-explanation",
                "content": "* append new interval to list of intervals\\n* sort by beg time\\n* then do merge intervals \\n\\n(I know sorting will raise time to O(nlogn) and there are some solutions out there that yield O(n))\\n\\n```javascript\\nconst insert = (intervals, newInterval) => {\\n    if(!intervals) return [];\\n    const ans = new Array();\\n    \\n    intervals.push(newInterval);\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    if(intervals.length === 1) return intervals;\\n    const prev = [intervals[0][0], intervals[0][1]];\\n    for(let i = 1; i < intervals.length; i++) {\\n        const curr = intervals[i];\\n        if(isOverlap(prev, curr)) {\\n            prev[0] = Math.min(prev[0], curr[0]);\\n            prev[1] = Math.max(prev[1], curr[1]);\\n        } else {\\n            ans.push([...prev]);\\n            prev[0] = curr[0];\\n            prev[1] = curr[1];\\n        }\\n        \\n        if(i === intervals.length - 1) ans.push([...prev])\\n    }\\n    \\n    return ans;\\n};\\n\\nconst isOverlap = (prev, curr) => {\\n    return  prev[1] >= curr[0] && prev[1] <= curr[1]\\n            || prev[0] >= curr[0] && prev[0] <= curr[1]\\n            || prev[0] <= curr[0] && prev[1] >= curr[1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst insert = (intervals, newInterval) => {\\n    if(!intervals) return [];\\n    const ans = new Array();\\n    \\n    intervals.push(newInterval);\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    if(intervals.length === 1) return intervals;\\n    const prev = [intervals[0][0], intervals[0][1]];\\n    for(let i = 1; i < intervals.length; i++) {\\n        const curr = intervals[i];\\n        if(isOverlap(prev, curr)) {\\n            prev[0] = Math.min(prev[0], curr[0]);\\n            prev[1] = Math.max(prev[1], curr[1]);\\n        } else {\\n            ans.push([...prev]);\\n            prev[0] = curr[0];\\n            prev[1] = curr[1];\\n        }\\n        \\n        if(i === intervals.length - 1) ans.push([...prev])\\n    }\\n    \\n    return ans;\\n};\\n\\nconst isOverlap = (prev, curr) => {\\n    return  prev[1] >= curr[0] && prev[1] <= curr[1]\\n            || prev[0] >= curr[0] && prev[0] <= curr[1]\\n            || prev[0] <= curr[0] && prev[1] >= curr[1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21813,
                "title": "short-simple-o-n-in-place-java-solution-with-explanation",
                "content": "The idea is to look at each interval in the list. If it intersects with newInterval then merge it to newInterval and delete it. In the end add newInterval back to its corresponding place.\\n\\n    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            ListIterator<Interval> i = intervals.listIterator();\\n            Interval in;\\n            while (i.hasNext()) {\\n                in = i.next();\\n                if (newInterval.end < in.start) {\\n                    i.previous();\\n                    break;\\n                }\\n                if (in.start <= newInterval.end && newInterval.start <= in.end) {\\n                    newInterval.start = Math.min(newInterval.start, in.start);\\n                    newInterval.end = Math.max(newInterval.end, in.end);\\n                    i.previous();\\n                    i.remove();\\n                }\\n            }\\n            i.add(newInterval);\\n            return intervals;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            ListIterator<Interval> i = intervals.listIterator();\\n            Interval in;\\n            while (i.hasNext()) {\\n                in = i.next();\\n                if (newInterval.end < in.start) {\\n                    i.previous();\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3992539,
                "title": "best-solution-in-c-100-easily-understandable",
                "content": "# Approach\\nExplained in the code using comments\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n\\n        //sort using the same logic as Merge Intervals question\\n        sort(intervals.begin(), intervals.end()); \\n\\n        for(auto it: intervals)\\n        {\\n            //if interval before is smaller add that\\n            if(it[1] < newInterval[0]) \\n                ans.push_back(it);\\n\\n            //if the newInterval is smaller add that\\n            else if(newInterval[1] < it[0]) \\n            {\\n                ans.push_back(newInterval);\\n                newInterval = it;\\n            }\\n            \\n            //if newInterval lies within the currentIntervals\\n            else \\n            {\\n                newInterval[0] = min(newInterval[0], it[0]);\\n                newInterval[1] = max(newInterval[1], it[1]);\\n            } \\n        }\\n\\n        //add the last Interval\\n        ans.push_back(newInterval);\\n\\n        return ans;                                                                          \\n    }\\n};\\n```\\n\\n![pleaseupvotye.jpeg](https://assets.leetcode.com/users/images/e1cd0d4f-0255-4afa-8f6e-b5fff843647b_1693664013.5913265.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n\\n        //sort using the same logic as Merge Intervals question\\n        sort(intervals.begin(), intervals.end()); \\n\\n        for(auto it: intervals)\\n        {\\n            //if interval before is smaller add that\\n            if(it[1] < newInterval[0]) \\n                ans.push_back(it);\\n\\n            //if the newInterval is smaller add that\\n            else if(newInterval[1] < it[0]) \\n            {\\n                ans.push_back(newInterval);\\n                newInterval = it;\\n            }\\n            \\n            //if newInterval lies within the currentIntervals\\n            else \\n            {\\n                newInterval[0] = min(newInterval[0], it[0]);\\n                newInterval[1] = max(newInterval[1], it[1]);\\n            } \\n        }\\n\\n        //add the last Interval\\n        ans.push_back(newInterval);\\n\\n        return ans;                                                                          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057457,
                "title": "simple-c-beats-99-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all if we think of approach so we can do this by using linear search or Binary search . So we know  Bianry search has logn timpecomplexity but through binary search we find where to insert in logn but we have to merge with others and insert also that will take O(n) so there is no need of binary search we can do a linear serach as well beacuse both will be O(n).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nComing to Approach first we can think of many conditions but We only need to check three conditions that are :\\n- Insert those intervals who are not overlapping and are less than our new Interval \\n- Now check if our new Interval is overalpping wiht any other interval(s) so either insert if not overlapping or merge if overallping with others\\n- Now insert those who are left i.e those intervals which are greater than new Interval\\n*These condtions can easily be checked using a while loop*\\nFor second condition when the inertvals are overlapping we can do that by :\\n` (a,b)  and (c,d) the  new interval: [min(a,c),max(b,d)]`\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inv, vector<int>& newI) {\\n       vector<vector<int>>ans;\\n       int n=inv.size();\\n        int i=0;\\n        // insert those intervals which are not overlapping and less than newInterval\\n       while(i<n and inv[i][1]<newI[0]){\\n           ans.push_back(inv[i++]);\\n       }\\n       // now insert the new Interval or merge the interval if neccessary\\n\\n       while(i<n and newI[1]>=inv[i][0]){\\n           newI[0]=min(newI[0],inv[i][0]);\\n           newI[1]=max(newI[1],inv[i][1]);\\n           i++;\\n       }\\n       ans.push_back(newI);\\n      // insert thse intervals which are left or greater than the newInterval\\n      while(i<n ){\\n          ans.push_back(inv[i++]);\\n      }\\n       return ans; \\n    }\\n};\\n```\\n**Please upVote If Found HelpFull \\uD83D\\uDD3C**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inv, vector<int>& newI) {\\n       vector<vector<int>>ans;\\n       int n=inv.size();\\n        int i=0;\\n        // insert those intervals which are not overlapping and less than newInterval\\n       while(i<n and inv[i][1]<newI[0]){\\n           ans.push_back(inv[i++]);\\n       }\\n       // now insert the new Interval or merge the interval if neccessary\\n\\n       while(i<n and newI[1]>=inv[i][0]){\\n           newI[0]=min(newI[0],inv[i][0]);\\n           newI[1]=max(newI[1],inv[i][1]);\\n           i++;\\n       }\\n       ans.push_back(newI);\\n      // insert thse intervals which are left or greater than the newInterval\\n      while(i<n ){\\n          ans.push_back(inv[i++]);\\n      }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681746,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let result = []\\n    \\n    for(let i = 0; i < intervals.length; i++){\\n        //not overlapping with current interval\\n        if(newInterval[1] < intervals[i][0]){\\n            result.push(newInterval)\\n            result.push(...intervals.slice(i))\\n            return result\\n        }else if(newInterval[0] > intervals[i][1]){\\n            result.push(intervals[i])\\n        }else{\\n            //is overlapping with current interval\\n            newInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]\\n            //extend interval if needed\\n        }\\n    }\\n    result.push(newInterval)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let result = []\\n    \\n    for(let i = 0; i < intervals.length; i++){\\n        //not overlapping with current interval\\n        if(newInterval[1] < intervals[i][0]){\\n            result.push(newInterval)\\n            result.push(...intervals.slice(i))\\n            return result\\n        }else if(newInterval[0] > intervals[i][1]){\\n            result.push(intervals[i])\\n        }else{\\n            //is overlapping with current interval\\n            newInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]\\n            //extend interval if needed\\n        }\\n    }\\n    result.push(newInterval)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581680,
                "title": "python-easy-solution-two-approaches",
                "content": "\\t# 1st Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\tintervals.append(newInterval)\\n\\t\\t\\tintervals.sort(key=lambda x: x[0])\\n\\t\\t\\tstart = intervals[0][0]\\n\\t\\t\\tend = intervals[0][1]\\n\\t\\t\\ti = 1\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tif intervals[i][0] <= end:\\n\\t\\t\\t\\t\\tend = max(end, intervals[i][1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append([start, end])\\n\\t\\t\\t\\t\\tstart = intervals[i][0]\\n\\t\\t\\t\\t\\tend = intervals[i][1]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append([start, end])\\n\\t\\t\\treturn res\\n\\n\\t# 2nd Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\ti = 0\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals) and intervals[i][1] < newInterval[0]:\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\twhile i < len(intervals) and intervals[i][0] <= newInterval[1]:\\n\\t\\t\\t\\tnewInterval[0] = min(intervals[i][0], newInterval[0])\\n\\t\\t\\t\\tnewInterval[1] = max(intervals[i][1], newInterval[1])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append(newInterval)\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# 1st Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\tintervals.append(newInterval)\\n\\t\\t\\tintervals.sort(key=lambda x: x[0])\\n\\t\\t\\tstart = intervals[0][0]\\n\\t\\t\\tend = intervals[0][1]\\n\\t\\t\\ti = 1\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tif intervals[i][0] <= end:\\n\\t\\t\\t\\t\\tend = max(end, intervals[i][1])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append([start, end])\\n\\t\\t\\t\\t\\tstart = intervals[i][0]\\n\\t\\t\\t\\t\\tend = intervals[i][1]\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append([start, end])\\n\\t\\t\\treturn res\\n\\n\\t# 2nd Approach:\\n\\tclass Solution:\\n\\t\\tdef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\t\\t\\ti = 0\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i < len(intervals) and intervals[i][1] < newInterval[0]:\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\twhile i < len(intervals) and intervals[i][0] <= newInterval[1]:\\n\\t\\t\\t\\tnewInterval[0] = min(intervals[i][0], newInterval[0])\\n\\t\\t\\t\\tnewInterval[1] = max(intervals[i][1], newInterval[1])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\tres.append(newInterval)\\n\\t\\t\\twhile i < len(intervals):\\n\\t\\t\\t\\tres.append(intervals[i])\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1506902,
                "title": "java-easy-to-understand-o-n-code-with-comments",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Handling edge case when intervals is empty\\n        if(intervals.length == 0){\\n            if(newInterval.length != 0)\\n                result.add(newInterval);\\n            return result.toArray(new int[result.size()][]);\\n        }\\n        \\n        int i=0;\\n        \\n        // 1. Copy until overlap is not found\\n        while(i < intervals.length && newInterval[0] > intervals[i][1])\\n            result.add(intervals[i++]);\\n        \\n        // 2. Update newInterval by comparing it with overlapped intervals\\n        while(i < intervals.length && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        \\n        // 3. Add the updated newInterval\\n        result.add(newInterval);\\n        \\n        // 4. Copy the remaining in the intervals list to the final result\\n        while(i < intervals.length)\\n            result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> result = new ArrayList<>();\\n        \\n        // Handling edge case when intervals is empty\\n        if(intervals.length == 0){\\n            if(newInterval.length != 0)\\n                result.add(newInterval);\\n            return result.toArray(new int[result.size()][]);\\n        }\\n        \\n        int i=0;\\n        \\n        // 1. Copy until overlap is not found\\n        while(i < intervals.length && newInterval[0] > intervals[i][1])\\n            result.add(intervals[i++]);\\n        \\n        // 2. Update newInterval by comparing it with overlapped intervals\\n        while(i < intervals.length && newInterval[1] >= intervals[i][0]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        \\n        // 3. Add the updated newInterval\\n        result.add(newInterval);\\n        \\n        // 4. Copy the remaining in the intervals list to the final result\\n        while(i < intervals.length)\\n            result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261009,
                "title": "zero-bullshit-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 844384,
                "title": "java-greedily-absorb-overlapping-intervals-o-n-time-o-1-extra-space-explained",
                "content": "```\\n\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        int i=0;\\n\\t\\t/* Add all intervals ending earlier than the start of newInterval */\\n        while(i < intervals.length && intervals[i][1] < newInterval[0]){\\n            result.add(intervals[i++]);\\n        }\\n        \\n\\t\\t/* Greedily absorb any interval that overlaps with newInterval */\\n        while(i < intervals.length && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n\\t\\t/* Add newInterval to the result list */\\n        result.add(newInterval);\\n\\t\\t\\n\\t\\t/* Add any remaining intervals. These start later than the end\\n\\t\\t   time of newInterval */\\n        while(i < intervals.length) result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        int i=0;\\n\\t\\t/* Add all intervals ending earlier than the start of newInterval */\\n        while(i < intervals.length && intervals[i][1] < newInterval[0]){\\n            result.add(intervals[i++]);\\n        }\\n        \\n\\t\\t/* Greedily absorb any interval that overlaps with newInterval */\\n        while(i < intervals.length && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);\\n            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);\\n            i++;\\n        }\\n        \\n\\t\\t/* Add newInterval to the result list */\\n        result.add(newInterval);\\n\\t\\t\\n\\t\\t/* Add any remaining intervals. These start later than the end\\n\\t\\t   time of newInterval */\\n        while(i < intervals.length) result.add(intervals[i++]);\\n        \\n        return result.toArray(new int[result.size()][]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 530137,
                "title": "hard-problem-c-easy-solution",
                "content": "Not sure why this problem is marked as Hard, it\\'s on the \\'easy\\' side of Easy.\\n```cpp\\nvector<vector<int>> insert(vector<vector<int>>& ints, vector<int>& ni, int i = 0) {\\n    vector<vector<int>> res;\\n    for (; i < ints.size() && ints[i][0] <= ni[1]; ++i) {\\n        if (ints[i][1] < ni[0])\\n            res.push_back(ints[i]);\\n        else {\\n            ni[0] = min(ni[0], ints[i][0]);\\n            ni[1] = max(ni[1], ints[i][1]);\\n        }\\n    }\\n    res.push_back(ni);\\n    res.insert(end(res), begin(ints) + i, end(ints));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<vector<int>> insert(vector<vector<int>>& ints, vector<int>& ni, int i = 0) {\\n    vector<vector<int>> res;\\n    for (; i < ints.size() && ints[i][0] <= ni[1]; ++i) {\\n        if (ints[i][1] < ni[0])\\n            res.push_back(ints[i]);\\n        else {\\n            ni[0] = min(ni[0], ints[i][0]);\\n            ni[1] = max(ni[1], ints[i][1]);\\n        }\\n    }\\n    res.push_back(ni);\\n    res.insert(end(res), begin(ints) + i, end(ints));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395709,
                "title": "beautiful-rust-solution-o-n-0-ms",
                "content": "As straightforward as possible.\\nAvoided most of heap memory allocation in method.\\n\\n```\\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        use std::cmp::{min, max};\\n        let mut less = vec![];\\n        let mut more = vec![];\\n        let mut start = new_interval[0];\\n        let mut end = new_interval[1];\\n        \\n        for curr in intervals{\\n            if curr[1] < new_interval[0]{\\n                less.push(curr);\\n            }\\n            else if curr[0]>new_interval[1]{\\n                more.push(curr);\\n            }\\n            else {\\n                start = min(curr[0], start);\\n                end = max(curr[1], end);\\n            }\\n        }\\n        less.push(vec![start, end]);\\n        less.append(&mut more);\\n        less\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\\n        use std::cmp::{min, max};\\n        let mut less = vec![];\\n        let mut more = vec![];\\n        let mut start = new_interval[0];\\n        let mut end = new_interval[1];\\n        \\n        for curr in intervals{\\n            if curr[1] < new_interval[0]{\\n                less.push(curr);\\n            }\\n            else if curr[0]>new_interval[1]{\\n                more.push(curr);\\n            }\\n            else {\\n                start = min(curr[0], start);\\n                end = max(curr[1], end);\\n            }\\n        }\\n        less.push(vec![start, end]);\\n        less.append(&mut more);\\n        less\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289422,
                "title": "simple-java-solution-with-new-signature-1ms",
                "content": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        for (int[] interval : intervals) {\\n\\t\\t   // If not overlapped, we always add the smaller one to the result and point newInterval to the larger one.\\n            if (newInterval[1] < interval[0]) {\\n                result.add(newInterval);\\n                newInterval = interval;\\n            } else if (newInterval[0] > interval[1]) {\\n                result.add(interval);\\n            } else {\\n\\t\\t\\t// If overlapped, update the newInterval\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        result.add(newInterval);\\n        return result.toArray(new int[][]{});\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        for (int[] interval : intervals) {\\n\\t\\t   // If not overlapped, we always add the smaller one to the result and point newInterval to the larger one.\\n            if (newInterval[1] < interval[0]) {\\n                result.add(newInterval);\\n                newInterval = interval;\\n            } else if (newInterval[0] > interval[1]) {\\n                result.add(interval);\\n            } else {\\n\\t\\t\\t// If overlapped, update the newInterval\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        result.add(newInterval);\\n        return result.toArray(new int[][]{});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21595,
                "title": "c-clean-code",
                "content": "**Steps**\\n1. add all intervals smaller than newitv to the new array\\n2. merge all intervals overlap with newitv, then add the merged interval to the new array;\\n3. add all intervals that is leftover (no overlap) into the new array;\\n```\\nclass Solution {\\npublic:\\n    vector<Interval> insert(vector<Interval>& a, Interval newitv) {\\n        vector<Interval> res;\\n        int i = 0;\\n        for (; i < a.size() && a[i].end < newitv.start; i++) res.push_back(a[i]);\\n        \\n        for (; i < a.size() && max(a[i].start, newitv.start) <= min(a[i].end, newitv.end); i++) {\\n            newitv.start = min(a[i].start, newitv.start);\\n            newitv.end = max(a[i].end, newitv.end);\\n        }\\n        res.push_back(newitv);\\n\\n        for (; i < a.size(); i++) res.push_back(a[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<Interval> insert(vector<Interval>& a, Interval newitv) {\\n        vector<Interval> res;\\n        int i = 0;\\n        for (; i < a.size() && a[i].end < newitv.start; i++) res.push_back(a[i]);\\n        \\n        for (; i < a.size() && max(a[i].start, newitv.start) <= min(a[i].end, newitv.end); i++) {\\n            newitv.start = min(a[i].start, newitv.start);\\n            newitv.end = max(a[i].end, newitv.end);\\n        }\\n        res.push_back(newitv);\\n\\n        for (; i < a.size(); i++) res.push_back(a[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21776,
                "title": "my-18ms-c-code-with-explanation",
                "content": "        class Solution {\\n    public:\\n      std::vector<Interval> insert(std::vector<Interval> &intervals, Interval newInterval) {\\n    \\n        auto partial_order =[](const Interval & a, const Interval & b){\\n          return a.end < b.start;\\n        };\\n    \\n        auto less = std::lower_bound(intervals.begin(), intervals.end(), newInterval, partial_order);\\n    \\n        auto greater = std::upper_bound(intervals.begin(), intervals.end(), newInterval, partial_order);\\n        //printf(\"The index position: %d %d\\\\n\", less - intervals.begin(), greater - intervals.begin());\\n        std::vector<Interval> answer; \\n    \\n        answer.insert(answer.end(), intervals.begin(), less);\\n        answer.push_back(mergeEqual(less, greater, newInterval));\\n        answer.insert(answer.end(), greater, intervals.end());\\n        return answer;\\n      }\\n    \\n    private:\\n    \\n      // Merge the new interval with an array of intervals, all intervals in the \\n      // array equal with the new interval in terms of the partial order we \\n      // defined.\\n      // In other words all of them are overlapped with the new interval.\\n    \\n      Interval mergeEqual(const std::vector<Interval>::iterator & first, const std::vector<Interval>::iterator & last, const Interval &target){\\n    \\n        Interval answer(target);\\n        if(first < last){\\n          answer = merge(answer, *first);\\n          answer = merge(answer, *(last-1));\\n        }\\n        return answer;\\n      }\\n      // Merge two overlapped intervals.\\n      Interval merge(const Interval & a, const Interval & b) {\\n        return Interval(std::min(a.start, b.start), std::max(a.end, b.end));\\n      }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n      std::vector<Interval> insert(std::vector<Interval> &intervals, Interval newInterval) {\\n    \\n        auto partial_order =[](const Interval & a, const Interval & b){\\n          return a.end < b.start;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 21844,
                "title": "concise-solution-using-stl",
                "content": "use lower_bound find the left and right bound of newinterval, step back or forward if need.\\n\\n\\n    bool comp1(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.start < rhs.start;\\n\\t}\\n\\tbool comp2(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.end < rhs.end;\\n\\t}\\n\\n\\tvector<Interval> insert(vector<Interval> &intervals, Interval newInterval) \\n\\t{\\n\\t\\tvector<Interval>::iterator begin = lower_bound(intervals.begin(), intervals.end(), newInterval, comp1);\\n\\t\\tif(begin != intervals.begin() && (begin - 1)->end >= newInterval.start)\\n\\t\\t{\\n\\t\\t\\t--begin;\\n\\t\\t\\tnewInterval.start = begin->start;\\n\\t\\t}\\n\\n\\t\\tvector<Interval>::iterator end = lower_bound(intervals.begin(), intervals.end(), newInterval, comp2);\\t\\t\\n\\t\\tif(end != intervals.end() && end->start <= newInterval.end)\\n\\t\\t{\\n\\t\\t\\tnewInterval.end = end->end;\\n\\t\\t\\t++end;\\t\\t\\t\\n\\t\\t}\\n\\t\\tvector<Interval>::iterator t = intervals.erase(begin, end);\\n\\t\\tintervals.insert(t, newInterval);\\n\\n\\t\\treturn intervals;\\n\\t}",
                "solutionTags": [],
                "code": "use lower_bound find the left and right bound of newinterval, step back or forward if need.\\n\\n\\n    bool comp1(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.start < rhs.start;\\n\\t}\\n\\tbool comp2(const Interval& lhs ,const Interval& rhs)\\n\\t{\\n\\t\\treturn lhs.end < rhs.end;\\n\\t}\\n\\n\\tvector<Interval> insert(vector<Interval> &intervals, Interval newInterval) \\n\\t{\\n\\t\\tvector<Interval>::iterator begin = lower_bound(intervals.begin(), intervals.end(), newInterval, comp1);\\n\\t\\tif(begin != intervals.begin() && (begin - 1)->end >= newInterval.start)\\n\\t\\t{\\n\\t\\t\\t--begin;\\n\\t\\t\\tnewInterval.start = begin->start;\\n\\t\\t}\\n\\n\\t\\tvector<Interval>::iterator end = lower_bound(intervals.begin(), intervals.end(), newInterval, comp2);\\t\\t\\n\\t\\tif(end != intervals.end() && end->start <= newInterval.end)\\n\\t\\t{\\n\\t\\t\\tnewInterval.end = end->end;\\n\\t\\t\\t++end;\\t\\t\\t\\n\\t\\t}\\n\\t\\tvector<Interval>::iterator t = intervals.erase(begin, end);\\n\\t\\tintervals.insert(t, newInterval);\\n\\n\\t\\treturn intervals;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3734438,
                "title": "11-lines-of-clean-and-optimized-code-step-by-step-approach",
                "content": "# Approach:\\nMy approach to solving the problem is as follows:\\n\\n- Initialize an empty array for the left side of the intervals and another empty array for the right side.\\n- Iterate through each interval in the given intervals.\\n- Check if the current interval is completely before the new interval. If so, add it to the left array.\\n- Check if the current interval is completely after the new interval. If so, add it to the right array.\\n- If the current interval overlaps with the new interval, update the new interval\\'s start and end values to cover both intervals.\\n- Finally, combine the left array, the new interval, and the right array to get the result.\\n# Complexity:\\n- Time complexity: The time complexity of this approach is O(n), where n is the number of intervals.\\n- Space complexity: The space complexity is also O(n), where n is the number of intervals.\\n\\n# Code\\n```\\nfunction insert(intervals: number[][], newInterval: number[]): number[][] {\\n    let [newStart, newEnd] = newInterval, left = [], right = [];\\n    for( let int of intervals ){\\n        let [start, end] = int;\\n        if( end < newStart )left.push(int);\\n        else if( start > newEnd )right.push(int);\\n        else {\\n            newStart = Math.min(start, newStart);\\n            newEnd = Math.max(end, newEnd);\\n        }\\n    }\\n    return [...left, [newStart, newEnd], ...right]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nfunction insert(intervals: number[][], newInterval: number[]): number[][] {\\n    let [newStart, newEnd] = newInterval, left = [], right = [];\\n    for( let int of intervals ){\\n        let [start, end] = int;\\n        if( end < newStart )left.push(int);\\n        else if( start > newEnd )right.push(int);\\n        else {\\n            newStart = Math.min(start, newStart);\\n            newEnd = Math.max(end, newEnd);\\n        }\\n    }\\n    return [...left, [newStart, newEnd], ...right]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467746,
                "title": "awesome-logic-python3",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        list1=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                list1.append(newInterval)\\n                return list1+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                list1.append(intervals[i])\\n            else:\\n                newInterval=[min(newInterval[0],intervals[i][0]),max(intervals[i][1],newInterval[1])]\\n        list1.append(newInterval)\\n        return list1\\n                \\n````\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        list1=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                list1.append(newInterval)\\n                return list1+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                list1.append(intervals[i])\\n            else:\\n                newInterval=[min(newInterval[0],intervals[i][0]),max(intervals[i][1],newInterval[1])]\\n        list1.append(newInterval)\\n        return list1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248191,
                "title": "easy-java-solution-3ms-solved-using-a-single-loop",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int [][] merged = new int[intervals.length+1][];\\n        int c = 0;\\n        for (int []i : intervals) {\\n            merged[c++] = i;\\n        }\\n        merged[intervals.length] = newInterval;\\n        Arrays.sort(merged , (a,b) -> Integer.compare(a[0], b[0]));\\n        List<int []> l1 = new ArrayList<>();\\n        for(int [] arr : merged){\\n            if(l1.size() == 0) l1.add(arr);\\n            else{\\n                int [] prevArr = l1.get(l1.size()-1);\\n                if(arr[0] <= prevArr[1]){\\n                    prevArr[1] = Math.max(prevArr[1] , arr[1]);\\n                }\\n                else l1.add(arr);\\n            }\\n        }\\n        return l1.toArray(new int[l1.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int [][] merged = new int[intervals.length+1][];\\n        int c = 0;\\n        for (int []i : intervals) {\\n            merged[c++] = i;\\n        }\\n        merged[intervals.length] = newInterval;\\n        Arrays.sort(merged , (a,b) -> Integer.compare(a[0], b[0]));\\n        List<int []> l1 = new ArrayList<>();\\n        for(int [] arr : merged){\\n            if(l1.size() == 0) l1.add(arr);\\n            else{\\n                int [] prevArr = l1.get(l1.size()-1);\\n                if(arr[0] <= prevArr[1]){\\n                    prevArr[1] = Math.max(prevArr[1] , arr[1]);\\n                }\\n                else l1.add(arr);\\n            }\\n        }\\n        return l1.toArray(new int[l1.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057348,
                "title": "c-same-logic-of-merge-intervals-2-pointers-comments-added",
                "content": "### Merge Interval Problem\\n### https://leetcode.com/problems/merge-intervals/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        // just remember the merge intervals problem\\n        // try to change this problem into that\\n        \\n        // add newInterval to the intervals\\n        intervals.push_back(newInterval);\\n        \\n        // now sort this\\n        sort(intervals.begin(),intervals.end());\\n        \\n        // now use the same logic that we used in merge intervals\\n        vector<vector<int>> ans;\\n        int n = intervals.size();\\n        int i=0,j=1;                                // using 2 pointers\\n        ans.push_back(intervals[i]);                // very first interval\\n        \\n        while(j<n)\\n        {\\n            // if my new interval is not overalpping with previous one then just add this\\n            if(intervals[j][0]>ans[i][1])\\n            {\\n                i++;                                // move previous pointer\\n                ans.push_back(intervals[j]);\\n            }\\n            // if it is overlapping then update prev second by curr second\\n            else\\n            {\\n                ans[i][1] = max(ans[i][1],intervals[j][1]);\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        // just remember the merge intervals problem\\n        // try to change this problem into that\\n        \\n        // add newInterval to the intervals\\n        intervals.push_back(newInterval);\\n        \\n        // now sort this\\n        sort(intervals.begin(),intervals.end());\\n        \\n        // now use the same logic that we used in merge intervals\\n        vector<vector<int>> ans;\\n        int n = intervals.size();\\n        int i=0,j=1;                                // using 2 pointers\\n        ans.push_back(intervals[i]);                // very first interval\\n        \\n        while(j<n)\\n        {\\n            // if my new interval is not overalpping with previous one then just add this\\n            if(intervals[j][0]>ans[i][1])\\n            {\\n                i++;                                // move previous pointer\\n                ans.push_back(intervals[j]);\\n            }\\n            // if it is overlapping then update prev second by curr second\\n            else\\n            {\\n                ans[i][1] = max(ans[i][1],intervals[j][1]);\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057029,
                "title": "c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ (not considering answer array)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        bool inserted = false;\\n        for (int i = 0; i < intervals.size(); i++) {\\n            // current interval can be merged with last ans interval\\n            int siz = ans.size();\\n            if (siz != 0 && ans[siz - 1][1] >= intervals[i][0]) {\\n                ans[siz - 1][1] = max(ans[siz - 1][1], intervals[i][1]);\\n                continue;\\n            }\\n            // newInterval complete dis-joint with current interval\\n            if (intervals[i][1] < newInterval[0]) {\\n                ans.push_back(intervals[i]);\\n                continue;\\n            }\\n            if (intervals[i][0] > newInterval[1]) {\\n                if (!inserted) ans.push_back(newInterval);\\n                ans.push_back(intervals[i]);\\n                inserted = true;\\n                continue;\\n            }\\n\\n            // newInterval overlapping with current interval\\n            ans.push_back({min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])});\\n            inserted = true;\\n        }\\n        // still not inserted\\n        if (!inserted) ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        bool inserted = false;\\n        for (int i = 0; i < intervals.size(); i++) {\\n            // current interval can be merged with last ans interval\\n            int siz = ans.size();\\n            if (siz != 0 && ans[siz - 1][1] >= intervals[i][0]) {\\n                ans[siz - 1][1] = max(ans[siz - 1][1], intervals[i][1]);\\n                continue;\\n            }\\n            // newInterval complete dis-joint with current interval\\n            if (intervals[i][1] < newInterval[0]) {\\n                ans.push_back(intervals[i]);\\n                continue;\\n            }\\n            if (intervals[i][0] > newInterval[1]) {\\n                if (!inserted) ans.push_back(newInterval);\\n                ans.push_back(intervals[i]);\\n                inserted = true;\\n                continue;\\n            }\\n\\n            // newInterval overlapping with current interval\\n            ans.push_back({min(intervals[i][0], newInterval[0]), max(intervals[i][1], newInterval[1])});\\n            inserted = true;\\n        }\\n        // still not inserted\\n        if (!inserted) ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056927,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n      List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n         for (int i = 0; i < intervals.length; i ++) {\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n      List<int[]> ans = new ArrayList<>();\\n        int[] toAdd = newInterval;\\n         for (int i = 0; i < intervals.length; i ++) {\\n            if (intervals[i][0] > toAdd[1]) {\\n                ans.add(toAdd);\\n                toAdd = intervals[i];\\n            }\\n\\t\\t\\telse if (intervals[i][1] >= toAdd[0])  \\n                toAdd = new int[] {Math.min(intervals[i][0], toAdd[0]),\\n                                   Math.max(intervals[i][1], toAdd[1]) };\\n            else ans.add(intervals[i]); \\n        }\\n        ans.add(toAdd);\\n\\t\\treturn ans.toArray(new int[ans.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056577,
                "title": "python-o-n-beats-90-easy",
                "content": "**if you like the solution -- Please vote this code**\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ans=[]\\n        i=0\\n        \\n        while i<len(intervals) and newInterval[0]>intervals[i][1]:\\n            ans.append(intervals[i])\\n            i+=1\\n            \\n        while i<len(intervals) and intervals[i][0]<=newInterval[1]:\\n            newInterval[0]=min(intervals[i][0],newInterval[0])\\n            newInterval[1]=max(intervals[i][1],newInterval[1])\\n            i+=1\\n        ans.append(newInterval)\\n        \\n        while i<len(intervals):\\n            ans.append(intervals[i])\\n            i+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        ans=[]\\n        i=0\\n        \\n        while i<len(intervals) and newInterval[0]>intervals[i][1]:\\n            ans.append(intervals[i])\\n            i+=1\\n            \\n        while i<len(intervals) and intervals[i][0]<=newInterval[1]:\\n            newInterval[0]=min(intervals[i][0],newInterval[0])\\n            newInterval[1]=max(intervals[i][1],newInterval[1])\\n            i+=1\\n        ans.append(newInterval)\\n        \\n        while i<len(intervals):\\n            ans.append(intervals[i])\\n            i+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733979,
                "title": "javascript-solution-based-on-merge-intervals",
                "content": "This solution is written based on the solution to **Merge Intervals** https://leetcode.com/problems/merge-intervals/\\n\\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\n var insert = function(intervals, newInterval) {\\n    const n = intervals.length\\n    // insert interval based on newInterval[0]\\n\\t// note: can be improved by using binary search\\n    let idx = 0\\n    \\n    while (idx < n) {\\n        if (intervals[idx][0] >= newInterval[0]) {\\n            break\\n        }\\n        idx++\\n    }\\n    \\n    intervals.splice(idx, 0, newInterval)\\n    \\n    // after the newInterval is inserted\\n\\t// we need to handle overlapping intervals\\n    let i = 0\\n    \\n\\t// run until i is the last index on intervals\\n    while (i < intervals.length - 1) {\\n       \\n\\t   // does not overlap\\n\\t   if (intervals[i][1] < intervals[i+1][0]) {\\n            i++\\n            continue\\n        }\\n        \\n\\t\\t// overlap\\n        intervals[i][1] = Math.max(intervals[i+1][1], intervals[i][1])\\n        \\n\\t\\t// intervals[i] has absorbed intervals[i+1]\\n\\t\\t// remove intervals[i+1]\\n        intervals.splice(i+1,1)\\n    }\\n    \\n    return intervals\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\n var insert = function(intervals, newInterval) {\\n    const n = intervals.length\\n    // insert interval based on newInterval[0]\\n\\t// note: can be improved by using binary search\\n    let idx = 0\\n    \\n    while (idx < n) {\\n        if (intervals[idx][0] >= newInterval[0]) {\\n            break\\n        }\\n        idx++\\n    }\\n    \\n    intervals.splice(idx, 0, newInterval)\\n    \\n    // after the newInterval is inserted\\n\\t// we need to handle overlapping intervals\\n    let i = 0\\n    \\n\\t// run until i is the last index on intervals\\n    while (i < intervals.length - 1) {\\n       \\n\\t   // does not overlap\\n\\t   if (intervals[i][1] < intervals[i+1][0]) {\\n            i++\\n            continue\\n        }\\n        \\n\\t\\t// overlap\\n        intervals[i][1] = Math.max(intervals[i+1][1], intervals[i][1])\\n        \\n\\t\\t// intervals[i] has absorbed intervals[i+1]\\n\\t\\t// remove intervals[i+1]\\n        intervals.splice(i+1,1)\\n    }\\n    \\n    return intervals\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1319389,
                "title": "python3-1-pass-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        # skip all intervals that are strictly smaller than newInterval\\n        # i.e. interval[1] < newInterval[0]\\n        # after this while loop, `idx` will be the index of first interval that\\'s not strictly smaller than newInterval\\n        idx = 0\\n        while idx < len(intervals) and intervals[idx][1] < newInterval[0]:\\n            idx += 1\\n\\n        for i in range(idx, len(intervals)):\\n            interval = intervals[i]\\n            if interval[0] > newInterval[1]:\\n                # because `intervals` is sorted on start time and is non-overlapping, whenever an interval \\n                # is strictly larger than newInterval, we can skip the rest and return result\\n                return intervals[:idx] + [newInterval] + intervals[i:]\\n            # if interval is not strictly larger than newInterval, we can merge it and update newInterval\\n            newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\\n\\n        return intervals[:idx] + [newInterval]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        # skip all intervals that are strictly smaller than newInterval\\n        # i.e. interval[1] < newInterval[0]\\n        # after this while loop, `idx` will be the index of first interval that\\'s not strictly smaller than newInterval\\n        idx = 0\\n        while idx < len(intervals) and intervals[idx][1] < newInterval[0]:\\n            idx += 1\\n\\n        for i in range(idx, len(intervals)):\\n            interval = intervals[i]\\n            if interval[0] > newInterval[1]:\\n                # because `intervals` is sorted on start time and is non-overlapping, whenever an interval \\n                # is strictly larger than newInterval, we can skip the rest and return result\\n                return intervals[:idx] + [newInterval] + intervals[i:]\\n            # if interval is not strictly larger than newInterval, we can merge it and update newInterval\\n            newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\\n\\n        return intervals[:idx] + [newInterval]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096028,
                "title": "python-easy-solution-with-complete-explanation",
                "content": "The code is pretty staright forward \\nfirstly we are appending the new element in the interval and then sorting the array on ethe basis of first element and that it what lambda x:x[0] is doing. After that we are checking if len< 0 then its empty and returning the new element. Otherwise we are checking for the condtion for merging the intervals. So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index and after this condition is True and the intervals are merged we are just poping out the current i else we will continue till the end.\\n\\n        intervals.append(newInterval)\\n        intervals.sort(key = lambda x:x[0])\\n        print(intervals)\\n        \\n        if len(intervals)<0:\\n            return newInterval\\n        \\n        i = 1\\n\\n        while i < len(intervals):\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n                \\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i)\\n            else:\\n                i+=1\\n                continue\\n                \\n        return intervals\\n\\nUpvote if you find it helful",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The code is pretty staright forward \\nfirstly we are appending the new element in the interval and then sorting the array on ethe basis of first element and that it what lambda x:x[0] is doing. After that we are checking if len< 0 then its empty and returning the new element. Otherwise we are checking for the condtion for merging the intervals. So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index and after this condition is True and the intervals are merged we are just poping out the current i else we will continue till the end.\\n\\n        intervals.append(newInterval)\\n        intervals.sort(key = lambda x:x[0])\\n        print(intervals)\\n        \\n        if len(intervals)<0:\\n            return newInterval\\n        \\n        i = 1\\n\\n        while i < len(intervals):\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n                \\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i)\\n            else:\\n                i+=1\\n                continue\\n                \\n        return intervals\\n\\nUpvote if you find it helful",
                "codeTag": "Python3"
            },
            {
                "id": 741146,
                "title": "swift-simple-steps-o-n-complexity",
                "content": "Time: O(n), Space: O(n)\\n```\\nfunc insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tvar new = newInterval\\n\\tvar index = 0\\n\\n\\t// add the non-conflicting beginning\\n\\twhile index < intervals.count && intervals[index][1] < new[0] {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\t// merge the conflictions\\n\\twhile index < intervals.count && intervals[index][0] <= new[1] {\\n\\t\\tnew[0] = min(intervals[index][0], new[0])\\n\\t\\tnew[1] = max(intervals[index][1], new[1])\\n\\t\\tindex += 1\\n\\t}\\n\\tresult.append(new)\\n\\n\\t// add the rest\\n\\twhile index < intervals.count {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\\n\\tvar result = [[Int]]()\\n\\tvar new = newInterval\\n\\tvar index = 0\\n\\n\\t// add the non-conflicting beginning\\n\\twhile index < intervals.count && intervals[index][1] < new[0] {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\t// merge the conflictions\\n\\twhile index < intervals.count && intervals[index][0] <= new[1] {\\n\\t\\tnew[0] = min(intervals[index][0], new[0])\\n\\t\\tnew[1] = max(intervals[index][1], new[1])\\n\\t\\tindex += 1\\n\\t}\\n\\tresult.append(new)\\n\\n\\t// add the rest\\n\\twhile index < intervals.count {\\n\\t\\tresult.append(intervals[index])\\n\\t\\tindex += 1\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502484,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> resultList = new ArrayList<>();\\n        \\n        for(int[] interval : intervals) {\\n            if(newInterval[0] > interval[1]) {\\n                resultList.add(interval);\\n            }\\n            else if(newInterval[1] < interval[0]) {\\n                resultList.add(newInterval);\\n                newInterval = interval;\\n            }\\n            else {\\n                int[] merged = new int[] {Math.min(newInterval[0], interval[0]), Math.max(newInterval[1], interval[1])};\\n                newInterval = merged;\\n            }\\n        }\\n        resultList.add(newInterval);\\n        \\n        return resultList.toArray(new int[resultList.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> resultList = new ArrayList<>();\\n        \\n        for(int[] interval : intervals) {\\n            if(newInterval[0] > interval[1]) {\\n                resultList.add(interval);\\n            }\\n            else if(newInterval[1] < interval[0]) {\\n                resultList.add(newInterval);\\n                newInterval = interval;\\n            }\\n            else {\\n                int[] merged = new int[] {Math.min(newInterval[0], interval[0]), Math.max(newInterval[1], interval[1])};\\n                newInterval = merged;\\n            }\\n        }\\n        resultList.add(newInterval);\\n        \\n        return resultList.toArray(new int[resultList.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463679,
                "title": "java-10-lines-o-n-1ms",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        for (int[] next: intervals) {\\n            if (next[1]<newInterval[0]) list.add(next);\\n            else if (newInterval[1]<next[0]) {\\n                list.add(newInterval);\\n                newInterval = next;\\n            }\\n            else newInterval = new int[]{Math.min(newInterval[0], next[0]), Math.max(newInterval[1], next[1])};\\n        }\\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        for (int[] next: intervals) {\\n            if (next[1]<newInterval[0]) list.add(next);\\n            else if (newInterval[1]<next[0]) {\\n                list.add(newInterval);\\n                newInterval = next;\\n            }\\n            else newInterval = new int[]{Math.min(newInterval[0], next[0]), Math.max(newInterval[1], next[1])};\\n        }\\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689977,
                "title": "easy-to-understand-c-solution-o-n",
                "content": "# Intution & Approach\\n# Use three loops.\\n1.) Insert all the intervals which are strictly lesser than the new Interval.\\n2.)(When the new interval is overlaping) In second loop maintain a start and end variable and find the start point and end point of interval and insert that interval in resultant vector.\\n3.)When the intervals values are strictly greater than the new interval insert all the intervals till end.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i=0;\\n        bool flag=false;\\n        int start=newInterval[0];;\\n        int end=newInterval[1];\\n// Insert all the intervals which are strictly lesser than the new Interval.\\n        while(i<intervals.size() && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n// Overlapping intervals\\n        while(i<intervals.size() && intervals[i][0]<=newInterval[1])\\n        {\\n            \\n            start=min(intervals[i][0],start);\\n            end=max(intervals[i][1],end);\\n            i++;\\n        }\\n//Strictly Greater intervals\\n        result.push_back({start,end});\\n        while(i<intervals.size())\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n       \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i=0;\\n        bool flag=false;\\n        int start=newInterval[0];;\\n        int end=newInterval[1];\\n// Insert all the intervals which are strictly lesser than the new Interval.\\n        while(i<intervals.size() && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n// Overlapping intervals\\n        while(i<intervals.size() && intervals[i][0]<=newInterval[1])\\n        {\\n            \\n            start=min(intervals[i][0],start);\\n            end=max(intervals[i][1],end);\\n            i++;\\n        }\\n//Strictly Greater intervals\\n        result.push_back({start,end});\\n        while(i<intervals.size())\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n       \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057287,
                "title": "c-easy-to-understand-beats-75",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& ne) {\\n        intervals.push_back(ne);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        int j=0;\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[j][1]>=intervals[i][0]){\\n                intervals[j][1]=max(intervals[j][1],intervals[i][1]);\\n               \\n            }\\n            else{\\n                j++;\\n                intervals[j]=intervals[i];\\n            }\\n        }\\n        \\n       for(int i=0;i<=j;i++){\\n           ans.push_back(intervals[i]);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& ne) {\\n        intervals.push_back(ne);\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        int j=0;\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[j][1]>=intervals[i][0]){\\n                intervals[j][1]=max(intervals[j][1],intervals[i][1]);\\n               \\n            }\\n            else{\\n                j++;\\n                intervals[j]=intervals[i];\\n            }\\n        }\\n        \\n       for(int i=0;i<=j;i++){\\n           ans.push_back(intervals[i]);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057001,
                "title": "c-easy-solution-using-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inter, vector<int>& nInter) {\\n        vector<int>a,b;\\n        vector<vector<int>>ans;\\n        for(auto &val:inter){\\n            a.push_back(val[0]);\\n            b.push_back(val[1]);\\n        }\\n        int x=upper_bound(a.begin(),a.end(),nInter[0])-a.begin()-1;\\n        int y=upper_bound(a.begin(),a.end(),nInter[1])-a.begin()-1;\\n        \\n        \\n        if(x==y){\\n            if(x==-1){\\n                ans.push_back(nInter);\\n                for(int i=0;i<inter.size();i++){\\n                    ans.push_back(inter[i]);\\n                    \\n                }\\n                return ans;\\n            }\\n            else{\\n                if(nInter[0]>inter[x][1]){\\n                    for(int i=0;i<inter.size();i++){\\n                        ans.push_back(inter[i]);\\n                        if(i==x){\\n                            ans.push_back(nInter);\\n                        }\\n                        \\n                    }\\n                    return ans;\\n                }\\n            }\\n        }\\n        bool flag=true;\\n        for(int i=0;i<inter.size();i++){\\n            if(flag&&(i==x||x==-1)){\\n                if(x!=-1&&inter[x][1]<nInter[0]){\\n                    ans.push_back(inter[x]);\\n                }\\n                ans.push_back({min(nInter[0],inter[x+(x==-1||inter[x][1]<nInter[0])][0]),max(nInter[1],inter[y][1])});\\n                i=y;\\n                flag=false;\\n            }\\n            else{\\n                ans.push_back(inter[i]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n**Please Upvote it really Motivates me**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& inter, vector<int>& nInter) {\\n        vector<int>a,b;\\n        vector<vector<int>>ans;\\n        for(auto &val:inter){\\n            a.push_back(val[0]);\\n            b.push_back(val[1]);\\n        }\\n        int x=upper_bound(a.begin(),a.end(),nInter[0])-a.begin()-1;\\n        int y=upper_bound(a.begin(),a.end(),nInter[1])-a.begin()-1;\\n        \\n        \\n        if(x==y){\\n            if(x==-1){\\n                ans.push_back(nInter);\\n                for(int i=0;i<inter.size();i++){\\n                    ans.push_back(inter[i]);\\n                    \\n                }\\n                return ans;\\n            }\\n            else{\\n                if(nInter[0]>inter[x][1]){\\n                    for(int i=0;i<inter.size();i++){\\n                        ans.push_back(inter[i]);\\n                        if(i==x){\\n                            ans.push_back(nInter);\\n                        }\\n                        \\n                    }\\n                    return ans;\\n                }\\n            }\\n        }\\n        bool flag=true;\\n        for(int i=0;i<inter.size();i++){\\n            if(flag&&(i==x||x==-1)){\\n                if(x!=-1&&inter[x][1]<nInter[0]){\\n                    ans.push_back(inter[x]);\\n                }\\n                ans.push_back({min(nInter[0],inter[x+(x==-1||inter[x][1]<nInter[0])][0]),max(nInter[1],inter[y][1])});\\n                i=y;\\n                flag=false;\\n            }\\n            else{\\n                ans.push_back(inter[i]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056444,
                "title": "daily-leetcoding-challenge-january-day-16",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-interval/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Linear Search\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-interval/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2489404,
                "title": "c-easy-and-concise",
                "content": "```\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto &it : intervals) {\\n            if(it[1] >= newInterval[0] and it[0] <= newInterval[1]) {\\n                newInterval[0] = min(it[0],newInterval[0]);\\n                newInterval[1] = max(it[1],newInterval[1]);\\n            }\\n            else {\\n                if(it[0] > newInterval[0]) \\n                    swap(it,newInterval);\\n                ans.push_back(it);\\n            }\\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto &it : intervals) {\\n            if(it[1] >= newInterval[0] and it[0] <= newInterval[1]) {\\n                newInterval[0] = min(it[0],newInterval[0]);\\n                newInterval[1] = max(it[1],newInterval[1]);\\n            }\\n            else {\\n                if(it[0] > newInterval[0]) \\n                    swap(it,newInterval);\\n                ans.push_back(it);\\n            }\\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2435713,
                "title": "c-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    // merge intervals.\\n    vector<vector<int>> merge(vector<vector<int>>&ans,int n)\\n    {\\n        vector<vector<int>>res;\\n        res.push_back(ans[0]);\\n        int prev=res[0][1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans[i][0]<=prev)\\n            {\\n                res[res.size()-1][1]=max(res[res.size()-1][1],ans[i][1]);\\n                prev=res[res.size()-1][1];\\n            }\\n            else\\n            {\\n                res.push_back(ans[i]);\\n                prev=ans[i][1];\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n=intervals.size();\\n        // Adding interval \\n        vector<vector<int>>ans;\\n        bool first=false;\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(!first && intervals[i][0]>=newInterval[0])\\n            {\\n                ans.push_back(newInterval);\\n                first=true;\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                i++;\\n            }\\n        }\\n        if(!first)\\n            ans.push_back(newInterval);\\n \\n        // merge intervals\\n        return merge(ans,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // merge intervals.\\n    vector<vector<int>> merge(vector<vector<int>>&ans,int n)\\n    {\\n        vector<vector<int>>res;\\n        res.push_back(ans[0]);\\n        int prev=res[0][1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans[i][0]<=prev)\\n            {\\n                res[res.size()-1][1]=max(res[res.size()-1][1],ans[i][1]);\\n                prev=res[res.size()-1][1];\\n            }\\n            else\\n            {\\n                res.push_back(ans[i]);\\n                prev=ans[i][1];\\n            }\\n        }\\n        return res;\\n    }\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n=intervals.size();\\n        // Adding interval \\n        vector<vector<int>>ans;\\n        bool first=false;\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(!first && intervals[i][0]>=newInterval[0])\\n            {\\n                ans.push_back(newInterval);\\n                first=true;\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                i++;\\n            }\\n        }\\n        if(!first)\\n            ans.push_back(newInterval);\\n \\n        // merge intervals\\n        return merge(ans,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271812,
                "title": "python-simplest-solution-with-explanation-beg-to-adv-interval",
                "content": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        if len(intervals) < 2 and len(newInterval) == 0: # if there is only one element in the provided list and if htere is no element in newInterval\\n            return intervals # then just return interval. \\n      \\n        intervals.append(newInterval) # merging both the lists.\\n        \\n        # Below is the same program for merge interval, as we have to return a list with overlape. \\n        \\n        intervals.sort()# Sorting the list, if we dont then we wont be able to check for the overlapping intervals.\\n        start = intervals[0][0] # saving first element of the sublist in a variable for comparing it. \\n        end = intervals[0][1] # saving second element of the sublist in a variable for comparing it. \\n        res = [] # crerating a empty list for saving the result. \\n        \\n        for i in range(1, len(intervals)):# traversing the list from 1 as 0th element of the list is allocated to the variables, start & end.\\n            interval = intervals[i]# assigning i`th element to the a variable for performing the logic.\\n            if interval[0]<=end: # overlapping intervals\\n                end = max(interval[1], end)\\n            else:  # non-overlapping interval, add the previous interval and reset\\n                res.append([start, end])\\n                start = interval[0] # updating start variable with current interval element.\\n                end = interval[1]# updating end variable with current interval element.\\n        res.append([start, end])  # add the last interval\\n        return res\\n```\\n***Found helpful, Do upvote !!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        \\n        if len(intervals) < 2 and len(newInterval) == 0: # if there is only one element in the provided list and if htere is no element in newInterval\\n            return intervals # then just return interval. \\n      \\n        intervals.append(newInterval) # merging both the lists.\\n        \\n        # Below is the same program for merge interval, as we have to return a list with overlape. \\n        \\n        intervals.sort()# Sorting the list, if we dont then we wont be able to check for the overlapping intervals.\\n        start = intervals[0][0] # saving first element of the sublist in a variable for comparing it. \\n        end = intervals[0][1] # saving second element of the sublist in a variable for comparing it. \\n        res = [] # crerating a empty list for saving the result. \\n        \\n        for i in range(1, len(intervals)):# traversing the list from 1 as 0th element of the list is allocated to the variables, start & end.\\n            interval = intervals[i]# assigning i`th element to the a variable for performing the logic.\\n            if interval[0]<=end: # overlapping intervals\\n                end = max(interval[1], end)\\n            else:  # non-overlapping interval, add the previous interval and reset\\n                res.append([start, end])\\n                start = interval[0] # updating start variable with current interval element.\\n                end = interval[1]# updating end variable with current interval element.\\n        res.append([start, end])  # add the last interval\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159738,
                "title": "kotlin-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\\n        \\n\\n        var ans = mutableListOf<IntArray>()\\n        \\n        \\n        var start = newInterval[0]\\n        var end = newInterval[1]\\n        \\n        var counter = 0\\n        \\n        // get the intervals which are smaller than the newInterval\\n        while(counter < intervals.size && intervals[counter][1] < start) ans.add(intervals[counter++])\\n        \\n        // check if any overlapping exist and define the boundraies for the merged intervals\\n        while(counter < intervals.size && intervals[counter][0] <= end){\\n            start = Math.min(intervals[counter][0],start)\\n            end = Math.max(intervals[counter++][1],end)\\n        }\\n        \\n        // add the merged intervals\\n        ans.add(intArrayOf(start,end))\\n        \\n        // add the remaining part that its size is larger than the merged part\\n        while(counter < intervals.size) ans.add(intervals[counter++])\\n\\n        return ans.toTypedArray()\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\\n        \\n\\n        var ans = mutableListOf<IntArray>()\\n        \\n        \\n        var start = newInterval[0]\\n        var end = newInterval[1]\\n        \\n        var counter = 0\\n        \\n        // get the intervals which are smaller than the newInterval\\n        while(counter < intervals.size && intervals[counter][1] < start) ans.add(intervals[counter++])\\n        \\n        // check if any overlapping exist and define the boundraies for the merged intervals\\n        while(counter < intervals.size && intervals[counter][0] <= end){\\n            start = Math.min(intervals[counter][0],start)\\n            end = Math.max(intervals[counter++][1],end)\\n        }\\n        \\n        // add the merged intervals\\n        ans.add(intArrayOf(start,end))\\n        \\n        // add the remaining part that its size is larger than the merged part\\n        while(counter < intervals.size) ans.add(intervals[counter++])\\n\\n        return ans.toTypedArray()\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105125,
                "title": "east-to-understand-c-solution-very-intuitive",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>> &intervals, vector<int> &new_interval)\\n    {\\n        vector<vector<int>> res;\\n        int n = intervals.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int low = max(intervals[i][0], new_interval[0]);\\n            int high = min(intervals[i][1], new_interval[1]);\\n\\n            // overlapping condition\\n            if (low <= high)\\n            {\\n                int union_low = min(intervals[i][0], new_interval[0]);\\n                int union_high = max(intervals[i][1], new_interval[1]);\\n\\n                new_interval = {union_low, union_high};\\n            }\\n            else\\n            {\\n                if (intervals[i][1] < new_interval[0])\\n                {\\n                    res.push_back(intervals[i]);\\n                }\\n                else if (new_interval[1] < intervals[i][0])\\n                {\\n                    res.push_back(new_interval);\\n                    new_interval = intervals[i];\\n                }\\n            }\\n        }\\n        res.push_back(new_interval);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>> &intervals, vector<int> &new_interval)\\n    {\\n        vector<vector<int>> res;\\n        int n = intervals.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            int low = max(intervals[i][0], new_interval[0]);\\n            int high = min(intervals[i][1], new_interval[1]);\\n\\n            // overlapping condition\\n            if (low <= high)\\n            {\\n                int union_low = min(intervals[i][0], new_interval[0]);\\n                int union_high = max(intervals[i][1], new_interval[1]);\\n\\n                new_interval = {union_low, union_high};\\n            }\\n            else\\n            {\\n                if (intervals[i][1] < new_interval[0])\\n                {\\n                    res.push_back(intervals[i]);\\n                }\\n                else if (new_interval[1] < intervals[i][0])\\n                {\\n                    res.push_back(new_interval);\\n                    new_interval = intervals[i];\\n                }\\n            }\\n        }\\n        res.push_back(new_interval);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075054,
                "title": "c-easy-o-n",
                "content": "\\n\\n```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        int i=0;\\n\\t\\t\\n\\t\\t//Insert the interval in sorted order\\n        while(i<intervals.size() && newInterval[0]>intervals[i][0])\\n            i++;\\n        intervals.insert(intervals.begin()+i,newInterval);\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n\\t\\t/*If end of previous inserted interval end value  is less than next Interval end value then only we have to consider it otherwise \\n\\t\\t\\tdiscard and move ahead . If true check whether the current interval is overlapping with the next then merge and Push . If not just push interval in the ans vector. */\\n            if(ans[j][1] <= intervals[i][1])\\n            if(ans[j][1]>=intervals[i][0])\\n                ans[j][1] = intervals[i][1];\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        int i=0;\\n\\t\\t\\n\\t\\t//Insert the interval in sorted order\\n        while(i<intervals.size() && newInterval[0]>intervals[i][0])\\n            i++;\\n        intervals.insert(intervals.begin()+i,newInterval);\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n\\t\\t/*If end of previous inserted interval end value  is less than next Interval end value then only we have to consider it otherwise \\n\\t\\t\\tdiscard and move ahead . If true check whether the current interval is overlapping with the next then merge and Push . If not just push interval in the ans vector. */\\n            if(ans[j][1] <= intervals[i][1])\\n            if(ans[j][1]>=intervals[i][0])\\n                ans[j][1] = intervals[i][1];\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680989,
                "title": "easy-faster-than-91-72-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto x: intervals){\\n            if(x[1]<newInterval[0]){\\n                ans.push_back(x);\\n            }else if(x[0]>newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = x;\\n            }else{\\n                newInterval[0] = min(x[0],newInterval[0]);\\n                newInterval[1] = max(x[1],newInterval[1]);\\n            }            \\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> ans;\\n        for(auto x: intervals){\\n            if(x[1]<newInterval[0]){\\n                ans.push_back(x);\\n            }else if(x[0]>newInterval[1]){\\n                ans.push_back(newInterval);\\n                newInterval = x;\\n            }else{\\n                newInterval[0] = min(x[0],newInterval[0]);\\n                newInterval[1] = max(x[1],newInterval[1]);\\n            }            \\n        }\\n        ans.push_back(newInterval);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877685,
                "title": "java-solution-with-figures-diagrams-easy-3-step-process-update-with-new-signature",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> out = new ArrayList<>();\\n        int i = 0;\\n        \\n        /*\\n        Step 1.\\n        Add all intervals before newInterval (that don\\'t overlap with newInterval so just 1 in this case\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------        \\n         */\\n        while( i<intervals.length && intervals[i][1] < newInterval[0] ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        // \\n        /*\\n        Step 2.\\n        Now i is at an interval that we merge with OR that we don\\'t merge with (case B)\\n        Case A.\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------   \\n\\n        Case B.\\n            1.                          2.  \\n          -----                       ------\\n                    -------------   \\n                    \\n        \"intervals[i][0] <= newInterval[1]\" below means if the current interval\\'s start is before or \\n\\t\\tat the newIntervals end, it should be part of the merge interval. Look at the diagram,\\n\\t\\tin case A it is easy to see 4. is the last interval we take. In case B. there are no intervals so the while never loops\\n         */\\n        while( i<intervals.length && intervals[i][0] <= newInterval[1] ){\\n            newInterval[0] = Math.min( newInterval[0], intervals[i][0] ); \\n            newInterval[1] = Math.max( newInterval[1], intervals[i][1] ); \\n            i++;\\n        }\\n        \\n\\t\\t// Add the insert interval\\n        out.add(newInterval);\\n        \\n        // Step 3. Add all of the intervals that come after the inserted interval if any\\n        while( i<intervals.length ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        return out.toArray(new int[out.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        \\n        List<int[]> out = new ArrayList<>();\\n        int i = 0;\\n        \\n        /*\\n        Step 1.\\n        Add all intervals before newInterval (that don\\'t overlap with newInterval so just 1 in this case\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------        \\n         */\\n        while( i<intervals.length && intervals[i][1] < newInterval[0] ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        // \\n        /*\\n        Step 2.\\n        Now i is at an interval that we merge with OR that we don\\'t merge with (case B)\\n        Case A.\\n            1.    2.     3.     4.      5  \\n          ----- ------- ---- -------- ------\\n                    -------------   \\n\\n        Case B.\\n            1.                          2.  \\n          -----                       ------\\n                    -------------   \\n                    \\n        \"intervals[i][0] <= newInterval[1]\" below means if the current interval\\'s start is before or \\n\\t\\tat the newIntervals end, it should be part of the merge interval. Look at the diagram,\\n\\t\\tin case A it is easy to see 4. is the last interval we take. In case B. there are no intervals so the while never loops\\n         */\\n        while( i<intervals.length && intervals[i][0] <= newInterval[1] ){\\n            newInterval[0] = Math.min( newInterval[0], intervals[i][0] ); \\n            newInterval[1] = Math.max( newInterval[1], intervals[i][1] ); \\n            i++;\\n        }\\n        \\n\\t\\t// Add the insert interval\\n        out.add(newInterval);\\n        \\n        // Step 3. Add all of the intervals that come after the inserted interval if any\\n        while( i<intervals.length ){\\n            out.add(intervals[i++]);\\n        }\\n        \\n        return out.toArray(new int[out.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864312,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        left, merge, right = [], [], []\\n        for x in intervals: # credit to @StefanPochmann\\n            if x[0] > e:\\n                right.append(x)\\n            elif x[1] < s:\\n                left.append(x)\\n            else:\\n                merge.append(x)\\n        if merge:\\n            s = min(merge[0][0], s)\\n            e = max(merge[-1][1], e)\\n            \\n        return left + [[s,e]] + right\\n            \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        s, e = newInterval\\n        left, merge, right = [], [], []\\n        for x in intervals: # credit to @StefanPochmann\\n            if x[0] > e:\\n                right.append(x)\\n            elif x[1] < s:\\n                left.append(x)\\n            else:\\n                merge.append(x)\\n        if merge:\\n            s = min(merge[0][0], s)\\n            e = max(merge[-1][1], e)\\n            \\n        return left + [[s,e]] + right\\n            \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602609,
                "title": "simple-python-o-n-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals, new):\\n        \\n        merged,t,l = [], 0, len(intervals)       \\n        for curr in intervals:\\n            \\n            # If interval[i] completely smaller than new one\\n            if new[0]>curr[1]:\\n                merged.append(curr)\\n             \\n            # If interval[i] completely greater than new\\n            elif curr[0]>new[1]:\\n                break\\n             \\n            # If interval[i] is overlapping with new\\n            else:              \\n                # choose minm and maxm boundaries from both\\n                new[0] = min(new[0], curr[0])\\n                new[1] = max(new[1], curr[1])\\n            \\n            t+=1\\n            \\n        # Apeending last new interval\\n        merged.append(new)\\n        \\n        # Now understand this part\\n        # i) If new part extend till end than simply return merged ones\\n        # ii) If not till end than return merged + remainling intervals\\n        return merged+intervals[t:] if t<l else merged\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals, new):\\n        \\n        merged,t,l = [], 0, len(intervals)       \\n        for curr in intervals:\\n            \\n            # If interval[i] completely smaller than new one\\n            if new[0]>curr[1]:\\n                merged.append(curr)\\n             \\n            # If interval[i] completely greater than new\\n            elif curr[0]>new[1]:\\n                break\\n             \\n            # If interval[i] is overlapping with new\\n            else:              \\n                # choose minm and maxm boundaries from both\\n                new[0] = min(new[0], curr[0])\\n                new[1] = max(new[1], curr[1])\\n            \\n            t+=1\\n            \\n        # Apeending last new interval\\n        merged.append(new)\\n        \\n        # Now understand this part\\n        # i) If new part extend till end than simply return merged ones\\n        # ii) If not till end than return merged + remainling intervals\\n        return merged+intervals[t:] if t<l else merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562487,
                "title": "extremely-easy-understanding-java",
                "content": "All the intervals can be classified into three groups:\\n\\n1. non-overlapping interval ends before the `newInterval`\\n2. overlapping intervals\\n2. non-overlapping interval starts after the `newInterval`\\n\\nFor intervals in the first and third group, we don\\'t need to do anything rather than adding them to the result set.\\nFor the second group, we just merge their `startTime` and `endTime`, with our `newInterval`, and add the final merged interval to the result.\\n\\n```java\\nList<int[]> result = new ArrayList<>();\\nint index = 0;\\n// Add all non-overlapping intervals before the \\'newSpan\\'\\nwhile (index < intervals.length && intervals[index][1] < newSpan[0]) {\\n\\tresult.add(intervals[index++]);\\n}\\n// Merge all overlapping intervals into the newSpan\\nwhile (index < intervals.length && intervals[index][0] <= newSpan[1]) {\\n\\tint[] thisSpan = intervals[index++];\\n\\tnewSpan[0] = Math.min(thisSpan[0], newSpan[0]);\\n\\tnewSpan[1] = Math.max(thisSpan[1], newSpan[1]);\\n\\n}\\nresult.add(newSpan);  // return the merged newspan\\n\\n// Add all remaining non-overlapping intervals after the merged newSpan\\nwhile (index < intervals.length) {\\n\\tresult.add(intervals[index++]);\\n}\\n\\nreturn result.toArray(new int[result.size()][]);\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```java\\nList<int[]> result = new ArrayList<>();\\nint index = 0;\\n// Add all non-overlapping intervals before the \\'newSpan\\'\\nwhile (index < intervals.length && intervals[index][1] < newSpan[0]) {\\n\\tresult.add(intervals[index++]);\\n}\\n// Merge all overlapping intervals into the newSpan\\nwhile (index < intervals.length && intervals[index][0] <= newSpan[1]) {\\n\\tint[] thisSpan = intervals[index++];\\n\\tnewSpan[0] = Math.min(thisSpan[0], newSpan[0]);\\n\\tnewSpan[1] = Math.max(thisSpan[1], newSpan[1]);\\n\\n}\\nresult.add(newSpan);  // return the merged newspan\\n\\n// Add all remaining non-overlapping intervals after the merged newSpan\\nwhile (index < intervals.length) {\\n\\tresult.add(intervals[index++]);\\n}\\n\\nreturn result.toArray(new int[result.size()][]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499881,
                "title": "python-two-different-solutions",
                "content": "1. Using two pointers\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            return [newInterval]\\n        \\n        x = len(intervals)\\n        i = 0\\n        while(i<x and intervals[i][1]<newInterval[0]):\\n            i += 1\\n            \\n        j = i\\n        while(j<x and intervals[j][0]<=newInterval[1]):\\n            j += 1\\n\\n\\n        if i == j:\\n            ret = newInterval\\n        else:\\n            start = min(intervals[i][0], newInterval[0])\\n            end = max(intervals[j-1][1],newInterval[1])\\n            ret = [start,end]\\n            \\n        return intervals[:i] + [ret] + intervals[j:]\\n```\\n\\n2. Use previous solution\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        \\n        intervals.sort()\\n        \\n        merged=[]\\n        for interval in intervals:\\n            if not merged or merged[-1][1] < interval[0]:\\n                merged.append(interval)\\n            else:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n                \\n        return merged\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            return [newInterval]\\n        \\n        x = len(intervals)\\n        i = 0\\n        while(i<x and intervals[i][1]<newInterval[0]):\\n            i += 1\\n            \\n        j = i\\n        while(j<x and intervals[j][0]<=newInterval[1]):\\n            j += 1\\n\\n\\n        if i == j:\\n            ret = newInterval\\n        else:\\n            start = min(intervals[i][0], newInterval[0])\\n            end = max(intervals[j-1][1],newInterval[1])\\n            ret = [start,end]\\n            \\n        return intervals[:i] + [ret] + intervals[j:]\\n```\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        \\n        intervals.sort()\\n        \\n        merged=[]\\n        for interval in intervals:\\n            if not merged or merged[-1][1] < interval[0]:\\n                merged.append(interval)\\n            else:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n                \\n        return merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436879,
                "title": "javascript-solution-o-n",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let results = [];\\n    \\n    let i = 0;\\n    while(i < intervals.length && intervals[i][1] < newInterval[0]) {\\n        results.push(intervals[i]);\\n        i++;\\n    }\\n    \\n    newInterval = [Math.min(newInterval[0], i < intervals.length ? intervals[i][0] : Infinity), newInterval[1]];    \\n                                       \\n    while(i < intervals.length && newInterval[1] >= intervals[i][0]) {\\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n        i++;\\n    }       \\n    results.push(newInterval);\\n   return results.concat(intervals.slice(i, intervals.length));\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let results = [];\\n    \\n    let i = 0;\\n    while(i < intervals.length && intervals[i][1] < newInterval[0]) {\\n        results.push(intervals[i]);\\n        i++;\\n    }\\n    \\n    newInterval = [Math.min(newInterval[0], i < intervals.length ? intervals[i][0] : Infinity), newInterval[1]];    \\n                                       \\n    while(i < intervals.length && newInterval[1] >= intervals[i][0]) {\\n        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n        i++;\\n    }       \\n    results.push(newInterval);\\n   return results.concat(intervals.slice(i, intervals.length));\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 309024,
                "title": "c-98-beat-o-n-single-pass-looper-lew-pah-luu-purrrrr",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        vector<vector<int>> aResult;\\n        \\n        int aIndex = 0;\\n        while (aIndex < intervals.size() && intervals[aIndex][1] < newInterval[0]) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        while (aIndex < intervals.size() && intervals[aIndex][0] <= newInterval[1]) {\\n            newInterval[1] = max(newInterval[1], intervals[aIndex][1]);\\n            newInterval[0] = min(newInterval[0], intervals[aIndex][0]);\\n            ++aIndex;\\n        }\\n        aResult.push_back(newInterval);\\n        \\n        while (aIndex < intervals.size()) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\n$ Dolla Dolla Plz $$ TY",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        \\n        vector<vector<int>> aResult;\\n        \\n        int aIndex = 0;\\n        while (aIndex < intervals.size() && intervals[aIndex][1] < newInterval[0]) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        while (aIndex < intervals.size() && intervals[aIndex][0] <= newInterval[1]) {\\n            newInterval[1] = max(newInterval[1], intervals[aIndex][1]);\\n            newInterval[0] = min(newInterval[0], intervals[aIndex][0]);\\n            ++aIndex;\\n        }\\n        aResult.push_back(newInterval);\\n        \\n        while (aIndex < intervals.size()) {\\n            aResult.push_back(intervals[aIndex++]);\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304135,
                "title": "go-8ms-6-2mb",
                "content": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    ret := make([][]int, 0)\\n    for i, v := range intervals {\\n\\t\\tif v[1] < newInterval[0] {\\n\\t\\t\\tret = append(ret, v)\\n            continue\\n\\t\\t}\\n        \\n        if v[0] > newInterval[1] {\\n            ret = append(ret, newInterval)\\n            ret = append(ret, intervals[i:]...)\\n            return ret\\n\\t\\t}\\n        \\n        newInterval[0] = min(newInterval[0], v[0])\\n        newInterval[1] = max(newInterval[1], v[1])\\n\\t}\\n    return append(ret, newInterval)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc insert(intervals [][]int, newInterval []int) [][]int {\\n    ret := make([][]int, 0)\\n    for i, v := range intervals {\\n\\t\\tif v[1] < newInterval[0] {\\n\\t\\t\\tret = append(ret, v)\\n            continue\\n\\t\\t}\\n        \\n        if v[0] > newInterval[1] {\\n            ret = append(ret, newInterval)\\n            ret = append(ret, intervals[i:]...)\\n            return ret\\n\\t\\t}\\n        \\n        newInterval[0] = min(newInterval[0], v[0])\\n        newInterval[1] = max(newInterval[1], v[1])\\n\\t}\\n    return append(ret, newInterval)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279899,
                "title": "java-iteration-new-method-signature",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, size = intervals.length;\\n        while(i< size && intervals[i][1] < newInterval[0]){\\n            res.add(intervals[i]); \\n            i++;\\n        }\\n        while(i < size && intervals[i][0] <=  newInterval[1]){\\n           int[] cur = new int[]{Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])};\\n                newInterval = cur; \\n            i++;\\n        }\\n        res.add(newInterval);\\n        while(i < size){\\n            res.add(intervals[i]);\\n            i++;\\n        }\\n        int[][] insert = new int[res.size()][2];\\n        for(int j = 0; j < res.size(); j++){\\n            insert[j] = res.get(j);\\n        }\\n        return insert;\\n    }\\n}\\n```\\n\\nintervals[i][0] <= newInterval[1] is the key to create newInterval recursively.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> res = new ArrayList<>();\\n        int i = 0, size = intervals.length;\\n        while(i< size && intervals[i][1] < newInterval[0]){\\n            res.add(intervals[i]); \\n            i++;\\n        }\\n        while(i < size && intervals[i][0] <=  newInterval[1]){\\n           int[] cur = new int[]{Math.min(intervals[i][0], newInterval[0]), Math.max(intervals[i][1], newInterval[1])};\\n                newInterval = cur; \\n            i++;\\n        }\\n        res.add(newInterval);\\n        while(i < size){\\n            res.add(intervals[i]);\\n            i++;\\n        }\\n        int[][] insert = new int[res.size()][2];\\n        for(int j = 0; j < res.size(); j++){\\n            insert[j] = res.get(j);\\n        }\\n        return insert;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180320,
                "title": "python-easy-solution-beat-100-36ms",
                "content": "I extract all the start time points from intervals to a list, all the end time points to another list. Then make use of binary search to check the position of the newInterval. Once I found out the position ( the overlapping duration), then I replace them with the new interval.\\n```\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :type newInterval: Interval\\n        :rtype: List[Interval]\\n        \"\"\"\\n        left, right = newInterval.start, newInterval.end\\n        start = [interval.start for interval in intervals]\\n        end = [interval.end for interval in intervals]\\n        i = bisect.bisect_left(start, left)\\n        j = bisect.bisect(end, right)\\n        if i > 0 and left <= intervals[i-1].end:\\n            left = intervals[i-1].start\\n            i = i - 1\\n        if j < len(intervals) and right >= intervals[j].start:\\n            right = intervals[j].end\\n            j = j + 1\\n        intervals[i:j] = [Interval(left, right)]\\n        return intervals\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[Interval]\\n        :type newInterval: Interval\\n        :rtype: List[Interval]\\n        \"\"\"\\n        left, right = newInterval.start, newInterval.end\\n        start = [interval.start for interval in intervals]\\n        end = [interval.end for interval in intervals]\\n        i = bisect.bisect_left(start, left)\\n        j = bisect.bisect(end, right)\\n        if i > 0 and left <= intervals[i-1].end:\\n            left = intervals[i-1].start\\n            i = i - 1\\n        if j < len(intervals) and right >= intervals[j].start:\\n            right = intervals[j].end\\n            j = j + 1\\n        intervals[i:j] = [Interval(left, right)]\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21676,
                "title": "clean-and-short-java-solution-with-explanation",
                "content": "There are three cases with inserting an interval: \\n\\n 1. the start value of the newInterval < the old interval end:  insert the old interval and increment the index as we will know where this newInterval should be inserted.\\n 2.  the start value of the old interval > newInterval end:  we simply insert the old interval as there is no effect on where the newInterval should be inserted.\\n 3.  Otherwise, we need to merge the interval, simply be getting the min of start and max of end value.\\n\\nIn the end, we insert the newInterval based on the index we get on the fly.\\n\\n\\n    public class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            List<Interval> res = new ArrayList<>();\\n            int index = 0;\\n            for(int i = 0; i < intervals.size(); i++) {\\n                if(intervals.get(i).end < newInterval.start) {\\n                    res.add(intervals.get(i));\\n                    index++;\\n                } else if(intervals.get(i).start > newInterval.end) {\\n                    res.add(intervals.get(i));\\n                } else {\\n                    newInterval.start = Math.min(intervals.get(i).start, newInterval.start);\\n                    newInterval.end = Math.max(intervals.get(i).end, newInterval.end);\\n                }\\n            }\\n            res.add(index, newInterval);\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n            List<Interval> res = new ArrayList<>();\\n            int index = 0;\\n            for(int i = 0; i < intervals.size(); i++) {\\n                if(intervals.get(i).end < newInterval.start) {\\n                    res.add(intervals.get(i));\\n                    index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4077652,
                "title": "optimal-solution-o-n-line-by-line-commented-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n  O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int i = 0 ;\\n        int n = intervals.size();\\n        vector<vector<int>>result;\\n        while(i < intervals.size()){\\n          if(intervals[i][1] < newInterval[0]){\\n            result.push_back(intervals[i]);\\n          }\\n          else if(intervals[i][0] > newInterval[1]){\\n            break;   \\n          }\\n          else{ // merging step \\n        // newInterval\\'s starting point will be min. of starting point of both newIntervals and intervals\\n               newInterval[0] = min(newInterval[0] , intervals[i][0]);\\n               newInterval[1] = max(newInterval[1] , intervals[i][1]);\\n          }\\n          i++;\\n        }\\n        result.push_back(newInterval);\\n\\n        while(i < n ){ // if newInterval\\'s starting point will be greater than all given intervals\\'s stating point(we pass throuth loop)//\\n          result.push_back(intervals[i]);\\n          i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int i = 0 ;\\n        int n = intervals.size();\\n        vector<vector<int>>result;\\n        while(i < intervals.size()){\\n          if(intervals[i][1] < newInterval[0]){\\n            result.push_back(intervals[i]);\\n          }\\n          else if(intervals[i][0] > newInterval[1]){\\n            break;   \\n          }\\n          else{ // merging step \\n        // newInterval\\'s starting point will be min. of starting point of both newIntervals and intervals\\n               newInterval[0] = min(newInterval[0] , intervals[i][0]);\\n               newInterval[1] = max(newInterval[1] , intervals[i][1]);\\n          }\\n          i++;\\n        }\\n        result.push_back(newInterval);\\n\\n        while(i < n ){ // if newInterval\\'s starting point will be greater than all given intervals\\'s stating point(we pass throuth loop)//\\n          result.push_back(intervals[i]);\\n          i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929854,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        l = []\\n        for i in intervals:\\n            if i[1] < newInterval[0]:\\n                l.append(i)\\n            elif i[0] > newInterval[1]:\\n                l.append(newInterval)\\n                newInterval = i\\n            elif i[1] >= newInterval[0] or i[0] <= newInterval[1]:\\n                newInterval[0] = min(i[0],newInterval[0])\\n                newInterval[1] = max(newInterval[1],i[1])\\n        l.append(newInterval)\\n        return l\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        l = []\\n        for i in intervals:\\n            if i[1] < newInterval[0]:\\n                l.append(i)\\n            elif i[0] > newInterval[1]:\\n                l.append(newInterval)\\n                newInterval = i\\n            elif i[1] >= newInterval[0] or i[0] <= newInterval[1]:\\n                newInterval[0] = min(i[0],newInterval[0])\\n                newInterval[1] = max(newInterval[1],i[1])\\n        l.append(newInterval)\\n        return l\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057652,
                "title": "simple-easy-to-understand",
                "content": "# Complexity\n- Time complexity: **O(N)**\n\n- Space complexity: **O(1)** #if we ignore answer list\n\n# Code\n```\nclass Solution(object):\n    def insert(self, inter, new):\n        flag = False\n        res = []\n        for li in inter:\n            if not flag:\n                if li[0] > new[1]:\n                    res.append(new)\n                    res.append(li)\n                    flag = True\n                elif li[1] < new[0]:\n                    res.append(li)\n                elif new[0] >= li[0] and new[1] >= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif new[0] >= li[0] and new[0] <= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif li[0] >= new[0] and li[0] <= new[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n            else:\n                if res[-1][0] <= li[0] and li[0] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] >= res[-1][0] and li[1] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] <= res[-1][0] and res[-1][1] >= li[0]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                else:\n                    res.append(li)\n        if not flag: res.append(new)\n        return res\n```\nIf you have any **doubt** ask me in comments and UpVote, if you like it **:)**",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def insert(self, inter, new):\n        flag = False\n        res = []\n        for li in inter:\n            if not flag:\n                if li[0] > new[1]:\n                    res.append(new)\n                    res.append(li)\n                    flag = True\n                elif li[1] < new[0]:\n                    res.append(li)\n                elif new[0] >= li[0] and new[1] >= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif new[0] >= li[0] and new[0] <= li[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n                elif li[0] >= new[0] and li[0] <= new[1]:\n                    res.append([min(new[0], li[0]), max(new[1], li[1])])\n                    flag = True\n            else:\n                if res[-1][0] <= li[0] and li[0] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] >= res[-1][0] and li[1] <= res[-1][1]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                elif li[0] <= res[-1][0] and res[-1][1] >= li[0]:\n                    res[-1][0] = min(res[-1][0], li[0])\n                    res[-1][1] = max(res[-1][1], li[1])\n                else:\n                    res.append(li)\n        if not flag: res.append(new)\n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057584,
                "title": "fastest-python-solution-explained",
                "content": "# Intuition\\nThe intuition is simple we just need to expand the values which come under same component i.e. connected\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind the starting index from where potential connection can occur so if ending value of any given interval is greater than equal to newInterval starting value then they can be connected.\\n\\nSimilarly, if ending index of newInterval is greater than equal to starting value of any given interval then they can be also in potential conection. so change index of end pointer to current index\\n\\nFinally if starting pointer(intially st=-1) has not changed at that means newIntwrval is greatest of all. Similarly if end pointer(initially end=-1) has never changed that means it is before the interval pointed by starting pointer(st) \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        st=-1\\n        end=-1\\n        n=len(intervals)\\n        if n==0:\\n            return [newInterval]\\n        for i in range(n):\\n            if st==-1:\\n                if newInterval[0]<=intervals[i][1]:\\n                    st=i\\n            if st!=-1:\\n                if newInterval[1]>=intervals[i][0]:\\n                    end=i+1\\n        if st==-1:\\n            intervals.append(newInterval)\\n        elif end==-1:\\n            intervals.insert(st,newInterval)\\n        else:\\n            ni=[min(newInterval[0],intervals[st][0]),max(newInterval[1],intervals[end-1][1])]\\n            intervals[st:end]=[ni]\\n        \\n        return intervals\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        st=-1\\n        end=-1\\n        n=len(intervals)\\n        if n==0:\\n            return [newInterval]\\n        for i in range(n):\\n            if st==-1:\\n                if newInterval[0]<=intervals[i][1]:\\n                    st=i\\n            if st!=-1:\\n                if newInterval[1]>=intervals[i][0]:\\n                    end=i+1\\n        if st==-1:\\n            intervals.append(newInterval)\\n        elif end==-1:\\n            intervals.insert(st,newInterval)\\n        else:\\n            ni=[min(newInterval[0],intervals[st][0]),max(newInterval[1],intervals[end-1][1])]\\n            intervals[st:end]=[ni]\\n        \\n        return intervals\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057502,
                "title": "live-coding-0-ms-and-beats-99-with-video-explanation-in-english-and-hindi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nMy approach in ENGLISH\\n\\nhttps://youtu.be/qTTqgwvfBZs\\n\\nIN HINDI\\n\\nhttps://youtu.be/rDGgpi1HUXk\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        List<int[]>ans = new ArrayList();\\n        for(int i=0;i<n;i++){\\n            if(intervals[i][1]<newInterval[0]){\\n                ans.add(intervals[i]);\\n            }\\n            else if(intervals[i][0]>newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            }else if(intervals[i][1]>=newInterval[0] || intervals[i][0]<=newInterval[1]){\\n                newInterval[0] = Math.min(newInterval[0],intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1],intervals[i][1]);\\n            }\\n        }\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        List<int[]>ans = new ArrayList();\\n        for(int i=0;i<n;i++){\\n            if(intervals[i][1]<newInterval[0]){\\n                ans.add(intervals[i]);\\n            }\\n            else if(intervals[i][0]>newInterval[1]){\\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            }else if(intervals[i][1]>=newInterval[0] || intervals[i][0]<=newInterval[1]){\\n                newInterval[0] = Math.min(newInterval[0],intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1],intervals[i][1]);\\n            }\\n        }\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057466,
                "title": "c-begineer-friendly-easy-understanding-union-find-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/BCBBfE0HV_0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n        vector<vector<int>>ans;\\n\\n        // 2 cases.\\n        for(auto currentInterval:intervals){\\n        //case 1 :non overlapping\\n        // new interval is after current interval. add current interval to the ans.\\n        if(currentInterval[1]<newInterval[0]){ans.push_back(currentInterval);}\\n        // if new interval comes before current interval that means we need to make it current interval and check for overlaping with others. And our new interval will also be add to ans.\\n        else if(newInterval[1]<currentInterval[0]){\\n                    ans.push_back(newInterval);\\n                    //update it to new interval for overlapping checking.\\n                    newInterval = currentInterval;\\n        }\\n        // case 2 :overlapping\\n        else{\\n            // update the newInterval for checking overlapping.\\n            newInterval[0] = min(currentInterval[0],newInterval[0]);\\n            newInterval[1] = max(currentInterval[1],newInterval[1]);\\n\\n        }\\n\\n        }\\n        // Add the last non overlaping interval (newInterval)\\n        ans.push_back(newInterval);\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sort",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n        vector<vector<int>>ans;\\n\\n        // 2 cases.\\n        for(auto currentInterval:intervals){\\n        //case 1 :non overlapping\\n        // new interval is after current interval. add current interval to the ans.\\n        if(currentInterval[1]<newInterval[0]){ans.push_back(currentInterval);}\\n        // if new interval comes before current interval that means we need to make it current interval and check for overlaping with others. And our new interval will also be add to ans.\\n        else if(newInterval[1]<currentInterval[0]){\\n                    ans.push_back(newInterval);\\n                    //update it to new interval for overlapping checking.\\n                    newInterval = currentInterval;\\n        }\\n        // case 2 :overlapping\\n        else{\\n            // update the newInterval for checking overlapping.\\n            newInterval[0] = min(currentInterval[0],newInterval[0]);\\n            newInterval[1] = max(currentInterval[1],newInterval[1]);\\n\\n        }\\n\\n        }\\n        // Add the last non overlaping interval (newInterval)\\n        ans.push_back(newInterval);\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057150,
                "title": "python-solution-using-binary-search-and-simple-merge-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition was to first iterate through the `intervals` and find correct index to insert `newInterval`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this approach I first found the correct index to insert the given interval, and then the key to this question is understanding how to merge the intervals, Thus following are the steps involved in the question:\\n1) find the position where new interval should be inserted based on the end time of the intervals given. (used binary search to optimize time)\\n2) for merging intervals take minimum of ( `intervals[k][0]` and `newInterval[0]` ) and maximum of ( `intervals[k][0]` and `newInterval[0]` )    \\nNote: here `k` is the index found using binary search\\n3) simply store it in new result list and return it.\\n\\nThis approach is quite fast:\\n![asdasd.PNG](https://assets.leetcode.com/users/images/91b1baa7-3f3b-40a4-9895-ea2e219b3134_1673846919.1683147.png)\\n\\n\\nHope it Helps!!\\n\\n# Code\\n```\\ndef binary_search(x, n):\\n    s = 0\\n    e = len(x) - 1\\n    while s<=e:\\n        mid = (s+e)//2\\n        if x[mid] == n:\\n            return mid\\n        elif x[mid] < n:\\n            s  = mid + 1\\n        else:\\n            e = mid - 1\\n    return e+1\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            intervals.append(newInterval)\\n            return intervals\\n        x = []\\n        for i in range(len(intervals)):\\n            x.append(intervals[i][1])\\n\\n        k = binary_search(x,newInterval[0])\\n        res = intervals[:k] #to store intervals till `k`th index\\n        while k < len(intervals) and intervals[k][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[k][0], newInterval[0])\\n            newInterval[1] = max(intervals[k][1], newInterval[1])\\n            k += 1\\n        res.append(newInterval)\\n        #adding remaining elements to the list\\n        res += intervals[k:]  \\n        return res        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\ndef binary_search(x, n):\\n    s = 0\\n    e = len(x) - 1\\n    while s<=e:\\n        mid = (s+e)//2\\n        if x[mid] == n:\\n            return mid\\n        elif x[mid] < n:\\n            s  = mid + 1\\n        else:\\n            e = mid - 1\\n    return e+1\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        if not intervals:\\n            intervals.append(newInterval)\\n            return intervals\\n        x = []\\n        for i in range(len(intervals)):\\n            x.append(intervals[i][1])\\n\\n        k = binary_search(x,newInterval[0])\\n        res = intervals[:k] #to store intervals till `k`th index\\n        while k < len(intervals) and intervals[k][0] <= newInterval[1]:\\n            newInterval[0] = min(intervals[k][0], newInterval[0])\\n            newInterval[1] = max(intervals[k][1], newInterval[1])\\n            k += 1\\n        res.append(newInterval)\\n        #adding remaining elements to the list\\n        res += intervals[k:]  \\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845908,
                "title": "java-solution-with-simple-explanation",
                "content": "### Simulation\\n\\nIdea: We just need to deal with the insert interval, the intervals outside the range of insert interval, we just put it in the list. For those intervals within the range of insert interval, we need to merge them together.\\n\\n```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ansList = new ArrayList<>();\\n        int i = 0;\\n\\n        // add all the intervals before newInterval starts\\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        // merge intervals with the insert interval\\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        ansList.add(newInterval);\\n\\n        // add the rest of intervals\\n        while (i < intervals.length) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        int[][] ans = new int[ansList.size()][2];\\n        for (int j = 0; j < ansList.size(); j++)\\n            ans[j] = ansList.get(j);\\n\\n        return ans;\\n    }\\n}\\n```\\n\\nComplexity Analysis:\\n\\n- Time Complexity: $O(n)$. $n$ is the length of intervals.\\n- Space Complexity: $O(1)$. We only use extra space for variables.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ansList = new ArrayList<>();\\n        int i = 0;\\n\\n        // add all the intervals before newInterval starts\\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        // merge intervals with the insert interval\\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        ansList.add(newInterval);\\n\\n        // add the rest of intervals\\n        while (i < intervals.length) {\\n            ansList.add(intervals[i]);\\n            i++;\\n        }\\n\\n        int[][] ans = new int[ansList.size()][2];\\n        for (int j = 0; j < ansList.size(); j++)\\n            ans[j] = ansList.get(j);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710112,
                "title": "java-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) for result array\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        int i=0;\\n        while(i<intervals.length && intervals[i][1]< newInterval[0]){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        while(i<intervals.length && newInterval[1] >= intervals[i][0] ){\\n            newInterval[0]= Math.min(newInterval[0],intervals[i][0]);\\n            newInterval[1]= Math.max(newInterval[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.add(newInterval);\\n        while(i<intervals.length){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> result = new ArrayList<>();\\n        int i=0;\\n        while(i<intervals.length && intervals[i][1]< newInterval[0]){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        while(i<intervals.length && newInterval[1] >= intervals[i][0] ){\\n            newInterval[0]= Math.min(newInterval[0],intervals[i][0]);\\n            newInterval[1]= Math.max(newInterval[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.add(newInterval);\\n        while(i<intervals.length){\\n            result.add(intervals[i]);\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587472,
                "title": "c-clean-and-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/25238441-3aa0-4ea3-a549-39e8e6ae2ad3_1663422186.4353445.png)\\n\\n\\nThis solution is very easy and begginer friendly.\\n\\nExplanation :\\n\\nI have used two for loops one for inserting the newInterval and the second loop for merging intervals.\\n\\nI have also added 2 edge cases(it is self explanatory)\\n\\nThis is my Solution:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n         vector<vector<int>> output;\\n        if(intervals.size()==0){//edge case1\\n            output.push_back(newInterval);\\n        return output;\\n        }\\n        int flag=1;\\n        for (int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]>newInterval[0]){\\n                intervals.insert(intervals.begin() + i,newInterval);\\n                flag=0;\\n            break;\\n            }\\n        }\\n        if (flag==1)//edge case2\\n            intervals.push_back(newInterval);\\n        \\n        output.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(output.back()[1]>=intervals[i][0])\\n                output.back()[1]=max(output.back()[1],intervals[i][1]);\\n            else\\n                output.push_back(intervals[i]);\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\nIt takes only 1 sec to Upvote!!!\\nThanks in advance.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n         vector<vector<int>> output;\\n        if(intervals.size()==0){//edge case1\\n            output.push_back(newInterval);\\n        return output;\\n        }\\n        int flag=1;\\n        for (int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]>newInterval[0]){\\n                intervals.insert(intervals.begin() + i,newInterval);\\n                flag=0;\\n            break;\\n            }\\n        }\\n        if (flag==1)//edge case2\\n            intervals.push_back(newInterval);\\n        \\n        output.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(output.back()[1]>=intervals[i][0])\\n                output.back()[1]=max(output.back()[1],intervals[i][1]);\\n            else\\n                output.push_back(intervals[i]);\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576902,
                "title": "c-easiest-to-understand-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size()-1;\\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < intervals.size(); i++){\\n            if(intervals[i][1] < newInterval[0]){\\n                res.push_back(intervals[i]);\\n            }\\n            \\n            else if(intervals[i][0] > newInterval[1]){\\n                res.push_back(newInterval);\\n                newInterval = intervals[i];\\n            }\\n            \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(intervals[i][1], newInterval[1]);\\n            }\\n        }\\n       res.push_back(newInterval);\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        int n = intervals.size()-1;\\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < intervals.size(); i++){\\n            if(intervals[i][1] < newInterval[0]){\\n                res.push_back(intervals[i]);\\n            }\\n            \\n            else if(intervals[i][0] > newInterval[1]){\\n                res.push_back(newInterval);\\n                newInterval = intervals[i];\\n            }\\n            \\n            else if(intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]){\\n                newInterval[0] = min(intervals[i][0], newInterval[0]);\\n                newInterval[1] = max(intervals[i][1], newInterval[1]);\\n            }\\n        }\\n       res.push_back(newInterval);\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563315,
                "title": "python-2-different-solutions-with-explanation",
                "content": "# Approach 1: O(nlogn)\\nThis is exactly the same thing as the problem **[56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)**, except at the beginning of the we append the new interval into the list.\\n\\nIn the for loop, we check if the intervals are overlapping or not (whether the last interval in the resultant list\\'s end time is greater than the start time of the new interval). If they overlap, we merge them by setting the last interval in the resultant list\\'s end time to be the maximum of the 2 intervals.\\n```py\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        intervals.append(newInterval)\\n        intervals.sort()\\n        merged = []\\n        for interval in intervals:\\n            if merged and merged[-1][1] >= interval[0]:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n            else:\\n                merged.append(interval)\\n        return merged\\n```\\n\\n# Approach 2: O(n)\\nWe cover the 3 basic scenarios:\\n1. The current interval is before the interval we want to add (we just add the current interval)\\n2. The current interval is after the one we want to add (we add the new interval, and update the new interval since it\\'s now added already)\\n3. The intervals overlap (we merge them, and update the new interval. NO ADDING YET)\\n\\n\\n```py \\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        for interval in intervals:\\n            if interval[1] < newInterval[0]:\\n                res.append(interval)\\n            elif interval[0] > newInterval[1]:\\n                res.append(newInterval)\\n                newInterval = interval\\n            else:\\n                newInterval[0] = min(newInterval[0], interval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n        res.append(newInterval)\\n            \\n        return res\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```py\\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        intervals.append(newInterval)\\n        intervals.sort()\\n        merged = []\\n        for interval in intervals:\\n            if merged and merged[-1][1] >= interval[0]:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n            else:\\n                merged.append(interval)\\n        return merged\\n```\n```py \\nclass Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        for interval in intervals:\\n            if interval[1] < newInterval[0]:\\n                res.append(interval)\\n            elif interval[0] > newInterval[1]:\\n                res.append(newInterval)\\n                newInterval = interval\\n            else:\\n                newInterval[0] = min(newInterval[0], interval[0])\\n                newInterval[1] = max(newInterval[1], interval[1])\\n        res.append(newInterval)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058154,
                "title": "java-simple-solution-with-explanation",
                "content": "Check below solution with explanation\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\n\\t\\t\\t// base condition\\n\\t\\t\\tif(intervals.length == 0)\\n\\t\\t\\t\\treturn new int[][]{newInterval};\\n\\n\\t\\t\\t// define start and end\\n\\t\\t\\tint start  = newInterval[0];\\n\\t\\t\\tint end  = newInterval[1];\\n\\n\\t\\t\\tList<int[]> output = new ArrayList<>();\\n\\n\\t\\t\\t// to insert any interval in sorted array we need to find the place where it needs to be added\\n\\t\\t\\t// to do that we will first add all intervals in output list which has end less than new interval\\n\\t\\t\\tint i = 0;\\n\\t\\t\\twhile(i < intervals.length && intervals[i][1] < start){\\n\\t\\t\\t\\toutput.add(new int[]{intervals[i][0],intervals[i][1]});\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// once we found the place where new interval should be added using above while loop we will use same logic as merge interval\\n\\t\\t\\t// we will compare new interval and current interval. If merging needed we will merge and add it in the list. \\n\\t\\t\\twhile(i < intervals.length){\\n\\t\\t\\t\\tif(intervals[i][0] <= end){\\n\\t\\t\\t\\t\\tstart = Math.min(start, intervals[i][0]);\\n\\t\\t\\t\\t\\tend = Math.max(end, intervals[i][1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\toutput.add(new int[]{start,end});\\n\\t\\t\\t\\t\\tstart = intervals[i][0];\\n\\t\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add last remaining interval\\n\\t\\t\\toutput.add(new int[]{start, end});\\n\\n\\t\\t\\t// convert list to 2d array\\n\\t\\t\\tint[][] insertInterval = output.toArray(new int[output.size()][]);\\n\\n\\t\\t\\t// return\\n\\t\\t\\treturn insertInterval;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\n\\t\\t\\t// base condition\\n\\t\\t\\tif(intervals.length == 0)\\n\\t\\t\\t\\treturn new int[][]{newInterval}",
                "codeTag": "Java"
            },
            {
                "id": 1742085,
                "title": "c-easy-and-convivence",
                "content": "```\\nbool comp(vector<int>&a,vector<int>&b)\\n{\\n    return a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newIntervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        vector<vector<int>>ans;\\n        for(auto it:intervals)\\n        {\\n            if(it[1]<newIntervals[0]){\\n                ans.push_back(it);\\n            }\\n            else if(it[0]>newIntervals[1]){\\n                ans.push_back(newIntervals);\\n                newIntervals=it;\\n            }\\n            else{\\n                newIntervals[0]=min(it[0],newIntervals[0]);\\n                newIntervals[1]=max(it[1],newIntervals[1]);\\n            }\\n        }\\n        ans.push_back(newIntervals);\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool comp(vector<int>&a,vector<int>&b)\\n{\\n    return a[1]<b[1];\\n}\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newIntervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        vector<vector<int>>ans;\\n        for(auto it:intervals)\\n        {\\n            if(it[1]<newIntervals[0]){\\n                ans.push_back(it);\\n            }\\n            else if(it[0]>newIntervals[1]){\\n                ans.push_back(newIntervals);\\n                newIntervals=it;\\n            }\\n            else{\\n                newIntervals[0]=min(it[0],newIntervals[0]);\\n                newIntervals[1]=max(it[1],newIntervals[1]);\\n            }\\n        }\\n        ans.push_back(newIntervals);\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721591,
                "title": "c-visualized-explanation-and-analytics-99-faster-and-clean",
                "content": "**Method 1: Straightforward**\\n\\n```\\n1. \\ninterval     |__|\\nnewInterval       |_____|\\n\\n2.\\ninterval       |__|\\nnewInterval       |_____|\\n\\n3.\\ninterval        |__|\\nnewInterval       |_____|\\n\\n4.\\ninterval          |__|\\nnewInterval       |_____|\\n\\n5.\\ninterval            |__|\\nnewInterval       |_____|\\n\\n6.\\ninterval             |__|\\nnewInterval       |_____|\\n\\n7.\\ninterval                |__|\\nnewInterval       |_____|\\n\\n8.\\ninterval                  |__|\\nnewInterval       |_____|\\n```\\n\\n\\nThere are 8 possible relationships between interval and newInterval.\\n\\n**Goal: \\n1 and 8 are easy, so we have to focus on overlapping (2-7)!**\\n\\n```plain\\ncase 1: \\t       if interval[END] is smaller than newInterval[START], just push_back to ans\\ncase 2-7: \\t       if interval[START] is smaller or equal newInterval[END], \\n(overlapping)        we keep the min and max value as start and end of the newInterval\\ncase 8:            if we encounter the first non-overlapping interval\\n\\t\\t\\t\\t\\t push back newInterval and keep the index, then break\\n\\t\\t\\t\\t\\t we will finish the remaining non-overlapping interval\\n```\\n\\nThe algorithm will fail if the newInterval is non-overlapping and last interval,\\nso if `index` is default value (-1), we push back newInterval.\\n\\n```cpp\\n#define START 0\\n#define END 1\\n\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    int index = -1;\\n    for (int i = 0; i < intervals.size(); i++) {\\n      if (intervals[i][END] < newInterval[START]) {\\n        ans.push_back(intervals[i]);\\n      } else if (intervals[i][START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(intervals[i][START], newInterval[START]);\\n        newInterval[END] = max(intervals[i][END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        index = i;\\n        break;\\n      }\\n    }\\n    if (index == -1) {\\n      // if newInterval is the last interval\\n      ans.push_back(newInterval);\\n    } else {\\n      // finish the non-overlapping interval\\n      for (int i = index; i < intervals.size(); i++)\\n        ans.push_back(intervals[i]);\\n    }\\n    return ans;\\n  }\\n};\\n```\\n\\nTime Complexity: O(n), where n is the size of intervals\\nSpace Complexity: O(n)\\nRuntime: 7 ms, faster than 99.17% of C++ online submissions for Insert Interval.\\nMemory Usage: 17.2 MB, less than 40.83% of C++ online submissions for Insert Interval.\\n\\n\\n**Method 2: Clean Version**\\nby reusing the newInterval but more runtime\\n\\n```cpp\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    for (vector<int>& interval: intervals) {\\n      if (interval[END] < newInterval[START]) {\\n        ans.push_back(interval);\\n      } else if (interval[START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(interval[START], newInterval[START]);\\n        newInterval[END] = max(interval[END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        newInterval = interval;\\n      }\\n    }\\n    ans.push_back(newInterval);\\n    return ans;\\n  }\\n};\\n```\\nRuntime: 8 ms, faster than 98.95% of C++ online submissions for Insert Interval.\\nMemory Usage: 16.9 MB, less than 99.47% of C++ online submissions for Insert Interval.\\n\\n**If you have any suggestion or advice, feel free to contact me!**\\n",
                "solutionTags": [],
                "code": "```\\n1. \\ninterval     |__|\\nnewInterval       |_____|\\n\\n2.\\ninterval       |__|\\nnewInterval       |_____|\\n\\n3.\\ninterval        |__|\\nnewInterval       |_____|\\n\\n4.\\ninterval          |__|\\nnewInterval       |_____|\\n\\n5.\\ninterval            |__|\\nnewInterval       |_____|\\n\\n6.\\ninterval             |__|\\nnewInterval       |_____|\\n\\n7.\\ninterval                |__|\\nnewInterval       |_____|\\n\\n8.\\ninterval                  |__|\\nnewInterval       |_____|\\n```\n```plain\\ncase 1: \\t       if interval[END] is smaller than newInterval[START], just push_back to ans\\ncase 2-7: \\t       if interval[START] is smaller or equal newInterval[END], \\n(overlapping)        we keep the min and max value as start and end of the newInterval\\ncase 8:            if we encounter the first non-overlapping interval\\n\\t\\t\\t\\t\\t push back newInterval and keep the index, then break\\n\\t\\t\\t\\t\\t we will finish the remaining non-overlapping interval\\n```\n```cpp\\n#define START 0\\n#define END 1\\n\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    int index = -1;\\n    for (int i = 0; i < intervals.size(); i++) {\\n      if (intervals[i][END] < newInterval[START]) {\\n        ans.push_back(intervals[i]);\\n      } else if (intervals[i][START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(intervals[i][START], newInterval[START]);\\n        newInterval[END] = max(intervals[i][END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        index = i;\\n        break;\\n      }\\n    }\\n    if (index == -1) {\\n      // if newInterval is the last interval\\n      ans.push_back(newInterval);\\n    } else {\\n      // finish the non-overlapping interval\\n      for (int i = index; i < intervals.size(); i++)\\n        ans.push_back(intervals[i]);\\n    }\\n    return ans;\\n  }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n  vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n    vector<vector<int>> ans;\\n    for (vector<int>& interval: intervals) {\\n      if (interval[END] < newInterval[START]) {\\n        ans.push_back(interval);\\n      } else if (interval[START] <= newInterval[END]) {\\n        // if it is overlapping interval, we keep the min and max value as start and end\\n        newInterval[START] = min(interval[START], newInterval[START]);\\n        newInterval[END] = max(interval[END], newInterval[END]);\\n      } else {\\n        // if we encounter the first non-overlapping interval\\n        // push back newInterval and keep the index, then break\\n        ans.push_back(newInterval);\\n        newInterval = interval;\\n      }\\n    }\\n    ans.push_back(newInterval);\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515974,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i = 0, n = intervals.size();\\n        while(i < n && intervals[i][1] < newInterval[0]) result.push_back(intervals[i++]);\\n        \\n        vector<int> mI = newInterval;\\n        while(i < n && intervals[i][0] <= newInterval[1]){\\n            mI[0] = min(mI[0], intervals[i][0]);\\n            mI[1] = max(mI[1], intervals[i++][1]);\\n        }\\n        result.push_back(mI);\\n        \\n        while(i < n) result.push_back(intervals[i++]);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int i = 0, n = intervals.size();\\n        while(i < n && intervals[i][1] < newInterval[0]) result.push_back(intervals[i++]);\\n        \\n        vector<int> mI = newInterval;\\n        while(i < n && intervals[i][0] <= newInterval[1]){\\n            mI[0] = min(mI[0], intervals[i][0]);\\n            mI[1] = max(mI[1], intervals[i++][1]);\\n        }\\n        result.push_back(mI);\\n        \\n        while(i < n) result.push_back(intervals[i++]);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451390,
                "title": "interval-simple-solution-o-n-time-c",
                "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] ni) {\\n        \\n        int i=0, n=intervals.length;\\n        \\n        LinkedList<int []> res=new LinkedList<>();\\n        \\n        while(i<n && ni[0]>intervals[i][1])\\n        {\\n            res.add(intervals[i++]);\\n        }\\n        \\n        while(i <n && intervals[i][0]<=ni[1])\\n        {\\n            ni[0]=Math.min(intervals[i][0],ni[0]);\\n            ni[1]=Math.max(intervals[i][1],ni[1]);\\n            i++;\\n        }\\n        \\n        res.add(ni);\\n        \\n        while(i<n)\\n        {\\n            res.add(intervals[i++]);\\n        }\\n        \\n        return res.toArray(new int[res.size()][2]);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] ni) {\\n        \\n        int i=0, n=intervals.length;\\n        \\n        LinkedList<int []> res=new LinkedList<>();\\n        \\n        while(i<n && ni[0]>intervals[i][1])\\n        {\\n            res.add(intervals[i++]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1441307,
                "title": "python3-o-n-concise-solution-99-9-binary-search-merge-intervals",
                "content": "**Explanation**\\nSince the given intervals is already in sorted order, we can use binary search to find the insertion point. Then, merge the interval if necessary.\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\n```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        i = bisect.bisect_left(intervals, newInterval)\\n        res = intervals[:i]\\n        for interval in [newInterval]+intervals[i:]:\\n            if res and res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        i = bisect.bisect_left(intervals, newInterval)\\n        res = intervals[:i]\\n        for interval in [newInterval]+intervals[i:]:\\n            if res and res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347799,
                "title": "java-solution-easy-to-understand",
                "content": "**Runtime: 1 ms\\nMemory Usage: 41.4 MB**\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        LinkedList<int[]> list = new LinkedList();\\n        \\n        int idx = 0;\\n        \\n        while(idx < intervals.length && intervals[idx][0] < newInterval[0]){\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        if(list.size() == 0 || list.getLast()[1] <  newInterval[0]){\\n            list.add(newInterval);\\n        }else{\\n            list.getLast()[1] = Math.max(list.getLast()[1],newInterval[1]);\\n        }\\n        \\n        while(idx < intervals.length){\\n            if(list.getLast()[1] < intervals[idx][0])list.add(intervals[idx]);\\n            else list.getLast()[1] = Math.max(list.getLast()[1],intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        return list.toArray(new int[list.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        LinkedList<int[]> list = new LinkedList();\\n        \\n        int idx = 0;\\n        \\n        while(idx < intervals.length && intervals[idx][0] < newInterval[0]){\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        if(list.size() == 0 || list.getLast()[1] <  newInterval[0]){\\n            list.add(newInterval);\\n        }else{\\n            list.getLast()[1] = Math.max(list.getLast()[1],newInterval[1]);\\n        }\\n        \\n        while(idx < intervals.length){\\n            if(list.getLast()[1] < intervals[idx][0])list.add(intervals[idx]);\\n            else list.getLast()[1] = Math.max(list.getLast()[1],intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        return list.toArray(new int[list.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295056,
                "title": "javascript-very-easy-to-understand",
                "content": "```\\nvar insert = function(intervals, newInterval) {\\n    const result = [newInterval];\\n    for (const interval of intervals) {\\n        const last = result.pop();\\n        if (last[1] < interval[0]) {\\n\\t\\t // last comes before current interval\\n            result.push(last);\\n            result.push(interval)\\n        } else if (last[0] > interval[1]) {\\n\\t\\t// last comes after current interval\\n            result.push(interval);\\n            result.push(last)\\n        } else {\\n\\t\\t// intersection\\n            result.push([Math.min(last[0], interval[0]), Math.max(last[1], interval[1])])\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function(intervals, newInterval) {\\n    const result = [newInterval];\\n    for (const interval of intervals) {\\n        const last = result.pop();\\n        if (last[1] < interval[0]) {\\n\\t\\t // last comes before current interval\\n            result.push(last);\\n            result.push(interval)\\n        } else if (last[0] > interval[1]) {\\n\\t\\t// last comes after current interval\\n            result.push(interval);\\n            result.push(last)\\n        } else {\\n\\t\\t// intersection\\n            result.push([Math.min(last[0], interval[0]), Math.max(last[1], interval[1])])\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239530,
                "title": "first-attempt-efficient-solution",
                "content": "First Attempt, which is O(n)\\n```\\nvar insert = function(intervals, newInterval) {\\n    const size = intervals.length;\\n    const [start, end] = newInterval;\\n    \\n    const overlap = (interval) => {\\n        const [first, last] = interval;\\n        //3...5    <-first, last\\n        //  4....8 <-start, end\\n        if(start <= last &&  end >= last) return true;\\n        //1...5 <-first, last\\n        // 2.3  <-start, end\\n        return (first <= end && last >= end);\\n    }\\n    \\n    const overlaps = intervals.map(overlap);\\n    const result = [];\\n\\t\\n\\t//push left\\n    let i = 0;\\n    while(i < size && overlaps[i] === false && intervals[i][0] < end) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n\\t//merge overlaps\\n    let min = start;\\n    let max = end;\\n    while(i < size && overlaps[i]) {\\n        min = Math.min(min, intervals[i][0]);\\n        max = Math.max(max, intervals[i][1]);\\n        i++;\\n    }\\n    \\n    result.push([min, max]);\\n    \\n\\t//push right\\n    while(i < size) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n    return result;\\n};\\n```\\n\\nThis can be solved in one single pass\\n```\\nvar insert = function(intervals, newInterval) {\\n    const [start, end] = newInterval;\\n    const left = [];\\n    const right = [];\\n    let min = start;\\n    let max = end;\\n    \\n    for(const interval of intervals) {\\n        const [first, last] = interval;\\n        if(last < start) {\\n            left.push(interval);\\n        } else if(first > end) {\\n            right.push(interval);\\n        } else {\\n            min = Math.min(min, first);\\n            max = Math.max(max, last);\\n        }\\n    }\\n    \\n    return [...left, [min, max], ...right];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insert = function(intervals, newInterval) {\\n    const size = intervals.length;\\n    const [start, end] = newInterval;\\n    \\n    const overlap = (interval) => {\\n        const [first, last] = interval;\\n        //3...5    <-first, last\\n        //  4....8 <-start, end\\n        if(start <= last &&  end >= last) return true;\\n        //1...5 <-first, last\\n        // 2.3  <-start, end\\n        return (first <= end && last >= end);\\n    }\\n    \\n    const overlaps = intervals.map(overlap);\\n    const result = [];\\n\\t\\n\\t//push left\\n    let i = 0;\\n    while(i < size && overlaps[i] === false && intervals[i][0] < end) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n\\t//merge overlaps\\n    let min = start;\\n    let max = end;\\n    while(i < size && overlaps[i]) {\\n        min = Math.min(min, intervals[i][0]);\\n        max = Math.max(max, intervals[i][1]);\\n        i++;\\n    }\\n    \\n    result.push([min, max]);\\n    \\n\\t//push right\\n    while(i < size) {\\n        result.push(intervals[i++]);\\n    }\\n    \\n    return result;\\n};\\n```\n```\\nvar insert = function(intervals, newInterval) {\\n    const [start, end] = newInterval;\\n    const left = [];\\n    const right = [];\\n    let min = start;\\n    let max = end;\\n    \\n    for(const interval of intervals) {\\n        const [first, last] = interval;\\n        if(last < start) {\\n            left.push(interval);\\n        } else if(first > end) {\\n            right.push(interval);\\n        } else {\\n            min = Math.min(min, first);\\n            max = Math.max(max, last);\\n        }\\n    }\\n    \\n    return [...left, [min, max], ...right];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166865,
                "title": "python-easy-o-n",
                "content": "```\\n        s, e = newInterval[0], newInterval[1]\\n        merge, left, right = [], [], []\\n        \\n        for i in intervals:\\n            if i[1] < s:\\n                left.append(i)\\n            elif e < i[0]:\\n                right.append(i)\\n            else:\\n                merge.append(i)\\n\\n        if merge:\\n            s = min(s, merge[0][0])\\n            e = max(e, merge[-1][1])\\n        return left + [[s,e]]+ right\\n```",
                "solutionTags": [],
                "code": "```\\n        s, e = newInterval[0], newInterval[1]\\n        merge, left, right = [], [], []\\n        \\n        for i in intervals:\\n            if i[1] < s:\\n                left.append(i)\\n            elif e < i[0]:\\n                right.append(i)\\n            else:\\n                merge.append(i)\\n\\n        if merge:\\n            s = min(s, merge[0][0])\\n            e = max(e, merge[-1][1])\\n        return left + [[s,e]]+ right\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140661,
                "title": "java-1ms-99-faster",
                "content": "```\\n public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        \\n        for(int[] interval: intervals){\\n            if(interval[1] < newInterval[0])\\n                list.add(interval);\\n            else if(interval[0] > newInterval[1]){\\n                list.add(newInterval);\\n                newInterval = interval;\\n            }else {\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        \\n        for(int[] interval: intervals){\\n            if(interval[1] < newInterval[0])\\n                list.add(interval);\\n            else if(interval[0] > newInterval[1]){\\n                list.add(newInterval);\\n                newInterval = interval;\\n            }else {\\n                newInterval[0] = Math.min(newInterval[0], interval[0]);\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            }\\n        }\\n        \\n        list.add(newInterval);\\n        return list.toArray(new int[list.size()][]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947241,
                "title": "python3-simple-easy-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals += [newInterval]\\n        intervals.sort()\\n        merge = []\\n        for interval in intervals:\\n            if not merge or merge[-1][1] < interval[0]:\\n                merge.append(interval)\\n            else:\\n                merge[-1][1] = max(merge[-1][1], interval[1])\\n        return merge\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals += [newInterval]\\n        intervals.sort()\\n        merge = []\\n        for interval in intervals:\\n            if not merge or merge[-1][1] < interval[0]:\\n                merge.append(interval)\\n            else:\\n                merge[-1][1] = max(merge[-1][1], interval[1])\\n        return merge\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844488,
                "title": "python-3-o-n-insert-intervals-easy-math-solution",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        leftList, rightList=[],[]\\n        START,END=0,1\\n        \\n        for currentInterval in intervals:\\n            if currentInterval[END]< newInterval[START]:\\n                leftList+= [currentInterval]\\n            \\n            elif currentInterval[START]> newInterval[END]:\\n                rightList+=[currentInterval]\\n            \\n            else:\\n                newInterval[START]= min(currentInterval[START],newInterval[START])\\n                newInterval[END]= max(currentInterval[END], newInterval[END])\\n        \\n        return leftList + [[newInterval[START], newInterval[END]]] + rightList\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        leftList, rightList=[],[]\\n        START,END=0,1\\n        \\n        for currentInterval in intervals:\\n            if currentInterval[END]< newInterval[START]:\\n                leftList+= [currentInterval]\\n            \\n            elif currentInterval[START]> newInterval[END]:\\n                rightList+=[currentInterval]\\n            \\n            else:\\n                newInterval[START]= min(currentInterval[START],newInterval[START])\\n                newInterval[END]= max(currentInterval[END], newInterval[END])\\n        \\n        return leftList + [[newInterval[START], newInterval[END]]] + rightList\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 790477,
                "title": "python-binary-search-o-n-time-o-1-space",
                "content": "Hello,\\n\\nHere are my two solutions. The analysis follows. \\n\\t- Solution 1: `\\u0398(n)`time and `O(1)` space\\n\\t- Solution 2: `O(logn)`best time,`O(n)`worst time and`O(n)`space: see Complexity Analsysis below.\\n\\n- **Intuition**:\\n\\t\\t\\t\\n\\t\\t\\t- Binary Search : find the intervals new_interval overlap with : insert_start=i, insert_end=j :\\n\\t\\t\\tIntervals :              |---0---| ... |--i-1--||---i---|  ... |---j---||--j+1--|  ... |---n---| \\n\\t\\t\\tnew_interval :                                     |--------------|\\n\\t\\t\\t\\n\\t\\t\\t- Update new_interval :\\n\\t\\t\\tIntervals :              |---0---| ... |--i-1--||---i---|  ... |---j---||--j+1--|  ... |---n---| \\n\\t\\t\\tnew_interval :                                  |----------------------|\\n\\t\\t\\t\\n\\t\\t\\t- Return [0 : i[ + new_interval + ]j : n] :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t |---0---| ... |--i-1--||----------------------||--j+1--|  ... |---n---| \\n\\n- **Implementation**:\\n\\n```\\ndef __init__(self):\\n\\tself._start, self._end = 0, 1 # interval start and end indexes\\n\\ndef _binary_search(self, intervals: List[List[int]], val, l=0, r=None):\\n\\tif r is None:\\n\\t\\tr = len(intervals) - 1\\n\\t\\n\\twhile l <= r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tif intervals[mid][self._start] <= val <= intervals[mid][self._end]:\\n\\t\\t\\treturn mid\\n            \\n\\t\\telif val > intervals[mid][self._end]:\\n\\t\\t\\tl = mid + 1\\n                \\n\\t\\telse:\\n\\t\\t\\tr = mid - 1\\n        \\n\\treturn l\\n\\n# Solution 1:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\n\\tintervals_count = len(intervals)\\n\\t\\n\\t# 1. Search the interval where new_interval.start fits in: O(logn) time\\n\\tval = new_interval[self._start]\\n\\tinsert_start = self._binary_search(intervals, val)\\n\\tif insert_start < intervals_count and intervals[insert_start][self._start] <= val <= intervals[insert_start][self._end]:\\n\\t\\tnew_interval[self._start] = intervals[insert_start][self._start]\\n\\t\\tnew_interval[self._end] = max(intervals[insert_start][self._end], new_interval[self._end])        \\n\\t\\n\\t# 2. Search the interval where new_interval.end fits in: O(logn) time\\n\\tval = new_interval[self._end]\\n\\tinsert_end = self._binary_search(intervals, val, insert_start)\\n\\tif insert_end < intervals_count and intervals[insert_end][self._start] <= val:\\n\\t\\tnew_interval[self._end] = max(intervals[insert_end][self._end], new_interval[self._end])\\n\\t\\tinsert_end += 1\\n\\t\\n\\t# 3. Replace overlapping intervals with new_interval: O(n) time and O(1) space\\n\\tintervals[insert_start:insert_end] = [new_interval]\\n\\t\\n\\treturn intervals\\n\\n```\\n\\n```\\n# Solution 2:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\t# Same as above\\n\\t# ...\\n\\t\\n\\t# 3. Create new merged_intervals list: O(n) time in worst case and O(n) space\\n\\tmerged_intervals = intervals[:insert_start]       # Insert all intervals before insert_start\\n    merged_intervals.append(new_interval)             # Insert new_interval\\n    merged_intervals.extend(intervals[insert_end:])   # Insert all intervals after insert_end\\n\\t\\n\\treturn merged_intervals\\n\\t\\n```\\n\\n- **Complexity Analysis**:\\n\\t- Let\\'s `n` be the length of the input list `intervals`\\n\\t- Let\\'s `m` be the length of the output list\\n\\t- Solution 1:\\n\\t\\t- The input is modified and returned\\n\\t\\t- Space Complexity: `O(1)` \\n\\t\\t- Time Complexity: `O(n)`\\n\\t\\t- It requires to delete from`intervals`all overlapping intervals\\n\\t- Solution 2:\\n\\t\\t- A new list is returned\\n\\t\\t- Space Complexity:`O(m)` \\n\\t\\t- Time Complexity:`\\u0398(max(logn, m)) = O(n)`(here `n` is an upper-bound only)\\n\\t\\t- The worst case time complexity is`O(n)`: happens for example when`new_interval`doesn\\'t overlap with`intervals`\\n\\t\\t- The best case time complexity is`O(logn)`: happens for example when`new_interval`overlaps whith the majority of`intervals`, more than`n - logn`\\n\\t\\t- In practice, this solution is faster than solution 1\\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef __init__(self):\\n\\tself._start, self._end = 0, 1 # interval start and end indexes\\n\\ndef _binary_search(self, intervals: List[List[int]], val, l=0, r=None):\\n\\tif r is None:\\n\\t\\tr = len(intervals) - 1\\n\\t\\n\\twhile l <= r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tif intervals[mid][self._start] <= val <= intervals[mid][self._end]:\\n\\t\\t\\treturn mid\\n            \\n\\t\\telif val > intervals[mid][self._end]:\\n\\t\\t\\tl = mid + 1\\n                \\n\\t\\telse:\\n\\t\\t\\tr = mid - 1\\n        \\n\\treturn l\\n\\n# Solution 1:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\n\\tintervals_count = len(intervals)\\n\\t\\n\\t# 1. Search the interval where new_interval.start fits in: O(logn) time\\n\\tval = new_interval[self._start]\\n\\tinsert_start = self._binary_search(intervals, val)\\n\\tif insert_start < intervals_count and intervals[insert_start][self._start] <= val <= intervals[insert_start][self._end]:\\n\\t\\tnew_interval[self._start] = intervals[insert_start][self._start]\\n\\t\\tnew_interval[self._end] = max(intervals[insert_start][self._end], new_interval[self._end])        \\n\\t\\n\\t# 2. Search the interval where new_interval.end fits in: O(logn) time\\n\\tval = new_interval[self._end]\\n\\tinsert_end = self._binary_search(intervals, val, insert_start)\\n\\tif insert_end < intervals_count and intervals[insert_end][self._start] <= val:\\n\\t\\tnew_interval[self._end] = max(intervals[insert_end][self._end], new_interval[self._end])\\n\\t\\tinsert_end += 1\\n\\t\\n\\t# 3. Replace overlapping intervals with new_interval: O(n) time and O(1) space\\n\\tintervals[insert_start:insert_end] = [new_interval]\\n\\t\\n\\treturn intervals\\n\\n```\n```\\n# Solution 2:\\ndef insert(self, intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]:\\n\\t# Same as above\\n\\t# ...\\n\\t\\n\\t# 3. Create new merged_intervals list: O(n) time in worst case and O(n) space\\n\\tmerged_intervals = intervals[:insert_start]       # Insert all intervals before insert_start\\n    merged_intervals.append(new_interval)             # Insert new_interval\\n    merged_intervals.extend(intervals[insert_end:])   # Insert all intervals after insert_end\\n\\t\\n\\treturn merged_intervals\\n\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 637718,
                "title": "java-o-n-clean-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        int idx = 0;\\n        \\n        while (idx < intervals.length && intervals[idx][1] < newInterval[0]) {\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        int mn = newInterval[0];\\n        int mx = newInterval[1];\\n        \\n        while (idx < intervals.length && mx >= intervals[idx][0]) {\\n            mn = Math.min(mn, intervals[idx][0]);\\n            mx = Math.max(mx, intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        list.add(new int[] { mn, mx });\\n        list.addAll(Arrays.asList(intervals).subList(idx, intervals.length));\\n        \\n        return list.stream().toArray(int[][]::new);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> list = new ArrayList<>();\\n        int idx = 0;\\n        \\n        while (idx < intervals.length && intervals[idx][1] < newInterval[0]) {\\n            list.add(intervals[idx++]);\\n        }\\n        \\n        int mn = newInterval[0];\\n        int mx = newInterval[1];\\n        \\n        while (idx < intervals.length && mx >= intervals[idx][0]) {\\n            mn = Math.min(mn, intervals[idx][0]);\\n            mx = Math.max(mx, intervals[idx][1]);\\n            idx++;\\n        }\\n        \\n        list.add(new int[] { mn, mx });\\n        list.addAll(Arrays.asList(intervals).subList(idx, intervals.length));\\n        \\n        return list.stream().toArray(int[][]::new);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442034,
                "title": "clear-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if (intervals == null || newInterval == null || newInterval.length == 0) return null;\\n        if (intervals.length == 0) return new int[][]{newInterval};\\n        \\n        List<int[]> result = new ArrayList<>();\\n        boolean alreadyDone = false;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][1] < newInterval[0]) {\\n                result.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                if (!alreadyDone) {\\n                    result.add(newInterval);\\n                    alreadyDone = true;\\n                }\\n                result.add(intervals[i]);\\n            } else {\\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        \\n        if (!alreadyDone) {\\n            result.add(newInterval);\\n        }\\n        \\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        if (intervals == null || newInterval == null || newInterval.length == 0) return null;\\n        if (intervals.length == 0) return new int[][]{newInterval};\\n        \\n        List<int[]> result = new ArrayList<>();\\n        boolean alreadyDone = false;\\n        \\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][1] < newInterval[0]) {\\n                result.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                if (!alreadyDone) {\\n                    result.add(newInterval);\\n                    alreadyDone = true;\\n                }\\n                result.add(intervals[i]);\\n            } else {\\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        \\n        if (!alreadyDone) {\\n            result.add(newInterval);\\n        }\\n        \\n        return result.toArray(new int[result.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369471,
                "title": "easy-python-solution-insert-and-merge-in-place",
                "content": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        size = len(intervals)\\n        \\n\\t\\t#Insert newInterval into intervals to keep sorted order\\n        for i, interval in enumerate(intervals):\\n            if newInterval[0] <= interval[0]:\\n                intervals.insert(i, newInterval)\\n                break\\n        \\n        #If the interval hasn\\'t been added yet\\n        if size == len(intervals):\\n            intervals.append(newInterval)\\n        \\n        i = 1\\n        while i < len(intervals):\\n            #Merge if previous interval\\'s end is >= to current interval\\'s start\\n            if intervals[i-1][1] >= intervals[i][0]:\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n\\t\\t\\t\\t#Remove current because it was merged into previous\\n                intervals.pop(i) \\n                i -= 1\\n            i += 1\\n        \\n        return intervals\\n                \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        size = len(intervals)\\n        \\n\\t\\t#Insert newInterval into intervals to keep sorted order\\n        for i, interval in enumerate(intervals):\\n            if newInterval[0] <= interval[0]:\\n                intervals.insert(i, newInterval)\\n                break\\n        \\n        #If the interval hasn\\'t been added yet\\n        if size == len(intervals):\\n            intervals.append(newInterval)\\n        \\n        i = 1\\n        while i < len(intervals):\\n            #Merge if previous interval\\'s end is >= to current interval\\'s start\\n            if intervals[i-1][1] >= intervals[i][0]:\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n\\t\\t\\t\\t#Remove current because it was merged into previous\\n                intervals.pop(i) \\n                i -= 1\\n            i += 1\\n        \\n        return intervals\\n                \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 304030,
                "title": "1ms-simple-java-solution-explained",
                "content": "The principle of this solution is to merge overlapping intervals inside the new one (if needed).\\nThen, the new interval is inserted inside the list only once at the right place.\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tboolean added = false;\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif ((interval[1] < newInterval[0])) {      // Non-overlapping to the left\\n\\t\\t\\t\\t\\tresult.add(interval);                  // We can safely add the interval to the list\\n\\t\\t\\t\\t} else if (interval[0] > newInterval[1]) { // Non-overlapping to the right\\n\\t\\t\\t\\t\\tif (!added) {                          // Add the new interval only once\\n\\t\\t\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t\\t\\t\\tadded = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tresult.add(interval);\\n\\t\\t\\t\\t} else {                                   // Overlapping, update the new interval\\n\\t\\t\\t\\t\\tnewInterval[0] = Math.min(newInterval[0], interval[0]);\\n\\t\\t\\t\\t\\tnewInterval[1] = Math.max(newInterval[1], interval[1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!added) { // Only happens if newInterval is last\\n\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t}\\n\\t\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] insert(int[][] intervals, int[] newInterval) {\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tboolean added = false;\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif ((interval[1] < newInterval[0])) {      // Non-overlapping to the left\\n\\t\\t\\t\\t\\tresult.add(interval);                  // We can safely add the interval to the list\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 245084,
                "title": "super-simple-golang-solution-8ms-beats-100",
                "content": "```\\nfunc insert(intervals []Interval, newInterval Interval) []Interval {\\n    var left,right []Interval\\n    for _,v := range intervals {\\n        if v.End < newInterval.Start {\\n            left =  append(left, v)\\n        } else if v.Start > newInterval.End {\\n            right = append(right, v)\\n        } else {\\n            newInterval.Start = min(newInterval.Start, v.Start)\\n            newInterval.End = max(newInterval.End, v.End)\\n        }\\n    }\\n    return append(append(left,newInterval),right...)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insert(intervals []Interval, newInterval Interval) []Interval {\\n    var left,right []Interval\\n    for _,v := range intervals {\\n        if v.End < newInterval.Start {\\n            left =  append(left, v)\\n        } else if v.Start > newInterval.End {\\n            right = append(right, v)\\n        } else {\\n            newInterval.Start = min(newInterval.Start, v.Start)\\n            newInterval.End = max(newInterval.End, v.End)\\n        }\\n    }\\n    return append(append(left,newInterval),right...)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21613,
                "title": "my-java-solution-pretty-simple-with-one-treemap",
                "content": "```\\npublic List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        TreeMap<Integer, Interval> treeMap = new TreeMap<>();\\n        for(Interval interval : intervals) {\\n            treeMap.put(interval.start, interval);\\n        }\\n        Interval cur = newInterval;\\n        \\n        while(treeMap.floorEntry(cur.end) != null && treeMap.floorEntry(cur.end).getValue().end >= cur.start) {\\n         \\n            if(treeMap.floorEntry(cur.start) != null && treeMap.floorEntry(cur.start).getValue().end >= cur.start) {\\n                Interval out = treeMap.floorEntry(cur.start).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.start));\\n                cur.start = out.start;\\n                cur.end = Math.max(cur.end, out.end);\\n            }else{\\n                Interval out = treeMap.floorEntry(cur.end).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.end));\\n                cur.end = Math.max(cur.end, out.end);\\n                cur.start = Math.min(cur.start, out.start);\\n            }\\n            \\n        }\\n        treeMap.put(cur.start, cur);\\n        return new ArrayList<>(treeMap.values());\\n    }",
                "solutionTags": [],
                "code": "```\\npublic List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        TreeMap<Integer, Interval> treeMap = new TreeMap<>();\\n        for(Interval interval : intervals) {\\n            treeMap.put(interval.start, interval);\\n        }\\n        Interval cur = newInterval;\\n        \\n        while(treeMap.floorEntry(cur.end) != null && treeMap.floorEntry(cur.end).getValue().end >= cur.start) {\\n         \\n            if(treeMap.floorEntry(cur.start) != null && treeMap.floorEntry(cur.start).getValue().end >= cur.start) {\\n                Interval out = treeMap.floorEntry(cur.start).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.start));\\n                cur.start = out.start;\\n                cur.end = Math.max(cur.end, out.end);\\n            }else{\\n                Interval out = treeMap.floorEntry(cur.end).getValue();\\n                treeMap.remove(treeMap.floorKey(cur.end));\\n                cur.end = Math.max(cur.end, out.end);\\n                cur.start = Math.min(cur.start, out.start);\\n            }\\n            \\n        }\\n        treeMap.put(cur.start, cur);\\n        return new ArrayList<>(treeMap.values());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21733,
                "title": "a-very-short-c-solution-with-o-logn-search-is-it-clear-enough",
                "content": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        auto it1 = lower_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        auto it2 = upper_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        vector<Interval> r( intervals.begin(), it1 );\\n        auto it3 = ( it2 == intervals.begin() ) ? it2 : it2 - 1;\\n        Interval m( (it1 == it2) ? newInterval.start : min( it1->start, newInterval.start ),\\n                    (it1 == it2) ? newInterval.end   : max( it3->end, newInterval.end ) );\\n        r.push_back(m);\\n        r.insert(r.end(), it2, intervals.end());\\n        return r;\\n    }\\n\\nIs this C++ solution clear enough?",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        auto it1 = lower_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        auto it2 = upper_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval& a, const Interval &b ){return a.end < b.start;});\\n        vector<Interval> r( intervals.begin(), it1 );\\n        auto it3 = ( it2 == intervals.begin() ) ? it2 : it2 - 1;\\n        Interval m( (it1 == it2) ? newInterval.start : min( it1->start, newInterval.start ),\\n                    (it1 == it2) ? newInterval.end   : max( it3->end, newInterval.end ) );\\n        r.push_back(m);\\n        r.insert(r.end(), it2, intervals.end());\\n        return r;\\n    }\\n\\nIs this C++ solution clear enough?",
                "codeTag": "Unknown"
            },
            {
                "id": 21793,
                "title": "easy-java-solution",
                "content": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        int ids = 0;\\n        while (ids < intervals.size() && newInterval.start > intervals.get(ids).start) ids++;\\n        intervals.add(ids, newInterval);\\n        for (int i = 0; i < intervals.size() - 1; ++i) {\\n            if (intervals.get(i).end < intervals.get(i + 1).start) continue;\\n            intervals.get(i).start = Math.min(intervals.get(i).start, intervals.get(i + 1).start);\\n            intervals.get(i).end = Math.max(intervals.get(i).end, intervals.get(i + 1).end);\\n            intervals.remove(i + 1);\\n            i--;\\n        }\\n        return intervals;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\\n        int ids = 0;\\n        while (ids < intervals.size() && newInterval.start > intervals.get(ids).start) ids++;\\n        intervals.add(ids, newInterval);\\n        for (int i = 0; i < intervals.size() - 1; ++i) {\\n            if (intervals.get(i).end < intervals.get(i + 1).start) continue;\\n            intervals.get(i).start = Math.min(intervals.get(i).start, intervals.get(i + 1).start);\\n            intervals.get(i).end = Math.max(intervals.get(i).end, intervals.get(i + 1).end);\\n            intervals.remove(i + 1);\\n            i--;\\n        }\\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21702,
                "title": "c-code-use-binary-search",
                "content": "        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        if(intervals.empty()) {\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        \\n        int first=0, piv=0, count=intervals.size(), step = 0;\\n        while(count > 0) {  // lower bound of ends\\n            step = count/2; piv = first + step;\\n            if(intervals[piv].end < newInterval.start) {\\n                first = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        int last = first;\\n        count = intervals.size() - first;\\n        while(count > 0) {  // upper bound of starts\\n            step = count/2; piv = last + step;\\n            if(intervals[piv].start <= newInterval.end) {\\n                last = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        if(last == first)\\n            intervals.insert(intervals.begin()+first, newInterval);\\n        else {\\n            intervals[first].start = min(newInterval.start, intervals[first].start);\\n            intervals[first].end   = max(newInterval.end,   intervals[last-1].end);\\n            intervals.erase(intervals.begin()+(first+1), intervals.begin()+last);\\n        }\\n        \\n        return intervals;\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "        vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {\\n        if(intervals.empty()) {\\n            intervals.push_back(newInterval);\\n            return intervals;\\n        }\\n        \\n        int first=0, piv=0, count=intervals.size(), step = 0;\\n        while(count > 0) {  // lower bound of ends\\n            step = count/2; piv = first + step;\\n            if(intervals[piv].end < newInterval.start) {\\n                first = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        int last = first;\\n        count = intervals.size() - first;\\n        while(count > 0) {  // upper bound of starts\\n            step = count/2; piv = last + step;\\n            if(intervals[piv].start <= newInterval.end) {\\n                last = ++piv;\\n                count -= step + 1;\\n            } else count = step;\\n        }\\n        \\n        if(last == first)\\n            intervals.insert(intervals.begin()+first, newInterval);\\n        else {\\n            intervals[first].start = min(newInterval.start, intervals[first].start);\\n            intervals[first].end   = max(newInterval.end,   intervals[last-1].end);\\n            intervals.erase(intervals.begin()+(first+1), intervals.begin()+last);\\n        }\\n        \\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 21810,
                "title": "in-place-solution-ask-for-suggestion",
                "content": "I have done non in place insertion. Just want to try in place version because it seems faster and more memory efficient. Would like to ask for suggestion to see whether I can further improve it. Pass OJ already. But not guarantee it's bug free :P\\n  \\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\\n        //inplace solution for interval insertion\\n        if(intervals.empty()){intervals.insert(intervals.begin(),newInterval);return intervals;}\\n        int l=0,r=(int)intervals.size()-1;\\n        Interval& n=newInterval;\\n    \\n        //binary search for the first interval x, such that x.start is larger than n.start\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].start<=n.start)l=m+1;\\n            else r=m-1;\\n        }\\n        int left=l;\\n        l=0,r=(int)intervals.size()-1;\\n        //binary search for the first interval x such that x.end is smaller than n.end\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].end<n.end)l=m+1;\\n            else r=m-1;\\n        }\\n        int right=r;\\n    \\n        //check right boundary\\n        if(right+1<intervals.size()&&intervals[right+1].start<=n.end)\\n            n.end=max(n.end,intervals[++right].end);\\n    \\n        //check left boundary\\n        if(left-1>=0&&n.start<=intervals[left-1].end)\\n            n.start=min(n.start,intervals[--left].start);\\n    \\n        //check and update\\n        if(right+1>=left){\\n            intervals.insert(intervals.begin()+left,n);\\n            intervals.erase(intervals.begin()+left+1,intervals.begin()+right+2);\\n        }\\n        return intervals;\\n    }",
                "solutionTags": [],
                "code": "I have done non in place insertion. Just want to try in place version because it seems faster and more memory efficient. Would like to ask for suggestion to see whether I can further improve it. Pass OJ already. But not guarantee it's bug free :P\\n  \\n    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {\\n        //inplace solution for interval insertion\\n        if(intervals.empty()){intervals.insert(intervals.begin(),newInterval);return intervals;}\\n        int l=0,r=(int)intervals.size()-1;\\n        Interval& n=newInterval;\\n    \\n        //binary search for the first interval x, such that x.start is larger than n.start\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].start<=n.start)l=m+1;\\n            else r=m-1;\\n        }\\n        int left=l;\\n        l=0,r=(int)intervals.size()-1;\\n        //binary search for the first interval x such that x.end is smaller than n.end\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(intervals[m].end<n.end)l=m+1;\\n            else r=m-1;\\n        }\\n        int right=r;\\n    \\n        //check right boundary\\n        if(right+1<intervals.size()&&intervals[right+1].start<=n.end)\\n            n.end=max(n.end,intervals[++right].end);\\n    \\n        //check left boundary\\n        if(left-1>=0&&n.start<=intervals[left-1].end)\\n            n.start=min(n.start,intervals[--left].start);\\n    \\n        //check and update\\n        if(right+1>=left){\\n            intervals.insert(intervals.begin()+left,n);\\n            intervals.erase(intervals.begin()+left+1,intervals.begin()+right+2);\\n        }\\n        return intervals;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4018688,
                "title": "insert-interval-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());   \\n        vector<int> temp = intervals[0];\\n        vector<vector<int> > ans;\\n\\n\\n        for(auto it : intervals)\\n        {\\n            if(temp[1] >= it[0])\\n            {\\n                temp[1] = max(temp[1],it[1]);\\n              \\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp = it;\\n            }\\n        }ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) \\n    {\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(),intervals.end());   \\n        vector<int> temp = intervals[0];\\n        vector<vector<int> > ans;\\n\\n\\n        for(auto it : intervals)\\n        {\\n            if(temp[1] >= it[0])\\n            {\\n                temp[1] = max(temp[1],it[1]);\\n              \\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp = it;\\n            }\\n        }ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795785,
                "title": "very-easy-brute-force-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval[0],newInterval[1]});\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> v;\\n        for(int i = 0 ; i < intervals.size() ; i++)\\n        {\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n            if(!v.empty() && v.back()[1] >= end)\\n            {\\n                continue;\\n            }\\n            for(int j = i+1 ; j < intervals.size() ; j++)\\n            {\\n                if(intervals[j][0] <= end)\\n                {\\n                    end = max(end , intervals[j][1]);\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            v.push_back({start,end});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        intervals.push_back({newInterval[0],newInterval[1]});\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> v;\\n        for(int i = 0 ; i < intervals.size() ; i++)\\n        {\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n            if(!v.empty() && v.back()[1] >= end)\\n            {\\n                continue;\\n            }\\n            for(int j = i+1 ; j < intervals.size() ; j++)\\n            {\\n                if(intervals[j][0] <= end)\\n                {\\n                    end = max(end , intervals[j][1]);\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            v.push_back({start,end});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781818,
                "title": "simple-python-solution-using-insort",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insort(intervals, newInterval)\\n        ans = [intervals[0]]\\n        for s, e in intervals[1:]:\\n            if ans[-1][-1] >= s:\\n                ans[-1][-1] = max(ans[-1][-1], e)\\n            else:\\n                ans.append([s, e])\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        insort(intervals, newInterval)\\n        ans = [intervals[0]]\\n        for s, e in intervals[1:]:\\n            if ans[-1][-1] >= s:\\n                ans[-1][-1] = max(ans[-1][-1], e)\\n            else:\\n                ans.append([s, e])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766731,
                "title": "simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        Stack<int[]> st = new Stack<>();\\n        int i= 0;\\n        int s = intervals.length;\\n        while(i<s && intervals[i][1]<newInterval[0]) st.push(intervals[i++]);\\n        while(i<s && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        st.push(newInterval);\\n        while(i<s) st.push(intervals[i++]);\\n      int[][] output = new int[st.size()][2];\\n      for(int j = output.length-1; j>=0; j--){\\n          output[j] = st.pop();\\n      }\\n      return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        Stack<int[]> st = new Stack<>();\\n        int i= 0;\\n        int s = intervals.length;\\n        while(i<s && intervals[i][1]<newInterval[0]) st.push(intervals[i++]);\\n        while(i<s && intervals[i][0] <= newInterval[1]){\\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        st.push(newInterval);\\n        while(i<s) st.push(intervals[i++]);\\n      int[][] output = new int[st.size()][2];\\n      for(int j = output.length-1; j>=0; j--){\\n          output[j] = st.pop();\\n      }\\n      return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492665,
                "title": "simplest-solution-easy-to-understand-c-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbreak a problem into parts\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nvector processing\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int n=intervals.size();\\n        int i=0;\\n        while(i<n && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n        vector<int>mi=newInterval;\\n        while(i<n && intervals[i][0]<=newInterval[1])\\n        {\\n            mi[0]=min(mi[0],intervals[i][0]);\\n            mi[1]=max(mi[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.push_back(mi);\\n        while(i<n)\\n        {\\n            result.push_back(intervals[i++]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> result;\\n        int n=intervals.size();\\n        int i=0;\\n        while(i<n && intervals[i][1]<newInterval[0])\\n        {\\n            result.push_back(intervals[i]);\\n            i++;\\n        }\\n        vector<int>mi=newInterval;\\n        while(i<n && intervals[i][0]<=newInterval[1])\\n        {\\n            mi[0]=min(mi[0],intervals[i][0]);\\n            mi[1]=max(mi[1],intervals[i][1]);\\n            i++;\\n        }\\n        result.push_back(mi);\\n        while(i<n)\\n        {\\n            result.push_back(intervals[i++]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434453,
                "title": "absolutely-clear-and-simple-python-solution-o-n-beats-over-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only need modify intervals when an old interval intersect with new interval, that say in this 2 situations:\\n1. left value of old interval <= right value of new interval\\n2. right value of old interval >= left value of new interval\\n\\nBesides upon 2 situation, we just put old intervals into solutions.\\nHowever, in other cases, we would expand new interval.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nA little thing we sholud pay attention, is whether we met the intersection or not. So I use a variable \\'meet\\' to record it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        #-1: never met\\n        # 0: already interted to result\\n        # 1: met, but not interted to result yet\\n        meet = -1 \\n\\n        left = newInterval[0]\\n        right = newInterval[1]\\n        for interval in intervals:    \\n            if interval[1] < left:\\n                result.append(interval)\\n            elif interval[0] > right:\\n                if meet != 0:\\n                    result.append([left, right])\\n                    meet = 0\\n                result.append(interval)\\n            else:\\n                left = min(interval[0], left)\\n                right = max(interval[1], right)\\n                meet = 1\\n        if meet != 0:\\n            result.append([left, right])\\n        return result\\n```\\n\\nIt\\'s my first post, UPVOTE this if you like :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        result = []\\n        #-1: never met\\n        # 0: already interted to result\\n        # 1: met, but not interted to result yet\\n        meet = -1 \\n\\n        left = newInterval[0]\\n        right = newInterval[1]\\n        for interval in intervals:    \\n            if interval[1] < left:\\n                result.append(interval)\\n            elif interval[0] > right:\\n                if meet != 0:\\n                    result.append([left, right])\\n                    meet = 0\\n                result.append(interval)\\n            else:\\n                left = min(interval[0], left)\\n                right = max(interval[1], right)\\n                meet = 1\\n        if meet != 0:\\n            result.append([left, right])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429077,
                "title": "java-solution-beats-100-o-n",
                "content": "\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        int l = 0;\\n        int r = n - 1;\\n        while (l < n && newInterval[0] > intervals[l][1]) {\\n            l++;\\n        }\\n        while (r >= 0 && newInterval[1] < intervals[r][0]) {\\n            r--;\\n        }\\n        int[][] res = new int[l + n - r][2];\\n        for (int i = 0; i < l; i++) {\\n            res[i] = Arrays.copyOf(intervals[i], intervals[i].length);\\n        }\\n        res[l][0] = Math.min(newInterval[0], l == n ? newInterval[0] : intervals[l][0]);\\n        res[l][1] = Math.max(newInterval[1], r == -1 ? newInterval[1] : intervals[r][1]);\\n        for (int i = l + 1, j = r + 1; j < n; i++, j++) {\\n            res[i] = intervals[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        int n = intervals.length;\\n        int l = 0;\\n        int r = n - 1;\\n        while (l < n && newInterval[0] > intervals[l][1]) {\\n            l++;\\n        }\\n        while (r >= 0 && newInterval[1] < intervals[r][0]) {\\n            r--;\\n        }\\n        int[][] res = new int[l + n - r][2];\\n        for (int i = 0; i < l; i++) {\\n            res[i] = Arrays.copyOf(intervals[i], intervals[i].length);\\n        }\\n        res[l][0] = Math.min(newInterval[0], l == n ? newInterval[0] : intervals[l][0]);\\n        res[l][1] = Math.max(newInterval[1], r == -1 ? newInterval[1] : intervals[r][1]);\\n        for (int i = l + 1, j = r + 1; j < n; i++, j++) {\\n            res[i] = intervals[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142437,
                "title": "easy-python-solution-with-linear-time-complexity-100-working",
                "content": "\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                res.append(newInterval)\\n                return res+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                res.append(intervals[i])\\n            else:\\n                newInterval=(min(intervals[i][0],newInterval[0]),max(intervals[i][1],newInterval[1]))\\n        res.append(newInterval)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        res=[]\\n        for i in range(len(intervals)):\\n            if newInterval[1]<intervals[i][0]:\\n                res.append(newInterval)\\n                return res+intervals[i:]\\n            elif newInterval[0]>intervals[i][1]:\\n                res.append(intervals[i])\\n            else:\\n                newInterval=(min(intervals[i][0],newInterval[0]),max(intervals[i][1],newInterval[1]))\\n        res.append(newInterval)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060958,
                "title": "linear-explained-python3-beats-92-javascript-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intervals are sorted.\\nThere are intervals coming strictly before, after, and intersecting the new interval\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Partition the input intervals into three categories:\\n   - preceeding the new interval\\n   - intersecting the new interval, thus merged into one interval\\n   - following the new interval\\n2. Return these joined interval categories\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$, the space for the resulting intervals is not counted\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Python 3\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        start, end = newInterval\\n        prefix, suffix = [], []\\n        for i in intervals:\\n            if i[1] < start:\\n                prefix.append(i)\\n            elif i[0] > end:\\n                suffix.append(i)\\n            else:\\n                start, end = min(start, i[0]), max(end, i[1])\\n        return prefix + [[start, end]] + suffix\\n```\\n## JavaScript\\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let [start, end] = newInterval;\\n    const [prefix, suffix] = [[], []];\\n    for (const i of intervals) {\\n        if (i[1] < start) {\\n            prefix.push(i);\\n        } else if (i[0] > end) {\\n            suffix.push(i);\\n        } else {\\n            start = Math.min(start, i[0]);\\n            end = Math.max(end, i[1]);\\n        }\\n    }\\n    return [...prefix, [start, end], ...suffix];\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        start, end = newInterval\\n        prefix, suffix = [], []\\n        for i in intervals:\\n            if i[1] < start:\\n                prefix.append(i)\\n            elif i[0] > end:\\n                suffix.append(i)\\n            else:\\n                start, end = min(start, i[0]), max(end, i[1])\\n        return prefix + [[start, end]] + suffix\\n```\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} newInterval\\n * @return {number[][]}\\n */\\nvar insert = function(intervals, newInterval) {\\n    let [start, end] = newInterval;\\n    const [prefix, suffix] = [[], []];\\n    for (const i of intervals) {\\n        if (i[1] < start) {\\n            prefix.push(i);\\n        } else if (i[0] > end) {\\n            suffix.push(i);\\n        } else {\\n            start = Math.min(start, i[0]);\\n            end = Math.max(end, i[1]);\\n        }\\n    }\\n    return [...prefix, [start, end], ...suffix];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060893,
                "title": "c-solution-easy-and-simple-explanation-o-n-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere Three cases we have to consider \\nCase 1. Insert all the intervals that are non overlapping with the gievn newinterval.\\nCase 2. On finding the overlapping interval merge all the overlappig intervals.\\nCase 3. Insert all the remaining intervals after the overlapping intervals. \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> v;\\n        int n = intervals.size(), i = 0;\\n        // push all the intervals till non overlapping interval\\n        while(i < n && newInterval[0] > intervals[i][1])\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        // merging all the overlapping intervals\\n        while(i < n && newInterval[1] >= intervals[i][0])\\n        {\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        v.push_back(newInterval);\\n        // psuh all the remaining intervals after merging \\n        while(i < n)\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        vector<vector<int>> v;\\n        int n = intervals.size(), i = 0;\\n        // push all the intervals till non overlapping interval\\n        while(i < n && newInterval[0] > intervals[i][1])\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        // merging all the overlapping intervals\\n        while(i < n && newInterval[1] >= intervals[i][0])\\n        {\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n        v.push_back(newInterval);\\n        // psuh all the remaining intervals after merging \\n        while(i < n)\\n        {\\n            v.push_back(intervals[i]);\\n            i++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1759866,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760304,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759735,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1572656,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760461,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760366,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759762,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1567828,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1818723,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760226,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759866,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760304,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759735,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1572656,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760461,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760366,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1759762,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1567828,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1818723,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760226,
                "content": [
                    {
                        "username": "Taswell",
                        "content": "this problem feels like its sole purpose of existing is to disgust you."
                    },
                    {
                        "username": "spookie886",
                        "content": "thankfully i only spent like 20 mins thinking about the edge cases and trying to impletement it before going to the solutinos section. because there is no need to waste hours on a question if you can\\'t figure out, you will revisit this question anyways"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "[@ya17kun](/ya17kun) Yo! This is so true!"
                    },
                    {
                        "username": "ya17kun",
                        "content": ":bloodshot eyes:  j.j.just one more if-else ... i promise ....  last one ..... \"Submit\" .... next one is the last ... p.p.promise"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Ikr? Seems like a simple problem, yet you spend an eternity to implement it. Imagine getting this on a real interview, becoming happy and at the end of the interview being dissapointed you failed, because there are so many edge cases."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "True, but I was actually able to come up with a HEAP + STACK solution that is decently efficient and is much easier to code. Here, check it out\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@gaurav-garg](/gaurav-garg) Exactly, This problem has a very simple logic, but requires complex coding abilities. I think this is hardest a problem with if-else + loop can get."
                    },
                    {
                        "username": "Finesse",
                        "content": "This is one of rare Leet Code problems that I actually met and solved at work. Whenever you manage availability time slots, you deal with intervals."
                    },
                    {
                        "username": "gaurav-garg",
                        "content": "So Many test Cases. Wonder if i can code it in 30 Minutes in interview. Concept is very simple"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Whenever the times comes when I start developing arrogance about the multiple data structures + algos I know, I will return back to this problem and it will humble me down by telling me **how a simple Array problem with simple statement can test our coding abilities!!**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a stop to tree problems! \\uD83D\\uDC35\\uD83D\\uDC35"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "Greedy is my nightmare."
                    },
                    {
                        "username": "Finesse",
                        "content": "This can be viewed as a tree and solved with Union Find"
                    },
                    {
                        "username": "PinkGlove",
                        "content": "finally relieved"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "[@shrayaherself](/shrayaherself) me too"
                    },
                    {
                        "username": "shrayaherself",
                        "content": "agreed!!"
                    },
                    {
                        "username": "todamoon",
                        "content": "It feels to me only adding unnecessary coding complexity without adding interesting challenge to this question. Any one sees the point of such change?"
                    },
                    {
                        "username": "orbuluh",
                        "content": "In my opinion, for problems that seems to be easy but turns out to be hard to get right, are something valuable. This problem, at least to me, is one of them. Also, off-by-one error is one of the top common software bugs. And this kind of question to some degree helps you to practice your thought on bundary condition. So although annoying, I won\\'t think it\\'s unnecessary."
                    },
                    {
                        "username": "shxtrk",
                        "content": "with each failed test case and after adding another `if` statement, I realize that there is a simpler solution, but I still persist in branching in the hope that next attempt will definitely be accepted.."
                    },
                    {
                        "username": "user8344Yr",
                        "content": "Us."
                    },
                    {
                        "username": "newcopernicus",
                        "content": "my solution is so long and disgusting, i feel ashamed"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Well, mine too same situation "
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Congrats to the people who made it through the forest!!!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Comments show that people are not familiar enough with trees.\nLeetCode: Okay, more tree practice in the future!"
                    },
                    {
                        "username": "aleckerrigan",
                        "content": "I receive this problem from startups all the time, I\\'m not sure why they like it, but really work at it!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Finesse](/Finesse) If I receive this problem in an interview, I am going to say that I know the logic and will explain the algo, and then will straight away give warning that the coding might slip into 30+ minute time frame because of so many checks to consider"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because it\\'s related to life. This is one of rare Leet Code problems that I actually met and solved at work."
                    },
                    {
                        "username": "gavinlinasd",
                        "content": "Looking at the problem, the O(N) solution is pretty straightforward, and I thought it's for sure going to TLE. Therefore I come up with an O(logN) solution.\\n\\nFrom the problem we know:\\n\\n- \"start\" of the intervals are sorted\\n-  intervals are not overlapped (i.e. the end of an interval is smaller than the start of next interval, otherwise they are overlapped and should be merged into one)\\n\\nfrom the 2 facts we can draw the following conclusion\\n\\n-  \"end\" of the intervals are also sorted\\n\\n(proof: For all i, end_i > start_i > end_(i-1) => end_i > end_(i-1). \"end\" values are sorted)\\n\\nWhen you have sorted integer, you can apply binary search and find the place you need to insert. You will need to do it twice: once for start of interval, once for end of interval\\n\\n 1. start of interval: last_interval_before_insert.end < newInterval.start\\n 2. end of interval: first_interval_after_insert.start > newInterval.end\\n\\nAfter you find the start/end of the interval, everything in between should be merged. \\n\\nThe general idea is like that but my code is too ugly so I don't feel like posting them :("
                    },
                    {
                        "username": "pavlic148",
                        "content": "[@SuperSourav](/SuperSourav) Time complexity of `intervals[:n]` is `O(n)`. So, in the best case your algorithm will have a complexity `O(log(n))` (when the new interval overlaps with all intervals) and in the worst case a complexity will be `O(n)` (when the new interval doesn't overlap with any other)."
                    },
                    {
                        "username": "Sherrry",
                        "content": "[@SuperSourav](/SuperSourav)  I dont see no reason why you need to reassign             \\nleft = left\\nright = right\\nin your inner function, what do they do?"
                    },
                    {
                        "username": "zlnovember",
                        "content": "You either have to create a new array, or you need to delete elements in the middle of the array, both are O(n) operation."
                    },
                    {
                        "username": "SuperSourav",
                        "content": "[@esvcoder](/esvcoder)  @gavinlinasd is correct. If you know the right and left edges using binary search you do not have to examine all the intermediate intervals, you can just use the intervals adjacent to the two edges, so time complexity is just O(log(n)).\n\n```\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        start, end = newInterval\n        \n        def bs_rightedge(x, left, right):\n            left = left\n            right = right\n            rt_edge = right+1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][0] > x):\n                    rt_edge = mid\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return rt_edge\n\n        def bs_leftedge(x, left, right):\n            left = left\n            right = right\n            lt_edge = left-1\n\n            while (left <= right):\n                mid = (left + right) // 2\n                if (intervals[mid][1] < x):\n                    lt_edge = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return lt_edge\n        \n        \n        rt_edge = bs_rightedge(end, 0, len(intervals)-1)\n        lt_edge = bs_leftedge(start, 0, rt_edge-1)\n        \n        if (rt_edge - lt_edge) > 1:\n            start = min(start, intervals[lt_edge+1][0])\n            end = max(end, intervals[rt_edge-1][1])\n        return intervals[:lt_edge+1] + [[start, end]] + intervals[rt_edge:]\n```"
                    },
                    {
                        "username": "esvcoder",
                        "content": "Yes, but given you\\'re returning a new integer array you will need to copy and therefore examine/possibly merge others so you will need to visit all N integers.  Therefore the overall time is still O(n)."
                    },
                    {
                        "username": "hamza979",
                        "content": "This solution I found in the runtime submissions is so beautiful:\\n```\\ndef insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n\\tl, r = [], []\\n\\tfor interval in intervals:\\n\\t\\tif interval[1] < newInterval[0]:\\n\\t\\t\\tl.append(interval)\\n\\t\\telif interval[0] > newInterval[1]:\\n\\t\\t\\tr.append(interval)\\n\\t\\telse:\\n\\t\\t\\tnewInterval = (min(interval[0], newInterval[0]), \\\\\\n\\t\\t\\t\\t\\t\\t   max(interval[1], newInterval[1]))\\n\\treturn l + [newInterval] + r\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Failed at many test cases and finally solved it ... Ahhhh relief \\uD83D\\uDE05\\uD83D\\uDE05\\n"
                    }
                ]
            },
            {
                "id": 1760727,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1868788,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1762258,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1574365,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1948131,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1761687,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 2062287,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1760761,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1760076,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1568879,
                "content": [
                    {
                        "username": "mukadas026",
                        "content": "Anyone else manage to solve it but still feel like they did nothing. This challenge literally drained me."
                    },
                    {
                        "username": "benjaminsll18",
                        "content": "> \"Return `intervals` after the insertion.\"\\n\\nCan the question be rephrased? This sentence makes it seems like the code is asking for us to modify the input `intervals` array, but the problem actually can be solved by creating a new solution array."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I am so relieved looking at the comments to see that I was not the only one being completely thrown off by how easy the problem sounds and what a nightmare it turned out to be! Every failed test case took away a piece of my soul. There\\'s very little left of it but after several hours of pure frustration, I at least got a horrible frankenstein monster of a solution, with awful if statements pieced together. I need to work read uo in the solution and learn but that will be for another (distant) day"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is probably the hardest interval question "
                    },
                    {
                        "username": "Riyafa",
                        "content": "The following post covers all interval related topics often asked in interviews:\\nhttp://www.zrzahid.com/maximum-number-of-overlapping-intervals/"
                    },
                    {
                        "username": "lightning_123456",
                        "content": "thnx"
                    },
                    {
                        "username": "9NineUnknown",
                        "content": "thx"
                    },
                    {
                        "username": "patelishan320",
                        "content": "this problem is easy af if you have done the merge intervals problem"
                    },
                    {
                        "username": "stifstyle",
                        "content": "I feel like this problem is aimed at finding gifted QA engineers among LeetCode users."
                    },
                    {
                        "username": "CivilCS",
                        "content": "I would recommend doing Leetcode 56. Merge Intervals. That will give a way better understanding of this problem. "
                    },
                    {
                        "username": "ohYouCan",
                        "content": "This question feels like a simple logic but heavy implementation.\\nSo I solved it\\'s simpler version \"merge intervals\"(got from similar question) first and then came back here. But it still took almost an hour and 4 wrong submissions. But got  faster than 99.80%.(It was worth it).\\nP.S :-  I am not good with implementation."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "other similar problems to solve:\\nhttps://leetcode.com/problems/merge-intervals/\\nhttps://leetcode.com/problems/non-overlapping-intervals/\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/"
                    },
                    {
                        "username": "jinqiangshou",
                        "content": "Accepted Solutions Runtime Distribution shows that answers written by pure C is very slow. This is rarely seen in other problems. Can you help me explain it?"
                    }
                ]
            },
            {
                "id": 1944081,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760929,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760840,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760409,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759971,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759916,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759732,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1759731,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1571142,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 1760371,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "Many people here are saying that this had too many testcases. But I didnt felt si while solving this question. \\n\\nThis was my approach:\\n\\nFirst, I added the newInterval in the intervals vector and sorted the intervals vector.\\nthen I just merged the intervals like in the 56th (previous part) question.\\n\\n\\n`class Solution {\\n\\n\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n\\n\\n        intervals.push_back(newInterval);\\n        sort(intervals.begin(), intervals.end());        \\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++){\\n            int a = ans.size()-1;\\n            if(intervals[i][0] <= ans[a][1]){\\n                ans[a][1]  = max(intervals[i][1], ans[a][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Diamantis",
                        "content": "Handling edge cases is not one of my virtues.\\nI can get tilted very easily."
                    },
                    {
                        "username": "maltarouti",
                        "content": "Let\\'s go back to trees"
                    },
                    {
                        "username": "wingeryan",
                        "content": "Why does this not work please help I\\'m such a loser\\n```\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x:x[0], reverse=False)\\n        \\n\\n\\n\\n        inserted = False\\n        for i in range(len(intervals)-1,-1,-1):\\n            if intervals[i][0] <= newInterval[0]:\\n                inserted = True\\n                if intervals[i][1] > newInterval[1]:\\n                    break\\n                else:\\n                    intervals[i][1] = newInterval[1]\\n                    break\\n        if not inserted:\\n            if newInterval[1] < intervals[0][0]:\\n                intervals.insert(0, newInterval)\\n            else:\\n                intervals.insert(len(intervals)-1, newInterval)\\n\\n\\n        for i in range(1, len(intervals)):\\n            # print(intervals[i][0], \" + \" , intervals[i-1][1])\\n            print(len(intervals))\\n            if i >= len(intervals) or i < 0:\\n                break\\n            if intervals[i][0] <= intervals[i-1][1]:\\n                print(\"gottem\")\\n                intervals[i-1][1] = intervals[i][1]\\n                intervals.remove(intervals[i])\\n\\n\\n        return intervals\\n\\n\\n        # for interval in intervals:\\n        #     if interval[0] > newInterval[0]:\\n        #         if interval[1] > newInterval[1]:\\n        #             break\\n        #         else\\n        \\n        # return intervals\\n```"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                      \\n       class Solution:\\n    def insert(self, intervals,newInterval):\\n        intervals.append(newInterval)\\n        intervals.sort()\\n\\n        res = []\\n        for st,end in intervals:\\n            if not res or res[-1][1] < st:\\n                res.append([st,end])\\n            else:\\n                res[-1][1] = max(res[-1][1], end)\\n\\n        return res"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "nikhilsh20",
                        "content": "After a week of tree problems\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congratulations on the half mark! Those who survived yesterday\\'s HARD problem have enough resolve that they\\'ll easily get the January Badge"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@vaibhavkambar123](/vaibhavkambar123) In the past 15 days, I think I was able to solve 12+ problems without hints in a respectable amount of time. The rest were either after a lot of hints, or after lots of time. Yesterday\\'s problem was the hardest where even after hints I spent total 3+ hours on it.\\nBut I think the point of daily challenge is not to get every problem right and swift, but to show courage to learn about the topic and re-attempt on the same day even if we fail at first attempt, so it is in that regard that I said that if we had enough zeal to cross yesterday\\' problem, then we will surely cross the rest of month too."
                    },
                    {
                        "username": "coderkkk",
                        "content": "How many daily problems could you solve in the past week on your own , "
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Finally No trees or graph \\uD83D\\uDE42"
                    },
                    {
                        "username": "pengg",
                        "content": "sorted is meaningless.  Given a random non-overlapping list, we can insert  in O(n)sdffsf"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Finally, I don\\'t have to copy paste codes to maintain streak!!...  Rescue from trees............."
                    }
                ]
            },
            {
                "id": 2069722,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2067271,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2051636,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2045374,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2042915,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2039965,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2033587,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2028140,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 2011437,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 1963552,
                "content": [
                    {
                        "username": "GrimShinigami",
                        "content": "If you have done the Merge Intervals question before this, this is just copy paste of that, cause you need to merge intervals just as before, just pushing one more interval to the overall roster"
                    },
                    {
                        "username": "saurabh0707",
                        "content": "The problem only tested my patience. LOL. Simple problem with some tricky edge cases."
                    },
                    {
                        "username": "xnoname0000",
                        "content": "God. I hate myself"
                    },
                    {
                        "username": "chengqqq",
                        "content": "TIP : do LC 56. Merge Intervals before attempting this , should be a piece of cake afterwards"
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "just add the newInterval arr to the intervals arr in a sorted manner. After doing so, merge the intervals. people who have done merge intervals question might find this easy. "
                    },
                    {
                        "username": "rquant",
                        "content": "I definitely struggled on this one"
                    },
                    {
                        "username": "cheukhin1024",
                        "content": "why I cannot sort the first element of the subarrays?\\n\\nIt returns `TypeError: \\'int\\' object has no attribute \\'__getitem__\\'`\\n\\n\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        intervals.sort(key=lambda x: x[0])\\n        newInterval.sort(key=lambda x: x[0])"
                    },
                    {
                        "username": "Ataf10",
                        "content": "This problem alone is pretty good to test your coding ability, now think of a question where you are given multiple `newInterval` and we have to insert it into the existing `intervals` . That could be placed in hard category without any second thought.\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I did merge intervals first and decided not to bother with the annoying if else statements I would need to handle inserting and merging in one go. I just inserted and then sorted on its own and then merged intervals just like in the merge intervals problem. Funnily enough this approach still beat 98%."
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem tough af\n\nEasiest method is to just make a copy interval of intervals and add newIntervals to it, then sort. Then it just becomes merge intervals \n\nBeats 22% of runtime xD "
                    }
                ]
            },
            {
                "id": 1957718,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1954453,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1947263,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1944702,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1941307,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1935767,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1933469,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1921887,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1919335,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1906710,
                "content": [
                    {
                        "username": "garvitagrawal_02",
                        "content": "ohh yeah, there is one more edge case\\naah, one more if condition\\nno man one more if condition\\nand this goes on till 4th submission."
                    },
                    {
                        "username": "d_meet",
                        "content": "class Solution(object):\\n    def insert(self, intervals, newInterval):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type newInterval: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        c = []\\n        for lists in intervals:\\n            for element in lists:\\n\\n                c.append(element)\\n                if element <= newInterval[1] and element >= newInterval[0]:\\n                    c.remove(element)\\n        result = [c[i:i+2] for i in range(0, len(c), 2)]\\n        return result\\n\\ndid I understand something wrong?"
                    },
                    {
                        "username": "aryanpwani",
                        "content": "Isn\\'t this question same as 56. Merge Intervals\\nWe just need to add the new interval using this:\\nintervals.push_back(newInterval);\\nand done?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "No guarantee newInterval won\\'t conflict. Can\\'t do that "
                    },
                    {
                        "username": "who_rules",
                        "content": "such kind of task that doesn\\'t really teach you with anything, but makes you suffer"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "Failed 7 times before finally accepted. Took 18 minutes to debug lol. If this question is asked in the interview, I think this will show your debugging skills. :)"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "Here\\'s my written solution\\n\\ncreate res variable\\nloop through array\\n1. If the the second value of newInterval less than first value of cur interval they never overlap anymore. we can push new interval to it and then return the rest of the numbers left\\n2. If the first value of newInterval is bigger than the second value of cur interval, they have not overlapped yet\\n3. Else they do overlap and we can update our newInterval like this \\nnewInterval = [Math.min(newInterval[0], intervals[i][0]), Math.max(newInterval[1], intervals[i][1])]"
                    },
                    {
                        "username": "andrew_in_code",
                        "content": "There\\'s billions of edge cases you can never guess until you hit the \"submit\" button"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How to solve this if more than one interval is to be merged?"
                    },
                    {
                        "username": "AlbusDumbeldore",
                        "content": "use loop to iterate in whole array checking for any possible condition to merge."
                    },
                    {
                        "username": "celesty",
                        "content": "I took a week off from leetcoding. Now this problem took me 1.5hr to solve....... Then all the comments are suggesting how nasty this problem actually is. I don\\'t know if I regressed so much or I am okay...."
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Just wanna say one thing - \"Appearances can be deceptive\""
                    }
                ]
            },
            {
                "id": 1905777,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1904235,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1863143,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1832801,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1820519,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1804316,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1801891,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1792060,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1778869,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1766824,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "\"Uh! Why isn't this test case working?....Oh! Ofc, why didn't I think of this before! Let me just change this small thing......and that should be it!\"  - been doing this for the past 4 hours, still not able to solve the problem by myself"
                    },
                    {
                        "username": "isopaleocopria",
                        "content": "I found this problem to be much more difficult than any other \"medium\" level problem that I have tried thus far. "
                    },
                    {
                        "username": "MalikMuzzammilRafiq",
                        "content": "<h1>hint</h1>\n<h2>insert interval one by one in new array</h2>"
                    },
                    {
                        "username": "Vithesh",
                        "content": "8 wrong answers and almost 2 hours. Now i got the answer.\\nI don\\'t know how people got answers in an actual contest where you can\\'t see any test cases."
                    },
                    {
                        "username": "Akshay1054",
                        "content": "my code throw runtime error could you tell where code is wrong ,i am pasting my code in downside\\nclass Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& interval, vector<int>& newInterval) {\\n        vector<vector<int>>result;\\n        if(interval.size()==0) return result ;\\n        sort(interval.begin(),interval.end());\\n        sort(newInterval.begin(),newInterval.end());\\n        result.push_back(interval[0]);\\n        int j=0;\\n        bool check=true;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            // if they are overlapping with new interval so include it \\n    \\n            if(result[j][1]>=newInterval[0] && check==true) {\\n                result[j][i]=max(result[j][1],newInterval[1]);\\n                   check=false;\\n                   i--;\\n            }           \\n             if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "Devanshul",
                        "content": " What is the problem with the following code? All the test cases are passed but still not able to submit. Why????? :\n\n    \n\n        int i_sz=intervals.size();\n        \n        for(int i=0;i<intervals.size();i++){\n            if(intervals[i][0]>newInterval[0]){\n                intervals.insert(intervals.begin()+i,newInterval);\n                break;\n            }\n        } \n        if(intervals.size()==i_sz){\n            intervals.push_back(newInterval);\n        }\n\n        for(int i=1;i<intervals.size();i++){\n            if(intervals[i-1][1] >= intervals[i][0]){\n                intervals[i-1][1] = max(intervals[i-1][1],intervals[i][1]);\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n        }\n\n        return intervals;      "
                    },
                    {
                        "username": "pijgom",
                        "content": "All the given data is in an  ascent order, using binary search find the new interval begin place and end place.I know the logic but so many boundaries or conditions to check. It ended up like costing me more than one hour :(\\nFeel bad about myself :( "
                    },
                    {
                        "username": "trifo75",
                        "content": "I am quite confused now. I thoght I  should not consolidate intervals this way. My code fails on this example, but I do not inderstand how the expected output come up.   Why should it be the solution?\\n\\nintervals =\\n[[1,5],[6,8]]\\nnewInterval =\\n[5,6]\\n130 / 156 testcases passed\\nOutput\\n[[1,5],[6,8]]\\nExpected\\n[[1,8]]"
                    },
                    {
                        "username": "user1395vo",
                        "content": "This is one of those problems that isn\\'t necessarily conceptually complex, but simply tedious. You can use the right data structures and hit the right time complexity, but may still fail numerous corner cases due to index mismanagement."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Explanatory video: https://youtu.be/b5Y4ipYjLkk"
                    }
                ]
            },
            {
                "id": 1761800,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761074,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761047,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1761039,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760766,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760764,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760746,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760741,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760739,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760738,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "Greedy tag should be mentioned in related topics for this question."
                    },
                    {
                        "username": "BristolJ",
                        "content": "This was surprisingly confusing and that made it hard for me"
                    },
                    {
                        "username": "Dhabot",
                        "content": "This was my first Daily Challenge. I almost arrived at proper solution but took a U turn and then exhausted myself finding alternation solutions for 3 hours. "
                    },
                    {
                        "username": "JuanQP",
                        "content": "Lots and lots of `if`s \\uD83E\\uDD2A"
                    },
                    {
                        "username": "sahle123",
                        "content": "I feel dumb. This one was surprisingly difficult."
                    },
                    {
                        "username": "milanthakor",
                        "content": "Finally!!!! After 3.25 hours and 3 incorrect submissions, I was to able to solve it with!! Although not the most efficient solution but still happy that implemented on it my own :). Good night!"
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone tell me why this works without a main method?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "LeetCode does not treat your solution like a complete program.  \\nInstead your solution and their tests get merged into a program which calls your functions.  \\nThat way you don\\'t have to read input and parse it, you can focus on the important parts."
                    },
                    {
                        "username": "Augus7",
                        "content": "can someone plz explain the problem "
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "You can look at my recent comment, sort by newest and go back a page."
                    },
                    {
                        "username": "jburkha3",
                        "content": "can someone explain to me how these solutions work without a main method?"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "They do things on the server-side, where it runs with a main method, that goes through all the test cases calling the code you provided. That\\'s why you can\\'t change the function name.\\n\\nI\\'m not sure because I don\\'t know. But that is the gist of it, because you can\\'t run code with e.g. `main` in Rust."
                    },
                    {
                        "username": "Yogin_Pahuja03",
                        "content": "case 146 is evil\\n"
                    }
                ]
            },
            {
                "id": 1760706,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760696,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760675,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760640,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760615,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760579,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760572,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760503,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760476,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760462,
                "content": [
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Help me debug this\ni don't what is the logical error, as when i try to debug it by printing the values\nthen after the if condition of last loop for first case it is becoming [1,9] don't know how?\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>>  ans=intervals;\n        int i=0,n=intervals.size(),flag=0;\n        for( i=0;i<n;i++)\n        {\n            if(ans[i][0]>newInterval[0])\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(flag==0)\n        {\n           ans.push_back(newInterval);\n        }\n        else\n        {\n            ans.insert(ans.begin()+i,newInterval);\n        }\n        for( i=1;i<ans.size();i++)\n        {\n            if(ans[i-1][1]>ans[i][0])\n            {\n                cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\n                cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n                vector<int> curr={min(intervals[i-1][0],intervals[i][0]),max(intervals[i-1][1],intervals[i][1])};\n               ans[i-1]=curr;\n                // cout<<ans[i-1][0]<<\" \"<<ans[i-1][1]<<endl;\n               ans.erase(ans.begin()+i);\n                i--;\n            }\n        }   \n        return ans;        \n    }\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There are two problems:\\n- This solution creates `ans` as a copy of the original `intervals` and then uses `ans` everywhere ... except when calling `min()` and `max()`. \\n- The second loop merges two intervals if the first one ends *after* the second one starts (`ans[i-1][1] > ans[i][0]`). But what if the first one ends exactly when the second one starts?"
                    },
                    {
                        "username": "audianu",
                        "content": "This problem is more focused on writing the code rather than thinking of any algorithm."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[][] insert(int[][] intervals, int[] newInterval) {\\n        List<int[]> ans = new ArrayList<>();\\n        int n = intervals.length;\\n        for (int i = 0; i < n; i++) {\\n            int[] curInterval = intervals[i];\\n            if (intervals[i][1] < newInterval[0]) {\\n               \\n                ans.add(intervals[i]);\\n            } else if (intervals[i][0] > newInterval[1]) {\\n                \\n                ans.add(newInterval);\\n                newInterval = intervals[i];\\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\\n                \\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\\n            }\\n        }\\n        // add the last interval\\n        ans.add(newInterval);\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}"
                    },
                    {
                        "username": "santanusen",
                        "content": "If in-place insertion seems complicated, try creating a separate array/vector for the result.\n\n1. From the beginning till we get an overlap, keep appending the intervals with end lesser than the current interval start to the result.\n2. Till we keep getting overlapping intervals, extend the new interval be extending it (reduce start and/or increase end) to cover the overlapping interval.\n3. Append the new interval to result.\n4. Keep appending the rest of the non-overlapping intervals with start more than the new interval end to the result."
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally a stop to tree problems.\n"
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "Okay, I think I get it after some consideration:\\n\\nYou are given a new interval to insert into the existing intervals. The intervals array is already sorted, so we just need to find the point of insertion.\\n\\nAdditionally, we need to merge the overlapping intervals, where:\\n> Intervals are considered overlapping if they share at least one common point in time. For example, the intervals [1,3] and [2,4] are overlapping because they both include the point in time 2.\\n\\nAs such, the problem statement is broken into two different operations:\\n1. Merge overlapping intervals\\n1. Insert the new interval in the already sorted array\\n    1. Such that the result is an array of sorted intervals."
                    },
                    {
                        "username": "1ncu804u",
                        "content": "not my day \\uD83D\\uDE16 edge cases killed me"
                    },
                    {
                        "username": "thePhoton",
                        "content": "I don\\'t know whether this question should belong to hard category or I am dumb :("
                    },
                    {
                        "username": "thePhoton",
                        "content": "[@rosie-i](/rosie-i) yes implementation is tough "
                    },
                    {
                        "username": "rosie-i",
                        "content": "I thought initially it looked really easy and then I realised it\\'s actually quite complicated to code! Sneaky question, you\\'re not dumb!"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "No sorting required to solve this problem.\\nThis medium-level question seems an Easy-level question after this approach in Java: https://youtu.be/oTw6eO9zYMQ"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "I wrote a stupid Heap + Stack Solution. Feels like cheating. Check it out:\\nhttps://leetcode.com/problems/insert-interval/solutions/3058844/heap-stack-cheat-solution-w-explanation/"
                    }
                ]
            },
            {
                "id": 1760439,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760396,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760374,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760368,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760298,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760264,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760221,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760218,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760194,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760172,
                "content": [
                    {
                        "username": "xhqwd159",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "Why not trees again haha??"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Over-lapping and non-overlapping intervals  problems..mark them as important!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Probably, one of the most asked question (variations)  in online coding tests..."
                    },
                    {
                        "username": "pawangupta",
                        "content": "Do remember to check for corner case that the intervals list can be empty also, before submitting the final solution.\\nInput\\nintervals = []\\nnewInterval = [5,7]"
                    },
                    {
                        "username": "qiushile",
                        "content": "We are finally out of the forest"
                    },
                    {
                        "username": "demenkov",
                        "content": "Where is tree? "
                    },
                    {
                        "username": "mdthabrez108",
                        "content": "tree week is over\\n"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "such a great relief to see other topic"
                    },
                    {
                        "username": "qiushile",
                        "content": "This problem took me 6 hours...TT"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@sarpalmadhav](/sarpalmadhav) nice strategic learning technique there... its good to start with basic problems of same kind."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@mkprajapati1614](/mkprajapati1614) Mee too, I took 2 hours but I think next time would be just 30 mins. Whenever I start flying higher, I\\'ll revisit such problems to humble myself \\uD83D\\uDE09"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "These tough times turns us into a better problem solver. \\nI also struggled for few hours and finally got it fixed up all by myself"
                    }
                ]
            },
            {
                "id": 1760159,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760145,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760138,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760100,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1760049,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759898,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759890,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759840,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759803,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            },
            {
                "id": 1759802,
                "content": [
                    {
                        "username": "olehn",
                        "content": "Please hold for a second and appreciate the Leetcode\\'s efforts that were recently put into fighting deforestation."
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "How to solve this problem using tree or graph ?? Anyone?"
                    },
                    {
                        "username": "akankshagupt_cs18",
                        "content": "using list"
                    },
                    {
                        "username": "Msey",
                        "content": "No trees?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "No more Trees\\uD83D\\uDE2D"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Biggest hints for this problem is testcases:\\nintervals = [[1,5]] newInterval = [0,0]\\nOutput = [[0,0],[1,5]]\\n\\nintervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] newInterval = [4,8]\\nOutput = [[1,2],[3,10],[12,16]]\\n\\nintervals = [[1,5]] newInterval = [6,8]\\nOutput = [[1,5],[6,8]]\\n\\nintervals = [] newInterval = [5,7]\\nOutput = [[5,7]]\\nComplete solution here: https://youtu.be/scIzz_H0MrA"
                    },
                    {
                        "username": "ravi183243",
                        "content": "I always get confused whether to use a dp or greedy to a particular problem as some problem statements are similar but the approaches are different. Some are solved by dp and other by greedy. So I think i found a little trick , given a problem statement try to first sort it by different parameters given in the question like startTime , endTime or some other and then try to see if you can find answer by greedy going through the sorted array , this is because all the greedy solutions requires some sort of sorting if it is not sorted already. If you can find a intuition or solve by greedy even after sorting then the problem is most likely an dp problem. Please comment what you think about this. Please upvote."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@ravi183243](/ravi183243) using the word 'sorted' is not correct. I think the best way to decide on DP/Greedy is the only way: the official way.. i.e see if picking the locally optimum solution hampers our ability of achieving globally optimum solution. If so then greedy is out, and then not much is left.. DP being one of the options, even in DP see if it is useful to memorize or not. Although lengthy,  DP chapter in CLRS is a pretty good foundation for these concepts. "
                    },
                    {
                        "username": "Peet_code",
                        "content": "Hope, It will help...\\n\\nHere 3 cases can be seen\\nCase 1. No overlapping intervals before given newInterval :- push into ans array\\nCase 2. Overlapping of intervals and newInterval :- update new interval starting point of newInterval will be min of the interval starting point or starting point of newInterval and Ending point will be max of newInterval end point or interval ending point.\\nCase 3. Non overlapping intervals after the newInterval has been merged :- push into ans array"
                    },
                    {
                        "username": "sanasdh",
                        "content": "is the graph war finally over?!"
                    },
                    {
                        "username": "saicremsi",
                        "content": "Final a problem on new topic seems pretty much interesting "
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Half way down the January road after passing the trees forest."
                    }
                ]
            }
        ]
    }
]